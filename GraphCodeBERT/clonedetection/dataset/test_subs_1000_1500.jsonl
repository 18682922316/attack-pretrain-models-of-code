{"id1": "17286898", "id2": "17792212", "code1": "                public void run() {\n                    BufferedReader reader = null;\n                    String message = null;\n                    int messageStyle = SWT.ICON_WARNING;\n                    try {\n                        URL url = new URL(Version.LATEST_VERSION_URL);\n                        URLConnection conn = url.openConnection();\n                        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                        String latestVersion = reader.readLine();\n                        latestVersion = latestVersion.substring(latestVersion.indexOf(' ') + 1);\n                        if (!Version.getVersion().equals(latestVersion)) {\n                            message = Labels.getLabel(\"text.version.old\");\n                            message = message.replaceFirst(\"%LATEST\", latestVersion);\n                            message = message.replaceFirst(\"%VERSION\", Version.getVersion());\n                            messageStyle = SWT.ICON_QUESTION | SWT.YES | SWT.NO;\n                        } else {\n                            message = Labels.getLabel(\"text.version.latest\");\n                            messageStyle = SWT.ICON_INFORMATION;\n                        }\n                    } catch (Exception e) {\n                        message = Labels.getLabel(\"exception.UserErrorException.version.latestFailed\");\n                        Logger.getLogger(getClass().getName()).log(Level.WARNING, message, e);\n                    } finally {\n                        try {\n                            if (reader != null) reader.close();\n                        } catch (IOException e) {\n                        }\n                        final String messageToShow = message;\n                        final int messageStyleToShow = messageStyle;\n                        Display.getDefault().asyncExec(new Runnable() {\n\n                            public void run() {\n                                statusBar.setStatusText(null);\n                                MessageBox messageBox = new MessageBox(statusBar.getShell(), messageStyleToShow);\n                                messageBox.setText(Version.getFullName());\n                                messageBox.setMessage(messageToShow);\n                                if (messageBox.open() == SWT.YES) {\n                                    BrowserLauncher.openURL(Version.DOWNLOAD_URL);\n                                }\n                            }\n                        });\n                    }\n                }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"run": ["name", "execute", "apply", "def", "task", "begin", "process", "job", "runs", "log", "Run", "func", "function", "build", "ran", "fun", "call", "exit", "sync", "status", "thread", "play", "loop", "un", "work", "get", "running", "block", "exec", "render", "runner", "show", "pass", "handle"], "reader": ["iterator", "READ", "liner", "writer", "older", "reading", "inner", "stream", "rs", "loader", "r", "entry", "rr", "rx", "redo", "layer", "file", "source", "query", "buffer", "holder", "resource", "read", "parser", "builder", "rar", "io", "context", "handler", "uri", "rows", "peer", "ner", "body", "rl", "Reader", "er", "ro", "client", "upper", "iter", "mr", "rc", "lr", "connection", "row", "runner", "readable", "input", "dd", "rot"], "message": ["sequence", "metadata", "html", "Message", "subject", "content", "number", "success", "question", "warning", "trace", "mess", "hash", "text", "essage", "definition", "license", "field", "show", "document", "msg", "version", "notice", "title", "menu", "location", "maximum", "reason", "error", "result", "m", "mode", "report", "body", "language", "summary", "address", "position", "request", "flash", "style", "mail", "attribute", "response", "view", "where", "memory", "expression", "value", "hello", "template", "translation", "password", "comment", "base", "time", "command", "module", "print", "missing", "image", "string", "description", "label", "log", "minimum", "email", "media", "application", "status", "console", "code", "phrase", "note", "format"], "messageStyle": ["maximumStyle", " messageType", "MessageStyle", "maximumTheme", "sequenceSty", "sequenceColor", "displaystyle", "Messagestyle", "MessageTheme", "maximumSty", " messageColor", "minimumstyle", "minimumStyle", "displayStyle", "metadataWeight", "sequenceStyle", "documentSty", "MessageSty", "messageWeight", " messagestyle", "messageSty", "messageTheme", "maximumType", "displayWeight", "minimumSty", "metadatastyle", " messageWeight", "messagestyle", "messageColor", "sequencestyle", "displayTheme", "messageType", "documentStyle", " messageTheme", " messageSty", "metadataStyle", "minimumColor", "MessageType", "documentType", "metadataTheme", "documentstyle"], "url": ["Url", "name", "link", "server", "cert", "socket", "loader", "r", "mount", "lb", "b", "ssl", "resource", "host", "bel", "f", "dl", "base", "uri", "http", "nl", "rl", "str", "ll", "browser", "address", "https", "loc", "rel", "l", "open", "client", "con", "connection", "URL", "ls", "ur", "cp"], "conn": ["Connection", "obj", "ch", "cert", "ws", "socket", "addr", "comm", "cb", "cc", "enc", "loader", "nt", "ait", "ns", "connect", "cmd", "conv", "iw", "c", "res", "nc", "cur", "out", "l", "client", "con", "connection", "Conn", "net", "ls", "ct", "cp", "handle", "cn"], "latestVersion": ["highestKey", "olderVer", "largestKey", "oldVer", "largestValue", "latestPoint", "uniqueLine", "lastOne", "highestPoint", "latestUrl", "largestVer", "highestVersion", "uniqueValue", "stableOne", "finalVer", "latestLine", "oldVersion", "lastString", " latestKey", "olderVERSION", "finalPoint", "releasedVersion", "largestLine", "largestString", "releasedVer", "releasedOne", " latestVERSION", "largestUrl", "oldLine", "latestString", "highestValue", " latestVer", "oldValue", "oldVERSION", "lastVersion", "oldPoint", "stableVersion", "latestVer", "latestKey", "lastValue", " latestLine", "uniqueUrl", "finalValue", "largestVersion", "stableVer", "olderVersion", "latestVERSION", " latestValue", "highestVer", "finalVersion", "olderLine", "latestValue", "lastVer", "releasedVERSION", " latestUrl", "latestOne", "lastVERSION", "highestString", "uniqueVersion", "stableVERSION"], "messageToShow": ["messageTODisplay", "messageToshow", "commandToSh", "commandtoShow", "messageTOShow", "MessageToShow", "messageWillSee", "messagetoShow", "messagetoSh", "MessageTODisplay", "messageToDisplay", "commandtoSee", "commandToSee", "messageToSee", "message2Display", "message2show", "commandtoSh", "messageTOshow", "messagetoSee", "MessageToshow", "MessageToDisplay", "messageWillShow", "messageToSh", "message2Show", "messageWillSh", "MessageTOshow", "MessageTOShow", "commandToShow"], "messageStyleToShow": ["messageStyletoShow", "messageSizeTOshow", "messageStyleTOFind", "messageStyleTypeUse", "messageTypeToshow", "messageStyletoshow", "messageTypeTOshow", "messageStyleetoShow", "messageSizeTOShow", "messageTypeToShow", "messageTypeTODisplay", "messageSizeToDisplay", "messageTypeToUse", "messageStyleTOUse", "messageStyleToUse", "messageTypeTOShow", "messageStyleetoshow", "messageTypeToDisplay", "messageSizeToshow", "messageStyleToshow", "messageSizeTOFind", "messageStyletoUse", "messageStyleTypeDisplay", "messageTypeTOUse", "messageStyleTypeShow", "messageStyletoDisplay", "messageStyleetoFind", "messageStyleTOshow", "messageStyleTypeshow", "messageStyleetoDisplay", "messageSizeTODisplay", "messageStyleTODisplay", "messageStyleToFind", "messageStyleTOShow", "messageStyleToDisplay", "messageStyletoFind", "messageSizeToShow", "messageSizeToFind"], "messageBox": ["consoleBox", "descriptionBOX", "MessageRoot", "msgBOX", "statusBox", "messageLabel", " messageRoot", "msgLabel", "messageBOX", "descriptionSet", "createBox", "msgPanel", " messagebox", " messageBOX", "messageSet", " messagePanel", "Messagebox", "consoleArea", "statusBOX", "createRoot", "MessageBox", "messageArea", "msgBox", "createbox", "statusLabel", "messageBar", " messageLabel", "statusSet", " messageBar", "MessageArea", "descriptionBox", "consolebox", "consoleBar", " messageArea", "MessageBar", " messageSet", "statusPanel", "messagebox", "descriptionPanel", "messageRoot", "messagePanel"]}}
{"id1": "9805906", "id2": "2642914", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"dump": [" show", "zip", "link", "println", "stat", "init", " println", " debug", "display", "info", "copy", "flush", "download", "update", "debug", "read", "export", " dumps", "save", "send", "store", "load", " describe", "write", "show", "diff", "print", " dumped"], "source": ["remote", "Source", "sequence", "view", "origin", "parent", "init", "image", "shell", "select", "ource", "scope", "src", "se", "sample", "info", "copy", "file", "config", "start", "sys", "resource", "local", "template", "from", "search", "site", "java", "form", "sql", "store", "service", "check", "text", "spec", "iter", "input", "ie", "script", "ink", "SOURCE", "style"], "target": ["delete", "link", "it", "pattern", "replace", "dest", "current", "bolt", "arg", "copy", "mac", "Target", "file", "goal", "compatible", "host", "arget", "next", "local", "that", "template", "match", "gt", "top", "project", "base", "t", "test", "proxy", "table", "output", "tif", "term", "null", "to", "style"], "is": ["tis", "im", "bits", "are", "ib", "ri", "ois", "ip", "init", "it", "iss", "act", "si", "isin", "mos", "isa", "sis", "iso", "Is", "isf", "i", "ys", "sys", "ris", "ir", "es", "IS", "xs", "abs", "bis", "its", "ic", "in", "ios", "isl", "ims", "ins", "ms", "has", "ists", "ais", "iris", "ai", "s", "isc", "oss", "ics", "isi", "ls", "ist", "ar", "nis", "lis", "ii"], "os": ["bos", "obs", "oes", "cs", "ose", "Os", "ols", "css", "ts", "bs", "uts", "oS", "ps", "ox", "ds", "mos", "aos", "ns", "ants", "ost", "pos", "sys", "cos", "io", "ss", "OS", "es", "fs", "osi", "ot", "or", "ios", "nos", "o", "oses", "los", "dos", "s", "oss", "ros", "js", "outs", "ows", "ls", "oos"], "done": ["loaded", "disabled", "die", "enabled", "created", "continue", "progress", "flag", "given", "de", "Done", "di", "ded", "checked", "later", "filled", "complete", "needed", "only", "shown", "ished", "valid", "du", "led", "set", "seen", "dirty", "started", "d", "des", "finished", "made", " Done", "expected", "pleted", "did", " continued", "gone", "desc", "failed", "found"]}}
{"id1": "838844", "id2": "12766394", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "conVERT", "consvert", "CONversion", "conversion", "unfer", "converted", "compvert", "compversion", "consversion", "compverts", "Converted", "unversion", "converting", "CONverted", "CONfer", "unvert", "converts", "consVERT", "Conversion", "CONverting", "conprocess", "ConVERT", "CONVERT", "CONvert", "consverting", "Confer", "unverted", "confer", "Conprocess", "unverts", "compprocess", "Convert", "Converts", "unprocess"], "src": ["Source", "scan", "url", "hl", "path", "orig", "attr", "sq", "inst", "addr", "cc", "sin", "rs", "stream", "ource", "href", "sr", "rx", "file", "config", "source", "ebin", "start", "filename", "sys", "SourceFile", "sit", "ipl", "host", "func", "RC", "scene", "iv", "txt", "from", "cont", "uri", "http", "its", "st", "str", "ser", "ins", "cur", "img", "loc", "rel", "usr", "pkg", "buster", "sc", "ur", "req", "rc", "s", "dist", "input", "SOURCE", "rest", "upload"], "dest": ["port", " destinations", "orig", "est", "Dest", "mat", " Destination", "target", "temp", " orig", "source", " destination", "gin", "dat", "result", "txt", " dst", " Dest", "img", "test", "foreign", "write", "table", "tif", "disk", "dir", "dist", "rest"], "in": ["inn", "up", "is", "inner", "stream", "isin", "r", "din", "file", "source", "b", "bin", "i", "io", "serv", "ad", "ar", "m", "from", "res", "In", "el", "sql", "st", "ins", "en", "IN", "d", "l", "input", "cin", "rin", "reader", "as", "inf", "ind"], "p": ["fp", "pc", "php", "pl", "pp", "per", "it", "part", "g", "ps", "r", "pro", "py", "pg", "vp", "b", "ph", "i", "h", "ap", "parser", "P", "parse", "j", "pa", "pd", "f", "m", "lp", "c", "ping", "rep", "pm", "post", "prot", "op", "t", "pre", "er", "pers", "at", "jp", "dp", "d", "pb", "l", "pkg", "wp", "pt", "pi", "sp", "cp", "pe", "tp"], "ds": ["cs", " os", "ports", "drivers", "dh", " ads", "ss", "scripts", "di", "dates", "edes", "sts", " d", "tests", "nas", "dds", "aws", "hd", "obs", "posts", "bs", "rs", "cks", "DS", "ys", "uds", " dd", "eds", "its", "vs", "dp", "d", "os", "terms", "outs", "qs", "dd", "pd", "tp", "ras", "ts", "ods", "Ds", "tes", " DS", "ps", "points", "ils", "gs", "amps", "docs", "xs", "ands", " des", "workers", "lists", "ads", "des", "db", "eps", "dos", "iffs", "dt", "js", "ks", "ls", "mys", "yes", "ws", "gd", "ats", "els", "sets", "ns", "sd", "tags", "loads", "dl", "ags", "s", "hs", "df"], "format": ["name", "unit", "lat", "path", "shape", "version", "it", "settings", "mat", "pattern", "act", "fm", "MAT", "ats", "title", "file", "source", "layout", "parse", "sche", "template", "top", "id", "fc", "f", " Format", "type", "mode", "status", "form", "tag", "feature", "set", "t", "spec", "at", "cf", "table", "output", "module", "l", "policy", "feat", "size", "pretty", "pi", "filter", "mt", "ct", "style", "Format"], "hasPixelData": ["haspixelDATA", "hasFramedata", "HaspixelData", "hasixelData", "hasPixeldata", "hasixelDATA", "hasFrameDATA", "hasFrameData", " hasPixelDATA", "HasPixelDATA", "hasPixelDATA", "HasPixelData", "HaspixelDATA", "haspixeldata", "Haspixeldata", "HasPixeldata", " hasPixeldata", "hasixeldata", "haspixelData"], "inflate": ["Informate", "inFlocate", "informate", "invalidocate", " invalidATE", "inflATE", "inflated", "informated", "inFLated", "infolat", "incelicate", "inFlATE", "informat", "Inflat", "infolated", "invalidicate", "inFLat", "informocate", "incelocate", "Inflocate", "inFlate", "Informocate", "inFLocate", "incelate", "inflocate", "invalidate", "inFLate", " inflocate", "infolate", "inflicate", "invalidATE", "infolocate", "inFlicate", "Informated", " invalidicate", "Inflated", " invalidate", "incelATE", "inflat", " invalidocate", "Inflate", " inflicate", " inflATE", "Informat"], "pxlen": ["packls", "mxdec", "pexlen", "packln", "pxls", "pexfun", "xpden", "mxln", "phpdec", "tmpln", "pxden", "mxlength", "mmlen", "xyln", "mmln", "phpln", "pixellength", "pxdec", "xplen", "pixells", "pexln", "tmplength", "xylength", "cpden", "pxlin", "tmplin", "mmlength", "phplength", "pixelfun", "xylin", "cplength", "mmlin", "packdec", "pxln", "pexlength", "xylen", "tmplen", "xplength", "pxfun", "phplen", "mxlen", "pxlength", "pexls", "pexden", "pixellen", "packlen", "xpln", "packfun", "cplen", "cpln", "packlength"], "out": ["name", "msg", "obj", "group", "up", "conn", "ln", "init", "writer", "gov", "inv", "Out", "ex", "aos", "outer", "temp", "cmd", "log", "err", "sys", "io", "inter", "user", "crit", "res", "cfg", "sum", "store", "prefix", "client", "output", "dir", "gr", "list", "outs", "OUT", "screen", "net", "pretty", "print", "ou"]}}
{"id1": "6966398", "id2": "1180878", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"reader": [" readers", "ri", "rer", "writer", "older", "this", "rs", "stream", "inner", "ocr", "loader", "r", "rr", "sr", "rx", "redo", "file", "query", "buffer", "builder", "read", "parser", "io", "rar", "cer", " read", "roller", "handler", "driver", "ner", "rl", "Reader", "er", "ro", "iter", "mr", "rc", "lr", "row", "runner", "input", "rot", "dr", "wrapper"], "ks": ["KS", "ls", "ces", "obs", "cs", "kies", "uk", "icks", "ols", "ips", "bs", "sk", "cks", "ars", "ds", "ck", "kk", "ups", "eks", "agles", "ys", "k", "keys", "ss", "uds", "nets", "kas", "ses", "ans", "fs", "km", "ms", "ki", "vs", "kb", "eps", "akes", "kes", "ke", "oss", "ros", "checks", "qs", "ates", "hs", "kens", "mk", "kr", "sky"], "key": ["link", "obj", "mk", "power", "x", "ssh", "char", "sk", "ox", "info", "entry", "file", "k", "keys", "KEY", "user", "root", "password", "cer", "Key", "base", "type", "sign", "y", "object", "service", "ey", "hash", "er", "by", "client", "ke", "null", "core", "ek", "ca", "my", "trust", "pair", "tk", "sky", "owner"], "chain": ["sequence", "cache", "group", "path", "string", "ver", "pool", "stream", "stack", "number", "file", "channel", "sche", "bank", "Chain", "data", "root", "password", "box", "pair", "result", "batch", "base", "c", "type", "trace", "form", "frame", "range", "check", "hash", "piece", "code", "binary", "test", "table", "component", "family", "block", "chains", "ca", "list", "ce", "sign", "can"], "os": ["bos", "oes", "obs", "cs", "ose", "Os", "ols", "is", "ts", "css", "bs", "uts", "oS", "ps", "ox", "ds", "aos", "oso", "pos", "sys", "cos", "ys", "io", "OS", "osi", "fs", "oids", "ot", "ops", "ios", "ms", "us", "out", "o", "oses", "los", "oss", "js", "ls", "oos"], "stamper": [" stamter", " stummer", "stimper", " stramper", "stramPER", " stamPER", "stumter", "println", " stramPER", " stumter", "New", "annot", "def", "this", "stumper", "stamPER", " stammer", " stumpler", " stimmer", "stAmper", "stumpler", "important", "read", "stamter", "stAmmer", "stammer", "stAmpler", "stAmPER", " strampler", "Print", " stampler", "The", "strampler", "stampler", " stcampler", " strammer", "good", "_", "valid", "font", " stumper", " stcammer", "stimmer", "stummer", " stimper", "stramper", "stimPER", " stimter", " stcamter", " stimpler", "stimpler", "strammer", " stcamper"], "appearance": ["displayeared", "acreciation", "ascearance", "apeared", "appendix", "atteared", "Appearance", "displaylies", "acearance", "accears", " appearing", "Appeared", "acclies", "aplies", "displayearing", "displayendix", "appearing", "accearance", "applies", "displayearance", "attearance", "appearances", "attlies", " appendix", "aceared", "displayearances", "apearances", "displayears", "Applies", "apearance", "suppeared", "appears", "accearances", "ascearances", " appeared", "appreciation", "ascears", "Appearances", "acearances", "apreciation", "apearing", "ascearing", "suppearances", " appearances", "patternendix", "suppearance", "displayreciation", "appeared", "attearances", "apears", "patternearing", "patternearance", "patternearances"]}}
{"id1": "7351534", "id2": "4593012", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromSysIdentifiers", "getStreamFromSystemidentifer", "getStreamFromSysIdentifier", "getStreamFromSystemIdentifer", "getStreamFromSystemIdifier", "getStreamFromSysidentification", "getStreamFromSysIdentification", "getStreamFromSystemIdifiers", "getStreamFromSystemidentifier", "getStreamFromSystemidentification", "getStreamFromSystemIdifer", "getStreamFromSysidentifer", "getStreamFromSysIdentifer", "getStreamFromSystemIdentification", "getStreamFromSystemIdification", "getStreamFromSystemidentifiers", "getStreamFromSystemIdentifiers", "getStreamFromSysidentifiers", "getStreamFromSysidentifier"], "systemId": ["localhostMid", "sysIs", "systemid", "ystemid", "humanById", "serverIn", "systemIs", "humanId", " systemMid", "serverById", "systemName", " systemName", "cmsId", "localhostId", "ystemById", "ystemIn", "ystemId", "systemMid", "serverid", "publicName", "systemID", "publicid", "publicId", "ystemMid", "systemDoes", "serverId", "sysID", "cmsDoes", "ystemName", "humanMid", "humanDoes", "publicMid", " systemById", "sysId", "humanStart", "cmsMid", "humanID", "publicIn", "systemStart", "localhostStart", "publicById", "localhostDoes", "cmsStart", "ystemIs", "sysById", "systemById", "humanIs", "systemIn", "ystemID"], "resolver": ["rsolver", " resanger", "reserver", "reolving", "reolution", "rserver", " resolved", "resolution", "persolver", "reslove", "resolutionolver", "reolve", "perslove", "rsolution", "reolved", "resanger", " resolve", " resolution", "persolved", "resolve", "reanger", "rsanger", "resolutionolution", "persolve", " reserver", "reolver", "reerver", "resolutionolving", "resolved", "resolving", "relove", "persolving", "persolution", "resolutionlove"], "source": ["remote", "Source", "iterator", "attribute", "sequence", "cause", "unit", "response", "origin", "parent", "init", "image", "system", "shell", "string", "inner", "ource", "src", "scope", "subject", "sample", "via", "copy", "se", "target", "series", "node", "file", "resource", "context", "channel", "local", "template", "result", "base", "storage", "from", "uri", "force", "site", "peer", "status", "instance", "sql", "store", "object", "console", "service", "ser", "create", "spec", "rule", "relation", "seed", "supp", "proxy", "component", "table", "get", "null", "input", "ce", "sp", "missing", "SOURCE", "reader", "style", "raw"], "stream": ["port", "sequence", "cache", "our", "content", "mount", "buffer", "channel", "data", "export", "cont", "Stream", "valid", "form", "ream", "input", "upload", "shape", "clean", "pool", "message", "sample", "stack", "download", "REAM", "progress", "resource", "read", "result", "sw", "sync", "http", "poll", "body", "impl", "proc", "hold", "row", "control", "response", "present", "pipe", "ssl", "batch", "peer", "object", "chain", "out", "load", "loop", "test", "length", "output", "null", "trans", "window", "wrapper", "encrypted", "iterator", "zip", "socket", "temp", "feed", "file", "log", "next", "complete", "pod", "instance", "console", "open", "reader"], "url": ["mail", "Url", "link", "hl", "external", "key", "system", "back", "char", "ret", "r", "job", "mount", "location", "b", "gl", "ssl", "resource", "build", "bel", "f", "dl", "uri", "web", "http", "sl", "nl", "rl", "service", "ll", "browser", "address", "ref", "rel", "l", "term", "null", "URL", "ls", "ur", "window", "ul"]}}
{"id1": "4593011", "id2": "9647576", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"loadDDL": ["readDDL", "loadSDL", "loadDSLS", "readDDDL", "readPDl", "loadSDLS", "loadSDDL", "loadDSl", "loadDDl", "loadPDl", "loadSDl", "readPDLS", "loadPDLS", "loadDDLS", "loadDDDL", "readPDDL", "readDDl", "readDDLS", "loadPDDL", "loadPDL", "loadDSDL", "loadDSL", "readPDL"], "stmt": ["Stm", "stpt", "sttx", "stemt", "stMT", " stpt", " stmn", " superstmt", "stmm", "STm", "steMT", "stmb", "tMT", "Stdo", "strMT", " Stmt", "STMT", "Stmm", "Sttr", " StMT", " stm", " superstm", "strmn", "tmt", "stdo", "stem", "Stmn", " superstMT", "Sttx", "strmb", "STmt", "ttr", "stedo", " superstpt", "STtx", " stmm", " sttx", "tmm", " sttr", "strmt", " stMT", " Stpt", "Stmt", "StMT", "sttr", " stdo", "stmn", "Stmb", "stm", " Stm", " stmb"], "qry": ["sqries", "quries", "qury", "qutry", "Qries", "qries", " qries", "qtry", "quri", "Qrys", "Qri", " qtry", "qrys", "Qry", " qri", "sqrys", "sqtry", "sqri", "sqry", " qrys", "qri"], "q": [" sq", "p", "sq", "qu", "qt", "g", "v", "w", "u", "e", "query", "i", "h", "k", "j", "ql", "ry", "f", "m", "c", "qq", "Q", "y", "qi", "t", "qv", "o", "d", "pkg", "l", "dq", "z", "qa", "qs", "quest", "iq", "n"]}}
{"id1": "335223", "id2": "21425787", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewrites", "readAndrewWrite", "readAndReprites", "readAndResWrite", "readAndResend", "readAndReprite", "readAndResrites", "readAndrewrites", "readAndRepWrite", "readAndrewend", "readAndRewWrite", "readAndResrite", "readAndRepend", "readAndRewend", "readAndrewrite"], "inFile": [" inFilename", "outFilename", "InFile", "outfile", "inTime", "INTime", "inputPlace", "inFace", "INFILE", "initPlace", " infile", "docFILE", "initFilename", "inFilename", "inputFilename", "iTime", "INFile", "initFace", "INFace", "InFilename", "iFILE", "Infile", "infile", "INPlace", "docFilename", "docFile", "inputFile", "INFilename", "inPlace", "iFile", "docTime", "iFilename", "initFile", "inFILE", "inputFace"], "outFile": [" outFILE", "outFilename", "reportFile", "outfile", "reportFILE", "nameFile", "nameFilename", "checkfile", "toFile", "inFilename", " outFilename", "reportfile", "checkFile", "nameFILE", "checkFILE", "checkFilename", "reportFilename", "infile", "toFilename", "outFILE", "toFILE", "namefile", "tofile", " outfile", "inFILE"], "iis": ["diIs", " iisc", " iIS", "IIs", "Ii", "eis", "liIs", "diiss", " ii", "iisc", "dii", "liisc", " iIs", " iiss", "Iis", "iIs", "iiss", "liis", "aiis", "iiris", "aiIS", "Iiss", "iiIs", "aiIs", "iris", "iiisc", "liris", " iris", "eIS", "iiis", "eIs", "diis", "iIS", "ii"], "dcmParser": ["dpmStatement", " dcmLoader", "dmmparser", "DpmParser", "DpmReader", "dpmPar", "dmmmParser", "decmarser", "Dpmparser", "dfmLoader", "dmmReader", " dpmarser", "decmReader", "DcmReader", "dcommParser", "dpmParser", "dpmPrivate", " dcmAssistant", " dpmparser", "deromReader", "dmReader", "dcfStatement", "deromParser", " dpmAssistant", "DcmBuilder", "DcmAdapter", "dcomBuilder", "deromarser", " dpmParser", " dpmPrivate", " dcmStatement", "dmarser", "dcrparser", "dcomLoader", "dromReader", "dmmarser", "dmmParser", "dmmmparser", "dcomParser", "dcfReader", "dpmBuilder", "dgrPar", "dpmReader", "dromparser", "dcmStatement", "dcmPrivate", " dpmListener", " dpmStatement", "dmparser", "dpmLoader", "dfmReader", "drumPar", "dpmListener", " dcmarser", "dfmParser", "Dcmparser", "dgrReader", "dcmAdapter", "dmoduleAssistant", "dmmAdapter", "DcmPar", "dcmLoader", "dromListener", "dpcParser", "dpcReader", "dcrBuilder", " dcmReader", "dromarser", "dfmBuilder", "DpmBuilder", " dcmparser", "dpcAssistant", "dcmPar", "dcommListener", " dcmPrivate", " dcmBuilder", "decmParser", "dgrStatement", "decmparser", "dcmAssistant", "drumBuilder", "dcmListener", "dcommReader", "DcmParser", " dpmPar", "drumReader", " dpmLoader", "dmParser", "dcmReader", " dcmListener", "dcommAssistant", "dmodulePrivate", " dcmPar", "DpmAdapter", "dcomReader", "dcmarser", "dgrParser", "dpmparser", "dmmmReader", "dromParser", "DpmPar", "dpmAssistant", "dcfParser", "dcrParser", "dpmAdapter", "dromAssistant", "drumParser", " dpmBuilder", " dpmReader", "dpmarser", "dcfPar", "deromparser", "dpcPrivate", "dmoduleReader", "dmoduleParser", "dmmmAdapter", "dcmparser", "dcmBuilder", "dcrReader"], "ds": ["obs", "cs", "ws", "gd", "bs", "ods", "Ds", "rs", "tes", " DS", "ps", "drivers", "sets", "dh", "ns", "aos", "dx", "der", "DS", "hd", "bd", "sys", "ys", "ils", "gs", "sd", "dat", "ss", "es", "data", "uds", "xs", " des", "sv", "dl", "fs", "services", "ads", "eds", "its", "details", "in", "da", "ims", "ins", "dds", "pers", "vs", "d", "des", "db", "eps", "dos", "os", "dt", "s", "dq", "js", "outs", "qs", "dd", "hs", "ks", "ls", "as", "df", "pd"], "pdReader": ["vdWriter", "pedRunner", "xdHelper", "ddHelper", "tdParser", "pdParser", "dpLoader", "pdCar", "ddParser", "ddRunner", "vdReader", "pedReader", "pdRunner", "pdHelper", "ddLoader", "pedLoader", "pdLoader", "ddRead", "ddWriter", "hdReader", "dpReader", "ddReader", "vdHelper", "pedCar", "pdRead", "tdRead", "hdWriter", "xdReader", "xdLoader", "xdWriter", "dpRunner", "vdLoader", "ddCar", "dpCar", "hdRead", "hdParser", "tdWriter", "tdReader"], "out": ["obj", "cache", "conn", "p", "Out", "ex", "v", "cmd", "pos", "io", "one", "data", "res", "in", "str", "end", "list", "name", "auto", "msg", " err", "full", "writer", "cb", "inv", "pool", "opt", "on", "sw", "cfg", "we", "at", "gr", "os", "con", "oss", "outs", "screen", "OUT", "net", "raw", "cn", "up", "nt", "w", "outer", "ent", "all", "nr", "err", "tmp", "conv", "gt", "gen", "id", "c", "sum", "ins", "o", "output", "null", "co", "js", "desc", "ou", "go", "ch", "it", "inner", "aos", "flush", "sys", "log", "serv", "inter", "txt", "status", "t", "en", "client", "s", "to", "over", "n"], "dcmEncParam": ["dcmencMsg", "dmmencMsg", "dmmEncPar", "dmmEnNum", "dmmencNum", "dmmEncParam", "dcmEncVal", "dmmEnParam", "dcmEscNum", "dmmEncMsg", "dmmEnPar", "dcmDecCmd", "dcmEnParam", "dcmencParam", "dcmencPar", "dcmDecMsg", "dcmEnPar", "dcmDecParam", "dcmEscVal", "dcmEnNum", "dcmEncPar", "dmmencCmd", "dcmencCmd", "dmmEncVal", "dcmEnVal", "dcmencNum", "dcmDecNum", "dcmEncNum", "dcmEncMsg", "dmmEncNum", "dmmEncCmd", "dcmEscParam", "dcmEncCmd", "dcmEscPar", "dmmencParam"], "pdWriter": ["PDEditor", "pcWriter", "tdWriter", "dpEditor", "PDReader", "PDWrite", "pdWrite", "pidWriting", "PDWriter", "pdwriter", "dpReader", "dpWriter", "tdEditor", "pdEditor", "pidWriter", "pcWrite", "pcWriting", "pcwriter", "dpWrite", "pidwriter", "tdWriting", "tdwriter", "pidWrite", "pdWriting", "tdWrite", "tdReader"]}}
{"id1": "17724879", "id2": "6159896", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"getDigest": [" getMDEST", " getDigEST", "getHashest", "getdigse", " getDigested", "getdigEST", "getDigEST", "getMDest", "getMDse", " getDigse", "getHashse", " getMDest", " getMDse", "getDigse", "getDigested", "getHashEST", "getHashested", "getdigest", " getMDested", "getMDested", "getMDEST", "getdigested"], "attribute": ["name", "character", "al", "metadata", "option", "attr", "each", "and", "operator", "description", "a", "message", "subject", "add", "entry", "member", "expression", "management", "associated", "article", "argument", "value", "event", "variable", "missing", "ribute", "property", "information", "Attribute", "data", "reference", "password", "pair", "application", "type", "qualified", "space", "report", "communication", "command", "object", "item", "address", "element", "at", "relation", "definition", "policy", "word", "position", "request", "input", "operation", "att", "document", "ident", "directory"], "digestAlgorithm": ["digestPalgorithm", "digestSchego", "digestAlgorith", "digestAlgebra", "digestalgorithm", "digestsAlgo", "digesteralgo", "digesterAlgebra", "digestsalgo", "digestSchegorithm", "digesterAlgorithm", "digestPalgo", "digestalgo", "digestALgorithm", "digestsAlgebra", "digesteralgebra", "digesterAlgorith", "digestALgorith", "digesteralgorithm", "digestalgebra", "digestsalgebra", "digestsAlgorithm", "digestAlgo", "digestalgorith", "digesteralgorith", "digestPalgebra", "digestALgo", "digesterAlgo", "digestALgebra", "digestsalgorithm", "digestSchegebra", "digestPalgorith"], "digest": ["designist", "Digest", "diagnested", "mditude", "digend", "digtest", " digist", "hashend", " digested", "digitude", "equested", "equEST", "designEST", "hashested", "mdest", "hashest", "diagnitude", "digse", "digests", "Digist", " digitude", " digse", "digested", "Digse", "Digtest", "Digend", " digtest", " digests", " digEST", "digEST", "hashEST", "designests", "DigEST", "Digests", "equend", "digist", "designest", "Digested", "equest", "mdse", "diagnest", "diagnse", "mdtest", "mdested"], "md": ["sm", "metadata", "amd", "mt", "wd", "cd", "mb", "MD", "nt", "dm", "dh", "ds", "mm", "der", "mac", "cmd", "managed", "hd", "ind", "grad", "bd", "sd", "mod", "esm", "di", "ld", "rpm", "m", "mind", "det", "pdf", "fd", "pm", "good", "rm", "cond", "mg", "ms", "red", "mn", "d", "nd", "met", "pt", "ma", "ud", "strong", "js", "dd", "mc", "dr", "ct", "mk", "df", "pd"]}}
{"id1": "15904772", "id2": "6756635", "code1": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"getSystemStateHash": ["getSystemRandomhash", "getSysStateSalt", "getSystemStatesSalt", "getSystemStatesKey", "getSysStatehash", "getSystemRandomKey", "getSysStateKey", "getSysStateshash", "getSystemLocalHash", "getSysStatesKey", "getSysStatesSalt", "getSystemLocalhash", "getSystemLocalSalt", "getSystemLocalKey", "getSysStatesHash", "getSystemStatesHash", "getSystemStateSalt", "getSystemRandomSalt", "getSystemStateshash", "getSystemStateKey", "getSystemRandomHash", "getSystemStatehash", "getSysStateHash"], "sha1": ["sh384", "sh01", " SHA11", "sh8", "sche4", "ha4", "ka3", "ppa1", "ka11", "no01", "shache", "SHAone", "sha384", "ssh6", "haache", "shaone", "sh11", "ssh8", "ha01", "sche1", "ka001", "sha11", "shape1", "ppa01", "sche9", "ha384", "sche51", "shake7", "sh64", "wa3", "sche256", "wa1", "shacy", "shake1", "tar1", "shape51", "sh61", "sh256", "tar384", "tarache", "sh81", "sche7", "ha7", "shone", "sh1", "sha001", "ami7", "sha100", "ka01", "sche11", "SHA1", "shaOne", "ppaache", "tar3", "ka1", "sha3", "shapeache", "ha100", "ssh1", "shaacy", "sche8", " SHA001", "ha51", "sh0", "sche0", "ha2", "sha8", "sh6", "ssh81", "sha6", "scheOne", "sha7", "scheache", "shake64", "ha64", "sche61", "SHA2", "sche100", "haacy", "ha11", "ppa100", "sha81", "ha256", "sche2", "ha3", "shake61", "ha1", "sche3", "ha6", "sh4", "sche64", "shOne", "sh9", "sha51", "sh2", "no3", "ha8", "haone", "sha01", " SHA1", "sha4", "ka81", "sh100", "amiacy", "ami1", "sha64", "tar7", "ha9", "tar01", "haOne", "sh3", "no1", "sha61", "ha81", "waone", "sche81", "tar100", "ha0", "sh7", "sche6", "no81", "sha0", "sha2", "SHA3", "ha001", "scheone", "SHA4", "sha9", "sha256", "shape4", "shaache"], "props": ["prps", "prors", "prep", "proPS", "ProPS", " prors", "pperties", "rops", "Prors", "proports", "prop", "prePS", " proms", "pps", "roms", "pports", "Probs", "prbs", " proPS", "prports", "pbs", "Prop", "Proms", " prop", "prperties", " properties", "Props", "proms", "Properties", "probs", "preps", "roperties", "preperties", "rors", "Proports", "properties"], "names": ["testers", "groups", "makers", "pres", "nm", "idents", "AMES", "als", "ports", "strings", "beans", "members", "ers", "ns", "parents", "ons", "values", "aps", "ren", "nes", "appers", "keys", "ones", "these", "nets", "files", "Names", "photos", "ames", "modules", "ids", "ews", "ern", "objects", "paces", "ms", "nos", "words", "terms", "s", "ors", "chains", "versions", "papers", "codes", "ens", "events", "n", "mas", "properties"], "name": ["attribute", "url", "parent", "key", "path", "NAME", "string", "nm", "part", "def", "description", "old", "a", "info", "entry", "title", "label", "number", "value", "event", "node", "named", "alias", "var", "resource", "nam", "id", "num", "comment", "base", "type", "prefix", "Name", "str", "code", "item", "class", "create", "no", "address", "common", "word", "ame", "family", "term", "size", "print", "pair", "n"]}}
{"id1": "14877116", "id2": "411595", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"cpFile": [" copBuffer", "pasteSingle", " cpSingle", " dupStream", " copSingle", " cpBuffer", " dupFile", " cpStream", "pasteFile", " copFile", "pasteBuffer", " dupSingle", " copStream", " dupBuffer", "pasteStream"], "source": ["scan", "origin", "stream", "old", "subject", "secure", "from", "form", "store", "in", "spec", "create", "input", "self", "Source", "name", "ace", "unit", "comp", "path", "ource", "before", "original", "sample", "current", "series", "config", "start", "resource", "scene", "sql", "component", "ce", "SOURCE", "style", "use", "remote", "attribute", "up", "none", "select", "shell", "find", "this", "dest", "scope", "se", "query", "template", "base", "search", "site", "peer", "null", "ie", "sp", "parent", "init", "image", "string", "char", "copy", "file", "local", "status", "service", "get", "format"], "target": ["port", "link", "origin", "master", "bolt", "mount", "tor", "buffer", "alias", "host", "that", "set", "range", "normal", "table", "tree", "theme", "path", " targ", "current", "point", "resource", "join", "top", "project", "type", "force", "style", "remote", "this", "dest", "scope", "arg", "localhost", "Target", "goal", "tmp", "arget", "template", "gt", "root", "dev", "base", " dst", "site", "peer", "test", "output", "null", "print", "primary", "window", "handle", "ARGET", "secondary", "parent", "it", " Target", "file", "update", "internal", "global", "build", "next", "local", "default", "t", "tif", "tool", "to", "transform", "format"], "replace": ["remote", "delete", "link", "hide", "use", "include", "first", " Replace", "apply", "find", "ignore", "display", "keep", "repl", "add", "fix", "copy", "repair", "repeat", "change", "update", "compatible", "join", "close", "append", "match", "record", "places", "save", "force", "search", "report", "only", "enable", "rm", "store", "prefix", "load", "insert", "write", "placed", "place", "share", "null", "remove", "inline", "register", "fill", "format"], "bufferSize": ["bufferStyle", "windowCount", "BufferSize", "blockCount", "bufferName", "blockSize", "blockStyle", " bufferStyle", "BufferCount", "BufferSIZE", "BufferStyle", "windowName", "bufferCount", "bufferSIZE", "BufferName", "windowSize", " bufferCount", " bufferName", "windowSIZE", "blockSIZE", " bufferSIZE"], "src": ["Source", "sec", "obj", "init", "inst", "sq", "sin", "rs", "dest", "stream", "copy", "sr", "sb", "rx", "syn", "sys", "bin", "secure", "tmp", "read", "conv", "RC", "fc", "txt", "sync", "std", "sl", "http", "ctr", "rl", "in", "st", "img", "ser", "ins", "sf", "str", "out", "cur", "usr", "proc", "supp", "sc", "iter", "req", "rc", "sub", "rb", "input", "sp", "rt", "SOURCE"], "tarn": [" tara", "wtara", "starn", "utorn", "tara", " tarp", "Tard", "vtarm", "Tarm", "Tann", " tourn", " torn", "utarn", "Tinn", "vtorn", "tarp", "wtinn", "thorn", "vtann", "starp", "tinn", "tourn", "torn", "tard", "yarm", "tharl", "Tarn", "utann", " tinn", "wtarn", "yourn", "pourn", " tann", "pann", "thourn", "yarn", " tard", "wtann", "vtarn", "stourn", "parn", "Tara", "parm", "Tourn", "tarl", "starm", "utard", "tann", "yarp", "storn", "Torn", "tharn", "starl", " tarl", " tarm", "porn", "tarm"], "tardir": [" tartart", " tartir", " tarnar", " tarnr", "tartore", "tardr", "tarnr", " tardr", " tardint", "tarnint", "taredint", " tartr", " tartore", "tarnar", "tareddir", " tardore", "tarddir", "tradore", "taredar", "tartar", "tartr", "tarnore", "tardore", "tradart", "tardart", "tradir", "tadint", " tarnint", "taddir", "tartdir", "taredir", "tarndir", "tadr", "tarnart", "tadir", " tarnir", "tadar", "tarnir", "tartart", " tarndir", "tradr", " tarddir", "tartir", "tardar", " tardart", "tardint", " tardar"], "n": ["ln", "nm", "x", "g", "nt", "index", "ns", "max", "w", "nn", "nb", "number", "ind", "nr", "i", "k", "nan", "next", "j", "on", "num", "m", "c", "nl", "nc", "y", "t", "en", "nu", "mn", "d", "un", "sn", "l", "con", "count", "z", "na", "norm", "N", "cn"], "tar": ["sea", "zip", "tf", "dr", "tr", "vol", "part", "cot", "add", "bolt", "copy", "drop", "cro", "pack", "tor", "par", "buffer", "archive", "tan", "rar", "gre", "parse", "dra", "car", "box", "tg", "roo", "txt", "sv", "mar", "tap", "sum", "ctr", "te", "nut", "store", "or", "gob", "trap", "Tar", "mask", "cast", "csv", "tif", "gz", "cube", "stable", "war", "qa", "star", "cat", "bare", "ar"], "bytes": ["resources", "bits", "groups", "elines", "cs", "ips", "unks", "bags", "frames", "bs", "some", "strings", "tes", "lines", "pages", "classes", "gets", "series", "users", "values", "reports", "blocks", "gs", "es", "ones", "files", "seconds", "cells", "pieces", "steps", "services", "pins", "rows", "boxes", "its", "parts", "ings", "vals", "Bytes", "words", "versions", "outs", "qs", "les", "bles", "bps", "ls"], "readn": [" Readl", "Readnl", "Readnn", "ReadN", "rolll", "writel", "Readn", "writele", "rolln", " Readn", "readl", "printle", "readN", "loadnn", "readle", "loadl", "printn", " Readnl", "Readl", "loadn", " readl", "writen", "rollle", "printl", "readnn", "readns", "writens", "readnl", "writenn", "loadN", "rollns", "writeN", "printns", " readnl"]}}
{"id1": "20623709", "id2": "2009072", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "label": 0, "substitutes": {"split": ["scan", "unit", "use", "part", "process", "align", "copy", "lock", "join", "read", "transfer", "parse", "append", "map", "sync", "batch", "scale", "slice", "upload", "write", "share", "disk", "open", "count", "seek", "Split", "format"], "targetDirectory": ["TargetDir", " targetFolder", " targetFile", "targetDir", "targetLocation", "baseFile", "baseDirectory", "baseMemory", "TargetFolder", "testDir", "targetdirectory", "localDirectory", "localdirectory", "baseFolder", "targetMemory", " targetDirect", "testDirect", "baseDirect", "targetDirect", "Targetdirectory", "localFile", "testDirectory", " targetMemory", "TargetLocation", " targetDir", "TargetDirectory", "TargetDirect", "localDir", "targetFile", "testLocation", "basedirectory", "baseDir", " targetLocation", "TargetMemory", " targetdirectory", "targetFolder"], "prefix": ["ix", "name", "PRE", "Pref", "path", "key", "pres", "p", "version", "pattern", "this", "fix", "localhost", "title", "filename", "alias", "template", "padding", "password", "zero", "root", "fixed", "FIX", "base", "division", "type", "uri", "username", "command", "status", "tag", " suffix", "pre", "pkg", "fixes", "size", "pi", "directory", "index", "format"], "maxUnitBases": ["maxUnitLases", "maxUnitbias", "maxUnityBias", "maxUnityAliounds", "maxUnitReplages", "maxUnityLicas", "maxUnityBicas", "maxUnitLounds", "maxUnitChades", "maxUnitbases", "maxUnitReplases", "maxUnityLages", "maxUnitReplicas", "maxUnitBades", "maxUnitBounds", "maxUnitChases", "maxUnitbounds", "maxUnityAliases", "maxUnitReplounds", "maxUnitLicas", "maxUnityAliades", "maxUnityBades", "maxUnitBicas", "maxUnitbades", "maxUnitBias", "maxUnityBounds", "maxUnitAliases", "maxUnitChages", "maxUnitAliias", "maxUnityAliias", "maxUnitBages", "maxUnityBases", "maxUnityLases", "maxUnitAliounds", "maxUnitAliades", "maxUnitLages", "maxUnitChias", "maxUnitChounds", "maxUnitChicas", "maxUnityBages", "maxUnityLounds"], "maxUnitEntries": ["maxunitEntrys", "maxUnitErrs", "maxUnitentrys", "maxUnityEntrys", "maxUnitEntires", "maxUnityEntires", "maxUnitIntegrys", "maxUnityentrs", "maxUnityentires", "maxUnityentries", "maxunitEntires", "maxUnitEntryires", "maxUnitentrs", "maxunitEntrs", "maxUnitIntegries", "maxUnitentries", "maxUnitErries", "maxUnitErires", "maxUnitEntrs", "maxUnityEntrs", "maxUnitErrys", "maxUnitEntrys", "maxUnitEntryriers", "maxUnityentrys", "maxUnityEntries", "maxUnitEntriers", "maxUnitEntryries", "maxUnitentires", "maxUnitEntryrys", "maxunitEntries", "maxUnitIntegires", "maxUnitIntegriers"], "fis": ["viss", "fii", "Fis", "Fci", "fiss", "Fic", "fic", "Fiss", "ifis", "Fii", " fi", " fii", "ific", "fi", " fic", "vis", " fiss", "vi", "Fi", "vic", "ifci", "ifii"], "fci": ["cfico", "mco", "fii", "Fai", "cfai", "Fis", "Fci", "tco", "Fic", "Fini", "Fico", " fini", "mcu", "Fco", "fic", "fico", " fii", "cfis", "tci", " fico", " fcu", " fic", " fai", "mci", "fai", "cfci", "cfic", "fcu", "cfco", "mii", "tii", "tcu", "cfini", "fini"], "fos": ["fOS", " fios", "fbos", "flOS", "yios", "yos", "waos", "yaos", "Faos", "fios", "faos", "flos", "wos", "foss", "Foss", "flaos", " fOS", " faos", "wbos", "Fos", "FOS", "wios", "floss", " fbos", " foss", "ybos"], "fco": ["ccon", " foco", "pci", "Fcon", "pco", "Fci", "tdo", "tco", "Fdo", "cco", "cso", "tcos", "fcos", "Fco", "Fso", "fso", "pso", " fcos", "fcon", "fdo", "pcos", "Fcos", " fdo", "toco", " fcon", "cdo", "Foco", "foco", " fso"], "buffer": ["sequence", "timeout", "cache", "channel", "char", "order", "message", "memory", "sample", "entry", "stack", "flush", "database", "temp", "event", "source", "bridge", "holder", "limit", "black", "buf", "Buffer", "function", "append", "data", "template", "match", "record", "library", "padding", "read", "button", "result", "queue", "batch", "comment", "note", "complete", "command", "pause", "buff", "binary", "address", "phrase", "length", "table", "iter", "position", "block", "row", "reset", "callback", "print", "document", "filter", "window", "index"], "currentBasesCount": ["currentbasesCode", "currentBaseCount", "currentBaseCode", "currentBasesLength", "currentBadesLength", "currentbaseCode", "currentbaseLength", "currentbaseCount", "currentBasesCode", "currentBasedCount", "currentBasedCode", "currentBadesCode", "currentBaseLength", "currentbasesLength", "currentbasesCount", "currentBadesCount", "currentBasedLength"], "currentEntriesCount": ["currentEntrsCode", "currentEntriesFlag", "currentEntrsFlag", "currentEntriesCode", "currentEntrsCount", "currentEntiesCount", "currentEntrysCount", "currentEntiesCode", "currentEntrysCode", "currentEntiesFlag", "currentEntrysFlag"], "targetCount": [" targetAmount", "TargetCount", "targetAmount", " targetInfo", "TargetInfo", "argetNum", "TargetNum", " targetNum", "TargetAmount", "targetNum", "targetInfo", "argetCount", "argetAmount", "argetInfo"], "fastaChannel": [" fastoChan", " fastoChannel", " fastaButton", " fastaProvider", "fastityQueue", "fastoConnection", "fastpaButton", "fastoStream", "fastpaConnection", " fastoStream", "fastaProvider", "fastaStream", "fastpaChannel", "fastoChan", "fastityChannel", "fastaiQueue", "fastaQueue", "fastoChannel", "fastoButton", " fastaChan", "fastityChan", "fastoQueue", " fastaStream", "fastaiChannel", "fastaButton", " fastaConnection", " fastaQueue", "fastaiStream", "fastityStream", " fastoQueue", "fastaChan", "fastpaProvider", "fastoProvider", "fastaiChan", "fastaConnection"], "totalSeqCount": ["totalSeqsCount", "totalSeqCode", "totalSegCode", "totalSeQCounter", "totalSeQSize", "totalSeqSize", "totalSegCount", "totalSeqsCounter", "totalSeqCounter", "totalSeqsCode", "totalSeQCode", "totalSegSize", "totalSeQCount", "totalSegCounter", "totalSeqsSize"], "totalResiduesCount": ["totalResiduationsCode", "totalResiduesCode", "totalResIduesCount", "totalResidusCount", "totalResidueCount", "totalResidueFlag", "totalResIduesFlag", "totalResIduesCode", "totalResidusFlag", "totalResidusCode", "totalResIdueFlag", "totalResidueCode", "totalResIdueCount", "totalResiduesFlag", "totalResiduationsFlag", "totalResiduationsCount", "totalResIdueCode"], "prevTime": ["parTime", "parThread", " prevT", " previousTime", " previousT", "prevThread", " previousThread", "prevT", " prevThread", "parT"], "fastaFileSize": ["fastaFileSIZE", "fastoFileSize", "fastaReaderLength", "fastaReaderHeight", "fastoTableSize", "fastaChainLength", "fastaChainSIZE", "fastATableLength", "fastaTableOwner", "fastoFileSIZE", "fastaFileName", "fastaFilesHeight", "fastafileOwner", "fastoTableOwner", "fastATableSize", "fastATableName", "fastaTableSIZE", "fastATableHeight", "fastafileSIZE", "fastaFileOwner", "fastaTableHeight", "fastaFilesLength", "fastAFileSize", "fastAFileLength", "fastafileSize", "fastoTableSIZE", "fastaTableSize", "fastaChainSize", "fastaFileLength", "fastaTableName", "fastaFileHeight", "fastaTableLength", "fastoTableLength", "fastaReaderSize", "fastAFileHeight", "fastaReaderName", "fastAFileName", "fastafileLength", "fastaChainOwner", "fastoFileOwner", "fastoFileLength", "fastaFilesSize", "fastaFilesName"], "fastaFileReadOffset": ["fastaFilesLoadAmount", "fastaFilesReadAmount", "fastaFileInputAmount", "fastaFileReadPos", "fastaPageLoadAmount", "fastaFileReadAmount", "fastaFileReadOrder", "fastaFileLoadLength", "fastaChainCurrentOffset", "fastaFilereadOffset", "fastaFileLoadAmount", "fastaFileCurrentOffset", "fastaFileInputoffset", "fastaChainCurrentPosition", "fastaChainCurrentLocation", "fastaFilesLoadOffset", "fastaFilesLoadLength", "fastaFilesReadOffset", "fastaChainReadoffset", "fastaFileWriteOrder", "fastaFileCurrentoffset", "fastaFileReadPosition", "fastaFileReadLocation", "fastaFilereadPos", "fastaPageReadOrder", "fastaFileInputLocation", "fastaChainReadLocation", "fastaPageReadOffset", "fastaFileViewAmount", "fastaPageReadPos", "fastaFileInputOffset", "fastaFilesReadLength", "fastaFileReadoffset", "fastaFileReaderoffset", "fastaFileInputOrder", "fastaFileViewOffset", "fastaChainCurrentoffset", "fastaFileViewPos", "fastaFileViewOrder", "fastaFileReaderOffset", "fastaFileWriteAmount", "fastaFileLoadOrder", "fastaFileReaderLocation", "fastaFileInputLength", "fastaFileWriteLength", "fastaFileLoadPos", "fastaChainReadPosition", "fastaPageReadAmount", "fastaFileLoadOffset", "fastaPageLoadOrder", "fastaFileCurrentPosition", "fastaChainReadOffset", "fastaFilereadAmount", "fastaFileReaderPosition", "fastaPageLoadOffset", "fastaFileReadLength", "fastaPageLoadPos", "fastaFileInputPosition", "fastaFilesReadOrder", "fastaFileCurrentLocation", "fastaFilesLoadOrder", "fastaFilereadOrder", "fastaFileWriteOffset"], "partitionStartOffset": ["partitonStartPoint", "partitionDataPoint", "partitonStartingPosition", "partitonStartPosition", "partitionEndPoint", "partitionStartingPoint", "partitonStartingOffset", "partitionDataOffset", "partitonStartOff", "partitionStartingOff", "partitionStartPosition", "partitionDataOff", "partitionDataPosition", "partitonStartOffset", "partitionStartingPosition", "partitonStartingOff", "partitionStartOff", "partitonStartingPoint", "partitionEndOff", "partitionStartingOffset", "partitionStartPoint", "partitionEndPosition"], "bufferSize": ["sequenceSIZE", "buffLength", "BufferSize", "tableSIZE", "bufferName", "bufferCode", " bufferLength", "tableSize", "bufferLength", "bufLength", " bufferCode", "buffSIZE", "tableName", "buffName", "bufSize", "sequenceCode", "tableLength", "sequenceLength", "BufferSIZE", "sequenceSize", "bufSIZE", "bufferSIZE", "BufferName", "BufferLength", "buffSize", " bufferSIZE", "bufCode"], "fastaBuffer": ["fastasBuff", "fastanBuffer", "fastcaBuffer", "fastoBuff", "fastmaCache", "fastsaQueue", "fastmaBuilder", "fastmaQueue", "fastalBuff", "FastmaBuffer", "fastmaRequest", " fastaDB", "fastaCounter", "wildaCache", "fastsaBuffer", "fastmaBuffer", "fastaDB", "FastaBuffer", "fastuBuff", "fastalQueue", "fastasCache", "fastcaCache", "FastaBuff", " fastaMemory", "fastmaStore", "wildanCache", "fastalBuffer", "fastoCounter", "fastoQueue", "fastoRequest", "fastasBuffer", "fastasQueue", "fastaCache", "wildaRequest", "fasteBuff", "fastasBuilder", " fastoQueue", "fastanRequest", "wildaBuff", "fastaRequest", "fastsaChannel", "fastaBuilder", "fasteBuffer", "fastuMemory", "FastmaStore", "fastasCounter", "fastmaBuff", " fastoBuff", "FastmaBuff", " fastoCounter", "fastcaBuff", "fastasRequest", " fastaBuff", " fastaCache", "wildanBuffer", " fastaQueue", "fastuDB", "FastaStore", "FastmaRequest", "fastcaRequest", "wildanBuff", "fastaStore", " fastoBuffer", "fastaMemory", "fastanBuff", "fastuBuffer", "fastsaBuff", "fastalCounter", "FastaRequest", "fastaQueue", "fasteMemory", "wildanRequest", "wildaBuffer", "fastoStore", "fastoBuffer", " fastaBuilder", "fastaBuff", "fastanCache", " fastaCounter", "fastmaChannel", "fasteDB", "fastasStore"], "fastaReadState": ["fastoReadSTATE", "fastaReaderSTATE", "fastoReadStatus", "fastaCurrentStatus", "fastaLoadType", "fastaCurrentState", "fastaLoadState", "fastoReadState", "fastoReaderState", "fastaReaderType", "fastaCurrentSTATE", "fastaReadSTATE", "fastaCurrentType", "fastaReaderStatus", "fastoReaderSTATE", "fastoReaderType", "fastoReaderStatus", "fastaLoadStatus", "fastaReadType", "fastaReaderState", "fastoReadType", "fastaReadStatus", "fastaLoadSTATE"], "nBytes": ["nBlocks", "NParts", " nKeys", "nrBytes", " nNs", "nrKeys", "nWords", "nParts", "nrItems", " nParts", "NKeys", " nbytes", "nsWords", "nKeys", "numbytes", " nItems", "numBytes", "NWords", "nsBytes", "nsParts", "noBlocks", "NItems", " nWords", " nBlocks", "noBytes", "nItems", "numNs", "Nbytes", "noNs", "numBlocks", "nobytes", "nsbytes", "nNs", "NBytes", "nbytes", "nrbytes"]}}
{"id1": "15810440", "id2": "1188100", "code1": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"addRecipe": ["newRule", "setRecipe", "setDefinition", " addDefinition", "newDefinition", "newRecipe", "addRule", " addRule", "addDefinition", "setRule"], "name": ["sequence", "path", "NAME", "key", "image", "string", "version", "about", "system", "description", "title", "label", "value", "file", "config", "source", "named", "question", "filename", "alias", "admin", "data", "template", "root", "error", "comment", "base", "type", "category", "prefix", "in", "Name", "summary", "address", "definition", "common", "table", "ame", "word", "family", "term", "license", "names", "n"], "instructions": ["inemptIONS", "injectings", "inscriptions", "inSTRUCTION", "inscriptures", "injectION", "injectations", "construction", "INSTRUCTions", "inSTRUCTions", "insjectings", "conructures", "instructION", "INstructures", "instrations", "constructures", "INSTRUCTures", "instructures", " instructations", "inripts", "instructations", "inSTRUCTIONS", "instritions", "INstructIONS", "instractings", "conruction", "INstructions", "insstruction", "inription", "instructs", "inemptations", " inemptions", "inInstructION", "instracts", "injectures", "constructions", " inemptitions", "insjections", "inructures", "instructings", "inscriptations", "insjection", "conructations", "inructIONS", "instrIONS", "inSTRUCTures", "inInstructures", "INstructION", "instrions", "INSTRUCTION", "instractions", "constructations", "injectIONS", "instraction", "inructations", "injects", "inInstructions", "inructions", "inruction", "insstructs", "instructIONS", " instructitions", "inriptings", "insjects", " instructIONS", "inInstructIONS", "inemptions", "instructitions", "inructitions", " inemptIONS", "injections", " inemptations", "inriptions", "conructions", "inscription", "insstructings", "insstructions", "INSTRUCTIONS", "instruction", "injection", "inemptitions"], "categoryId": ["folderID", " categoryInfo", "familyid", " categoryById", " categoryid", "ategoryID", "categoryid", " categoryID", "currencyID", "currencyById", "familyById", "folderId", "categoryById", "familyID", "categoryInfo", "ategoryInfo", "folderid", "ategoryId", "folderById", "ategoryid", "currencyId", "currencyInfo", "categoryID", "familyId", "folderInfo"], "ainekset": ["ainysSet", "ainysets", "aineekset", "areewsET", "aineeksut", "areeksets", "aineeksets", "aineeksit", "ainsekset", "ainseksetter", "aineeksetter", "ainzensET", "ainewset", "aineksET", "aineksset", "ainzensit", "areewsSet", "aineeksSet", "ainzenset", "ainewsET", "ainskesSet", "areewsets", "areewsit", "ainskeset", "areeksit", "areeksset", "aineeksET", "areekset", "ainewsSet", "aineksit", "areewsset", "ainyset", "ainskesut", "aineeksset", "ainvesut", "ainzensset", "ainewsets", "areewset", "areeksSet", "ainysset", "ainseksut", "ainveset", "ainseksSet", "areeksET", "ainewsset", "aineksSet", "aineksut", "aineksetter", "ainvesetter", "ainkesetter", "ainskesetter", "aineksets", "ainkesut", "ainvesSet", "ainkesSet", "ainewsit", "ainkeset"], "pst1": ["pSTOne", "apstrOne", "pSTInternal", "pest2", "pcstore7", "pcstore2", "pST7", "pst001", " pctOnce", "pstrOnce", "pstyOnce", "pST2", "pert101", "pcst30", "pst8", "pcstore1", "apst3", "pST30", " pct2", "pct1", "PSt1", "prest51", "psta1", "patstra1", "psty2", "pstra51", "pestPre", "pst30", "pSt10", "prest8", "pstPre", "pST3", "pstr3", "pSt3", "prest001", "pstore2", "pst51", "wpst101", "pestOnce", "pconst8", "pstaInternal", "pmt2", "pconst001", "Pst2", "prest10", "patst8", "psta101", "pST101", "wpstaInternal", "pstOne", "pstore7", "pstr1", " pct1", "pst3", "pert1", "wpsta1", "pST1", "pctPre", "prest1", "pstOnce", "pstra1", "pSt1", "prestOne", "pcst2", " pstOnce", " pctPre", "patstra8", "pstore1", "wpst0", "PstOne", "apst1", "pcstore30", "pstrOne", "apstr1", "wpsta101", "pert0", "Pst10", "pstyPre", "pmt1", "pmt7", "patst001", "pStOne", "pstra8", "patstra51", "pst7", "prest2", "apstr3", "pst10", "pStOnce", "psty1", "PStOne", "pmt30", "pst0", "pctOnce", "pST0", "apstOnce", "patst1", "wpstInternal", "wpsta0", "pcst1", "psta0", "pSt2", "pst101", "PSt10", "apstrOnce", "pcst7", "pest1", "pST10", "pstInternal", "pstore30", "apstOne", "pconst1", " pstPre", "wpst1", "patstra001", "pSTOnce", "pstra001", "patst51", "pconst51", "pct2", "pertInternal", "Pst1", "PSt2"], "pst2": ["pstd2", "psth42", "pest2", "prost2", "psth22", "pster02", " pct8", "lpst2", "pswtwo", "pkt2", "pSt7", "pstat8", "PST1", "pST2", "PST2", "pst8", "PSTB", "prosetdb", "pkttwo", " pct2", "pst22", "pstd52", "Pst22", "pstB", "pct0", "pth2", "pusttwo", "psth1", "pust2", "ppsttwo", " pst8", "pSt3", "lpster7", "prosttwo", "pst02", "pset42", "pstattwo", "pstdb", "pest8", "proset2", "Pst2", "pST22", "psthtwo", "pst52", " pst3", "pSt8", "psthB", "PstB", "pset2", "ppusttwo", "pSt0", "psw8", " psttwo", "pster2", "psth2", "pst3", "pST1", "pSTB", "ppust2", "pct3", "prost42", "lpst7", "pSt1", " pst0", "ppst52", "psthdb", "psth7", " pct0", "lpster2", "lpster02", "psettwo", " pstattwo", "ppst2", "pstdtwo", "pst7", "psth02", "pSt22", "pth8", " pstat2", " pstat8", "lpst02", "pest3", "pst0", "pkt42", "pct8", "psttwo", "pktdb", "pSt2", "pest0", "pstat52", "psetdb", "psw2", "prosettwo", "pst42", "pStB", "ppust52", "pSt02", "prostdb", "pct2", "PST22", "pust52", "pthtwo", "proset42", "pster7", "pstat2", "Pst1", " pct3"], "rs": ["ls", "ras", "cs", "rd", "ws", "icks", "ges", "bs", "ps", "cks", "ats", "ars", "hr", "ds", "sr", "rates", "irms", "ubs", "RS", "ys", "vers", "gs", "ris", "xs", "bys", "fs", "sts", "res", "ags", "rows", "its", "wcs", "rl", "ims", "ours", "ms", "rys", "vs", "Rs", "usr", "acks", "times", "mr", "rc", "s", "js", "ires", "qs", "ows", "hs", "ks", "mc", "ues", "rt"], "retVal": [" retValid", "RETval", "contVAL", "rtVal", " retValue", "retsDev", "retsValue", "rtSel", "altRes", "retDev", "contValue", "altVal", "altValue", "rtval", " retval", "retval", "rtValue", "RETValue", "contRes", "Retval", "altVAL", "contVal", " retSel", "RETSel", " retVAL", "RetValid", " retDev", "retsVal", "retsval", "RETVal", "RetVal", "retVAL", " retRes", "retValue", "RETValid", "RetDev", "retRes", "RetValue", "retValid", "retSel"], "id": ["url", "sid", "key", "it", "oid", "hid", "a", "mid", "info", "ide", "rid", "uid", "start", "kid", "h", "ID", "alias", "val", "one", "record", "aid", "result", "num", "m", "f", "res", "time", "fd", "ids", "status", "in", "hash", "ref", "d", "db", "pid", " tid", "bid", "Id", "size", "ident", "index", "vid"], "aines": ["raines", "ainsves", "expresses", "ainces", "ainis", "ainves", "rainis", "aine", "AINe", "abais", "havees", "expressES", "abae", "abaces", "AINES", "ainses", "haveses", "asteris", "ainsesome", "expressces", "inse", "havee", "raine", "asteresome", "natis", "rainces", "insis", "ainsses", "nate", "ainsces", "ainES", "expresse", "AINes", "rainves", "rainES", "ainsis", "abaes", "astere", "nates", "haveis", "inses", "ainse", "AINves", "insses", "natesome", "asteres", "ainsES", "ainesome", "expressves"], "i": ["ix", "bi", "im", "sequence", "ip", "init", "go", "key", "mi", "is", "x", "it", "gi", "phi", "ui", "si", "v", "ini", "hi", "ami", "u", "e", "cli", "gu", "h", "io", "ci", "ti", "multi", "j", "di", "xi", "f", "m", "q", "ri", "y", "ei", "ic", "ms", "qi", "us", "o", "ai", "I", "my", "pi", "sim", "index", "ii", "li"]}}
{"id1": "15896098", "id2": "6987642", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getSHA256Checksum": ["getSHA256Checkchecksums", "getSHA256Checkcksume", "getSHA256Checkchecksume", "getSHA256Checsums", "getSHA256Checksam", "getSHA256Checkums", "getSHA256Checksums", "getSHA256Chechecksum", "getSHA256Chechecksam", "getSHA256Checkchecksum", "getSHA256Checsum", "getSHA256Checsume", "getSHA256Checkcksum", "getSHA256Checkcksums", "getSHA256Chechecksume", "getSHA256Checkume", "getSHA256Chechecksums", "getSHA256Checkcksam", "getSHA256Checksume", "getSHA256Checkum", "getSHA256Checsam", "getSHA256Checkchecksam", "getSHA256Checkam"], "source": ["Source", "name", "url", "sequence", "path", "image", "string", "this", "ource", "src", "message", "sample", "subject", "target", "content", "value", "file", "filename", "buffer", "context", "reason", "data", "template", "base", "from", "status", "body", "in", "text", "out", "seed", "output", "s", "input", "SOURCE", "style", "secret", "raw", "format"], "checksum": ["checkum", "cksume", " checkssum", "checkume", "cssum", "checkumb", "checksim", " checksums", "checkssum", " checksume", "csim", "checkim", "ckssum", "checksume", " checksumb", "csume", "checksums", "cksim", "cksums", "cksum", "checksumb", " checksim", "cksumb", "checkums", "csum"], "md": ["sm", " MD", "dr", "mt", "wd", "def", "cd", "mb", "MD", "nt", "dm", "dh", "mo", "mm", "der", "od", "cmd", "grad", "hd", "ind", "bd", "sd", "mod", "ad", "di", "ld", "m", "det", " Md", "down", "Cmd", "pm", "mp", "red", "ms", "mg", "mn", "d", "mand", "dd", "mc", "pdf", "mk", "df", "pd"], "byteData": ["byteRel", "ByteBytes", "ioDATA", "routeDATA", "sliceDat", "bytesData", "byteParts", "wordArray", "routeData", "ioDat", "ioData", "bleRel", "ByteParts", "reverseDat", " byteParts", "bytedata", "wordData", "channeldata", "channelRel", "reverseDATA", "reverseCount", " byteCount", "byteCount", "ioList", "phraseBytes", " bytedata", "channelData", "wordBytes", "channelParts", "ByteData", " byteArray", "phraseData", "ByteDATA", "bytesDATA", "bleData", "sliceList", "bytesArray", "phraseParts", "byteDATA", "reverseData", "sliceDATA", "routeCount", "byteDat", " byteDATA", "byteArray", "bleParts", "routeDat", " byteDat", "bytesBytes", "sliceData", " byteList", " byteBytes", "bledata", "wordDATA", "byteList", "byteBytes", "phraseDATA", " byteRel"], "sb": ["sm", "erb", "bg", "ib", "SF", "sq", "shell", "bs", "cb", "mb", "si", "sa", "bh", "sbm", "sh", "nb", "lb", "b", "ssl", "bsp", "bb", "sg", "sam", "sw", "sv", "lp", "eb", "bash", "bis", "gb", "bj", "bf", "sf", "wb", "ub", "kb", "pb", "db", "obb", "bt", "ob", "rb", "SB", "zb", "sp", "bps", "xb"], "i": ["ix", "im", "ime", "phi", "ui", "hi", "major", "info", "ski", "gu", "io", "ci", "multi", "di", "uri", "ic", "set", "ity", "ei", "qi", "I", "list", "my", "sim", "ind", "ii", "si", "life", "iu", "series", "point", "xi", "m", "ki", "remote", "ip", "ri", "this", "g", "u", "cli", "json", "\u0438", "err", "me", "id", "q", "y", "ims", "ms", "ij", "chain", "history", "loop", "o", "ai", "ie", "print", "bi", "init", "oi", "any", "mi", "it", "gi", "ji", "ini", "ion", "ti", "j", "iy", "er", "l", "client", "to", "pi", "iq", "li"], "hexString": ["hexResource", "hashstring", "shortArray", "fullBuffer", " hexArray", "htmlBuffer", "hexArray", "hexStore", " hexstring", " hexBuffer", "htmlstring", "exArray", " HexResource", " HexBuffer", " hexResource", "htmlString", "fullStore", "exString", "hashArray", "exBuffer", "shortstring", "hashString", " hexStore", "shortString", "exstring", "shortBuffer", "fullstring", " HexString", "hashBuffer", " Hexstring", "fullString", "shortResource", "htmlArray", "hexstring", "hexBuffer", "exStore"], "hex": ["zh", "hl", "php", "html", "comp", "exp", "alph", "none", " ex", "full", "tx", "x", "tex", "def", "sh", "rex", "ex", "temp", "json", "hello", "lit", "ph", "alias", "h", "prop", "sex", "ext", "dump", " Hex", "cont", "mix", "solid", "oct", "he", "com", "form", "pex", "des", "rh", "term", " sex", "flash", "cat", "rendered", "raw"]}}
{"id1": "16378239", "id2": "11032546", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"byReference": [" byRef", "byResource", "forResource", " byResource", "ByReference", "Byreference", " byreference", "forreference", "byRef", "forReference", "ByResource", "byreference", "ByRef", "forRef"], "inputStream": ["Inputstream", "inFile", "InputSteam", "inputReader", " inputSteam", "readableStream", "InputFile", " inputFile", " inputstream", " inputReader", "readableSteam", "InputStream", "readableReader", "readablestream", "instream", "inStream", "InputReader", "inputSteam", "inputstream", "inputFile", "inSteam"], "tempFile": ["tempUrl", "empfile", "empFile", "TempFile", "tmpName", "poraryUrl", "tempFiles", "tempName", "tmpPath", "empPlace", "empPath", "TempPath", "tmpDirectory", "poraryName", " tempfile", "Tempfile", "poraryPlace", "poraryDir", " tempChain", "TempDir", "tempPath", " tempDir", "tmpPlace", "tempfile", "tmpFile", " temporaryfile", " temporaryFile", "tempDirectory", "TempDirectory", "poraryFile", "TempUrl", "tempPlace", "poraryfile", " tempFiles", "empDirectory", "empName", " temporaryChain", "tempChain", "tempDir", " tempUrl", "tmpfile", "TempFiles", "TempChain", " temporaryFiles"], "out": ["auto", "msg", "up", "writer", "Out", "v", "ex", "aos", "dis", "ent", "file", "source", "all", "cos", "sys", "io", "serv", "one", "conv", "user", "again", "sum", "in", "lay", "ins", "t", "us", "o", "OU", "l", "output", "gr", "con", "os", "null", "to", "oss", "ao", "co", "s", "outs", "OUT", "net", "as", "n", "ou"]}}
{"id1": "3731077", "id2": "1357662", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["downloadFile", "CopyFile", " cpfile", "copyDirectory", "CopyFiles", "Copyfile", "downloadFiles", "downloadDirectory", " cpFile", " cpFiles", "copyFiles", "copyfile", "CopyDirectory", "downloadfile", " cpDirectory"], "from": ["name", "link", "url", "view", "html", "origin", "orig", "path", "por", "vol", "string", "bean", "org", "part", "old", "add", "se", "a", "what", "without", "info", "before", "original", "pro", "file", "config", "source", "so", "start", "query", "local", "data", "f", "base", "form", "or", "st", "str", "range", "with", "of", "at", "un", "From", "by", "db", "term", "rom", "s", "input", "fr", "reset", "star", "ol", "as"], "to": ["name", "auto", "tu", "html", "eto", "parent", "none", "full", "it", "org", "phi", "this", "dest", "nt", "toc", "target", "temp", "two", "file", "oto", "tt", "etc", "TO", "one", "must", "that", "template", "top", "on", "f", "too", "base", "po", "into", "te", "or", "st", "ta", "To", "t", "no", "bo", "o", "by", "table", "total", "output", "null", "pt", "tree", "co", "tom", "th", "size", "token", "pretty"], "parentDir": ["parentFile", " parentFile", "masterDirectory", " parentdir", "parentFolder", " parentFolder", "parentDirectory", "masterDir", "netdir", "rootFile", "ParentFile", "ParentDir", "rootDir", "ParentDirectory", "Parentdir", "ParentFolder", "netFile", "parentdir", "rootdir", "netFolder", "netDir", "rootFolder", "masterFolder", "masterFile", " parentDirectory"], "in": ["inn", "al", "inc", "up", "ri", "init", "raw", "mi", "irc", "it", "ain", "is", "sin", "inner", "xml", "isin", "ini", "din", "mm", "config", "source", "min", "all", "update", "bin", "i", "ir", "gin", "local", "one", "win", "on", "id", "In", "conf", "form", "ins", "inside", "en", "IN", "o", "doc", "get", "con", "ma", "input", "rin", "cin", "re", " IN", "net", "mc", "print", "vin", "inf", "ind"], "out": ["auto", "obj", "go", "ln", "vol", "it", "css", "Out", "g", "ex", "v", "nt", "aos", "outer", "ns", "cmd", "file", "gc", "b", "all", "sys", "ion", "i", "cos", "err", "io", "nin", "one", "conv", "gt", "on", "c", "ou", "again", "res", "ot", "or", "op", "t", "no", "at", "ro", "o", "ne", "write", "output", "client", "os", "null", "con", "oss", "co", "na", "outs", "OUT", "list", "net", "can", "n", "cn"], "ic": ["ix", "mic", "pc", "inc", "iac", "icon", "ip", "icy", "ac", "bc", "irc", "it", "cc", "eric", "arc", "tc", "tic", "iu", "sic", "i", "nic", "ci", "aic", "fc", "icc", "c", "ik", "ot", "pic", "ico", "cu", "ins", "ican", "vc", "cus", "IC", "wic", "isc", "rc", "co", "cin", "ics", "ric"], "oc": ["mic", "oly", "pc", "ac", "irc", "ocon", "soc", "ec", "cot", "arc", "ocr", "ox", "tc", "toc", "OC", "oe", "anc", "roc", "osc", "gc", "ict", "cos", "og", "nic", "ci", "aic", "yo", "oci", "oco", "mot", "c", "unc", "voc", "ot", "oct", "nc", "ucc", "pic", "ico", "cu", "o", "vc", "oca", "alloc", "cus", "co", "ric", "aco"]}}
{"id1": "18374478", "id2": "9033639", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"updateUser": ["insertUser", "uploadUse", "uploadCommon", "gePer", "setUser", "setuser", "insertAccount", "geUser", " updateMe", "putUse", "updateByte", "updateOne", "insertGroup", " updateByte", " updateCommon", " updateUSER", "setUse", "geuser", "uploadMe", " updateAccount", "putUser", "updateGroup", "UpdateAccount", "setPer", " updateUse", "geUse", "UpdateUsers", "updateUse", "makeByte", "putOne", "putUSER", " updateOne", "updateUSER", "UpdateGroup", " updatePer", "updateCommon", "uploadUser", "makeUsers", "updateUsers", "putUsers", "putuser", " updateUsers", "updateAccount", "uploadUsers", "updateuser", " updateuser", "makeUser", " updateGroup", "updatePer", "updateMe", "insertUsers", "uploadUSER", "putMe", "putCommon", "makeOne", "UpdateUser", "putByte", "uploaduser"], "user": ["name", "util", "up", "other", "key", "User", "version", "ver", "per", "part", "char", "display", "this", "order", "v", "usage", "message", "add", "info", "device", "job", "content", "u", "users", "file", "config", "admin", "uid", "update", "author", "resource", "host", "me", "profile", "record", "data", "password", "result", "plugin", "base", "usa", "report", "sum", "valid", "form", "instance", "object", "post", "item", "rule", "usr", "by", "module", "table", "client", "get", "word", "USER", "account", "ud", "connection", "row", "re", "token", "used", "username", "use", "owner"], "conn": ["port", "link", "obj", "die", "enc", "info", "cmd", "cont", "res", "conf", "quote", "cur", "bo", "dc", "cf", "ctx", "Con", "pt", "req", "Connection", " con", "yn", "bind", "act", "cb", "pool", "cc", "org", "apt", "wn", "gc", "iw", "oc", "coll", "cfg", "ctr", "com", "con", "connection", "oss", "exec", "pub", "ce", "net", "mt", "col", "addr", "tp", "cn", "cons", "cert", "resp", "comm", "nt", "err", "ssl", "conv", "gen", "c", "pas", "nc", "gate", "out", "pkg", "cm", "db", "dt", "co", "cat", "mc", "ct", "handle", "ch", "socket", "wd", "typ", "ns", "connect", "pg", "wr", "log", "priv", "close", "lang", "t", "jp", "rel", "open", "client", "wp", "ann", "Conn", "n", "cp"], "autoCommit": ["AutoDebit", "AutoCommort", "anoActivort", "autoCollmit", "autoRemend", " autoCommend", "autoDeblate", "AutoCommmit", "anoActivmit", "autoCollit", "autoComort", "autoDebort", " autoCompe", "anoActivit", " autoCompit", "autoComme", "AutoDebmit", "autoCollcommit", " autoComme", " autoCompmit", "autoActivmit", "autoCompend", "anoCommlate", " autoCompend", "autoQue", "autoComlate", "AutoCommcommit", "autoQumit", "autoCommmit", "anoCommit", "autoReme", "autoActivort", "AutoDebcommit", "autoComcommit", "autoDebit", "autoRemit", "autoCollort", "autoCommort", "autoCommcommit", "autoComit", " autoCommmit", "autoCompit", "AutoCommit", "autoDebmit", "autoCommlate", "AutoDebort", "autoQuend", "anoActivlate", "autoRemmit", "anoCommort", "anoCommmit", "autoCompe", "autoDebcommit", "autoQuit", "autoCommend", "autoCompmit", "autoActivit", "autoActivlate"], "deleteRoles": ["deleteToles", " deleteRoids", "deleteNroups", "deleteRadles", " deleteResols", "deleteResoids", "deleteRoids", "deleteRols", "deleteRanguages", "deleteRroups", "deleteTules", "deleteEroids", "deleteEroles", "deleteGroups", "detailCorroups", "deleteNols", "deleteGles", " deleteResroups", "deleteCorules", "deleteRadols", " deleteResles", " deleteRroups", "detailCoranguages", "deleteCoroles", "deleteRadoles", "deleterroups", "detailRules", "deleteNles", "deleteResols", "deleteRules", "deleteCorroups", "deleteRadoids", "deleteErols", " deleteRols", " deleteResoles", "deleteRles", "deleteResles", "detailRoles", "deleteCoranguages", "detailRanguages", "deleteroles", "deleteTroups", "deleteErles", "deleteranguages", " deleteRles", "deleteResoles", "deleteGols", "deleteGoles", " deleteResoids", "deleterules", "detailRroups", "detailCoroles", "detailCorules", "deleteNoles", "deleteTanguages", "deleteResroups"], "insertRoles": ["sequenceRrots", "insertNodes", "InsertRhips", "insertRsrots", "insertRobels", "insertRobles", "insertPodes", "insertRrots", "insertResoles", "insertCights", "insertReplroups", "sequenceRobles", "insertResles", "deletePodes", "insertCodes", "insertPights", "insertRhips", "insertColes", "sequenceRoles", "insertLiders", "insertLoles", "insertReploles", "insertRows", "stepReplodes", "insertRsoles", "insertReships", "insertRsles", "insertRights", "deletePoles", "InsertRles", "deleteRows", "insertNoles", "insertRepliders", "deletePights", "insertLroups", "insertRodes", "insertLodes", "insertGiders", "sequenceRles", "insertNhips", "stepRodes", "insertRsels", "stepRroups", "InsertRodes", "insertGodes", "insertRles", "insertCows", "insertNles", "sequenceRobrots", "insertReplodes", "stepReplroups", "insertRels", "insertRroups", "deleteRodes", "insertRoboles", "deleteRights", "insertResodes", "sequenceRoboles", "stepRoles", "insertRiders", "deletePows", "insertPoles", "sequenceRels", "insertGroups", "insertGoles", "stepRiders", "stepReploles", "insertPows", "InsertRoles", "sequenceRobels", "stepRepliders", "insertRobrots"], "role": ["le", "hole", "part", "char", "def", "r", "entry", "slave", "oval", "label", "node", "resource", "ole", "profile", "password", "right", "type", "rol", "peer", "cell", "tro", "te", "feature", "rl", "range", "office", "tag", "rice", "country", "rule", "zone", "ro", "relation", "rel", "word", "family", "ule", "block", "row", "Role", "ce", "hero", "aco", "col", "pe"]}}
{"id1": "4501356", "id2": "4468255", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"calculateProfileDiffDigest": ["calculateProfileDiffdigests", "calculateProfileDiffDiffst", "calculateProfileChangeDigest", "calculateProfileDiffDigests", "calculateProfileChangedigest", "calculateProfileDiffDigst", "calculateProfileDiffSigne", "calculateProfileChangeDigests", "calculateProfileDiffSignest", "calculateProfileChangedige", "calculateProfileDiffSignests", "calculateProfileChangedigst", "calculateProfileDiffdigst", "calculateProfileDiffDiffe", "calculateProfileChangedigests", "calculateProfileDiffdigest", "calculateProfileChangeDige", "calculateProfileDiffDiffest", "calculateProfileDiffdige", "calculateProfileDiffDiffests", "calculateProfileDiffDige", "calculateProfileDiffSignst", "calculateProfileChangeDigst"], "profileDiff": ["profileData", "pictureInf", "templateDifferent", "profileUpdate", " profileUpdate", " profileDelta", "ProfileChange", "profileInf", "userChange", "templateDiff", "personUpdate", "phdiff", "pictureChange", "ProfileDifferent", "persondiff", "userDiff", "profilediff", "userDelta", "ProfileDiff", "phInf", "templateDelta", " profileInf", "caseDelta", "caseDiff", "jsonDelta", "ProfileData", "templateData", "ProfileDelta", "pictureDiff", " profileChange", "jsonData", " profilediff", "personDelta", "personDiff", "profileDelta", "profileChange", "casediff", "caseUpdate", "picturediff", "phChange", "profileDifferent", "jsonDiff", "phDiff", "jsonDifferent"], "normaliseWhitespace": ["normaliseWhitesspace", "normaliseWhipsSpace", "normaliseWhatsSpace", "normaliseWhitspaces", "normaliseWitesSpace", "normaliseWitesace", "normaliseWitespace", "normaliseWhatspace", "normaliseWatsSpace", "normaliseWhipsace", "normaliseWipspace", "normaliseWipsspace", "normaliseWhipspace", "normaliseWhitspace", "normaliseWhitesSpace", "normaliseWipspaces", "normaliseWhitesace", "normaliseWipsSpace", "normaliseWatsace", "normaliseWhitsspace", "normaliseWhipspaces", "normaliseWhatsspace", "normaliseWitespaces", "normaliseWatsspace", "normaliseWhitsSpace", "normaliseWhatsace", "normaliseWhipsspace", "normaliseWhitespaces", "normaliseWhatspaces", "normaliseWatspace", "normaliseWitesspace"], "md": ["sm", "deep", "obj", "amd", "dr", "and", "mt", "cd", "MD", "add", "nt", "dm", "mm", " df", "der", "od", "cmd", "mac", "ind", "grad", " sd", "bd", "de", "sd", "mod", "ad", "sam", "pd", "ld", "m", "det", "fd", "pm", "rm", "ms", "red", "mg", "mn", "d", "nd", "dir", "dist", "js", "dd", "mc", "pdf", "mk", "df", "hd"]}}
{"id1": "9096319", "id2": "1508161", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"handleNodeRegainedService": ["handleNoderegainedSite", "handleNoderegainedServices", "handleNodeRegalledService", "handleNodeRegainedServices", "handleNodeRegifiedSite", "handleNodeRegifiedService", "handleNodeRegalledServices", "handleNoderegainsService", "handleNoderegainedService", "handleNodeRegainedSite", "handleNodeRegainsSite", "handleNodeRegainsService", "handleNodeRegalledSite", "handleNoderegainsServices", "handleNoderegainsSite", "handleNodeRegainsServices", "handleNodeRegifiedServices"], "eventID": ["nodeTime", "nodeUID", "nodeId", "EventName", "nodeKey", "nodeType", "eventUID", " eventName", " eventKey", "EventID", "eventType", "nodeName", "EventTime", "EventType", "serviceUID", "serviceId", "eventName", " eventId", "EventUID", " eventUID", " eventType", "serviceTime", "serviceKey", "EventId", "eventKey", "eventId"], "nodeID": ["instanceIDs", " nodeIDs", "entityID", "resourceName", "odeId", "NodeName", "entityId", "moduleIDE", " nodeName", "odeIDE", "localId", "nodeId", "odeID", "serverID", "serverIDs", "volumeId", "serverInfo", "NodeIT", "nodeName", "volumeIT", " nodeInfo", "moduleID", "nodeIDs", " nodeIDE", "moduleId", "nodeIT", "serverId", "entityJS", "volumeName", "nodeInfo", " nodeJS", "serverName", "moduleIT", "NodeID", "localJS", "instanceID", "localID", " nodeId", "resourceID", "nodeJS", " nodeIT", "nodeIDE", "Nodeid", " nodeid", "moduleid", "instanceId", "NodeIDs", "NodeId", "volumeID", "resourceId", "instanceInfo", "nodeid"], "ipAddr": ["ipStorehr", "ipAddrb", "ipSendr", "ipIntr", "ipAddsrb", "ipAndrt", "ipAcr", "ipAttp", "ipAddl", "ipSender", " ipaddrt", " ipAddaddr", "ipStorer", "ipAcrs", "ipAcrb", "ipStorers", "ipaddr", "ipAddsn", "ipIntp", " ipAddrs", "ipStorert", "ipAndri", " ipAttrar", " ipaddp", "ipAttrar", "ipAndp", " ipAttr", "ipAcn", " ipAtter", "ipResrs", "ipAddrs", "ipAddn", "ipAddsrs", " ipAddrt", "ipaddp", "ipAddressrar", " ipAddp", "ipaddl", " ipaddrs", "ipIntaddr", "ipAddaddr", "ipAttr", "ipAddressri", "epAddressl", "ipAtter", "ipaddrt", "ipResr", "epAddri", "ipAddressaddr", "ipAndrs", " ipAddressr", "epAddressrs", " ipAdder", "epAddrs", "epAddressr", "ipSendp", "ipSendrar", "epAddl", "ipAndl", "ipAddsr", "ipAddressp", "epAddressri", " ipAttp", "ipResrt", "ipAddp", "ipIntrs", " ipAddhr", "ipAddressrs", "epAddr", " ipaddr", " ipAddressrs", "ipAddrt", "ipAddressl", " ipAddn", " ipAddressaddr", " ipAddl", "ipAddressr", " ipAddrb", "ipReshr", "ipAddri", "ipAdder", " ipAddrar", "ipAddresser", "ipAddhr", "ipaddrs", "ipAddrar", "ipAndr", " ipAddressp"], "serviceID": ["ServiceName", "sourceJO", " serviceLAN", " serviceKey", "resourceName", "securityId", " serviceJO", "servKey", " serviceNOTE", "componentId", "servName", "ServiceKey", "servNAME", "serviceName", "securityid", " serviceName", "securityName", "componentNOTE", "ServiceId", "serviceNAME", "ServiceID", "sourceId", "serviceType", "ServiceJO", "serviceLAN", "sourceName", "serviceId", "ServiceNAME", "servLAN", "ServiceType", "servid", "Serviceid", "serviceJO", "resourceId", " serviceType", " serviceNAME", "componentName", "serviceid", "ServiceNOTE", "resourceType", "serviceNOTE", "ServiceLAN", "resourceID", "servId", "serviceKey", " serviceId", "securityID", "sourceID", "componentID", "servID", " serviceid"], "eventTime": ["eventTIME", "ageTIME", "attributeTIME", "eventType", "eventTimes", "EventTime", "EventType", "ventTimes", " eventtime", "EventTIME", "attributeTimes", " eventTIME", " eventTimes", "Eventtime", "agetime", "attributeType", " eventType", "ageTime", "ventType", "attributeTime", "ventTIME", "eventtime", "ventTime", "ageType"], "log": ["link", "and", "ex", "ger", "debug", "channel", "user", "bug", "call", "cont", "conf", "scale", "cell", "store", "set", "gob", "url", "msg", "le", "full", "xml", "message", "event", "config", "error", "ome", "tab", "report", "com", "tag", "sql", "ge", "prot", "at", "lo", " logger", "row", "net", "ar", "use", "mail", "util", "pl", "se", "w", "json", "de", "err", "og", "cal", "low", "base", "category", "or", "out", "db", "blog", "cat", "be", "zip", "LOG", "enter", "it", "Log", "entry", "lock", "file", "email", "ext", "pel", "crit", "iam", "t", "en", "l", "note"], "dbConn": ["dbObj", "DBConn", "fbConnect", "sbCon", "sbConn", "cbCon", "tableCon", "bCons", "DbObj", "DbCon", "tableConn", "gbCon", "dbCon", "sbConnect", "fbConn", "dbCons", "bdConnect", "bConn", "userCon", "dbconn", "bdConn", "userConnect", " dbCon", "cbConnection", "dbConnection", " dbconn", "cbConn", "DBCons", "gbConn", "fbObj", "gbConnection", "tableObj", "userObj", "userConn", "DBConnect", "sbConnection", "bCon", "dbConnect", "bdObj", "cbConnect", "bConnect", " dbCons", " dbObj", "fbCon", "tableconn", "sbObj", "DbConnect", "gbConnect", "Dbconn", "bdCon", " dbConnect", "DBCon", "DbConn"], "outageUpdater": ["outageUpnatter", "outageUPdarer", "outageUPtaser", "outageUPtoder", "outageUpdbaser", "outageUpDaters", "outageUPtater", "outageUndater", "outageUpDatter", "outageUPnater", "outageUpnater", "outageUndATER", "outageUptatter", "outageUPdaser", "outageUPtaters", "outageUdatoder", "outageUptarer", "outageUtdaser", "outageUtDoder", "outageUppater", "outageUplitter", "outageUpnATER", "outageUpDager", "outageUpdatemomer", "outageUdoder", "outageUpdatedATER", "outageUtDater", "outageUPtatter", "outageUpdATER", "outageUpdoder", "outageUpddater", "outageUptater", "outageUdetter", "outageUdater", "outageUpdaterarer", "outageUplter", "outageUdatetter", "outageUptager", "outageUnndATER", "outageUpnomer", "outageUplater", "outageUPnarer", "outageUpdarer", "outageUPdatter", "outageUpraters", "outageUnnditter", "outageUpdatedarer", "outageUppoder", "outageUptoder", "outageUpdboder", "outageUpmetter", "outageUpdatter", "outageUPditter", "outageUtDrer", "outageUpnoder", "outageUpdatetter", "outageUpdataser", "outageUpnaser", "outageUPdater", "outageUpnter", "outageUpdatedater", "outageUpmaser", "outageUpdomer", "outageUpmATER", "outageUdatater", "outageUpdager", "outageUpmrer", "outageUPtter", "outageUpdter", "outageUtDaser", "outageUpdbater", "outageUPdoder", "outageUpdatoder", "outageUpnarer", "outageUpDater", "outageUPtitter", "outageUpndter", "outageUpnitter", "outageUPdATER", "outageUpDoder", "outageUpdatemaser", "outageUpdaser", "outageUpDATER", "outageUpmter", "outageUpdaters", "outageUdaser", "outageUpdrer", "outageUpdateraters", "outageUpprer", "outageUpDaser", "outageUpndATER", "outageUpdatedaters", "outageUplATER", "outageUdataser", "outageUtdoder", "outageUpddomer", "outageUpdbetter", "outageUpmomer", "outageUpdatedomer", "outageUnditter", "outageUpnaters", "outageUPnaters", "outageUpdatedager", "outageUnndater", "outageUprater", "outageUpnditter", "outageUpdaterater", "outageUpndater", "outageUPnATER", "outageUtdrer", "outageUptitter", "outageUptter", "outageUpdetter", "outageUPdaters", "outageUpDrer", "outageUpdaterager", "outageUPdter", "outageUpditter", "outageUptaters", "outageUpmitter", "outageUploder", "outageUpdatedaser", "outageUtdater", "outageUpmater", "outageUpDarer", "outageUnndter", "outageUpdatemATER", "outageUplarer", "outageUpddATER", "outageUpdatater", "outageUprager", "outageUplaters", "outageUpdatemater", "outageUpmoder", "outageUndter", "outageUptaser", "outageUppaser", "outageUpddaser", "outageUprarer"]}}
{"id1": "5744493", "id2": "3958807", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"onlyFileCopy": [" synchronizedFileMove", " doStreamMove", " doFullDownload", " doPageCopy", " synchronizedFullDownload", " doStreamDownload", " synchronizedFullCopy", " doFullCopy", " doFileCopy", " doFileMove", " synchronizedFileCopy", " doPageDownload", " doStreamCopy", " synchronizedFullMove", " doFileDownload", " synchronizedFileDownload", " doPageMove", " doFullMove"], "in": ["inn", "inc", "up", "init", "ac", "it", "ain", "isin", "old", "ex", "r", "din", "mm", "file", "ck", "source", "b", "i", "gin", "from", "In", "el", "or", "ic", "ins", " input", "en", "IN", "o", "l", "n", "input", "cin", "rin", "as", "inf", "ind"], "out": ["up", "ch", "p", "it", "Out", "v", "ex", "nt", "w", "file", "log", "io", "serv", "gt", "c", "po", "res", "ot", "check", "help", "op", "t", "at", "o", "ne", "write", "l", "output", "os", "null", "to", "s", "outs", "OUT", "net", "as", "n", "ou"], "inChannel": [" inCase", "dinCommand", "innerChannel", "Inchannel", "outCh", "innerStream", "outStream", " inConnection", "innerchannel", "INStream", "cinButton", "innCategory", "vinCommand", "inCommand", "dinChannel", "InChannel", "vinChannel", "isinConnection", "InCh", "cinCategory", "innButton", "INchannel", " inCategory", "vinCase", " inCh", "isinChan", "innerChan", "dinChan", "outchannel", " inCommand", "dinCase", "outChan", "inStream", "INChannel", "vinConnection", "inCase", "cinCommand", "isinChannel", "inchannel", "inCategory", "cinChannel", "inConnection", "innChannel", "isinButton", " inChan", "inCh", " inButton", "dinButton", "InChan", "INChan", "inChan", "inButton", " inchannel", "dinConnection", "innCommand"], "outChannel": ["outerRoom", "cosChannel", "upDisk", " outChan", "outCh", "outStream", "OutChan", "cosDisk", "OutChannel", "aosMachine", "aosSection", " outCh", "cosSection", "outerChan", " outConnection", "outSection", "outerStream", "newChannel", "outputChan", "onchannel", "outputCh", "onChan", "newConnection", "upMachine", "outerChannel", "outputChannel", "outchannel", "upChannel", "aosChannel", " outchannel", "outChan", "newChan", "OutCh", "cosMachine", "inStream", "outDisk", " outRoom", "OutStream", "aosDisk", "onConnection", "upSection", "inRoom", "outConnection", "newchannel", "onChannel", "outMachine", " outStream", "inChan", "outRoom", "outputStream"], "maxCount": ["minCount", "MaxCast", "minSize", "MAXLength", " maxCast", "MaxLength", "MaxSize", " maxFlag", "maxFlag", "MAXFlag", " maxLength", "MAXCount", "MaxCount", "minFlag", "minCast", " maxSize", "minLength", "maxSize", "maxLength", "maxCast"], "size": ["name", "sent", "len", "ose", "shape", "any", "is", "equal", "height", "notice", "capacity", "bytes", "si", "sample", "message", "shift", "gets", "start", "resolution", "keys", "read", "sd", "close", "scroll", "SIZE", "export", "m", "space", "small", "send", "south", "sum", "scale", "body", "range", "set", "ms", "ize", "duration", "write", "fee", "length", "total", "position", "count", "seek", "Size", "speed", "readable", "show", "empty", "score", "ze", "area"], "pos": ["port", "pc", "len", "offset", "exp", "pl", "p", "resp", "it", "x", "part", "def", "ps", "pointer", "seq", "pro", "pg", "Pos", "point", "cos", "start", "i", "slot", "limit", "Position", "coord", "zero", "po", "left", "page", "spec", "no", "loc", "pr", "o", "rel", "pose", "l", "doc", "length", "os", "position", "pt", "to", "pid", "n", "row", "sp", "POS", "pi", "pass", "index", "off"]}}
{"id1": "23088292", "id2": "8079516", "code1": "    private void Submit2URL(URL url) throws Exception {\n        HttpURLConnection urlc = null;\n        try {\n            urlc = (HttpURLConnection) url.openConnection();\n            urlc.setRequestMethod(\"GET\");\n            urlc.setDoOutput(true);\n            urlc.setDoInput(true);\n            urlc.setUseCaches(false);\n            urlc.setAllowUserInteraction(false);\n            if (urlc.getResponseCode() != 200) {\n                InputStream in = null;\n                Reader reader = null;\n                try {\n                    in = urlc.getInputStream();\n                    reader = new InputStreamReader(in, \"UTF-8\");\n                    int read = 0;\n                    char[] buf = new char[1024];\n                    String error = null;\n                    while ((read = reader.read(buf)) >= 0) {\n                        if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read);\n                    }\n                    throw new NpsException(error, ErrorHelper.SYS_UNKOWN);\n                } finally {\n                    if (reader != null) try {\n                        reader.close();\n                    } catch (Exception e1) {\n                    }\n                    if (in != null) try {\n                        in.close();\n                    } catch (Exception e1) {\n                    }\n                }\n            }\n        } finally {\n            if (urlc != null) try {\n                urlc.disconnect();\n            } catch (Exception e1) {\n            }\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"Submit2URL": [" get3SSL", " GETToURL", " getToSSL", " GETToUrl", " get4Url", " GET2HTTP", " getToHTTP", " get4URL", " getToUrl", " GET2Url", " GETToHTTP", " get2Url", " GET2SSL", " GETToSSL", " get4SSL", " get3URL", " getToURL", " get3Url", " get2HTTP", " get4HTTP", " GET2URL", " get2URL", " get3HTTP", " get2SSL"], "url": ["mail", "Url", "link", "name", "hl", "pl", "char", "loader", "r", "job", "download", "dll", "b", "location", "log", "ssl", "build", "email", "bel", "call", "dl", "base", "uri", "web", "http", "nl", "sl", "el", "uu", "rl", "mil", "str", "ll", "un", "l", "work", "URL", "ls", "ur", "ul"], "urlc": ["httpd", "urlC", "cmcat", "httpcu", "buildci", "httpC", "calfc", "mlcu", "nelci", "urlcat", "mlco", "lookc", "hlce", " urlcc", " urle", "buildc", "sslc", "glC", "cmc", "llc", "ulcat", "lookcc", "implci", "nele", "bbcc", "lookfc", "llC", "Urlc", "httpc", "implcu", " urlcon", "urllc", "mlC", "urlcc", "nelc", " urlt", "cmC", "bbcat", "lookci", "ssllc", "glc", "relcp", "nelC", "hlco", " urlC", "bbC", "relci", "cmcc", "calc", "lllc", "nelfc", "calcat", "urlci", "gld", "relc", "hlc", "nelcont", " urlrc", " urlcat", "ulcon", "hlcu", "relfc", " urlcp", "lookcont", "calcp", "urlcont", "urlco", "urlce", "bbc", "urlcp", " urlfc", "getc", "sslce", " urlcont", "buildrc", "urlf", "urlrc", "calcon", "Urlce", "hllc", "buildcc", "lookrc", "implc", "getlc", " urlcu", "llcc", "ult", "calcu", "mlc", "implf", "Urllc", "ulc", "lle", "llf", "calt", "getC", "calco", "urlcon", "urlcu", "sslC", "hlci", "urle", "urld", "urlt", "hlC", "llci", "hlf", "llcu", " urld", "llcat", "UrlC", "calC", "getce", " urlci", "calci", "glcu", "urlfc", "llce"], "in": ["inn", "name", "inc", "pin", "init", "raw", "is", "it", "mi", "ain", "image", "inner", "stream", "isin", "ini", "r", "din", "file", "source", "all", "nin", "bin", "i", "io", "gin", "win", "on", "media", "m", "In", "body", "or", "inside", "ins", "en", "out", "er", "IN", "l", "get", "iter", "ma", "con", "n", "cin", "rin", "input", "re", "pi", "mc", "print", "inf", "ind"], "reader": ["iterator", "rd", "rer", "writer", "image", "per", "handle", "and", "older", "reading", "inner", "stream", "via", "loader", "r", "entry", "rr", "rx", "redo", "source", "buffer", "ger", "her", "resource", "parser", "builder", "rar", "io", "author", "parse", "dra", "library", "media", "roller", "handler", "driver", "unsigned", "peer", "ner", "rl", "ser", "Reader", "rule", "er", "no", "ro", "phrase", "proc", "word", "iter", "mr", "row", "runner", "readable", "rot", "print", "dr", "pe"], "read": ["scan", "im", "READ", "len", "orig", "select", "find", "height", "handle", "ready", "add", "reads", " Read", "w", "max", "run", "connect", "query", "start", "buffer", "i", "push", "close", "give", "take", "val", "available", "num", "accept", "mix", "send", "wait", "lex", "check", "text", "t", "load", "loop", "write", "ok", "open", "get", "length", "iter", "req", "hold", "count", "seek", "end", "skip", "input", "readable", "n", "show", "size", "print", "pe", "index", "ind", "Read"], "buf": ["cap", "len", "cv", "bc", "nm", "tx", "cb", "bh", "seq", "temp", "cmd", "b", "bed", "buffer", "err", "log", "uf", "val", "Buffer", "tmp", "conv", "bar", "box", "tab", "queue", "batch", "arr", "cam", "br", "img", "bag", "str", "Buff", "mem", "buff", "ref", "proc", "pkg", "vec", "db", "doc", "ctx", "iter", "block", "rb", "norm", "cat", "aka", "bytes"], "error": ["attribute", "option", "ace", "parent", "Error", "string", "it", "and", "operator", "our", "problem", "order", "description", "ror", "message", "r", "errors", "terror", "info", "entry", "ack", "detail", "e", "wrong", "success", "event", "query", "iso", "err", "debug", "ion", "resource", "reason", "parse", "one", "root", "bug", "warning", "result", "alert", "complete", "comment", "type", "command", "status", "instance", "or", "danger", "red", "code", "serial", "address", "no", "ro", "relation", "ERROR", "exc", "expected", "row", "re", "orr", "note", "primary", "style", "owner"]}}
{"id1": "18731843", "id2": "20920051", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doBody": [" sendbody", " sendHead", " dobody", "loadbody", "loadHead", " doContent", " writeBody", " doHead", " sendBody", " writeHead", " sendContent", "loadBody", "loadContent", " writebody", " writeContent"], "req": ["sq", "quick", "tx", "qt", "inv", "def", "rec", "ps", "hr", "cmd", "Request", "pro", "query", "err", "wx", "j", "express", "qq", "crit", "res", "reg", "q", "http", "conf", "Requ", "aj", "urg", "jp", "proc", "pkg", "ctx", "gr", "request", "exec", "requ", "fr", "js", "quest"], "resp": ["response", "exp", "wa", " res", "RES", "vol", "soc", "comm", "def", "ret", "rec", "Rep", "cl", "esp", "wr", "pos", "err", "serv", "next", "Res", "respond", "respons", "Resp", "result", "res", "rep", "http", "Response", "sol", "out", "rel", "output", "client", "re", "js", "trans", "sp"], "bis": ["fps", "bi", "bits", "obs", "pin", "oi", "mi", "is", "iss", "zo", "bs", "isin", "bh", "sb", "bat", "bil", "avi", "bie", "onis", "iso", "idis", "ris", "ses", "rison", "inet", "webkit", "pins", "lin", "ads", "aus", "ubis", "ios", "bes", "ais", "iris", "los", "bt", "phis", "os", "lbs", "oss", "atis", "mis", "cin", "bid", "bps", "isi", "be", "nis", "lis"], "bos": ["tis", "bits", "bi", "obs", "oi", "ols", "is", "ts", "bs", "ods", "banks", "tes", "uts", "bh", "asket", "aos", "ubs", "bil", "oops", "asis", "bin", "ys", "gs", "uds", "fits", "fs", "pins", "vas", "its", "bas", "acs", "ios", "ubis", "stones", "nos", "bo", "bes", "mes", "los", "dos", "os", "eros", "jas", "oss", "outs", "ows", "BS", "zb", "oos"]}}
{"id1": "21425787", "id2": "14598566", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFile", "transferFiles", " copyByte", "CopyFile", "CopyFiles", "Copyfile", " copyFiles", "transferByte", "CopyByte", "copyFiles", "copyfile", "copyByte", " copyfile", "transferfile"], "in": ["inn", "inc", "up", "is", "it", "isin", "old", "din", "source", "b", "i", "gin", "on", "from", "In", "el", "ic", "ins", "en", "IN", "o", "l", "n", "input", "cin", "rin", "ie", "ar", "vin", "inf", "ind"], "out": ["p", "it", "Out", "g", "v", "ex", "nt", "w", "ent", "b", "source", "err", "i", "io", "gt", "c", "po", "ot", "help", "str", "t", "at", "o", "ne", "l", "output", "os", "null", "to", "s", "oss", "outs", "OUT", "net", "n", "ou"], "sourceChannel": ["sourceClass", "srcConnection", " sourceCh", "sourcePanel", "ourceManager", "systemCategory", "startChannel", "sourceMachine", "sourceCommand", "seedCategory", "srcCh", "ourceChannel", " sourceClass", "sourceConnection", "srcCommand", "systemMachine", " sourceManager", " sourceChan", "inputChan", "ourceChan", "inputChannel", "inputCh", "sourceCh", " sourceCommand", "startCategory", "seedMachine", "sourceCategory", "srcChannel", "startPanel", "inputConnection", "sourceManager", "sourceChan", "seedPanel", " sourceConnection", "systemPanel", "srcManager", "ourceCommand", "startMachine", "seedChannel", "srcChan", "srcClass", "systemChannel", "ourceConnection", "ourceClass"], "destinationChannel": ["destationHandler", "restinationchannel", "destationChannel", "DestinationHandler", "restinationChan", "destensionConnection", "DestensionChan", "restinationChannel", "Destensionchannel", "destinoChan", "destinatedChan", "DestationHandler", "destinationsChannel", "destinatedchannel", "destinationHandler", "DestationChan", "destinatorChan", "restinochannel", "destationChan", "DestensionConnection", "restinationContext", "destationContext", "destinoChannel", "destinoContext", "destinatedChannel", "DestensionChannel", "Destationchannel", "destensionChannel", "destensionchannel", "destinationchannel", "destinationsChan", "destinationContext", "destinatorHandler", "DestationChannel", "Destinationchannel", "destinatedContext", "destinatorChannel", "destinationsConnection", "destinatorchannel", "destinochannel", "destationchannel", "restinoChan", "restinoContext", "destensionChan", "DestinationChannel", "destationConnection", "destinationChan", "DestinationChan", "restinoChannel", "destinationschannel", "destinationConnection", "DestinationConnection"]}}
{"id1": "21348951", "id2": "9824814", "code1": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "code2": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"processAddByURLSubmit": ["processAddByURlsubmission", "processAddByURLSumit", "processAddByURLSUBmission", "processAddByURLSUBit", "processAddByURlsubmitted", "processAddByURLSubmitted", "processAddByURLSubsit", "processAddByURLSummit", "processAddByURlsubit", "processAddByURLSubit", "processAddByURlsummission", "processAddByURlsummit", "processAddByURLSummitted", "processAddByURLSubsmit", "processAddByURLSUBmitted", "processAddByURlsubmit", "processAddByURlsummitted", "processAddByURlsumit", "processAddByURLSummission", "processAddByURLSubsmitted", "processAddByURLSubsmission", "processAddByURLSUBmit", "processAddByURLSubmission"], "url": ["mail", "Url", "name", "link", "util", "html", "external", "path", "key", "string", "char", "run", "u", "mount", "file", "location", "ssl", "resource", "email", "bel", "id", "base", "dl", "uri", "force", "web", "http", "nl", "sl", "page", "el", "q", "rl", "str", "impl", "ll", "browser", "address", "ref", "item", "loc", "rect", "un", "l", "URL", "input", "document", "ls", "ur", "use", "ul", "addr"], "invalidUrlMsg": ["invalidUrStr", "inInvalidUrlLog", "invalidStrStr", "invalidUrMessage", "inInvalidURLStr", "invalidUrlMessage", "invalidurlStr", "invalidFileMsg", "invalidurlmsg", "inInvalidStrStr", "invalidUrlmsg", "invalidUrmsg", "invalidStrLog", "invalidURLmsg", "invalidUrLog", "inInvalidUrlMsg", "invalidFileStr", "invalidUrlStr", "invalidFileLog", "invalidURLStr", "invalidURLMsg", "inInvalidStrMessage", "invalidFileMessage", "invalidStrMessage", "invalidUrMsg", "inInvalidStrLog", "invalidurlMsg", "invalidStrMsg", "inInvalidURLMsg", "inInvalidUrlStr", "inInvalidUrlmsg", "inInvalidURLmsg", "inInvalidUrlMessage", "invalidUrlLog", "inInvalidStrMsg"], "xmlSourceWriter": ["xmlStringWriting", "xmlStringCode", "jsonSourceWriting", " xmlSourceReader", " xmlSourceWriting", " xmlSourceBuilder", "xmlSourceWriting", "xmlsourceRW", "xmlSourceReader", " xmlSourceRW", "jsonStringWriting", " xmlSourceWrite", "xmlStringWriter", "jsonSourceCode", "xmlStringReader", "xmlsourceWrite", "xmlSourceFileWriter", "xmlSourceWrite", "xmlSourceFileBuilder", "jsonSourceWriter", "xmlsourceReader", "xmlSourcesCode", "jsonSourceReader", "jsonStringReader", "xmlSourcesReader", "xmlsourceWriter", "jsonStringWriter", "xmlSourceRW", "xmlsourceBuilder", "xmlSourceFileRW", "xmlSourceBuilder", "xmlSourceCode", "xmlsourceWriting", "xmlSourcesWriting", "jsonStringCode", "xmlSourcesWriter", "xmlSourceFileWriting"]}}
{"id1": "10728243", "id2": "7948308", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"scramble411": ["scramblesPassword", "scamblesBasic", "scramble ", "scrambledBasic", "scamblePassword", "scramle ", "scramlePassword", "scrambledpassword", "scrambledPassword", "scramblesBasic", "scrambles ", "scramlepassword", "scramblepassword", "scramleBasic", "scamblesPassword", "scramblePassword", "scrambled ", "scramblespassword", "scamblepassword", "scamble ", "scambleBasic", "scambles ", "scamblespassword", "scrambleBasic"], "password": ["attribute", "key", "string", "pattern", "remember", "auth", "wd", "primary", "description", "message", "database", "hello", "Password", "profile", "email", "data", "padding", "user", "crypt", "sword", "prefix", "hash", "text", "address", "phrase", "words", "word", "shadow", "reset", "pass", "token", "username", "secret"], "seed": ["needs", "sequence", "offset", "key", "df", "initial", "se", "sample", "entry", "rand", "derived", "feed", "eed", "source", "start", "sudo", "sex", "padding", "template", "example", "setup", "Salt", "eder", "prime", "mix", "vector", "sql", "random", "hash", "ser", "create", " seeds", "test", "phrase", "shadow", "reset", " seeded", "index", "secret"], "md": ["sm", "metadata", "msg", "amd", "rd", "dr", "dig", "addr", "def", "cd", "mb", "MD", "nt", "dm", "dh", "mm", "der", "od", "cmd", "grad", "hd", "ind", "managed", "bd", "de", "gm", "sd", "mod", "ad", "multi", "esm", "di", "ld", "rpm", "m", "det", "med", "mind", "pdf", "pm", "mp", "rm", "mg", "img", "desc", "red", "ms", "mn", "d", "pkg", "cm", "nd", "pt", "ma", "mand", "exec", "ann", "dd", "mc", "td", "mt", "ct", "mk", "df", "pd", "sha"], "passwordHashStage1": ["passwordHashSHA1", "passwordHashPage1", "passwordHashSHA2", "passwordHashstage5", "passwordhashStageOne", "passwordHashPhase2", "passwordHashPhase1", "passwordhashStage2", "passwordHashPhase0", "passwordHashStage5", "passwordhashstageOne", "passwordHashSHA0", "passwordHashPage2", "passwordHashstage1", "passwordHashstage0", "passwordhashstage1", "passwordhashStage1", "passwordHashStage01", "passwordhashstage0", "passwordHashStage0", "passwordHashPage5", "passwordHashstageOne", "passwordhashStage0", "passwordHashPhaseOne", "passwordHashSHA01", "passwordHashStageOne", "passwordHashstage01", "passwordHashstage2", "passwordhashstage2", "passwordHashPage0"], "passwordHashStage2": ["passwordHashVersion1", "passwordHashScene3", "passwordHashStage4", "passwordHashstage4", "passwordHashPhaseTwo", "passwordSaltStage62", "passwordHashStyleTwo", "passwordHashPhase2", "passwordHashPhase1", "passwordHashStyle62", "passwordHashStage3", "passwordHashStyle3", "passwordHashVersion2", "passwordHashSceneTwo", "passwordSaltStage3", "passwordHashStyle2", "passwordSaltStage2", "passwordHashstage1", "passwordHashStage62", "passwordHashScene62", "passwordSaltStageTwo", "passwordHashPhase4", "passwordHashVersionTwo", "passwordHashScene2", "passwordHashstage2", "passwordHashstageTwo", "passwordHashVersion4", "passwordHashStageTwo"], "toBeXord": ["toBEXorg", "toBeTxond", "toBeXorg", "toBEXords", "toBeYorg", "toBeZords", "tobeXold", "toBeXLords", "toBEXod", "toBeXLord", "toBeZord", "toBeZXords", "toBeXold", "toBeYold", "toBexorg", "toBeYor", "tobeYord", "tobeYords", "tobeXorg", "tobeXord", "toBEXord", "toBexord", "toBeTxords", "toBeZor", "toBeZXord", "toBeZorg", "toBeXod", "toBexords", "toBeXor", "toBeTxorg", "tobeYor", "toBeXond", "toBexond", "tobeXor", "toBeXLor", "toBeXords", "tobeYorg", "toBeYod", "toBeZXor", "toBEXor", "toBeYords", "toBexor", "toBeZXold", "tobeYold", "toBeYord", "tobeXords", "toBeTxord", "toBEXond", "toBeXLod"], "numToXor": ["numtoXOR", "numToXors", "numToxor", "num2Restors", "num2Xors", "numtoYor", "num2Restore", "numtoXord", "num2XOR", "numToRestors", "numToZore", "numToZor", "numToRestOR", "numToXore", "num2RestOR", "numToRestor", "num2Xore", "numToYord", "numToxors", "numToYOR", "numToZors", "numtoYors", "numToxore", "numtoXor", "numToxOR", "num2Restor", "numtoXors", "num2Xor", "numToXOR", "numToZord", "numToYors", "numToRestore", "numToxord", "numToZOR", "numToYor", "numtoYOR", "numToXord", "numtoYord"], "i": ["ix", "ni", "im", "sequence", "bi", "ip", "init", "span", "ri", "is", "mi", "x", "it", "phi", "gi", "ui", "ji", "si", "g", "ex", "ini", "info", "u", "e", "cli", "\u0438", "k", "io", "ci", "ti", "zi", "multi", "j", "di", "xi", "m", "batch", "uri", "fi", "ii", "y", "ic", "set", "ei", "in", "ms", "qi", "t", "us", "o", "ai", "I", "s", "z", "ie", "pi", "sim", "n", "ind", "li"]}}
{"id1": "16804988", "id2": "22268798", "code1": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "code2": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "label": 0, "substitutes": {"init": [" reload", "icon", "initial", " startup", "ui", "Init", " Init", " gui", "construct", " initialization", "file", "update", "start", "layout", "close", "launch", "uri", " reset", " construct", "create", "load", " constructor", "open", "render", " refresh", "index"], "filename": ["fp", "name", "fps", "metadata", "println", "origin", "path", "mson", "journal", "string", "nm", "jl", "lua", "png", "jpg", "sbm", "fn", "description", "original", "ename", "subject", "src", "fax", "title", "download", "doi", "json", "nil", "file", "source", "location", "ren", "fil", "FILE", "mpeg", "f", "kl", "txt", "kj", "uri", "nl", "stem", "java", "bf", "sql", "prefix", "slice", "summary", "Filename", "xxx", "csv", "fle", "ame", "jj", "word", "wikipedia", "document", "directory", "username", "tp"], "dim": ["im", "dimensional", "shape", "nom", "lim", "mi", "wh", "mat", "height", "def", " dimension", "dm", "ds", "fam", "dx", "div", "gm", "prop", "nam", "dat", "val", "dem", "sam", "di", "coord", "cal", "ext", "m", "Dim", "mode", "sum", "du", "rm", "depth", "ims", "xd", "mem", "late", "mn", "vals", "d", "wid", "dir", "dimension", "tm", "size", "dr"], "w": ["wk", "wa", "W", "ws", "wh", "x", "height", "wd", "g", "v", "a", "nw", "wal", "wr", "aw", "wt", "win", "iw", "fw", "hw", "\u0142", "sw", "m", "we", "wl", "kw", "ew", "wb", "rw", "d", "weight", "l", "work", "wid", "wo", "word", "wp", "width", " dw", "window", "n"], "h": ["hang", "ch", "p", "height", "wh", "x", "ho", "sh", "g", "v", "hr", "hi", "r", "e", "H", "b", "k", "hz", "hw", "f", "kh", "m", "c", "ah", "he", "hh", "y", "ih", "t", "en", "ha", "d", "rh", "l", "z", "th", "ht", "oh", "hd"], "in": ["inn", "al", "inc", "pin", "conn", "kin", "include", "ln", "raw", "mi", "is", "ain", "and", "inner", "isin", "a", "r", "din", "mm", "file", "source", "nin", "bin", "i", "io", "serv", "gin", "on", "f", "from", "In", "body", "or", "st", "ins", "mem", "en", "out", "IN", "o", "l", "con", "ma", "ai", "n", "cin", "input", "rin", "mc", "vin", "inf", "ind"], "ff": ["fp", "tf", "ef", "fed", "fm", "fo", "fn", "eff", "ph", "fx", "uf", "fw", "ld", "fc", "f", "fig", "iff", "ffer", "fi", "fd", "bf", "FF", "lf", "fl", "sf", "xff", "buff", "cf", "ft", "nd", "fe", "aft", "af", "alf", "pdf", "df", "off"], "url": ["mail", "Url", "link", "hl", "external", "pl", "p", "char", "mb", "r", "cl", "mount", "large", "file", "b", "log", "gl", "ssl", "resource", "bel", "f", "kl", "dl", "abs", "uri", "web", "sl", "http", "nl", "rl", "fl", "str", "ll", "ref", "rel", "l", "lr", "www", "URL", "gif", "ls", "ur", "ul"]}}
{"id1": "11183087", "id2": "7761195", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"doPost": ["doPOST", "dopost", " doAdd", " doPOST", "handlepost", " dopost", "doAdd", "handlePOST", "handlePost", "handleAdd", "DoAdd", "DoPost", "DoPOST", "Dopost"], "request": ["server", "model", "subject", "question", "context", "reference", "user", "call", "web", "frame", "collection", "browser", "create", "req", "list", "input", "quest", "document", "register", "QUEST", "url", "version", "begin", "xml", "message", "current", "event", "controller", "start", "result", "project", "the", "report", "http", "address", "position", "connection", "reset", "raw", "remote", "select", "argument", "Request", "hello", "query", "record", "setup", "search", "command", "object", "post", "requ", "re", "require", "print", "handle", "parent", "enter", "initial", "first", "system", "order", "run", "connect", "application", "complete", "law", "forward", "work", "open", "get", "client"], "response": ["view", "server", "image", "resp", "message", "entry", "content", "e", "success", "ve", "context", "next", "one", "respond", "default", "application", "exit", "result", "res", "report", "send", "page", "status", "onse", "frame", "Response", "service", "collection", "environment", "out", "write", "output", "connection", "to", "re", "ce", "reply", "print", "document"], "senha": ["tinhi", "Senwa", "ensenho", "senwa", "Senha", "Senja", "ensenha", " senhi", " senca", " senigma", "renHa", " senhas", "tenha", "renwa", "ensenca", "Senhas", "tenja", "Senigma", "tenwa", "renha", "tinha", "senca", " senho", "tenHa", "senhi", "tinhas", "ensenHA", "senhas", "senho", "Senca", " senHA", "senHa", "senja", "senigma", "SenHa", "senHA", "Senhi", "renja", "tinigma", "SenHA", "Senho"], "email": ["mail", "zip", "name", "url", "external", "path", "domain", "ip", "image", "string", "IL", "enter", "le", "message", "sample", "gmail", "Email", "oe", "lock", "detail", "e", "ails", "label", "file", "hello", "alias", "Mail", "password", "example", "ql", "elly", "echo", "login", "el", "quote", "office", "address", "ne", "line", "ilo", "live", "license", "username", "secret", "addr"], "messageDigest": ["MessageDig5", "MessageDigse", "messagemdest", " messageDigester", "MessageDigEST", "messagemdEST", " messageDigse", "Messagedigest", "messageIGester", "messageDig5", "messagedigse", "messageDer", " messageDiger", " messagediger", "Messagedigse", "messageMDest", "messageIGEST", "messageMDester", "messageIGse", "Messagedig5", "messageMDEST", "messageMDse", "messagemd5", "messageDigester", "messageDigse", "messageIGest", "messagedig5", "messageDigEST", "messagedigester", "messagediger", "MessageDigest", "messagemdester", "Messagedigester", " messagedigester", "messagedigest", "messageDse", "MessageDigester", "messageDester", "messageDiger", " messagedigse", "messagedigEST", " messagedigest", "MessagedigEST", "messageDest"], "usuario": ["usruario", "usuiarial", "usnuarial", "ussuarios", " usuarius", " ussuarius", "usui\u00e9r", "usnuario", "usu\u00e9r", "usruarios", "usuiarios", "cusuarial", "cusuarios", "usurio", "cussu\u00e9r", " usuarial", "cussuarial", "ussuarial", "ussuarius", "usuarial", "ussuario", "uscuino", "usnurio", "usuarius", "usuiario", "cussuarios", " ussurio", "ususrio", " ussuarial", "usruarial", "ussurio", "usruino", "uscuario", "cusuino", "ususarial", " usurio", "cusu\u00e9r", "uscu\u00e9r", " ussuario", "uscuarios", "ususarius", "ususario", "cussuino", "usuino", "ussu\u00e9r", "usnuarius", "cussuario", "usuarios", "uscuarial", "cusuario", "ussuino"], "redirect": ["Rederer", " reddraw", " redir", "edurl", "predirection", "REDirect", "redrict", "Redigate", "reddirect", "redir", "indrict", "redirection", "REDurl", "inderer", "predurl", "edirection", "reddirection", " redirection", "rederer", "redRECT", "REDirection", "predirect", "preddraw", "Redirect", " redurl", "Redrict", "rightirection", "indirection", "edirect", "reddigate", "redurl", "REDir", "RedRECT", "redigate", "rightigate", "reddRECT", "reddraw", "indirect", "edrict", "edir", "Redurl", "Reddraw", "rightRECT", "rightirect", "Redirection", "ederer"], "session": ["metadata", "sid", "cache", "group", "server", "still", "system", "activity", "shared", "task", "current", "cookie", "json", "params", "container", "layout", "context", "ESSION", "local", "data", "trip", "user", "application", "ess", "person", "save", "instance", "sql", "ession", "Session", "store", "environment", "browser", "condition", "relation", "client", "connection", "s", "input", "window", "use", "state"]}}
{"id1": "4618237", "id2": "23452437", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFileAsDisk", "writeFile2File", "writeFilesToDisk", "writeFileAndStream", "writeFiles2File", "writeFileAndFiles", "writeFileAndDisk", "writeFiles2Stream", "writeFiles2Files", "writeFilesToStream", "writeFile2Files", "writeFiles2Disk", "writeFileAsFile", "writeFileToDisk", "writeFilesToFiles", "writeFileAndFile", "writeFileToFiles", "writeFilesToFile", "writeFileAsStream", "writeFileToStream", "writeFileAsFiles", "writeFile2Disk", "writeFile2Stream"], "fin": ["fp", "rf", "fur", "ln", "kin", "init", "fre", "inv", "fn", "ini", "mid", "din", "irm", "han", "syn", "Fin", "fil", "fa", "ran", "FIN", "fw", "fc", "f", "raf", "fi", "lin", "fd", "lf", "ic", "mil", "fl", "in", "details", "normal", "en", "mn", "lo", "focus", "fr", "rin", "jen", "n"], "fout": ["ffou", "fboutput", "ffin", "kOut", " foutput", "foutput", "Fou", "kout", "fou", "ffout", "fpo", "Fout", "fbpo", "tin", "Fin", "fbOut", "tOut", " fpo", "tout", "fbout", "tou", "ffOut", "koutput", "FOut", "kpo", "fOut", " fOut"], "append": ["printf", "bold", "include", "string", "equal", "apply", "animate", "replace", "fail", "add", "vert", "allow", "ended", "grow", "update", "folder", "push", "join", "ends", "express", "ext", "batch", "force", "send", "command", "buff", "flat", "insert", "seed", "csv", "app", "pend", "end", "note", "absolute", "ind"], "inChannel": ["Inchannel", "pinMachine", "inputCategory", "intClient", "iChannel", "outStream", "InStream", " inConnection", "innCategory", "iChan", "insideClient", "sinMachine", "inCommand", "insideChannel", "InChannel", "outCommand", "inListener", "rinListener", "innButton", "inputListener", " inCategory", "rinChannel", "intChannel", "pinCategory", "inClient", "innMachine", "outchannel", "rinCategory", " inCommand", "inMachine", "outChan", "inStream", "inputChan", "inputChannel", "insideSession", "InConnection", "inchannel", "inCategory", "inConnection", "iCommand", "rinChan", " inClient", "sinChannel", "innChannel", " inListener", " inStream", " inChan", "intSession", "insideChan", "pinButton", "sinButton", "outConnection", "inSession", "intChan", "iStream", "sinCategory", "inButton", "inChan", " inchannel", " inSession", "pinChannel"], "outChannel": ["outScope", " outController", " outChan", "outCh", "outController", "invChannel", "invCh", "nameChan", "outputScope", "netMember", "outMember", "nameChannel", "outputchannel", " outCh", "OUTchannel", "netchannel", " outConnection", "outputChan", "outputCh", "OUTChannel", " outScope", "netCh", "outputChannel", "outchannel", "invMember", " outchannel", "outChan", "netController", "userCh", "inchannel", "outputConnection", "OUTChan", "userChannel", "nameConnection", "nameScope", "inCh", "OUTController", "outConnection", "netChan", "inChan", "netChannel", "userMember"]}}
{"id1": "13757855", "id2": "1798720", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "label": 1, "substitutes": {"process": ["execute", "apply", "replace", "task", "display", "add", "run", "parse", "build", "processor", "call", "step", "project", "save", "Process", "create", "load", "loop", "proc", "write", "render", "transform", "processing", "filter", "handle", "format"], "tpl": ["ttopl", "terld", "topl", "timplug", "ttpl", "tpg", "turtle", " tplates", "ptpl", "timpl", "Tph", " turtle", "tspr", "atuple", "Tpl", "stplate", "otpl", "stbl", "tmpp", "tyPL", "templ", "stpg", "tPL", "ptbl", " tpp", "tembl", "tpp", "stopl", "itbl", "itPL", "tsurtle", "tyurtle", "otld", "typl", "ttplug", "itpl", "Tplate", "atld", " tplate", "terplate", "tplate", "tsbl", "stplug", "Tplates", "stpl", "ttpg", "Tspl", "ttph", "tplug", "timspl", "tph", "tpr", "ptld", "Tpp", "timpg", "atplate", " tbl", "stspl", "tmbl", "tspl", "Tld", "timbl", "timopl", "tmpl", "ptplates", "tsPL", "temPL", "tempr", "otplate", "tuple", "Tbl", "ttPL", "tld", "tplates", "itplate", " tld", "tmplate", "terpl", "tmplates", "tmPL", "atpl", " tuple", "TPL", "tbl", "timplate", "Tpr", "ttbl", " tPL", "teruple", " tph", "otbl"], "model": ["html", "parent", "M", "content", "node", "file", "product", "log", "Model", " Model", "data", "record", "project", "m", "base", "Document", "el", "models", "object", "md", " models", "module", "tree", "ml", "document"], "packageName": ["PackageClass", "pkgNames", "PackageRoot", " packageRoot", "viewname", "groupVersion", "groupFamily", "viewRoot", "viewClass", "packageNames", "groupNames", "packagename", "viewName", "packageFamily", " packageNames", "packageVersion", "pkgVersion", " packageClass", "PackageName", " packageFamily", "groupName", "pkgName", "packageClass", "packageRoot", "pkgFamily", "Packagename", " packagename", " packageVersion"], "outFileName": ["outFilename", "infileType", "outFNames", "outFileType", "outFilenameSize", " outFilenamename", "outStreamTime", "outFilenameTime", "outTableName", " outTableName", "outDirSize", "outFileSize", " outFilenamePath", "outTableChain", "outfileNames", "outFilenameName", "outImagePath", "outFilenamename", " outfileNames", "outStreamPath", "outfileTime", "outDirName", " outFileTime", "outDirTime", " outFilenameName", "outfileName", "outFilenamePath", "infileName", "outTableType", "outStreamType", "outfileType", "inFileTime", "outFileChain", " outFileType", "outTableTime", "infileNames", "outFileNames", " outFilePath", "infilePath", " outfileName", "outFPath", " outFilenameType", "outfileChain", "inFileName", "outFilenameChain", "outfilename", " outFileNames", " outFilenameChain", " outfilename", " outFileChain", "outFname", "outFilenameType", "outFileTime", "inFilePath", "outImagename", "outFName", " outfilePath", " outTableTime", " outFilenameSize", " outTablePath", "infileTime", " outTableSize", "outTablePath", " outFilename", "outDirPath", "outFilenameNames", "inFileType", "inFileNames", "outStreamNames", "outImageName", "outfilePath", "outImageSize", " outFileSize", "outFilePath", "outStreamName", "outTableSize", "outTablename"], "xsltParam": ["xsltParameter", "xsslParam", "xltParameter", "xsqlParam", "xltConf", "xsslConf", "xsslParameter", "xsmlParam", "xmlParam", "xsltConf", "xltParam", "xsqlParameter", "xmlConf", "xsmlParameter", "xsqlConf", "xsmlConf", "xmlParameter"], "artifact": ["artifacts", "artificial", "anificate", "ardificate", "ardificial", "artificate", " artificial", " artifacts", " artificate", "Artifacts", "ardifact", "anifacts", "partifact", "anificial", "arifact", "partifacts", "anifact", "Artifact", "arifacts", "ardifacts"], "destinationPath": ["destationDir", "estinationName", "destinerDir", "desturationpath", "desturationPath", " destinationTarget", " destociationDisk", "estinationKey", "desticationDir", "descositoryHost", "destATIONPort", "destociationHost", "destATIONPath", "destinationAt", "estinationPoint", "identinateKey", "destacementTime", "identinatePath", "destinatedTarget", "destificationLocation", "DestinationLocation", "estationPath", "estionPATH", "estationDir", "destinatePart", "destinationPoints", "destinationDisk", "destinatorPoint", "DestensionPath", "generinationAt", "destinationTime", "destinatorPath", "origininatedNow", "destregationpath", " destociationpath", "DestensionHost", "destificationDir", "destinationTemp", "DestensionTemp", "DestensionPod", "generinatePath", "destinoName", "destionPATH", "destinationName", "DestinationTemp", "destinateForm", "destinationJar", "chaininatedDisk", "desturationJar", "destociationPoint", "destinatedDisk", "destinatorParent", "destinantPod", "origininationForm", "generinateJar", "destinateLocation", "destinatedDriver", "destinateInfo", "destinerPart", "destesticSystem", "estinationHost", "destinatorpath", "estinationPATH", "destinateChain", "chaininationHome", "generinationSystem", "destinateUrl", "destinationForm", "destinatePath", "destinoTime", "estionPath", "destionpath", "destinantPath", "destositoryParent", "DestinationHost", "destinateNow", "delinationLog", "delinatePoints", "destociationHome", "destinateAt", "estinoPath", "destitutionPATH", "destitutionPoint", "destinerJar", "delinateForm", "destociationDisk", "destinationParent", "origininatedPath", "termininerTarget", " destinationpath", "generinationPath", "descinationParent", "destationPart", "identinateChain", "destinatedKey", "desticationPath", "destinateSystem", "destigationPath", "destinerSystem", "destacementKey", "DestinationPoint", "destesticJar", "destinationLocation", "destinationPATH", "chaininationDisk", "termininationJar", "delinationPoints", "destositoryPort", "destesticAt", "destinationpath", "destinatorPort", "destinationPart", "estinoKey", "estinoTime", "destationPath", "destinateKey", "destinateDir", "DestensionDir", "destensionTemp", "descinationPort", "destacementPath", "destinatorChain", "destregationDisk", "estinationDir", "delinationPath", "destinoHost", "destociationTarget", "chaininatedDriver", "estinationpath", "destinerAt", "destensionPath", "destociationLog", "destATIONParent", "DestinationPath", "destinationUrl", "termininationPath", "chaininatedPath", "destinatedPath", "destinationPort", "termininationTarget", "destositoryHost", "identinationChain", "generinateAt", "destationUrl", "destinerTarget", "termininationpath", "destinerpath", "destinationHost", " destociationPath", "destregationTarget", "origininationChain", "destinationLog", " destinationDisk", "destrancePoints", "descinationPath", "destensionHost", "destinateName", "destationHost", "estionpath", "destranceForm", "descinationHost", "generinateSystem", "DestificationPath", "destionPoint", "destinatorPATH", "destinatePoints", "destinationTarget", "destinoDir", "destigationNow", "destensionPod", "destinerHost", "destinationKey", "estinationPart", "destinoPath", "destinatedInfo", "destinatorHost", "estinationTime", "destacementName", "destitutionPath", "DestensionPoint", "destinationPod", "destinantTemp", "DestinationDir", "destensionPoint", "DestificationDir", "DestinationUrl", "delinatePath", "origininationPath", "origininationNow", "chaininationPath", "DestinationPod", "destventionDriver", "descositoryParent", "destinatedHome", "desticationPod", "destinationDir", "destranceLog", "descositoryPath", "destensionDir", "identinationKey", "destinateLog", "destinationInfo", "destventionPath", "destventionDisk", "estionPoint", "termininerPath", "generinationJar", "identinationPath", "desticationTemp", "delinateLog", "chaininationDriver", "destificationUrl", "destrancePath", "destinatepath", "destociationDriver", "destociationPath", "destinateJar", "destinationPoint", "chaininatedHome", "destventionHome", "destinationChain", "identinateInfo", "delinationForm", "destationLocation", "destATIONHost", "destinateTarget", "identinationInfo", "destinantDir", "destinateHost", "desturationTarget", "termininerpath", "destociationDir", "destitutionpath", "destociationPoints", "destinatedForm", "destociationForm", "destinationNow", "destigationForm", "destinatedNow", "termininerJar", "destinatedpath", "destinationDriver", "descositoryPort", "destinationSystem", "estationHost", "destociationpath", "destinatedChain", "origininatedChain", "destinoKey", "destositoryPath", "estinationPath", "destinateTime", "destionPath", "destinoPoint", "estinoName", "destigationChain", "destinatorKey", "destinationHome", "destregationPath", "estationPart", "DestificationLocation", "destinerPath", "destesticPath", "origininatedForm", "destificationPath", " destociationTarget", "DestificationUrl", "destinatorInfo"], "in": ["inner", "r", "din", "info", "w", "file", "bin", "i", "io", "id", "f", "m", "c", "In", "ins", "t", "IN", "o", "d", "doc", "l", "input", " IN", "reader", "n"], "out": ["msg", "obj", "println", "up", "cache", "ln", "conn", "go", "ch", "writer", "p", "it", "Out", "inv", "inner", "ex", "v", "nt", "w", "outer", "aos", "dis", "oe", "e", "cmd", "u", "file", "nr", "all", "log", "err", "sys", "ger", "b", "io", "gen", "f", "c", "res", "report", "cfg", "conf", "cn", "or", "ins", "t", "o", "l", "write", "output", "gr", "client", "con", "null", "os", "s", "to", "list", "co", "screen", "OUT", "outs", "net", "print", "can", "n", "raw", "ou"], "root": ["name", "Root", "println", "group", "child", "parent", "initial", "p", "New", "def", "Template", "scope", "se", "r", "parents", "node", "json", "config", "start", "de", "context", "roots", "data", "id", "dump", "m", "_", "impl", "chain", "create", "ok", "table", "dir", "tree", "graph", " roots"]}}
{"id1": "19687456", "id2": "88047", "code1": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testReadPerMemberSixSmall": [" testReadPerMemberSixsmall", " testReadPerMemberSixLarge", " testReadPermemberEightLarge", " testReadPermemberSixLarge", " testReadPermemberSixsmall", " testReadPerMemberEightLarge", " testReadPerMemberEightMember", " testReadPerMembersixSmall", " testReadPerMembersixLarge", " testReadPerMemberEightSmall", " testReadPerMembersixsmall", " testReadPerMembersixMember", " testReadPermemberSixMember", " testReadPermemberSixSmall", " testReadPerMemberSixMember", " testReadPermemberEightsmall", " testReadPerMemberEightsmall", " testReadPermemberEightSmall", " testReadPermemberEightMember"], "gzin": ["znin", "gzgen", "gtnin", "ctxins", "gifIN", "zcin", "gcIn", "gdin", "gdins", "gdcin", "gilpin", "zipisin", "gtins", "resppin", "gtIn", "zagvin", "ctxin", "urgins", "gtgen", "zaginner", "cfgins", "cfgcin", "cfgin", "zaggen", "zagadd", "gifin", "zipin", "gcin", "cfgadd", "gifIn", "gifinner", "gdinner", "respin", "zagcin", "gilvin", "respvin", "gzinner", "gznin", "zagpin", "quscin", "zagin", "gzIn", "qusisin", "ctxIN", "zgen", "gtcin", "urgIN", "gzcin", "urgin", "gzvin", "cliins", "gcins", "gifins", "cliin", "zin", "gzpin", "gcIN", "zagnin", "gtin", "cliIN", "zipcin", "gzadd", "gtIN", "gifadd", "gzisin", "gzIN", "zagins", "gilcin", "qusin", "gzins", "gilin", "gifcin", "gilisin"], "i": ["ix", "im", "ip", "init", "go", "p", "is", "it", "x", "phi", "gi", "ui", "ex", "v", "ini", "index", "u", " j", "ind", "gu", "ci", "me", "multi", "j", "di", "id", "m", "batch", "q", "wait", "y", "ic", "mill", "ms", "qi", "chain", "us", "client", "ai", "I", "pi", "print", "sim", "n", "ii", "li"], "count2": ["found4", "ountTwo", " count5", "count4", "count5", " countTwo", "Count4", "const2", "found2", " count4", " count1", "found1", "Count2", "countTwo", "ount2", "constTwo", "Count1", "count1", "ount5", "const5"], "count3": ["ountThree", "commandthree", "trustthree", "currency3", "currencyThree", "count313", "countthree", "trust43", " countThree", "ount3", " countthree", "count43", "command3", "ount43", "countThree", "ountthree", "ount313", "trust3", " count313", "currency313", "currencythree", "command43"], "countEnd": ["foundend", "CountEnd", "ountEND", "ountEnd", "countEND", "ountend", "foundBegin", "foundEnd", "CountEND", "ountBegin", "detailEND", "countend", " countEND", "Countend", "detailend", "detailBegin", "countBegin", " countend", "detailEnd", "CountBegin", " countBegin", "foundEND"]}}
{"id1": "15262411", "id2": "5135688", "code1": "    String fetch_pls(String pls) {\n        InputStream pstream = null;\n        if (pls.startsWith(\"http://\")) {\n            try {\n                URL url = null;\n                if (running_as_applet) {\n                    url = new URL(getCodeBase(), pls);\n                } else {\n                    url = new URL(pls);\n                }\n                URLConnection urlc = url.openConnection();\n                pstream = urlc.getInputStream();\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        if (pstream == null && !running_as_applet) {\n            try {\n                pstream = new FileInputStream(System.getProperty(\"user.dir\") + System.getProperty(\"file.separator\") + pls);\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        String line = null;\n        while (true) {\n            try {\n                line = readline(pstream);\n            } catch (Exception e) {\n            }\n            if (line == null) {\n                break;\n            }\n            if (line.startsWith(\"File1=\")) {\n                byte[] foo = line.getBytes();\n                int i = 6;\n                for (; i < foo.length; i++) {\n                    if (foo[i] == 0x0d) {\n                        break;\n                    }\n                }\n                return line.substring(6, i);\n            }\n        }\n        return null;\n    }\n", "code2": "    private boolean saveNodeMeta(NodeInfo info, int properties) {\n        boolean rCode = false;\n        String query = mServer + \"save.php\" + (\"?id=\" + info.getId());\n        try {\n            URL url = new URL(query);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            byte[] body = Helpers.EncodeString(Helpers.ASCII, createURLEncodedPropertyString(info, properties));\n            conn.setAllowUserInteraction(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            setCredentials(conn);\n            conn.setDoOutput(true);\n            conn.getOutputStream().write(body);\n            rCode = saveNode(info, conn);\n        } catch (Exception ex) {\n            System.out.println(\"Exception: \" + ex.toString());\n        }\n        return rCode;\n    }\n", "label": 0, "substitutes": {"fetch_pls": ["fetch_cls", "fetch_clls", "fetch_plts", "fetch_repls", "fetch_plls", "fetch_ples", "fetch_reples", "fetch_iplls", "fetch_replts", "fetch_cles", "fetch_clts", "fetch_iplts", "fetch_iples", "fetch_ipls", "fetch_replls"], "pls": [" plt", "bls", "Pls", "ppls", "paterences", "splerences", "plerences", "pats", "Plits", "Plos", "PLjs", "plss", "plits", "plS", "blss", "plis", "PLits", "Plis", "ppt", " plls", "pps", "plt", "PLs", " plS", " plis", " ples", " plerences", "plls", " plos", "flss", "spls", "blS", "iplos", "Plls", "iplls", " plss", "patls", "splls", " pljs", "fls", "fles", "flS", "ipls", "bles", "ples", "Pljs", "plos", "splt", "PLis", "pljs", " plits"], "pstream": ["ppstream", "vpsocket", "pssocket", " pream", " psupp", " pchain", "ppod", "pfile", "ppream", "psocket", " pmount", "Ppipe", "ppipe", "Pstack", "ptStream", "ltime", "phpchain", "lsupp", "vpfile", " psw", " pline", "pream", "vpstream", "pline", "pspod", "phpsw", "phpstream", " ptime", "psupp", "ptstack", "mppod", "ppchain", " ppipe", "pStream", "ptpipe", "ppmount", "PStream", "phpsupp", "phpmount", " pstack", "psfile", "phpline", "pmount", "psstream", "phpream", "psw", "mpfile", "mpsw", " pStream", "ptime", "ptstream", "mpstream", "mpline", "mpsocket", "lstream", "phptime", "lream", "pchain", "pstack", " psocket", "vppod", "phpsocket", "Pstream"], "url": ["mail", "Url", "link", "hl", "util", "conn", "pl", "cert", "org", "xml", "r", "u", "mount", "cl", "log", "gl", "ssl", "host", "email", "bel", "user", "cal", "deb", "f", "dl", "il", "web", "nl", "http", "sl", "el", "rl", "str", "ll", "browser", "address", "ref", "https", "loc", "rel", "l", "open", "client", "con", "ob", "www", "URL", "ml", "ol", "ls", "ur", "window", "cp", "ul"], "urlc": ["urlct", "webcc", "Urlc", "urlC", "webc", " urlcon", "httpc", "charcon", "urlcc", "httpC", "webC", "httpct", "charc", "urlcon", " urlC", "charC", "URLct", "webcon", "UrlC", "Urlct", " urlcc", "urlcs", "URLc", "URLC", "Urlcs", "httpcs", "URLcs", "charcc"], "line": ["port", "mail", "link", "sequence", "lane", "online", "msg", "liner", "ln", "le", "stay", "none", "string", "header", "ine", "char", "continue", "lines", "stream", "message", "sample", "se", "entry", "lock", "detail", "value", "Line", "label", "file", "log", "buffer", "channel", "next", "LINE", "record", "eline", "zero", "note", "comment", "lin", "nl", "valid", "page", "cell", "body", "frame", "range", "normal", "text", "chain", "rule", "out", "no", "phrase", "ne", "lo", "l", "word", "iter", "block", "row", "inline", "print", "ode", "pe"], "foo": ["bits", "printf", "radio", "beer", "some", "bytes", "fax", "fo", "ox", "yy", "oo", "xx", "hat", "apache", "wrong", "config", "hello", "pie", "axe", "bar", "bug", "tab", "xy", "stuff", "mu", "lex", "bool", "flo", "frame", "prefix", "bow", "buck", "coin", "binary", "dirty", "bo", "xxx", "brace", " Foo", "goo", "something", "my", "zx", "aaa", "area"], "i": ["ix", "bi", "cgi", "ri", "key", "oi", "mi", "is", "x", "it", "gi", "phi", "ui", "ji", "si", "ini", "hi", "info", "ami", " j", "u", "iu", "cli", "\u0438", "e", "pos", "start", "ti", "ci", "me", "ori", "zi", "j", "multi", "di", "id", "xi", "num", "m", "uri", "fi", "q", "y", "ei", "ic", "qi", "us", "ki", "l", "length", "ai", "I", "n", "s", "pi", "sim", "index", "ii", "li"]}}
{"id1": "20623709", "id2": "3266833", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "label": 1, "substitutes": {"split": ["scan", "unit", "use", "part", "process", "align", "copy", "lock", "join", "read", "transfer", "parse", "append", "map", "sync", "batch", "scale", "slice", "upload", "write", "share", "disk", "open", "count", "seek", "Split", "format"], "targetDirectory": ["TargetDir", " targetFolder", " targetFile", "targetDir", "targetLocation", "baseFile", "baseDirectory", "baseMemory", "TargetFolder", "testDir", "targetdirectory", "localDirectory", "localdirectory", "baseFolder", "targetMemory", " targetDirect", "testDirect", "baseDirect", "targetDirect", "Targetdirectory", "localFile", "testDirectory", " targetMemory", "TargetLocation", " targetDir", "TargetDirectory", "TargetDirect", "localDir", "targetFile", "testLocation", "basedirectory", "baseDir", " targetLocation", "TargetMemory", " targetdirectory", "targetFolder"], "prefix": ["ix", "name", "PRE", "Pref", "path", "key", "pres", "p", "version", "pattern", "this", "fix", "localhost", "title", "filename", "alias", "template", "padding", "password", "zero", "root", "fixed", "FIX", "base", "division", "type", "uri", "username", "command", "status", "tag", " suffix", "pre", "pkg", "fixes", "size", "pi", "directory", "index", "format"], "maxUnitBases": ["maxUnitLases", "maxUnitbias", "maxUnityBias", "maxUnityAliounds", "maxUnitReplages", "maxUnityLicas", "maxUnityBicas", "maxUnitLounds", "maxUnitChades", "maxUnitbases", "maxUnitReplases", "maxUnityLages", "maxUnitReplicas", "maxUnitBades", "maxUnitBounds", "maxUnitChases", "maxUnitbounds", "maxUnityAliases", "maxUnitReplounds", "maxUnitLicas", "maxUnityAliades", "maxUnityBades", "maxUnitBicas", "maxUnitbades", "maxUnitBias", "maxUnityBounds", "maxUnitAliases", "maxUnitChages", "maxUnitAliias", "maxUnityAliias", "maxUnitBages", "maxUnityBases", "maxUnityLases", "maxUnitAliounds", "maxUnitAliades", "maxUnitLages", "maxUnitChias", "maxUnitChounds", "maxUnitChicas", "maxUnityBages", "maxUnityLounds"], "maxUnitEntries": ["maxunitEntrys", "maxUnitErrs", "maxUnitentrys", "maxUnityEntrys", "maxUnitEntires", "maxUnityEntires", "maxUnitIntegrys", "maxUnityentrs", "maxUnityentires", "maxUnityentries", "maxunitEntires", "maxUnitEntryires", "maxUnitentrs", "maxunitEntrs", "maxUnitIntegries", "maxUnitentries", "maxUnitErries", "maxUnitErires", "maxUnitEntrs", "maxUnityEntrs", "maxUnitErrys", "maxUnitEntrys", "maxUnitEntryriers", "maxUnityentrys", "maxUnityEntries", "maxUnitEntriers", "maxUnitEntryries", "maxUnitentires", "maxUnitEntryrys", "maxunitEntries", "maxUnitIntegires", "maxUnitIntegriers"], "fis": ["viss", "fii", "Fis", "Fci", "fiss", "Fic", "fic", "Fiss", "ifis", "Fii", " fi", " fii", "ific", "fi", " fic", "vis", " fiss", "vi", "Fi", "vic", "ifci", "ifii"], "fci": ["cfico", "mco", "fii", "Fai", "cfai", "Fis", "Fci", "tco", "Fic", "Fini", "Fico", " fini", "mcu", "Fco", "fic", "fico", " fii", "cfis", "tci", " fico", " fcu", " fic", " fai", "mci", "fai", "cfci", "cfic", "fcu", "cfco", "mii", "tii", "tcu", "cfini", "fini"], "fos": ["fOS", " fios", "fbos", "flOS", "yios", "yos", "waos", "yaos", "Faos", "fios", "faos", "flos", "wos", "foss", "Foss", "flaos", " fOS", " faos", "wbos", "Fos", "FOS", "wios", "floss", " fbos", " foss", "ybos"], "fco": ["ccon", " foco", "pci", "Fcon", "pco", "Fci", "tdo", "tco", "Fdo", "cco", "cso", "tcos", "fcos", "Fco", "Fso", "fso", "pso", " fcos", "fcon", "fdo", "pcos", "Fcos", " fdo", "toco", " fcon", "cdo", "Foco", "foco", " fso"], "buffer": ["sequence", "timeout", "cache", "channel", "char", "order", "message", "memory", "sample", "entry", "stack", "flush", "database", "temp", "event", "source", "bridge", "holder", "limit", "black", "buf", "Buffer", "function", "append", "data", "template", "match", "record", "library", "padding", "read", "button", "result", "queue", "batch", "comment", "note", "complete", "command", "pause", "buff", "binary", "address", "phrase", "length", "table", "iter", "position", "block", "row", "reset", "callback", "print", "document", "filter", "window", "index"], "currentBasesCount": ["currentbasesCode", "currentBaseCount", "currentBaseCode", "currentBasesLength", "currentBadesLength", "currentbaseCode", "currentbaseLength", "currentbaseCount", "currentBasesCode", "currentBasedCount", "currentBasedCode", "currentBadesCode", "currentBaseLength", "currentbasesLength", "currentbasesCount", "currentBadesCount", "currentBasedLength"], "currentEntriesCount": ["currentEntrsCode", "currentEntriesFlag", "currentEntrsFlag", "currentEntriesCode", "currentEntrsCount", "currentEntiesCount", "currentEntrysCount", "currentEntiesCode", "currentEntrysCode", "currentEntiesFlag", "currentEntrysFlag"], "targetCount": [" targetAmount", "TargetCount", "targetAmount", " targetInfo", "TargetInfo", "argetNum", "TargetNum", " targetNum", "TargetAmount", "targetNum", "targetInfo", "argetCount", "argetAmount", "argetInfo"], "fastaChannel": [" fastoChan", " fastoChannel", " fastaButton", " fastaProvider", "fastityQueue", "fastoConnection", "fastpaButton", "fastoStream", "fastpaConnection", " fastoStream", "fastaProvider", "fastaStream", "fastpaChannel", "fastoChan", "fastityChannel", "fastaiQueue", "fastaQueue", "fastoChannel", "fastoButton", " fastaChan", "fastityChan", "fastoQueue", " fastaStream", "fastaiChannel", "fastaButton", " fastaConnection", " fastaQueue", "fastaiStream", "fastityStream", " fastoQueue", "fastaChan", "fastpaProvider", "fastoProvider", "fastaiChan", "fastaConnection"], "totalSeqCount": ["totalSeqsCount", "totalSeqCode", "totalSegCode", "totalSeQCounter", "totalSeQSize", "totalSeqSize", "totalSegCount", "totalSeqsCounter", "totalSeqCounter", "totalSeqsCode", "totalSeQCode", "totalSegSize", "totalSeQCount", "totalSegCounter", "totalSeqsSize"], "totalResiduesCount": ["totalResiduationsCode", "totalResiduesCode", "totalResIduesCount", "totalResidusCount", "totalResidueCount", "totalResidueFlag", "totalResIduesFlag", "totalResIduesCode", "totalResidusFlag", "totalResidusCode", "totalResIdueFlag", "totalResidueCode", "totalResIdueCount", "totalResiduesFlag", "totalResiduationsFlag", "totalResiduationsCount", "totalResIdueCode"], "prevTime": ["parTime", "parThread", " prevT", " previousTime", " previousT", "prevThread", " previousThread", "prevT", " prevThread", "parT"], "fastaFileSize": ["fastaFileSIZE", "fastoFileSize", "fastaReaderLength", "fastaReaderHeight", "fastoTableSize", "fastaChainLength", "fastaChainSIZE", "fastATableLength", "fastaTableOwner", "fastoFileSIZE", "fastaFileName", "fastaFilesHeight", "fastafileOwner", "fastoTableOwner", "fastATableSize", "fastATableName", "fastaTableSIZE", "fastATableHeight", "fastafileSIZE", "fastaFileOwner", "fastaTableHeight", "fastaFilesLength", "fastAFileSize", "fastAFileLength", "fastafileSize", "fastoTableSIZE", "fastaTableSize", "fastaChainSize", "fastaFileLength", "fastaTableName", "fastaFileHeight", "fastaTableLength", "fastoTableLength", "fastaReaderSize", "fastAFileHeight", "fastaReaderName", "fastAFileName", "fastafileLength", "fastaChainOwner", "fastoFileOwner", "fastoFileLength", "fastaFilesSize", "fastaFilesName"], "fastaFileReadOffset": ["fastaFilesLoadAmount", "fastaFilesReadAmount", "fastaFileInputAmount", "fastaFileReadPos", "fastaPageLoadAmount", "fastaFileReadAmount", "fastaFileReadOrder", "fastaFileLoadLength", "fastaChainCurrentOffset", "fastaFilereadOffset", "fastaFileLoadAmount", "fastaFileCurrentOffset", "fastaFileInputoffset", "fastaChainCurrentPosition", "fastaChainCurrentLocation", "fastaFilesLoadOffset", "fastaFilesLoadLength", "fastaFilesReadOffset", "fastaChainReadoffset", "fastaFileWriteOrder", "fastaFileCurrentoffset", "fastaFileReadPosition", "fastaFileReadLocation", "fastaFilereadPos", "fastaPageReadOrder", "fastaFileInputLocation", "fastaChainReadLocation", "fastaPageReadOffset", "fastaFileViewAmount", "fastaPageReadPos", "fastaFileInputOffset", "fastaFilesReadLength", "fastaFileReadoffset", "fastaFileReaderoffset", "fastaFileInputOrder", "fastaFileViewOffset", "fastaChainCurrentoffset", "fastaFileViewPos", "fastaFileViewOrder", "fastaFileReaderOffset", "fastaFileWriteAmount", "fastaFileLoadOrder", "fastaFileReaderLocation", "fastaFileInputLength", "fastaFileWriteLength", "fastaFileLoadPos", "fastaChainReadPosition", "fastaPageReadAmount", "fastaFileLoadOffset", "fastaPageLoadOrder", "fastaFileCurrentPosition", "fastaChainReadOffset", "fastaFilereadAmount", "fastaFileReaderPosition", "fastaPageLoadOffset", "fastaFileReadLength", "fastaPageLoadPos", "fastaFileInputPosition", "fastaFilesReadOrder", "fastaFileCurrentLocation", "fastaFilesLoadOrder", "fastaFilereadOrder", "fastaFileWriteOffset"], "partitionStartOffset": ["partitonStartPoint", "partitionDataPoint", "partitonStartingPosition", "partitonStartPosition", "partitionEndPoint", "partitionStartingPoint", "partitonStartingOffset", "partitionDataOffset", "partitonStartOff", "partitionStartingOff", "partitionStartPosition", "partitionDataOff", "partitionDataPosition", "partitonStartOffset", "partitionStartingPosition", "partitonStartingOff", "partitionStartOff", "partitonStartingPoint", "partitionEndOff", "partitionStartingOffset", "partitionStartPoint", "partitionEndPosition"], "bufferSize": ["sequenceSIZE", "buffLength", "BufferSize", "tableSIZE", "bufferName", "bufferCode", " bufferLength", "tableSize", "bufferLength", "bufLength", " bufferCode", "buffSIZE", "tableName", "buffName", "bufSize", "sequenceCode", "tableLength", "sequenceLength", "BufferSIZE", "sequenceSize", "bufSIZE", "bufferSIZE", "BufferName", "BufferLength", "buffSize", " bufferSIZE", "bufCode"], "fastaBuffer": ["fastasBuff", "fastanBuffer", "fastcaBuffer", "fastoBuff", "fastmaCache", "fastsaQueue", "fastmaBuilder", "fastmaQueue", "fastalBuff", "FastmaBuffer", "fastmaRequest", " fastaDB", "fastaCounter", "wildaCache", "fastsaBuffer", "fastmaBuffer", "fastaDB", "FastaBuffer", "fastuBuff", "fastalQueue", "fastasCache", "fastcaCache", "FastaBuff", " fastaMemory", "fastmaStore", "wildanCache", "fastalBuffer", "fastoCounter", "fastoQueue", "fastoRequest", "fastasBuffer", "fastasQueue", "fastaCache", "wildaRequest", "fasteBuff", "fastasBuilder", " fastoQueue", "fastanRequest", "wildaBuff", "fastaRequest", "fastsaChannel", "fastaBuilder", "fasteBuffer", "fastuMemory", "FastmaStore", "fastasCounter", "fastmaBuff", " fastoBuff", "FastmaBuff", " fastoCounter", "fastcaBuff", "fastasRequest", " fastaBuff", " fastaCache", "wildanBuffer", " fastaQueue", "fastuDB", "FastaStore", "FastmaRequest", "fastcaRequest", "wildanBuff", "fastaStore", " fastoBuffer", "fastaMemory", "fastanBuff", "fastuBuffer", "fastsaBuff", "fastalCounter", "FastaRequest", "fastaQueue", "fasteMemory", "wildanRequest", "wildaBuffer", "fastoStore", "fastoBuffer", " fastaBuilder", "fastaBuff", "fastanCache", " fastaCounter", "fastmaChannel", "fasteDB", "fastasStore"], "fastaReadState": ["fastoReadSTATE", "fastaReaderSTATE", "fastoReadStatus", "fastaCurrentStatus", "fastaLoadType", "fastaCurrentState", "fastaLoadState", "fastoReadState", "fastoReaderState", "fastaReaderType", "fastaCurrentSTATE", "fastaReadSTATE", "fastaCurrentType", "fastaReaderStatus", "fastoReaderSTATE", "fastoReaderType", "fastoReaderStatus", "fastaLoadStatus", "fastaReadType", "fastaReaderState", "fastoReadType", "fastaReadStatus", "fastaLoadSTATE"], "nBytes": ["nBlocks", "NParts", " nKeys", "nrBytes", " nNs", "nrKeys", "nWords", "nParts", "nrItems", " nParts", "NKeys", " nbytes", "nsWords", "nKeys", "numbytes", " nItems", "numBytes", "NWords", "nsBytes", "nsParts", "noBlocks", "NItems", " nWords", " nBlocks", "noBytes", "nItems", "numNs", "Nbytes", "noNs", "numBlocks", "nobytes", "nsbytes", "nNs", "NBytes", "nbytes", "nrbytes"]}}
{"id1": "364438", "id2": "19134229", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "conVERT", "consvert", "CONversion", "conversion", "unfer", "converted", "compvert", "compversion", "consversion", "compverts", "Converted", "unversion", "converting", "CONverted", "CONfer", "unvert", "converts", "consVERT", "Conversion", "CONverting", "conprocess", "ConVERT", "CONVERT", "CONvert", "consverting", "Confer", "unverted", "confer", "Conprocess", "unverts", "compprocess", "Convert", "Converts", "unprocess"], "src": ["Source", "scan", "url", "hl", "path", "orig", "attr", "sq", "inst", "addr", "cc", "sin", "rs", "stream", "ource", "href", "sr", "rx", "file", "config", "source", "ebin", "start", "filename", "sys", "SourceFile", "sit", "ipl", "host", "func", "RC", "scene", "iv", "txt", "from", "cont", "uri", "http", "its", "st", "str", "ser", "ins", "cur", "img", "loc", "rel", "usr", "pkg", "buster", "sc", "ur", "req", "rc", "s", "dist", "input", "SOURCE", "rest", "upload"], "dest": ["port", " destinations", "orig", "est", "Dest", "mat", " Destination", "target", "temp", " orig", "source", " destination", "gin", "dat", "result", "txt", " dst", " Dest", "img", "test", "foreign", "write", "table", "tif", "disk", "dir", "dist", "rest"], "in": ["inn", "up", "is", "inner", "stream", "isin", "r", "din", "file", "source", "b", "bin", "i", "io", "serv", "ad", "ar", "m", "from", "res", "In", "el", "sql", "st", "ins", "en", "IN", "d", "l", "input", "cin", "rin", "reader", "as", "inf", "ind"], "p": ["fp", "pc", "php", "pl", "pp", "per", "it", "part", "g", "ps", "r", "pro", "py", "pg", "vp", "b", "ph", "i", "h", "ap", "parser", "P", "parse", "j", "pa", "pd", "f", "m", "lp", "c", "ping", "rep", "pm", "post", "prot", "op", "t", "pre", "er", "pers", "at", "jp", "dp", "d", "pb", "l", "pkg", "wp", "pt", "pi", "sp", "cp", "pe", "tp"], "ds": ["cs", " os", "ports", "drivers", "dh", " ads", "ss", "scripts", "di", "dates", "edes", "sts", " d", "tests", "nas", "dds", "aws", "hd", "obs", "posts", "bs", "rs", "cks", "DS", "ys", "uds", " dd", "eds", "its", "vs", "dp", "d", "os", "terms", "outs", "qs", "dd", "pd", "tp", "ras", "ts", "ods", "Ds", "tes", " DS", "ps", "points", "ils", "gs", "amps", "docs", "xs", "ands", " des", "workers", "lists", "ads", "des", "db", "eps", "dos", "iffs", "dt", "js", "ks", "ls", "mys", "yes", "ws", "gd", "ats", "els", "sets", "ns", "sd", "tags", "loads", "dl", "ags", "s", "hs", "df"], "format": ["name", "unit", "lat", "path", "shape", "version", "it", "settings", "mat", "pattern", "act", "fm", "MAT", "ats", "title", "file", "source", "layout", "parse", "sche", "template", "top", "id", "fc", "f", " Format", "type", "mode", "status", "form", "tag", "feature", "set", "t", "spec", "at", "cf", "table", "output", "module", "l", "policy", "feat", "size", "pretty", "pi", "filter", "mt", "ct", "style", "Format"], "hasPixelData": ["haspixelDATA", "hasFramedata", "HaspixelData", "hasixelData", "hasPixeldata", "hasixelDATA", "hasFrameDATA", "hasFrameData", " hasPixelDATA", "HasPixelDATA", "hasPixelDATA", "HasPixelData", "HaspixelDATA", "haspixeldata", "Haspixeldata", "HasPixeldata", " hasPixeldata", "hasixeldata", "haspixelData"], "inflate": ["Informate", "inFlocate", "informate", "invalidocate", " invalidATE", "inflATE", "inflated", "informated", "inFLated", "infolat", "incelicate", "inFlATE", "informat", "Inflat", "infolated", "invalidicate", "inFLat", "informocate", "incelocate", "Inflocate", "inFlate", "Informocate", "inFLocate", "incelate", "inflocate", "invalidate", "inFLate", " inflocate", "infolate", "inflicate", "invalidATE", "infolocate", "inFlicate", "Informated", " invalidicate", "Inflated", " invalidate", "incelATE", "inflat", " invalidocate", "Inflate", " inflicate", " inflATE", "Informat"], "pxlen": ["packls", "mxdec", "pexlen", "packln", "pxls", "pexfun", "xpden", "mxln", "phpdec", "tmpln", "pxden", "mxlength", "mmlen", "xyln", "mmln", "phpln", "pixellength", "pxdec", "xplen", "pixells", "pexln", "tmplength", "xylength", "cpden", "pxlin", "tmplin", "mmlength", "phplength", "pixelfun", "xylin", "cplength", "mmlin", "packdec", "pxln", "pexlength", "xylen", "tmplen", "xplength", "pxfun", "phplen", "mxlen", "pxlength", "pexls", "pexden", "pixellen", "packlen", "xpln", "packfun", "cplen", "cpln", "packlength"], "out": ["name", "msg", "obj", "group", "up", "conn", "ln", "init", "writer", "gov", "inv", "Out", "ex", "aos", "outer", "temp", "cmd", "log", "err", "sys", "io", "inter", "user", "crit", "res", "cfg", "sum", "store", "prefix", "client", "output", "dir", "gr", "list", "outs", "OUT", "screen", "net", "pretty", "print", "ou"]}}
{"id1": "16621499", "id2": "647224", "code1": "    public static byte[] loadURLToBuffer(URL url) throws IOException {\n        byte[] buf = new byte[4096];\n        byte[] data = null;\n        byte[] temp = null;\n        int iCount = 0;\n        int iTotal = 0;\n        BufferedInputStream in = new BufferedInputStream(url.openStream(), 20480);\n        while ((iCount = in.read(buf, 0, buf.length)) != -1) {\n            if (iTotal == 0) {\n                data = new byte[iCount];\n                System.arraycopy(buf, 0, data, 0, iCount);\n                iTotal = iCount;\n            } else {\n                temp = new byte[iCount + iTotal];\n                System.arraycopy(data, 0, temp, 0, iTotal);\n                System.arraycopy(buf, 0, temp, iTotal, iCount);\n                data = temp;\n                iTotal = iTotal + iCount;\n            }\n        }\n        in.close();\n        return data;\n    }\n", "code2": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "label": 0, "substitutes": {"loadURLToBuffer": ["loadURLToBytes", "loadUrl2Buff", "loadUrlToBuffer", "loadURLtoBuff", "loadURLToBuff", "loadUrlToBuff", "loadURL2Buff", "loadURLtoBuffer", "loadUrlToBytes", "loadUrl2Bytes", "loadURLtoBytes", "loadUrl2Buffer", "loadURL2Buffer", "loadURL2Bytes"], "url": ["mail", "Url", "link", "name", "html", "pl", "cert", "char", "xml", "loader", "r", "job", "file", "location", "b", "log", "gl", "ssl", "bel", "base", "dl", "uri", "web", "http", "nl", "page", "sl", "el", "str", "ll", "browser", "address", "l", "open", "URL", "ls", "ur", "ul"], "buf": ["bn", "msg", "cap", "cv", "tr", "bc", "tx", "bs", "cb", "bh", "bl", "nt", "seq", "nb", "cmd", "b", "div", "buffer", "log", "uf", "dat", "Buffer", "tmp", "capt", "conv", "box", "bar", "bp", "queue", "batch", "txt", "axe", "bu", "arr", "mu", "br", "font", "str", "bag", "img", "Buff", "buff", "bo", "pkg", "vec", "db", "ctx", "bt", "rb", "cat", "fb", "desc", "mus", "bytes", "BU"], "data": ["cache", "obj", "p", "info", "content", "partial", "buffer", "dat", "di", "res", "set", "str", "text", "no", "bo", "table", "count", "list", "name", "msg", "ata", "part", "def", "ret", "message", "div", "result", "done", "type", "size", "raw", "this", "a", "nt", "value", "json", "all", "tmp", "zero", "step", "batch", "arr", "good", " DATA", "out", "length", "output", "total", "null", "missing", "bytes", "initial", "image", "it", "action", "bus", "dec", "bin", "results", "next", "default", "map", "txt", "only", "mu", "br", "item", "buff", "rel", "to", "DATA", "format"], "temp": ["util", "tem", "cache", "unit", "nom", "tr", "EMP", "vol", "ret", "dest", "v", "tc", "current", "copy", "mm", "deg", "partial", "pos", "div", "alt", "buffer", "unt", "tt", "variable", "tmp", "dat", "Temp", "mod", "template", "ptr", " Temp", "rem", "result", "txt", "fake", "tim", "tar", "mp", "font", "ta", "porary", "t", "buff", "mem", "pre", "test", "term", "met", "pt", "null", "em", "tm", "mont", "emp"], "iCount": ["piTotal", "diCounter", "jcount", "intNow", "iniMark", "iCounter", "aiCounter", "giTotal", "phiMark", "iiNow", "ciTotal", "piCount", "ciCP", "diCount", "iNow", "biCode", "giCheck", "iMark", "jLength", "giCount", "iniCount", "intProcess", "iiTotal", "biCount", "iuCount", " icount", "phiCount", "uiCounter", " iCode", "giCounter", "aicount", "iiCounter", "iCheck", "liTotal", "dicount", "piCP", "jTotal", "iProcess", "iCall", "piCounter", "liCount", " iCheck", "iiProcess", "iriCount", "liCounter", " iLength", "piLength", "iiCategory", "iniNumber", "iuCP", "icount", "iCategory", "uiCount", "uiTotal", "iriNow", "iuTotal", "phiLength", "iiCall", "aiLength", "iuCounter", "iCode", "iniLength", "iCP", "iLength", "iNumber", "aiCount", "biTotal", "biCheck", "jCount", "aiTotal", " iMark", "giCode", "liCall", "phiNumber", "iriCategory", " iCounter", "diTotal", "uiCall", "intCategory", "giLength", "ciCounter", "ciCount", "iiCount", "intCount", "iriProcess", " iNumber"], "iTotal": ["jtotal", "piTotal", "uiFull", "miCurrent", " iNow", " iLast", "iiZero", "miToken", "ditotal", "mitotal", "ciTotal", "piCount", "iLast", "iitotal", "ciAll", "diCount", "iNow", "liParent", " iZero", "iuNew", "piDone", "phiTotal", "phiNew", "liLast", "aiToken", "miAll", "aiComplete", "iTemp", " itotal", " iTarget", "iiTotal", "diNow", "imTotal", "iDone", "miLast", "liTotal", "jTotal", "liCount", "piFull", "miTarget", " iTemp", " iFull", "miComplete", "iuLast", "iAll", "iToken", "miTotal", "ciToken", "miZero", "itotal", "uiTotal", "ciComplete", "iuTotal", "jCurrent", " iDone", "iParent", "imCount", "iZero", "phiLast", "iComplete", "piParent", "jZero", "iuTarget", "liNew", "jCount", "aiTotal", "jNow", " iCurrent", "uiDone", "diTotal", "iNew", "aiAll", " iNew", "liTemp", "iCurrent", "iiCount", " iParent", "phiTemp", "iTarget", "imZero", "imtotal", "iFull", "miNew"], "in": ["inn", "al", "inc", "up", "is", "it", "per", "and", "inner", "isin", "v", "add", "r", "din", "info", "mm", "b", "bin", "i", "h", "io", "serv", "on", "from", "In", "conf", "sum", "or", "ic", "check", "ins", "en", "out", "mn", "IN", "by", "l", "get", "con", "ma", " din", "cin", "input", "re", "mc", "reader", "inf", "ind"]}}
{"id1": "949327", "id2": "12380475", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"f": ["fp", "name", "rf", "fab", "tf", "path", "exp", "fed", "p", "it", "def", "ret", "fm", "fax", "fo", "fn", "v", "g", "F", "info", "r", "w", "e", "file", "b", "filename", "h", "fx", "fa", "j", "fw", "fc", "m", "c", "base", "fs", "fi", "fd", "elf", "q", "bf", "lf", "y", "form", "t", "sf", "test", "o", "d", "cf", "l", "ft", "dir", "n", "fac", "fr", "fb", "df"], "in": ["inn", "im", "al", "inc", "up", "init", "ac", "is", "it", "inner", "isin", "ex", "add", "r", "din", "info", "mm", "all", "make", "nin", "bin", "h", "log", "io", "gin", "local", "on", "m", "from", "again", "In", "ic", "ins", "t", "en", "er", "IN", "at", "o", "by", "l", "lo", "get", "iter", "ai", "con", "n", " din", "ma", "cin", "rin", "input", "re", " IN", "pi", "reader", "inf", "oin", "ind", "thin"], "cbuf": ["cfuf", "rbbuf", "bcuff", "rboff", "abbbuf", "rbuf", "cduff", "cbdf", "cbbf", "cduf", "rbfg", "cdbuf", "CBf", "cbf", "cdoff", "sbbuf", "cfuff", "sbuff", "CBbuf", "nbbuf", "nbuff", "cduffy", "cbuff", "cff", "gbf", "sbuf", "rbather", "abbdf", "cfbf", "CBuffy", "CBbf", "gbbf", "nbfg", "rbuff", "CBuff", "sbather", "bcdf", "rbuffy", "gbuf", "bcfg", "cbuffy", "cbfg", "abbfg", "gbuff", "CBuf", "cbbuf", "cbather", "bcather", "rbdf", "cboff", "abbuf", "bcbuf", "nbuf", "bcoff", "bcuf"], "read": ["scan", "link", "is", "stream", "ready", "old", "reads", "pack", "buffer", "io", "data", "ly", "ead", "saw", "set", "range", "text", "miss", "iter", "count", "core", "end", "seek", "skip", "input", "readable", "trust", "index", "pe", "ind", "READ", "clear", "est", "ignore", "bind", "height", "fail", "ret", "current", "r", "start", "error", "sync", "report", "send", "poll", "depth", "mem", "Reader", "slow", "hold", "row", "ink", "raw", "view", "ip", "orig", "burst", "select", "find", "reach", "reading", "se", " Read", "ed", "value", "hello", "query", "rank", "k", "parse", "give", "record", "rate", "dev", "mix", "ank", "wait", "q", "chain", "load", "test", "length", "ke", "ai", "roll", "re", "print", "handle", "key", "it", "x", "add", "shift", "run", "connect", "allow", "feed", "log", "close", "default", "ext", "think", "check", "play", "pre", "write", "ok", "open", "get", "need", "reader", "n", "fill", "Read"], "totRead": ["tottWrit", "totalCheck", "totReader", "ltotRead", "toteAdd", "toteFind", "tcotDisplay", "atotaPrint", "tottNeed", "notaLoad", "trotRead", "totNeed", "trotFind", "retotReader", "ttottAdd", "tiatFill", "tOTFind", "totaBuild", "tokLoad", "notPrint", "totCheck", "tacotCheck", "taotConnect", "tfatWrite", "totPrint", "tobyPrint", "totAdd", "notalLoad", "tottAdd", "totaLoad", "totaFind", "tOTRead", "tiatVal", "notRead", "tiotBreak", "totaNeed", "notalNeed", "totBreak", "tiotVal", "ptotFind", "tottedRead", "trotWrite", "ttottNeed", "taotRead", "taotDisplay", "totalWrite", "totWrit", "totalLoad", "tobyCheck", "ptotWrite", " totRun", " totLength", "tiotFill", "totalFind", "tobyNeed", "ptOTFind", "retotRead", "tobyLoad", "tcotSend", "totaDisplay", "toteWrite", "tootRead", "tootConnect", "tiatSend", "ttotNeed", "retottPrint", "totalNeed", "tcotCheck", " toteRead", "letrotFind", "tootCheck", "atotaFill", "toiotRead", "totalLength", "letotSee", "totHave", " totalRead", "letrotSee", "taotCheck", "notalCheck", "ltotBuild", "tootDisplay", " totFind", "ptOTLoad", "tacotConnect", "tottReader", "tiotRead", " totalBuild", "ttotRead", "tootBreak", "tootVal", "tcotBreak", "tcotConnect", "tottWrite", "notaRead", "totaCheck", "totRun", "tiotHave", "atotHave", "ptOTWrite", "tiatBuild", "letotFind", " toteFind", "totSend", "toteNeed", "trotSee", "tokFind", "ptotLoad", "totalSee", "notCheck", "tcotVal", "totaRead", "toiotSend", "totVal", "totaPrint", "notReader", "totedHave", "tottedReader", "tiotSend", " toteRun", "tacotRead", "totFill", "tacotDisplay", "toteReader", "totaConnect", "totaLength", "tobyWrite", "tiatLoad", "toteLoad", " totBuild", "tiotReader", "tottRead", "atotaHave", "totDisplay", "toteRead", "totaAdd", " totWrite", "ptotRead", "ltotFill", "notalRead", "totaHave", "toticRead", "tokWrite", "tiatRead", "tottRun", "tOTLoad", "totConnect", "totSee", "tOTWrite", "ttotWrite", "toiotBreak", "notLoad", "totedPrint", "toteRun", "letrotRead", "letrotWrite", "tottedWrit", "totalBuild", "notWrite", "atotPrint", "tiotPrint", "totLoad", "toiotVal", "retottWrit", "toteFill", "toteBuild", "ltotaRead", "totLength", "letotRead", "toticWrite", "totalPrint", "totWrite", "atotaRead", "tiotWrit", "notalPrint", "retotPrint", "retottReader", "atotRead", "ltotaLoad", "ltotaFill", "totaReader", "tiatBreak", "tcotRead", " totalWrite", "totaSee", "ltotLoad", "totedRead", "notalWrite", "tootSend", "ltotaBuild", "totalRead", "toticFind", "notNeed", "atotFill", " totalLength", "notaReader", "totaFill", "tokRead", "toteLength", "totBuild", "tOTNeed", "tobyRead", "ptOTRead", "tottFind", "letotWrite", "tottPrint", "ttottRead", "notaWrite", "tfatReader", " toteWrite", "totaWrite", "retotWrit", "ttottWrite", "toticRun", "totedFill", "retottRead", "tfatRead", "totFind", "tfatLoad", "ttotAdd", "tottedPrint"], "out": ["auto", "obj", "up", "ch", "writer", "Out", "g", "ex", "v", "r", "w", "aos", "b", "sys", "log", "io", "conv", "c", "res", "we", "or", "t", "at", "o", "OU", "write", "output", "con", "os", "to", "oss", "end", "co", "s", "outs", "OUT", "net", "n", "ou"], "i": ["ix", "im", "php", "p", "is", "phi", "ui", "v", "hi", "info", "ski", "io", "ci", "multi", "di", "uri", "ei", "set", "ic", "ity", "qi", "ico", "I", "my", "sim", "ia", "index", "ind", "ii", "si", "r", "integer", "e", "iu", "point", "xi", "m", "iii", " I", "ki", "ice", "ip", "ri", "you", "this", "g", "mm", "\u0438", "cli", "me", "zi", "id", "c", "q", "y", "ims", "ij", "chain", "o", "ai", "ie", "print", "bi", "init", "oi", "any", "mi", "it", "x", "gi", "ji", "ini", "ami", "um", "b", "ion", "ti", "j", "iy", "status", "PI", "t", "us", "l", "client", "to", "s", "pi", "iq", "dr", "li"]}}
{"id1": "2381663", "id2": "12417893", "code1": "    @Test(expected = GadgetException.class)\n    public void malformedGadgetSpecIsCachedAndThrows() throws Exception {\n        HttpRequest request = createCacheableRequest();\n        expect(pipeline.execute(request)).andReturn(new HttpResponse(\"malformed junk\")).once();\n        replay(pipeline);\n        try {\n            specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n            fail(\"No exception thrown on bad parse\");\n        } catch (GadgetException e) {\n        }\n        specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"malformedGadgetSpecIsCachedAndThrows": ["malformedGadgetSpecIsCachedAndThrown", "malformedGadgetSpecIsCachedandthrown", "malformedGadgetSpecIsCachedAndrethrows", "malformedGadgetSpecIsCachedAndrethows", "malformedGadgetSpecIsCachedandthThrow", "malformedGadgetSpecIsCachedAndthows", "malformedGadgetSpecIsCachedAndThows", "malformedGadgetSpecIsCachedAndrethThrow", "malformedGadgetSpecIsCachedandThrown", "malformedGadgetSpecIsCachedandthrows", "malformedGadgetSpecIsCachedAndthThrow", "malformedGadgetSpecIsCachedAndthrows", "malformedGadgetSpecIsCachedandThThrow", "malformedGadgetSpecIsCachedandThrows", "malformedGadgetSpecIsCachedandThows", "malformedGadgetSpecIsCachedAndrethrown", "malformedGadgetSpecIsCachedandthows", "malformedGadgetSpecIsCachedAndThThrow", "malformedGadgetSpecIsCachedAndthrown"], "request": ["url", "response", "ip", "initial", "p", "first", "task", "this", "xml", "message", "Request", "query", "question", "resource", "context", "next", "parse", "reference", "record", "map", "call", "result", "project", "report", "http", "q", "command", "instance", "object", "frame", "create", "condition", "forward", "client", "req", "requ", "input", "pull", "quest", "document", "pair"]}}
{"id1": "11865906", "id2": "17947247", "code1": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String postURL(String urlLocation, ArrayList headers, String content, HashMap postVariables, RenderEngine c) throws Exception {\n        String postContent = null;\n        if (postVariables != null) {\n            boolean firstElement = true;\n            postContent = new String();\n            Iterator elements = postVariables.keySet().iterator();\n            while (elements.hasNext()) {\n                String key = (String) elements.next();\n                String val = (String) postVariables.get(key);\n                if (firstElement) {\n                    postContent += Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                    firstElement = false;\n                } else {\n                    postContent += \"&\" + Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                }\n            }\n            elements = null;\n        } else {\n            postContent = content;\n        }\n        Debug.log(\"Connecting to URL '\" + urlLocation + \"', content '\" + postContent + \"'\");\n        URL url = null;\n        try {\n            url = new URL(urlLocation);\n        } catch (MalformedURLException e) {\n            Debug.log(\"Unable to retrieve URL '\" + urlLocation + \"': \" + e.getMessage());\n            return null;\n        }\n        StringBuffer lines = new StringBuffer();\n        HttpURLConnection conn = null;\n        boolean contentLengthFound = false;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            loadCookies(urlLocation, conn, c);\n            if (headers != null) {\n                for (int i = 0; i < headers.size(); i++) {\n                    String header = (String) headers.get(i);\n                    String key = header.substring(0, header.indexOf(\":\"));\n                    String value = header.substring(header.indexOf(\":\") + 2);\n                    if (key != null && key.equalsIgnoreCase(\"content-length\")) {\n                        contentLengthFound = true;\n                    }\n                    Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                    conn.setRequestProperty(key, value);\n                }\n            }\n            if (!contentLengthFound) {\n                Debug.log(\"Adding new request header 'Content-Length'='\" + postContent.length() + \"'\");\n                conn.setRequestProperty(\"Content-Length\", Integer.toString(postContent.length()));\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(postContent);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                lines.append(line);\n                lines.append(\"\\r\\n\");\n            }\n            handleHeaders(urlLocation, conn.getHeaderFields());\n            wr.close();\n            rd.close();\n            wr = null;\n            rd = null;\n        } catch (IOException e) {\n            if (conn != null) {\n                lines = new StringBuffer();\n                try {\n                    throw new Exception(\"Server returned error code '\" + conn.getResponseCode() + \"': \" + conn.getResponseMessage());\n                } catch (IOException ee) {\n                    throw new Exception(\"Unable to report error codes: \" + ee.getMessage());\n                }\n            }\n            Debug.log(\"I/O Exception occurred while communicating with endpoint: \" + e.getMessage());\n            return lines.toString().trim();\n        } catch (Exception e) {\n        }\n        url = null;\n        conn = null;\n        return lines.toString().trim();\n    }\n", "label": 0, "substitutes": {"testIdentification": ["Testidentifier", "testidentify", "testidentication", "testIdification", "Testidentification", "TestIdentifier", "TestIdentication", "testIdify", "testIdication", "testIdentifier", "testidentification", "testIDENTify", "Testidentication", "TestIdentify", "TestIdentification", "testIdentication", "testIdentify", "testIDENTification", "Testidentify", "testidentifier", "testIdifier", "testIDENTication", "testIDENTifier"], "username": ["attribute", "name", "character", "url", "lead", "metadata", "knife", "NAME", "initial", "key", "uno", "string", "approximately", "about", "operator", "owner", "wordpress", "subject", "localhost", "pai", "title", "unknown", "rue", "your", "hello", "admin", "uid", "sudo", "filename", "source", "author", "twitter", "blood", "information", "\u4eba", "email", "minimum", "profile", "taker", "project", "phone", "person", "displayText", "login", "uri", "pty", "otype", "impact", "ubuntu", "sword", "instance", "john", "prefix", "language", "albeit", "ername", "component", "term", "position", "USER", "connection", "latest", "account", "dn", "token", "seat", "assuming", "stab", "human"], "password": ["attribute", "picture", "power", "REDACTED", "string", "height", "pattern", "PASS", "auth", "remember", "confirmed", "description", "message", "entry", "device", "database", "value", "number", "hello", "Password", " Password", "profile", "email", "padding", "application", "comment", "login", "crypt", "command", "sword", "hash", "python", "language", "address", "phrase", "definition", "words", "word", "shadow", "account", "reset", "pass", "token", "secret"], "md5": ["sha7", "MD2", " md2", "md3", " Md512", " Md3", "sha5", "md7", "md4", "sha512", " md512", " Md7", "dig5", "md512", "sha3", " md7", "MD5", " md4", "md2", "dig3", "dig2", "digol", " mdol", " md3", "MDol", "MD4", "MD3", "mdol", "sha4", " Md5"], "logServiceMock": ["logServicePOCK", "logServiceVocks", "logServicemlock", "logStorePOCK", "logServicePocker", "logServiceVocked", "logServiceMlock", "logServiceVock", "logServMock", "logServicemck", "logServiceMulock", "logServiceVocker", "logServMTlock", "logServiceMTlock", "logServiceManocked", "logServiceManocker", "logStoreMox", "logServiceDock", "logServicePock", "logServiceMox", "logServicemocks", "logServiceMTock", "logServiceMTocked", "logServMTock", "logStorePock", "logServicemex", "logServiceJMock", "logServiceDex", "logServiceMuock", "logServiceVex", "logServiceMMocker", "logStoreMOCK", "logServiceJMocked", "logServMlock", "logServiceJMocker", "logServiceMXocker", "logServiceMocked", "logServiceDocked", "logServiceManock", "logServicemocked", "logServiceMXocked", "logServiceMOCK", "logStorePocker", "logServicemOCK", "logStoreMock", "logStoreMocker", "logServicemox", "logServiceMuck", "logServiceMMOCK", "logServiceMex", "logServiceMXock", "logServiceManocks", "logServiceMck", "logServMTck", "logServiceMTck", "logServiceMMox", "logServMTocked", "logServicemock", "logServicePox", "logServiceMocks", "logServMck", "logStorePox", "logServiceMocker", "logServMocked", "logServicemocker", "logServiceMMock", "logServiceMuocked", "logServiceDocker"], "dbServiceMock": ["dbServiceSaj", "dbServicesMocked", "dbFactoryMXck", "dbServiceMox", "dbFactoryMXocked", "dbServiceSocked", "dbServiceTocked", "dbServicesMaj", "dbServiceMXocks", "dbServicemike", "dbFactoryMXocks", "dbServicemocks", "dbServiceHMock", "dbServiceMocks", "dbServiceTrap", "dbServicemocked", "dbStoreMox", "dbServiceMike", "dbFactoryMocked", "dbServiceHMox", "dbServiceTox", "dbServiceSocker", "dbServicemox", "dbServiceMonock", "dbServiceVock", "dbServicemck", "dbServiceJMock", "dbServiceHMess", "dbServiceSike", "dbServicemess", "dbStoremocked", "dbServicesmocked", "dbServiceVrap", "dbServiceHMocked", "dbStoremrap", "dbServicesMike", "dbStoreMock", "dbServiceMonocker", "dbServiceMaj", "dbServiceMick", "dbServiceTock", "dbServiceMXck", "dbServiceMonox", "dbServicesmike", "dbServiceMonick", "dbFactoryMocks", "dbServiceMess", "dbServiceJMaj", "dbFactoryMck", "dbServiceMck", "dbStoremox", "dbServiceVocks", "dbStoreMrap", "dbServiceVck", "dbServiceVocked", "dbStoreMocked", "dbServiceJMocked", "dbFactoryMXock", "dbServiceMXocked", "dbServicemocker", "dbServicemock", "dbServiceVox", "dbServicesmaj", "dbServiceMrap", "dbServiceMocker", "dbServiceJMike", "dbServiceMocked", "dbServiceSick", "dbServiceMXock", "dbServiceMonocked", "dbServicesmock", "dbServiceMoness", "dbServicemrap", "dbServicesMock", "dbServicemaj", "dbServicemick", "dbFactoryMock", "dbStoremock", "dbServiceSock"], "user": ["name", "response", "other", "key", "User", "system", "per", "char", "auth", "owner", "message", "usage", "entry", "menu", "u", "prof", "temp", "entity", "json", "uid", "author", "read", "profile", "record", "result", "plugin", "comment", "person", "actor", "usa", "report", "role", "responsible", "instance", "form", "body", "object", "rule", "contact", "usr", "by", "write", "component", "client", "output", "word", "null", "USER", "account", "core", "creator", "to", "list", "reply", "student", "used", "use", "human"]}}
{"id1": "12766377", "id2": "3945236", "code1": "    public Document index() throws CrawlingException {\n        log.debug(\"BEGINIG indexing page [code=\" + getCode() + \"] ...\");\n        URL url = null;\n        InputStream in = null;\n        String contentType = null;\n        try {\n            url = new URL(getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath());\n            HttpURLConnection pageContent = (HttpURLConnection) url.openConnection();\n            if (pageContent.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                log.debug(\"page pk[\" + getCode() + \",\" + url.toExternalForm() + \"] is invalid\");\n                return null;\n            }\n            String redireccion = pageContent.getHeaderField(\"location\");\n            if (redireccion != null) {\n                log.debug(\"Page \" + url.toExternalForm() + \" redirected to \" + redireccion);\n                recordLink(redireccion);\n                return null;\n            }\n            contentType = pageContent.getContentType();\n            in = new BufferedInputStream(pageContent.getInputStream(), 32768);\n        } catch (MalformedURLException e) {\n            log.error(\"Invalid page address\", e);\n        } catch (ConnectException e) {\n            if (getServer() != null) {\n                log.error(\"Unable to connect to page: \" + getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath(), e);\n            }\n        } catch (UnknownHostException uhe) {\n            log.warn(\"Unknow host indexing page \" + getURL(), uhe);\n        } catch (IOException e) {\n            log.warn(\"Unable to index page \" + getURL(), e);\n        }\n        Document doc = generateDocument(contentType, in);\n        log.debug(\"END indexing page [code=\" + getCode() + \"]\");\n        return doc;\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"index": ["access", "scan", "link", "execute", "view", "html", "version", "image", "find", "suggest", "display", "process", "se", "xx", "connect", "download", "node", "query", "update", "author", "read", "archive", "build", "parse", " Index", " ingest", "search", "evaluate", "service", "create", "address", " analyse", "insert", "review", "write", "open", "tree", "blog", "list", "show", "Index", "print", "document", "ind", " indexed"], "url": ["mail", "Url", "link", "hl", "util", "server", "pl", "path", "cert", "html", "p", "org", "char", "xml", "loader", "r", "mount", "cl", "lb", "b", "location", "log", "gl", "ssl", "resource", "build", "bel", "user", "kl", "dl", "il", "base", "uri", "github", "web", "http", "nl", "sl", "el", "rl", "str", "impl", "fl", "t", "browser", "address", "ll", "https", "loc", "au", "rel", "un", "ref", "l", "get", "lr", "www", "URL", "ml", "ls", "ur", "ul", "addr"], "in": ["inn", "pc", "inc", "up", "is", "it", "ain", "inv", "inner", "xml", "isin", "ini", "r", "din", "file", "min", "bin", "asin", "i", "io", "gin", "on", "m", "from", "po", "In", "conf", "sum", "ins", "t", "en", "out", "er", "IN", "o", "l", "con", "s", "cin", "input", "rin", "mc", "ar", "as", "inf", "ind"], "contentType": ["conditionTyp", "conditionType", " contentStyle", "ontentLength", "contentCode", "contentTypes", " contentTyp", "ContentLength", "contentFormat", "ontenttype", " contentLength", "documentCode", "commentTyp", "Contenttype", "ontentType", "commentType", "contenttype", "documentLength", " contentCode", "ContentTypes", "contentLength", "commentFormat", "contentStyle", "conditionFormat", "contentTyp", "ContentType", "ontentTypes", " contenttype", "documentType", " contentFormat", "ContentCode", " contentTypes", "conditionStyle", "commentStyle", "documentTypes"], "pageContent": ["wikiCa", "articleComment", "contentContents", "serverComment", "pageComment", "pageOne", "pixelOne", " pageComment", "contentSync", " pagecontent", "articleSync", "pixelCa", "profileContents", "articlecontent", " pageOne", "profileComment", " pageAuth", "serverContext", " pageConn", "pixelContent", "PageContents", " pageContents", "contentComment", "PageAuth", "profileContext", "articleContent", "articleAuth", "pagesContent", "contentContent", "resultContent", "resultConn", "pagesCode", " pageCode", "resultCode", "resultContents", "pageConn", "wikiContent", "PageContent", "serverContent", "pageAuth", "pageCa", "pagesConn", " pageSync", "pagesContents", "profileContent", "serverContents", "articleContents", "wikiOne", " pageCa", "pageContext", "pageCode", "wikicontent", " pageContext", "Pagecontent", "pageSync", "pageContents", "pagecontent", "pixelcontent"], "redireccion": ["redirencension", "redoreccions", "redileccison", "redirecedison", "redorecION", "redIREncion", "redirequestison", "redireccao", "redilencension", "redilencion", "redirecsison", "redorecion", "redirecsension", "redoreccION", "redIREcciton", "redoreccison", "redirecions", "redileccion", "redirepcison", "redireccions", "redirecciton", "redorecison", "redIREnciton", "redirecedion", "redirequestion", "redirecsion", "redIREccION", "redireccION", "redirencion", "redIREccion", "redorecions", "redirecION", "redirencison", "redirebcao", "redirecison", "redirencION", "redilecciton", "redirecsION", "redireccension", "redirecion", "redirenciton", "redirecedension", "redileccension", "redirepcION", "redirebcison", "redirebciton", "redIREncison", "redireccison", "redirecsiton", "redIREccison", "redirequestiton", "redilencison", "redirencao", "redileccao", "redirecsao", "redirebcion", "redilencao", "redirepcions", "redIREncION", "redilenciton", "redirequestION", "redirecediton", "redirepcion", "redoreccion", "redirecsions"], "doc": ["msg", "html", "exp", "tx", "it", "mat", "def", "xml", "nt", "content", "article", "dec", "ent", "file", "de", "log", "DOC", "Doc", "m", "Document", "po", "pdf", "oc", "coll", "cam", "page", "good", "pic", "st", "md", "t", "out", "dc", "d", "db", "word", "tree", "document", "dr", "mk", "df"]}}
{"id1": "2834524", "id2": "18782385", "code1": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"write": ["zip", "link", " overwrite", "println", " rewrite", "apply", "commit", "add", "flush", "download", "lock", "file", "update", "rite", "read", "next", "append", "export", "dump", "save", "check", "service", "Write", "create", "end", "print", "filter", "handle"], "jarOut": ["pkgOut", "JarOut", " jarOutput", "JarIn", "JarOver", "pkgIn", "jamNet", "javaStore", "jarNet", " jarIn", "Jarout", "javaGen", "browserOut", " jarGen", "jarOutput", "javaOutput", "pkgOver", "JarStore", "browserIn", "jamIn", "JarGen", "jamOut", "jarout", "javaOut", "JarOutput", " jarout", "jarIn", "jamOver", "JarNet", "javaout", "browserOutput", "browserout", " jarStore", "jarGen", "pkgNet", "jarOver", "javaIn", "jarStore"], "allEntries": [" allents", "allEnrys", " allentries", " allenties", "allEnies", "allEntrys", " allEnties", "allenties", "allEntryrys", "allentries", "allENTrys", "allEntlections", " allentrys", "allEntryries", " allEntarts", "allentarts", "allENTries", "allEntarts", "allEnties", "allEnts", " allEntrys", " allEntlections", "allEntryies", "allentrys", "allEnarts", "allENTlections", "allENTies", "allents", "allentlections", "allEnries", " allEnts"], "iterator": ["sequence", "ter", "former", "ippy", "immigration", "counter", "liner", "writer", "operator", "iver", "continue", "inner", "stream", "loader", "ator", "members", "current", "copy", "sample", "integer", "pointer", "database", "outer", "series", "internet", "menu", "number", "starter", "values", "ski", "walker", "i", "Iterator", "builder", "pie", "iner", "next", "tmp", "pee", "issues", "timer", "rows", "trace", "vector", "instance", "inator", "set", "range", "finder", "collection", "loop", "table", "iter", "creator", "versions", "list", "runner", "size", "river", "reader"], "jar": ["zip", "cert", "magic", "vol", "char", "job", "Jar", "entry", "gem", "pack", "json", "file", "jo", "folder", "resource", "archive", "parse", "rar", "j", "be", "library", "car", "tab", "batch", "pod", "tar", "java", "bag", "browser", "class", "binary", "zone", "jp", "lib", "pkg", "cf", "module", "jj", "dir", "war", "sp", "bare", "cp"], "jarEntries": ["JarEntires", " jarEntities", "jarEnities", "jarEntrs", "jarMatries", "jarEnries", "jarMatires", "jarEntities", "jarContrys", " jarEntarts", " jarentries", "jarEntires", "jarAddies", "jarentrs", "jarEntrys", "JarEntrs", "jarIntries", "jarenties", "jarEies", " jarEntents", "jarEarts", "Jarentrs", "jarEnrys", "jarInties", " jarEntrys", " jarContities", "jarContities", "Jarentires", "jarEries", "jarentries", " jarenties", "jarContries", "jarentents", "jarContents", "Jarentries", "jarentarts", "jarEnties", "jarEntents", "jarAddries", "jarentires", "jarEents", "jarEnents", "jarEntarts", "jarMaties", "jarIntires", " jarContrys", " jarContents", "jarAddarts", "JarEntries", " jarContries", " jarEnties", " jarentents", "jarIntrs", " jarentarts", "Jarenties", "JarEnties", "jarMatrs", "jarAddents"], "o1": ["co1", "e1", "oOne", " o512", "oo8", "icoone", "e0", "oa8", "o512", " o2", "os2", "co11", "o8", "ico2", "os1", "a0", "eOne", "os512", "o10", " o8", " o5", " o0", " oOne", "oa6", "o5", "eone", "o0", "ico512", "a2", "os5", "oa10", "a1", " oone", "e512", "oa11", "oo10", "e5", "oone", "co6", "oa1", " o11", " o6", "co2", "o6", "ico1", "o11", "aOne", " o10", "o2", "e2", "oa2", "oo1"], "entryStream": ["enterStreamer", "EntrySteam", "entryForm", "rowSteam", "rowPage", " entrySteam", "rowStream", " entryPage", "resultPage", "entrySteam", "entryPage", "EntryStream", "resultStream", " entryPoint", "inputStream", "inputStreamer", "inputForm", "EntryForm", "EntryStreamer", "inputSteam", "enterSteam", "resultSteam", "enterStream", "rowPoint", "enterForm", "entryPoint", "entryStreamer", "resultPoint"]}}
{"id1": "23402240", "id2": "4461350", "code1": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 1, "substitutes": {"actualizarNdivisiones": [" actualizarMdivisionas", " actualizarNisione", " actualizarNisioners", " actualizarMisionas", " actualizarNumentas", " actualizarNdivisione", " actualizarMisione", " actualizarMisiones", " actualizarMisioners", " actualizarNdomers", " actualizarNumente", " actualizarNisionas", " actualizarNdivisionas", " actualizarNdome", " actualizarMdivisioners", " actualizarNumentes", " actualizarNumenters", " actualizarMdivisiones", " actualizarNisiones", " actualizarNdivisioners", " actualizarMdivisione", " actualizarNdomes", " actualizarNdomas"], "idTorneo": ["idToralon", "idTanei", "idLTorneo", "idLTorneO", "idTeroo", "idMorno", "idTalee", "idLTaneO", "idLTaneo", "idTronpo", "idTornei", "idTorno", "idMorne", "idMornpo", "idTeroO", "idTornepo", "idTornos", "idTronos", "idTorne", "idMorneos", "idTrone", "idLTornei", "idToralO", "idTornee", "idTorneos", "idLTaneon", "idTorneO", "idTorali", "idTaleo", "idTeroon", "idTaneo", "idMornos", "idMornee", "idMornepo", "idTalepo", "idLTorneon", "idToralo", "idTorneon", "idLTanei", "idTrono", "idTornpo", "idTaleos", "idTaneon", "idTaneO", "idTeroi", "idMorneo"], "nDivisiones": ["nDivions", "ndivisions", "nDecisione", "nDivitiones", "nDivisions", "ndivione", "nDivisionse", "nDivionals", "nDivione", "ndivisiones", "ndivisionales", "nDivisionals", "nDivideales", "nDecione", "nDecisionales", "nDecisionals", "nDivitione", "ndiviones", "nDecionals", "nDivisione", "nDeciones", "nDiviones", "nDivides", "nDivisionsales", "nDivisionses", "ndivisione", "nDecisiones", "nDividee", "nDivitionals", "nDividees", "nDivisionales", "ndivionales", "ndivions", "nDivisionss", "nDivitionales", "nDivideals", "nDivionales", "nDecionales"], "intResult": ["INTResults", "floatResult", " intRes", "interRes", " intReturn", "IntReturn", " intResults", "intResults", "uintResults", "uintValue", "strResult", "interResults", "intresult", " intresult", "intReturn", "INTResult", "IntRes", "interResult", "interReturn", "floatResults", "INTReturn", " intValue", "intRes", "INTresult", "strValue", "floatresult", "IntResults", "strResults", "uintResult", "strReturn", "IntResult", "intValue", "uintReturn", "floatReturn"], "sql": ["mail", "url", "ln", "pp", "string", "sq", "select", "inv", "xml", "description", "fn", "scl", "expression", "sb", "cmd", "json", "sel", "params", "query", "log", "template", "ql", "pel", "sv", "dl", "spr", "login", "q", "nl", "status", "sol", "spec", "csv", "seed", "sn", "table", "db", "s", "SQL", "qs", "sp", "ls"], "connection": ["port", "Connection", "link", "response", "server", "conn", "writer", "system", "statement", "socket", "created", "pool", "connected", "description", "subject", "pointer", "current", "connect", "database", "number", "location", "network", "ion", "session", " Connection", "resource", "computer", "channel", "function", "context", "close", "reference", "user", "application", "c", "handler", "po", "communication", "engine", "command", "page", "nc", "collection", "condition", "no", "bo", "relation", "db", "table", "client", "open", "con", "position", "creator", "to", "platform", "document", "directory"], "ps": ["fp", "fps", "cs", "pp", "prep", "ips", "p", "posts", "pse", "statement", "pn", "ts", "ports", "rs", "PS", "stats", "ds", "Ps", "pg", "pos", "aps", "gs", "pps", "ptr", "processor", "po", "ping", "res", "mp", "pers", "pr", "jp", "proc", "eps", "pb", "pt", "s", "sp", "gres", "mt", "pe", "cp", "pd", "tp"]}}
{"id1": "14168494", "id2": "411595", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"copyFile": [" Copyfile", " copyStream", " copyByte", "CopyFile", "CopyStream", " cpfile", " CopyFile", " CopyStream", " cpFile", " cpByte", "CopyByte", " cpStream", " CopyByte", "Copyfile", " copyfile"], "dest": ["origin", "orig", "nom", "del", "Dest", "master", "v", "nt", "nw", "target", "w", "temp", "source", "etc", "np", "tmp", "gt", "result", "cont", "way", "good", "st", "img", "out", "them", "loc", "usr", "d", "des", "doc", "dir", "to", "pub", "dist", "www", "trans", "rest"], "src": ["Source", "sec", "init", "inst", "sq", "rs", "sr", "sb", "rx", "file", "sel", "source", "start", "sys", "iv", "from", "cont", "sl", "st", "cur", "ser", "ins", "img", "loc", "usr", "rel", "sc", "req", "rc", "sub", "input", "ls", "desc", "upload"], "srcChannel": ["destChan", "rcchannel", "srcchannel", "rcCommand", "sourceChannel", "destChain", "instCan", " srcCommand", "srcCh", "instChannel", " srcChan", "srcCan", "instChain", "bgChain", "bgCan", "srcCommand", "rcChannel", "sysChan", "srcMessage", "sqCan", "srcPanel", "rcChain", " srcCh", "srcChain", "sysChannel", "sourceCh", "bgChannel", "instCh", "instChan", "sqChannel", " srcMessage", "instPanel", "sourceChan", "destChannel", " srcChain", "syschannel", "bgPanel", "srcChan", "sqChain", "rcChan", "destMessage", "rcMessage", "sqPanel", "sysCommand", " srcchannel"], "dstChannel": ["dotCh", "dstClient", "dndCommand", "destClient", "pdestCommand", "ddestButton", "dstChan", "dndCh", "pdestButton", " dotHandler", "dbrChan", "destButton", "dstCh", "dotHandler", "dotButton", "ddestChan", "ddestClient", "ddestCommand", "dstHandler", "dotChan", "dndClient", " dstButton", "dbrCh", "dstCommand", "dndChannel", "dstButton", " dotButton", "ddestHandler", "dbrHandler", "pstChannel", "dbrChannel", " dotCh", " dotChannel", "destChannel", "dotChannel", " dotChan", "pstClient", "dndChan", "destCommand", "pstCommand", "dndButton", "pdestClient", "ddestChannel", "pdestChannel", "pstButton", " dstHandler", " dstCh", " dstChan", "ddestCh"]}}
{"id1": "841724", "id2": "8801436", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewrites", "readAndrewWrite", "readAndReprites", "readAndResWrite", "readAndResend", "readAndReprite", "readAndResrites", "readAndrewrites", "readAndRepWrite", "readAndrewend", "readAndRewWrite", "readAndResrite", "readAndRepend", "readAndRewend", "readAndrewrite"], "inFile": [" inFilename", "outFilename", "InFile", "outfile", "inTime", "INTime", "inputPlace", "inFace", "INFILE", "initPlace", " infile", "docFILE", "initFilename", "inFilename", "inputFilename", "iTime", "INFile", "initFace", "INFace", "InFilename", "iFILE", "Infile", "infile", "INPlace", "docFilename", "docFile", "inputFile", "INFilename", "inPlace", "iFile", "docTime", "iFilename", "initFile", "inFILE", "inputFace"], "outFile": [" outFILE", "outFilename", "reportFile", "outfile", "reportFILE", "nameFile", "nameFilename", "checkfile", "toFile", "inFilename", " outFilename", "reportfile", "checkFile", "nameFILE", "checkFILE", "checkFilename", "reportFilename", "infile", "toFilename", "outFILE", "toFILE", "namefile", "tofile", " outfile", "inFILE"], "iis": ["diIs", " iisc", " iIS", "IIs", "Ii", "eis", "liIs", "diiss", " ii", "iisc", "dii", "liisc", " iIs", " iiss", "Iis", "iIs", "iiss", "liis", "aiis", "iiris", "aiIS", "Iiss", "iiIs", "aiIs", "iris", "iiisc", "liris", " iris", "eIS", "iiis", "eIs", "diis", "iIS", "ii"], "dcmParser": ["dpmStatement", " dcmLoader", "dmmparser", "DpmParser", "DpmReader", "dpmPar", "dmmmParser", "decmarser", "Dpmparser", "dfmLoader", "dmmReader", " dpmarser", "decmReader", "DcmReader", "dcommParser", "dpmParser", "dpmPrivate", " dcmAssistant", " dpmparser", "deromReader", "dmReader", "dcfStatement", "deromParser", " dpmAssistant", "DcmBuilder", "DcmAdapter", "dcomBuilder", "deromarser", " dpmParser", " dpmPrivate", " dcmStatement", "dmarser", "dcrparser", "dcomLoader", "dromReader", "dmmarser", "dmmParser", "dmmmparser", "dcomParser", "dcfReader", "dpmBuilder", "dgrPar", "dpmReader", "dromparser", "dcmStatement", "dcmPrivate", " dpmListener", " dpmStatement", "dmparser", "dpmLoader", "dfmReader", "drumPar", "dpmListener", " dcmarser", "dfmParser", "Dcmparser", "dgrReader", "dcmAdapter", "dmoduleAssistant", "dmmAdapter", "DcmPar", "dcmLoader", "dromListener", "dpcParser", "dpcReader", "dcrBuilder", " dcmReader", "dromarser", "dfmBuilder", "DpmBuilder", " dcmparser", "dpcAssistant", "dcmPar", "dcommListener", " dcmPrivate", " dcmBuilder", "decmParser", "dgrStatement", "decmparser", "dcmAssistant", "drumBuilder", "dcmListener", "dcommReader", "DcmParser", " dpmPar", "drumReader", " dpmLoader", "dmParser", "dcmReader", " dcmListener", "dcommAssistant", "dmodulePrivate", " dcmPar", "DpmAdapter", "dcomReader", "dcmarser", "dgrParser", "dpmparser", "dmmmReader", "dromParser", "DpmPar", "dpmAssistant", "dcfParser", "dcrParser", "dpmAdapter", "dromAssistant", "drumParser", " dpmBuilder", " dpmReader", "dpmarser", "dcfPar", "deromparser", "dpcPrivate", "dmoduleReader", "dmoduleParser", "dmmmAdapter", "dcmparser", "dcmBuilder", "dcrReader"], "ds": ["obs", "cs", "ws", "gd", "bs", "ods", "Ds", "rs", "tes", " DS", "ps", "drivers", "sets", "dh", "ns", "aos", "dx", "der", "DS", "hd", "bd", "sys", "ys", "ils", "gs", "sd", "dat", "ss", "es", "data", "uds", "xs", " des", "sv", "dl", "fs", "services", "ads", "eds", "its", "details", "in", "da", "ims", "ins", "dds", "pers", "vs", "d", "des", "db", "eps", "dos", "os", "dt", "s", "dq", "js", "outs", "qs", "dd", "hs", "ks", "ls", "as", "df", "pd"], "pdReader": ["vdWriter", "pedRunner", "xdHelper", "ddHelper", "tdParser", "pdParser", "dpLoader", "pdCar", "ddParser", "ddRunner", "vdReader", "pedReader", "pdRunner", "pdHelper", "ddLoader", "pedLoader", "pdLoader", "ddRead", "ddWriter", "hdReader", "dpReader", "ddReader", "vdHelper", "pedCar", "pdRead", "tdRead", "hdWriter", "xdReader", "xdLoader", "xdWriter", "dpRunner", "vdLoader", "ddCar", "dpCar", "hdRead", "hdParser", "tdWriter", "tdReader"], "out": ["obj", "cache", "conn", "p", "Out", "ex", "v", "cmd", "pos", "io", "one", "data", "res", "in", "str", "end", "list", "name", "auto", "msg", " err", "full", "writer", "cb", "inv", "pool", "opt", "on", "sw", "cfg", "we", "at", "gr", "os", "con", "oss", "outs", "screen", "OUT", "net", "raw", "cn", "up", "nt", "w", "outer", "ent", "all", "nr", "err", "tmp", "conv", "gt", "gen", "id", "c", "sum", "ins", "o", "output", "null", "co", "js", "desc", "ou", "go", "ch", "it", "inner", "aos", "flush", "sys", "log", "serv", "inter", "txt", "status", "t", "en", "client", "s", "to", "over", "n"], "dcmEncParam": ["dcmencMsg", "dmmencMsg", "dmmEncPar", "dmmEnNum", "dmmencNum", "dmmEncParam", "dcmEncVal", "dmmEnParam", "dcmEscNum", "dmmEncMsg", "dmmEnPar", "dcmDecCmd", "dcmEnParam", "dcmencParam", "dcmencPar", "dcmDecMsg", "dcmEnPar", "dcmDecParam", "dcmEscVal", "dcmEnNum", "dcmEncPar", "dmmencCmd", "dcmencCmd", "dmmEncVal", "dcmEnVal", "dcmencNum", "dcmDecNum", "dcmEncNum", "dcmEncMsg", "dmmEncNum", "dmmEncCmd", "dcmEscParam", "dcmEncCmd", "dcmEscPar", "dmmencParam"], "pdWriter": ["PDEditor", "pcWriter", "tdWriter", "dpEditor", "PDReader", "PDWrite", "pdWrite", "pidWriting", "PDWriter", "pdwriter", "dpReader", "dpWriter", "tdEditor", "pdEditor", "pidWriter", "pcWrite", "pcWriting", "pcwriter", "dpWrite", "pidwriter", "tdWriting", "tdwriter", "pidWrite", "pdWriting", "tdWrite", "tdReader"]}}
{"id1": "19113613", "id2": "23666867", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["delete", "link", "zip", "php", "ip", "init", "cross", "opy", "same", "replace", "download", "py", "Cop", "gc", "cos", "cop", "transfer", "map", "sync", "save", "clip", "crop", "slice", "move", "create", "clone", "write", "split", "share", "paste", "proxy", "to", "core", "Copy", "co", "cat", "pixel", "cp"], "in": ["inn", "inc", "up", "init", "is", "it", "mi", "act", "inv", "sin", "inner", "isin", "old", "ini", "info", "din", "all", "bin", "i", "ir", "gin", "local", "on", "id", "from", "In", "el", "y", "ic", "check", "ins", "inside", "en", "IN", "o", "by", "l", "iter", "con", "ai", "input", "rin", "cin", "ie", "re", "net", "ar", "inf", "ind"], "out": ["port", "cache", "obj", "not", "conn", "ch", "p", "it", "ver", "Out", "this", "inner", "v", "ex", "nt", "w", "aos", "outer", "ent", "all", "b", "log", "err", "ion", "sys", "io", "tmp", "local", "one", "gt", "on", "result", "base", "res", "ot", "y", "store", "set", "op", "t", "en", "at", "o", "OU", "l", "write", "output", "client", "con", "null", "os", "to", "end", "oss", "co", "over", "outs", "OUT", "net", "can", "n", "ou"], "source": ["Source", "attribute", "scan", "sequence", "cause", "unit", "origin", "parent", "key", "system", "select", "string", "shell", "sin", "inner", "this", "ource", "src", "scope", "si", "subject", "se", "title", "query", "start", "resource", "local", "template", "base", "space", "search", "from", "site", "status", "sql", "store", "prefix", "service", "range", "finder", "language", "relation", "position", "s", "input", "ie", "ce", "sp", "SOURCE", "style", "index", "use", "lower", "format"], "target": ["link", "url", "origin", "parent", "key", "other", "pattern", "dest", "scope", "arg", "bolt", "Target", "query", "point", "goal", "alias", "location", "ARGET", "resource", "join", "arget", "local", "match", "template", "that", "gt", "translation", "top", "root", "step", "base", "t", "test", "rel", "module", "table", "output", "tif", "term", "null", "to", "tree", "token", "print", "style"], "files": ["resources", "assets", "ports", "banks", "lines", "uploads", "pages", "members", "features", "users", "values", "reports", "thumbnails", "facts", "faces", "issues", "fs", "services", "pieces", "workers", "actions", "states", "packages", "modules", "jobs", "models", "tools", "details", "parts", "objects", "iles", "balls", "lets", "books", "items", "styles", "events", "plates", "les", "headers", "images", "ls"], "file": ["ile", "fp", "name", "port", "child", "le", "key", "path", "File", "image", "model", "full", "parent", "tile", "current", "job", "entry", "foo", "e", "label", "node", "event", "folder", "filename", "ve", "resource", "local", "data", "FILE", "user", "library", "f", "base", "el", "page", "feature", "play", "item", "rule", "relation", "work", "table", "line", "dir", "fe", "block", "word", "tree", "row", "field", "print", "document", "be", "pe"], "inCh": ["cinch", "outCod", "incCr", "dinCr", "rinCod", "incSam", "cinSam", " inCl", "inch", "inCr", "cinCor", "rinCh", "InCh", "InCod", "inCl", " inCod", "cinCh", "outChan", "dinCor", "rinChan", "dinCh", "inCor", " inChan", "incCor", "cinCod", "incCh", "dinSam", " inch", "cinChan", "InChan", "InCl", "inSam", "rinCl", "inCod", "inChan", "outch", "cinCr"], "outCh": ["newGr", " outChan", "newCol", "inch", "outCol", "newch", " outCol", "outputChan", "outputCh", "inCol", "outputCod", "newCod", "outChan", "newChan", "outGr", "outputGr", "newCh", " outch", " outCod", "inChan", "outch", " outGr", "outCod"]}}
{"id1": "23161545", "id2": "3767903", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomSuid", "getRandomSUID", "getRandomUuid", "getRandUuid", "getRandomUUID", "getRandUID", "getRandGUID", "getRandUUID", "getRandomCuid", "getRandomGuid", "getRandUid", "getRandomCID", "getRandomGID", "getRandomCUID", "getRandGid", "getRandomUID", "getRandomUid", "getRandomSid", "getRandGuid", "getRandomSID", "getRandGID", "getRandomCid", "getRandomGid"], "secure": ["sec", "clear", "active", "server", " Secure", "confirmed", "sr", "safe", "sys", "ssl", "weak", "sync", "security", "force", "prime", " insecure", "http", "status", "nice", "service", "protect", " securely", "Secure", "google", "https", "dirty", "sensitive", "client", "quiet", "stable", "strong", "ie", "pretty", "trust", "secret", "encrypted"], "md5": ["MD512", "metadata3", "MD2", " md6", " md2", " mdle", "md45", "dig4", "md3", " md45", "metadata5", "metadata2", "md4", "sha5", "sha512", " md512", "dig5", "metadata45", "md512", "sha3", "MD5", " md4", "md2", "dig3", "sha2", "md6", "MD45", " md3", "MD4", "MD3", "digle", "sha6", "MD6", "MDle", "mdle"], "sbValueBeforeMD5": ["sbValueBeforeIM1", "sbValueAfterMDson", "sbValueBeforeOLD5", "sbValueBeforeSMson", "sbValueBeforeDD512", "sbValueAfterMD5", "sbValueBeforeLM2", "sbValueAfterND4", "sbValueAfterMDLeft", "sbValueBeforeAMD2", "sbValueBeforeMDson", "sbValueBeforeAMDFound", "sbValueBeforeMAC5", "sbValueBeforeSM5", "sbValueWithoutMD512", "sbValueBeforeLM512", "sbValueAfterMD1", "sbValueAfterMD4", "sbValueBeforeMDLeft", "sbValueAfterMDFound", "sbValueBeforeDD65", "sbValueBeforeDS5", "sbValueBeforeLM5", "sbValueAfterMD2", "sbValueBeforeND2", "sbValueBeforeDDFive", "sbValueBeforeOLD512", "sbValueAfterMDFive", "sbValueBeforeND4", "sbValueWithoutDD5", "sbValueBeforeMP2", "sbValueBeforeMS2", "sbValueBeforeOLD2", "sbValueBeforeAMDson", "sbValueBeforeNDson", "sbValueAfterND2", "sbValueBeforeMS3", "sbValueBeforeMD512", "sbValueBeforeMS1", "sbValueBeforeDS2", "sbValueWithoutMD5", "sbValueAfterNDson", "sbValueBeforeMP1", "sbValueBeforeMOD2", "sbValueBeforemdFound", "sbValueBeforeIM2", "sbValueBeforeMT5", "sbValueBeforeMACFive", "sbValueBeforeSM2", "sbValueAfterMD3", "sbValueBeforeMTson", "sbValueBeforeMDFound", "sbValueBeforeMS5", "sbValueBeforeIM5", "sbValueBeforeMOD3", "sbValueBeforeMPLeft", "sbValueWithoutDD2", "sbValueBeforeMOD1", "sbValueBeforeMOD5", "sbValueBeforeDS512", "sbValueWithoutDD512", "sbValueBeforeND5", "sbValueBeforemd2", "sbValueBeforeMD4", "sbValueBeforeMD3", "sbValueBeforeDD5", "sbValueBeforeAMD5", "sbValueBeforeSM4", "sbValueBeforeMAC65", "sbValueBeforeMAC2", "sbValueBeforeDD2", "sbValueBeforeIMLeft", "sbValueBeforeMD2", "sbValueBeforeMDFive", "sbValueBeforeMT2", "sbValueAfterND5", "sbValueBeforeMT4", "sbValueBeforeMD65", "sbValueAfterMD65", "sbValueBeforeMP5", "sbValueWithoutMD2", "sbValueBeforemd5", "sbValueBeforemdson", "sbValueBeforeMD1"], "time": ["name", "ime", "timeout", "counter", "race", "est", "now", "system", "ts", "ty", "estamp", "current", "TIME", "clock", "value", "start", "date", "when", "user", "top", "year", "id", "rate", "timer", "tim", "today", "frame", "set", "age", "t", "history", "Time", "duration", "etime", "work", "length", "total", "times", "client", "size", "runtime", "hour"], "rand": ["rev", "sid", "init", "rd", "and", "inv", "mid", "sample", "r", "nt", "rid", "grad", "ng", "uid", "round", "rank", "rad", "quant", "sam", "gt", "gen", "rate", "id", "pick", "Rand", "res", "reg", "rss", "std", "random", "range", "hash", "red", "serial", "seed", "rh", "frac", "gz", "nd", "rc", "cr", "pid", "dist", "roll", "z", "did", "rot", "rt", "dr"], "valueBeforeMD5": ["valueBeforeMT3", "valueAfterND7", "valueBeforeMOD7", "valueAfterMD3", "valueAfterND5", "valueBeforeMC2", "valueAfterMD2", "valueBeforeMC7", "valueBeforeMOD5", "valueBeforeMT2", "valueBeforeMC3", "valueAfterMD7", "valueBeforeND2", "valueBeforeMT5", "valueBeforeMOD2", "valueAfterND2", "valueAfterND3", "valueBeforeMD7", "valueBeforeMD2", "valueBeforeMOD3", "valueBeforeMD25", "valueBeforeND3", "valueBeforeMT25", "valueBeforeND7", "valueBeforeMC5", "valueBeforeMD3", "valueBeforeND5", "valueBeforeMC25"], "array": ["attribute", "response", "rays", "external", "ray", "image", "Array", "our", "raw", "arrow", "sh", "a", "sample", "RAY", "expression", "number", "buffer", "archive", " Array", "data", "record", "ash", "map", "av", "batch", "atomic", "storage", "audio", "arr", "vector", "instance", "angular", "random", "range", "hash", "object", "feature", "collection", "address", "binary", "angle", "app", "length", "share", "list", "row", "ary", "pair", "var", "area"], "sb": ["obs", "erb", "bg", "ib", "sq", "soc", "bs", "cb", "sth", "sh", "si", "sa", "bh", "sr", "abb", "nb", "lb", "gc", "ssl", "bsp", "bb", "sg", "bp", "sw", "sv", "lp", "eb", "bis", "bf", "gb", "ctrl", "rob", "sf", "wb", "ub", "kb", "pb", "db", "bt", "ob", "rb", "SB", "hs", "zb", "bps", "xb"], "j": ["ix", "msg", "obj", "off", "key", "jump", "uj", "jl", "it", "ji", "g", "v", "ja", "job", "yy", "je", "json", "ju", "jo", "jc", "i", "k", "jack", "oj", "m", "kj", "q", "_", "J", "br", "bj", "__", "str", "ij", "aj", "t", "dj", "us", "jp", "jit", "jj", "js", "z", "att", "bot", "ct", "index", "ind"], "b": ["bi", "bg", "ib", "bc", "bs", "cb", "mb", "v", "B", "a", "ab", "nb", "u", "bd", "k", "ba", "bb", "bar", "bp", "beta", "eb", "bu", "bis", "gb", "bf", "y", "br", "d", "db", "bound", "bt", "rb", "fb", "be", "xb"], "valueAfterMD5": ["valueAfterMD3", "valueAftermd7", "valueAfterID2", "valueAfterMD2", "valueAfterID3", "valueAfterMD7", "valueBeforeMD7", "valueBeforeMD2", "valueAftermd2", "valueAfterID7", "valueBeforeMD3", "valueAftermd3", "valueAfterID5", "valueAftermd5"]}}
{"id1": "1954410", "id2": "15799935", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "label": 1, "substitutes": {"doExecute": ["doEditExec", "doEditutes", "DoExecute", "DoExecit", "doEditit", "doCommute", "DoExecutes", "doCommutes", "DoExecExec", "doCommExec", "doEditute", "doCommit", "doExecutes", "doExecExec", "doExecit"], "mapping": ["Mappings", "mapped", "mappings", "mapper", " mapped", "Mapping", " mappings", " mapper", "smapped", "smappings", "Mapped", "smapper", "smapping", "Mapper"], "form": ["view", "parent", "path", "raw", " forms", "FORM", "forms", "subject", " Form", "config", "session", "orm", "template", "sam", "map", "fc", "Form", "f", "m", "type", " FORM", "format", "command", "formed", "app", "self", "owner"], "request": ["server", "model", "container", "question", "context", "host", "reference", "user", "cont", "store", "frame", "create", "req", "input", "quest", "document", "upload", "QUEST", "url", "version", "def", "xml", "message", "current", "resource", "project", "sw", "report", "http", "_", "Upload", "impl", "address", "reset", "remote", "view", "this", "se", "w", "Request", "query", "template", "command", "post", "window", "parent", "initial", "first", "true", "order", "allow", "Exception", "session", "application", "instance", "open", "client"], "response": ["view", "server", "resp", "xml", "message", "content", "success", "session", "respond", "application", "result", "res", "report", "send", "status", "frame", "Response", "write", "output", "connection", "re", "ce", "reply", "sp", "document", "print"], "errors": [" status", " flash", " mess", " elements", " warnings", " updates", " storage", " sessions", " error", " success", "Mess", " Messages", " problems", " messenger", " requests", " messages", " state", " flashes", " fails", " logs", " steps", " managers", "ages", " changes", " manager", " states", " statements", " moves"], "isMultipart": ["isMultiIParts", "isMultIPain", "isMultIPart", "isMultIPod", "isMultIPade", "isMultifare", "isMultIParts", "isMultipod", "isMultiipart", "isMultiplarts", "isMultipade", "isMultipain", "isMultifarts", "isMultiipare", "isMultiplade", "isMultiIPade", "isMultiipain", "isMultiparts", "isMultiiparts", "isMultospain", "isMultiart", "isMultiIPain", "isMultiplart", "isMultiipod", "isMultiplod", "isMultospart", "isMultiIPare", "isMultIPare", "isMultifain", "isMultospare", "isMultiarts", "isMultiIPart", "isMultifart", "isMultiipade", "isMultosparts", "isMultipare", "isMultiod", "isMultiIPod", "isMultiade"], "mailInstance": ["emailInst", "flexInstance", " MailInst", "emailinstance", " mailInst", " MailBuilder", " MailInstance", "emailance", "flexInst", "mailance", " mailinstance", " Mailinstance", "flexinstance", "emailBuilder", "mailInst", "mailBuilder", "emailInstance", " mailance", "mailinstance", "flexance", " mailBuilder"], "fields": ["views", "bits", "packs", "groups", "posts", "rules", "sections", "frames", "ports", "locks", "lines", "drivers", "forms", "strings", "pages", "members", "features", "days", "classes", "plugins", "users", "reports", "relations", "comments", "links", "keys", "tags", "holders", "dates", "files", "faces", "states", "services", "workers", "lists", "rows", "packages", "modules", "tests", "boxes", "models", "details", "phones", "parts", "objects", "levels", "balls", "types", "atts", "terms", "flags", "lights", "checks", "qs", "headers", "field", "orders", "images", "names", "prints", "properties"], "attachments": ["achions", "payances", "attments", "payements", "payments", "payitions", "attachresses", " attachions", "achresses", " attachresses", "attachitions", "Attachresses", "Attachions", "attachements", " attachances", "attachMENTS", "Attachitions", "achensions", "acheances", " attachitions", "AttachMENTS", "attMENTS", "achMENTS", "attachensions", "achitions", "Attachments", " attachements", "attensions", "attitions", "attachions", "Attachensions", "acheements", "achments", "achements", "acheitions", "attachances"], "items": ["resources", "groups", "ips", "lines", " Items", "pages", "members", " results", "reports", "links", "keys", "archives", "results", "apps", "files", " samples", "issues", "actions", "services", "photos", "packages", "ids", "rows", "its", "Items", " files", "objects", "phones", "parts", "tests", " images", " inputs", "events", "orders", "qs", "images", "names", "cases"], "iter": ["orient", "iterator", "ter", "former", "init", "altern", "tr", "writer", "cmp", "it", "each", "older", "inner", "order", "ator", "ait", "ite", "outer", "ipper", "walker", "i", "Iterator", "read", "iner", "inter", "gener", "result", "maker", "coll", "el", "ner", "its", "store", "set", "ser", "er", "loc", "loop", "test", "tif", "upper", "dir", "Iter", "list", "re", "oper", "reader", "ind", "li"], "item": ["ix", "link", "obj", "stat", "ex", "info", "one", "data", "el", "cell", "store", "element", "spec", "name", "url", "unit", "other", "claim", "attr", "xml", "member", "entity", "detail", "event", "resource", "on", "type", "details", "single", "rule", "row", "att", "raw", "addr", "attribute", "up", "anything", "ip", "job", "mm", "layer", "json", "record", "template", "step", "or", "object", "module", "area", "zip", "group", "key", "initial", "image", "it", "order", "inner", "add", "entry", "file", "change", "internal", "local", "related", "match", "atom", "page", "status", "instance", "er", "Item", "app", "word"], "aux": ["ix", "AU", "ras", "auto", "lim", "tx", "fax", "ex", "ox", "foo", "pet", "fat", "fam", "aos", "max", "aim", "ups", "fuck", "vers", "etc", "pad", "fx", "uf", "aw", "uds", "imp", "airs", "uff", "av", "abs", "ux", "mu", "du", "ax", "fu", "aus", "eu", "aff", "cu", "us", "au", "buff", "af", "net", "extra", "used", "area", "off"], "part": ["html", "p", "tx", "and", "partial", "pos", "par", "pad", "parts", "card", "piece", "zone", "bound", "pt", "block", "list", "comp", "version", "message", "sample", "member", "detail", "point", "start", "join", "top", "tab", "person", " Part", "worker", "prefix", "component", "party", "PART", "Part", "job", "pet", "photo", "layer", "half", "admin", "art", "tmp", "mod", "step", "base", "peer", "object", "api", "relation", "pkg", "section", "sp", "print", "primary", "patch", "pair", "wrapper", "group", "parent", "inner", "add", " parts", "temp", "local", "pod", "pre", "work", "split", "word", "format"], "baos": ["baOs", "biOS", "bao", "taops", "tao", "vaOs", "vaoss", "vaols", "poOS", "tais", "bioses", "boOs", "bais", "caoss", "caOs", "waos", "taoss", "waols", "booses", "baols", "poops", "baoses", "caos", "boos", "waOs", "bio", "bios", "booss", "baOS", "waoss", "kaops", "caOS", "pois", "cao", "caols", "kais", "boo", "pooss", "taOs", "vaos", "poo", "boOS", "baops", "baoss", "pooses", "poos", "kaoss", "taos", "kaos"], "body": ["mail", "name", "port", "html", "header", "head", "shell", "display", "description", "message", "subject", "content", "title", "detail", "json", "file", "ody", "buffer", "layout", "log", "data", "template", "default", "scroll", "tail", "comment", "base", "foot", "report", "format", "plain", "send", "post", "text", "summary", "t", "bill", "binary", "loop", "rel", "output", "null", "tree", "ODY", "size", "pass", "business", "note", "Body"], "preferencesInstance": ["preffiesinstance", "prefancesObj", "prefferencesObj", "prefiesinstance", "prefferencesInstance", "prefferencesinstance", "prefancesImpl", "prefutesInstance", "prefiesObj", "preferencesObj", "preferencesImpl", "prefiesInstance", "prefutesObj", "preffiesObj", "prefancesinstance", "prefancesInstance", "preferencesinstance", "prefferencesImpl", "prefiesImpl", "preffiesInstance", "preffiesImpl", "prefutesinstance", "prefutesImpl"]}}
{"id1": "14317425", "id2": "23620712", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeStringAsDisk", "encodeStringAsStream", "encodeFileAsStream", "encodeFiletoDisk", "encodeStringAsFile", "encodeStringToStream", "encodeFileToFiles", "encodeStringToFiles", "encodeStringToDisk", "encodeStringAsFiles", "encodeFileAsFile", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileAsDisk", "encodeFiletoStream", "encodeFileFromFiles", "encodeFileAsFiles", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk", "encodeFileFromDisk", "encodeFileFromFile", "encodeFileToStream"], "infile": ["inFile", "outFile", "InFile", "inputfilename", "inbase", "Inbase", " inbase", " inFile", "infilename", "inpath", "Inpath", " inpath", "outbase", "Infile", "outfilename", "outpath", "inputfile", "inputpath", "inputFile", " infilename"], "outfile": ["inFile", " outname", "outFile", "infp", " outFile", "fromfile", "tofp", "newfilename", "todir", "outdir", "infilename", "toFile", "fromfp", "indir", "outname", "fromFile", "inname", "outfp", "outfilename", " outfilename", "newfile", "newFile", "fromdir", "newname", "tofile"], "in": ["inn", "im", "al", "inc", "up", "pin", "conn", "init", "image", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "gin", "on", "id", "from", "In", "form", "or", "amin", "ins", "inside", "t", "en", "IN", "ro", "by", "get", "iter", "con", " din", "cin", "rin", "input", "re", "ar", "inf", "oin", "ind"], "out": ["up", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "aos", "outer", "flush", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "null", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "character", "sequence", "cache", "view", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "bone", "variable", "pad", "buf", "black", "append", "Buffer", "template", "bar", "padding", "library", "available", "password", "button", "note", "batch", "base", "comment", "queue", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "length", "block", "row", "print", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "run", "connect", "allow", "through", "query", "start", "i", "push", "close", "give", "send", "wait", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "req", "count", "iter", "seek", "end", "skip", "input", "readable", "need", "n", "size", "print", "reader", "index", "ind", "Read"], "success": ["response", "town", " okay", "first", "same", "fail", "continue", "primary", "support", " successes", "commit", " successful", "positive", "growth", "photo", "safe", "value", "submit", " succ", "second", "snap", "Success", "city", "ccess", "successfully", "error", "warning", "ceed", "result", "successful", "complete", "setup", "done", "accept", "crit", "sufficient", "release", "democracy", "valid", "status", "good", "surv", "danger", "summary", " Success", "condition", "please", "ok", " failure", "unity", "ratulations", "cess", "ith"]}}
{"id1": "21642215", "id2": "20024612", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    private void parse() throws Exception {\n        BufferedReader br = null;\n        InputStream httpStream = null;\n        URL fileURL = new URL(url);\n        URLConnection urlConnection = fileURL.openConnection();\n        httpStream = urlConnection.getInputStream();\n        br = new BufferedReader(new InputStreamReader(httpStream, \"UTF-8\"));\n        String ligne;\n        String post;\n        String date;\n        String titre;\n        String resume;\n        String url2DL;\n        while ((ligne = br.readLine()) != null) {\n            if (ligne.indexOf(\"div class=\\\"post\\\" id=\\\"post\") != -1) {\n                post = null;\n                date = null;\n                titre = null;\n                try {\n                    post = ligne.substring(ligne.indexOf(\"post-\") + 5, ligne.indexOf(\"\\\"\", ligne.indexOf(\"post-\")));\n                    ligne = br.readLine();\n                    date = ligne.substring(ligne.indexOf(\"<div class=\\\"date\\\"><span>\") + 24);\n                    date = date.replaceAll(\"</span>\", \"\").replaceAll(\"</div>\", \"\").trim();\n                    log.info(\"Post   : \" + post + \" du \" + date);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    titre = ligne.substring(ligne.indexOf(\">\", ligne.indexOf(\"title\")) + 1, ligne.indexOf(\"</a>\"));\n                    titre = titre.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    url2DL = ligne.substring(ligne.indexOf(\"<a href=\\\"\") + 9, ligne.indexOf(\"/\\\"\")).trim();\n                    url2DL = url2DL.replace(\"mega-films.net\", \"mega-protect.com\") + \".php\";\n                    log.info(\"Titre  : \" + titre);\n                    log.info(\"To DL  : \" + url2DL);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    resume = ligne.substring(ligne.indexOf(\"<em>\") + 4, ligne.indexOf(\"</em>\"));\n                    resume = resume.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    log.info(\"Resume : \" + resume);\n                } catch (Exception e) {\n                    log.error(\"ERREUR : Le film n'a pas pu etre parse...\");\n                }\n                log.info(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\");\n            }\n        }\n    }\n", "label": 0, "substitutes": {"addIDs": ["processID", "setIDs", " addIDS", "processIDs", " addNames", " addID", "setID", "setNames", "addNames", "addIDS", "processNames", "addID", "processIDS", "setIDS"], "row": ["group", "tr", "board", "r", "job", "entry", "ow", "ack", "week", "node", "buffer", "rank", "channel", "rown", "record", "user", "box", "error", "ry", "result", "batch", "report", "Row", "rows", "cell", "instance", "post", "item", "out", "ro", "table", "roll", "block", "list", "skip", "ows", "star", "pair", "col", "raw"], "name": ["path", "NAME", "key", "version", "string", "image", "description", "a", "title", "value", "label", "file", "query", "named", "source", "filename", "question", "template", "password", "type", "search", "prefix", "Name", "text", "item", "address", "create", "ame", "word", "n", "format"], "in": ["inn", "scan", "inc", "al", "up", "pin", "conn", "ln", "init", "is", "it", "ain", "inner", "xml", "isin", "ex", "ini", "r", "din", "copy", "file", "source", "update", "log", "bin", "i", "nin", "ssl", "serv", "gin", "local", "win", "on", "m", "il", "again", "In", "el", "conf", "form", "sql", "ic", "check", "ins", "t", "en", "out", "er", "IN", "at", "l", "db", "get", "con", "n", "s", "cin", "input", "rin", "re", " IN", "mc", "reader", "vin", "inf"], "urlName": ["lName", " urlPath", "lPath", "UrlKey", "urlNames", "UrlNames", "implPath", "logKey", "urlKey", "urlname", "urlPath", " urlNAME", "logname", "logName", " urlNames", "implNAME", "lKey", "implname", "urlNAME", "logNAME", "lNames", "UrlName", "lNAME", "implNames", "lname", "implName", " urlname", "UrlNAME", "Urlname"], "url": ["Url", "link", "char", "ret", "loader", "r", "cl", "mount", "file", "b", "gl", "ssl", "resource", "channel", "result", "base", "il", "uri", "web", "http", "nl", "sl", "el", "rl", "str", "ll", "browser", "t", "ref", "rel", "l", "open", "client", "con", "URL", " URL", "ls", "ur", "reader", "ul"], "inputLine": [" Inputline", "latLINE", "sourceLine", "listLine", "dataFrame", "keyL", "InputLINE", "submitLINE", "formLINE", "dataBlock", " inputLINE", "tableLINE", "viewLine", "intBlock", "latLine", "helloLINE", "inputNode", "keyline", "listLINE", "statusLINE", "commandLine", "contextRow", "singleLINE", "InputL", "tablePort", "statusFile", "tempLine", "listPort", " InputLin", "viewLINE", "operationNet", "inputPage", "intLINE", " inputEntry", "intLin", " inputNet", "helloPort", " inputLin", "tempLINE", " inputRecord", "formLine", " inputNode", "Inputline", "inputLink", "intLine", "commandLINE", "singleBlock", "contextLine", "commandBlock", "cacheLine", "dataLink", "firstLine", "latline", "submitBlock", "inputEntry", " InputLINE", "inLINE", "inLine", "InputLine", "submitDe", "inputBlock", "inline", "singleDe", "operationLine", "sourcePage", "sourceNode", "InputBlock", "inputDe", " inputDe", "InputFile", "keyLine", "firstLINE", "keyLINE", "singleLine", "dataPort", "sourceLINE", " InputLine", "inputL", "contextLINE", "inputRow", "submitLine", "patternLine", "dataLINE", "viewRow", " inputPort", "cacheNode", "inputNet", "inputLin", "inputline", "InputRow", "patternLINE", "operationLINE", "cacheLINE", "helloEntry", " inputFrame", "statusLine", "dataLine", " inputline", "statusline", "firstBlock", "patternline", "formBlock", "inL", "tableLink", "inputPort", " inputFile", "dataNet", "latRecord", " inputLink", "patternRow", "templine", "formFrame", "cachePage", " inputBlock", "helloLine", " inputRow", "inputLINE", " inputPage", "dataline", "inputRecord", "dataFile", "listEntry", "inRecord", "inputFrame", "inputFile", "intline", "tableLine"], "score": ["scan", "confidence", "display", " Score", "price", "message", "distance", "value", "success", "strength", "source", "goal", "err", "rank", "match", "scroll", "error", "rate", "scoring", "result", "search", "average", "report", "sum", "scale", "status", "set", "loss", "draw", "check", "depth", " scores", "Score", "test", "weight", "length", "grade", "sc", "count", "core", "level", "style", "index"], "metaboliteID": ["metaboliceInfo", "metabolitateID", "metabolicITEName", "metaboliceid", "metaboliceID", "metaboliciteName", "metaboliteId", "metabolisticId", "metabolitableID", "metabolteID", "metabiliterHandle", "metabolitateInfo", "metabolitesID", "metabolITEType", "metabolicitationInfo", "metaboliciteInfo", "metabolitationid", "metabolitateid", "metabolicITEId", "metabiliteID", "metabolITEId", "metabolitationIN", "metaboliteIN", "metabolteHandle", "metmbolitationID", "metabolicITEType", "metabolitateId", "metaboliterHandle", "metabolisticID", "metabolitationName", "metaboliteType", "metabiliteId", "metabiliterUID", "metaboliteid", "metabolitationId", "metmboliteIN", "metabolitionid", "metabolitionID", "metabolitableId", "metabolitionName", "metabiliterID", "metaboliciteType", "metabolisticIN", "metaboliterid", "metabolitationID", "metabolITEID", "metabiliteid", "metaboliterID", "metabolicITEID", "metabolITEName", "metabolitableUID", "metaboliterName", "metabolitationInfo", "metabolitableHandle", "metabolteUID", "metaboliceId", "metaboliciteid", "metabolitesid", "metaboliterUID", "metaboliteUID", "metabiliteName", "metaboliterIN", "metmboliteID", "metmboliteId", "metabiliterid", "metaboliteHandle", "metabolicitationID", "metabolicitationId", "metaboliciteId", "metabiliterId", "metabolteId", "metaboliciteID", "metabiliteHandle", "metaboliteInfo", "metabolitesName", "metmbolitationIN", "metabiliterName", "metabiliteUID", "metabolitationType", "metaboliteName", "metabolicitationid", "metaboliterId", "metaboliterType", "metmbolitationId"], "dataScore": [" dataRank", "deviceTransfer", " dataWeight", "relationScore", "parentSc", "relationscore", "dataAge", "dataStyle", "dataSize", "DATARank", "DATATest", "errorWeight", "blockSpeed", "errorscore", "parentRank", "blockScore", "blockStyle", " dataSize", "DataSc", "ataScore", "dataTransfer", "deviceScore", "dataRank", "DataSize", "divScore", " dataAge", "parentScore", "arraySc", " dataSc", "divSize", "DATAScore", " datascore", "dataWeight", "tdScore", "relationSize", "ataTransfer", "tdAge", "dataSpeed", "blockSc", "errorSize", "arrayScore", "arraySpeed", "errorScore", "dataTest", "parentTest", " dataStyle", " dataSpeed", "deviceSc", "arrayAge", "arrayStyle", " dataTest", "DataRank", " dataTransfer", "tdSc", "divRank", "relationWeight", "datascore", "DataScore", "ataSize", "dataSc", "divSc", "ataSc", "DATASc", "deviceSize"], "data": ["cache", "html", "array", "none", "image", "string", "ata", "multiple", "lines", "description", "info", "content", "ns", "series", "json", "users", "value", "params", "values", "all", "buffer", "keys", "dat", "results", "video", "map", "zero", "available", "step", "batch", "base", "space", "valid", "mu", "draw", "details", "hash", "set", "text", "chain", "supported", "rew", "table", "words", "DATA", "size", "extra", "missing", "td", "hex", "window", "bytes", "raw"], "molecularWeight": ["moleuralWeight", "moleularWeight", "moleculeData", "moleculeweight", "mlecularFont", "moleularData", "mlecularData", "moleularweight", "moleuralScore", "moleularFont", "mlecularWater", "molecularData", "moleuralWater", "molecularWater", "molecularFont", "molellularData", "mleularweight", "mleularScore", "molellularweight", "mlecularWeight", "moleudoScore", "moleularWater", "mlecularweight", "mleularData", "molellularFont", "moleculeWeight", "mlecularScore", "molellularWeight", "molecularScore", "moleudoWater", "moleculeFont", "mleularFont", "mleularWeight", "mleularWater", "moleularScore", "molecularweight", "moleudoWeight"]}}
{"id1": "12537270", "id2": "8490297", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["delete", "php", "p", "arse", "replace", "process", "se", "layer", "update", "Parser", "resource", "read", "close", "parser", "build", "match", "error", "ping", "slice", "check", "load", "loop", "split", "print", "pair", "handle", "format"], "link": ["name", "html", "path", "ln", "le", "ip", "image", "string", "action", "pattern", "char", "se", "add", "entry", "linked", "lock", "e", "label", "source", "start", "log", "links", "join", "local", "match", "template", "id", "let", "type", "uri", "ping", "page", "tag", "frame", "address", "load", "element", "loc", "rel", "l", "line", "word", "block", "route", "script", "ink", "sp", "style", "index", "Link"], "conn": ["nav", "obj", "gn", "cs", "ch", "ln", "ws", "yn", "resp", "socket", "comm", "cb", "org", "act", "enc", "nt", "ait", "ns", "connect", "cmd", "err", "conv", "txt", "c", "cont", "res", "pas", "ctr", "nc", "ner", "cn", "ctrl", "loc", "rel", "ctx", "client", "open", "con", "cr", "connection", "ann", "oss", "nec", "Conn", "cat", "ls", "ct", "cp", "addr"], "rd": ["ri", "rer", "rs", "hr", "r", "din", "rr", "rand", "rn", "sr", "rid", "rx", "wr", "ird", "rad", "rar", "rog", "ld", "raf", "vr", "rl", "rob", "red", "ro", "rw", "d", "rh", "usr", "nd", "ra", "mr", "erd", "rc", "rb", "lr", "fr", "dd", "rt", "dr", "reader"], "kit": ["Kit", "util", "html", "ch", "init", "qt", "bh", "tc", "iz", "pack", "sys", "sit", "k", "io", "h", "ang", "kt", "iw", "box", "tk", "kat", "c", "base", "pot", "maker", "webkit", "cam", "ic", "set", "cu", "t", "lib", "pkg", "jit", "ctx", "ok", "sc", "iter", "boot", "js", "shop", "et", "ect", "net", "rot", "cat", "rt", "bot", "mk", "sky"], "doc": ["msg", "html", "p", "head", "tx", "def", "xml", "g", "nt", "ds", "content", "w", "window", "man", "dec", "json", "file", "config", "div", "log", "og", "dat", "ad", "data", "di", "Doc", "pdf", "page", "mu", "body", "in", "md", "t", "out", "dc", "d", "db", "dir", "tree", "js", "sp", "document", "dr", "mk", "n"], "url": ["mail", "Url", "util", "hub", "html", "pl", "cert", "path", "ln", "domain", "server", "org", "mb", "xml", "r", "mount", "log", "gl", "ssl", "host", "resource", "git", "bel", "user", "deb", "dl", "base", "uri", "web", "http", "nl", "sl", "peer", "el", "rl", "impl", "ll", "t", "address", "ref", "https", "loc", "api", "l", "open", "lr", "blog", "URL", "ls", "ur", "ul", "addr"], "it": ["im", "ip", "init", "you", "It", "rit", "nt", "ite", "iz", "IT", "lit", "sit", "io", "ci", "iw", "wait", "ot", "pit", "he", "its", "ic", "in", "t", "out", "at", "l", "ert", "iter", "et", "ct", "ind", "li"], "elem": [" peom", "elt", "tem", "eelt", "belement", "lem", " pelect", "llem", " element", "seem", "telt", "tlect", "tlement", " pelem", "selem", "seelt", " eom", "bem", "sem", " pelement", "eem", "llement", "eleelt", " elect", "elelem", "eleem", "telement", "element", "elect", "belem", "elelement", "eom", "tlem", "em", "tom", "lelt", "selement", "belt", "telem", "selt"], "s": ["sm", "cs", "is", "sq", "ts", "als", "rs", "si", "sa", "ps", "se", "stats", "ats", "ds", "ns", "sb", "sys", "ys", "S", "gs", "sd", "ss", "es", "xs", "sam", "sg", "less", "ess", "sv", "fs", "sts", "space", "sl", "simple", "set", "st", "ins", "ms", "spec", "os", "sym", "js", "sp", "ls"], "lnk": ["olnn", "linko", "lankt", "olnk", "lenk", "nelko", "olnj", "lenak", "nlko", "klk", "lnak", "olnak", "dlak", "dln", "lank", "olnck", "lenck", "dnko", "olnik", "lnek", "nelk", "linik", "dnck", "nlk", "lntk", "dlck", "lnkt", "olnko", "lnck", "nln", "lnj", "nlak", "lnke", "linke", "linck", "klek", "lnn", "dlik", "dnk", "klko", "nelke", "klke", "nltk", "olnkt", "lnik", "linn", "nlck", "dnn", "lenj", "nlkt", "lann", "nelek", "dltk", "linj", "linak", "linek", "dlk", "lanak", "lintk", "lnko"], "j": ["obj", "off", "jump", "uj", "jl", "ji", "g", "v", "ja", "je", "max", "ng", "div", "jc", "pos", "Ja", "h", "k", "oj", "kj", "prime", "q", "J", "bj", "br", "y", "ij", "aj", "t", "dj", "bo", "jp", "o", "adj", "jj", "js", "z", "n", "ind", "li"], "urlLink": ["emailSource", "emaillink", "httpLinks", "emailLink", "objUrl", " urllink", "strLink", "sslLoad", "objLink", "sslLinks", "urlLinks", "UrlLock", "Urllink", "UrlLink", "urlMatch", " urlRel", "urlStart", "httpLoad", " urlUrl", " urlMatch", "strStart", "UrlSource", " urlLinks", "objRel", "urlSource", "urllink", " urlSource", "strRel", "sslLink", "urlLock", "urlRel", "strUrl", "httpLink", "urlUrl", " urlLock", "httpMatch", "sslMatch", "objStart", "urlLoad", "emailLock", " urlLoad", " urlStart"], "str": ["msg", "elt", "stri", "html", "exp", "tr", "p", "string", "vol", "inst", "comm", "char", "part", "inner", "g", "ocr", "r", "w", "temp", "STR", "wr", "div", "f", "txt", "m", "res", "coll", "arr", "ctr", "br", "prefix", "st", "text", "t", "ll", "out", "spec", "chain", "usr", "pkg", "Str", "tree", "stable", "list", "fr", "js", "print", "hex", "dr", "n", "raw"], "i": ["ix", "bi", "im", "ip", "init", "oi", "p", "mi", "x", "gi", "phi", "ui", "si", "ex", "a", "ini", "hi", "info", "ami", "\u0438", "cli", "iu", "start", "io", "ci", "me", "ti", "zi", "multi", "di", "ori", "xi", "batch", "m", "iy", "PI", "y", "ic", "ei", "in", "ims", "ms", "qi", "ity", "chain", "us", "ki", "o", "length", "iter", "ai", "I", "ie", "pi", "sim", "index", "area", "ii", "li"], "skip": ["warn", " skipped", "deep", "ip", "ips", "jump", "cmp", "replace", " bypass", "sk", "process", "add", "copy", "strip", " skipping", "complete", "clip", "ops", "op", "fast", "loop", "Skip", "write", "iter", "pass", "note", "kill", "stop"]}}
{"id1": "8000624", "id2": "2642914", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyFrom", " copiesTo", " copiesInt", "CopyFrom", " copiesFrom", " CopyInt", " CopyFrom", " copyTo", " copyInt", "CopyInt"], "dest": ["name", "origin", "path", "orig", "nom", "est", "p", "image", "Dest", "it", "pipe", "v", "src", "fn", "target", "copy", "w", "temp", "source", "filename", "opt", "tmp", "result", "txt", "cont", "st", "img", "mem", "them", "loc", "usr", "d", "output", "dir", "null", "th", "sp", "cat", "rest"], "in": ["inn", "ire", "al", "inc", "up", "init", "image", "is", "per", "ac", "ain", "it", "mi", "sin", "inner", "isin", "ini", "r", "din", "file", "min", "source", "nin", "bin", "i", "ir", "internal", "read", "gin", "local", "one", "ar", "win", "on", "m", "from", "login", "In", "ins", "inside", " input", "en", "t", "IN", "o", "by", "l", "client", "iter", "con", "ai", " din", "cin", "rin", "input", "re", "net", "reader", "inf", "ind", "thin"], "out": ["obj", "up", "not", "other", "ln", "writer", "full", "it", "Out", "inner", "v", "ex", "nt", "fn", "oe", "w", "outer", "flush", "e", "dis", "aos", "ns", "b", "all", "cos", "io", "one", "conv", "gt", "user", "batch", "res", "ot", "cn", "loss", "op", "t", "en", "at", "o", "ne", "by", "write", "output", "client", "os", "null", "boot", "to", "oss", "end", "co", "con", "outs", "OUT", "na", "list", "net", "note", "can", "n", "ou"], "c": ["character", "cap", "cs", "ch", "ac", "bc", "ec", "char", "cb", "cc", "cd", "arc", "g", "v", "current", "u", "e", "cl", "gc", "i", "k", "f", "uc", "unc", "cont", "cut", "conf", "nc", "code", "t", "lc", "d", "cm", "cf", "l", "sc", "con", "count", "rc", "cr", "ca", "z", "cod", "ce", "cat", "C", "n", "cp", "ct"]}}
{"id1": "530882", "id2": "18613870", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewrites", "readAndrewWrite", "readAndReprites", "readAndResWrite", "readAndResend", "readAndReprite", "readAndResrites", "readAndrewrites", "readAndRepWrite", "readAndrewend", "readAndRewWrite", "readAndResrite", "readAndRepend", "readAndRewend", "readAndrewrite"], "inFile": [" inFilename", "outFilename", "InFile", "outfile", "inTime", "INTime", "inputPlace", "inFace", "INFILE", "initPlace", " infile", "docFILE", "initFilename", "inFilename", "inputFilename", "iTime", "INFile", "initFace", "INFace", "InFilename", "iFILE", "Infile", "infile", "INPlace", "docFilename", "docFile", "inputFile", "INFilename", "inPlace", "iFile", "docTime", "iFilename", "initFile", "inFILE", "inputFace"], "outFile": [" outFILE", "outFilename", "reportFile", "outfile", "reportFILE", "nameFile", "nameFilename", "checkfile", "toFile", "inFilename", " outFilename", "reportfile", "checkFile", "nameFILE", "checkFILE", "checkFilename", "reportFilename", "infile", "toFilename", "outFILE", "toFILE", "namefile", "tofile", " outfile", "inFILE"], "iis": ["diIs", " iisc", " iIS", "IIs", "Ii", "eis", "liIs", "diiss", " ii", "iisc", "dii", "liisc", " iIs", " iiss", "Iis", "iIs", "iiss", "liis", "aiis", "iiris", "aiIS", "Iiss", "iiIs", "aiIs", "iris", "iiisc", "liris", " iris", "eIS", "iiis", "eIs", "diis", "iIS", "ii"], "dcmParser": ["dpmStatement", " dcmLoader", "dmmparser", "DpmParser", "DpmReader", "dpmPar", "dmmmParser", "decmarser", "Dpmparser", "dfmLoader", "dmmReader", " dpmarser", "decmReader", "DcmReader", "dcommParser", "dpmParser", "dpmPrivate", " dcmAssistant", " dpmparser", "deromReader", "dmReader", "dcfStatement", "deromParser", " dpmAssistant", "DcmBuilder", "DcmAdapter", "dcomBuilder", "deromarser", " dpmParser", " dpmPrivate", " dcmStatement", "dmarser", "dcrparser", "dcomLoader", "dromReader", "dmmarser", "dmmParser", "dmmmparser", "dcomParser", "dcfReader", "dpmBuilder", "dgrPar", "dpmReader", "dromparser", "dcmStatement", "dcmPrivate", " dpmListener", " dpmStatement", "dmparser", "dpmLoader", "dfmReader", "drumPar", "dpmListener", " dcmarser", "dfmParser", "Dcmparser", "dgrReader", "dcmAdapter", "dmoduleAssistant", "dmmAdapter", "DcmPar", "dcmLoader", "dromListener", "dpcParser", "dpcReader", "dcrBuilder", " dcmReader", "dromarser", "dfmBuilder", "DpmBuilder", " dcmparser", "dpcAssistant", "dcmPar", "dcommListener", " dcmPrivate", " dcmBuilder", "decmParser", "dgrStatement", "decmparser", "dcmAssistant", "drumBuilder", "dcmListener", "dcommReader", "DcmParser", " dpmPar", "drumReader", " dpmLoader", "dmParser", "dcmReader", " dcmListener", "dcommAssistant", "dmodulePrivate", " dcmPar", "DpmAdapter", "dcomReader", "dcmarser", "dgrParser", "dpmparser", "dmmmReader", "dromParser", "DpmPar", "dpmAssistant", "dcfParser", "dcrParser", "dpmAdapter", "dromAssistant", "drumParser", " dpmBuilder", " dpmReader", "dpmarser", "dcfPar", "deromparser", "dpcPrivate", "dmoduleReader", "dmoduleParser", "dmmmAdapter", "dcmparser", "dcmBuilder", "dcrReader"], "ds": ["obs", "cs", "ws", "gd", "bs", "ods", "Ds", "rs", "tes", " DS", "ps", "drivers", "sets", "dh", "ns", "aos", "dx", "der", "DS", "hd", "bd", "sys", "ys", "ils", "gs", "sd", "dat", "ss", "es", "data", "uds", "xs", " des", "sv", "dl", "fs", "services", "ads", "eds", "its", "details", "in", "da", "ims", "ins", "dds", "pers", "vs", "d", "des", "db", "eps", "dos", "os", "dt", "s", "dq", "js", "outs", "qs", "dd", "hs", "ks", "ls", "as", "df", "pd"], "pdReader": ["vdWriter", "pedRunner", "xdHelper", "ddHelper", "tdParser", "pdParser", "dpLoader", "pdCar", "ddParser", "ddRunner", "vdReader", "pedReader", "pdRunner", "pdHelper", "ddLoader", "pedLoader", "pdLoader", "ddRead", "ddWriter", "hdReader", "dpReader", "ddReader", "vdHelper", "pedCar", "pdRead", "tdRead", "hdWriter", "xdReader", "xdLoader", "xdWriter", "dpRunner", "vdLoader", "ddCar", "dpCar", "hdRead", "hdParser", "tdWriter", "tdReader"], "out": ["obj", "cache", "conn", "p", "Out", "ex", "v", "cmd", "pos", "io", "one", "data", "res", "in", "str", "end", "list", "name", "auto", "msg", " err", "full", "writer", "cb", "inv", "pool", "opt", "on", "sw", "cfg", "we", "at", "gr", "os", "con", "oss", "outs", "screen", "OUT", "net", "raw", "cn", "up", "nt", "w", "outer", "ent", "all", "nr", "err", "tmp", "conv", "gt", "gen", "id", "c", "sum", "ins", "o", "output", "null", "co", "js", "desc", "ou", "go", "ch", "it", "inner", "aos", "flush", "sys", "log", "serv", "inter", "txt", "status", "t", "en", "client", "s", "to", "over", "n"], "dcmEncParam": ["dcmencMsg", "dmmencMsg", "dmmEncPar", "dmmEnNum", "dmmencNum", "dmmEncParam", "dcmEncVal", "dmmEnParam", "dcmEscNum", "dmmEncMsg", "dmmEnPar", "dcmDecCmd", "dcmEnParam", "dcmencParam", "dcmencPar", "dcmDecMsg", "dcmEnPar", "dcmDecParam", "dcmEscVal", "dcmEnNum", "dcmEncPar", "dmmencCmd", "dcmencCmd", "dmmEncVal", "dcmEnVal", "dcmencNum", "dcmDecNum", "dcmEncNum", "dcmEncMsg", "dmmEncNum", "dmmEncCmd", "dcmEscParam", "dcmEncCmd", "dcmEscPar", "dmmencParam"], "pdWriter": ["PDEditor", "pcWriter", "tdWriter", "dpEditor", "PDReader", "PDWrite", "pdWrite", "pidWriting", "PDWriter", "pdwriter", "dpReader", "dpWriter", "tdEditor", "pdEditor", "pidWriter", "pcWrite", "pcWriting", "pcwriter", "dpWrite", "pidwriter", "tdWriting", "tdwriter", "pidWrite", "pdWriting", "tdWrite", "tdReader"]}}
{"id1": "12380475", "id2": "22801734", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"transport": ["interport", "exmit", "trports", "transports", "traaction", "exports", "transceive", "trceive", "Transmit", "Transport", "transaction", "export", "traceive", "transmit", "exlate", "interlate", "traport", "trport", "interceive", "intermit", "Transceive", "exaction", "traports", "translate", "traction", "Translate", "exceive"], "file": ["port", "link", "File", "p", "info", "io", "channel", "data", "user", "f", "valid", "create", "spec", "table", "running", "block", "tree", "input", "document", "directory", "name", "url", "path", "domain", "full", "pool", "message", "current", "title", "entity", "e", "event", "config", "source", "resource", "type", "force", "report", "http", "rule", "use", "ile", "fp", "attribute", "remote", "record", "template", "comment", "base", "out", "relation", "db", "module", "output", "null", "be", "handle", "key", "image", "entry", "folder", "log", "local", "FILE", "page", "t", "class", "work", "get", "dir", "line", "format"], "files": ["assets", "Files", "fields", "lines", "uploads", "names", "pages", "members", "classes", "mails", "reports", "thumbnails", "keys", "scripts", "projects", "checked", "faces", "issues", "fs", " Files", "photos", "packages", "modules", "tests", "jobs", "ids", "objects", "iles", "ories", "balls", "types", "times", "books", "items", "styles", "ors", "papers", "plates", "headers", "images", "ls"], "i": ["ix", "im", "bi", "ip", "init", "is", "mi", "x", "phi", "gi", "ui", "inner", "si", "ini", "u", "e", "cli", "b", "cos", "gu", "io", "ci", "me", "ti", "multi", "j", "di", "id", "m", "batch", "base", "uri", "ii", "y", "ic", "in", "ims", "ms", "qi", "t", "us", "ki", "client", "iter", "ai", "I", "ie", "my", "pi", "sim", "uu", "li"], "inChannel": ["createPanel", "dinConnection", "Inchannel", "fromFace", "innchannel", "InStream", " inConnection", "createFace", "openFace", "dinChannel", "InChannel", "inFace", "openCategory", "fromCategory", "openPanel", "dinChan", "createCategory", "innStream", "inStream", "openChannel", "InConnection", "fromPanel", "inchannel", "inCategory", "inConnection", "fromChannel", "innChannel", " inStream", " inChan", "createChannel", "innChan", "inPanel", "InChan", "dinchannel", "inChan", " inchannel"], "outChannel": ["OUTCh", " outChan", "outCh", "outStream", "outputchannel", " outCh", "OUTchannel", " outConnection", "outputChan", "outputCh", "OUTChannel", "outputChannel", "outchannel", " outchannel", "outChan", "inStream", "outputConnection", "OUTChan", "inConnection", "outConnection", " outStream", "inChan", "outputStream"]}}
{"id1": "364438", "id2": "5035872", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "conVERT", "consvert", "CONversion", "conversion", "unfer", "converted", "compvert", "compversion", "consversion", "compverts", "Converted", "unversion", "converting", "CONverted", "CONfer", "unvert", "converts", "consVERT", "Conversion", "CONverting", "conprocess", "ConVERT", "CONVERT", "CONvert", "consverting", "Confer", "unverted", "confer", "Conprocess", "unverts", "compprocess", "Convert", "Converts", "unprocess"], "src": ["Source", "scan", "url", "hl", "path", "orig", "attr", "sq", "inst", "addr", "cc", "sin", "rs", "stream", "ource", "href", "sr", "rx", "file", "config", "source", "ebin", "start", "filename", "sys", "SourceFile", "sit", "ipl", "host", "func", "RC", "scene", "iv", "txt", "from", "cont", "uri", "http", "its", "st", "str", "ser", "ins", "cur", "img", "loc", "rel", "usr", "pkg", "buster", "sc", "ur", "req", "rc", "s", "dist", "input", "SOURCE", "rest", "upload"], "dest": ["port", " destinations", "orig", "est", "Dest", "mat", " Destination", "target", "temp", " orig", "source", " destination", "gin", "dat", "result", "txt", " dst", " Dest", "img", "test", "foreign", "write", "table", "tif", "disk", "dir", "dist", "rest"], "in": ["inn", "up", "is", "inner", "stream", "isin", "r", "din", "file", "source", "b", "bin", "i", "io", "serv", "ad", "ar", "m", "from", "res", "In", "el", "sql", "st", "ins", "en", "IN", "d", "l", "input", "cin", "rin", "reader", "as", "inf", "ind"], "p": ["fp", "pc", "php", "pl", "pp", "per", "it", "part", "g", "ps", "r", "pro", "py", "pg", "vp", "b", "ph", "i", "h", "ap", "parser", "P", "parse", "j", "pa", "pd", "f", "m", "lp", "c", "ping", "rep", "pm", "post", "prot", "op", "t", "pre", "er", "pers", "at", "jp", "dp", "d", "pb", "l", "pkg", "wp", "pt", "pi", "sp", "cp", "pe", "tp"], "ds": ["cs", " os", "ports", "drivers", "dh", " ads", "ss", "scripts", "di", "dates", "edes", "sts", " d", "tests", "nas", "dds", "aws", "hd", "obs", "posts", "bs", "rs", "cks", "DS", "ys", "uds", " dd", "eds", "its", "vs", "dp", "d", "os", "terms", "outs", "qs", "dd", "pd", "tp", "ras", "ts", "ods", "Ds", "tes", " DS", "ps", "points", "ils", "gs", "amps", "docs", "xs", "ands", " des", "workers", "lists", "ads", "des", "db", "eps", "dos", "iffs", "dt", "js", "ks", "ls", "mys", "yes", "ws", "gd", "ats", "els", "sets", "ns", "sd", "tags", "loads", "dl", "ags", "s", "hs", "df"], "format": ["name", "unit", "lat", "path", "shape", "version", "it", "settings", "mat", "pattern", "act", "fm", "MAT", "ats", "title", "file", "source", "layout", "parse", "sche", "template", "top", "id", "fc", "f", " Format", "type", "mode", "status", "form", "tag", "feature", "set", "t", "spec", "at", "cf", "table", "output", "module", "l", "policy", "feat", "size", "pretty", "pi", "filter", "mt", "ct", "style", "Format"], "hasPixelData": ["haspixelDATA", "hasFramedata", "HaspixelData", "hasixelData", "hasPixeldata", "hasixelDATA", "hasFrameDATA", "hasFrameData", " hasPixelDATA", "HasPixelDATA", "hasPixelDATA", "HasPixelData", "HaspixelDATA", "haspixeldata", "Haspixeldata", "HasPixeldata", " hasPixeldata", "hasixeldata", "haspixelData"], "inflate": ["Informate", "inFlocate", "informate", "invalidocate", " invalidATE", "inflATE", "inflated", "informated", "inFLated", "infolat", "incelicate", "inFlATE", "informat", "Inflat", "infolated", "invalidicate", "inFLat", "informocate", "incelocate", "Inflocate", "inFlate", "Informocate", "inFLocate", "incelate", "inflocate", "invalidate", "inFLate", " inflocate", "infolate", "inflicate", "invalidATE", "infolocate", "inFlicate", "Informated", " invalidicate", "Inflated", " invalidate", "incelATE", "inflat", " invalidocate", "Inflate", " inflicate", " inflATE", "Informat"], "pxlen": ["packls", "mxdec", "pexlen", "packln", "pxls", "pexfun", "xpden", "mxln", "phpdec", "tmpln", "pxden", "mxlength", "mmlen", "xyln", "mmln", "phpln", "pixellength", "pxdec", "xplen", "pixells", "pexln", "tmplength", "xylength", "cpden", "pxlin", "tmplin", "mmlength", "phplength", "pixelfun", "xylin", "cplength", "mmlin", "packdec", "pxln", "pexlength", "xylen", "tmplen", "xplength", "pxfun", "phplen", "mxlen", "pxlength", "pexls", "pexden", "pixellen", "packlen", "xpln", "packfun", "cplen", "cpln", "packlength"], "out": ["name", "msg", "obj", "group", "up", "conn", "ln", "init", "writer", "gov", "inv", "Out", "ex", "aos", "outer", "temp", "cmd", "log", "err", "sys", "io", "inter", "user", "crit", "res", "cfg", "sum", "store", "prefix", "client", "output", "dir", "gr", "list", "outs", "OUT", "screen", "net", "pretty", "print", "ou"]}}
{"id1": "13720140", "id2": "10715601", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"modifyProperty": ["modateProperty", "modifyProp", "ModifiesProp", "modateAttribute", "ModifyAttribute", "ModifiesAttribute", "modureValue", "ModifyProperty", "modifiesAttribute", "modureAttribute", "modateProp", "ModifiesProperty", "modureProperty", "ModifyValue", "ModifiesValue", "modateValue", "modureProp", "modifiesProp", "modifiesProperty", "ModifyProp", "modifyValue", "modifiesValue", "modifyAttribute"], "valueID": ["versionIDs", "versionId", "versionid", "propertyid", " valueid", " valueMD", "valueIDs", "valueid", " valueId", "versionUID", "VALUEId", " valueUID", "valueId", "VALUEMD", "propertyId", "valueUID", "propertyIDs", "VALUEID", "VALUEUID", "versionID", "valueMD", "propertyID", "versionMD", " valueIDs"], "value": ["attribute", "name", "key", "version", "string", "description", "v", "message", "current", "memory", "entry", "content", "expression", "label", "hello", "values", "update", "buffer", "variable", "function", "val", "data", "padding", "default", "password", "example", "Value", "application", "comment", "type", "save", "format", "vector", "instance", "text", "code", "address", "output", "get", "VALUE", "input", "field", "state"], "userID": ["UserURL", "usernameID", "UserType", "usernameName", "ownerName", "userName", "ownerID", "userId", " userName", "UserID", " userId", " userURL", "userURL", "usernameId", " userType", "usernameURL", "userType", "UserId", "ownerType", "UserName", "ownerId"], "property": ["attribute", "name", "option", "metadata", "key", "state", "claim", "p", "operator", "display", "this", "ty", "description", "message", "title", "expression", "associated", "label", "config", "second", "alias", "prop", "resource", "profile", "function", "data", "translation", "method", "media", "setup", "project", "type", "prototype", "command", "feature", "object", "Property", "prefix", "language", "item", "address", "relation", "module", "table", "policy", "term", "section", "position", "to", "license", "field", "print", "pair", "style", "pe", "properties"], "newValue": ["NEWValue", " newValues", "oldMessage", "Newvalue", "newMessage", "newValues", "newVersion", "newString", " newResult", "newName", " newVersion", "oldName", "oldResult", "uniqueValue", "oldVersion", "uniqueName", "newvalue", "NewString", "oldValue", " newName", " newvalue", "uniqueMessage", "NEWString", "oldValues", "oldvalue", "oldString", "NEWResult", "newResult", "NewValue", "NewValues", " newString", " newMessage", "NEWvalue", "uniqueVersion"], "crypt": ["bec", "sm", "roy", "cs", "ch", "go", "init", "cert", "magic", "cmp", "comm", "auth", "cc", "cot", "enc", "ocr", "nt", "mac", "dec", "cmd", "gc", "cos", "sys", "ssl", "cry", "col", "conv", "rem", "password", "Crypt", "arch", "sync", "cont", "coll", "ctr", "CR", "cook", "check", "hash", "prot", "coin", "mem", "code", "cy", "cur", "rh", "cm", "pt", "cr", "core", "dict", "reset", "rot", "hex", "trust", "ct", "cp", "rypt"], "digest": ["hexEST", " Digest", "mdested", "dEST", "Digest", "digestamp", "dester", "mdEST", "mdge", "dest", " digested", "Digester", " digestamp", " DigEST", "Digge", "digert", "Diggest", "diggest", "mdest", "hashest", "mdester", "digge", "digests", "mdgest", "Digestamp", "Digert", "digested", "hashge", " Digert", "hexest", "digEST", " Digester", " digEST", "hashgest", "DigEST", "digester", "hexert", "Digests", "mdestamp", "dested", "Digested", "hexester", "mdests", "hashests"], "hexString": ["hexBytes", "shortStr", "hashstring", " hexArray", "hexArray", " hexstring", " hexBuffer", "exArray", "exBytes", "formBytes", " hexBytes", "hashStr", "hexstring", "exString", "hashArray", "formBuffer", "exBuffer", "formStr", "shortstring", "formString", "hashString", "exstring", "shortString", "shortBuffer", " hexStr", "exStr", "hexStr", "hexBuffer"], "i": ["ix", "bi", "im", "ip", "init", "span", "is", "it", "x", "mi", "phi", "gi", "ui", "ji", "si", "v", "a", "ex", "ini", "info", "hi", "major", "u", "e", "cli", "\u0438", "number", "point", "gu", "io", "ci", "ti", "j", "multi", "di", "id", "m", "uri", "ii", "q", "y", "ic", "ei", "slice", "ms", "qi", "chain", "us", "ki", "o", "ai", "I", "ie", "pi", "sim", "index", "ind", "li"]}}
{"id1": "149935", "id2": "17558353", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            URL urlhome = new URL(\"http://www.verussolutions.biz/NGLDashBoard.xml\");\n            URLConnection uc = urlhome.openConnection();\n            InputStreamReader input = new InputStreamReader(uc.getInputStream());\n            BufferedReader in = new BufferedReader(input);\n            String inputLine;\n            String xmlData = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                xmlData += inputLine;\n            }\n            in.close();\n            PrintWriter fw = new PrintWriter(new FileWriter(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            fw.println(xmlData);\n            fw.flush();\n            fw.close();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n        try {\n            Document doc = new SAXBuilder().build(new File(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            String onlinsuppcdat = doc.getRootElement().getChild(\"OnlineSupportInformation\").getText();\n            CDATA cdata = new CDATA(onlinsuppcdat);\n            host.setOnlineInformationHTML(cdata.getText());\n            onlinsuppcdat = doc.getRootElement().getChild(\"News\").getText();\n            cdata = new CDATA(onlinsuppcdat);\n            host.setNewsHTML(cdata.getText());\n            host.fillData();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["Converting", "conVERT", "consvert", "CONversion", "conversion", "unfer", "converted", "compvert", "compversion", "consversion", "compverts", "Converted", "unversion", "converting", "CONverted", "CONfer", "unvert", "converts", "consVERT", "Conversion", "CONverting", "conprocess", "ConVERT", "CONVERT", "CONvert", "consverting", "Confer", "unverted", "confer", "Conprocess", "unverts", "compprocess", "Convert", "Converts", "unprocess"], "src": ["Source", "scan", "url", "hl", "path", "orig", "attr", "sq", "inst", "addr", "cc", "sin", "rs", "stream", "ource", "href", "sr", "rx", "file", "config", "source", "ebin", "start", "filename", "sys", "SourceFile", "sit", "ipl", "host", "func", "RC", "scene", "iv", "txt", "from", "cont", "uri", "http", "its", "st", "str", "ser", "ins", "cur", "img", "loc", "rel", "usr", "pkg", "buster", "sc", "ur", "req", "rc", "s", "dist", "input", "SOURCE", "rest", "upload"], "dest": ["port", " destinations", "orig", "est", "Dest", "mat", " Destination", "target", "temp", " orig", "source", " destination", "gin", "dat", "result", "txt", " dst", " Dest", "img", "test", "foreign", "write", "table", "tif", "disk", "dir", "dist", "rest"], "in": ["inn", "up", "is", "inner", "stream", "isin", "r", "din", "file", "source", "b", "bin", "i", "io", "serv", "ad", "ar", "m", "from", "res", "In", "el", "sql", "st", "ins", "en", "IN", "d", "l", "input", "cin", "rin", "reader", "as", "inf", "ind"], "p": ["fp", "pc", "php", "pl", "pp", "per", "it", "part", "g", "ps", "r", "pro", "py", "pg", "vp", "b", "ph", "i", "h", "ap", "parser", "P", "parse", "j", "pa", "pd", "f", "m", "lp", "c", "ping", "rep", "pm", "post", "prot", "op", "t", "pre", "er", "pers", "at", "jp", "dp", "d", "pb", "l", "pkg", "wp", "pt", "pi", "sp", "cp", "pe", "tp"], "ds": ["cs", " os", "ports", "drivers", "dh", " ads", "ss", "scripts", "di", "dates", "edes", "sts", " d", "tests", "nas", "dds", "aws", "hd", "obs", "posts", "bs", "rs", "cks", "DS", "ys", "uds", " dd", "eds", "its", "vs", "dp", "d", "os", "terms", "outs", "qs", "dd", "pd", "tp", "ras", "ts", "ods", "Ds", "tes", " DS", "ps", "points", "ils", "gs", "amps", "docs", "xs", "ands", " des", "workers", "lists", "ads", "des", "db", "eps", "dos", "iffs", "dt", "js", "ks", "ls", "mys", "yes", "ws", "gd", "ats", "els", "sets", "ns", "sd", "tags", "loads", "dl", "ags", "s", "hs", "df"], "format": ["name", "unit", "lat", "path", "shape", "version", "it", "settings", "mat", "pattern", "act", "fm", "MAT", "ats", "title", "file", "source", "layout", "parse", "sche", "template", "top", "id", "fc", "f", " Format", "type", "mode", "status", "form", "tag", "feature", "set", "t", "spec", "at", "cf", "table", "output", "module", "l", "policy", "feat", "size", "pretty", "pi", "filter", "mt", "ct", "style", "Format"], "hasPixelData": ["haspixelDATA", "hasFramedata", "HaspixelData", "hasixelData", "hasPixeldata", "hasixelDATA", "hasFrameDATA", "hasFrameData", " hasPixelDATA", "HasPixelDATA", "hasPixelDATA", "HasPixelData", "HaspixelDATA", "haspixeldata", "Haspixeldata", "HasPixeldata", " hasPixeldata", "hasixeldata", "haspixelData"], "inflate": ["Informate", "inFlocate", "informate", "invalidocate", " invalidATE", "inflATE", "inflated", "informated", "inFLated", "infolat", "incelicate", "inFlATE", "informat", "Inflat", "infolated", "invalidicate", "inFLat", "informocate", "incelocate", "Inflocate", "inFlate", "Informocate", "inFLocate", "incelate", "inflocate", "invalidate", "inFLate", " inflocate", "infolate", "inflicate", "invalidATE", "infolocate", "inFlicate", "Informated", " invalidicate", "Inflated", " invalidate", "incelATE", "inflat", " invalidocate", "Inflate", " inflicate", " inflATE", "Informat"], "pxlen": ["packls", "mxdec", "pexlen", "packln", "pxls", "pexfun", "xpden", "mxln", "phpdec", "tmpln", "pxden", "mxlength", "mmlen", "xyln", "mmln", "phpln", "pixellength", "pxdec", "xplen", "pixells", "pexln", "tmplength", "xylength", "cpden", "pxlin", "tmplin", "mmlength", "phplength", "pixelfun", "xylin", "cplength", "mmlin", "packdec", "pxln", "pexlength", "xylen", "tmplen", "xplength", "pxfun", "phplen", "mxlen", "pxlength", "pexls", "pexden", "pixellen", "packlen", "xpln", "packfun", "cplen", "cpln", "packlength"], "out": ["name", "msg", "obj", "group", "up", "conn", "ln", "init", "writer", "gov", "inv", "Out", "ex", "aos", "outer", "temp", "cmd", "log", "err", "sys", "io", "inter", "user", "crit", "res", "cfg", "sum", "store", "prefix", "client", "output", "dir", "gr", "list", "outs", "OUT", "screen", "net", "pretty", "print", "ou"]}}
{"id1": "22560224", "id2": "11005804", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"hashStringMD5": [" hashBytesMT0", " hashStringMD1", " hashBytesMT1", " hashBytesMD5", " hashStringSHA1", " hashStringMD0", " hashStringMT0", " hashBytesMT5", " hashStringSM5", " hashStringSHA5", " hashBytesMD1", " hashStringMDHash", " hashStringMT5", " hashStringSHA0", " hashBytesMDHash", " hashBytesMD0", " hashStringSMHash", " hashStringSHAHash", " hashBytesMTHash", " hashStringSM0", " hashStringMT1", " hashStringSM1", " hashStringMTHash"], "string": ["name", "sequence", "array", "char", "strings", "v", "message", "content", "value", "number", "file", "source", "buffer", "filename", "host", "function", "data", "password", "result", "comment", "space", "setting", "site", "sql", "prefix", "object", "service", "str", "text", "ring", "spec", "address", "test", "word", "null", "s", "list", "input", "ident", "print", "format"], "md": ["sm", "amd", " MD", "dr", "and", "mt", "cd", "mb", "MD", "add", "nt", "dm", "dh", "mm", "der", "od", "cmd", "grad", "hd", "ind", "bd", "de", "alg", "sd", "mod", "ad", "di", "ld", "m", "det", " Md", "mode", "down", "Cmd", "cond", "red", "ms", "desc", "mn", "d", "nd", "dir", "mand", "dist", "dd", "mc", "pdf", "mk", "df", "pd"], "byteData": ["ByteBytes", "componentData", "byteParts", "byteForm", " ByteBuffer", "ByteDat", "ByteBuffer", "ByteParts", "byteLens", " ByteLens", " byteParts", "wordData", "bytedata", "displayDo", "nodeLens", " byteCount", "ByteDo", "byteCount", "phraseBytes", " bytedata", "componentBytes", "phraseDo", "viewData", "chardata", " byteBuffer", "phraseDat", "displayData", "viewDo", "seeLens", "seeData", " ByteData", "charData", "ByteData", "displaydata", "phraseData", "seeForm", "componentBuffer", "helloData", "charDATA", "byteDATA", "seeBuffer", "componentParts", " ByteForm", "helloBytes", "byteDat", " byteDATA", "viewdata", "helloDat", " byteDo", "nodeForm", "worddata", "nodeBuffer", " byteBytes", "helloDo", "wordDATA", "byteBytes", "byteBuffer", "viewCount", "displayCount", "byteDo", "nodeData"], "sb": ["erb", "bg", "alph", "ib", "ws", "sq", "soc", "shell", "bs", "cb", "sth", "sh", "mb", "sa", "bh", "src", "nb", "lb", "b", "ssl", "bsp", "bb", "sg", "sam", "sw", "sv", "eb", "sync", "bash", "web", "gb", "bf", "bj", "sf", "kb", "pb", "bt", "sc", "rb", "SB", "zb", "sp", "xb"], "i": ["ix", "im", "cgi", "phi", "ui", "ex", "v", "hi", "info", "ski", "gu", "io", "ci", "multi", "di", "uri", "kj", "ic", "set", "ity", "in", "ei", "qi", "I", "list", "my", "ii", "name", "si", "series", "iu", "point", "xi", "m", "ki", "remote", "ip", "ri", "span", "this", "g", "cli", "json", "\u0438", "err", "me", "zi", "conv", "id", "batch", "base", "c", "q", "y", "ij", "chain", "history", "o", "ai", "z", "ie", "yi", "print", "bi", "init", "oi", "any", "mi", "it", "gi", "ji", "ini", "ti", "j", "iy", "us", "er", "client", "pi", "iq", "li"], "hexString": ["pexString", " hexScreen", "alphaStr", "hexNumber", " hexBuffer", "serialStr", "hexSite", " hexNumber", "serialString", "sexList", "alphaScreen", "expNumber", "expSet", "expBuffer", "sexStatement", "sexString", "viewSet", "exSocket", "hexList", "pexList", " hexSite", "httpSite", "viewBuffer", "hexScreen", "hexSocket", "exText", "exString", "alphaString", "expString", "pexSocket", "exBuffer", "viewString", "httpString", "exStatement", "exList", "serialBuffer", "pexStatement", "hexBuffer", "hexText", "serialText", "httpScreen", "viewNumber", "hexSet", " hexText", "httpStr", " hexSet", " hexStr", "sexSocket", "exStr", "hexStr", "alphaSite", "hexStatement"], "hex": ["zh", "xf", "hl", "html", "comp", "hp", "ip", "none", " ex", "exp", "full", "tx", "x", "tex", "aux", "char", "def", "handle", "cmp", "sh", "rex", "ex", "hi", "json", "hello", "lit", "ph", "h", "prop", "sex", "hz", "ext", "dump", "hw", " Hex", "sv", "cont", "oct", "he", "com", "form", "pex", "hash", "buff", "des", "rh", "term", " sex", "cat", "print", "raw"]}}
{"id1": "14783950", "id2": "8132219", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["composeWithoutExt", "composeWithoutFiles", "compressWithzip", "compressWithoutExt", "composeWithoutzip", "compressByFiles", "compresswithZip", "compressByExt", "compressByzip", "composeWithFiles", "composeWithZip", "compresswithFiles", "compresswithExt", "compresswithzip", "compressWithExt", "compressWithoutFiles", "compressWithFiles", "composeWithExt", "compressWithoutZip", "compressByZip", "compressWithoutzip", "composeWithzip", "composeWithoutZip"], "fileList": ["fileLIST", " fileSet", "tileSet", " fileCode", "itemNames", "resourceLock", "wordSet", "pageSet", "tileList", "wordIterator", "pageLIST", "ilelist", "filelist", "ileLIST", "tileLIST", "pageL", " FileCode", "pagelist", "pageList", "fileLock", " FileList", " FileSet", "wordLIST", "fileIterator", "ileL", "ileList", " filelist", "fileNames", " fileNames", " fileIterator", "fileCode", " fileLock", "resourceNames", "tileIterator", "fileSet", "wordList", " fileL", "resourceList", "pageCode", "itemList", " fileLIST", " FileLIST", "itemLock", "fileL"], "zipFileName": ["zFileName", "zipileName", " zipFileNames", " zipfileName", "zipFileFilename", "zipFilenameFilename", "zipfileFilename", "zipFileNames", "zipDirPath", " zipfileNames", "zFileFilename", "zipilename", "zipileFilename", "zFilenamePath", " zipFileFilename", "zipFilenameName", "zipFilenamename", " zipfilePath", "zFilename", "zipDirFilename", "zipFilePath", "zipFilename", "zipfileNames", "zipfilePath", " zipfileFilename", "zipFilenameNames", "zipFilenamePath", " zipFilePath", "zipDirNames", "zFilenamename", "zipDirName", "zipfileName", "zFilePath", "zipilePath", "zFilenameName", "zipfilename", "zFilenameFilename"], "fos": ["fOS", "flOS", "woos", "wOS", "Foos", "woss", "lfis", "flis", "lfoos", "flos", "wos", "lfos", "foss", "lfOS", "Foss", " fOS", " foos", "lOS", "loss", "loos", "FOS", "foos", "Fos", "los", "floos"], "zos": ["zip", "zh", "zin", "es", "zag", "ws", "zo", "css", "sbm", "ps", "zers", "enz", "hess", "sis", "han", "zon", "ossus", "ss", "zi", "hz", "zes", "iaz", "rez", "less", "ez", "zar", "ses", "zero", "ess", "zzle", "Sax", "webkit", "zan", "zik", "ippers", "rys", "nz", "bes", "za", "los", "cz", "os", "eros", "jas", "oss", "enos", "iners", "js", "z", "zer", "zb", "zu", "zen", "ze"], "iter": ["orient", "iterator", "ter", "former", "where", "ip", "exp", "tr", "is", "it", "ver", "iver", "izer", "inner", "order", "loader", "ator", "ait", "kit", "outer", "train", "ee", "ipper", "walker", "i", "Iterator", "ger", "here", "iner", "ir", "inter", "ptr", "user", "cer", "gener", "iv", "maker", "coll", "el", "valid", "ner", "its", "ser", "fer", "er", "loc", "loop", "vis", "liter", "Iter", "list", "re", "oper", "reader", "li"], "fileName": [" fileSet", "fNames", "getStore", "tableSet", "getSource", "localName", "FileName", "FileNames", "fileStore", "ileBody", "ilePath", "fileSource", "ileNAME", "fBody", "tableName", "fileNumber", "filename", "shortStore", "fieldList", "shortname", " fileString", "ilename", "filePath", " fileNumber", "ileList", "fieldname", "fileNames", " fileNames", " fileCurrent", "getName", "ileNumber", "fName", "shortSource", "fString", "localList", "fileNAME", "ileSet", "getname", "ileSource", " fileStore", "Filename", " filename", " filePath", "FilePath", "ileName", "fileSet", "fNumber", "localname", "fileString", "FileCurrent", "fileCurrent", "fileBody", "localNAME", "fieldName", " fileBody", "fname", " fileSource", "fieldNAME", "ileCurrent", "ileString", "tablePath", "fSource", "FileString"], "ind": ["inn", "inc", "stick", "pl", "hend", "find", "bind", "cd", "typ", "index", "ent", "pos", "div", "pred", "Ind", "i", "mod", "IND", "j", "ptr", "ded", "ld", "num", "mind", "med", "cand", "cond", "draw", "butt", "md", "red", "dj", "loc", "kind", "d", "wind", "seed", "nd", "req", "count", "dial", "roll", "cod", "td", "sign", "att", "inder", "n"], "shortName": ["fullType", "ShortFilename", "smallCode", "ShortString", "fullName", "ShortCode", "ShortName", "shortType", "quickKey", "shortKey", "ShortKey", "Shortname", " shortname", "recentFilename", "shortname", "fullname", "recentCode", "smallname", "shortCode", " shortType", " shortString", "ShortType", "quickString", "shortFilename", "recentname", "shortString", " shortKey", "smallName", "fullString", "smallFilename", "recentName", "quickName", "quickname"], "fis": ["cfris", "sfois", "Fis", "wi", "ufIs", "sfIs", "ufis", "hi", "hris", "FIs", " fIs", "Fris", "his", "sfis", "wis", "ufois", "pis", "fi", "cfois", "cfi", "cfis", " fris", "pois", "fIs", "pris", "fris", "wIs", "hois", "ufris", "pi", "ufi", "wois", "fois", "sfi"], "buf": ["cap", "msg", "orig", "cv", "tr", "bc", "bus", "cb", "bytes", "bl", "fam", "seq", "temp", "cmd", "b", "bed", "buffer", "bin", "uf", "Buffer", "conv", "bar", "box", "tab", "batch", "arr", "mu", "br", "fg", "img", "bag", "cur", "mem", "Buff", "buff", "ref", "wb", "pkg", "vec", "db", "block", "rb", "fb", "cat", "aka", "var"], "bytesRead": ["bytesNeed", " bytesNeed", "bytesLength", "flowsLoad", "secondsLoad", "blocksRead", "flowsFind", "bytesLoad", "usersFind", "bytesWritten", "BytesRead", " bytesLength", "linesNeed", "postsRead", "BytesWritten", "bytesReady", "flowsReady", "BytesNeed", " bytesWrite", "secondsWrite", "secondsWritten", "blocksWritten", "postsLoad", "postsReady", "blocksWrite", "blocksLoad", " bytesWritten", "bytesFind", "secondsRead", "linesLength", "usersLoad", "linesRead", "linesWritten", "flowsRead", " bytesLoad", "usersRead", "bytesWrite", "postsFind", "usersReady", "BytesLength"]}}
{"id1": "2642914", "id2": "19467540", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "label": 0, "substitutes": {"addFileToTarGz": ["addFileToTarGep", "addFileToTarGszip", "addFileToTarRw", "addFileToTarBx", "addFileToTarJx", "addFileToTarJzip", "addFileToTarJz", "addFileToTarGx", "addFileToTarGzip", "addFileToTarBw", "addFileToTarGp", "addFileToTarBz", "addFileToTarRzip", "addFileToTarGst", "addFileToTarBzip", "addFileToTarGet", "addFileToTarGsp", "addFileToTarGw", "addFileToTarGezip", "addFileToTarRz", "addFileToTarBt", "addFileToTarJw", "addFileToTarRx", "addFileToTarGt", "addFileToTarBp", "addFileToTarGsz", "addFileToTarGez"], "taro": [" tara", "thamo", "staco", "stoa", "Taco", "warro", "Tamo", "qtaro", "tempamo", "marro", "staro", "stargo", "stamo", "troa", "maro", "trary", "starro", "ttara", " tolan", "retaro", "tory", "trro", "ktara", "Taro", " tory", "thosa", "ktarro", "tamo", "stary", "qtro", "margo", "tro", "ktaro", "ttaro", "thara", "tolan", "Tolan", "waro", "ktrar", "taco", " tarro", "tara", " tary", "tary", "retaco", "tarro", "tosa", "trar", "tharo", "Tarro", "retara", "targo", "traro", "temparo", " targo", "retamo", "qtolan", "Targo", "tharro", "tempargo", "toa", "Tro", "ttosa", "Tory", "wro", "qtory", "tempro", " taco", " tosa", " tamo", " toa", "Tara", " trar", "stro", "thrar", "wargo", "mro", "ttamo", " tro"], "path": ["name", "url", "PATH", "ath", "key", "p", "full", "string", "pattern", "clean", "ex", "entry", "w", "mount", "file", "h", "local", "root", "project", "m", "c", "parts", "text", "chain", "ref", "history", "kind", "doc", "dir", "Path", "core", "binding", "th", "transform", "pi", "print"], "base": ["name", "server", "parent", "full", "part", "file", "b", "start", "buffer", "alias", "pad", "build", "padding", "template", "default", "root", "based", "basic", "Base", "bf", "bas", "prefix", "check", "normal", "relative", "create", "db", "common", "family", "ase", "shadow", "binding", "bad", "reset", "extra", "bare", "absolute"], "f": ["fp", "xf", "rf", "fab", "tf", "fed", "df", "p", "fm", "g", "v", "fo", "r", "F", "w", "e", "life", "perm", "file", "b", "i", "h", "fx", "fa", "uf", "fc", "c", "fs", "fi", "fd", "elf", "bf", "lf", "y", "fg", "form", "fl", "t", "sf", "o", "d", "cf", "l", "ft", "fe", "far", "fac", "fr", "af", "alf", "fb", "inf"], "entryName": ["ryname", " entryKey", "EntryPath", "entryType", "ryName", "rowType", "elementPath", "cueKey", "elementname", "rowName", " entryLetter", "entryPath", " entryPath", "EntryKey", "cueName", "elementKey", "rowname", "entryKey", " entryType", "rowLetter", "cuename", "cueType", " entryname", "ryLetter", "ryType", "entryLetter", "entryname", "Entryname", "elementName", "EntryName", "EntryType"], "goIn": [" goIN", "moInput", "gein", "poIN", "geIn", " goOut", "GoIn", "moIN", "goIns", "Goin", "GoIns", "poin", "goOut", "GoIN", "goin", "moin", "moIns", "moIn", "goIN", "geInput", "poOut", " goInput", "poIn", "geIns", "goInput", " goIns", " goin", "GoOut"], "tarEntry": ["rarentry", "warItem", "rarComponent", "rarCategory", "tarentry", " tarEnt", "warComponent", "warEnt", " tarItem", "tarCategory", "tarItem", "rarEntry", "warEntry", " tarCategory", "rarItem", "tarEnt", "carCategory", "carEnt", "tarComponent", "rarEnt", "carentry", " tarComponent", "carEntry", " tarentry"], "children": ["resources", "cache", "groups", "cs", "parent", "each", "ports", "cloud", "stories", "wn", "gall", "ps", "pages", "kids", "members", "many", "names", "aos", "parents", "json", "users", "all", "reports", "blocks", "ren", "keys", "roots", "they", "these", "files", "batch", "fs", "packages", "modules", "jobs", "objects", "ll", "balls", "los", "hawks", "items", "ml", "Children", "follow", "ls", "ul"], "child": ["zip", "name", "cache", "ch", "parent", "key", "Child", "shell", "char", "job", "entry", "label", "last", "file", "ph", "close", "id", "comment", "c", "batch", "fd", "q", "cell", "page", "lf", "uncle", "ll", "friend", "cow", "l", "client", "count", "block", "brother", "row", "fr", "background", "follow", "pixel", "col", "handle"]}}
{"id1": "11562173", "id2": "14231545", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkAudioChannel", "checkAudioStream", "checkContentFile", "assertInputstream", "checkContentChannel", "checkContentStream", "checkAudioFile", "checkInputstream", "checkOutputChannel", "assertOutputFile", "assertInputStream", "checkOutputFile", "checkInputFile", "checkOutputStream", "assertInputFile", "checkOutputstream", "checkContentstream", "assertOutputStream", "assertInputChannel", "checkAudiostream", "assertOutputChannel", "checkInputChannel", "assertOutputstream"], "in": ["inn", "al", "inc", "up", "raw", "is", "it", "inner", "ex", "old", "din", "mm", "file", "source", "b", "io", "gin", "on", "c", "from", "cont", "In", "or", "st", "ins", "en", "IN", "o", "doc", "l", "get", "con", "s", "input", "cin", "mc", "n", "ind"], "cmp": ["msg", "cs", "comp", "ch", "Comp", "cv", "pres", "resp", "different", "equal", "comm", "cb", "cc", "same", "cd", "eq", "tc", "cmd", "ck", "vp", "par", "qual", "tmp", "match", "conv", "result", "c", "coll", "cond", "mp", "com", "good", "ctrl", "cu", "rel", "csv", "pkg", "ctx", "dict", "co", "compl", "cod", "omp", "diff", "mc", "desc", "cp", "cn"], "all": ["attribute", "al", "active", "alph", "All", "none", "oll", "any", "full", "each", "first", "equal", "both", "and", "bl", "a", "ssl", "default", "ALL", "also", "call", "m", "only", "valid", "alpha", "ll", "test", "always", "l", "app", "total", "null", "other", "list", "empty", "kill", " ALL"], "stream": ["port", "zip", "view", "parent", "shape", "system", "our", "socket", "clean", "each", "Steam", "pipe", "se", "sample", "stack", "REAM", "mount", "event", "ost", "sudo", "network", "buffer", "host", "tmp", "channel", "local", "context", "sw", "sync", "time", "engine", "Stream", "form", "store", "draw", "console", "service", "st", "collection", "output", "ST", "row", "input", "screen", "ream", "dd", "sign", "window", "upload"], "out": ["obj", "up", "external", "not", "exp", "array", "p", "raw", "it", "clean", "Out", "v", "ex", "aos", "outer", "ent", "b", "sys", "log", "io", "tmp", "serv", "data", "conv", "batch", "res", "ot", "good", "check", "help", "str", "t", "at", "o", "ne", "pkg", "des", "output", "con", "to", "list", "outs", "OUT", "net", "n", "cn"], "i": ["ix", "bi", "ri", "init", "key", "span", "is", "mi", "x", "it", "phi", "gi", "ui", "ji", "si", "v", "hi", "ini", "info", "u", "iu", "cli", "\u0438", "json", "perm", "point", "gu", "ti", "ci", "me", "zi", "multi", "j", "di", "id", "xi", "m", "batch", "uri", "ii", "q", "y", "ic", "ei", "ims", "ms", "qi", "ij", "chain", "us", "ki", "client", "iter", "ai", "I", "n", "vi", "sym", "z", "pi", "sim", "index", "ind", "li"]}}
{"id1": "3558512", "id2": "9479502", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"serialize": ["serialate", "serialized", "Serializer", "erialate", "erializer", "finalized", "initialization", "serializer", "erialized", "finalization", "finalize", "erialize", "Serialze", "finalze", "Serialate", "serialze", " serialate", "serialization", "Serialization", "initialize", " serialized", "initialze", "initialized", "Serialized", " serializer", "Serialize"], "out": ["up", "ch", "p", "it", "Out", "pool", "stream", "v", "a", "w", "aos", "file", "b", "log", "err", "i", "io", "serv", " OUT", "result", "f", "sw", "c", "res", "report", "sum", "t", "o", "d", "OU", "output", "os", "to", "outs", "OUT", "n", "ou"], "parser": ["aser", "util", "rer", "magic", "writer", "p", "per", "now", "part", "inner", "xml", "loader", "job", "tp", "layer", "file", "ker", "Parser", "ger", "walker", "builder", "jack", "parse", "manager", "bank", "plan", "processor", "password", "arser", "base", "handler", "lp", "worker", "peer", "command", "instance", "tar", "asser", "language", "er", "proc", "pkg", "policy", "tree", "ler", "token", "reader", "style", "format"], "on_disk": ["on_link", "On2disk", "on_Disk", "on2Disk", " on_disc", "on_download", "On2link", "On_file", "On_Disk", " on_Disk", "on_volume", "On_cloud", "on_file", "On_link", "On2Disk", " on_volume", "on2link", " on_download", "on_dis", "On_disk", "on_disc", "on2file", " on_file", "on_cloud", "On2file", "on2disk", " on_dis"], "in": ["inn", "inc", "mi", "is", "it", "ain", "and", "sin", "inner", "isin", "r", "din", "min", "bin", "i", "io", "gin", "ad", "on", "id", "from", "In", "body", "ins", "inside", "en", "IN", " din", "input", "cin", "rin", " IN", "vin", "inf", "ind"]}}
{"id1": "8973505", "id2": "9647576", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"writeFileType": ["readFileType", "writefileInfo", "writeContentName", "writePagetype", "writeContenttype", "writePageInfo", "writeFileName", "readfiletype", "writefiletype", "writeFiletype", "readFileInfo", "writePageName", "writeContentType", "readfileType", "writePageType", "writeContentInfo", "readFiletype", "writeFileInfo", "readFileName", "readfileName", "writefileType", "readfileInfo", "writefileName"], "uriFile": ["irifile", "iriData", "URIfile", "URIFiles", "rangeFile", "urifile", "rangeFILE", "iriFILE", "fileFilename", "uriFiles", "rangefile", "URIFILE", "rangeData", "fileFiles", "filefile", "URIFile", "filenameFile", "filenamefile", "filenameFilename", "URIData", "iriFile", "uriData", "URIFilename", "fileFile", "uriFilename", "filenameFiles", "uriFILE"], "outputfile": ["outputbase", "outFile", "outputport", "outputFile", "outfile", " outputFile", "inputf", "OutputFile", "outputf", "inputFILE", "imageFile", "imageFILE", "outbase", "Outputfile", "imageport", "imagefile", "inputfile", "Outputport", "inputport", "outf", "inputFile", "OutputFILE", "inputbase", " outputf", "outputFILE", " outputbase"], "num": ["alph", "nom", "required", "nm", "cmp", "x", "NUM", "add", "current", "index", "Num", "max", "um", "Number", "nb", "number", "all", "mon", "np", "nam", "multi", "mult", "zero", "m", "done", "random", "check", "no", "total", "con", "count", "end", "n"], "writer": ["link", "server", "external", "operator", "stream", "utils", "writ", "buffer", "builder", "function", "manager", "data", "wire", "storage", "written", "maker", "widget", "riter", "table", "runner", "player", "document", "RW", "journal", "wright", "event", "variable", "author", "resource", "read", "ender", "processor", "timer", "worker", "ner", "usher", "Reader", "width", "connection", "writing", "will", "Writer", "linger", "memory", "w", "layer", "ener", "record", "comment", "handler", "thus", "test", "editor", "term", "creator", "director", "window", "wrapper", "owner", "writers", "iterator", "liner", "inner", "loader", "commit", "entry", "flush", "file", "network", "driver", "caster", "console", "service", "er", "write", "client", "to", "format"], "uri": ["ni", "link", "origin", "phi", "ui", "wiki", "URI", "subject", "hi", "doi", "obo", "verb", "channel", "reference", "multi", "user", "general", "form", "ei", "range", "qi", "browser", "directory", " URI", "unit", "domain", "uno", "ugi", "ource", "via", "rid", "source", "location", "resource", "result", "http", "prefix", "details", "address", "ref", "https", "iri", "connection", "bid", "uni", "remote", "ri", "ip", "qu", "query", "filename", "ir", "id", "basic", "queue", "hyper", "chain", "ur", "href", "uu", "iterator", "image", "mi", "inner", "description", "copy", "file", "uid", "folder", "i", "sofar", "umi", "du", "phrase", "pi", "username"], "counter": ["iterator", "sequence", "ter", "amount", "key", "system", "Counter", "cms", "const", "continue", "order", "inner", "scope", "loader", "message", "memory", "pointer", "entry", "outer", "clock", "cookie", "currency", "number", "controller", "nr", "container", "buffer", "walker", "context", "meter", "manager", "conv", "processor", "cover", "ier", "book", "money", "timer", "mer", "coll", "time", "ctr", "instance", "random", "machine", "frequency", "mill", "card", "finder", "browser", "loop", "phrase", "ounter", "editor", "common", "total", "another", "term", "mr", "count", "creator", "norm", "TER", "index"], "reader": ["iterator", "server", "liner", "journal", "older", "inner", "loader", "r", "entry", "rx", "yer", "redo", "layer", "file", "buffer", "resource", "read", "parser", "builder", "rar", "context", "processor", "method", "roller", "handler", "driver", "timer", "ner", "rl", "Reader", "address", "er", "ro", "editor", "upper", "iter", "row", "input", "runner", "dd", "player", "document"], "url": ["mail", "Url", "link", "hl", "name", "char", "r", "mount", "location", "gl", "ssl", "resource", "build", "bel", "dl", "base", "il", "github", "web", "http", "nl", "sl", "str", "ll", "browser", "address", "google", "https", "loc", "ref", "rel", "l", "open", "client", "get", "www", "URL", "re", "ur", "li"], "myConnection": ["newLink", "thisConn", "yourLink", "myConnector", "newConn", " myConnect", "thisLink", "myConn", "thisConnection", "yourconnection", "newConnection", "thisConnect", "myConnect", "myconnection", " myconnection", "yourConnection", "MyConnection", " myConnector", "myLink", "newConnect", " myConn", "MyConnector", "MyLink", "yourConnector", " myLink", "Myconnection"], "myReader": ["yWriter", "yourRead", " myParser", "myRead", "mxReader", " mySer", "yFr", " myFr", " myRead", "yourReader", "mxFr", "mxSer", "myParser", "mySer", "yourParser", "MyWriter", "myFr", "yourWriter", "MyRead", "MyReader", "ySer", "yReader", "myWriter", " myWriter", "mxWriter", "MyParser"], "line": ["link", "lane", "sequence", "online", "liner", "ln", "le", "ip", "stroke", "ine", "part", "char", "message", "sample", "entry", "edge", "detail", "side", "label", "Line", "cli", "point", "log", "ole", "channel", "email", "LINE", "one", "eline", "user", "comment", "lin", "page", "cell", "trace", "body", "frame", "range", "ge", "normal", "text", "code", "rule", "no", "lo", " Line", "l", "definition", "word", "iter", "block", "row", " LINE", "inline", "ode", "style", "raw"], "linecount": ["linefound", "elinecounter", " lineconfig", "strokenumber", "linecounter", "elineconst", " linelength", "inlinelength", "linnumber", "inlineconst", " linecounter", "lineamount", " lineamount", "strokeconsider", "linerconfig", "linerCount", "inlinecount", "linelength", "lineconst", " linefound", "lineCount", "inlinecounter", "Linefound", "linerfound", "strokecount", " lineCount", "elinelength", "lincount", "LineCount", " lineconsider", "linamount", "Lineconfig", "linconsider", "Linecount", "elinecount", "linercount", " linenumber", " lineconst", "linenumber", "lineconsider", "strokeamount", "lineconfig"], "hasOWL": ["hasEWB", " hasOWNL", "hasOWSB", "hasOWSNL", " hasOWSNL", "hasEWL", " hasEWL", "hasROL", "hasEWLP", " hasOWLP", "hasOWNL", "hasROR", " hasOWR", "hasOHLP", "HasOWSB", "hasEWR", "HasOWB", "hasSOR", "hasOWLP", "hasEWS", " hasOWSR", " hasOWLS", "hasOWSR", "hasSOLS", " hasOWSL", "hasOHL", "hasOWLS", "hasSOLP", "hasOWSLS", "HasOWS", "hasOWS", "hasOWNLP", "hasOHB", "hasOWSLP", " hasEWLP", "hasSOL", " hasOWSLP", "hasRONL", "HasOWL", "hasEWLS", "hasOWR", "HasOWSS", "HasOWLP", "hasOHS", "hasOWNR", "hasROLP", "hasOWNNL", " hasEWLS", " hasEWR", "hasOWB", "HasOWSLP", "hasOWSS", "HasOWSL", "hasOWSL"], "hasRDFS": ["hasSRDFS", "hasRDSDS", "hasRRICS", "hasRdfDS", "hasRRIB", "hasORDFs", "hasXDFM", "hasSRDFs", "hasXDFDS", "hasORDFDS", "hasRDSs", "hasRDFM", "hasRDSCS", "hasRMLS", "hasORDSS", "hasXDSDS", "hasORDSM", "hasORDFS", "hasXDFS", "hasRNFDS", "hasRdfs", "hasRDSS", "hasSRDSs", "hasSRDSCS", "hasRDFCS", "hasRNFS", "hasSRDFB", "hasRdfM", "hasRDSM", "hasSRDFCS", "hasRDSB", "hasORDSDS", "hasRdfCS", "hasSRDSB", "hasRdfB", "hasXDSS", "hasRDFB", "hasORDSs", "hasRMLM", "hasRRIs", "hasRMLs", "hasXDSM", "hasORDFM", "hasXDFs", "hasRdfS", "hasRMLDS", "hasRDFs", "hasRNFM", "hasXDSs", "hasRNFs", "hasSRDSS", "hasRRIS", "hasRDFDS"], "hasRDF": ["hasORDS", "hasORDR", "hasRdf", "hasRTDS", "hasRRdf", "hasRTNF", "hasRRDS", " hasRRDS", "hsRDF", "hasRCNF", "hasREDS", " hasRRNF", "hasRCDF", "hasRADF", "hsRDT", " hasRRDR", "hasRTDF", "hasRRCD", "hsRRDT", "hsRRDS", "hasRCdf", "hasDNF", "hasORDF", "hasRRDI", "hasREDT", "hasRTDR", " hasDNF", "hasRDR", "hasDdf", "hasRRDT", "hsRRDI", "hasRNF", "hasRRDR", " hasDCD", " hasDdf", "hasRADT", " hasRNF", "hasRCCD", " hasRdf", "hasRDS", " hasDDF", "hasRDI", "hsRDI", "hasRDT", "hasREDI", "hasREDF", "hsRDS", " hasRDR", "hsRRDF", "hasRRNF", " hasRCD", "hasDDF", "hasRADI", "hasORNF", "hasRCD", " hasRRDF", "hasDCD", "hasRADS", "hasRRDF", " hasRDS"]}}
{"id1": "21224967", "id2": "9796161", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "label": 0, "substitutes": {"crear": [" necessar", " Crear", " executado", " executada", " executas", " necessas", "creas", " Creado", " executar", " necessada", " necessado", " Creada", "creado", "creada", " Creas"], "result": ["sequence", "die", "su", "power", "tr", "Result", "true", "continue", "ret", "unique", "order", "process", "message", "r", "integer", "run", "currency", "number", "success", "value", "event", "date", "results", "successfully", "user", "successful", "complete", "comment", "num", "res", "search", "report", "valid", "command", "status", "conf", "br", "feature", "draw", "card", "test", "duration", "relation", "length", "total", "count", "rc", "row", "diff", "ULT", "df"], "sql": ["mail", "url", "ws", "string", "sq", "select", "xml", "description", "fn", "expression", "sb", "cmd", "sel", "params", "query", "join", "sd", "serv", "template", "ql", "pel", "sv", "dl", "spr", "q", "nl", "quote", "status", "sol", "sf", "condition", "csv", "seed", "db", "s", "SQL", "qs", "sp", "ls"], "connection": ["port", "character", "Connection", "link", "response", "server", "conn", "writer", "system", "statement", "socket", "created", "pool", "connected", "pointer", "current", "connect", "database", "number", "location", "query", "network", "ion", "session", " Connection", "resource", "computer", "channel", "close", "function", "context", "reference", "library", "application", "handler", "c", "driver", "communication", "engine", "command", "we", "nc", "collection", "condition", "relation", "client", "open", "con", "position", "creator", "to", "platform", "reset", "document", "directory"], "ps": ["fp", "fps", "cs", "pp", "prep", "ips", "p", "pse", "ts", "statement", "bs", "rs", "PS", "ds", "Ps", "pg", "aps", "pps", "pa", "ptr", "pd", "po", "ping", "pas", "res", "mp", "pers", "pr", "jp", "proc", "eps", "pb", "pt", "s", "sp", "gres", "pi", "cp", "pe"]}}
{"id1": "22752444", "id2": "6866575", "code1": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["decode", "decrypted", "Encode", " encode", " encrypted", "Encryption", "encryption", "decryption", " encryption", "encode", "decrypt", "Encrypt", "Encrypted", "encrypted"], "plainText": ["protectedHTML", "protectedCode", "plainObject", " plainTEXT", "ainObject", "messageTEXT", "protectedTEXT", "ainText", " plainEntity", "plainEntity", "publicEntity", " plainHTML", "messageContent", "publicContent", " plainContent", "ainHTML", "messageText", "plainCode", " plaintext", "ainTEXT", "plaintext", "publicObject", "plainContent", "publicText", " plainObject", "ainCode", "protectedText", " plainCode", "plainHTML", "plainTEXT", "ainEntity", "publicTEXT", "messagetext", "publictext"], "hash": ["response", "cache", "html", "key", "array", "header", "chip", "cert", "tr", "height", "dig", "handle", "sh", "message", "title", "temp", "mac", "json", "filename", "log", "h", "data", "ash", "map", "password", "user", "id", "result", "alert", "search", "Hash", "ah", "report", "sum", "tag", "text", "proof", "test", "rh", "total", "shadow", "input", "flash", "hex", "score", "has", "sha"], "md": ["sm", "metadata", "amd", "dig", "del", "cd", "mb", "MD", " m", "mo", "dm", "dh", "mm", "ds", "der", "od", "cmd", "ng", "managed", "grad", "ind", "bd", "mac", "h", "sd", "mod", "ad", "esm", "sam", " mo", "di", "pd", "ld", "m", "det", "med", " Md", " mc", "pm", "mp", "rm", "ms", "mg", "mn", "d", "nd", "mand", "dd", "mc", "mt", "mk", "df", "hd", "sha"], "raw": ["array", " RAW", "wrap", "full", "clean", "shared", "bytes", "sh", "message", "original", "known", "cooked", "content", "unknown", "pack", "partial", "json", "value", "all", "read", "buf", "aw", "data", "box", "available", " Raw", "c", "unsigned", "custom", "valid", "random", "text", "out", "load", "rew", "row", "input", "Raw", "hex", "rendered", "RAW", "n"]}}
{"id1": "11616716", "id2": "19912848", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResultsasString", "getCMSResultasStream", "getCMSResultsasSteam", "getCMSResultasView", "getCMSResultAsView", "getCMSResultasString", "getCMSResultsAsStream", "getCMSResultAsSteam", "getCMSResultsasView", "getCMSResultsAsString", "getCMSResultAsString", "getCMSResultsAsSteam", "getCMSResultasSteam", "getCMSResultsasStream", "getCMSResultsAsView"], "rqlQuery": [" rqlString", "rqlStatement", "RQLQuery", "rsqlString", "rqlString", "rviewCommand", "rumbleQuery", "RQLquery", "rumbleString", "Rqlquery", "rqCommand", "rQLquery", "rviewquery", "rqlCommand", "RqlQuery", " rsqlString", " rsqlStatement", " rsqlQuery", "rqStatement", "rqString", "rsqlQuery", "rQLCommand", "rumbleStatement", "RQLCommand", "rqquery", "rQLQuery", "rviewQuery", "rqQuery", "rqlquery", " rqlStatement", "rsqlStatement", "RqlCommand"], "osr": ["iossr", "iosr", "iosh", " osmr", "osssr", "ossrg", "osd", "osmr", "osesrw", "possr", " osq", "oesmr", "posrator", "ooscr", "ossrw", " ossr", "orar", "oosd", "osscr", "ovr", "oesr", "oeser", "osq", "iosd", "ossr", " osvr", " osrar", "iosvr", "oessr", "iosq", " osh", "ioser", "or", "osesr", "posr", "osvr", "osrw", "ossd", "ossh", "ossq", "ooser", " osrg", "iosmr", "ossvr", " oscr", "oesrw", "oseser", "iosrg", "oosr", "osrar", "oscr", "osh", "osesmr", "oesrator", "osrator", "ossrar", "osrg", "ioscr", "osser", "iosrator", "ossmr", "oser"], "url": ["mail", "Url", "link", "hl", "cert", "char", "ret", "mb", "mount", "lb", "gl", "ssl", "host", "build", "bel", "ld", "il", "dl", "abs", "uri", "web", "http", "nl", "sl", "el", "str", "ll", "https", "loc", "rel", "pkg", "l", "client", "open", "URL", "net", "ol", "ls", "ur", "ul"], "conn": ["link", "obj", "ch", "cert", "init", "resp", "socket", "addr", "comm", "cb", "act", "org", "connected", "enc", "nt", "nw", "ns", "connect", "cmd", "pg", "syn", "sys", "close", "j", "conv", "col", "win", "sync", "c", "cont", "res", "pas", "conf", "nc", "cur", "canon", "out", "loc", "jp", "rel", "proc", "l", "ctx", "client", "open", "con", "os", "req", "connection", "n", "exec", "Conn", "ct", "cp", "cn"]}}
{"id1": "10218878", "id2": "18211588", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeMAPfile", "DecodeMAPFile", "DecodeFromfile", "DecodeMAPLog", "DecvertMapFile", "DecodeFromFile", "DecodeToLog", "DecvertMAPFiles", "DecodeToFiles", "DecvertMAPfile", "DecvertMAPLog", "DecvertMAPFile", "DecvertMapfile", "DecodeMapLog", "DecodeMapFiles", "DecvertMapFiles", "DecodeFromLog", "DecodeMAPFiles", "DecodeFromFiles", "DecodeToFile", "DecodeMapfile", "DecvertMapLog", "DecodeTofile"], "mapFile": ["listPath", "mapFILE", "imageStream", " mapStream", " mapfile", "listFile", " mapFilename", "imageFile", "mapPath", "MapFile", "MapFilename", "mapfile", "MapStream", " mapPath", "imagefile", "mapStream", "cacheFILE", "Mapfile", "listFILE", " mapFILE", "cachePath", "cacheFile", "imageFilename", "mapFilename"], "outputFile": ["writeName", "outFile", "outFilename", "outputPath", "mapName", "OutputPath", "OutputFile", "OutputFilename", "inputDir", "writeFile", "writeStream", "outputName", " outputDir", "OutputDir", "outputFilename", "inputStream", "inputName", "outDir", " outputFilename", "mapDir", "writeDir", "outputDir", " outputPath", "mapStream", "inputFile", "outPath", "outputStream"], "magicKey": [" magicCode", "uniqueCounter", "magicName", " magicField", "serialKEY", "uniqueCode", "anticChar", "uniqueKey", "magickey", " magicId", "uniqueValue", "magicCode", " magicChar", "magicField", " magicValue", "magicCounter", "serialName", " magicName", " magicCounter", "prefixCode", "MagicKEY", "magicKEY", "encryptedKey", "anticField", "MagicId", "serialId", "magicValue", "antickey", " magicKEY", "prefixKey", "prefixValue", "serialKey", "magicId", "anticKey", "prefixCounter", "encryptedChar", "encryptedField", "magicChar", " magickey", "encryptedkey", "MagicKey", "MagicName"], "buffer": ["attribute", "sequence", "cache", "shape", "header", "initial", "stroke", "char", "display", "document", "stream", "message", "memory", "sample", "stack", "database", "detail", "bridge", "bone", "variable", "pad", "black", "buf", "Buffer", "append", "template", "button", "queue", "batch", "base", "vector", "command", "page", "sum", "frame", "check", "code", "mem", "buff", "binary", "bo", "history", "phrase", "table", "length", "total", "paste", "iter", "block", "row", "screen", "flash", "print", "program", "filter", "window", "index"], "nread": [" nRead", "ncreadable", "ncadd", "renread", "maxRead", "renreader", " nreadable", " nwrite", "rnwrite", "NRead", "NREAD", "rawreader", "rentry", "nget", "Nreadable", "nREAD", "Nget", "nRead", "rnread", "rnREAD", "nadd", "rawwrite", "ncwrite", "maxadd", "nwrite", "ncread", "rawtry", "nreadable", "Nadd", " ntry", "maxget", "Nwrite", "ncget", "ncRead", "nreader", " nREAD", "maxread", "rawread", "renwrite", "rnRead", "Nread", " nreader", "ntry"], "map": ["clear", "cache", "ace", "where", "view", "pl", "ip", "up", "shape", "image", "per", "master", "apping", "memory", "apper", "man", "lock", "mount", "pack", "file", "collect", "make", "aps", "config", "bridge", "ap", "read", "mod", "parse", "manager", "batch", "m", "down", "meta", "com", "mp", "mate", "form", "set", "mask", "op", "MAP", "mem", "address", "load", "pose", "module", "app", "place", "maps", "open", "cm", "con", "block", "table", "co", "ml", "ape", "mt", "window"], "output": ["port", "auto", "four", "response", "cache", "online", "icon", "other", "socket", "display", "put", "stream", "current", "target", "oe", "outer", "Output", "entity", "file", "update", "network", "log", "secure", "next", "result", "exit", "queue", "batch", "format", "web", "plain", "blue", "object", "console", "out", "o", "write", "client", "open", "ilo", "latest", "block", "input", "net", "print", "hidden", "can", "ou"], "i": ["ix", "ni", "bi", "ip", "ri", "span", "mi", "is", "x", "it", "phi", "gi", "ui", "ji", "si", "v", "g", "ini", "ami", "u", "spin", "cli", "iu", "ind", "b", "gu", "ti", "ci", "j", "multi", "di", "id", "xi", "m", "batch", "uri", "fi", "q", "y", "ic", "ei", "ms", "qi", "t", "us", "ai", "I", "n", "ie", "pi", "ish", "sim", "index", "ii", "li"]}}
{"id1": "8932510", "id2": "17207832", "code1": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "code2": "    @Test\n    public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception {\n        Exception e = new UnsuccessfulResponseException(resp);\n        expect(mockBackend.execute(host, req, ctx)).andThrow(e);\n        replay(mockBackend);\n        HttpResponse result = impl.execute(host, req, ctx);\n        verify(mockBackend);\n        assertSame(resp, result);\n    }\n", "label": 0, "substitutes": {"doPost": ["doPOST", "actionPre", " doPre", " doPOST", "doPre", "doPut", " doPut", "DoPut", "DoPre", "actionPost", "DoPost", "actionPut", "DoPOST", "actionPOST"], "request": ["cgi", "server", "subject", "info", "container", "question", "context", "reference", "user", "call", "web", "form", "store", "frame", "create", "req", "block", "input", "remove", "self", "quest", "document", "register", "QUEST", "url", "xml", "message", "current", "start", "resource", "error", "project", "report", "http", "address", "condition", "position", "connection", "reset", "remote", "select", "this", "memory", "Request", "query", "art", "record", "setup", "search", "time", "command", "java", "object", "post", "requ", "re", "pair", "enter", "initial", "first", "have", "order", "copy", "change", "session", "application", "complete", "instance", "forward", "client", "get"], "response": ["view", "model", "image", "resp", "version", "description", "event", "success", "session", "context", "information", " Response", "one", "respond", "respons", "default", "application", "result", "res", "report", "send", "site", "release", "onse", "frame", "Response", "object", "write", "output", "render", "connection", " responding", "tree", "ce", "reset", "reply", "document"], "is": ["tis", "bits", "obs", "ip", "init", "ois", "ips", "image", "icks", "iss", "si", "isin", "as", "info", "isa", "sis", "iso", "Is", "ir", "i", "ys", "ris", "es", "IS", "xs", "isp", "bis", "its", "in", "ios", "ims", "ms", "isl", "ins", "ists", "ais", "iris", "was", "isc", "mis", "isi", "has", "lis"], "page": ["port", "link", "pc", "url", "view", "cache", "html", "server", "go", "pp", "image", "p", "part", "pool", "stream", "wiki", "pages", "message", "entry", "content", "menu", "title", "article", "node", "file", "pos", "point", "session", "resource", "next", "data", "error", "result", "po", "form", "frame", "object", "post", "age", "address", "out", "browser", "o", "proxy", "table", "line", "row", "Page", "token", "sp", "document", "index", "pe"], "os": ["offset", "Os", "oid", "pool", "ui", "si", "ps", "mo", "pos", "so", "iso", "io", "es", "OS", " o", "sw", "po", "res", "or", "ops", "ios", "ms", "op", "o", "s", "oss", "oos"], "rootUrl": ["parentURL", "baseUr", "parentUrl", " rootDir", "baseUrl", "rootUr", "webDir", "homeUr", "rootURL", "rootDir", "parentUr", "webUr", "homeUrl", "baseURL", " rootURL", "parenturl", "webURL", "rooturl", "homeurl", " rootUr", "baseDir", " rooturl", "homeURL"], "isMultipart": ["isMultipage", "isMultIPart", "isMultIParts", "isMultiipart", "isMultiplarts", "isMultipand", "isMultipland", "isMultispand", "isMultisparted", "isMulticarted", "isManiparts", "isMultiparts", "isMultiisparted", "isMultispage", "isMultiiparted", "isMultiiparts", "isMultiispage", "isMultiplart", "isMultiparted", "isMultIParted", "isManIPage", "isManipand", "isMulticage", "isManipage", "isMultiispart", "isMultiipage", "isManIParts", "isManipart", "isManIPand", "isMulticart", "isMultiisparts", "isMulticarts", "isMultispart", "isMultisparts", "isMultIPand", "isManIPart", "isMultIPage", "isMultiplage"], "rd": ["rod", "vd", "rend", "rer", "ord", "dig", "gd", "adr", "rs", "nder", "hr", "r", "rr", "rand", "rn", "rid", "hd", "dk", "ird", "yd", "rown", "RD", "hod", "dra", "ptr", "ld", "ard", "fd", "rl", "rob", "red", "xd", "rg", "ro", "rw", "rh", "nd", "ra", "erd", "ud", "rb", "rc", "fr", "dd", "td", "rt", "dr", "rus", "ind"], "upload": ["delete", "util", "execute", "up", "image", "select", "pload", "attach", "fax", "uploads", "add", "grab", "ow", "download", "imgur", " Upload", "ut", "allow", "ack", "file", "update", "art", "own", "archive", "tmp", "transfer", "aw", "save", "install", "form", "Upload", "post", "load", "move", "create", "insert", "ud", "row", "input"], "webUrl": ["rootPath", "WebUr", "weURL", "httpVer", "netPath", "wwwUr", "weurl", "weUrl", "httpUr", "httpPort", "wePort", "weVer", "netUr", "weburl", "webPort", "rootUr", "Weburl", "weUr", "webVer", "wwwURL", "rootVer", "rootURL", "webUr", "wwwPath", "httpUrl", "netUrl", "webURL", "WebUrl", "netURL", "rootPort", "webPath", "neturl", "wwwUrl", "WebURL"], "iter": ["orient", "iterator", "ter", "former", "where", "ip", "li", "init", "tr", "it", "ver", "iver", "inv", "order", "inner", "loader", "ator", "ait", "kit", "iz", "outer", "train", "IT", "ipper", "walker", "ir", "i", "iner", "next", "inter", "cer", "coll", "valid", "ner", "ser", "fer", "er", "loc", "loop", "tif", "dir", "Iter", "oper", "reader", "ind", "iv"], "item": ["attribute", "iterator", "im", "link", "obj", "unit", "stat", "option", "up", "ip", "key", "other", "image", "it", "order", "hit", "info", "entry", "member", "mm", "json", "value", "file", "event", "source", "container", "local", "record", "error", "atom", "tab", "step", "m", "base", "el", "status", "instance", "or", "object", "store", "in", "mem", "element", "rule", "Item", "module", "word", "block", "row", "area", "li"], "name": ["sequence", "cap", "len", "path", "NAME", "key", "parent", "string", "magic", "part", "order", "a", "old", "title", "label", "event", "file", "source", "named", "alias", "resource", "channel", "local", "one", "data", "on", "id", "num", "base", "type", "prefix", "normal", "Name", "class", "no", "o", "module", "common", "ame", "word", "family", "ma", "block", "term", "size", "names", "n"], "baos": ["gais", " baoss", "bao", "baoes", "BAo", "daoes", "BAops", "aooS", "booS", "booes", "bais", " bao", "waos", "waOS", "BAoss", "aooss", "gaOS", "BAoes", "BAis", "boos", " baops", "gaos", "aoos", "daos", "booss", "baOS", "aoOS", "waoss", "daoss", "BAoS", "kaoes", "BAOS", " baoes", "gaoss", "kaos", "bois", "boo", "baoS", "boOS", "baops", "BAos", "baoss", "gaoS", "boops", "kaoss", "kaOS", "daOS", "wais"], "wpIs": ["xpAre", "WPIs", "wtShares", "wordpressis", "WPUrl", "wordpressIm", "fwI", "WPI", "phpShares", "hwIs", "fwIm", "WPIS", "cpis", "wordpressIS", "wpI", "phpAre", "ipIS", "hwInst", "hwI", "wordpressI", "wpAre", "hwIS", "WPInst", "wordpressUrl", "wpIm", "phpI", "wpIS", "ipI", "phpIs", "wtAre", "wpis", "xpIs", "wpUrl", "wordpressIs", "phpIS", "wtIs", "cpIs", "ipInst", "ipIs", "cpIS", "wtI", "WPIm", "xpShares", "wpInst", "fwIs", "wpShares", "fwUrl", "xpI", "phpis"], "u": ["url", "tu", "ue", "U", "su", "p", "uj", "it", "ui", "ul", "ru", "r", "w", "iu", "uv", "uid", "gu", "i", "io", "uf", "user", "lu", "f", "bu", "uri", "hu", "ux", "mu", "fu", "eu", "cu", "us", "nu", "au", "o", "l", " nu", "ur", "uni", "uu", "ou"]}}
{"id1": "11183087", "id2": "23335922", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 1, "substitutes": {"doPost": ["doPOST", "dopost", " doAdd", " doPOST", "handlepost", " dopost", "doAdd", "handlePOST", "handlePost", "handleAdd", "DoAdd", "DoPost", "DoPOST", "Dopost"], "request": ["server", "model", "subject", "question", "context", "reference", "user", "call", "web", "frame", "collection", "browser", "create", "req", "list", "input", "quest", "document", "register", "QUEST", "url", "version", "begin", "xml", "message", "current", "event", "controller", "start", "result", "project", "the", "report", "http", "address", "position", "connection", "reset", "raw", "remote", "select", "argument", "Request", "hello", "query", "record", "setup", "search", "command", "object", "post", "requ", "re", "require", "print", "handle", "parent", "enter", "initial", "first", "system", "order", "run", "connect", "application", "complete", "law", "forward", "work", "open", "get", "client"], "response": ["view", "server", "image", "resp", "message", "entry", "content", "e", "success", "ve", "context", "next", "one", "respond", "default", "application", "exit", "result", "res", "report", "send", "page", "status", "onse", "frame", "Response", "service", "collection", "environment", "out", "write", "output", "connection", "to", "re", "ce", "reply", "print", "document"], "senha": ["tinhi", "Senwa", "ensenho", "senwa", "Senha", "Senja", "ensenha", " senhi", " senca", " senigma", "renHa", " senhas", "tenha", "renwa", "ensenca", "Senhas", "tenja", "Senigma", "tenwa", "renha", "tinha", "senca", " senho", "tenHa", "senhi", "tinhas", "ensenHA", "senhas", "senho", "Senca", " senHA", "senHa", "senja", "senigma", "SenHa", "senHA", "Senhi", "renja", "tinigma", "SenHA", "Senho"], "email": ["mail", "zip", "name", "url", "external", "path", "domain", "ip", "image", "string", "IL", "enter", "le", "message", "sample", "gmail", "Email", "oe", "lock", "detail", "e", "ails", "label", "file", "hello", "alias", "Mail", "password", "example", "ql", "elly", "echo", "login", "el", "quote", "office", "address", "ne", "line", "ilo", "live", "license", "username", "secret", "addr"], "messageDigest": ["MessageDig5", "MessageDigse", "messagemdest", " messageDigester", "MessageDigEST", "messagemdEST", " messageDigse", "Messagedigest", "messageIGester", "messageDig5", "messagedigse", "messageDer", " messageDiger", " messagediger", "Messagedigse", "messageMDest", "messageIGEST", "messageMDester", "messageIGse", "Messagedig5", "messageMDEST", "messageMDse", "messagemd5", "messageDigester", "messageDigse", "messageIGest", "messagedig5", "messageDigEST", "messagedigester", "messagediger", "MessageDigest", "messagemdester", "Messagedigester", " messagedigester", "messagedigest", "messageDse", "MessageDigester", "messageDester", "messageDiger", " messagedigse", "messagedigEST", " messagedigest", "MessagedigEST", "messageDest"], "usuario": ["usruario", "usuiarial", "usnuarial", "ussuarios", " usuarius", " ussuarius", "usui\u00e9r", "usnuario", "usu\u00e9r", "usruarios", "usuiarios", "cusuarial", "cusuarios", "usurio", "cussu\u00e9r", " usuarial", "cussuarial", "ussuarial", "ussuarius", "usuarial", "ussuario", "uscuino", "usnurio", "usuarius", "usuiario", "cussuarios", " ussurio", "ususrio", " ussuarial", "usruarial", "ussurio", "usruino", "uscuario", "cusuino", "ususarial", " usurio", "cusu\u00e9r", "uscu\u00e9r", " ussuario", "uscuarios", "ususarius", "ususario", "cussuino", "usuino", "ussu\u00e9r", "usnuarius", "cussuario", "usuarios", "uscuarial", "cusuario", "ussuino"], "redirect": ["Rederer", " reddraw", " redir", "edurl", "predirection", "REDirect", "redrict", "Redigate", "reddirect", "redir", "indrict", "redirection", "REDurl", "inderer", "predurl", "edirection", "reddirection", " redirection", "rederer", "redRECT", "REDirection", "predirect", "preddraw", "Redirect", " redurl", "Redrict", "rightirection", "indirection", "edirect", "reddigate", "redurl", "REDir", "RedRECT", "redigate", "rightigate", "reddRECT", "reddraw", "indirect", "edrict", "edir", "Redurl", "Reddraw", "rightRECT", "rightirect", "Redirection", "ederer"], "session": ["metadata", "sid", "cache", "group", "server", "still", "system", "activity", "shared", "task", "current", "cookie", "json", "params", "container", "layout", "context", "ESSION", "local", "data", "trip", "user", "application", "ess", "person", "save", "instance", "sql", "ession", "Session", "store", "environment", "browser", "condition", "relation", "client", "connection", "s", "input", "window", "use", "state"]}}
{"id1": "21152728", "id2": "9081749", "code1": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"authenticate": ["validicator", " authenticated", "Authenticate", "authenticated", "Authenticator", "authenticator", "validicate", " authentate", "Authentate", "validate", "validicated", "Authenticated", "authentate", " authenticator"], "module": ["remote", "option", "attribute", "util", "msg", "Module", "group", "domain", "model", "system", "scope", "message", "device", "entry", "member", "node", "file", "config", "network", " MODULE", "resource", "mod", "profile", "function", "manager", "data", "library", "project", "m", "security", "mode", "role", "command", "modules", "instance", "object", "course", "service", "address", "proxy", "component", "table", "cm", "ule", "connection", "js", "vm", "directory"], "rand": ["go", "rd", "init", "gram", "and", "nt", "r", "max", "rx", "grad", "ng", "pos", "start", "sys", "round", "err", "cos", "rad", "gt", "gen", "dev", "Rand", "from", "res", "reg", "crypt", "random", "in", "range", "serial", "out", "ro", "seed", "rw", "nd", "gz", "get", "mr", "cr", "rc", "cin", "rot", "rt", "dr", "reader", "mk"], "challenge": ["promote", " challche", "scheonge", "quchall", "scheenge", "challure", "challchant", "challape", "engeure", "chonge", "promenges", " challchant", "challchall", "chenge", "engeape", "challote", "engeenge", " Challenges", "challonge", "promchall", "messchall", " Challchant", "quote", "chape", "quenged", "messenged", "engeonge", "messote", "scheure", "promche", "chure", "messenge", "challche", "promenged", "scheape", " challenges", " Challenge", "promchant", " Challche", "promenge", "challenges", "challenged", "quenge"], "b64": ["B4", " b4", "base60", "mb64", "bb128", " b62", "base58", "rb128", "mb62", "b4", "rb64", "base128", "mb58", "B58", "B62", "b62", "base64", "bb64", "rb60", "B64", " b58", "bb60", "mb4", "b60", "B128", "b58", " b128", "b128"], "reply": ["remote", "link", "server", "answer", "resp", "shell", "notice", "back", "part", "ret", "delay", "ror", "repl", "message", "sample", "info", "detail", "cmd", "reverse", "query", "buffer", "err", "next", "transfer", "related", "respond", "error", "echo", "result", "comment", "sync", "base", "res", "report", "send", "http", "pty", "command", "quote", "poll", "body", "frame", "prefix", "in", "out", "address", "ply", "relation", "review", "proxy", "voice", "request", "route", "re", "reset", "Reply", "inline"], "user": ["port", "remote", "name", "url", "server", "parent", "key", "User", "string", "per", "system", "part", "char", "confirmed", "message", "device", "users", "file", "query", "uid", "admin", "author", "host", "me", "manager", "password", "method", "error", "id", "result", "plugin", "person", "type", "force", "usa", "nick", "valid", "command", "form", "ser", "browser", "ername", "er", "item", "rule", "test", "usr", "by", "proxy", "client", "human", "word", "term", "USER", "account", "core", "row", "token", "student", "used", "username", "use", "owner"], "response": ["remote", "server", "answer", "version", "string", "resp", "image", "bytes", "description", "message", "entry", "value", "success", "query", "next", "data", "password", "example", "error", "result", "application", "res", "command", "status", "onse", "Response", "code", "text", "out", "output", "request", "connection", "reset", "token", "username", "secret"], "secrets": ["secets", "escures", "scources", "privets", "privures", "privrets", " secuds", "secients", "Secources", "secures", "escets", "Secets", " secures", "escards", "secards", "Secrets", "Secuds", "Secards", " secources", "scuds", "scures", "secuds", "screts", "scients", "Secures", "privards", "secources", "Secients", "escrets", " secients"], "md4": ["dd64", "MD2", " md6", "dd4", " md2", " md44", " md5", "nd64", "md44", "sha5", "MD44", "dd5", "nd44", "MD64", "MD5", "nd5", "dd44", "md2", "sha2", "nd4", "md6", "md5", "MD4", "sha44", "sha6", "sha4", "md64", "MD6"], "line": ["mail", "link", "sequence", "msg", "online", "le", "ln", "ip", "header", "liner", "string", "shell", "ine", "char", "lines", "message", "job", "entry", "lock", "detail", "label", "Line", "file", "log", "buffer", "ole", "email", "LINE", "record", "eline", "queue", "comment", "login", "lin", "page", "cell", "body", "frame", "range", "store", "code", "text", "chain", "out", "lo", "l", "iter", "word", "block", "ice", "row", "inline", "print", "level", "handle"], "passwd": ["passw", "asspass", "Passpass", "pasw", "assword", "pascode", "wdword", "passwords", "wdw", "paswd", "passcode", "password", "Passwd", "Passw", " passwords", "asscode", " passpass", " passw", "wdwd", "pasword", "wdcode", "asswd", "asswords", "assw", "passpass", "Passwords"], "hash": ["html", "key", "dig", "string", "auth", "inv", "message", "mac", "hat", "square", "h", "her", "match", "ash", "data", "password", "result", "handler", "hed", "search", "Hash", "sum", "tag", "ashes", "check", "md", "str", "sha", "proof", "test", "total", "shadow", "flash", "print", "score", "hex", "token", "has", "handle", "style"]}}
{"id1": "4716110", "id2": "5723876", "code1": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" Copyfile", "cpfile", " copyingfile", "cpPath", " CopyFile", " copyResource", "cpResource", " copyingResource", " CopyPath", "cpFile", " copyingPath", " copyfile", " CopyResource", " copyingFile", " copyPath"], "in": ["inn", "inc", "up", "is", "it", "isin", "old", "r", "din", "mm", "source", "b", "i", "gin", "edIn", "on", "id", "from", "In", "el", "ic", "ins", "en", "IN", "o", "l", "n", "input", "rin", "cin", "ar", "vin", "inf", "ind"], "out": ["ch", "p", "it", "Out", "v", "ex", "nt", "w", "file", "b", "log", "err", "i", "k", "io", "serv", "gt", "po", "ot", "check", "str", "t", "at", "o", "ne", "l", "output", "os", "to", "s", "oss", "outs", "OUT", "net", "n", "ou"], "sourceChannel": ["givenConnection", "fromChuck", "localChannel", "scopechannel", "srcchannel", "givenChannel", "scopeChan", "sourceStream", "scopeConnection", "fromChain", "localChuck", "SourceChain", "sourcechannel", "ourceChannel", "sourceGate", "localConnection", "givenGate", "sourceConnection", " sourceGate", "sourceChain", "srcButton", " sourceChan", "ourceChan", " sourcechannel", "Sourcechannel", "SourceChan", "sourceChuck", "fromChannel", "scopeChannel", "ourceButton", " sourceButton", "srcChannel", "givenStream", "sourceChan", " sourceConnection", "ourcechannel", "SourceGate", "sourceButton", "SourceStream", "localChain", "SourceChannel", "srcChan", "SourceConnection", "fromConnection", " sourceStream", "SourceChuck"], "destinationChannel": ["destationChannel", "destensionConnection", "Destensionchannel", "destensionContext", "destinatedChan", "destinationsChannel", " destinationEntry", " destinationClient", "destinatedchannel", "destructionChannel", " destinationChan", "destinatedEntry", "destinatedClient", "destationChan", "DestensionClient", "DestensionConnection", "DestinationClient", "destationContext", "destinatedChannel", "DestensionChannel", "destensionChannel", "destensionchannel", "destinationchannel", "destinationsChan", "destinationContext", " destensionChannel", "destensionClient", "Destinationchannel", "destinationClient", "destinatedContext", "destationClient", " destensionContext", " destinationchannel", "destructionchannel", " destensionClient", "destationchannel", "destructionConnection", "destensionChan", "DestinationChannel", "destructionClient", "destationConnection", "destinationEntry", "destinationChan", " destensionChan", " destinationContext", "destinationsEntry", "destinationschannel", "destinationConnection", "DestinationConnection"]}}
{"id1": "6866575", "id2": "5951961", "code1": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"caml_md5_string": [" saml_md52String", " saml_md2_string", " saml_md5bystr", " saml_md2_sequence", " saml_md5bysequence", " saml_md22sequence", " saml_md5_str", " saml_md52sequence", " saml_md2_String", " saml_md5byString", " saml_md52str", " saml_md22string", " saml_md5_sequence", " saml_md52string", " saml_md2_str", " saml_md5_String", " saml_md5_string", " saml_md22String", " saml_md22str", " saml_md5bystring"], "ctxt": ["CTtxt", "cttxt", " cXT", " ctx", "cttx", "Cxt", " cxt", "Ctxt", "ctXT", "CTxt", "Ctx", "CTXT", "CTtx", "CXT"], "str": ["name", "msg", "stri", "tr", "string", "vol", "char", "rs", "strings", "uts", "v", "enc", "r", "seq", "dec", "STR", "buf", "dat", "data", "conv", "txt", "sts", "sl", "arr", "oct", "form", "br", "st", "text", "out", "vc", "os", "Str", "s", "fr", "input", "sp", "dr"], "ofs": ["OFrs", " ofts", "offs", "tells", "ofds", "Ofs", "Offs", "ofrs", " ofds", "OFs", " ofns", "Ofrs", "Ofds", " offs", "OFns", "OFds", " ofrs", "tellns", "tellts", "ofts", "OFts", "OFfs", "ofns", "tellds"], "len": ["hl", "elt", "offset", "ln", "le", "inv", "bytes", "lon", "nt", "syn", "fin", "L", "fun", "ld", "lp", "il", "el", "nl", "left", "lf", "fl", "ll", "en", "mem", "un", "l", "length", "lan", "Len", "wid", "n", "end", "compl", "size", "ls", "lis"], "md5": ["d512", " mdlet", " md6", " md2", " amd51", "mn3", "md51", " mk51", "md3", "mn6", "dig6", "mdlet", "mn5", " amd52", " md512", "dig5", " mk2", "d5", " md51", "diglet", "md512", " mk52", "d3", " amd5", "d6", "md2", "dig3", " md52", "dig512", "md6", "md52", "mnlet", " md3", " mk5", " amd2"]}}
{"id1": "22734545", "id2": "5872038", "code1": "    public void generate(String urlString, String target) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream());\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target));\n        byte[] buf = new byte[10 * 1024];\n        int len;\n        while ((len = inputStream.read(buf, 0, buf.length)) != -1) {\n            outputStream.write(buf, 0, len);\n        }\n        inputStream.close();\n        outputStream.close();\n        urlConnection.disconnect();\n    }\n", "code2": "    public void parse() throws ParserConfigurationException, SAXException, IOException {\n        DefaultHttpClient httpclient = initialise();\n        HttpResponse result = httpclient.execute(new HttpGet(urlString));\n        SAXParserFactory spf = SAXParserFactory.newInstance();\n        if (spf != null) {\n            SAXParser sp = spf.newSAXParser();\n            sp.parse(result.getEntity().getContent(), this);\n        }\n    }\n", "label": 0, "substitutes": {"generate": ["decce", "generiate", "validiate", "deciate", "validator", "generce", " generatece", "generator", "decator", "validate", "decate", " generateiate", " generateator", "validce", " generateate"], "urlString": [" urlRest", "urlStr", " urlStr", "lString", "uriString", "lInterface", "UrlRest", "UrlSource", "urlSource", "lStr", " urlSource", "lSource", "UrlString", "UrlStr", "uriSource", "urlInterface", " urlInterface", "uriRest", "urlRest", "UrlInterface"], "target": ["name", "link", "origin", "path", "p", "png", "dest", "src", "localhost", "title", "bolt", "temp", "Target", "file", "source", "location", "filename", "layout", "host", "arget", "tmp", "local", "template", "gt", "root", "top", "result", "project", "base", "trace", "summary", "t", "address", "test", "table", "output", "tif", "dir", "to", "pdf"], "url": ["Url", "link", "hl", "pl", "char", "loader", "r", "u", "mount", "gl", "ssl", "build", "bel", "user", "f", "dl", "base", "uri", "web", "http", "nl", "sl", "q", "rl", "str", "ll", "browser", "ref", "https", "rel", "l", "get", "www", "URL", "ml", "ls", "ur", "ul"], "urlConnection": ["urlNode", "Urlconnection", "UrlConnect", "httpConnection", "handleconnection", "UrlSession", " urlConnect", "UrlConn", "webconnection", " urlconnection", "urlConnect", "webConnection", "webConnect", "handleConnect", "httpconnection", "httpConnect", "urlSession", "browserSession", "urlConn", "httpNode", "browserconnection", "handleConn", "webNode", "httpSession", "UrlConnection", " urlNode", "handleConnection", "httpConn", "browserConnection", "browserConnect", "urlconnection"], "inputStream": ["InputThread", "activeSource", "InputSteam", "innerstream", "innerStream", " inputSteam", "InputView", " inputstream", "outputStyle", "readSteam", "acceptThread", "readThread", "activeSteam", "InputStream", "acceptStyle", "innerSource", "inputView", "readView", "activeStream", "innerSteam", "inputSteam", "inputstream", "inputSource", "acceptSteam", "activestream", "inputThread", " inputView", "outputThread", "outputSteam", " inputThread", "readStream", "acceptStream", " inputSource", "inputStyle", " inputStyle"], "outputStream": ["writeContext", "displaySteam", "displayContext", "inputLink", " outputSteam", "outputForm", "outputWindow", "applicationStream", "writeStream", "writeSteam", "OutputStream", "applicationStack", "applicationSteam", "inputForm", "outputStreamer", "writeStreamer", "OutputWindow", "OutputSteam", " outputWindow", "inputSteam", " outputLink", "displayStream", "applicationWindow", "outputContext", "writeLink", "outputSteam", "outputLink", " outputContext", " outputForm", " outputStack", "OutputStack", " outputStreamer", "displayStreamer", "writeForm", "outputStack"], "buf": ["bn", "cap", "msg", "rev", "alph", "cv", "bc", "tx", "bs", "cb", "bl", "fam", "seq", "nb", "cmd", "b", "buffer", "bin", "var", "prop", "uf", "Buffer", "dat", "conv", "bar", "box", "tab", "batch", "bu", "arr", "good", "br", "img", "bag", "cur", "Buff", "buff", "loc", "proc", "pkg", "vec", "db", "ob", "block", "rb", "fb", "cat", "bytes"], "len": ["cap", "elt", "ln", "le", "del", "cmp", "lon", "v", "bl", "nt", "seq", "syn", "pos", "all", "lit", "gl", "fin", "L", "BL", "val", "fun", "ld", "il", "dl", "coll", "el", "nl", "lf", "mil", "str", "El", "ll", "en", "t", "lib", "no", "rel", "l", "length", "vec", "Len", "lan", "lic", "end", "z", "ler", "ls", "n", "ind", "li"]}}
{"id1": "12724876", "id2": "17558353", "code1": "    private void loadURL(URL url, String username, String password, JLabel statusDialogMBLabel) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (username != null && !username.equals(\"\")) {\n            if (password == null) {\n                password = \"\";\n            }\n            String encoding = new sun.misc.BASE64Encoder().encode(new String(username + \":\" + password).getBytes());\n            connection.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        this.tmpVRMLFile = File.createTempFile(\"xnavi-\", null, null);\n        System.out.println(\"Created tmp file: \" + this.tmpVRMLFile.getAbsolutePath());\n        FileWriter fw = new FileWriter(this.tmpVRMLFile);\n        long bytesInFile = this.tmpVRMLFile.length();\n        double sizeInMB = ((double) bytesInFile) / (1024.0 * 1024.0);\n        String response = \"\";\n        while ((inputLine = in.readLine()) != null) {\n            response = inputLine + \"\\n\";\n            fw.write(response);\n            fw.flush();\n            if (statusDialogMBLabel != null) {\n                bytesInFile = this.tmpVRMLFile.length();\n                sizeInMB = ((double) bytesInFile) / (1024.0 * 1024.0);\n                sizeInMB *= 100.0;\n                sizeInMB = (double) ((int) sizeInMB);\n                sizeInMB /= 100.0;\n                statusDialogMBLabel.setText(sizeInMB + \" MB\");\n                statusDialogMBLabel.repaint();\n            }\n        }\n        fw.close();\n        System.out.println(\"Wrote file \" + this.tmpVRMLFile.getAbsolutePath());\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            URL urlhome = new URL(\"http://www.verussolutions.biz/NGLDashBoard.xml\");\n            URLConnection uc = urlhome.openConnection();\n            InputStreamReader input = new InputStreamReader(uc.getInputStream());\n            BufferedReader in = new BufferedReader(input);\n            String inputLine;\n            String xmlData = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                xmlData += inputLine;\n            }\n            in.close();\n            PrintWriter fw = new PrintWriter(new FileWriter(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            fw.println(xmlData);\n            fw.flush();\n            fw.close();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n        try {\n            Document doc = new SAXBuilder().build(new File(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            String onlinsuppcdat = doc.getRootElement().getChild(\"OnlineSupportInformation\").getText();\n            CDATA cdata = new CDATA(onlinsuppcdat);\n            host.setOnlineInformationHTML(cdata.getText());\n            onlinsuppcdat = doc.getRootElement().getChild(\"News\").getText();\n            cdata = new CDATA(onlinsuppcdat);\n            host.setNewsHTML(cdata.getText());\n            host.fillData();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"loadURL": [" loadFile", "downloadFile", " loadUrl", "downloadURL", "useFile", " loadurl", "useUrl", "loadFile", "loadurl", "downloadurl", "useURL", "downloadUrl", "loadUrl", "useurl"], "url": ["mail", "Url", "link", "name", "remote", "hub", "path", "string", "loader", "r", "job", "run", "file", "location", "b", "ssl", "host", "channel", "build", "email", "resource", "user", "dl", "base", "uri", "res", "web", "nl", "http", "str", "ll", "browser", "address", "https", "rect", "l", "client", "request", "URL", "ur", "window", "raw"], "username": ["attribute", "name", "provided", "metadata", "initial", "consumer", "string", "about", "uno", "auth", "description", "via", "subject", "title", "photo", "rue", "users", "hello", "admin", "sudo", "filename", "author", "twitter", "profile", "email", "me", "minimum", "user", "setup", "basic", "phone", "person", "login", "usa", "pty", "uri", "ubuntu", "sword", "john", "prefix", "ername", "usr", "common", "human", "term", "ua", "authent", "USER", "account", "wikipedia", "token", "owner"], "password": ["attribute", "picture", "key", "power", "p", "string", "ssh", "pattern", "PASS", "remember", "auth", "pool", "description", "wordpress", "database", "hello", "Password", "sudo", "alias", "session", "property", "parser", "profile", "padding", "user", "application", "comment", "login", "pty", "crypt", "worker", "sword", "prefix", "hash", "post", "python", "chain", "phrase", "paste", "another", "word", "wp", "words", "shadow", "reset", "pass", "token", "note", "secret"], "statusDialogMBLabel": ["statusDialogMMLlabel", "statusDialogMBlog", "statusDialogMBRog", "statusDialogMMLabel", "statusDialogAMBlabel", "statusDialogMBlabel", "statusDialogCMBLook", "statusDialogMBLlabel", "statusDialogMBILog", "statusDialogAMBLabel", "statusDialogMHLabel", "statusDialogMIBox", "statusDialogEMBLog", "statusDialogMBLLabel", "statusDialogMBlibrary", "statusDialogCMBLog", "statusDialogAMBlog", "statusDialogMLLog", "statusDialogCMMLog", "statusDialogCMBLox", "statusDialogMHLestyle", "statusDialogCMMLox", "statusDialogEMBlabel", "statusDialogEMBLlabel", "statusDialogAMBlox", "statusDialogCMMLook", "statusDialogEMBLabel", "statusDialogMHLox", "statusDialogAMBLox", "statusDialogAMBLog", "statusDialogMMLox", "statusDialogMLLox", "statusDialogAMBLibrary", "statusDialogMBlestyle", "statusDialogMBLestyle", "statusDialogCMMLabel", "statusDialogCMBLabel", "statusDialogMBLook", "statusDialogEMBLLabel", "statusDialogAMBlibrary", "statusDialogEMBlLabel", "statusDialogMBRabel", "statusDialogMBLox", "statusDialogMIBibrary", "statusDialogMBLog", "statusDialogMHLog", "statusDialogMMLog", "statusDialogMBILook", "statusDialogMBlLabel", "statusDialogMMLLabel", "statusDialogMBRook", "statusDialogMBRibrary", "statusDialogMBLibrary", "statusDialogEMBlog", "statusDialogMLLestyle", "statusDialogMBRox", "statusDialogMIBog", "statusDialogMBILabel", "statusDialogMIBabel", "statusDialogMBlox", "statusDialogMLLabel", "statusDialogEMBllabel", "statusDialogMBILox", "statusDialogMBllabel", "statusDialogMMLook"], "connection": ["character", "Connection", "link", "established", "conn", "system", "statement", "settings", "socket", "created", "still", "connected", "description", "entry", "connect", "database", "config", "network", "session", "cone", "ion", "resource", "cci", "channel", "context", "close", "io", "application", "c", "uri", "communication", "http", "command", "nc", "language", "condition", "relation", "client", "open", "con", "position", "using", "document", "directory"], "encoding": ["Encoding", "continoding", "enoding", "Encoring", "decuation", "decoder", "continryption", "cryption", "Encoder", "cuation", "coring", "encoder", "enryption", "continoder", "enoder", "encryption", "Encryption", "continuation", "decoding", "coder", "decryption", "encoring", "enoring", "encuation", "coding"], "in": ["inn", "inc", "up", "ri", "is", "inv", "inner", "isin", "din", "info", "file", "source", "b", "bin", "i", "io", "on", "f", "from", "fs", "In", "conf", "ic", "ins", "inside", "out", "IN", "get", "con", "cin", "input", "rin", "reader", "inf"], "inputLine": ["InputBlock", "readline", " Inputline", "readBlock", " inputFile", " inputChange", "Inputline", "imageLine", "outputLine", " InputRow", " InputLine", " inputLINE", "imageFile", "imageLINE", "inputChange", "outputRow", "inputRow", "outputChange", "feedFile", "InputStream", "inputStream", " inputBlock", "feedRow", " inputRow", "inputLINE", "readLine", "feedLINE", "feedLine", "inputline", " inputStream", "inputFile", "outputline", "InputLine", "readStream", "inputBlock", " InputChange", "imageRow", " inputline"], "tmpVRMLFile": ["tmpVDmlfile", "tmpVRmlReader", "tmpVRBLFile", "tmpVRmlLine", "tmpVRmlContent", "tmpVRDLPath", "tmpVRDOMFile", "tmpVRDOMPath", "tmpVRMLPath", "tmpVCBLNode", "tmpVDMLPath", "tmpVCMLNode", "tmpVRMLLine", "tmpVRmlPath", "tmpVRPLFile", "tmpVRDLFile", "tmpVRBLPath", "tmpNRMLReader", "tmpVRLFiles", "tmpNRDLFile", "tmpVRILFile", "tmpVRmlfile", "tmpNRmlContent", "tmpNRmlFile", "tmpNRMLFiles", "tmpNRMLContent", "tmpVRILfile", "tmpVRILPath", "tmpVRMLfile", "tmpNRmlReader", "tmpNRmlfile", "tmpVRMLFiles", "tmpVRVMFiles", "tmpVCMLPath", "tmpVRBLFiles", "tmpVRDLfile", "tmpVRMLReader", "tmpVRMLContent", "tmpVRDLLine", "tmpVDMLFile", "tmpNRDLLine", "tmpVRILFiles", "tmpVRDOMReader", "tmpVRLfile", "tmpVCBLPath", "tmpVDMLFiles", "tmpVDmlFiles", "tmpVRLNode", "tmpVDmlPath", "tmpVRLPath", "tmpVRDOMFiles", "tmpNRmlFiles", "tmpVRLReader", "tmpVRmlFiles", "tmpVRPLContent", "tmpVRPLFiles", "tmpNRMLPath", "tmpNRMLfile", "tmpVRBLNode", "tmpNRmlPath", "tmpVRVMFile", "tmpVRmlFile", "tmpVCBLFiles", "tmpVRDLContent", "tmpVCMLFile", "tmpNRMLFile", "tmpVRMLNode", "tmpNRMLLine", "tmpVDMLfile", "tmpVDmlFile", "tmpVRLFile", "tmpVRDLFiles", "tmpVRPLfile", "tmpVRmlNode", "tmpVCBLFile", "tmpNRDLFiles", "tmpVCMLFiles", "tmpVRVMLine"], "fw": ["fp", "wk", "wy", "xf", "rf", "wall", "tf", "writer", "ww", "wd", "fn", "nw", "w", "ow", "rx", "wal", "wr", "fine", "fin", "wx", "iw", "hw", "fc", "f", "sw", "wire", "FW", "fs", "fd", "wl", "kw", "flo", "wb", "rw", "cow", "xp", "work", "cf", "wo", "wp", "wu", "fr", "fb", "wt", "framework"], "bytesInFile": ["bytesedInfile", "filesINModel", " bytesINFile", "tesInPage", "clipsInsFile", "bytesINModel", "bytesedInFiles", "bytesedInDo", "tesINPage", "bytesedInPath", " bytesInModel", "clipsInsDo", " bytesINModel", "bytesInsfile", "filesINfile", "bytesInPage", "bytesInfile", "bytesIntFile", "bytesedInImage", "filesInFile", " bytesInFiles", "bytesINFile", "bytesinFiles", "bytesIntModel", "filesINPath", "clipsInfile", "tesInModel", "bytesINfile", "bytesInsFile", "bytesSetDo", "bytesINPage", "bytesSetfile", "bytesedInFILE", "filesINFile", "tesINModel", "bytesinImage", "filesInModel", "filesInfile", "bytesedInFile", " bytesINFiles", "tesInfile", "bytesInsDo", "bytesIntPage", "bytesInPath", "bytesINImage", "bytesInFILE", " bytesInImage", "tesINFile", "clipsInFILE", "bytesInModel", "tesINfile", "bytesINFiles", "bytesedInModel", "bytesINPath", "filesInPath", "bytesInImage", "clipsInDo", "bytesIntfile", "clipsInsFILE", "bytesInsFILE", "bytesInsModel", "tesInFile", "bytesInsPath", "bytesSetFile", " bytesINImage", "clipsInFile", "bytesInDo", "bytesInFiles", "bytesinModel", "clipsInsfile", "bytesinFile", "bytesSetFILE"], "sizeInMB": ["SIZEINMP", "SizeINmb", "SIZEINmb", " sizeOutMB", " sizeOutGB", "sizeInsMP", "sizeinmb", "sizeOutMS", "SIZEInMM", "lengthInMP", " sizeInMP", " sizeOutMP", "sizeOutKB", "SizeOutMS", "sizeInsMS", "SIZEInMB", "SizeOutMB", "SizeInMS", "sizeINGB", "sizeInMC", " sizeINMB", "sizeOutMM", "SizeOutKB", "sizeInsGB", "sizeInGB", "sizeInMP", "lengthInsMM", "sizeOutGB", "sizeInMS", "lengthInMC", " sizeINMS", "SIZEINMB", "lengthInMB", "sizeWithinMB", "SizeInMP", "sizeOutmb", " sizeInMS", "SizeOutMM", "sizeINMP", "sizeOutMC", " sizeOutmb", "sizeWithinKB", " sizeInMM", "SizeINGB", "lengthInsMB", "sizeIntMB", "SizeINMB", "SizeInMB", "sizeinGB", " sizeInGB", "sizeInsMM", "sizeInKB", "sizeIntMM", "sizeInsMC", "sizeOutMP", "SizeINMM", "sizeInMM", "SizeInKB", "sizeinMP", "SizeInMM", "sizeINMS", "SIZEInmb", "sizeIntMS", "SizeInGB", "SizeOutMP", "sizeOutMB", "lengthInMM", "sizeInsmb", "lengthInsMC", "SIZEINMM", "lengthInsMP", " sizeINMP", " sizeINMM", "sizeINmb", "sizeINMM", "sizeInsMB", "sizeinMB", "sizeWithinMP", "sizeINMB", "SizeInmb", " sizeInmb", "sizeInmb", "sizeWithinMM", "SIZEInMP", "sizeinMM"], "response": ["sequence", "answer", "version", "resp", "continue", "def", "description", "message", "sample", "entry", "value", "json", "hello", "query", "question", "network", "next", "template", "example", "result", "application", "complete", "search", "res", "vector", "command", "status", "page", "onse", "frame", "Response", "object", "hash", "text", "collection", "chain", "relation", "csv", "phrase", "output", "line", "block", "request", "reset", "field", "print"]}}
{"id1": "19378010", "id2": "14194234", "code1": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "code2": "    private String File2String(String directory, String filename) {\n        String line;\n        InputStream in = null;\n        try {\n            File f = new File(filename);\n            System.out.println(\"File On:>>>>>>>>>> \" + f.getCanonicalPath());\n            in = new FileInputStream(f);\n        } catch (FileNotFoundException ex) {\n            in = null;\n        } catch (IOException ex) {\n            in = null;\n        }\n        try {\n            if (in == null) {\n                filename = directory + \"/\" + filename;\n                java.net.URL urlFile = ClassLoader.getSystemResource(filename);\n                if (urlFile == null) {\n                    System.out.println(\"Integrated Chips list file not found: \" + filename);\n                    System.exit(-1);\n                }\n                in = urlFile.openStream();\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuffer xmlText = new StringBuffer();\n            while ((line = reader.readLine()) != null) {\n                xmlText.append(line);\n            }\n            reader.close();\n            return xmlText.toString();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"Integrated Chips list file not found\");\n            System.exit(-1);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getProteins": ["getPtein", "getPesteins", "getProteinIns", "getProteIns", "getProteinin", "getPteins", "getPesteIns", "getProroteelines", "getPesteelines", "getProroteIns", "getPestein", "getPteelines", "getProteinelines", "getProteinins", "getPteIns", "getProtein", "getProteelines", "getProroteins", "getProrotein"], "queries": ["quiries", "ques", "questeries", "quues", " quiries", " quests", "qests", "aquests", "qiries", "aquions", "qeries", "requions", "questests", "aqueries", "aquues", "quests", "quions", "questions", "requests", "requues", "questiries", "questues", " quues", "requeries"], "taxon": ["taxON", "Taxonomy", "Taxen", "axON", "taxiton", "axonomy", " taxiton", " taxen", "TaxON", "taxid", "axid", "taxonomy", " taxid", "axiton", " taxON", "taxen", " taxonomy", "axen", "Taxiton", "Taxid", "axon", "Taxon"], "parser": ["auto", "php", "pp", "writer", "system", "p", "xml", "process", "loader", "apache", "Parser", "walker", "builder", "jack", "parse", "ucker", "bank", "processor", "arser", "book", "basic", "lp", "handler", "maker", "http", "peer", "command", "instance", "ner", "browser", "Reader", "er", "proc", "creator", "token", "document", "pdf", "reader", "pd"], "xpe": ["zpes", "zte", "pxpe", "pxte", " xpse", " xme", "xpes", "axte", "axme", "xspl", " xpes", "axpe", "xpse", "xsme", "zpse", "pxpes", "xme", "xste", "axpl", "pxpse", "xpl", "xspe", "xte", " xpl", "zpe", " xte"], "proteins": ["proroteans", "pegeins", "protegins", "promeals", "proroteals", "pegein", "prosteins", "promeains", "pegegins", "propeins", "prostein", "proroteains", "Proroteins", "progeins", "Protein", "propeals", "proceals", "Proteains", "propegins", "prorotein", "proceIns", "prosteals", "procein", "progein", "proceins", "Prorotein", "propeans", "pegeans", "ProroteIns", "proteIns", "petein", "progeans", "peteins", "Proteals", "peteans", "promein", "propein", "proroteIns", "proroteins", "proteals", "proteans", "prosteains", "petegins", "promeins", "prorotegins", "Proroteals", "Proroteains", "proteains", "propeIns", "Proteins", "ProteIns", "progegins", "protein"], "query": ["name", "execute", "path", "key", "string", "qu", "Query", "sq", "statement", "select", "continue", "description", "subject", "entry", "content", "title", "expression", "series", "json", "question", "alias", "resource", "parse", "ql", "password", "comment", "uri", "search", "q", "command", "quote", "sql", "tag", "prefix", "check", "text", "chain", "condition", "test", "term", "word", "request", "row", "qa", "quest", "filter", "eries", "column"], "connection": ["remote", "character", "Connection", "link", "response", "cache", "established", "server", "conn", "external", "writer", "still", "statement", "socket", "created", "pool", "connected", "description", "current", "pointer", "entry", "internet", "connect", "database", "number", "location", "network", "session", "cone", "ion", "resource", "creation", "channel", "function", "close", "context", "reference", "library", "application", "c", "handler", "uri", "driver", "communication", "command", "nc", "generation", "console", "ticket", "collection", "language", "condition", "no", "bo", "relation", "client", "open", "con", "position", "creator", "reset", "document", "directory", "wrapper"], "encoded": ["encured", "Encoding", "Encoded", "enoding", "enccoded", "enoded", "unicoded", "decoder", "deccoded", "encoding", "Encoder", " encoding", "uniccoded", " encached", "unicoding", "Encured", "decured", "encoder", "enured", "decoded", "enoder", "unicached", "decoding", " enccoded", "decached", "encached"], "url": ["mail", "Url", "name", "link", "external", "conn", "socket", "char", "r", "sb", "location", "log", "ssl", "email", "bel", "dl", "uri", "web", "nl", "http", "sl", "el", "rl", "str", "ll", "browser", "address", "https", "loc", "l", "open", "con", "URL", "net", "ls", "ur", "ul"], "stream": ["iterator", "sequence", "response", "view", "present", "pool", "message", "sample", "current", "content", "stack", "feed", "file", "source", "buffer", "network", "resource", "read", "channel", "context", "data", "sw", "engine", "Stream", "pod", "body", "store", "console", "in", "collection", "chain", "out", "output", "row", "ream", "input", "screen", "trans", "document", "reader", "window"], "doc": ["msg", "html", "tx", "def", "xml", "g", "nt", "content", "json", "file", "div", "date", "city", "DOC", "data", "Doc", "Document", "m", "oc", "sum", "page", "cam", "body", "md", "text", "t", "str", "out", "dc", "d", "db", "word", "dir", "tree", "dict", "graph", "js", "document", "dr", "window"], "nodes": ["nums", "nsodes", " Namps", " nubes", "nubs", "nsums", "enumbers", " Nodes", " nords", "nubes", "snums", "numbers", " nones", "enones", " Noms", "noms", "nords", " nubs", "lums", "enubes", "nons", "neaves", "neumbers", "enodes", "naves", "lodes", " Nords", "nods", "enords", "lods", "joms", "jodes", "jords", " naves", "enaves", "snods", "namps", "ntones", "nsods", "ntubs", "ntords", "enubs", "snons", "jamps", "ntodes", "nsons", "neodes", "neubes", " numbers", " namps", "nones", "lons", "snodes", " noms"], "n": ["ni", "len", "ln", "nm", "g", "v", "nt", "nw", "ns", "nb", "nn", "number", "np", "k", "nan", "j", "num", "m", "nl", "ot", "nc", "an", "ll", "en", "nu", "mn", "no", "o", "d", "ne", "sn", "un", "l", "na", "net", "N", "cn"], "i": ["ix", "bi", "ip", "init", "mi", "is", "x", "it", "gi", "phi", "ui", "wi", "ji", "si", "a", "ini", "hi", "info", "index", "u", "e", "cli", "\u0438", "iu", "ti", "ci", "me", "ori", "zi", "multi", "j", "di", "xi", "m", "y", "ei", "ic", "eu", "ms", "qi", "us", "ki", "o", "ai", "I", "pi", "print", "sim", "ii", "li"], "node": ["remote", "name", "obj", "child", "ode", "key", "image", "stroke", "document", "job", "device", "slave", "entry", "edge", "entity", "nn", "e", "brain", "source", "holder", "resource", "tmp", "local", "Node", "cell", "good", "object", "normal", "card", "t", "element", "ne", "line", "word", "tree", "row", "ye", "field", "token", "note"]}}
{"id1": "6470716", "id2": "20519261", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 0, "substitutes": {"st": ["sm", "stri", "est", "inst", "sth", "sh", "stream", "se", "ost", "start", "tt", "sta", "ld", "step", "sw", "stra", "sts", "std", "store", "service", "set", "str", "ast", "t", "sty", "ust", "ste", "d", "sn", "ST", "ft", "nd", "St", "stable", "www", "th", "sp", "rt", "ist", "rest"], "url": ["mail", "Url", "link", "hl", "html", "pl", "ch", "cert", "domain", "shell", "string", "addr", "char", "ret", "r", "cl", "mount", "file", "location", "gl", "ssl", "host", "build", "bel", "f", "dl", "base", "abs", "uri", "github", "il", "web", "http", "nl", "sl", "el", "fl", "impl", "str", "ll", "browser", "address", "ref", "loc", "rect", "rel", "l", "client", "null", "www", "URL", "ls", "ur", "rest", "ul", "li"], "fis": ["tiss", "tis", "efis", "uf\u00eds", "xfis", "Fis", "ufiss", " fisl", "tos", "efi", "fiss", "tais", "ufis", "efiss", "xfier", "xfi", "flisl", "ef\u00eds", "fliss", "flis", "fisl", "fei", " f\u00eds", "xfois", "Fiss", " fi", "feis", "fi", "fli", "Fais", "fier", "f\u00eds", "Fier", "Fos", " fiss", "feier", "fois", "Fi", "ufisl", "feois", "ufi", " fais", "fais", "Fois"], "zis": [" zos", "zhisin", "zos", "zenis", "czisa", " zris", "fiss", "zenisi", "zipos", "zris", "zisin", "zhIs", "ozisin", "zits", "ozes", "zipIs", "zIs", "zes", "zisi", "zipisin", " zIs", "zipits", "fits", " ziss", "ozits", "zhes", " zisa", "zhis", "ozis", "zisa", "ozIs", "czits", "ziss", "fris", "zipes", "czis", "zeniss", "ozisa", " zisi", "fisi", "zenris", " zits", "zipis", "czIs"], "entry": ["zip", "name", "attribute", "link", "obj", "existent", "key", "enter", "system", "zo", "pattern", "char", "def", "nt", "se", "info", "member", "entity", "e", "ent", "event", "jo", "source", "de", "log", "tmp", "inter", "Entry", "record", "match", "ry", "result", "comment", "way", "valid", "cell", "form", "or", "office", "card", "chain", "out", "item", "element", "jar", "line", "word", "null", "row", "list", "fr", "ie", "ce", "field", "sp", "be", "index"], "count": ["name", "counter", "len", "ch", "amount", "child", "char", "cc", "nt", "add", "current", "index", "max", "acc", "nb", "last", "number", "start", "buffer", "err", "read", "ount", "match", "call", "num", "batch", "base", "comment", "c", "force", "cont", "sum", "page", "ctr", "cell", "check", "depth", "code", "t", "length", "total", "iter", "Count", "core", "end", "size", "found", "ct", "n", "ind"], "data": ["name", "cache", "image", "string", "ata", "part", "def", "message", "sample", "value", "number", "json", "all", "source", "buffer", "bin", "reason", "dat", "next", "buf", "zero", "result", "step", "batch", "done", "mu", "good", "text", " DATA", "mem", "out", "chain", "d", "table", "output", "length", "block", "n", "DATA", "size", "bytes", "area", "raw", "format"], "fos": ["fool", "Fol", "fOS", "fioss", "wOS", "foops", "hOS", "Fops", "fios", "hos", "woss", "fooss", "his", "wis", "fol", "wos", "hoss", "foss", "fiol", "Foss", " fOS", "Fos", "foos", "fops", "fiops", " foss"], "dest": ["origin", "comp", "est", "nom", "parent", "exp", "writer", "Dest", "master", "src", "pipe", "nt", "target", "member", "temp", "gest", "source", "bin", "comb", "dat", "transfer", "ptr", "coord", "result", "done", "det", "crit", "cont", "way", "pas", "std", "send", "sum", "desc", "mem", "gate", "out", "them", "dc", "loc", "foreign", "test", "des", "usr", "output", "nd", "dist", "trans", "cat", "rest", "decl"]}}
{"id1": "22135199", "id2": "300397", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": [" testCodingSizeFile", " testCodingemptyStream", " testCachingEmptyFile", " testCachingEmptyFiles", " testCodingSizeFiles", " testCodingEmptyFiles", " testCodingSizeStream", " testCodingFullfile", " testCodingemptyFile", " testCodingEmptyfile", " testCachingemptyFile", " testCodingFullFiles", " testCodingEmptyStream", " testCodingFullFile", " testCodingemptyfile", " testCachingemptyFiles", " testCodingemptyFiles", " testCachingEmptyfile", " testCodingFullStream", " testCodingSizefile", " testCachingemptyfile", " testCachingemptyStream", " testCachingEmptyStream"], "baos": ["baOs", " baoss", "bao", "tao", "boOs", "caoS", "caOs", " bao", "taoS", "boos", "caos", "aoo", "Baos", "aoos", "aoOs", "booss", "Bao", "baOS", "aoOS", "BaOs", "cao", " baOS", " baOs", "boo", "baoS", "taOs", "boOS", "baoss", "Baoss", " baoS", "taos"], "channel": ["room", "cache", "server", "ch", "system", "socket", "stream", "message", "window", "file", "container", "controller", "buffer", "session", "network", "resource", "io", "context", "password", "application", "queue", "batch", "c", "handler", "command", "caster", "console", "service", "chain", "out", "chan", "cm", "component", "client", "con", "block", "connection", "input", "Channel", "can"], "params": ["radius", "name", "units", "fps", "p", "cmp", "settings", "cms", " parameters", "pool", "rs", "ps", "names", "mm", "json", "Parameters", "config", "AMS", "sys", "par", "param", "caps", "tags", "data", "pps", "password", "phys", "services", "pins", "conf", "details", "ops", "parts", "spec", "types", "proc", "Par", "ctx", "ams", "limits", "pi", "options", "headers", "pretty", "properties"], "outbuf": ["outbuffer", "outrb", "outputbuf", "OutBuffer", " outBuffer", "inBuffer", "outBuffer", "Outbuff", "outbuff", "inbuff", "Outbuffer", " outbuffer", "inrb", "outputbuffer", "Outbuf", " outbuff", "outputrb", " outrb", "outputbuff", "inbuffer", "inbuf"], "metrics": ["metric", "Metrics", "metcs", "mutcs", "matrors", "mtcs", "mtths", "metrors", "mutrics", "monrix", "matrics", "monrors", "mutrices", "mtrics", " metths", "matrix", "metrix", "metths", "mtrices", "metrices", "Metrix", "matric", "mutths", "Metric", " metrices", "monrics", "Metrors", "monric", " metcs"], "encoder": ["execrier", "Encoding", "ecoded", "Encramer", "enoding", "enoded", "ecrier", "ecramer", "encressor", " encressor", "executer", "execoder", "encuter", "eciever", "eniever", "encoding", "Encoder", " encoding", "Encrier", "ecoder", "Enciever", "encoded", " encuter", "encrier", "Encuter", " encrier", "ecressor", "enoder", "ecoding", "execoding", " encramer", "enciever", "enressor", "enrier", "encramer", "enramer", " encoded"], "tmpFile": ["mpFile", " tmpKey", "tmpFiles", "tmpFILE", " tmpFILE", " tmpFiles", "tmpName", "tmpFilename", "tempFiles", "tmpPath", "txtPath", "fakeFiles", "tmpKey", "testName", "imgKey", "mpFilename", " tmpFilename", "imgFILE", "testfile", "tempKey", " tmpPath", "tempPath", "txtFile", "mpName", "tempfile", "tempFILE", "tempFilename", "testFilename", "fakefile", "testFile", "fakeFilename", "mpfile", "tempFile", "fakeFile", "tmpfile", "imgFile", " tmpfile", "imgfile", " tmpName", "txtfile"], "fout": ["fOUT", "fbal", "wOut", "sfout", "fullbal", "lOUT", "foutput", "wout", "dfOUT", "vOut", "fouts", "fullOUT", "sfouts", "vao", "fullout", "wao", "sfao", "vouts", "dfout", "vout", "dfoutput", "fao", "lout", "fOut", "wouts", "lbal", "dfbal", "sfOut", "loutput", "fulloutput"], "wrtout": ["wrdin", "wgtw", "wgtout", "ewrtwriter", "hwrtwriter", "hwrtw", "wrtin", "wrcw", "hwrcwriter", "hwrcw", "ewltwriter", "ewrtin", "wrtio", "wttout", "Wrtio", "Wrdwriter", "wrdgen", "Wrdio", "ewrtout", "wrtwriter", "wltgen", "Wrtn", "wwtwriter", "wrtgen", "wttwriter", "wdrout", "ewltout", "wltwriter", "hwrtout", "wwtex", "wrtn", "wrcex", "ewltin", "wdrgen", "wRTio", "wrcout", "wwtw", "wrdn", "hwrcout", "hwrtex", "wgtwriter", "wrdout", "wrtw", "wttn", "Wrdn", "wdrin", "wRTout", "ewrtgen", "wdrwriter", "ewltgen", "wrcwriter", "wwtout", "wgtex", "wrtex", "wRTn", "Wrdout", "hwrcex", "wrdio", "wRTwriter", "wttio", "wltin", "Wrtout", "Wrtwriter", "wltout", "wrdwriter"], "fchannel": [" fconnection", " fcontroller", "Fnet", " fnet", " fChannel", "fcconnection", " fchan", "Fconsole", "fnet", "fcchan", "flnet", "wconnection", "fccontroller", "Fchannel", "fconnection", "fcchannel", "FChannel", "flchannel", "fchan", "fChannel", "flChannel", "fconsole", "wchan", "flconsole", "fcontroller", "wcontroller", "wchannel", " fconsole"], "s": ["ws", "string", "sq", "ts", "p", "is", "rs", "g", "v", "a", "r", "ds", "w", "ns", "gets", "e", "b", "i", "S", "h", "gs", "ss", "j", "sg", "f", "sv", "c", "m", "str", "t", "csv", "js", "qs", "ls", "n"]}}
{"id1": "442381", "id2": "20851065", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionscheck", "doBuildTest", "doFeatureCheck", "doBuildcheck", "doVersionQuery", " doVersionsCheck", " doVersionTest", "doVersionsCheck", "doVersionUpdate", " doVersionQuery", " doVersioncheck", "doBuildCheck", " doApplicationCheck", "doFeatureTest", "doImageCheck", "doApplicationTest", "doImageTest", "doApplicationInfo", "doVersionsUpdate", " doVersionscheck", "doImageInfo", "doVersioncheck", "doImageQuery", "doApplicationCheck", "doFeatureUpdate", "doVersionsTest", " doVersionsUpdate", " doApplicationInfo", "doFeatureInfo", "doFeaturecheck", " doVersionUpdate", " doVersionInfo", " doApplicationQuery", "doVersionInfo", "doVersionTest", "doApplicationQuery", "doFeatureQuery", " doVersionsTest", "doBuildUpdate", " doApplicationTest"], "view": ["views", "port", "html", "server", "cv", "image", "version", "model", "display", "this", "pool", "v", "subject", "lock", "View", "file", "controller", "query", "update", "buffer", "layout", "eye", "VIEW", "h", "context", "manager", "tv", "box", "call", "project", "see", "report", "engine", "http", "q", "page", "cell", "form", "virtual", "check", "browser", "widget", "review", "component", "client", "iew", "block", "tree", "row", "input", "ml", "show", "vm", "self", "print", "document", "window", "index"], "url": ["mail", "Url", "link", "hl", "html", "pl", "oul", "domain", "char", "v", "r", "job", "mount", "file", "lb", "b", "log", "gl", "ssl", "host", "build", "bel", "f", "dl", "uri", "http", "nl", "sl", "rl", "str", "ll", "browser", "address", "ref", "loc", "rel", "l", "client", "get", "URL", "ur", "ul"], "in": ["inn", "inc", "ln", "init", "is", "ain", "mat", "sin", "inner", "stream", "isin", "din", "info", "source", "i", "asin", "gin", "on", "f", "from", "In", "body", "ins", "out", "mn", "IN", "l", "n", " din", "cin", "input", "rin", "can", " IN", "reader", "vin", "inf"], "bin": ["inn", "bi", "bn", "cache", "bg", "len", "ln", "abin", "init", "cb", "sin", "inner", "jin", "bl", "din", "spin", "nb", "brain", "file", "ebin", "b", "mon", "bed", "buffer", "cos", "session", "all", "stock", "gin", "local", "ran", "conv", "sam", "win", " bins", "body", "ins", " Bin", "lib", "binary", "buff", "out", "by", "db", "con", " din", "bur", "rb", "cin", "rin", "re", "obin", "reader", "thin"], "line": ["port", "link", "lane", "sequence", "liner", "ln", "key", "le", "tile", "string", "stay", "ine", "part", "char", "lines", "stream", "message", "sample", "job", "entry", "detail", "cmd", "Line", "file", "point", "log", "err", "channel", "parse", "next", "LINE", "record", " block", "eline", "comment", "base", "lin", "cell", "page", "status", "trace", "frame", "range", "code", "chain", "rule", "zone", "lo", "l", "section", "iter", "word", "block", "ice", "row", "inline", "field", "cat", "print", "style", "column"], "develBuild": ["depoLog", "duvelBuild", "devBuilder", "devBuilt", "deVELBuild", "devbuild", "duvelBuilder", "DevelLog", "deployRelease", "DevelBuild", "depoBuild", "duvelBuilt", "deployBuilder", "DeVELLog", "desVELBuild", "devBuild", "duffbuild", "deVELBoot", "DevelBuilt", "develLoad", "devBoot", "deffBuilder", "duVELBuild", "develbuild", "develRelease", "develBoot", "devLog", "develLog", "duffBuild", "deVELLog", "develBuilder", "desVELLoad", "deployLoad", "deVELBuilder", "desVELRelease", "depobuild", "deployBuilt", "deffbuild", "deploybuild", "DeVELbuild", "DeVELBuild", "duVELbuild", "deVELBuilt", "desvelRelease", "desvelLoad", "deVELLoad", "deVELbuild", "desvelBuild", "deeltaLoad", "deeltabuild", "DeVELBuilt", "deployBoot", "deeltaBuild", "duvelBoot", "duVELBuilder", "duffBuilder", "deVELRelease", "desVELbuild", "deployBuild", "deffBuilt", "Develbuild", "deffBuild", "duvelbuild", "duffBuilt", "desvelbuild", "develBuilt", "duVELBoot", "depoBuilt", "deeltaRelease"], "stableBuild": ["devBuilder", "stableCraft", "confirmedLong", " stableLong", "devbuild", "secureBuilder", "devBuild", "confirmedbuild", "securebuild", " stablebuild", "activeMake", "stableLong", " stableMake", "devMake", "secureBuild", " unstableBuilder", " unstableBoot", "stablebuild", " unstableBuild", " stableBoot", " stableBuilder", "stableMake", "activeBuilder", "activebuild", "activeBuild", "devBind", " unstableBind", "confirmedBuild", " unstablebuild", "secureCraft", "stableBind", "stableBoot", " unstableLong", "confirmedBoot", "stableBuilder", " stableCraft", " unstableCraft", " stableBind"]}}
{"id1": "6840241", "id2": "536614", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copy": ["delete", "link", "system", "opy", "replace", "gc", "cop", "read", "close", "transfer", "map", "cover", "call", "sync", "save", "clip", "slice", "create", "move", "load", "clone", "write", "share", "Copy", "size", "cat", "print", "cp"], "source": ["Source", "cache", "origin", "parent", "image", "shell", "select", "pse", "inner", "stream", "ource", "src", "master", "subject", "sample", "se", "si", "scope", "sr", "wrapper", "info", "start", "session", "resource", "context", "local", "template", "base", "from", "site", "status", "sql", "body", "store", "inside", "ins", "spec", "table", "iter", "input", "ie", "ce", "size", "sp", "SOURCE", "reader", "style", "state"], "sink": ["Source", "asink", "slource", "asinker", "sinker", "sue", "ssender", "sender", "slue", "ssinker", "Sender", "ssink", "asender", " sinker", "ssource", "slender", "asource", "Sink", " sue", " sender", "Sue", "slink", "Sinker"]}}
{"id1": "18339787", "id2": "12678045", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"reload": ["overload", "overLoad", "reLoad", "Reload", "ReLoad", "Rebuild", "disload", "overbuild", "disLoad", "replay", "display", "Replay", "rebuild", "disbuild", "overplay"], "currentDate": ["currentDoc", "reportedData", "reportedDoc", "CurrentYear", " CurrentDate", " CurrentDoc", "currentData", " CurrentData", " currentData", " CurrentTime", "CurrentDate", "reportedDate", " currentDoc", "reportedTime", " currentTime", "CurrentTime", " currentYear", "reportedYear", "currentTime", "currentYear"], "xpath": [" xath", "xxpt", "xPath", "dxprop", "xxath", " xPath", "axPath", "axtrace", "xpr", "axpointer", "rxpath", " xpointer", "xtrace", "expr", " xpr", "dxpath", "wprop", "ixath", "wPath", " xpt", " xprop", "xxpath", "xxwhere", "xath", "ixpt", "xxtrace", "ixpath", "xwhere", "dxPath", "xpointer", "axgraph", "expath", "axwhere", "dxwhere", "rxPath", "wpath", "txPath", " xgraph", "ixpointer", "expointer", "rxpr", " xwhere", "txgraph", "xgraph", "xprop", "xxpointer", "txpointer", "xpt", "rxpointer", " xtrace", "exPath", "axpath", "wwhere", "txpath"], "docBuilderFactory": ["docBuildInterface", "docBuilderFactor", "docMakerInterface", "docBuilderInterface", " docBuilderFactor", "docPathClass", "docBuildFactor", " docBuilderFact", " docBuilderClass", "docBuildFactory", "docPathFact", "docBuildFact", "docPathFactor", "docPathFactory", "docMakerFactor", "docBuilderFact", "docMakerFact", "docBuilderClass", " docBuilderInterface", "docBuildClass", "docMakerFactory"], "docBuilder": ["DocumentBu", "DocumentParser", " DOCBuild", "docBuild", "DocBuilder", "documentBuild", "documentbuilder", " DOCBuilder", " DOCParser", " docBu", "DocBu", " docParser", "documentBuilder", "docBu", "DocumentBuild", "DocBuild", "docbuilder", " docBuild", " DOCBu", "DocumentBuilder", "documentBu", "docParser", " docbuilder", "Docbuilder"], "conn": ["Connection", "link", "obj", "ch", "cert", "ws", "resp", "socket", "cb", "comm", "enc", "nt", "opens", "connect", "cmd", "syn", "ssl", "close", "conv", "iw", "lang", "c", "res", "nc", "cn", "gate", "out", "loc", "jp", "cm", "ctx", "client", "open", "db", "con", "connection", "oss", "ann", "Conn", "ls", "ct", "n", "cp", "handle", "addr"], "url": ["Url", "util", "link", "obj", "cert", "socket", "char", "mb", "r", "u", "sb", "mount", "lb", "b", "gl", "ssl", "bel", "f", "dl", "base", "abs", "web", "http", "sl", "nl", "sql", "rl", "str", "ll", "browser", "ref", "https", "rel", "l", "open", "client", "con", "connection", "URL", "net", "ls", "ur", "window", "n", "cp", "ul"], "xml": ["mail", "zip", "xf", "response", "php", "html", "path", "cert", "model", "ws", "image", "full", "x", "news", "p", "content", "json", "feed", "node", "config", "event", "file", "log", "date", "dom", "context", "parse", "email", "data", "template", "txt", "dl", "rss", "el", "http", "page", "body", "details", "str", "text", "item", "element", "tml", "eps", "doc", "xp", "output", "tree", "list", "ml", "input", "px", "tm", "print", "document", "pdf", "wt", "raw", "format"], "exchangeRateDate": ["exchangeRateMessage", "exchangeRangeDate", "exchangeCountMessage", "exchangeRuleDay", "exactionRateDays", "excelRateTime", "exchangeRangeDay", "excelRateDay", "exactionRateDate", "exchangerateDays", "exchangerateMessage", "exchangeRuleTime", "exactionrateDays", "excelrateDay", "exchangeRuleMessage", "exchangeRateDays", "exchangeCountDay", "exchangeTimeDate", "exchangerateDay", "exactionRateDay", "excelRateMessage", "exchangeCountDate", "exactionrateTime", "exchangeRangeTime", "exchangerateDate", "exchangeTimeDays", "exactionrateDay", "excelrateTime", "exchangerateTime", "excelrateDate", "excelRateDate", "exchangeCountTime", "exchangeTimeDay", "exactionRateTime", "exchangeTimeTime", "exactionrateDate", "exchangeRateTime", "excelrateMessage", "exchangeRuleDate", "exchangeRateDay", "exchangeRangeDays"], "currenciesNode": ["currenciesChan", "currencyChan", "cururrenciesChan", "currenciesList", "currencyCard", "curriesCard", "CurrenciesEvent", "curriersCard", "curreditsN", "curriersNode", "curreditsNode", " currenciesCard", " curriesNode", "currencyNode", "CurriesList", "CurriesN", "curthsList", "CurrenciesNode", "currsNode", "curreditsEvent", " curriesCard", "CurriesNode", "curriesChan", "curthsNode", "currsEvent", "curriersList", "currenciesCard", "currsList", "cururrenciesNode", "curriesNode", "cururrenciesCard", "curreditsList", "curriesList", "CurrenciesN", "curthsN", "curthsCard", "curriesN", "CurrenciesCard", "CurrenciesList", "currsN", " currenciesChan", "currenciesEvent", "curriersN", "CurriesEvent", "CurriesCard", " curriesChan", "currenciesN", "curriesEvent"], "currencies": ["corables", "constractions", "constpora", "cables", " curries", "crates", "Currencies", "Curries", "carrencies", "crencies", "curarters", "Curarters", "chractions", "chries", "carries", " cururrencies", "curpora", "constries", "currates", " curarters", "chrencies", "charurrencies", "constrencies", "correncies", "curables", "curries", "corurrencies", "carractions", "charrencies", "curractions", "chpora", "corries", "corarters", "Cururrencies", "corrates", "charables", "charrates", "carpora", "cururrencies"], "i": ["ix", "bi", "sequence", "ip", "key", "init", "oi", "span", "mi", "is", "x", "it", "phi", "gi", "ui", "ji", "si", "a", "ini", "ami", "u", "e", "cli", "\u0438", "gu", "io", "ci", "me", "ti", "j", "multi", "di", "id", "xi", "m", "c", "batch", "iq", "uri", "status", "ri", "y", "ic", "in", "ms", "qi", "ki", "o", "ai", "I", "n", "ie", "pi", "yi", "sim", "index", "ii", "li"]}}
{"id1": "11968328", "id2": "6517139", "code1": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": [" calculatemd1", " calculateMD2", " calculatemd5", " getMT5", " getmd5", " getMDState", " getHash2", " getMD1", " getMTState", " getMD2", " getHash5", " calculateMD5", " getHashState", " getmdState", " getmd1", " getmd2", " calculateMDState", " calculatemdState", " calculatemd2", " getHash1", " calculateMD1", " getMT2", " getMT1"], "_pwd": ["_wppriv", " _spw", " _pw", "_cwd", "_cfx", "_vppriv", "_pword", "_sppriv", "_wpword", "_vpw", "_passwords", "_vpwd", " _passw", "_pwords", "_passwd", "_ppriv", "_passw", "_passfx", " _pfx", "_wpw", "_cw", " _passwd", "_vpword", " _pword", "_cwords", " _passwords", "_pw", " _sppriv", " _passfx", "_spwd", " _spwd", "_spwords", "_pfx", " _pwords", "_spword", "_spfx", " _spword", "_spw", " _ppriv", "_wpwd"], "md": ["mail", "sm", "msg", "del", "dig", "and", "cd", "mb", "MD", "add", "dm", "dh", "mm", "man", "der", "od", "cmd", "ng", "hd", "ind", "bd", "de", "h", "sd", "tmp", "mod", "ld", "m", "det", " Md", "down", "pm", "bf", "rm", "mp", "mg", "ms", "red", "mn", "d", "db", "nd", "dir", "mand", "dd", "mc", "mt", "mk", "df", "pd"]}}
{"id1": "9826240", "id2": "18005010", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "label": 0, "substitutes": {"checkHashBack": ["checkClearDown", " checkhashUp", "checkHashDown", " checkHashback", " checkHashUp", "checkLockUp", "checkClearBack", "checkHashback", "checkLockDown", "checkHashUp", "checkhashUp", " checkhashDown", "checkhashDown", "checkhashBack", "checkClearback", "checkLockBack", " checkhashBack", "checkhashback", " checkHashDown", " checkhashback", "checkClearUp", "checkLockback"], "facade": ["funcade", "latade", "formade", "Facades", "facaded", "formace", "facades", "Facade", "latlegate", "facace", " facades", "glader", "glage", "Facader", " facage", "latace", "facader", "latader", "servade", "servaded", "famade", " facaded", "funclegate", "faclegate", "Facage", "famace", "Facaded", "formacet", "Facificate", "facacet", "facage", "Faclegate", "funcader", "servades", "glade", "formificate", "famificate", "famacet", "Facacet", "funcage", "servage", "facificate", "funcace", "glace", "Facace"], "req": ["msg", "obj", "p", "resp", "sq", "tx", "uj", "qt", "aux", "org", "required", "attr", "rec", "forge", "r", "e", "cmd", "Request", "params", "err", "etc", "wx", "data", "Resp", "rpm", "queue", "qq", "res", "needed", "reg", "q", "http", "ctr", "good", "forced", "body", "wcs", "Requ", "cur", "out", "urg", "jp", "proc", "rh", "work", "ctx", "gr", "pkg", "mr", "request", "rb", "requ", "compl", "qs", "require", "quest", "desc"], "txtTransactionID": ["txtTxKey", "textTxID", "xtTxKey", "xtTxID", "txtTransKey", "txtTxName", "txtOrderID", "txtTransName", "txtTransactionName", "textTransactionId", "textTransactionName", "txtTransactionId", "txtTXID", "textTransactionID", "textTxName", "txtTransID", "txtOrderId", "txtTXId", "xtTransactionKey", "txtTransId", "xtTransactionName", "xtTransactionId", "txtTXName", "txtTransactionKey", "txtOrderKey", "xtTxName", "txtTxId", "xtTxId", "xtTransactionID", "txtTxID", "textTxId", "txtOrderName"], "txtOrderTotal": ["txtOrdComplete", "txtJobId", "strTransactionComplete", "txtTradeComplete", "txtTransactionBase", "txtTransactionComplete", "txtOrderComplete", "txtOrderSum", "txtOrdInfo", "xtOrdSum", "xtOrdId", "xtOrderSum", "txtJobInfo", "txtOrderInfo", "txtOrdBase", "txtArticleSum", "strTransactionTotal", "xtOrderInfo", "strOrderComplete", "txtJobSum", "txtTradeBase", "xtOrdTotal", "txtOrderId", "txtArticleInfo", "xtOrderId", "txtOrdSum", "txtTransactionTotal", "txtTradeTotal", "xtOrdInfo", "strTransactionBase", "txtOrdTotal", "txtOrdId", "strOrderBase", "txtJobTotal", "txtArticleTotal", "txtArticleId", "xtOrderTotal", "txtOrderBase", "strOrderTotal"], "txtShopId": ["xtSiteid", "txtServerid", "txtServerID", "xtSiteId", "txtStreetId", "txtSiteID", "textStoreId", "txtSiteAid", "textShopId", "textShopById", "textShopid", "txtStoreID", "txtShopid", "txtShopID", "txtStreetid", "txtSiteById", "xtShopid", "txtShopById", "textStoreById", "xtSiteID", "txtServerId", "txtSiteid", "xtShopAid", "xtShopId", "textShopID", "txtStoreById", "txtForgeId", "textStoreid", "txtStreetID", "textStoreID", "xtSiteAid", "txtForgeid", "txtSiteId", "txtForgeAid", "txtShopAid", "txtStoreId", "txtServerAid", "txtStoreid", "txtForgeID", "txtStreetById", "xtShopID"], "txtArtCurrency": ["txtArtConurrency", "txtArticleConurrency", "txtArtColurrency", "txtArtConcurrency", "txtArtCcurrency", "txtArticleCocurrency", "txtArticleCurrencies", "txtArtCoulture", "txtArtCurrencies", "txtArtConulture", "txtArtCategories", "txtArtCourrencies", "txtArticleCcurrency", "txtArticleCurrency", "txtArticleCourrency", "txtArticleCulture", "txtArtConategories", "txtArtCocurrency", "txtArticleCategories", "txtArticleConcurrency", "txtArtColcurrency", "txtArticleCoulture", "txtArtCoategories", "txtArtCourrency", "txtArtColategories", "txtArticleConategories", "txtArticleCourrencies", "txtArtConurrencies", "txtArtCulture"], "txtHashBack": ["txthashback", "txtClearback", "txtClearBack", "txthashBACK", "xtHashBack", "txtClearFront", "texthashBACK", "txtFilterBack", "txtFilterback", "txtRawBack", "xtStockback", "texthashFront", "txtHashFront", "txtHashback", "txthashFront", "xtHashFront", "texthashback", "xtHashback", "txtFilterBACK", "txtStockBack", "txtLockBACK", "txtHelpback", "txtStockFront", "txthashBack", "textHashBACK", "textHashFront", "txtFilterFront", "xtStockBACK", "xtStockBack", "xtHashBACK", "txtRawBACK", "txthashValue", "txtRawValue", "txtLockback", "txtHashBACK", "txtStockBACK", "textHashValue", "txtHelpBACK", "txtClearBACK", "txtHashValue", "txtStockback", "txtHelpFront", "textHashback", "txtRawback", "txtLockBack", "texthashValue", "txtLockFront", "txtHelpBack", "texthashBack", "textHashBack", "xtStockFront"], "hashSeed": ["hoAseed", "hashAsetter", "hashSourceeed", " hashSeeds", " hashSee", "hashSeiper", "hoAsetter", "hashFetter", "hoSep", "hoSeed", "hashSetter", "hashSourceeder", "hoAsep", "hashSourceep", "hashSliper", " hashSeee", "hoAseder", "hashAseder", "hashSeeed", "hashSleeds", "hashFep", "hashFeed", "hashAsep", "hashSiper", "hashSeee", "hashSeeeds", "hashSourceetter", "hashSlee", " hashSiper", "hashAseed", "hoSetter", " hashSeeed", "hashFeder", "hoSeder", " hashSeeeds", "hashSeder", "hashSep", "hashSleed", " hashSeiper", "hashSeeds", "hashSee"], "securityValue": ["secData", "SecurityValues", " securityVal", "securityVal", "SecurityValue", "securityData", "SecurityVal", "securityValues", "secValues", " securityData", "secVal", " securityValues", "secValue", "SecurityData"], "digest": ["dEST", "Digest", "contest", "macested", "dester", "diger", "dest", "Diget", " digested", "Digester", "contested", "contests", "der", " diger", "Diggest", "diggest", "dependested", "equester", "equse", "diget", "digse", "digests", "macest", "dependest", "macgest", " digse", "dse", "equet", "digested", "dependgest", "Digse", " digester", " diget", " digests", " digEST", "digEST", "Diger", "DigEST", "digester", "Digests", "dested", "contse", "macester", "Digested", "equest", "dependester"], "array": ["attribute", "response", "view", "rays", "shape", "ray", "raw", "Array", "string", "our", "now", "arrow", "v", "a", "RAY", "max", "number", "buffer", "archive", " Array", "stage", "record", "ash", "export", "map", "ar", "bar", "av", "batch", "audio", "arr", "vector", "instance", "angular", "object", "range", "ashes", "collection", "binary", "angle", "length", "share", "list", "row", "iq", "pair", "area", "sha"], "sb": ["obs", "erb", "bg", "ib", "sq", "shell", "soc", "bs", "cb", "sbm", "sa", "bh", "abb", "nb", "lb", "gc", "rub", "ssl", "bsp", "bb", "orb", "esm", "sg", "sam", "sv", "lp", "eb", "abs", "bis", "gb", "bf", "bj", "ctrl", "rob", "gob", "sf", "wb", "kb", "pb", "obb", "sn", "bt", "ob", "rb", "SB", "zb", "bps", "ls", "stab"], "j": ["ix", "msg", "obj", "key", "jump", "uj", "x", "jl", "ji", "it", "g", "v", "ja", "job", "yy", "json", "jo", "jc", "ody", "i", "k", "oj", "from", "kj", "q", "_", "J", "el", "jet", "bj", "br", "ij", "aj", "dj", "jp", "jit", "gr", "jj", "js", "z", "att", "bot", "n", "ind", "state"], "b": ["bi", "bg", "ib", "bc", "bs", "cb", "mb", "v", "B", "ab", "nb", "bd", "h", "k", "ba", "bb", "bar", "bp", "bit", "beta", "eb", "base", "bu", "bis", "gb", "br", "bf", "binary", "db", "bound", "BB", "bt", "rb", "fb", "be"], "hash": ["url", "cache", "where", "response", "html", "key", "header", "version", "string", "uh", "height", "bh", "message", "sample", "ASH", "title", "json", "value", "h", "ssl", "data", "ash", "hz", "password", "result", "search", "Hash", "ah", "report", "crypt", "format", "sum", "tag", "ashes", "check", "address", "test", "rh", "buster", "total", "block", "flash", "hex", "filter", "href", "oh", "handle", "sha"]}}
{"id1": "19944975", "id2": "18748516", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["WriteConfig", "WriteConfiguration", " writeConfig", "writeConfig", "WriteSettings", "outputConfig", "writeContent", "WriteContent", "outputConfiguration", "outputContent", " writeSettings", "writeSettings", "outputSettings", " writeContent"], "out": ["free", "msg", "up", "group", "ch", "conn", "writer", "p", "Out", "pool", "this", "g", "v", "nt", "w", "aos", "outer", "ent", "cmd", "file", "b", "all", "log", "err", "h", "io", " OUT", "result", "c", "res", "report", "check", "help", "cast", "set", "t", "at", "o", "OU", "cm", "table", "output", "client", "con", "null", "to", "list", "over", "outs", "OUT", "pretty", "print", "n", "ou"], "url": ["mail", "Url", "link", "name", "path", "cert", "domain", "key", "pattern", "char", "ret", "r", "mount", "file", "location", "gl", "ssl", "resource", "bel", "user", "f", "dl", "abs", "base", "uri", "http", "nl", "sl", "rl", "service", "str", "ll", "address", "ref", "loc", "rect", "rel", "l", "client", "URL", "net"], "in": ["inn", "al", "up", "none", "is", "it", "and", "sin", "inner", "isin", "r", "din", "sample", "file", "source", "bin", "i", "io", "serv", "gin", "read", "user", "on", "f", "m", "from", "In", "el", "sum", "body", "st", "str", "ins", "inside", "en", "IN", "l", "con", "ma", "null", " din", "cin", "input", "rin", "mc", "reader", "ind"]}}
{"id1": "8515891", "id2": "9450274", "code1": "    protected String readUrl(String svnUrl) throws IOException {\n        URL url = new URL(svnUrl);\n        URLConnection uc = url.openConnection();\n        if (url.getProtocol().equals(\"https\")) {\n            String userPassword = user + \":\" + password;\n            String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n            uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        InputStream is = null;\n        String in = null;\n        try {\n            is = uc.getInputStream();\n            in = read(is);\n        } finally {\n            try {\n                is.close();\n            } catch (Exception e) {\n            }\n        }\n        return in;\n    }\n", "code2": "    public void seeURLConnection() throws Exception {\n        URL url = new URL(\"http://wantmeet.iptime.org\");\n        URLConnection uc = url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n        String s = null;\n        StringBuffer sb = new StringBuffer();\n        while ((s = br.readLine()) != null) {\n            sb.append(s);\n        }\n        br.close();\n        log.debug(\"sb=[\" + sb.toString() + \"]\");\n    }\n", "label": 0, "substitutes": {"readUrl": ["READURL", "loadUr", "READurl", "readurl", "readUr", "READUr", "getUr", "geturl", "getURL", "loadurl", "READUrl", "readURL", "loadUrl", "loadURL", "getUrl"], "svnUrl": ["svnServer", "svNUrl", "svneServer", "servicensUr", " svnUr", " svNServer", "servicensurl", "servicenurl", "svnUr", "svcURL", "svneStr", "svnsStr", "servicenUr", "svnURL", "svneUr", "svnStr", "svNUr", "svgURL", "servicenUrl", "svcurl", "svgurl", "svNStr", "svnsUrl", "svgUr", "svnsURL", "servicensURL", "svneUrl", "svgUrl", " svNUr", "svcUrl", "svnsUr", " svnStr", "svnsurl", " svnServer", "servicensUrl", "servicenURL", " svNUrl", "svnurl", "svnsServer", " svNStr", "svNServer", "svcUr"], "url": ["mail", "Url", "link", "hl", "html", "pl", "conn", "raw", "org", "char", "r", "mount", "cl", "lb", "location", "gl", "ssl", "host", "build", "uf", "bel", "call", "ld", "base", "dl", "abs", "uri", "github", "http", "nl", "sl", "uu", "str", "impl", "ll", "google", "browser", "ref", "https", "loc", "l", "lr", "URL", "ml", "acl", "ls", "ur", "ul"], "uc": ["conn", "ac", "bc", "soc", "ec", "uh", "ui", "cc", "ul", "tc", "u", "userc", "anc", "cl", "roc", "nic", "ci", "uf", "fc", "lu", "unic", "c", "usc", "unc", "oc", "ux", "ucc", "nc", "eu", "cur", "uci", "cu", "orc", "us", "lc", "dc", "ub", "loc", "sc", "con", "cus", "cr", "ud", "rc", "co", "UC", "auc", "mc", "uu"], "userPassword": ["browserPassword", " userAuth", "UserData", "browserPass", " userData", " userGrant", "userPass", "userAuth", "browserpassword", " userpassword", "userpassword", " userPass", "Userpassword", "userGrant", "managerPass", "UserAuth", "UserGrant", "userData", "managerGrant", "browserData", "UserPass", "UserPassword", "managerPassword", "managerAuth"], "encoding": ["Encoding", "enoding", "ecaling", "encaling", "ecasing", "Encasing", "cryption", "Encoder", "ecoder", "Encaling", "encoder", "enryption", "enasing", "Encryption", "encryption", "enoder", "encasing", "ecoding", "ecryption", "coder", "caling", "coding"], "is": ["tis", "im", "obs", "ri", "ip", "ois", "mi", "iss", "it", "si", "isin", "isa", "sis", "iso", "Is", "ir", "i", "isf", "ys", "ris", "es", "IS", "imp", "\u00eds", "abs", "fs", "bis", "its", "ic", "ios", "ims", "ms", "isl", "ins", "us", "ists", "ism", "ais", "iris", "vis", "os", "s", "isc", "oss", "mis", "ows", "isi", "as", "lis"], "in": ["inn", "inc", "pin", "kin", "ln", "it", "inner", "isin", "v", "r", "din", "e", "file", "lit", "nin", "bin", "i", "k", "read", "gin", "password", "on", "f", "m", "login", "In", "report", "sum", "str", "ins", "text", "t", "en", "out", "IN", "l", "con", "n", "cin", "input", "rin", "print", "vin", "edIn", "oin"]}}
{"id1": "5399593", "id2": "20568568", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"encrypt": ["ecrypt", "decode", "decrypted", "eccode", "enrypted", "deccode", "enrypt", "ecode", "encode", "enccode", "ecrypted", "decrypt", "enode", "encrypted"], "plaintext": ["preword", " Plainth", " plainText", "plaincontext", " plainword", "maintext", " Plaintext", "mainword", "plainText", "preText", " Plainpassword", " Plaininput", " plainth", "ainth", "precontext", " plaincontext", "aininput", "plainword", "plaininput", "plainpassword", "plainth", "ainpassword", "aintext", " plainpassword", "maincontext", " plaininput", "mainText", "pretext"], "UnsupportedEncodingException": ["UnsupportedEncryptionError", "UnsupportedEncodingEx", "UnsupportedEncodedException", "UnsupportedEncodedEx", "UnsupportedEncryptionEx", "UnsupportedCompoderException", "UnsupportedCompodingException", "UnsupportedEncoderEx", "UnsupportedEncryptionException", "UnsupportedCompodingEx", "UnsupportedCompoderError", "UnsupportedCompoderEx", "UnsupportedEncoderException", "UnsupportedEncoderError", "UnsupportedEncodingError", "UnsupportedEncodedError", "UnsupportedCompodingError"], "md": ["sm", " MD", "df", "del", " mm", "mt", "def", "cd", "mb", "MD", " m", " cmd", "add", "dm", "mo", "nt", "mm", "der", "od", "cmd", "grad", "ind", "gm", "bd", "sd", "mod", "ad", " mo", "pd", "ld", "m", "det", "med", " Md", " dd", " mc", "pm", "mp", "ms", "mg", "red", "mn", "d", "nd", "mand", "exec", "dd", "mc", "dr", "mk", " ma", "hd", "sha"], "raw": ["clear", "orig", " RAW", "full", "clean", "sh", "message", "cooked", "known", "pack", "json", "all", "strip", "read", "buf", "aw", "data", "available", " Raw", "unsigned", "custom", "valid", "draw", "mem", "serial", "out", "load", "des", "was", "hook", "n", "core", "row", "input", "empty", "Raw", "hex", "bare", "rendered", "RAW", "bytes"], "hash": ["zh", "name", "ashed", "html", "key", "tr", "ssh", "height", "sh", "bh", "ASH", "message", "unknown", "hat", "mac", "h", "ash", "password", "id", "dump", "result", "hed", "search", "Hash", "sum", "tag", "ashes", "check", "mask", "code", "proof", "component", "total", "shadow", "cloth", "hex", "hidden", "has", "sha"]}}
{"id1": "13595251", "id2": "5414088", "code1": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"descargarArchivo": [" descargarArchiv", " descargoArchiv", " descargoMotive", " descargarMotico", " descargoArchico", " descargarActive", " descargarRivo", " descargarRico", " descargarRiv", " descargoArchivo", " descargarActiv", " descargoArchive", " descargarActivo", " descargoMotiv", " descargoMotivo", " descargarMotivo", " descargarActico", " descargarArchive", " descargarArchico", " descargoMotico", " descargarMotiv", " descargarMotive", " descargarRive"], "fis": [" fios", "dfis", "Fis", "ufiss", "ffos", "fiss", "ufis", "fix", "ufos", "fios", "fiiss", "dfiss", "Fris", "Fiss", "ffiss", "dfos", "fiix", " fris", "fiis", "dfris", "ffios", "ffix", "fris", "fiios", "Fos", " fix", " fiss", "ffris", "ufris", "ffis"], "fos": ["fOS", " foes", "flbos", "lfoses", "fbos", " foss", "voes", "woses", "foes", "waos", "woss", " fOs", "infos", "fedOs", " fows", "infbos", "lfbos", "faos", "fOs", "foses", "flos", "wos", "foss", "lfos", "fedbos", "flaos", "wows", " fOS", "fows", "woes", "lfaos", "wbos", "infOS", "floses", "voss", "infOs", "vos", " fbos", "fedOS", "vows", "fedos"], "inChannel": ["initGray", "Inchannel", "innerChannel", "inGray", "initChannel", "innchannel", "initConnection", "aiChan", "initChan", "aiChannel", "innerchannel", "InButton", "InChannel", "outRow", "aichannel", "innerChan", "outchannel", "inputChan", "outChan", "inputChannel", "InConnection", "inchannel", "innerButton", "inConnection", "innChannel", "InGray", "inputConnection", " inChan", "innRow", "innChan", "aiRow", " inButton", "inRow", "InChan", "inChan", "inputGray", "inButton", " inchannel"], "outChannel": ["outConsole", " outChan", "outStream", "OUTchannel", "outButton", "OUTChannel", "outchannel", " outchannel", "outChan", "inStream", "inchannel", "OUTChan", "inConsole", " outButton", "OUTConsole", "OUTStream", " outConsole", "OUTButton", " outStream", "inChan", "inButton"]}}
{"id1": "9272325", "id2": "20100809", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"sendPost": ["doPOST", "executeRequest", "httpGet", "doGet", "httpPOST", "doRequest", "doPost", "sendGet", "executePost", "executePOST", "executeGet", "httpPost", "sendPOST", "httpRequest", "sendRequest"], "reqUrl": ["requestUrl", "resStr", "requName", "reqPath", "requestPath", "requUrl", " reqPath", " reqStr", "resUrl", "requLink", "reqLink", "seqURL", "reqName", "reqStr", "seqUrl", "seqName", " reqURL", "seqLink", " reqName", "resURL", "requestURL", "resPath", " reqLink", "requURL", "reqURL", "requestStr"], "parameters": ["parmes", "promams", "publiceter", "promuments", "promations", "paruments", "equeters", "arameters", "equams", "aramuments", "paramuments", "equations", "paramams", "arammes", "publicams", "prometers", "parameter", "arameter", "parammes", "prometer", "pareter", "prommes", "publications", "publiceters", "pareters", "paramations", "equeter"], "urlConn": ["relConnection", "mountConnector", "utilConnection", "urlCo", "mountCtrl", " urlConnect", " urlConnector", "rowCo", "objCo", "retConn", "webConnect", "resourceLink", "objConn", "relCo", "resourceConn", "mountConn", "belConn", "retConnect", "urlConnector", "mountCo", "fileconn", "relConn", "urlCon", "fileConn", "urlConnection", " urlCon", "implDesc", " urlCtrl", "mountconn", "URLconn", "utilConnector", "nlConnect", "sslCond", "sslDesc", "urlConnect", "belDesc", "leftConn", "implCond", "sslCon", "mountWr", "sslCo", "nlConnector", "URLConnect", "implConn", "leftConnect", "objCtrl", "URLConn", "webConn", "httpConnection", "nlConn", "belCond", "URLCon", "urlLink", "httpConnect", "rowConn", "fileConnection", "sslConnector", "utilConn", "urlDesc", "httpConn", "urlCtrl", "rowConnection", " urlCo", "relconn", "sslConnect", "nlConnection", "leftconn", "implConnection", "fileCon", "utilConnect", "leftCon", "belConnection", "resourceWr", "resourceconn", "retconn", " urlWr", "relConnector", "sslConnection", "sslconn", "urlWr", "mountLink", "urlconn", "rowconn", "httpConnector", " urlConnection", " urlconn", "urlCond", "objconn", "sslConn", "webconn", " urlLink"], "params": ["units", "p", "string", "posts", "rs", "ps", "v", "json", "Parameters", "values", "config", "AMS", "points", "param", "keys", "tags", "results", "data", "padding", "pps", "password", "files", "phys", "m", "base", "services", "pins", "conf", "prefix", "changes", "types", "terms", "s", "ams", "options", "names", "bytes", "properties"], "url": ["Url", "name", "hl", "loader", "r", "sb", "mount", "lb", "location", "log", "ssl", "build", "bel", "f", "dl", "il", "abs", "uri", "base", "web", "http", "nl", "sl", "el", "uu", "rl", "str", "ll", "t", "out", "au", "https", "loc", "pkg", "l", "get", "URL", "self", "ls", "ur", "ul"], "b": ["bits", "obj", "p", "bc", "it", "bs", "cb", "mb", "v", "a", "B", "r", "w", "sb", "nb", "u", "buffer", "bin", "i", "buf", "bb", "orb", "bp", "bit", "f", "eb", "base", "m", "batch", "bis", "bf", "gb", "br", "buff", "binary", "d", "db", "l", "ob", "block", "n", "rb", "s", "z", "fb", "be", "bytes"]}}
{"id1": "3514286", "id2": "6159896", "code1": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "code2": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"getHashedPassword": ["getHashPassword", "getShashedpassword", "getHackedSecret", "getHashesSecret", "getHackedPassword", "getHashedSecret", "getHashesUser", "getHashedpassword", "getShashedUser", "getHashesPassword", "getHashSecret", "getShashedSecret", "getHashedUser", "getHackedUser", "getShashUser", "getHashUser", "getHashpassword", "getShashPassword", "getShashpassword", "getShashSecret", "getHackedpassword", "getShashedPassword", "getHashespassword"], "password": ["attribute", "name", "key", "REDACTED", "string", "pattern", "wd", "description", "wordpress", "message", "database", "value", "Password", "email", "data", "padding", "default", "user", "login", "sword", "command", "prefix", "hash", "text", "address", "phrase", "word", "shadow", "input", "reset", "pass", "token", "username", "secret", "raw"], "digest": [" Digest", "Digest", "hashester", "dest", " digested", "Digester", " Digse", "hashested", "hashse", "mdest", "hashest", "dests", "digse", "mdester", "digests", " digse", "digested", "Digse", " digester", " digests", " Digester", "digester", "Digests", "dested", "Digested", "mdse", "mdests", "hashests"], "hashedInt": ["hashashingInteger", "hashInt", "hushedInteger", "hcheckedINT", "hashashingINT", "hashashedInt", "hashashedInteger", " hashedInteger", "hashInteger", "hashINT", "hashingINT", "hhedInteger", "hhedInt", "hushedId", "hashashedINT", "hcheckedInteger", " hashedTx", "happedId", "hhedTx", " hushedTx", " hashedId", "hashedINT", "happedInteger", " hushedId", "happedInt", "hhedId", "hashedInteger", " hushedInt", "hashingInt", "hcheckedInt", "hashingInteger", "happedTx", "hashashingInt", "hushedInt", "hashedId", " hushedInteger", "hashedTx", "hushedTx"]}}
{"id1": "884867", "id2": "494226", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"zipname": [" zipbase", "gzname", "gzsize", "zebase", "zipName", "zname", "archivename", "znamed", "downloadnamed", "gznamed", " zipsize", "downloadName", "ziproot", " zipName", "gzroot", "tarroot", "zipsize", "tarsize", "polyname", "downloadname", "downloadfilename", "zipbase", "zeName", "zName", "archiveName", "tarnamed", " zipnamed", "zfilename", "polyName", " ziproot", "polynamed", "zeout", "zipnamed", "zename", "archivebase", "polyfilename", "zipfilename", "archiveout", "tarname"], "zipout": ["zion", "zipoutput", "zin", "gzgen", "zipclient", " zipion", "zname", "gzout", " zipclient", " zipgen", "gzion", "zipobj", "Zipn", "zipOut", "zipin", "zipall", "zipgen", "zOut", "zobj", "Zipin", "Zipclient", "sendout", " zipall", "zgen", " zipobj", "sendclient", " zipOut", " zipoutput", "zall", "sendname", "zout", "gzin", "sendn", "zipn", "Zipname", "sendoutput", "gzall", "zipion", "sendin", "Zipoutput", "gzobj", " zipin", "gzOut", "Zipout", "zn"], "out": ["obj", "conn", "ac", "p", " Out", "Out", "ex", "cmd", "io", "one", "res", "conf", "set", "str", " manager", "list", " outs", "name", "auto", "msg", "writer", "inv", "opt", " say", "on", " output", "cfg", "at", "by", "con", "os", "oss", "screen", "OUT", "outs", "net", "inf", "cn", "up", "ln", " bout", "g", "nt", "w", "ent", "all", "cos", "gt", " OUT", "gen", "ins", "o", " sys", "output", "dt", "null", "co", "print", "desc", "can", "ou", " fmt", "group", "ch", "go", "init", "gov", "inner", "aos", "log", "sys", " abort", "t", "en", "client", "to", "pretty", "n"], "buffer": ["attribute", "sequence", "cache", "message", "memory", "stack", "database", "temp", "variable", "pad", "buf", "Buffer", "append", "template", "bar", "library", "available", "button", "queue", "batch", "comment", "page", "command", "frame", "mem", "buff", "binary", "history", "phrase", "paste", "table", "output", "line", "iter", "block", "total", "tree", "row", "document", "filter", "window"], "in": ["inn", "im", "bi", "inc", "up", "init", "ac", "is", "it", "per", "and", "inner", "isin", "ex", "ini", "din", "info", "mm", "query", "like", "nin", "bin", "i", "read", "gin", "on", "from", "In", "form", "or", "ic", "check", "ins", "en", "IN", "by", "get", "con", "ma", "iter", "ai", "cin", "rin", "input", "pi", "mc", "reader", "inf", "oin", "ind"], "length": ["volume", "character", "sequence", "language", "len", "amount", "shape", "version", "string", "full", "height", "present", "phi", "display", "capacity", "reading", "message", "distance", "integer", "shift", "database", "value", "number", "hello", "point", "maximum", "read", "join", "ENGTH", "match", "padding", "library", "available", "tail", "ength", "type", "space", "needed", "vector", "depth", "bow", "frequency", "code", "collection", "impl", "class", "load", "no", "loc", "angle", "duration", "history", "total", "component", "family", "position", "count", "size", "print", "Length"]}}
{"id1": "8132219", "id2": "10385815", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" Copyfile", " copyStream", " CopyFiles", "CopyFile", "copyStream", "CopyStream", "CopyFiles", " CopyFile", " CopyStream", "copyFiles", "Copyfile", " copyFiles", " copyfile", "copyfile"], "inFile": [" inPath", "innEmail", "outFilename", "inEmail", "ninName", "ninFilename", "dinFile", " inRow", "dinRow", "inputTemplate", "inName", "innPath", "inFilename", "inputName", "inTemplate", "inputFilename", "dinPath", "ninTemplate", " inEmail", "inPath", "outName", "outTemplate", "innRow", "inputFile", "inRow", "dinEmail", "innFile", "ninFile"], "outFile": ["ouFILE", " outFILE", "outFilename", "outFormat", "outputFile", "outfile", "outputfile", "inFilename", "outputFilename", "outputFormat", "destFormat", "ouFile", "destfile", "destFILE", " outFormat", "destFile", "ouFilename", "inTable", "outputTable", "outTable", "outFILE", " outfile", "inFILE", "outputFILE", "ouTable"], "in": ["inn", "inc", "up", "init", "is", "it", "ain", "sin", "inner", "isin", "old", "ini", "din", "info", "irm", "source", "ze", "ir", "bin", "i", "gin", "on", "id", "from", "In", "el", "ic", "ins", " input", "en", "IN", "o", "ai", "s", " din", "cin", "rin", "input", "inf", "ind"], "out": ["name", "p", "it", "Out", "g", "ex", "v", "w", "aos", "e", "file", "b", "all", "io", "one", "gt", "c", "res", "ot", "t", "en", "at", "o", "ne", "by", "output", "client", "os", "to", "co", "outs", "OUT", "net", "can", "n", "ou"], "inChannel": ["isinSlot", "innerChannel", "insideHandler", "isinCategory", "newPanel", "outStream", " inConnection", "innerchannel", "cinHandler", "cinComponent", "cinButton", "sinStream", "ginCategory", "innCase", "inBlock", "newCase", "innCategory", "inColumn", "insideComponent", "insideChannel", "vinChannel", "newChannel", "sinBlock", "outBlock", "vinPanel", "ginChannel", "vinCase", "isinCase", "innerChan", "insideButton", "innerConnection", "inSlot", "outchannel", "inStream", "outChan", "inCase", "sinSlot", "isinChannel", "inchannel", "sinCase", " inComponent", "inCategory", "cinChannel", "inConnection", " inHandler", "sinColumn", "innSlot", "outColumn", "sinChannel", "ginPanel", "innChannel", "cinStream", "vinCategory", " inChan", "inComponent", "outConnection", " inButton", "newCategory", "inHandler", "inPanel", "ginCase", "sinCategory", "inChan", "inButton", " inchannel", "cinBlock", "cinColumn"], "outChannel": ["inPassword", " outChan", "outCh", "oClient", "outStream", "oChannel", "OutChan", "OutChannel", "outClient", " outCh", " outClient", " outConnection", "exBlock", "outputChan", "outputCh", "oChan", "outBlock", "nStream", "inClient", "outPassword", "outputChannel", "outchannel", " outchannel", "outChan", "inStream", "OutCh", "inchannel", "outputConnection", "exChan", "outChain", "exChain", "nchannel", "OutConnection", "outConnection", "nChan", "oPassword", "exChannel", " outStream", "inChan", "nChannel", " outChain", " outPassword", " outBlock"]}}
{"id1": "20247400", "id2": "10795866", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"in": ["inn", "inc", "up", "init", "is", "it", "and", "inner", "isin", "din", "info", "file", "ze", "source", "bin", "i", "io", "gin", "on", "from", "In", "check", "ins", "IN", "con", "ai", " din", "input", "rin", "cin", "net", "inf", "ind"], "out": ["name", "auto", "msg", "obj", "println", "ln", "other", "writer", "it", "Out", "ex", "r", "w", "outer", "cmd", "b", "log", "err", "sys", "io", "gt", "exit", "report", "we", "ot", "or", "check", "str", "ins", "t", "at", "o", "ne", "OU", "write", "output", "client", "line", "dir", "null", "os", "to", "oss", "con", "list", "screen", "OUT", "outs", "net", "print", "n", "ou"], "buffer": ["attribute", "sequence", "clear", "cache", "view", "key", "shape", "header", "display", "document", "message", "memory", "se", "sample", "stack", "flush", "database", "temp", "event", "b", "source", "bridge", "variable", "limit", "buf", "Buffer", "function", "append", "data", "template", "bar", "match", "channel", "available", "library", "processor", "result", "queue", "batch", "comment", "trace", "command", "pause", "buff", "binary", "history", "address", "phrase", "db", "table", "output", "length", "total", "iter", "position", "block", "component", "size", "filter", "window", "index"]}}
{"id1": "2017833", "id2": "2807585", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"hash": ["string", "replace", "message", "hello", "update", " fingerprint", "read", "parse", "dump", "Hash", " hashing", "sum", "tag", "check", "str", "code", "test", "write", "to", "render", "transform", "print", "sign", "hex", "sha", " digest", "format"], "text": ["name", "url", "msg", "TEXT", "path", "string", "select", "now", "tx", "act", "pattern", "v", "message", "nt", "content", "title", "value", "event", "config", "source", "buffer", "log", "read", "data", "translation", "password", "ext", "txt", "comment", "cont", "q", "command", "aut", "form", "body", "prefix", "str", "t", "code", "out", "test", "output", "word", "pt", "input", "print", "document", "ct", "Text", "format"], "UnsupportedEncodingException": ["UnsupportedEncryptionError", "UnsupportedDecoderError", "UnsupportedDecoderFailure", "UnsupportedEncensionFailure", "UnsupportedEncoderFailure", "UnsupportedEncensionError", "UnsupportedEncryptionFailure", "UnsupportedDecodingError", "UnsupportedDecodingFailure", "UnsupportedEncryptionException", "UnsupportedEncensionException", "UnsupportedDecoderException", "UnsupportedEncoderException", "UnsupportedEncoderError", "UnsupportedEncodingError", "UnsupportedEncodingFailure", "UnsupportedDecodingException"], "md": ["sm", "amd", "and", "mt", "cd", "mb", "MD", "add", "dm", "dh", "mm", "der", "od", "cmd", "grad", "hd", "ind", "bd", "h", "sd", "mod", "ad", "di", "ld", "m", "det", "pdf", " Md", "pm", "rm", "mg", "red", "ms", "mn", "d", "dir", "mand", "dd", "mc", "dr", "ct", "mk", "df", "pd", "sha"], "sha1hash": ["sha5hex", "sha512h", "sha512dig", "haoneHash", "ha1sum", "sha512hash", "sha2hex", "sha2key", "sha2Hash", "shaonehex", "sha1h", "sha2sum", "sha1dig", "shaonehash", "sha1sum", "ha3sum", "sha2hash", "sha3Hash", "sha11hash", "shaonesum", "ha2Hash", "ha1h", "sha5hash", "ha1hex", "ha1dig", "ha3Hash", "sha11dig", "ha1key", "sha5sum", "haonesum", "ha3key", "shaoneHash", "ha2h", "sha512Hash", "sha1hex", "sha1Hash", "sha2h", "haonehash", "sha2dig", "sha1key", "sha5key", "sha3sum", "ha2dig", "sha3hash", "ha1Hash", "sha11Hash", "sha3key", "ha3hash", "ha2hash", "sha11h", "ha1hash", "haonehex", "sha5Hash"]}}
{"id1": "15018553", "id2": "536614", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"encrypt": ["unccrypt", "enccrypt", "Encode", " encode", " encrypted", " enccrypt", "uncrypted", "encode", "Enccrypt", "Encrypted", "uncrypt", "Encrypt", "uncode", "encrypted"], "text": ["name", "url", "msg", "TEXT", "path", "p", "string", "tx", "x", "now", "act", "select", "pattern", "v", "message", "nt", "content", "w", "title", "ut", "value", "source", "buffer", "read", "data", "translation", "password", "ext", "txt", "comment", "cont", "q", "form", "body", "str", "t", "code", "test", "phrase", "output", "word", "pt", "input", "th", "print", "document", "ct", "Text"], "md": ["msg", "metadata", "dig", "del", "cmp", "and", "cd", "mb", "MD", " cmd", "dm", "dh", "mo", "mm", "der", "od", "cmd", "grad", "ind", "mac", "mond", "bd", "de", "err", "h", "mod", "ad", "di", "pd", "ld", "m", "c", "det", "mode", " dd", " cd", "pm", "mp", "rm", "hash", "ms", "mg", "t", "mem", "img", "mn", "d", "pkg", "doc", "nd", "mand", "dd", "mc", "mt", "ct", "mk", "df", "hd", "sha"], "md5hash": ["md2hash", "md3hex", "md5cloth", "md512sum", "md5hex", " md2hex", " md5hex", "md3sha", "md2h", " md3sum", " md3hash", "md3sum", "md3cloth", "md2hex", "md512sha", " md3h", " md5Hash", " md5sha", "md5Hash", "md512Hash", "md2Hash", "md3h", " md2cloth", " md2sum", "md2cloth", " md3sha", " md5cloth", "md512hash", " md3Hash", "md2sum", "md5h", " md5sum", "md3hash", "md2sha", "md5sha", "md3Hash", " md5h", " md2hash", "md5sum", "md512h"]}}
{"id1": "9413074", "id2": "932225", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 0, "substitutes": {"getLocation": ["newLocation", " getlocation", "loadLocation", "getURL", "getURI", " getURL", "GetLoc", "newlocation", "loadURL", "getDescription", "getLoc", "GetDescription", "newLoc", " getLoc", "Getlocation", "GetURI", "loadURI", "GetLocation", "newDescription", " getDescription", " getURI", "loadDescription", "GetURL", "getlocation"], "clazz": ["ClClass", "scamp", "klClass", "scaz", "claz", "klaz", " claz", "Clazz", " clos", "CLazz", "klclass", "Clamp", "CLclass", "Claz", "clclass", "klazz", "CLaz", " clamp", "clClass", "Clos", "scazz", "clos", "scos", "clamp", "CLClass", "Clclass"], "url": ["remote", "Url", "link", "util", "mail", "hl", "conn", "path", "cert", "string", "handle", "socket", "org", "char", "ret", "this", "xml", "loader", "r", "u", "sb", "run", "mount", "log", "err", "gl", "buffer", "ssl", "resource", "host", "build", "channel", "user", "result", "f", "dl", "base", "abs", "uri", "web", "nl", "http", "q", "sl", "sql", "rl", "impl", "str", "ll", "browser", "address", "ref", "https", "loc", "rel", "l", "client", "get", "ob", "lr", "row", "URL", "ml", "ls", "ur", "ul", "addr"], "location": ["name", "where", "origin", "path", "none", "Location", "string", "display", "description", "scope", "availability", "message", "usage", "title", "expression", "ocation", "value", "update", "filename", "layout", "ion", "slot", "resource", "resolution", "function", "local", "reference", "behavior", "padding", "translation", "library", "media", "result", "selection", "application", "comment", "displayText", "type", "nl", "command", "trace", "peer", "region", "color", "feature", "range", "language", "summary", "direction", "address", "history", "loc", "relation", "l", "length", "family", "position", "row", "operation", "document", "directory", "area"], "file": ["ile", "port", "name", "fp", "path", "parent", "le", "File", "image", "full", "face", "entity", "run", "folder", "filename", "resource", "io", "channel", "FILE", "checked", "library", "user", "files", "f", "page", "object", "out", "binary", "angle", "ref", "db", "table", "output", "module", "dir", "block", "ca", "ory", " File", "pe", "format"]}}
{"id1": "17296916", "id2": "7425022", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"logging": ["debugStorage", "debugger", "debuging", " logger", "logStorage", " logStorage", " loging", "Logging", "loging", "logger", "LogStorage", "debugging", "Loging", "Logger"], "wrap": ["zip", "link", "xf", "wa", "W", "shape", "ws", "x", "find", "message", "nw", "add", "wra", "w", "window", "ow", "pack", "safe", "grow", " wrapped", "start", "pad", "read", "me", "build", "wx", "inter", "aw", "parse", "ad", "box", "root", " wrapper", "wire", "sw", "force", "web", "we", "rap", "form", "ew", "store", "python", "chain", "gate", "create", "wind", "work", "get", "word", "reset", "transform", "sp", "wrapper", "use", "handle", "format"], "buffer": ["attribute", "sequence", "cache", "view", "header", "writer", "display", "document", "message", "memory", "wrapper", "database", "face", "flag", "layer", "surface", "bridge", "builder", "buf", "Buffer", "bb", "append", "profile", "template", "bar", "reference", "library", "button", "queue", "batch", "note", "base", "complete", "report", "command", "trace", "quote", "body", "frame", "store", "console", "buff", "binary", "bo", "phrase", "pb", "table", "output", "line", "iter", "ob", "block", "position", "word", "row", "screen", "reset", "size", "flash", "reply", "print", "directory", "window"], "encoding": ["enclanguage", "enumging", "Encoding", "enaling", "cododer", "ecoded", "enoding", "enoded", "encaling", "enumoder", "enumlanguage", "cryption", "Encoder", "ecoder", "encoded", "enging", "Encaling", "encoder", "enryption", "enoder", "encryption", "Encryption", "enlanguage", "cododing", "codryption", "ecoding", "cododed", "ecryption", "coder", "caling", "clanguage", "enumoding", "encging", "cging", "coding"], "getEncoding": ["getOrigination", "getEncryption", "getOrigoding", "getExpryption", "getEncression", " getEncryption", "getEncination", "getEnryption", "getEnging", " getEncling", "getencling", "getencryption", "getEncging", "getExpression", " getEnoding", " getEncging", "getEnoding", "getencging", " getEnging", "getExpging", " getEnryption", "getOrigling", "getencoding", "getEnling", " getEnression", "getencression", " getEncression", "getEnination", " getEncination", "getEncling", " getEnling", "getOrigryption", "getExpoding", " getEnination", "getEnression", "getencination"], "headers": ["writers", "groups", "fields", "header", "head", "pres", "frames", "ports", "rs", "drivers", "members", "ers", "heads", "users", "values", "params", "reports", "blocks", "comments", "relations", "caps", "keys", "tags", "holders", "authors", "ters", "builders", "pins", "modules", "ids", "ilers", "ppers", "objects", "boxes", "weights", "ctors", "styles", "terms", "chains", "codes", "checks", "limits", "images", "names", "properties"], "is": ["tis", "obs", "ip", "ois", "does", "ri", "iss", "bs", "ui", "si", "isin", "as", "isa", "dis", "sis", "isd", "iso", "sys", "isf", "i", "Is", "ys", "ris", "IS", "\u00eds", "fs", "osi", "bis", "its", "or", "ic", "in", "ios", "isl", "ms", "ims", "ins", "has", "us", "ists", "ais", "iris", "was", "os", "isc", "mis", "isi", "ist", "nis", "lis"], "bos": ["tis", "bits", "bi", "obs", "cs", "ols", "soc", "ts", "bs", "ods", "banks", "ui", "tes", "uts", "ps", "bh", "stats", "boards", "aos", "oops", "cos", "bin", "ys", "sys", "ones", "uds", "ses", "fits", "fs", "oids", "pod", "bis", "bas", "tops", "ios", "bones", "ubis", "ms", "nos", "bo", "bes", "lets", "des", "los", "dos", "os", "eros", "jas", "oss", "js", "windows", "ows", "isi", "ots", "bot", "bytes", "oos"], "e": ["le", "p", "x", "E", "g", "ex", "v", "se", "r", "a", "oe", "ee", "de", "ate", "err", "i", "h", "me", "es", "error", "f", "m", "c", "ge", "t", "en", "er", "eeee", "o", "d", "ne", "exc", "re", "ae", "ie", "ev", "ed", "n"]}}
{"id1": "11556231", "id2": "1798720", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "label": 0, "substitutes": {"ByURL": ["createURL", "createUrl", "byUrl", "createString", "ByString", " byUrl", "byString", "ByUrl", " byHTTP", "createHTTP", " byURL", "byURL", "byHTTP", " byString", "ByHTTP"], "urlstr": ["urlStr", "urlobj", "uriStr", "UrlSTR", "lobj", "urlSTR", "uristring", "uristr", "ulStr", "ulstr", "Urlobj", "ulstring", "lStr", "uriobj", "UrlStr", "lstr", "urlstring", "Urlstring", "lstring", "Urlstr", "lSTR", "ulSTR"], "uri": ["link", "Url", "html", "origin", "ri", "path", "init", "string", "system", "phi", "ui", "description", "URI", "subject", "href", "u", "database", "doi", "file", "query", "uid", "filename", "i", "resource", "io", "context", "reference", "id", "http", "q", "du", "prefix", "range", "address", "https", "iri", "term", "URL", "pi", "ur", "directory", " URI", "uu"], "url": ["mail", "Url", "link", "hub", "conn", "socket", "char", "r", "job", "sb", "mount", "file", "location", "ssl", "resource", "parser", "host", "build", "parse", "f", "base", "http", "nl", "sl", "str", "impl", "ll", "browser", "address", "loc", "l", "open", "client", "URL", "ls", "ur", "ul", "li"], "connection": ["established", "Connection", "link", "response", "conn", "socket", "connected", "connect", "database", "number", "opening", "network", "ion", "i", "session", "resource", "io", "context", "channel", "application", "c", "handler", "engine", "http", "command", "directory", "service", "console", "condition", "relation", "client", "open", "con", "position", "using"], "in": ["inn", "mat", "sin", "inner", "stream", "isin", "r", "din", "info", "mm", "file", "bin", "i", "id", "f", "from", "In", "body", "ins", "en", "out", "us", "IN", "l", "client", "get", "ma", " din", "input", "cin", "rin", "mc", "inf", "ind"], "reader": ["iterator", "ri", "writer", "reading", "inner", "stream", "loader", "ator", "r", "rx", "buffer", "resource", "read", "parser", "io", "rar", "builder", "context", "handler", "ner", "body", "Reader", "er", "ro", "iter", "row", "input", "runner", "dr", "handle"], "is": ["im", "are", "ri", "iss", "rs", "isin", "as", "se", "info", "isa", "sis", "Is", "sys", "i", "ris", "serv", "es", "IS", "sam", "fs", "res", "bis", "its", "ios", "ms", "ins", "has", "ais", "iris", "ism", "os", "s", "isc", "mis", "input", "isi", "sim", "nis", "lis"], "document": ["response", "xml", "message", "content", "node", "file", "context", "dom", "information", " Document", "template", "record", "library", "ocument", "application", "result", "media", "Document", "m", "page", "object", "collection", "element", "doc", "output", "tree"], "source": ["Source", "select", "dest", "ource", "src", "se", "content", "node", "event", "number", "location", "resource", "context", "result", "handler", " src", "site", "instance", "or", "object", "set", "element", "out", "sn", "tree", "input", "SOURCE"], "name": ["attribute", "path", "key", "NAME", "version", "string", "attr", "description", "title", "value", "label", "file", "node", "named", "event", "variable", "location", "param", "property", "default", "id", "comment", "type", "tag", "prefix", "object", "Name", "code", "class", "names", "format"], "namespaceURI": ["namespaceIX", "namesificationUID", "namesplaceuri", "nspaceURL", "worksystemuri", "namesetURL", "namesaceURI", "namesacementIX", "resourcesacementIX", "worksystemRI", "workspaceRI", "workspaceUID", "namesystemuri", "namesaceUI", "namesaceIX", "namespaceuri", "workspaceURI", "nameseturi", "nsplaceURI", "resourcespaceURI", "namesacementUI", "namesystemURI", "namesenterUID", "namesplaceURI", "nsplaceID", "nspaceuri", "namesenterURI", "namespaceUI", "namesenterRI", "namesystemRI", "nsplaceuri", "namesplaceID", "resourcesacementURI", "resourcespaceIX", "namesetID", "namespaceRI", "resourcespaceUI", "namespaceURL", "worksystemUID", "namesetURI", "resourcesacementUI", "workspaceuri", "namesystemUID", "nspaceID", "nsplaceURL", "namesificationURI", "namespaceUID", "worksystemURI", "nspaceURI", "namesplaceURL", "namesificationRI", "namespaceID", "namesacementURI", "namesificationuri", "namesenteruri"], "qualifiedName": ["localType", "friendlyType", "fullName", "fullValue", "friendlyName", "fullNames", "commonNames", "friendlyname", "localValue", "relativeName", "fullname", "relativeValue", "qualifiedNames", "commonName", "localNames", "qualifiedname", "qualifiedValue", "commonname", "relativeNames", "localname", "relativename", "friendlyNames", "qualifiedType", "commonType"], "data": ["response", "key", "version", "string", "action", "ata", "pattern", "image", "def", "xml", "description", "message", "info", "content", "expression", "value", "event", "buffer", "resource", "dat", "password", "error", "media", "result", "comment", "type", "mode", "command", "body", "object", "str", "text", "element", "address", "definition", "output", "DATA", "input", "format"], "tagName": ["qualifiedData", "TagValue", "Tagname", "tagValue", "qualifiedname", "tagData", "localData", "localValue", "TagName", "qualifiedValue", "TagData", "localname"], "target": ["link", "ip", "path", "action", "owner", "src", "subject", "content", "title", "Target", "node", "location", "alias", "context", "property", "error", "result", "handler", "role", "command", "instance", "object", "prefix", "language", "class", "ref", "binding", "format"], "elementId": ["objectID", "documentIndex", "documentId", "elementID", "elementid", "documentid", "nodeID", "documentID", "objectId", "objectid", "nodeIndex", "elementIndex", "nodeId", "objectIndex", "nodeid"], "tagname": ["localnum", "Tagname", "shortnum", "shortName", "tagnum", "Tagnum", "tagid", "Tagid", "shortname", "shortid", "localid", "TagName", "localname"], "localName": ["fixedname", "supportedNames", "localNAME", "componentNAME", "componentNames", "fixedNames", "componentname", "componentName", "supportedname", "supportedNAME", "fixedNAME", "localNames", "fixedName", "supportedName", "localname"]}}
{"id1": "21642215", "id2": "11645260", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"addIDs": ["processID", "setIDs", " addIDS", "processIDs", " addNames", " addID", "setID", "setNames", "addNames", "addIDS", "processNames", "addID", "processIDS", "setIDS"], "row": ["group", "tr", "board", "r", "job", "entry", "ow", "ack", "week", "node", "buffer", "rank", "channel", "rown", "record", "user", "box", "error", "ry", "result", "batch", "report", "Row", "rows", "cell", "instance", "post", "item", "out", "ro", "table", "roll", "block", "list", "skip", "ows", "star", "pair", "col", "raw"], "name": ["path", "NAME", "key", "version", "string", "image", "description", "a", "title", "value", "label", "file", "query", "named", "source", "filename", "question", "template", "password", "type", "search", "prefix", "Name", "text", "item", "address", "create", "ame", "word", "n", "format"], "in": ["inn", "scan", "inc", "al", "up", "pin", "conn", "ln", "init", "is", "it", "ain", "inner", "xml", "isin", "ex", "ini", "r", "din", "copy", "file", "source", "update", "log", "bin", "i", "nin", "ssl", "serv", "gin", "local", "win", "on", "m", "il", "again", "In", "el", "conf", "form", "sql", "ic", "check", "ins", "t", "en", "out", "er", "IN", "at", "l", "db", "get", "con", "n", "s", "cin", "input", "rin", "re", " IN", "mc", "reader", "vin", "inf"], "urlName": ["lName", " urlPath", "lPath", "UrlKey", "urlNames", "UrlNames", "implPath", "logKey", "urlKey", "urlname", "urlPath", " urlNAME", "logname", "logName", " urlNames", "implNAME", "lKey", "implname", "urlNAME", "logNAME", "lNames", "UrlName", "lNAME", "implNames", "lname", "implName", " urlname", "UrlNAME", "Urlname"], "url": ["Url", "link", "char", "ret", "loader", "r", "cl", "mount", "file", "b", "gl", "ssl", "resource", "channel", "result", "base", "il", "uri", "web", "http", "nl", "sl", "el", "rl", "str", "ll", "browser", "t", "ref", "rel", "l", "open", "client", "con", "URL", " URL", "ls", "ur", "reader", "ul"], "inputLine": [" Inputline", "latLINE", "sourceLine", "listLine", "dataFrame", "keyL", "InputLINE", "submitLINE", "formLINE", "dataBlock", " inputLINE", "tableLINE", "viewLine", "intBlock", "latLine", "helloLINE", "inputNode", "keyline", "listLINE", "statusLINE", "commandLine", "contextRow", "singleLINE", "InputL", "tablePort", "statusFile", "tempLine", "listPort", " InputLin", "viewLINE", "operationNet", "inputPage", "intLINE", " inputEntry", "intLin", " inputNet", "helloPort", " inputLin", "tempLINE", " inputRecord", "formLine", " inputNode", "Inputline", "inputLink", "intLine", "commandLINE", "singleBlock", "contextLine", "commandBlock", "cacheLine", "dataLink", "firstLine", "latline", "submitBlock", "inputEntry", " InputLINE", "inLINE", "inLine", "InputLine", "submitDe", "inputBlock", "inline", "singleDe", "operationLine", "sourcePage", "sourceNode", "InputBlock", "inputDe", " inputDe", "InputFile", "keyLine", "firstLINE", "keyLINE", "singleLine", "dataPort", "sourceLINE", " InputLine", "inputL", "contextLINE", "inputRow", "submitLine", "patternLine", "dataLINE", "viewRow", " inputPort", "cacheNode", "inputNet", "inputLin", "inputline", "InputRow", "patternLINE", "operationLINE", "cacheLINE", "helloEntry", " inputFrame", "statusLine", "dataLine", " inputline", "statusline", "firstBlock", "patternline", "formBlock", "inL", "tableLink", "inputPort", " inputFile", "dataNet", "latRecord", " inputLink", "patternRow", "templine", "formFrame", "cachePage", " inputBlock", "helloLine", " inputRow", "inputLINE", " inputPage", "dataline", "inputRecord", "dataFile", "listEntry", "inRecord", "inputFrame", "inputFile", "intline", "tableLine"], "score": ["scan", "confidence", "display", " Score", "price", "message", "distance", "value", "success", "strength", "source", "goal", "err", "rank", "match", "scroll", "error", "rate", "scoring", "result", "search", "average", "report", "sum", "scale", "status", "set", "loss", "draw", "check", "depth", " scores", "Score", "test", "weight", "length", "grade", "sc", "count", "core", "level", "style", "index"], "metaboliteID": ["metaboliceInfo", "metabolitateID", "metabolicITEName", "metaboliceid", "metaboliceID", "metaboliciteName", "metaboliteId", "metabolisticId", "metabolitableID", "metabolteID", "metabiliterHandle", "metabolitateInfo", "metabolitesID", "metabolITEType", "metabolicitationInfo", "metaboliciteInfo", "metabolitationid", "metabolitateid", "metabolicITEId", "metabiliteID", "metabolITEId", "metabolitationIN", "metaboliteIN", "metabolteHandle", "metmbolitationID", "metabolicITEType", "metabolitateId", "metaboliterHandle", "metabolisticID", "metabolitationName", "metaboliteType", "metabiliteId", "metabiliterUID", "metaboliteid", "metabolitationId", "metmboliteIN", "metabolitionid", "metabolitionID", "metabolitableId", "metabolitionName", "metabiliterID", "metaboliciteType", "metabolisticIN", "metaboliterid", "metabolitationID", "metabolITEID", "metabiliteid", "metaboliterID", "metabolicITEID", "metabolITEName", "metabolitableUID", "metaboliterName", "metabolitationInfo", "metabolitableHandle", "metabolteUID", "metaboliceId", "metaboliciteid", "metabolitesid", "metaboliterUID", "metaboliteUID", "metabiliteName", "metaboliterIN", "metmboliteID", "metmboliteId", "metabiliterid", "metaboliteHandle", "metabolicitationID", "metabolicitationId", "metaboliciteId", "metabiliterId", "metabolteId", "metaboliciteID", "metabiliteHandle", "metaboliteInfo", "metabolitesName", "metmbolitationIN", "metabiliterName", "metabiliteUID", "metabolitationType", "metaboliteName", "metabolicitationid", "metaboliterId", "metaboliterType", "metmbolitationId"], "dataScore": [" dataRank", "deviceTransfer", " dataWeight", "relationScore", "parentSc", "relationscore", "dataAge", "dataStyle", "dataSize", "DATARank", "DATATest", "errorWeight", "blockSpeed", "errorscore", "parentRank", "blockScore", "blockStyle", " dataSize", "DataSc", "ataScore", "dataTransfer", "deviceScore", "dataRank", "DataSize", "divScore", " dataAge", "parentScore", "arraySc", " dataSc", "divSize", "DATAScore", " datascore", "dataWeight", "tdScore", "relationSize", "ataTransfer", "tdAge", "dataSpeed", "blockSc", "errorSize", "arrayScore", "arraySpeed", "errorScore", "dataTest", "parentTest", " dataStyle", " dataSpeed", "deviceSc", "arrayAge", "arrayStyle", " dataTest", "DataRank", " dataTransfer", "tdSc", "divRank", "relationWeight", "datascore", "DataScore", "ataSize", "dataSc", "divSc", "ataSc", "DATASc", "deviceSize"], "data": ["cache", "html", "array", "none", "image", "string", "ata", "multiple", "lines", "description", "info", "content", "ns", "series", "json", "users", "value", "params", "values", "all", "buffer", "keys", "dat", "results", "video", "map", "zero", "available", "step", "batch", "base", "space", "valid", "mu", "draw", "details", "hash", "set", "text", "chain", "supported", "rew", "table", "words", "DATA", "size", "extra", "missing", "td", "hex", "window", "bytes", "raw"], "molecularWeight": ["moleuralWeight", "moleularWeight", "moleculeData", "moleculeweight", "mlecularFont", "moleularData", "mlecularData", "moleularweight", "moleuralScore", "moleularFont", "mlecularWater", "molecularData", "moleuralWater", "molecularWater", "molecularFont", "molellularData", "mleularweight", "mleularScore", "molellularweight", "mlecularWeight", "moleudoScore", "moleularWater", "mlecularweight", "mleularData", "molellularFont", "moleculeWeight", "mlecularScore", "molellularWeight", "molecularScore", "moleudoWater", "moleculeFont", "mleularFont", "mleularWeight", "mleularWater", "moleularScore", "molecularweight", "moleudoWeight"]}}
{"id1": "14473711", "id2": "2736184", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    public static String getURLContent(String urlPath, String requestData, String charset) {\n        BufferedReader reader = null;\n        HttpURLConnection conn = null;\n        StringBuffer buffer = new StringBuffer();\n        OutputStreamWriter out = null;\n        try {\n            URL url = new URL(urlPath);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            conn.setDefaultUseCaches(false);\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(60000);\n            out = new OutputStreamWriter(conn.getOutputStream(), charset);\n            out.write(requestData);\n            out.flush();\n            int repCode = conn.getResponseCode();\n            if (repCode == 200) {\n                int count = 0;\n                char[] chBuffer = new char[1024];\n                BufferedReader input = new BufferedReader(new InputStreamReader(conn.getInputStream(), charset));\n                while ((count = input.read(chBuffer)) != -1) {\n                    buffer.append(chBuffer, 0, count);\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"\", ex);\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n                if (reader != null) {\n                    reader.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (Exception ex) {\n            }\n        }\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"str2md5": ["str2sha5", "str2dig7", "str2shaest", "str2md7", "str2sha6", "str2MD7", "str2MD5", "str_MD7", "str2MD6", "str_MD6", "str_mdest", "str2dig6", "str2md6", "str2MDest", "str_md6", "str_md7", "str2sha7", "str2mdest", "str2dig5", "str_MDest", "str_MD5", "str2digest", "str_md5"], "str": ["name", "url", "msg", "obj", "ch", "exp", "p", "string", "vol", "tr", "char", "rs", "enc", "v", "r", "STR", "b", "wr", "data", "f", "txt", "c", "sts", "cont", "res", "arr", "oct", "ctr", "br", "wcs", "st", "in", "piece", "text", "t", "cur", "out", "Str", "s", "cr", "input", "fr", "sp", "print", "hex", "dr", "n"], "alga": [" AlGa", " Alga", "agga", "palGa", "agba", "palga", " alxa", "alxa", "aga", " calba", " ala", " calGa", "balGa", " Algas", "balba", "palha", "ala", "bala", " calgas", "algas", " alGa", "palba", " alba", "balga", "alba", "alha", " calga", "balha", " algas", " Alba", "agxa", "balxa", "alGa", " alha"], "digesta": ["igresso", "designosi", "igista", "digresso", "divesta", " digested", "divested", "designested", "igella", "divista", "designesta", "divresso", " digresso", "divosi", "digested", "digosi", " digosi", "diveste", "divella", "igesta", " digeste", "digista", " digella", "digella", " digista", "digeste", "designeste"]}}
{"id1": "5148212", "id2": "300397", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": ["clonefile", "copyImage", " copyImage", "copFile", "copImage", "cloneFile", "copfile", "copyfile", " copyfile", "cloneImage"], "src": ["Source", "url", "sec", "inc", "obj", "path", "init", "inst", "sq", "attr", "rs", "ource", "sr", "syn", "file", "source", "ost", "lit", "start", "sys", "filename", "sit", "ipl", "txt", "usc", "from", "st", "img", "ins", "cur", "str", "sur", "urg", "sf", "ser", "loc", "usr", "rel", "pkg", "sc", "iter", "req", "rc", "input", "ie", "ident", "ls", "ur", "rest", "iv"], "dest": ["port", "obj", "origin", "ord", "vol", "master", "v", "min", "dat", "data", "coord", "cont", "st", "img", "spec", "iter", "req", "end", "dist", "comp", "est", "path", "nw", "deg", "source", "opt", "comb", "result", "sup", "foreign", "usr", "d", "ident", "orig", "nom", "tr", "Dest", "this", "target", "lit", "de", "etc", "prop", "gt", "way", "good", "test", "des", "doc", "output", "null", "fe", "fr", "trans", "tom", "sp", "cat", "desc", "them", "rest", "delete", "parent", "gov", "temp", "file", "sit", "crit", "loc", "tif", "nd", "dir", "to", "decl", "mk"], "bufSize": [" bufsize", " bufInfo", "bufInfo", "BufferSize", "fontSize", "fontInfo", "queueCount", "fontSIZE", "bufferLength", " bufSIZE", "bufLength", "queueLen", "bufferLen", "boxSIZE", "ufInfo", "fontsize", "ufsize", "BufferCount", "buffersize", "bufCount", "boxsize", "bufferSize", "BufferLen", "queueSize", "bufferCount", "bufSIZE", "bufferSIZE", "bufsize", "ufSIZE", "boxSize", "queueLength", "BufferLength", "ufSize", "bufLen"], "force": ["remote", "cp", "auto", "ace", "yes", "external", " confirm", "apply", "ignore", "replace", "fail", "forge", "flush", "vert", "e", "flag", "cmd", "allow", "ghost", "raise", "like", "start", "update", "func", "fx", "reason", "secure", "append", "default", "error", "sync", "only", "send", "enable", " enforce", "forced", "form", "quote", "frame", "rule", "fast", "dirty", "seed", "always", "write", "open", " override", "Force", "forcing", "require", "ce", "print", "pdf", "use", "handle"], "f": ["fp", "rf", "xf", "exp", "ef", "p", "part", "fm", "g", "v", "fo", "r", "F", "w", "e", "file", "b", "h", "uf", "fc", "m", "c", "fs", "fi", "elf", "conf", "bf", "lf", "t", "sf", "of", "d", "cf", "l", "inf", "dir", "s", "fac", "fr", "ct", "df"], "buffer": ["attribute", "sequence", "cache", "shape", "stroke", "char", "message", "memory", "sample", "stack", "database", "temp", "number", "variable", "buf", "Buffer", "parse", "append", "template", "bar", "library", "password", "result", "queue", "batch", "base", "command", "frame", "text", "buff", "binary", "history", "phrase", "write", "table", "paste", "length", "word", "iter", "line", "block", "row", "print", "document", "filter", "window", "index"], "read": ["im", "READ", "len", "ip", "key", "shape", "raw", "it", "find", "height", "bind", "select", "char", "reading", "stream", "before", "add", "info", "reads", " Read", "w", "run", "gets", "allow", "feed", "hello", "like", "query", "start", "log", "i", "parse", "give", "take", "record", "time", "send", "q", "valid", "reader", "check", "str", "range", "t", "en", "mem", "load", "write", "length", "open", "get", "ke", "iter", "word", "count", "end", "seek", "skip", "input", "readable", "need", "size", "print", "pe", "index", "fill", "ind", "Read"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "image", "mi", "it", "is", "ain", "per", "inner", "isin", "ex", "ini", "din", "mm", "irm", "source", "bin", "i", "ir", "io", "gin", "local", "internal", "on", "m", "from", "In", "or", "ic", "inside", "ins", "en", "IN", "by", "l", "client", "get", "con", "ma", "iter", "to", "cin", "rin", "input", "ie", "net", "ar", "inf", "oin", "ind"], "out": ["obj", "cache", "up", "not", "conn", "parent", "ln", "writer", "full", "it", "Out", "inner", "v", "ex", "nt", "aos", "oe", "outer", "flush", "file", "b", "sys", "bin", "ion", "cos", "io", "one", "conv", "user", "on", "ou", "ot", "or", "t", "at", "o", "ne", "OU", "write", "output", "client", "con", "os", "to", "oss", "end", "co", "list", "outs", "OUT", "net", "print", "note", "can", "n", "cn"]}}
{"id1": "23672408", "id2": "13595251", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"copyIconFiles": [" copyIconImages", " copyiconFiles", " copyiconDocuments", "copyIconfiles", " copyIconDocuments", "copyiconDocuments", "copyIndexImages", "copyiconFiles", "copyiconImages", " copyIconfiles", "copyIndexDocuments", " copyiconImages", " copyiconfiles", "copyIndexfiles", "copyIndexFiles", "copyIconImages", "copyiconfiles", "copyIconDocuments"], "clazz": ["crus", "relazz", "clbo", " clbean", "escojure", "callace", "classazz", "plaz", " classe", "classotted", " claz", "descab", "clashed", "escazz", "escace", "descose", "clace", " clotted", " cluster", "classuddy", "clab", "CLace", "classe", "descazz", "chojure", " plub", " cluddy", "descaz", "clbean", "colluddy", " clbo", " club", "cluster", "callazz", "relaz", "pkgasse", "scloser", "sclazz", "sclbean", " clace", "pkgashed", "club", "sclace", "pkgazz", "clus", "Clbo", "craz", "relab", "crub", "plazz", "plasse", "clotted", "callaz", "Clab", "chazz", "CLbean", "closer", "collotted", "claz", "Clazz", "callbo", "CLazz", "Close", "Claz", "pkgaz", "cluddy", " clojure", " plus", " clashed", "plashed", " plazz", " closer", "relose", "chace", " clus", "Clace", "close", "escotted", "collazz", " plaz", "classuster", "clojure", "CLoser", "crazz", "colluster", "chotted"], "i16": ["ri16", "pi150", "ii24", "i6", "ami150", "ami19", " i160", "iri6", "i24", "pi6", "ji6", "i216", "ji150", "ji63", "i150", "ami63", " i2016", "pi63", "ini19", "pi16", " i157", "i157", "ini2016", " i6", "ini160", "iniShort", "li16", "ini216", "i63", "ii16", "iri16", "ami2016", "iri2016", " i216", "ami6", "iri157", "ri2016", "amiShort", "ini16", "ji16", "ii216", "liShort", "ri6", "li2016", "ami16", "li19", "ri157", " i24", "i2016", "iShort", "i19", "i160", "ii160", "ini24"], "fileType": ["fileValue", " fileTyp", " fileList", "relationType", "resourceUnit", "fileFamily", "FileName", "resourceFormat", "fieldType", "fileTYPE", " filetype", "coreType", "fieldDef", "fileTyp", "treeTime", "resourceTYPE", "policyHandler", "issuePattern", "webDef", "issueType", "policyFamily", "eventUnit", "policyTyp", "webTyp", "formattype", "ileType", " fileValue", "fileName", "fileDef", "formatType", "relationTyp", "ilePattern", " fileFormat", "FILEType", "eventTYPE", "treeType", "viewTYPE", "fileHandler", "webList", "fieldTYPE", "filetype", "FILEtype", "formName", "formatTYPE", "webType", "formType", "treetype", "Filetype", "fileList", "issuetype", " fileTYPE", "eventList", "eventType", "relationFamily", " fileTime", "coreFamily", "formatTime", "policyType", "formtype", "ileTyp", "fileUnit", " fileUnit", "issueTyp", "viewtype", "formatValue", "coreDef", "filePattern", "coreTYPE", "viewType", "coreHandler", "coreTyp", "FILEName", "treeTYPE", "fileTime", " filePattern", "viewValue", "resourceType", "webTYPE", "eventFormat", "relationHandler", "fieldTyp", "FileType", "fileFormat", "iletype"], "desti16": ["destsi160", "destgi2016", "desti24", "resultii24", "destui24", " destsi160", "destii2016", "resulti2016", "destgi16", " destsi18", " desti18", " destsi16", "desti216", " destsi32", "destxi16", "destii16", "resulti216", "desti18", "destui160", "destui16", "destii24", "desti160", "destsi32", "destui18", "destgi24", "resulti16", "desti2016", "resultii216", " desti160", "destsi18", "destsi16", "resultii2016", "destxi160", "destii216", "destui2016", "destgi216", "destxi32", "destui32", "destui216", "resultii16", "resulti24", "destxi18"], "src": ["scan", "hl", "sec", "obs", "bg", "comp", "ln", "inst", "sq", "cmp", "bc", "addr", "cb", "inner", "rs", "dest", "bh", "via", "sr", "sb", "rx", "cli", "syn", "sel", "source", "sys", "bin", "etc", "sit", "ssl", "gs", "tmp", "ptr", "fc", "sync", "txt", "cont", "std", "nl", "sl", "ctr", "vr", "rl", "st", "rob", "sol", "ser", "isl", "cur", "ins", "ibl", "urg", "img", "loc", "rg", "rel", "usr", "pkg", "sn", "proc", "ctx", "sc", "iter", "req", "rc", "sub", "rb", "input", "sp", "ls", "desc", "rest", "iv"], "dst": [" dnd", "dnet", "Ddest", "ddest", "dsot", "ddst", "tgt", "dsest", "dput", " dput", " dgt", "dmt", "rdsts", " dsts", "rst", "nst", " dmt", "dsst", "ndest", "rcut", "tput", "ndst", "dLbl", "rbl", "dest", "nput", "ddr", "derst", "rdst", "dnd", "fnd", " dot", "ndsts", "dsnet", "Ddr", "dmn", " dmn", "dddest", "dcut", "ddmn", "dsts", "dLest", "nnd", "Dnd", "ngt", "tnd", "dLdest", " dnet", "dgt", " dbl", "dLcut", "dbl", " ddr", "rdest", " ddest", "dot", "tst", "fdest", "dLst", "derdest", "ndmt", " dest", "dermn", "fst", "ddnd", "rdmt", " dcut", "Dst", "dernd", "fdr", "dLnet", "dLot"], "i32": ["i342", "ic32", " i342", "ic342", "ini22", "i34", "ii342", "ii34", "ini31", " i86", "isi86", "pi64", "pi34", " i31", " i34", "ini48", "isi64", "ic31", "ii28", " i40", "ic48", "xi31", "ic86", "ic22", "isi40", "i40", " i28", "ip32", "pi32", "ip34", "i86", "ip64", "xi48", "xi32", "i64", "i28", "isi32", "ic40", "ini32", " i64", "ic28", "ic34", "ii32", "ic64", "xi22", "ip31", "i48", "i31", "i22", "pi31"], "desti32": ["DestI256", "destI256", "Desti90", "destdi34", "Desti31", "targeti31", "destI90", "destu256", "targetpi30", "destu90", "desti30", "targetpi31", "destu31", "DestI90", "destI32", "Desti256", "Desti32", "desti31", "destic34", "destic32", "targetpi34", "destpi30", "targetpi32", "destdi32", "destpi31", "desti90", "targeti34", "destdi30", "targeti30", "destic31", "destI31", "destic30", "destu32", "DestI31", "destdi31", "destpi32", "desti256", "desti34", "DestI32", "destpi34", "targeti32"]}}
{"id1": "13596891", "id2": "804637", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"doTransfer": ["DoTransfer", "doRequest", "doDownload", "handleSend", " doDownload", " doSend", "handleDownload", "handleRequest", "DoRequest", " doRequest", "handleTransfer", "doSend", "DoDownload", "DoSend"], "request": ["remote", "attribute", "QUEST", "name", "server", "parent", "initial", "version", "header", "have", "this", "order", "xml", "process", "message", "subject", "current", "Request", "config", "query", "change", "question", "log", "session", "params", "resource", "context", "record", "reference", "user", "call", "setup", "application", "result", "complete", "report", "http", "command", "frame", "object", "in", "address", "create", "client", "get", "req", "position", "connection", "requ", "input", "remove", "re", "reset", "quest", "document", "use", "raw"], "response": ["sequence", "view", "server", "answer", "image", "resp", "version", "this", "description", "message", "content", "json", "success", "pos", "session", "context", "next", "one", "respond", "respons", "default", "application", "exit", "result", "res", "report", "send", "site", "http", "page", "status", "onse", "frame", "Response", "service", "object", "body", "summary", "out", "write", "proxy", "output", "position", "block", "connection", "reset", "ce", "reply", "print", "document", "wrapper"], "method": ["name", "timeout", "other", "tr", "version", "string", "subject", "message", "verb", "eth", "property", "reason", "mod", "hod", "call", "right", "METHOD", "num", "m", "type", "report", "send", "http", "command", "form", "instance", "prefix", "service", "post", "direction", "length", "dir", "ETHOD", "th", "transform", "period", "Method"], "servletContext": ["servantcontext", " servantcontext", "ServletEvent", "servLETChain", "ServletsEvent", " servantComponent", "servfilecontext", "servlerEvent", " servletcontext", "ServletsConfig", "servLETDefinition", " servantDefinition", "servletsChain", "servletEvent", "servfileDefinition", "servletsConfig", "servletsContext", "servLETConfig", "servlerChain", "servletChain", "servLETComponent", "servLETEvent", "servantDefinition", " servletComponent", "servLETContext", "ServletContext", "servletConfig", "ServletsContext", "servletComponent", " servletDefinition", "ServletsChain", "servantContext", "ServletChain", "servLETcontext", "servlerContext", "servfileContext", "servletcontext", "servletDefinition", "servfileComponent", "servlerConfig", "servletsEvent", " servantContext", "ServletConfig", "servantComponent"], "wac": [" wacc", " wacs", "bacs", "wbacc", "wbAC", " wAC", "bAC", "bac", "wacc", "wbacs", "bacc", "wacs", "wbac", "wAC"], "szUrl": ["sziUrl", "sgzUr", "sZUrl", "sZurl", "szarUr", "szaLoc", "szaURL", "szurl", "sziUr", " szeUr", " szePath", "sziGl", "sldPath", "szUr", "szaUr", " szeURL", "szeurl", "szPath", "szGl", " szPath", "szarUrl", "sizStr", "szLoc", "szeUrl", "sziurl", "sZGl", "szaUrl", "desgzPath", " szeurl", "deszPath", "szePath", "szeLoc", "sgzStr", "sgzPath", " szeLoc", " szGl", "szURL", "sZUr", "deszUrl", "szarPath", "sldGl", "sldUrl", "sizURL", "szeGl", " szUr", "deszURL", "desgzURL", "szeUr", "szeURL", "deszStr", "szStr", "sldUr", "sgzUrl", " szeUrl", " szURL", " szLoc", "sgzLoc", "desgzUrl", " szeGl", "sizUrl", "sgzURL", "szeStr", "desgzStr", " szurl", "szarGl", "sizPath"], "url": ["mail", "Url", "name", "link", "util", "pl", "conn", "cert", "socket", "org", "char", "ret", "xml", "u", "mount", "file", "lb", "gc", "location", "date", "gl", "ssl", "host", "build", "bel", "f", "il", "base", "uri", "web", "http", "sl", "nl", "rl", "impl", "str", "prot", "ll", "browser", "t", "address", "ref", "loc", "https", "un", "l", "open", "client", "ob", "connection", "www", "URL", "re", "ml", "ol", "ls", "ur", "ul"], "is": ["tis", "cs", "ip", "ri", "ois", "iss", "bs", "si", "isin", "ps", "info", "isa", "sis", "iso", "Is", "ir", "i", "sys", "ris", "serv", "es", "IS", "id", "res", "bis", "its", "ic", "in", "ios", "ins", "ms", "us", "ism", "nis", "os", "s", "isc", " cis", " bis", "isi", "as", "lis", "ii"], "sout": [" scho", "wsos", " sj", " south", "sin", "lsin", "scho", "osouth", "lsout", "wscho", "lsos", "lsouth", "osin", " sos", "osout", "sj", " sOut", "south", "wsj", "osOut", "sOut", "wsout", "lsOut", "sos", "lsj", "lscho", " sin"], "con": ["cgi", "obj", "cache", "stat", "conn", "const", "cmd", "call", "res", "conf", "cond", "cell", "CON", "cur", "create", "un", "cf", "ctx", "Con", "req", "rc", "bc", "ain", "act", "current", "pen", "syn", "config", "h", "on", "fc", "num", "coll", "http", "com", "fl", "condition", "connection", "compl", "control", "thin", "cn", "util", "cons", "ln", "ver", "comm", "don", "apache", "cos", "ran", "conv", "cal", "c", "nc", "cm", "common", "dial", "co", "re", "can", "acon", "cv", "socket", "connect", "change", "cone", "ion", "log", "internal", "ven", "local", "ctrl", "canon", "code", "en", "client", "fac", "Conn", "cp"], "hNames": ["hmKeys", " hIDs", "hWords", " hStates", "hmAMES", "dhWords", "dhNames", " hUsers", "dhKeys", "hIDs", "hKeys", " hAMES", "htNames", "hrWords", "tKeys", "tNames", "tStates", " hNs", "dhIDs", " hWords", "hmNames", "bNs", "tNs", "hStates", "hrIDs", "hmUsers", "hrKeys", "bStates", "hUsers", "hrNames", "htKeys", "hAMES", " hKeys", "htAMES", "bKeys", "bNames", "hNs", "htUsers"], "txt": ["msg", "elt", "htm", "obj", "TEXT", "tf", "nm", "tx", "cmp", "qt", "xt", "fn", "nt", "typ", "ns", "xx", "filename", "tt", "tmp", "dat", "kt", "gt", "XT", "ext", "tab", "lt", "nv", "kw", "te", "str", "text", "t", "lv", "dj", "nu", "test", "xxx", "pkg", "bt", "pt", "tm", "btn", "sp", "ht", "mt", "ct", "tk", "wt"], "inBody": ["inbody", "inputBox", "Inbody", "inBoot", "dinReader", "inReader", "inBlock", " inBlock", "InReader", "inBox", "dinbody", "InBody", " INBox", "cinBox", "dinBody", "inputBody", " inbody", " inBoot", " INBoot", "InBox", " inThread", "cinBoot", "InThread", " inBox", "inputThread", " INBlock", " INBody", " inReader", "cinBlock", "cinBody", "inThread"], "bufCh": ["buffBuff", "bufCol", "cbCh", "BufferComp", "BufferChar", "cbChar", " bufComp", " bufChar", "ufCH", "ufCol", "ufChar", "BufferCH", " bufCol", "bufCH", "bufferCH", "bufBuff", "buffChar", "bufferCh", "bufferch", "cbCol", "buffCh", "ufCh", "bufComp", "bufch", "bufferBuff", "cbCH", "buffCH", "buffComp", "buffch", " bufBuff", " bufch", "BufferCh", " bufCH", "bufChar"], "r": ["ch", "rd", "p", "R", "x", "rs", "rec", "v", "hr", "sr", "w", "rr", "u", "e", "nr", "err", "i", "h", "k", "rar", "rate", "f", "c", "res", "q", "arr", "or", "t", "out", "er", "rw", "d", "o", "l", "gr", "mr", "rc", "cr", "rb", "lr", "z", "re", "rt", "dr", "ar", "n"], "outReq": ["outConqs", "inSech", "inSej", "outFrej", " outRequest", "inRech", "inSeq", "outConquest", " outRecq", " outRecqs", " outRech", "outReek", " outRecek", " outRej", "outFreq", "outRech", "outRecque", "outConque", "outRecquest", "outREqs", " outConq", "outResquest", "outResch", "outReqs", "outTeq", "outConck", "inReq", "outReck", " outReqs", "outSeck", "outTeqs", "outReQ", "outRecek", "outSeq", "outSej", "outREque", "inRequest", " outConqs", " outReque", "outFrech", "outRecqs", "outTeQ", " outConquest", "outRecQ", "outConj", "outTequest", "outREek", "outConq", "outReque", "inSequest", " outRecque", " outReek", "outResq", "outRej", "outConek", "outSech", "inRej", " outConQ", " outConj", "outREq", "outRequest", " outConch", " outReQ", "outRecq", "outConch", " outReck", "outFreck", "outResj", "outConQ", "outSequest", " outConck"], "buff": ["ff", "comp", "alph", "cb", "cho", "info", " buffers", "cmd", "ph", "buffer", "bin", "buf", "uf", "bb", "be", "emb", " buf", "cond", "bj", "font", "img", "mem", "Buff", "ref", "nd", "cod", "eng", "off"]}}
{"id1": "6866575", "id2": "23666867", "code1": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 0, "substitutes": {"caml_md5_string": [" saml_md52String", " saml_md2_string", " saml_md5bystr", " saml_md2_sequence", " saml_md5bysequence", " saml_md22sequence", " saml_md5_str", " saml_md52sequence", " saml_md2_String", " saml_md5byString", " saml_md52str", " saml_md22string", " saml_md5_sequence", " saml_md52string", " saml_md2_str", " saml_md5_String", " saml_md5_string", " saml_md22String", " saml_md22str", " saml_md5bystring"], "ctxt": ["CTtxt", "cttxt", " cXT", " ctx", "cttx", "Cxt", " cxt", "Ctxt", "ctXT", "CTxt", "Ctx", "CTXT", "CTtx", "CXT"], "str": ["name", "msg", "stri", "tr", "string", "vol", "char", "rs", "strings", "uts", "v", "enc", "r", "seq", "dec", "STR", "buf", "dat", "data", "conv", "txt", "sts", "sl", "arr", "oct", "form", "br", "st", "text", "out", "vc", "os", "Str", "s", "fr", "input", "sp", "dr"], "ofs": ["OFrs", " ofts", "offs", "tells", "ofds", "Ofs", "Offs", "ofrs", " ofds", "OFs", " ofns", "Ofrs", "Ofds", " offs", "OFns", "OFds", " ofrs", "tellns", "tellts", "ofts", "OFts", "OFfs", "ofns", "tellds"], "len": ["hl", "elt", "offset", "ln", "le", "inv", "bytes", "lon", "nt", "syn", "fin", "L", "fun", "ld", "lp", "il", "el", "nl", "left", "lf", "fl", "ll", "en", "mem", "un", "l", "length", "lan", "Len", "wid", "n", "end", "compl", "size", "ls", "lis"], "md5": ["d512", " mdlet", " md6", " md2", " amd51", "mn3", "md51", " mk51", "md3", "mn6", "dig6", "mdlet", "mn5", " amd52", " md512", "dig5", " mk2", "d5", " md51", "diglet", "md512", " mk52", "d3", " amd5", "d6", "md2", "dig3", " md52", "dig512", "md6", "md52", "mnlet", " md3", " mk5", " amd2"]}}
{"id1": "13720140", "id2": "2936678", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"modifyProperty": ["modateProperty", "modifyProp", "ModifiesProp", "modateAttribute", "ModifyAttribute", "ModifiesAttribute", "modureValue", "ModifyProperty", "modifiesAttribute", "modureAttribute", "modateProp", "ModifiesProperty", "modureProperty", "ModifyValue", "ModifiesValue", "modateValue", "modureProp", "modifiesProp", "modifiesProperty", "ModifyProp", "modifyValue", "modifiesValue", "modifyAttribute"], "valueID": ["versionIDs", "versionId", "versionid", "propertyid", " valueid", " valueMD", "valueIDs", "valueid", " valueId", "versionUID", "VALUEId", " valueUID", "valueId", "VALUEMD", "propertyId", "valueUID", "propertyIDs", "VALUEID", "VALUEUID", "versionID", "valueMD", "propertyID", "versionMD", " valueIDs"], "value": ["attribute", "name", "key", "version", "string", "description", "v", "message", "current", "memory", "entry", "content", "expression", "label", "hello", "values", "update", "buffer", "variable", "function", "val", "data", "padding", "default", "password", "example", "Value", "application", "comment", "type", "save", "format", "vector", "instance", "text", "code", "address", "output", "get", "VALUE", "input", "field", "state"], "userID": ["UserURL", "usernameID", "UserType", "usernameName", "ownerName", "userName", "ownerID", "userId", " userName", "UserID", " userId", " userURL", "userURL", "usernameId", " userType", "usernameURL", "userType", "UserId", "ownerType", "UserName", "ownerId"], "property": ["attribute", "name", "option", "metadata", "key", "state", "claim", "p", "operator", "display", "this", "ty", "description", "message", "title", "expression", "associated", "label", "config", "second", "alias", "prop", "resource", "profile", "function", "data", "translation", "method", "media", "setup", "project", "type", "prototype", "command", "feature", "object", "Property", "prefix", "language", "item", "address", "relation", "module", "table", "policy", "term", "section", "position", "to", "license", "field", "print", "pair", "style", "pe", "properties"], "newValue": ["NEWValue", " newValues", "oldMessage", "Newvalue", "newMessage", "newValues", "newVersion", "newString", " newResult", "newName", " newVersion", "oldName", "oldResult", "uniqueValue", "oldVersion", "uniqueName", "newvalue", "NewString", "oldValue", " newName", " newvalue", "uniqueMessage", "NEWString", "oldValues", "oldvalue", "oldString", "NEWResult", "newResult", "NewValue", "NewValues", " newString", " newMessage", "NEWvalue", "uniqueVersion"], "crypt": ["bec", "sm", "roy", "cs", "ch", "go", "init", "cert", "magic", "cmp", "comm", "auth", "cc", "cot", "enc", "ocr", "nt", "mac", "dec", "cmd", "gc", "cos", "sys", "ssl", "cry", "col", "conv", "rem", "password", "Crypt", "arch", "sync", "cont", "coll", "ctr", "CR", "cook", "check", "hash", "prot", "coin", "mem", "code", "cy", "cur", "rh", "cm", "pt", "cr", "core", "dict", "reset", "rot", "hex", "trust", "ct", "cp", "rypt"], "digest": ["hexEST", " Digest", "mdested", "dEST", "Digest", "digestamp", "dester", "mdEST", "mdge", "dest", " digested", "Digester", " digestamp", " DigEST", "Digge", "digert", "Diggest", "diggest", "mdest", "hashest", "mdester", "digge", "digests", "mdgest", "Digestamp", "Digert", "digested", "hashge", " Digert", "hexest", "digEST", " Digester", " digEST", "hashgest", "DigEST", "digester", "hexert", "Digests", "mdestamp", "dested", "Digested", "hexester", "mdests", "hashests"], "hexString": ["hexBytes", "shortStr", "hashstring", " hexArray", "hexArray", " hexstring", " hexBuffer", "exArray", "exBytes", "formBytes", " hexBytes", "hashStr", "hexstring", "exString", "hashArray", "formBuffer", "exBuffer", "formStr", "shortstring", "formString", "hashString", "exstring", "shortString", "shortBuffer", " hexStr", "exStr", "hexStr", "hexBuffer"], "i": ["ix", "bi", "im", "ip", "init", "span", "is", "it", "x", "mi", "phi", "gi", "ui", "ji", "si", "v", "a", "ex", "ini", "info", "hi", "major", "u", "e", "cli", "\u0438", "number", "point", "gu", "io", "ci", "ti", "j", "multi", "di", "id", "m", "uri", "ii", "q", "y", "ic", "ei", "slice", "ms", "qi", "chain", "us", "ki", "o", "ai", "I", "ie", "pi", "sim", "index", "ind", "li"]}}
{"id1": "10728243", "id2": "6866575", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 1, "substitutes": {"scramble411": ["scramblesPassword", "scamblesBasic", "scramble ", "scrambledBasic", "scamblePassword", "scramle ", "scramlePassword", "scrambledpassword", "scrambledPassword", "scramblesBasic", "scrambles ", "scramlepassword", "scramblepassword", "scramleBasic", "scamblesPassword", "scramblePassword", "scrambled ", "scramblespassword", "scamblepassword", "scamble ", "scambleBasic", "scambles ", "scamblespassword", "scrambleBasic"], "password": ["attribute", "key", "string", "pattern", "remember", "auth", "wd", "primary", "description", "message", "database", "hello", "Password", "profile", "email", "data", "padding", "user", "crypt", "sword", "prefix", "hash", "text", "address", "phrase", "words", "word", "shadow", "reset", "pass", "token", "username", "secret"], "seed": ["needs", "sequence", "offset", "key", "df", "initial", "se", "sample", "entry", "rand", "derived", "feed", "eed", "source", "start", "sudo", "sex", "padding", "template", "example", "setup", "Salt", "eder", "prime", "mix", "vector", "sql", "random", "hash", "ser", "create", " seeds", "test", "phrase", "shadow", "reset", " seeded", "index", "secret"], "md": ["sm", "metadata", "msg", "amd", "rd", "dr", "dig", "addr", "def", "cd", "mb", "MD", "nt", "dm", "dh", "mm", "der", "od", "cmd", "grad", "hd", "ind", "managed", "bd", "de", "gm", "sd", "mod", "ad", "multi", "esm", "di", "ld", "rpm", "m", "det", "med", "mind", "pdf", "pm", "mp", "rm", "mg", "img", "desc", "red", "ms", "mn", "d", "pkg", "cm", "nd", "pt", "ma", "mand", "exec", "ann", "dd", "mc", "td", "mt", "ct", "mk", "df", "pd", "sha"], "passwordHashStage1": ["passwordHashSHA1", "passwordHashPage1", "passwordHashSHA2", "passwordHashstage5", "passwordhashStageOne", "passwordHashPhase2", "passwordHashPhase1", "passwordhashStage2", "passwordHashPhase0", "passwordHashStage5", "passwordhashstageOne", "passwordHashSHA0", "passwordHashPage2", "passwordHashstage1", "passwordHashstage0", "passwordhashstage1", "passwordhashStage1", "passwordHashStage01", "passwordhashstage0", "passwordHashStage0", "passwordHashPage5", "passwordHashstageOne", "passwordhashStage0", "passwordHashPhaseOne", "passwordHashSHA01", "passwordHashStageOne", "passwordHashstage01", "passwordHashstage2", "passwordhashstage2", "passwordHashPage0"], "passwordHashStage2": ["passwordHashVersion1", "passwordHashScene3", "passwordHashStage4", "passwordHashstage4", "passwordHashPhaseTwo", "passwordSaltStage62", "passwordHashStyleTwo", "passwordHashPhase2", "passwordHashPhase1", "passwordHashStyle62", "passwordHashStage3", "passwordHashStyle3", "passwordHashVersion2", "passwordHashSceneTwo", "passwordSaltStage3", "passwordHashStyle2", "passwordSaltStage2", "passwordHashstage1", "passwordHashStage62", "passwordHashScene62", "passwordSaltStageTwo", "passwordHashPhase4", "passwordHashVersionTwo", "passwordHashScene2", "passwordHashstage2", "passwordHashstageTwo", "passwordHashVersion4", "passwordHashStageTwo"], "toBeXord": ["toBEXorg", "toBeTxond", "toBeXorg", "toBEXords", "toBeYorg", "toBeZords", "tobeXold", "toBeXLords", "toBEXod", "toBeXLord", "toBeZord", "toBeZXords", "toBeXold", "toBeYold", "toBexorg", "toBeYor", "tobeYord", "tobeYords", "tobeXorg", "tobeXord", "toBEXord", "toBexord", "toBeTxords", "toBeZor", "toBeZXord", "toBeZorg", "toBeXod", "toBexords", "toBeXor", "toBeTxorg", "tobeYor", "toBeXond", "toBexond", "tobeXor", "toBeXLor", "toBeXords", "tobeYorg", "toBeYod", "toBeZXor", "toBEXor", "toBeYords", "toBexor", "toBeZXold", "tobeYold", "toBeYord", "tobeXords", "toBeTxord", "toBEXond", "toBeXLod"], "numToXor": ["numtoXOR", "numToXors", "numToxor", "num2Restors", "num2Xors", "numtoYor", "num2Restore", "numtoXord", "num2XOR", "numToRestors", "numToZore", "numToZor", "numToRestOR", "numToXore", "num2RestOR", "numToRestor", "num2Xore", "numToYord", "numToxors", "numToYOR", "numToZors", "numtoYors", "numToxore", "numtoXor", "numToxOR", "num2Restor", "numtoXors", "num2Xor", "numToXOR", "numToZord", "numToYors", "numToRestore", "numToxord", "numToZOR", "numToYor", "numtoYOR", "numToXord", "numtoYord"], "i": ["ix", "ni", "im", "sequence", "bi", "ip", "init", "span", "ri", "is", "mi", "x", "it", "phi", "gi", "ui", "ji", "si", "g", "ex", "ini", "info", "u", "e", "cli", "\u0438", "k", "io", "ci", "ti", "zi", "multi", "j", "di", "xi", "m", "batch", "uri", "fi", "ii", "y", "ic", "set", "ei", "in", "ms", "qi", "t", "us", "o", "ai", "I", "s", "z", "ie", "pi", "sim", "n", "ind", "li"]}}
{"id1": "7044153", "id2": "3631989", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public void run() {\n        URL url;\n        try {\n            url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((str = in.readLine()) != null) {\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"sendExceptionToServer": ["sendExceptionToHost", "sendExceptionTOHost", "sendErrorToClient", "sendErrorToHost", "sendExceptionTOServer", "sendExceptiontoHost", "sendExceptiontoClient", "sendErrorToServer", "sendErrortoHost", "sendExceptionToClient", "sendErrortoClient", "sendErrortoServer", "sendExceptionTOClient", "sendExceptiontoServer"], "server": ["port", "remote", "version", "string", "ver", "env", "erver", "v", "description", "localhost", "value", "Server", "host", "serv", "channel", "email", "password", "base", "site", "store", "service", "ser", "code", "address", "test", "client", "null"], "ex": ["ix", "obj", "eas", "exp", "none", "any", "tx", "x", "aux", "it", "fail", "exe", "xc", "rex", "ox", "Exc", "rx", "e", "Exception", "event", "Ex", "err", "wx", "one", "error", "example", "ext", "ry", "exit", "EX", "el", "lex", "com", "expl", "or", "pex", "ic", "an", "test", "exclusive", "exc", "except", "re", "ception", "hex", "nex"], "config": ["cache", "cert", "env", "settings", "Config", "auth", "content", "params", "log", "param", "debug", "context", "channel", "password", "fig", "c", "cfg", "conf", "form", "service", "text", "Configuration", "rc", "input", "figure", "ct", "control"], "prob": ["probes", " prbe", "prbj", "probe", " prbes", "prbes", " prb", "Probj", " prbj", "prb", "prbe", "Prob", "probj", "Probes", "Probe"], "dataSB": ["dataWB", "partialSL", " dataSM", "partialSB", "DATASW", "windowSN", "listBB", "dataGB", "mapBS", "ataNB", "cacheSM", "contentSF", "imageBP", "DATABS", "jsonsb", "partialGB", "relationMB", "mapSB", "valueBS", "imageSF", "keyBS", "ataSF", "relationSB", " dataBB", "ataBP", " dataSN", " dataMB", "windowSB", "cacheBB", "dataBP", "DATASF", "divBS", " dataSW", "imageSB", " dataHB", "relBS", "ataSR", "DATASB", "ataSB", "relationQB", "joinWB", " datasb", "imagesb", "relBB", "mapSL", "listEB", "dataBu", "dataSW", "windowBB", "listMB", "divSN", "nextQB", "datMB", "dataRB", "joinsb", "relationSN", "ataBu", "atasb", "cacheBS", "listSF", "dataMB", "imageSw", "cacheBW", "ataBB", "relationRB", "listsb", "nextBS", " dataSA", "resourcesb", "divSF", "resourceSF", "windowBS", "dataSA", "debugBB", "relationBu", "dataEB", " dataSF", "listSI", "listSB", "divSquare", "mapBB", "cacheSA", "defGB", "mapGB", "divBW", "ataQB", "datWB", "keySL", "dateBu", "windowSL", "joinSL", "nextSB", "divBB", "relationSquare", "relationBS", "nextGB", "contentBS", "relSW", "relationSF", "resourceSI", "defQB", "valueSW", "cacheSF", "imageSN", " dataSI", "dateQB", "dataBS", "divSB", "reasonBS", "debugSF", "reasonSF", "imageQB", "dataBW", "reasonSW", "imageHB", "imageSL", "cacheSB", "relSB", "nextBB", "datasb", "contentSN", "keySB", " dataNB", "jsonSB", "dateSB", "jsonSw", "dataSw", "dataHB", "dataSI", "ataMB", "dataQB", "nextSF", "ataSA", "imageNB", " dataBS", " dataEB", "dataSquare", "defBB", "ataSN", "keyBB", " dataGB", "resourceSB", "mapHB", "imageSM", "reasonSB", "windowSF", " dataQB", "partialBB", "defSB", "mapSF", "divNB", "datSL", " dataBP", " dataSquare", " dataSw", "mapSN", "joinSB", "relationBB", "contentNB", "relationSL", "contentSR", "imageBB", "relationNB", "ataSW", "jsonSF", "dataSF", "dataSL", "dataSM", "dataSN", "datSB", "ataBS", "contentSB", "debugRB", "dataBB", "ataSL", "dateBS", "cachesb", "joinSF", "dataSR", "ataEB", "ataWB", " dataSL", "imageBS", "valueBB", "imageSR", "joinMB", " dataBW", "valueSB", "debugSB", " dataRB", "dataNB"], "trace": ["sequence", "ace", "race", "span", "tr", "tile", "true", "stream", "tty", "message", "sample", "track", "se", "stack", "detail", "temp", "buffer", "network", "debug", "log", "profile", "data", "be", "dump", "batch", "comment", "fake", "time", "role", "report", "te", "feature", "frame", "body", "range", "store", "thread", "chain", "address", "create", "history", " Trace", "test", "table", "stable", "list", "tm", "th", "transform", "mt", "style"]}}
{"id1": "6613944", "id2": "8385785", "code1": "    public static String installOvalDefinitions(final String xml_location) {\n        InputStream in_stream = null;\n        try {\n            URL url = _toURL(xml_location);\n            if (url == null) {\n                in_stream = new FileInputStream(xml_location);\n            } else {\n                in_stream = url.openStream();\n            }\n        } catch (IOException ex) {\n            throw new OvalException(ex);\n        }\n        Class<OvalDefinitions> type = OvalDefinitions.class;\n        OvalDefinitions object = _unmarshalObject(type, in_stream);\n        String pid = _getDatastore().save(type, object);\n        return pid;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"installOvalDefinitions": [" saveOevalEntications", " saveOvalDeclitions", " saveOvalEntinitions", " saveOvalEntications", " saveOevalEntinitions", " saveOvalDeclinitions", " saveOevalDefinitions", " saveOevalDefaults", " saveOevalDefications", " saveOvalDefaults", " saveOvalEntaults", " saveOvalDefinitions", " saveOvaldefitions", " saveOevalEntitions", " saveOvalDeclications", " saveOvaldefinitions", " saveOvalDeclaults", " saveOvalDefications", " saveOvalEntitions", " saveOvalDefitions", " saveOevalDefitions", " saveOvaldefications", " saveOevalEntaults", " saveOvaldefaults"], "xml_location": ["xmlContentLocation", " xml_position", "xml_uri", "xml_loc", " xml_loc", " xml_Location", "xmlContentloc", "xmlContenturi", "xml_Location", "xmlContentlocation", " xml_uri", "xml_position"], "in_stream": ["input_stream", "xmlptstream", "in_Stream", "in2store", "in67iterator", "xmlptStream", " in_ream", "inMemStream", "in_iter", "in67sign", "in___buffer", "in___iter", "in_store", "in_ream", "in2Stream", " in_Stream", "xmlptstore", "in_view", "inptstream", "inptresource", " in_iterator", "inMemstore", " in_sign", "xml_Stream", "in_resource", "input_buffer", "xmlptresource", "inptstore", "input_iter", "inMemstream", "xml_resource", "in67view", "in_sign", "xml_store", "in64stream", "in64Stream", "input_path", "xml_stream", "inptStream", " in_view", "in___path", "in_iterator", "in67stream", "in_path", "in64ream", "in___stream", "inMemresource", "in2resource", "in2stream", "in_buffer"], "url": ["mail", "Url", "link", "name", "path", "cert", "org", "char", "xml", "r", "download", "mount", "file", "location", "gl", "ssl", "resource", "host", "bel", "f", "dl", "abs", "uri", "web", "http", "nl", "sl", "el", "rl", "service", "impl", "str", "ll", "browser", "address", "ref", "loc", "rel", "l", "null", "lr", "URL", "ls", "ur", "ul"], "type": ["mail", "ime", "where", "ype", "TYPE", "shape", "model", "ver", "oid", "ty", "ped", "what", "info", "typ", "title", "cl", "file", "event", "function", "sche", "base", "ping", "role", "otype", "y", "check", "cast", "t", "class", "create", "test", "kind", "types", "module", "tool", "core", "tree", "Type", "ct", "style", "pe", "tp"], "object": ["name", "obj", "not", "array", "model", "version", "string", "system", "oid", "message", "info", "entry", "job", "entity", "detail", "value", "node", "json", "event", "resource", "context", "data", "id", "result", "instance", "objects", "class", "out", "element", "o", "output", "dict", "document"], "pid": ["port", "pc", "sid", "pp", "cert", "p", "pn", "pan", "oid", "png", "ps", " PID", "process", "pet", "title", "doi", "pg", " persistent", "uid", "prop", "PK", "pa", "id", "rpm", "po", "pty", "pm", "ids", "park", "pic", "pr", " pc", "ido", "proc", "pkg", "bid", "print", "vid", "pd"]}}
{"id1": "17202158", "id2": "1966310", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["findZoneIDs", "readLineIDS", "findLocalID", "readObjectID", "findZoneNames", "findLocalIDS", "readObjectIDS", "readLineIDs", "readZoneID", "readLineNames", "findLocalIDs", "findZoneID", "findLocalNames", "readZoneIDS", "readLocalIDS", "readObjectIDs", "readLineID", "readLocalID", "readLocalNames", "readLocalIDs", "readZoneNames", "findZoneIDS", "readObjectNames"], "zoneFileName": ["zoneFileFilename", "zoneFolderType", "zonefilePath", "zoneFilesPath", " zoneFileNames", "zonefileSource", "zoneFilenamePath", "zoneFilesNames", "ZoneFileType", "zoneFolderPath", "zoneFolderFilename", "ZoneFileSpec", "zoneDirSpec", "zonefileFilename", " zonefileName", " zonefileChain", "ZoneFileSource", "ZonefileSpec", "ZonefileType", "zoneDirPath", "zoneFILEName", "ZonefileSource", "zoneFileSpec", "zoneFolderName", "zoneDirSource", " zonefileNames", "zoneFilenameName", "zoneFILEPath", "zoneFilesName", "zonefileChain", "zoneFILENames", "ZoneFilePath", "zoneFILEType", " zonefilePath", "zoneFILEChain", "zoneFileChain", "ZonefileFilename", "zonefileType", "zoneFilePath", " zoneFileChain", "ZonefilePath", "zoneFileType", "zonefileSpec", "zoneFilenameSource", "zoneFILEFilename", "zoneDirName", " zoneFilePath", "zonefileNames", "zoneFileNames", "zoneFilesChain", "ZonefileName", "ZoneFileName", "ZoneFileFilename", "zoneFileSource", "zoneFilenameSpec", "zonefileName"], "zoneids": [" zoneoids", "zaIDs", "zipnames", "zanaires", " zoneIDs", "zipids", "ziplines", "tzoids", "znames", "elementids", " zonecodes", "zlines", " zonenames", "elementlines", "zaoids", "zoneuploads", "zipIDs", "tzIDs", "zcodes", " zonelines", "elementcodes", "elementuploads", "zonecodes", "zonenaires", "zonenames", "zonelines", "zIDs", " zoneuploads", "tzids", " zonenaires", "zuploads", "zids", "zaids", "tznaires", "zoneoids", "zoneIDs"], "url": ["Url", "name", "char", "ret", "this", "loader", "r", "cl", "mount", "file", "lb", "log", "resource", "ssl", "build", "bel", "user", "result", "f", "dl", "base", "uri", "web", "nl", "http", "sl", "q", "rl", "str", "ll", "browser", "ref", "loc", "rel", "l", "open", "lr", "URL", "ls", "ur", "ul"], "lnr": ["olnn", "olnr", "lnrar", "lenr", "nlp", "linr", "nldr", "lenR", "lncr", "lnR", "cnr", "nlrar", "lenn", "lincr", "olnR", "nln", "linp", "nlr", "olndr", "lnn", "lendr", "lnp", "lndr", "cncr", "nlcr", "linrar", "cnp", "cnrar", "nlR"], "line": ["link", "sequence", "lane", "online", "liner", "ln", "le", "header", "string", "stroke", "ine", "part", "char", "continue", "display", "stream", "message", "sample", "entry", "e", "Line", "number", "file", "point", "log", "next", "LINE", "eline", "comment", "lin", "nl", "page", "cell", "frame", "ge", "range", "normal", "day", "code", "text", "chain", "phrase", "l", "section", "word", "block", "row", "inline", "net", "print", "style"]}}
{"id1": "1180878", "id2": "17580775", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "label": 0, "substitutes": {"fetchURLData": ["fectURLFrame", "fetchUrldata", "fectURLStream", "fectURLdata", "fetchGETdata", "fetchStringFrame", "fectUrlStream", "fetchGETData", "fetchStringData", "fectUrlData", "fetchURLStream", "fetchURLFrame", "fectUrlFrame", "fectURLData", "fetchUrlFrame", "fectUrldata", "fetchGETStream", "fetchGETFrame", "fetchURLdata", "fetchUrlStream", "fetchStringdata", "fetchUrlData", "fetchStringStream"], "url": ["mail", "Url", "name", "link", "html", "pl", "path", "domain", "lim", "string", "full", "pattern", "xml", "mount", "cl", "file", "location", "b", "log", "gl", "ssl", "host", "resource", "default", "dl", "base", "uri", "web", "nl", "http", "sl", "el", "sql", "ll", "address", "ref", "https", "loc", "rel", "l", "null", "URL", "print", "ls", "ur", "ul"], "proxyHost": ["serverhost", "proxyName", " proxyhost", "roxyHost", "roxyUrl", "slaveCheck", "proxyUrl", "proxyOver", "slaveUrl", "proxyCheck", "ProxyHost", "roxyAddress", "slavehost", "slaveHost", "slaveLabel", "Proxyhost", "serverPort", "proxyAddress", "roxyOver", "slaveOver", "roxyCheck", "ProxyName", "serverName", "ProxyUrl", "ProxyLabel", " proxyOver", "proxyLabel", "proxyhost", "roxyhost", "roxyLabel", "serverHost", " proxyAddress", " proxyCheck", "slaveAddress", " proxyName", "ProxyPort"], "proxyPort": ["aliasHost", "serverAddress", "proxyPORT", "aliasPort", "aliasAddress", "Proxyport", "ProxyPORT", "ProxyHost", "serverPORT", " proxyport", "aliasport", "serverPort", "proxyAddress", " proxyPORT", "serverport", "serverHost", " proxyAddress", "proxyport", "ProxyPort"], "con": ["pc", "cons", "cgi", "cs", "conn", "go", "ln", "bc", "ver", "ocon", "ain", "comm", "const", "cc", "pan", "act", "xc", "rec", "ex", "don", "mo", "connect", "pen", "lock", "cmd", "syn", "cos", "cone", "fin", "func", "close", "ran", "col", "conv", "cover", "cal", "call", "fc", "c", "cont", "po", "non", "conf", "cond", "nc", "com", "ctrl", "CON", "cur", "canon", "en", "gate", "bo", "un", "proc", "cf", "client", "open", "Con", "sub", "connection", "dial", "co", "fac", "Conn", "trans", "cat", "mc", "can", "cp", "cn"], "is": ["im", "bits", "are", "cs", "ip", "init", "ois", "ri", "iss", "ts", "bs", "rs", "si", "isin", "ps", "as", "gets", "isa", "dis", "sis", "iso", "sys", "Is", "i", "isf", "ys", "ris", "es", "IS", "xs", "isp", "abs", "fs", "bis", "its", "in", "ios", "ims", "ms", "isl", "ins", "us", "ains", "ists", "ais", "iris", "eps", "was", "os", "iter", "s", "isc", "oss", "mis", "isi", "ist", "has", "lis"], "u": ["tu", "ue", "up", "U", "su", "uj", "ui", "g", "ru", "ut", "iu", "uv", "uid", "i", "uf", "pu", "user", "lu", "c", "bu", "uri", "hu", "mu", "uu", "fu", "eu", "cu", "us", "au", "nu", "o", "un", " nu", "ud", "yu", "ur", "uni", "ul", "ou"], "proxy": ["port", "zip", "link", " prox", "timeout", "cache", "pin", "server", "ip", "go", "domain", "cas", "roxy", "version", "pse", "x", "socket", "pool", "pipe", "via", "pointer", " proxies", "slave", "pro", "py", "cone", "alias", "ssl", "host", "profile", "embed", "map", "password", "library", "translation", "echo", "project", "phone", "xy", "base", "po", "prime", "PRO", "web", "http", "ping", "browser", "pre", "address", "https", "bo", "jp", "friend", "client", "policy", "Proxy", "null", "shadow", "connection", "pi", "token", "aco", "gp", "cp", "pe", "XY"], "baos": ["baOs", " baoss", "bao", "naoss", "poose", "BAo", "naos", "aois", "aooS", "bais", " bao", " baose", "naows", "baows", "BAoss", " baows", "baose", " bais", "aoos", "nao", "baOS", "aoOS", "BAows", "BAose", "BAOs", " baOS", " baOs", "baoS", "vaoS", "poOs", "vaos", "poo", "vaOS", "BAos", "baoss", "vais", " baoS", "poos"]}}
{"id1": "19738435", "id2": "14194234", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "    private String File2String(String directory, String filename) {\n        String line;\n        InputStream in = null;\n        try {\n            File f = new File(filename);\n            System.out.println(\"File On:>>>>>>>>>> \" + f.getCanonicalPath());\n            in = new FileInputStream(f);\n        } catch (FileNotFoundException ex) {\n            in = null;\n        } catch (IOException ex) {\n            in = null;\n        }\n        try {\n            if (in == null) {\n                filename = directory + \"/\" + filename;\n                java.net.URL urlFile = ClassLoader.getSystemResource(filename);\n                if (urlFile == null) {\n                    System.out.println(\"Integrated Chips list file not found: \" + filename);\n                    System.exit(-1);\n                }\n                in = urlFile.openStream();\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuffer xmlText = new StringBuffer();\n            while ((line = reader.readLine()) != null) {\n                xmlText.append(line);\n            }\n            reader.close();\n            return xmlText.toString();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"Integrated Chips list file not found\");\n            System.exit(-1);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"parse": ["link", "shape", "arse", "replace", "xml", "process", "se", "construct", "layer", "json", "file", "resource", "read", "parser", "build", "match", "service", "slice", "create", "load", "proc", "request", "transform", "document", "pair", "handle", "format"], "url": ["Url", "link", "name", "util", "conn", "path", "string", "char", "xml", "localhost", "u", "mount", "file", "location", "gl", "resource", "host", "ssl", "build", "parser", "id", "base", "dl", "abs", "uri", "github", "web", "http", "nl", "page", "sl", "el", "q", "sql", "str", "impl", "ll", "browser", "address", "ref", "https", "loc", "l", "open", "client", "term", "URL", "input", "document", "ls", "ur"], "target": ["name", "metadata", "group", "parent", "path", "other", "model", "pattern", "scope", "nt", "Target", "node", "container", "source", "layout", "resource", "context", "arget", "local", "record", "template", "root", "top", "result", "project", "type", "report", "instance", "object", "collection", "t", "table", "output", "component", "term", "to", "tree", "graph", "owner"], "parseURL": ["buildSR", "parseUrl", "arseSR", "buildUrl", "arseUrl", "arseURL", "parsePage", "buildPage", "buildURL", " parseUrl", "arsePage", " parseSR", " parsePage", "parseSR"], "connection": ["established", "Connection", "link", "character", "response", "conn", "writer", "still", "created", "socket", "connected", "description", "entry", "connect", "database", "cone", "session", "network", "ion", "resource", "context", "channel", "application", "result", "c", "uri", "communication", "command", "nc", "generation", "directory", "condition", "relation", "client", "open", "con", "position", "creator", "document"], "charset": ["chagnheet", "chactersheet", "chararsset", "charsat", "charaset", "CHARSet", "CHarsetter", "charsheet", "chacterset", "charsect", "chresset", "chARSets", "chARSetter", "CHarset", "chararsheet", "chreset", "chatsets", "chasheet", "chagnset", "charasheet", "CHarsets", "CHARSat", "charsetter", "cheresets", "chactersset", "chatsect", "charasET", "charasset", "chararsET", "charsets", "chactersetter", "chearsect", "chereset", "chearset", "chasset", "chresect", "cheresect", "charsET", "chearsets", "chagnet", "chARSat", "chactersET", "chagnET", "chatset", "chatsset", "CHARSets", "CHarsat", "chasET", "chactersat", "chresets", "cheresset", "chARSet", "chaset", "charsset", "chearsset", "chararset", "CHARSetter", "chactersets", "chactersect"], "reader": ["iterator", "writer", "reading", "inner", "stream", "loader", "message", "r", "entry", "layer", "event", "file", "source", "buffer", "resource", "read", "parser", "io", "builder", "rar", "data", "context", "processor", "handler", "uri", "driver", "ner", "red", "Reader", "client", "upper", "iter", "row", "input", "readable", "runner", "document"]}}
{"id1": "4164833", "id2": "21656668", "code1": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"buildDeb": ["buildDub", "buildAud", "BuildAud", " buildDub", " rebuildAud", "Builddeb", " rebuilddeb", " builddeb", "builddeb", " buildAud", "BuildDub", "BuildDeb", " rebuildDeb", " rebuildDub"], "debFile": ["debfile", "obfile", " debFilename", "debile", "audFilename", " debfile", "pkgFiles", "ubFile", "debFilename", "obFilename", " debile", " debFiles", "pkgFilename", "obFile", "audFiles", "ubfile", "ubFilename", "debFILE", "ubile", "debFiles", " debFILE", "audFILE", "obile", "pkgFile", "pkgFILE", "audFile"], "controlFile": [" controlFiles", "scriptfile", "controlChain", "ctrlLog", "controlFiles", "configFiles", "rolFILE", "controlfile", "dataChain", "rolfile", "configFILE", "configFile", "scriptFILE", "controlFILE", " controlChain", "ctrlfile", "rolFile", "ctrlFiles", "ctrlFILE", "ctrlFile", "datafile", "controlLog", "dataLog", "configfile", " controlfile", " controlFILE", "scriptFiles", "ctrlChain", "dataFiles", "scriptFile", " controlLog"], "dataFile": ["valueFILE", "DATAStream", "runFILE", " dataLot", " dataFiles", "helpfile", "byFile", "DataFiles", " dataList", "valueLot", "byFiles", "dataList", "runfile", "runSet", "byFILE", " dataSet", "dataStream", "DataStream", "datFILE", "dataTable", "DATAFile", "helpLot", "helpList", "dataFILE", "datfile", " datafile", " dataFILE", "datafile", "valueFiles", "valueFile", "DATATable", "DATAFiles", " dataTable", "runFile", "datSet", "byLot", "dataLot", "runList", "DataFile", "dataFiles", "runLot", "DataTable", "helpFile", " dataStream", "dataSet", "datFile"], "now": ["then", "off", "system", "first", "and", "present", "full", "after", "old", "current", " Now", "ow", "start", "date", "here", "fx", "aw", "zero", "NOW", "on", "num", "low", "sw", "from", "force", "time", "wait", "percent", "stuff", "java", " NOW", "today", "store", "set", "post", "cur", "age", "aj", "create", "loc", "always", "app", "length", "since", "www", "Now", "size"], "deb": ["pay", "del", "cmd", "debug", "fin", "dat", "web", "conf", "dep", "rob", "img", "gob", "ub", "req", "sub", "dan", " Deb", "stab", "iban", "cb", "def", "und", "cd", "mb", "jpg", "put", "bl", "download", "broad", "div", "bb", "report", "we", "com", "red", "dp", "pub", "debian", "compl", "gif", "fb", "aud", "prep", "comm", "sb", "de", "etc", "og", "bar", "dev", "av", "pkg", "db", "Deb", "cm", "dt", "desc", "be", "erb", "reb", "ib", "dm", "dec", "priv", "sd", "eb", "dl", "abs", "eg", "daily", "rel", "review", "ob", "decl", "df", "cp"], "control": ["cons", "comp", "system", "comm", "const", "cc", "current", "content", "connect", "cmd", "controller", "config", "ctl", "scroll", "controlled", "trl", "setup", "critical", "crit", "cont", "rol", "command", "cond", "cell", "form", "com", "rl", "ctrl", "console", "check", "ctr", "code", "ll", "Control", "history", "ro", "rel", "cm", "con", "roll", "core", "correct", "ca", "co", "rc", "compl"], "buffer": ["attribute", "sequence", "cache", "view", "shape", "document", "stream", "message", "memory", "sample", "stack", "database", "temp", "label", "number", "bridge", "variable", "resource", "buf", "function", "append", "context", "scroll", "template", "bar", "library", "match", "parse", "button", "result", "note", "batch", "base", "comment", "queue", "command", "page", "frame", "chain", "buff", "binary", "bo", "rule", "phrase", "history", "table", "length", "hold", "term", "iter", "paste", "block", "row", "Buffer", "print", "filter", "directory", "window", "absolute"], "read": ["len", "rd", "stream", "old", "reads", "io", "cont", "valid", "in", "text", "iter", "req", "count", "core", "seek", "end", "skip", "input", "reflect", "readable", "remove", "index", "ind", "pe", "READ", "est", "height", "bind", "config", "like", "start", "error", "report", "send", "depth", "red", "thread", "hold", "exec", "dd", "size", "raw", "then", "ip", "select", "find", "se", " Read", "rand", "through", "query", "ang", "push", "give", "val", "search", "mix", "draw", "load", "ro", "length", "ke", "ek", "print", "handle", "key", "each", "char", "add", "connect", "run", "close", "build", "match", "scroll", "check", "play", "write", "get", "word", "need", "pass", "reader", "fill"], "data": ["auto", "cache", "not", "image", "news", "ata", "bus", "def", "info", "database", "feed", "file", "div", "query", "debug", "internal", "bin", "dat", "next", "one", "video", "di", "error", "dev", "batch", "http", "meta", "valid", "mu", "good", "da", "normal", "help", "no", "test", "rel", "d", "db", "table", "share", "to", "DATA", "list", "na", "extra", "reader", "window", "raw"]}}
{"id1": "14865947", "id2": "12380475", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"execute": [" Execution", " evaluate", " command", "Exec", " executed", " resume", "process", " executions", "run", " Run", " executing", " eval", "Command", " parse", "Action", " operate", " executable", "command", " Exec", " dispatch", " interpret", " execution", " manage", "invoke", " executes", " proceed", "exec", " query"], "event": ["xe", " command", "Ev", "EE", " frame", " invocation", "E", " events", "ex", "se", "w", "ed", " Event", " EVENT", " environment", "ee", "de", "context", "command", "te", "frame", "t", "exc", "ae", "ce", "ev", "pe", "Event"], "shell": ["hl", "style", "theme", "html", "system", "ssh", "microsoft", "pool", "sh", "scope", "message", "grid", "ja", "stack", "sb", "lock", "detail", "cli", "query", "b", "buffer", "layout", "session", "quit", "h", "round", "sys", "template", "scroll", "root", "tab", "base", "search", "pty", "nl", "hell", "cell", "sql", "body", "console", "tools", "sol", "range", "help", "widget", "history", "l", "tool", "line", "tree", "kernel", "js", "screen", "windows", "fr", "bot", "window", "handle", "Shell"], "view": ["views", "html", "cv", "image", "version", "ui", "display", "v", "w", "View", "query", "vp", "buffer", "layout", "ve", "eye", "VIEW", "tv", "template", "see", "report", "web", "browser", "widget", "review", "iew", "block", "tree", "list", "row", "screen", "show", "vm", "document", "window", "ou"], "rootFolder": ["coverDirectory", "parentArea", "parentDir", " rootEntry", "RootEntry", " rootDirectory", "RootDir", "parentFolder", " rootDisk", "rootDirectory", " rootCategory", "rootArea", "RootDirectory", " rootDir", "parentDirectory", "rootCategory", "bottomLibrary", "rootEntry", "parentCategory", "rootDir", "coverDisk", "bottomDirectory", "parentEntry", "RootCategory", "rootLibrary", "RootArea", "coverLibrary", " rootLibrary", "bottomFolder", "rootDisk", " rootArea", "bottomDisk", "coverFolder", "RootFolder"], "dialog": ["Dialj", " Dialoc", "dloc", "choogs", "dialj", "clDialog", "callOG", "closer", "clog", "logoser", "dialDialog", "dliz", "callDialog", "selectig", "dialoser", "selectoser", "choOG", "selectog", "logDialog", "dialig", " Dialog", "callog", "clig", "choDialog", "dlog", "dializ", "dialoc", "logig", "selectDialog", "Dialoc", "Dialogs", "DialDialog", "DialOG", "choog", "Dializ", "logog", "Dialog", "dialOG", " Dialj", "dialogs", "callogs", " Dializ", "dlj"], "password": ["attribute", "clear", "response", "picture", "path", "key", "p", "string", "PASS", "pattern", "wd", "description", "message", "entry", "device", "expression", "database", "hello", "Password", "source", "query", "buffer", "data", "padding", "user", "comment", "login", "sword", "command", "prefix", "hash", "language", "address", "phrase", "definition", "table", "paste", "words", "word", "request", "shadow", "encrypted", "reset", "pass", "directory", "username", "secret", "raw"], "md5": ["MD7", "MD512", "MD2", " md6", " md2", "m3", "mm5", "m2", "mt5", "mm2", "mb5", "md3", "md4", "ma5", "md7", "mb512", " md512", "mt2", "mm6", "MD64", "mb2", "md512", "m4", " md64", " md7", "MD5", " md4", "md2", "ma2", "ma7", "m5", "mb4", "md6", "mt3", "MD4", "mm7", "MD3", "md64", "mt4", "MD6", "ma64"], "md": ["sm", "msg", "metadata", "dig", "magic", "mt", "cd", "mb", "MD", "nt", "dm", "dh", "mm", "mac", "od", "cmd", "ind", "bd", "de", "sd", "mod", "pd", "ld", "m", "det", "pdf", " Md", " dd", "pm", "rm", "hash", "ms", "mg", "red", "mn", "d", "nd", "pt", "dd", "mc", "dr", "ct", "mk", "df", "hd"]}}
{"id1": "15051083", "id2": "3745402", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getMessageTimests", "getMessagedigested", "getContentDigests", "getContentDigested", "getMessageDigests", "getContentDigse", "getMessageTimest", "getContentdigest", "getMessagedigests", "getContentdigse", "getMessageDigse", "getMessageDigested", "getContentDigest", "getMessagedigse", "getContentdigests", "getMessagedigest", "getContentdigested", "getMessageTimse", "getMessageTimested"], "digest": [" Digest", "mdested", "dependast", "Digest", " diggest", "dester", "digend", "drivergest", "modest", "hashester", "signested", " digast", "dest", " digested", "Digast", "Digester", "driverester", "signester", "signest", "Diggest", "hashested", "mdest", "diggest", "dependested", "signgest", "digast", "hashest", "modested", "digse", "mdester", "dependest", " digse", "digested", " Digend", "driverested", "dependester", "Digse", " digester", "Digend", " digestester", " digestest", " Digester", " digestested", "hashgest", "digester", "dested", "modester", "driverest", "Digested", "mdse", " Digested", "dend"], "node": ["remote", "attribute", "name", "link", "dependent", "child", "yn", "system", "inner", "process", "job", "entry", "run", "nn", "source", "query", "network", "missing", "resource", "host", "one", "root", "note", "Node", "role", "peer", "cell", "angular", "object", "post", "normal", "create", "binary", "element", "ne", "common", "open", "tree", "document", "n"], "external": ["remote", "name", "ternal", "intern", "obj", "outside", "secondary", "child", "any", "multiple", "this", "unique", "ex", "optional", "escape", "ns", "internal", "global", "local", "tern", "reference", "export", "express", "ext", " External", "exit", "complete", "qualified", "custom", "object", "External", "binary", "https", "foreign", "common", "get", "self", "extra", "note", "n"], "messageDigest": ["messageGuEST", "messageMixse", "MessageDigested", " messageDigested", "messageMixest", "essageDatese", "essageDigest", "MessageDigEST", "essageDateest", "messageGuest", "Messagedigest", "messagedigse", "messagedigested", "messageDigesting", "messageDesignest", "Messagedigested", "messageDateesting", "messageDighest", "messageDigse", "messageDesignested", "messagedigesting", "messageDigEST", "MessageDighest", "messagedighest", "MessageDigest", "messageMixesting", "messageGuested", "messageDateest", "messagedigest", "essageDigse", "essageDigesting", "messageDatese", "messageDesignEST", "messageGuhest", "messageDigested", "essageDateesting", "messageDesignse", "messagedigEST", "Messagedighest", " messageDigEST", " messageDigse", "MessagedigEST"]}}
{"id1": "15768167", "id2": "5035872", "code1": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "transferFile", " copyByte", " copyDir", " CopyFile", " CopyStream", "transferByte", "transferStream", "pasteFile", "pasteDir", " CopyByte", "pasteStream", " CopyDir", "pasteByte", "transferDir"], "in": ["inn", "im", "al", "inc", "up", "is", "it", "isin", "r", "din", "info", "irm", "file", "source", "b", "i", "gin", "on", "id", "from", "In", "el", "or", "ic", "ins", "en", "IN", "o", "l", "os", "input", "cin", "rin", "ar", "edIn", "ind"], "out": ["ch", "p", "it", "Out", "g", "v", "ex", "w", "u", "file", "b", "log", "err", "nin", "io", "serv", "j", "gt", "po", "ot", "help", "t", "at", "o", "ne", "l", "output", "os", "to", "s", "co", "outs", "OUT", "net", "n", "ou"], "sourceChannel": ["innerChannel", "siteChannel", "ourceChart", "ourceCh", "ourceChuck", "scopeChain", " sourceContext", " sourceCategory", "ourceCategory", "ourceListener", "sourceListener", "updateChuck", "innerVoice", "siteVoice", "scopeChan", "sourceStream", "seCategory", "resourceChannel", "privateChannel", "sourceChart", "singleChain", "SourceChain", "ourceChannel", "singleChannel", "serviceChan", "sourcechannel", "privateChuck", "innerCh", "singleChuck", "seStream", "siteSection", "ourceResource", "sourceChain", " sourceListener", "serviceChain", "sourceResource", "privateResource", " sourceChan", "ourceChan", "ourceSection", "updateChart", " sourceChain", "updateChannel", "sourceCh", " sourcechannel", "sourceSection", "SourceChan", "sourceChuck", "resourceListener", "scopeChannel", "ourceChain", "sourceContext", "sourceCategory", "SourceChuck", "innerSection", "sourceChan", "serviceChannel", "serviceChuck", "seChan", "resourceChan", "ourcechannel", "updateResource", "SourceChannel", "sourceVoice", "ourceContext", "ourceVoice", "privateChart", "scopeContext", " sourceStream", "resourcechannel", "ourceStream", "singleChan", "seChannel", "siteCh"], "destinationChannel": [" destrictionChannel", "destructureButton", " destinatedChan", "destinatorChan", " destinationCan", "destinantCow", "DestinationStream", "DestinatorChannel", "destinatedChannel", "destensionChannel", "destinationchannel", " destinatedCan", "destinatorChannel", "destructureChannel", "destinatechannel", "destinedChannel", "DestinatorChan", "destinedCan", "destinatedGate", "destrictionChannel", " destrictionButton", "destinantChannel", "destructureChan", "destinatorConnection", "DestinatorConnection", " destinatedGate", " destrictionCow", "destinatorchannel", "destinedConnection", "destationchannel", "destinationButton", "DestinationChannel", "destinateChannel", "destinedchannel", "destationConnection", "destrictionChan", "destinationGate", "destructureCow", "destinantChan", "destinateStream", " destinationCow", "destinyCow", "destationGate", " destinationChan", "destationChan", "destinatorStream", " destinationGate", "destinateChan", "destationCan", " destinatedChannel", "DestinatorStream", "destinatorCow", "destensionChan", "destinationChan", "Destinatorchannel", "DestinationChan", "destinyChan", "destinationConnection", "destationChannel", "destinatedChan", "destinedGate", "destinyChannel", "destinationCan", "DestinationCow", "DestinatorCow", "destinedChan", " destrictionChan", "Destinationchannel", "destensionCow", "destinatedCan", " destinationButton", "destensionButton", "destrictionButton", "destinationCow", "destinationStream", "destrictionCow", "DestinationConnection"]}}
{"id1": "13757855", "id2": "13783549", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"process": ["execute", "apply", "replace", "task", "display", "add", "run", "parse", "build", "processor", "call", "step", "project", "save", "Process", "create", "load", "loop", "proc", "write", "render", "transform", "processing", "filter", "handle", "format"], "tpl": ["ttopl", "terld", "topl", "timplug", "ttpl", "tpg", "turtle", " tplates", "ptpl", "timpl", "Tph", " turtle", "tspr", "atuple", "Tpl", "stplate", "otpl", "stbl", "tmpp", "tyPL", "templ", "stpg", "tPL", "ptbl", " tpp", "tembl", "tpp", "stopl", "itbl", "itPL", "tsurtle", "tyurtle", "otld", "typl", "ttplug", "itpl", "Tplate", "atld", " tplate", "terplate", "tplate", "tsbl", "stplug", "Tplates", "stpl", "ttpg", "Tspl", "ttph", "tplug", "timspl", "tph", "tpr", "ptld", "Tpp", "timpg", "atplate", " tbl", "stspl", "tmbl", "tspl", "Tld", "timbl", "timopl", "tmpl", "ptplates", "tsPL", "temPL", "tempr", "otplate", "tuple", "Tbl", "ttPL", "tld", "tplates", "itplate", " tld", "tmplate", "terpl", "tmplates", "tmPL", "atpl", " tuple", "TPL", "tbl", "timplate", "Tpr", "ttbl", " tPL", "teruple", " tph", "otbl"], "model": ["html", "parent", "M", "content", "node", "file", "product", "log", "Model", " Model", "data", "record", "project", "m", "base", "Document", "el", "models", "object", "md", " models", "module", "tree", "ml", "document"], "packageName": ["PackageClass", "pkgNames", "PackageRoot", " packageRoot", "viewname", "groupVersion", "groupFamily", "viewRoot", "viewClass", "packageNames", "groupNames", "packagename", "viewName", "packageFamily", " packageNames", "packageVersion", "pkgVersion", " packageClass", "PackageName", " packageFamily", "groupName", "pkgName", "packageClass", "packageRoot", "pkgFamily", "Packagename", " packagename", " packageVersion"], "outFileName": ["outFilename", "infileType", "outFNames", "outFileType", "outFilenameSize", " outFilenamename", "outStreamTime", "outFilenameTime", "outTableName", " outTableName", "outDirSize", "outFileSize", " outFilenamePath", "outTableChain", "outfileNames", "outFilenameName", "outImagePath", "outFilenamename", " outfileNames", "outStreamPath", "outfileTime", "outDirName", " outFileTime", "outDirTime", " outFilenameName", "outfileName", "outFilenamePath", "infileName", "outTableType", "outStreamType", "outfileType", "inFileTime", "outFileChain", " outFileType", "outTableTime", "infileNames", "outFileNames", " outFilePath", "infilePath", " outfileName", "outFPath", " outFilenameType", "outfileChain", "inFileName", "outFilenameChain", "outfilename", " outFileNames", " outFilenameChain", " outfilename", " outFileChain", "outFname", "outFilenameType", "outFileTime", "inFilePath", "outImagename", "outFName", " outfilePath", " outTableTime", " outFilenameSize", " outTablePath", "infileTime", " outTableSize", "outTablePath", " outFilename", "outDirPath", "outFilenameNames", "inFileType", "inFileNames", "outStreamNames", "outImageName", "outfilePath", "outImageSize", " outFileSize", "outFilePath", "outStreamName", "outTableSize", "outTablename"], "xsltParam": ["xsltParameter", "xsslParam", "xltParameter", "xsqlParam", "xltConf", "xsslConf", "xsslParameter", "xsmlParam", "xmlParam", "xsltConf", "xltParam", "xsqlParameter", "xmlConf", "xsmlParameter", "xsqlConf", "xsmlConf", "xmlParameter"], "artifact": ["artifacts", "artificial", "anificate", "ardificate", "ardificial", "artificate", " artificial", " artifacts", " artificate", "Artifacts", "ardifact", "anifacts", "partifact", "anificial", "arifact", "partifacts", "anifact", "Artifact", "arifacts", "ardifacts"], "destinationPath": ["destationDir", "estinationName", "destinerDir", "desturationpath", "desturationPath", " destinationTarget", " destociationDisk", "estinationKey", "desticationDir", "descositoryHost", "destATIONPort", "destociationHost", "destATIONPath", "destinationAt", "estinationPoint", "identinateKey", "destacementTime", "identinatePath", "destinatedTarget", "destificationLocation", "DestinationLocation", "estationPath", "estionPATH", "estationDir", "destinatePart", "destinationPoints", "destinationDisk", "destinatorPoint", "DestensionPath", "generinationAt", "destinationTime", "destinatorPath", "origininatedNow", "destregationpath", " destociationpath", "DestensionHost", "destificationDir", "destinationTemp", "DestensionTemp", "DestensionPod", "generinatePath", "destinoName", "destionPATH", "destinationName", "DestinationTemp", "destinateForm", "destinationJar", "chaininatedDisk", "desturationJar", "destociationPoint", "destinatedDisk", "destinatorParent", "destinantPod", "origininationForm", "generinateJar", "destinateLocation", "destinatedDriver", "destinateInfo", "destinerPart", "destesticSystem", "estinationHost", "destinatorpath", "estinationPATH", "destinateChain", "chaininationHome", "generinationSystem", "destinateUrl", "destinationForm", "destinatePath", "destinoTime", "estionPath", "destionpath", "destinantPath", "destositoryParent", "DestinationHost", "destinateNow", "delinationLog", "delinatePoints", "destociationHome", "destinateAt", "estinoPath", "destitutionPATH", "destitutionPoint", "destinerJar", "delinateForm", "destociationDisk", "destinationParent", "origininatedPath", "termininerTarget", " destinationpath", "generinationPath", "descinationParent", "destationPart", "identinateChain", "destinatedKey", "desticationPath", "destinateSystem", "destigationPath", "destinerSystem", "destacementKey", "DestinationPoint", "destesticJar", "destinationLocation", "destinationPATH", "chaininationDisk", "termininationJar", "delinationPoints", "destositoryPort", "destesticAt", "destinationpath", "destinatorPort", "destinationPart", "estinoKey", "estinoTime", "destationPath", "destinateKey", "destinateDir", "DestensionDir", "destensionTemp", "descinationPort", "destacementPath", "destinatorChain", "destregationDisk", "estinationDir", "delinationPath", "destinoHost", "destociationTarget", "chaininatedDriver", "estinationpath", "destinerAt", "destensionPath", "destociationLog", "destATIONParent", "DestinationPath", "destinationUrl", "termininationPath", "chaininatedPath", "destinatedPath", "destinationPort", "termininationTarget", "destositoryHost", "identinationChain", "generinateAt", "destationUrl", "destinerTarget", "termininationpath", "destinerpath", "destinationHost", " destociationPath", "destregationTarget", "origininationChain", "destinationLog", " destinationDisk", "destrancePoints", "descinationPath", "destensionHost", "destinateName", "destationHost", "estionpath", "destranceForm", "descinationHost", "generinateSystem", "DestificationPath", "destionPoint", "destinatorPATH", "destinatePoints", "destinationTarget", "destinoDir", "destigationNow", "destensionPod", "destinerHost", "destinationKey", "estinationPart", "destinoPath", "destinatedInfo", "destinatorHost", "estinationTime", "destacementName", "destitutionPath", "DestensionPoint", "destinationPod", "destinantTemp", "DestinationDir", "destensionPoint", "DestificationDir", "DestinationUrl", "delinatePath", "origininationPath", "origininationNow", "chaininationPath", "DestinationPod", "destventionDriver", "descositoryParent", "destinatedHome", "desticationPod", "destinationDir", "destranceLog", "descositoryPath", "destensionDir", "identinationKey", "destinateLog", "destinationInfo", "destventionPath", "destventionDisk", "estionPoint", "termininerPath", "generinationJar", "identinationPath", "desticationTemp", "delinateLog", "chaininationDriver", "destificationUrl", "destrancePath", "destinatepath", "destociationDriver", "destociationPath", "destinateJar", "destinationPoint", "chaininatedHome", "destventionHome", "destinationChain", "identinateInfo", "delinationForm", "destationLocation", "destATIONHost", "destinateTarget", "identinationInfo", "destinantDir", "destinateHost", "desturationTarget", "termininerpath", "destociationDir", "destitutionpath", "destociationPoints", "destinatedForm", "destociationForm", "destinationNow", "destigationForm", "destinatedNow", "termininerJar", "destinatedpath", "destinationDriver", "descositoryPort", "destinationSystem", "estationHost", "destociationpath", "destinatedChain", "origininatedChain", "destinoKey", "destositoryPath", "estinationPath", "destinateTime", "destionPath", "destinoPoint", "estinoName", "destigationChain", "destinatorKey", "destinationHome", "destregationPath", "estationPart", "DestificationLocation", "destinerPath", "destesticPath", "origininatedForm", "destificationPath", " destociationTarget", "DestificationUrl", "destinatorInfo"], "in": ["inner", "r", "din", "info", "w", "file", "bin", "i", "io", "id", "f", "m", "c", "In", "ins", "t", "IN", "o", "d", "doc", "l", "input", " IN", "reader", "n"], "out": ["msg", "obj", "println", "up", "cache", "ln", "conn", "go", "ch", "writer", "p", "it", "Out", "inv", "inner", "ex", "v", "nt", "w", "outer", "aos", "dis", "oe", "e", "cmd", "u", "file", "nr", "all", "log", "err", "sys", "ger", "b", "io", "gen", "f", "c", "res", "report", "cfg", "conf", "cn", "or", "ins", "t", "o", "l", "write", "output", "gr", "client", "con", "null", "os", "s", "to", "list", "co", "screen", "OUT", "outs", "net", "print", "can", "n", "raw", "ou"], "root": ["name", "Root", "println", "group", "child", "parent", "initial", "p", "New", "def", "Template", "scope", "se", "r", "parents", "node", "json", "config", "start", "de", "context", "roots", "data", "id", "dump", "m", "_", "impl", "chain", "create", "ok", "table", "dir", "tree", "graph", " roots"]}}
{"id1": "15018553", "id2": "4118412", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["unccrypt", "enccrypt", "Encode", " encode", " encrypted", " enccrypt", "uncrypted", "encode", "Enccrypt", "Encrypted", "uncrypt", "Encrypt", "uncode", "encrypted"], "text": ["name", "url", "msg", "TEXT", "path", "p", "string", "tx", "x", "now", "act", "select", "pattern", "v", "message", "nt", "content", "w", "title", "ut", "value", "source", "buffer", "read", "data", "translation", "password", "ext", "txt", "comment", "cont", "q", "form", "body", "str", "t", "code", "test", "phrase", "output", "word", "pt", "input", "th", "print", "document", "ct", "Text"], "md": ["msg", "metadata", "dig", "del", "cmp", "and", "cd", "mb", "MD", " cmd", "dm", "dh", "mo", "mm", "der", "od", "cmd", "grad", "ind", "mac", "mond", "bd", "de", "err", "h", "mod", "ad", "di", "pd", "ld", "m", "c", "det", "mode", " dd", " cd", "pm", "mp", "rm", "hash", "ms", "mg", "t", "mem", "img", "mn", "d", "pkg", "doc", "nd", "mand", "dd", "mc", "mt", "ct", "mk", "df", "hd", "sha"], "md5hash": ["md2hash", "md3hex", "md5cloth", "md512sum", "md5hex", " md2hex", " md5hex", "md3sha", "md2h", " md3sum", " md3hash", "md3sum", "md3cloth", "md2hex", "md512sha", " md3h", " md5Hash", " md5sha", "md5Hash", "md512Hash", "md2Hash", "md3h", " md2cloth", " md2sum", "md2cloth", " md3sha", " md5cloth", "md512hash", " md3Hash", "md2sum", "md5h", " md5sum", "md3hash", "md2sha", "md5sha", "md3Hash", " md5h", " md2hash", "md5sum", "md512h"]}}
{"id1": "9449064", "id2": "12490144", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    private void createJCoPluginProject(IProgressMonitor monitor, String sourceFileName, String pluginName) throws CoreException, IOException {\n        monitor.subTask(MessageFormat.format(Messages.ProjectGenerator_CreatePluginTaskDescription, pluginName));\n        final Map<String, byte[]> files = readArchiveFile(sourceFileName);\n        monitor.worked(10);\n        IProject project = workspaceRoot.getProject(pluginName);\n        if (project.exists()) {\n            project.delete(true, true, new SubProgressMonitor(monitor, 5));\n        } else {\n            monitor.worked(5);\n        }\n        project.create(new SubProgressMonitor(monitor, 5));\n        project.open(new SubProgressMonitor(monitor, 5));\n        IProjectDescription description = project.getDescription();\n        description.setNatureIds(new String[] { JavaCore.NATURE_ID, PLUGIN_NATURE_ID });\n        project.setDescription(description, new SubProgressMonitor(monitor, 5));\n        IJavaProject javaProject = JavaCore.create(project);\n        IFolder binDir = project.getFolder(\"bin\");\n        IPath binPath = binDir.getFullPath();\n        javaProject.setOutputLocation(binPath, new SubProgressMonitor(monitor, 5));\n        project.getFolder(\"jni\").create(true, true, new SubProgressMonitor(monitor, 5));\n        project.getFile(\"sapjco3.jar\").create(new ByteArrayInputStream(files.get(\"sapjco3.jar\")), true, new SubProgressMonitor(monitor, 10));\n        IFolder metaInfFolder = project.getFolder(\"META-INF\");\n        metaInfFolder.create(true, true, new SubProgressMonitor(monitor, 5));\n        StringBuilder manifest = new StringBuilder();\n        manifest.append(\"Manifest-Version: 1.0\\n\");\n        manifest.append(\"Bundle-ManifestVersion: 2\\n\");\n        manifest.append(\"Bundle-Name: SAP Java Connector v3\\n\");\n        manifest.append(MessageFormat.format(\"Bundle-SymbolicName: {0}\\n\", pluginName));\n        manifest.append(\"Bundle-Version: 7.11.0\\n\");\n        manifest.append(\"Bundle-ClassPath: bin/,\\n\");\n        manifest.append(\" sapjco3.jar,\\n\");\n        manifest.append(\" jni/\\n\");\n        manifest.append(\"Bundle-Vendor: SAP AG, Walldorf (packaged using RCER)\\n\");\n        manifest.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n        manifest.append(\"Export-Package: com.sap.conn.jco,\\n\");\n        manifest.append(\" com.sap.conn.jco.ext,\\n\");\n        manifest.append(\" com.sap.conn.jco.monitor,\\n\");\n        manifest.append(\" com.sap.conn.jco.rt,\\n\");\n        manifest.append(\" com.sap.conn.jco.server\\n\");\n        manifest.append(\"Bundle-ActivationPolicy: lazy\\n\");\n        writeTextFile(monitor, manifest, metaInfFolder.getFile(\"MANIFEST.MF\"));\n        final IPath jcoPath = new Path(MessageFormat.format(\"/{0}/sapjco3.jar\", pluginName));\n        IClasspathEntry jcoEntry = JavaCore.newLibraryEntry(jcoPath, Path.EMPTY, Path.EMPTY, true);\n        final IPath jniPath = new Path(MessageFormat.format(\"/{0}/jni\", pluginName));\n        IClasspathEntry jniEntry = JavaCore.newLibraryEntry(jniPath, Path.EMPTY, Path.EMPTY, true);\n        javaProject.setRawClasspath(new IClasspathEntry[] { jcoEntry, jniEntry }, new SubProgressMonitor(monitor, 5));\n        StringBuilder buildProperties = new StringBuilder();\n        buildProperties.append(\"bin.includes = META-INF/,\\\\\\n\");\n        buildProperties.append(\"               sapjco3.jar,\\\\\\n\");\n        buildProperties.append(\"               jni/,\\\\\\n\");\n        buildProperties.append(\"               .\\n\");\n        writeTextFile(monitor, buildProperties, project.getFile(\"build.properties\"));\n        exportableBundles.add(modelManager.findModel(project));\n    }\n", "label": 0, "substitutes": {"readExp": ["readexp", "readLoc", "readExpress", "ReadEXP", "readerLoc", "passExp", "readerEx", "readExpl", "Readexp", " readExpl", "ReadEx", "passexp", "checkExpl", "readProp", "passExpress", "readerExp", " readLoc", "checkExp", "passExpl", "readerexp", "checkexp", " readProp", " readexp", " readExpress", "ReadProp", "readerEXP", "readEx", "checkExpress", "readerProp", " readEXP", "ReadExp", "ReadLoc", "readEXP", " readEx"], "writeExp": ["writeEv", "writeExt", " writeexp", " writeXP", "riteConf", "writeexp", "riteEXP", "riteReg", " writeEv", "updateExp", "applyEx", "writeXP", "writEXP", "writEx", "applyEXP", " writeExt", "writexp", "writExp", "applyXP", " writeReg", "updateEv", "riteExt", "writeEx", "writeReg", "updateReg", "riteExp", "writeConf", " writeConf", "writeEXP", "updateExt", "riteEv", " writeEXP", "writXP", " writeEx", "writConf", "applyExp", "riteexp"], "expFile": [" expFILE", "Expfile", "exFile", "docPlace", "mxFile", "repPath", " expPlace", "docField", "expDir", "repFILE", "exprName", "exfile", "exprDir", "docFILE", "exprFile", "exFILE", "expName", "ExpDir", "exFilename", "expPath", "ExpFile", "xpFiles", "expPlace", "exprFilename", "xpPath", "xpFILE", "mxName", "xpfile", " expfile", "exPlace", "expFILE", "xpFile", "xpField", "expFilename", "mxFILE", "mxFilename", "xpFilename", "xpName", "exFiles", "docFile", "docFilename", "exprfile", " expDir", " expFilename", " expFiles", "repFile", "exprFILE", "expfile", "expField", "expFiles", "repField", "docPath"], "exp": [" np", " resp", "obj", " est", " expansion", "comp", " ep", "ef", "pp", "resp", "EXP", " dj", " expanded", "comm", "lim", "def", "expr", " xp", " ne", "eq", "ps", "ox", " inst", "expression", "acc", "ent", " imp", "esp", " op", "plus", "bed", "opt", " disp", "push", "inst", "dem", "wx", " sc", "imp", "Exp", "zero", "isp", "ext", "ez", "f", " exc", "rep", "raw", " extr", "expl", " vec", " doc", "nz", "ev", "pr", "jp", "prov", "xp", "eps", " expand", "sc", " exponent", " lim", " expr", " ev", "pl", "inf", " rap"], "fi": ["ni", "xf", "ri", "mi", "ffe", "zo", "fif", "phi", "gi", "wi", "eric", "si", "ini", "uti", "FI", "ista", "fty", "i", "cci", "ti", "ci", "fa", "zi", "osi", "obi", "aci", "lf", "flo", "ei", "uci", "qi", "ico", "ki", "iri", "fe", "Fi", "pi", "isi", "ati", "abi", "ii", "li"], "oi": ["ni", "bi", "odi", "uo", "ri", "ivo", "mi", "eric", "ini", "ami", "uti", "oni", "avi", "igi", "iso", "obo", "i", "ovi", "ti", "ci", "ori", "io", "multi", "rio", "eni", "osi", "obi", "bis", "oa", "flo", "ei", "ta", "ico", "uci", "ki", "iri", "ita", "vi", "asi", "ink", "isi", "uta", "ati", "oin", "ii"], "jf": [" jF", "djfd", " jif", "jsxf", " jsf", "jjc", "jcsf", "jcfm", " jbf", "Jfd", "jssf", "jcxf", "jb", "jjv", " jb", "bjfm", "jjfm", " jv", " jfp", "jbf", "jxf", "jfd", "jackxf", "jackfd", "Jsf", "Jfx", "jcf", "jjF", "gc", "djbf", "jc", "jjfp", "jjif", "Jb", "jfp", "jF", "jjfc", "Jbf", "jif", "jackbf", "jsbf", "jfm", "jackf", " jfm", "JF", "gfm", "gf", "Jxf", "jjf", "bjv", "djf", "Jfm", "jfx", "Jf", "djxf", "gfc", "bjfp", " jfc", "jv", "bjf", "jcfx", " jfx", " jc", "jfc", "jsf", "jcb", " jxf", "Jif"], "sp": ["sm", "pl", "pp", "span", "p", "sk", "si", "sh", "ps", "se", "sb", "ep", "esp", "vp", "so", "par", "ap", "bsp", "sg", "sam", "bp", "isp", "sw", "sv", "lp", "asp", "spr", "space", "rep", "osp", "st", "SP", "op", "sf", "spe", "jp", "pb", "sc", "Sp", "pt", "spl", " esp", "cp", "tp"], "e": ["name", "p", "it", "E", "x", "v", "a", "w", "ee", "event", "i", "f", "m", " ev", "el", "t", "er", "d", "fe", "s", "re", "ie", "ev", "ed", "n", "pe"], "fo": ["tto", "xf", "uo", "ooo", "ato", "folio", "tf", "opa", "zo", "fif", "wi", "mo", "eno", "oe", "FO", "so", "obo", "io", "ti", "hea", "uf", "fa", "olf", "po", "flo", "ico", "ki", "bo", "ro", "lo", "o", "cf", "tif", "wo", "co", "aco", "wt", "oos"], "oo": ["uo", "ooo", "ato", "oes", "folio", "opa", "elo", "zo", "oid", "ola", "ox", "foo", "mo", "oe", "cro", "ko", "oooooooo", "so", "oto", "obo", "ora", "ollo", "oooo", "yo", "oco", "olo", "po", "oa", "flo", "aco", "ano", "ta", "ico", "bo", "ro", "lo", "o", "wo", "ilo", "goo", "aha", "ao", "co", "ero", "OO", "oos"], "ex": ["ix", "xe", "external", "six", "none", "su", "ac", "tx", "x", "act", "exe", "aux", "tex", "iox", "def", "rex", "ox", "Exc", "event", "cre", "de", "log", "Ex", "err", "sex", "es", "wx", "example", "ry", "ext", "EX", " exc", "el", "lex", "com", "ax", "or", "pex", "ic", "te", "status", "spe", "pers", "des", "ctx", "exc", "re", "except", "ception", "px", "hex", "nex"]}}
{"id1": "17583193", "id2": "23532405", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "label": 0, "substitutes": {"populateRecord": ["populateData", "populaterecord", "popupdateData", "populateRec", " populatesRecord", "populatedRecord", " populaterecord", "populatesrecord", " populatesData", "populatedRec", "popupdateRec", "popupdateRecord", "populatesRecord", " populateData", "populatedrecord", "populatesData", "populatesRec", "popupdaterecord", " populatesRec", "populatedData", " populateRec", " populatesrecord"], "attrIDs": ["addrIDs", "arrKids", "filterKids", "aaaENTS", "attEMS", "addrUES", "attById", "attrKids", "immIDs", "sortids", "sortKids", "sortID", "filterIDs", "attributeENTS", "attributeids", "attrID", "attIDs", "rmIDS", "attributeFS", "aaaIDs", "addrIDS", "adjIDS", "addrKids", "attFiles", "urgLS", "attributeID", "rmById", "rmID", "cmpIDS", "attributeLS", "attID", "permFS", "immID", "attrById", "sortFiles", "urgIDS", "sortIDS", "addrids", "aaaLS", "urgIDs", "attIDS", "rmIDs", "attrLS", "urgENTS", "aaaIDS", "adjIDs", "filterids", "errIDS", "adjUES", "attrFiles", "filterIDS", "attributeById", "attributeFiles", "attributeEMS", "attrUES", "permIDS", "arrids", "attrFS", "attrEMS", "attributeIDS", "attrIDS", "attributeIDs", "immIDS", "arrIDS", "attrENTS", "attributeKids", "errUES", "permIDs", "attFS", "errIDs", "permID", "arrIDs", "attrids", "immEMS", "cmpIDs"], "i": ["ix", "ni", "im", "p", "is", "phi", "ui", "v", "hi", "info", "io", "ci", "multi", "di", "f", "uri", "ic", "ei", "eu", "ity", "in", "qi", "iter", "I", "list", "my", "sim", "ia", "index", "ii", "ind", "name", "si", "e", "iu", "h", "ori", "xi", "m", "ik", "ki", "d", "ip", "ri", "g", "u", "cli", "\u0438", "err", "ir", "me", "zi", "c", "base", "q", "y", "ims", "ij", "chain", "o", "ai", "z", "ie", "print", "bi", "parent", "init", "any", "mi", "it", "x", "gi", "ji", "wi", "ini", "ami", "ti", "status", "us", "er", "l", "pi", "iti", "iq", "n", "li"], "sortIDs": ["successUES", "filterKids", "successTags", "servFiles", "parseIDs", "ortBs", "sortVs", "sortDOS", "shareDOS", "saveIE", "ortBS", "sortResults", "attrKids", " sortBs", "sortids", "sortKids", "ordEMS", "servEMS", "altIDES", "ortIDs", "sortEMS", "saveIDES", "sortID", "saveMS", "filterIDs", "sortBs", "servVs", " sortVs", " sortFiles", "successIDs", "sortUES", "servKids", "servResults", "altBytes", "shareIDs", "attrID", "saveIDs", "sortBytes", "sortIE", "updateIDS", "servTags", " sortids", "saveLS", "syncIDS", " sortEMS", "SortIE", " sortResults", " sortensions", "servMembers", "syncBytes", "sortDocuments", "servBS", "attrIE", "successIDS", " sortMembers", "ortids", " sortID", "SortLS", "parseIDS", "altEMS", "SortMembers", " sortIDS", "SortEMS", "successEMS", "successDOS", "altIDs", "SortIDs", "ordIDS", "filterDocuments", "servids", "sortFiles", "sortIDS", " sortBytes", "successIDES", "orderIDs", "ordids", " sortBS", "saveKids", "updateEMS", "ortDetails", "relationMembers", "servDetails", "attrLS", "ortResults", "relationIDs", "shareUES", "sortDetails", "ortID", "servensions", "sortIDES", "filterBs", "attrFiles", "filterIDS", "sortensions", "saveResults", "servIDS", "successKids", "orderDOS", "attrEMS", "filterIDES", "ortVs", "updateIDs", "parseIDES", "parseKids", "attrIDS", " sortIDES", " sortDocuments", " sortKids", "SortIDS", "ordIDs", "sortTags", "orderKids", "servIDs", "sortLS", "sortMS", "syncEMS", "relationIDS", "orderUES", "relationensions", "altIDS", " sortDetails", " sortTags", "attrMS", "shareKids", "syncIDs", "sortMembers", "saveIDS", "sortBS", "ortDocuments", "altKids", " sortMS", "servID", "attrids", "updateMembers", "ortIDS"], "j": ["ix", "obj", "other", "tr", "jump", "jl", "uj", "it", "ji", "x", "g", "v", "ja", "r", "job", "je", "e", "json", "jo", "b", "jc", "err", "k", "next", "oj", "beta", "m", "c", "kj", "q", "el", "J", "jet", "jac", "bj", "br", "y", "ij", "aj", "out", "dj", "er", "pr", "jp", "rel", "by", "adj", "l", "jit", "d", "bo", "jj", "pt", "js", "fr", "z", "n", "ind"], "temp": ["cum", "tem", "orig", "EMP", "tty", "tc", "current", "perm", "alt", "variable", "buffer", "tt", "unt", "read", "tmp", "Temp", "mod", " Temp", "template", "rem", "ptr", "txt", "fake", "prime", "tim", "wait", "mp", "set", "porary", "mem", "pre", "t", "thread", "test", "length", "term", " tmp", "tm", "emp"]}}
{"id1": "6625074", "id2": "15051083", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "label": 1, "substitutes": {"SHA1": ["sha2", "HSOne", "sha512", " SHAOne", "HS512", "HS1", "SHA2", "shaOne", " SHA2", "sha1", "SHAOne", "HS2", "SHA512", " SHA512"], "text": ["name", "url", "msg", "TEXT", "path", "string", "it", "tx", "act", "v", "message", "nt", "content", "title", "ut", "value", "event", "source", "buffer", "read", "data", "template", "translation", "password", "ext", "txt", "comment", "cont", "q", "sum", "form", "body", "str", "t", "code", "test", "doc", "output", "word", "pt", "input", "hex", "document", "print", "Text"], "sha1hash": ["sha1address", "SHA1Hash", "SHA2hex", "haoneHash", "ha1sum", "sha31hash", "SHA2Hash", "sha2hex", "sha2Hash", "sha31sum", "SHA1hash", "shaonehex", "sha2address", "sha2sum", "SHA2hash", "shaonehash", "sha1sum", "sha0sum", "sha1message", "SHA2sum", "ha1message", "sha2hash", "sha3Hash", "SHA1hex", "ha2Hash", "shaonesum", "sha0address", "sha3message", "ha2address", "SHA1sum", "sha31address", "haonesum", "ha1address", "shaoneHash", "haonemessage", "sha31Hash", "sha1hex", "sha1Hash", "haonehash", "shaonemessage", "sha3sum", "sha3hash", "ha1Hash", "ha2hash", "sha2message", "sha0Hash", "ha2sum", "ha1hash", "sha0hash"], "md": ["sm", "obj", "amd", " MD", "dr", "and", "mt", "cd", "MD", "dm", "dh", "ds", "mm", "der", "od", "cmd", "hd", "ind", "bd", "alg", "sd", "mod", "ad", "di", "ld", "m", "det", " Md", "pm", "rm", "hash", "ms", "mn", "d", "nd", "mand", "strong", "dd", "mc", "pdf", "mk", "df", "pd", "sha"]}}
{"id1": "822452", "id2": "14191679", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewrites", "readAndrewWrite", "readAndReprites", "readAndResWrite", "readAndResend", "readAndReprite", "readAndResrites", "readAndrewrites", "readAndRepWrite", "readAndrewend", "readAndRewWrite", "readAndResrite", "readAndRepend", "readAndRewend", "readAndrewrite"], "inFile": [" inFilename", "outFilename", "InFile", "outfile", "inTime", "INTime", "inputPlace", "inFace", "INFILE", "initPlace", " infile", "docFILE", "initFilename", "inFilename", "inputFilename", "iTime", "INFile", "initFace", "INFace", "InFilename", "iFILE", "Infile", "infile", "INPlace", "docFilename", "docFile", "inputFile", "INFilename", "inPlace", "iFile", "docTime", "iFilename", "initFile", "inFILE", "inputFace"], "outFile": [" outFILE", "outFilename", "reportFile", "outfile", "reportFILE", "nameFile", "nameFilename", "checkfile", "toFile", "inFilename", " outFilename", "reportfile", "checkFile", "nameFILE", "checkFILE", "checkFilename", "reportFilename", "infile", "toFilename", "outFILE", "toFILE", "namefile", "tofile", " outfile", "inFILE"], "iis": ["diIs", " iisc", " iIS", "IIs", "Ii", "eis", "liIs", "diiss", " ii", "iisc", "dii", "liisc", " iIs", " iiss", "Iis", "iIs", "iiss", "liis", "aiis", "iiris", "aiIS", "Iiss", "iiIs", "aiIs", "iris", "iiisc", "liris", " iris", "eIS", "iiis", "eIs", "diis", "iIS", "ii"], "dcmParser": ["dpmStatement", " dcmLoader", "dmmparser", "DpmParser", "DpmReader", "dpmPar", "dmmmParser", "decmarser", "Dpmparser", "dfmLoader", "dmmReader", " dpmarser", "decmReader", "DcmReader", "dcommParser", "dpmParser", "dpmPrivate", " dcmAssistant", " dpmparser", "deromReader", "dmReader", "dcfStatement", "deromParser", " dpmAssistant", "DcmBuilder", "DcmAdapter", "dcomBuilder", "deromarser", " dpmParser", " dpmPrivate", " dcmStatement", "dmarser", "dcrparser", "dcomLoader", "dromReader", "dmmarser", "dmmParser", "dmmmparser", "dcomParser", "dcfReader", "dpmBuilder", "dgrPar", "dpmReader", "dromparser", "dcmStatement", "dcmPrivate", " dpmListener", " dpmStatement", "dmparser", "dpmLoader", "dfmReader", "drumPar", "dpmListener", " dcmarser", "dfmParser", "Dcmparser", "dgrReader", "dcmAdapter", "dmoduleAssistant", "dmmAdapter", "DcmPar", "dcmLoader", "dromListener", "dpcParser", "dpcReader", "dcrBuilder", " dcmReader", "dromarser", "dfmBuilder", "DpmBuilder", " dcmparser", "dpcAssistant", "dcmPar", "dcommListener", " dcmPrivate", " dcmBuilder", "decmParser", "dgrStatement", "decmparser", "dcmAssistant", "drumBuilder", "dcmListener", "dcommReader", "DcmParser", " dpmPar", "drumReader", " dpmLoader", "dmParser", "dcmReader", " dcmListener", "dcommAssistant", "dmodulePrivate", " dcmPar", "DpmAdapter", "dcomReader", "dcmarser", "dgrParser", "dpmparser", "dmmmReader", "dromParser", "DpmPar", "dpmAssistant", "dcfParser", "dcrParser", "dpmAdapter", "dromAssistant", "drumParser", " dpmBuilder", " dpmReader", "dpmarser", "dcfPar", "deromparser", "dpcPrivate", "dmoduleReader", "dmoduleParser", "dmmmAdapter", "dcmparser", "dcmBuilder", "dcrReader"], "ds": ["obs", "cs", "ws", "gd", "bs", "ods", "Ds", "rs", "tes", " DS", "ps", "drivers", "sets", "dh", "ns", "aos", "dx", "der", "DS", "hd", "bd", "sys", "ys", "ils", "gs", "sd", "dat", "ss", "es", "data", "uds", "xs", " des", "sv", "dl", "fs", "services", "ads", "eds", "its", "details", "in", "da", "ims", "ins", "dds", "pers", "vs", "d", "des", "db", "eps", "dos", "os", "dt", "s", "dq", "js", "outs", "qs", "dd", "hs", "ks", "ls", "as", "df", "pd"], "pdReader": ["vdWriter", "pedRunner", "xdHelper", "ddHelper", "tdParser", "pdParser", "dpLoader", "pdCar", "ddParser", "ddRunner", "vdReader", "pedReader", "pdRunner", "pdHelper", "ddLoader", "pedLoader", "pdLoader", "ddRead", "ddWriter", "hdReader", "dpReader", "ddReader", "vdHelper", "pedCar", "pdRead", "tdRead", "hdWriter", "xdReader", "xdLoader", "xdWriter", "dpRunner", "vdLoader", "ddCar", "dpCar", "hdRead", "hdParser", "tdWriter", "tdReader"], "out": ["obj", "cache", "conn", "p", "Out", "ex", "v", "cmd", "pos", "io", "one", "data", "res", "in", "str", "end", "list", "name", "auto", "msg", " err", "full", "writer", "cb", "inv", "pool", "opt", "on", "sw", "cfg", "we", "at", "gr", "os", "con", "oss", "outs", "screen", "OUT", "net", "raw", "cn", "up", "nt", "w", "outer", "ent", "all", "nr", "err", "tmp", "conv", "gt", "gen", "id", "c", "sum", "ins", "o", "output", "null", "co", "js", "desc", "ou", "go", "ch", "it", "inner", "aos", "flush", "sys", "log", "serv", "inter", "txt", "status", "t", "en", "client", "s", "to", "over", "n"], "dcmEncParam": ["dcmencMsg", "dmmencMsg", "dmmEncPar", "dmmEnNum", "dmmencNum", "dmmEncParam", "dcmEncVal", "dmmEnParam", "dcmEscNum", "dmmEncMsg", "dmmEnPar", "dcmDecCmd", "dcmEnParam", "dcmencParam", "dcmencPar", "dcmDecMsg", "dcmEnPar", "dcmDecParam", "dcmEscVal", "dcmEnNum", "dcmEncPar", "dmmencCmd", "dcmencCmd", "dmmEncVal", "dcmEnVal", "dcmencNum", "dcmDecNum", "dcmEncNum", "dcmEncMsg", "dmmEncNum", "dmmEncCmd", "dcmEscParam", "dcmEncCmd", "dcmEscPar", "dmmencParam"], "pdWriter": ["PDEditor", "pcWriter", "tdWriter", "dpEditor", "PDReader", "PDWrite", "pdWrite", "pidWriting", "PDWriter", "pdwriter", "dpReader", "dpWriter", "tdEditor", "pdEditor", "pidWriter", "pcWrite", "pcWriting", "pcwriter", "dpWrite", "pidwriter", "tdWriting", "tdwriter", "pidWrite", "pdWriting", "tdWrite", "tdReader"]}}
{"id1": "18782385", "id2": "17792212", "code1": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"saveFile": ["storeFiles", " saveFiles", "savePage", "saveFiles", "outputFile", "storefile", "outputFiles", "savefile", "outputPage", "storePage", " savePage", "storeFile", " savefile", "outputfile"], "window": ["port", "remote", "volume", "wall", "view", "where", "server", "flow", "wa", "go", "html", "ws", "now", "height", "env", "system", "wd", "this", "scope", "before", "message", "device", "stack", "w", "lock", "file", "event", "query", " Window", "buffer", "session", "context", "stage", "wx", "manager", "Window", "win", "fw", "button", "box", "hw", "driver", "http", "wait", "page", "we", "form", "frame", "draw", "console", "browser", "widget", "history", "Win", "doc", "client", "focus", "screen", "WIND", "th", "document", "gui"], "stream": [" status", " resp", " con", " form", " session", " dos", "is", " response", " screen", "aos", " error", "REAM", " context", " im", " enc", " steam", " console", "Stream", " fin", " zip", " upstream", " sock", " upload", "os", " din", " is", "ream", " streams"], "outputDoc": ["outputDec", "documentDoc", "OutputDocument", "OutputCode", "outputCode", "exportDoc", " outputCode", "displayDocument", "OutputMat", "putDocument", "putDoc", "outputMat", "outputDocument", "OutputDoc", "OutputDec", " outputDocument", "Outputdoc", "outputdoc", "exportCode", " outputdoc", "putMat", "documentDocument", "toDocument", "toDec", "toDoc", "putDec", "toMat", "displayDoc", "documentdoc", "exportDocument", "displaydoc"], "dtd": ["sdTD", "Dtd", "sdtd", " dpd", "ttm", "DTD", " dtm", "dpd", "dtif", "dhTD", "dtm", " dTD", "sdpd", "dTD", "ttif", " dtif", "dhtd", "dhtif", "ttd", "Dpd", "dhtm", "tTD"], "uiElement": ["uObject", "clielement", "tiObject", "uiEngine", "guiFrame", "guielement", "umiComponent", "uiEvent", "uEvent", "UITag", "uEmail", "UIEntry", "culement", "tiItem", "cliMember", "uiMotion", "uciEvent", "iuToken", "UIlement", "zuSecret", "UISecret", "uiSecret", "iulement", "uMember", "zuLink", "UIEngine", "uciBlock", "guiEntity", "cuSecret", "iuE", "guiEvent", "iuFunction", "uiToken", "uiBlock", "iuMotion", "iuFrame", "tiEngine", "uciFunction", "UIBlock", "iuElement", "umiToken", "iuelement", "cliElement", "uiEmail", "zuEmail", "wuEmail", "wuLink", "cuEntry", "uilement", "cliEmail", "tielement", "iuTag", "zuElement", "uiEntity", "iuEntity", "tilement", "guiTag", "ucilement", "uiEntry", "uiComponent", "umiSecret", "tiElement", "tiEntry", "cuToken", "uItem", "uiFrame", "iuEvent", "umilement", "umiEngine", "UIelement", "uiFunction", "uFrame", "uciElement", "uiObject", "uFunction", "iuItem", "cuComponent", "iiMember", "UIEntity", "ulement", "uE", "UIElement", "guiElement", "UILink", "cuElement", "uiE", "uciE", "iuComponent", "uMotion", "iielement", "iuObject", "UIE", "uiTag", "uelement", "uiItem", "wuSecret", "uiLink", "uciMotion", "UIEvent", "iiEmail", "uiMember", "wuElement", "UIEmail", "guiE", "umiEntry", "umiElement", "uielement", "iuBlock", "iiElement", "uElement"], "currentLFClassName": ["currentLEFClassPath", "currentLEFclassNames", "currentLWStyleConfig", "currentLFClassNames", "currentLEFclassName", "currentLFFullNames", "currentLFSystemNames", "currentLFClassClass", "currentLWClassConfig", "currentLFclassNames", "currentLFFullName", "currentLFClassPath", "currentLFDisplayNames", "currentLFclassSet", "currentLEFclassPath", "currentLFClassSet", "currentLFSystemClass", "currentLEFClassClass", "currentLFStyleConfig", "currentLFFullSet", "currentLFClassConfig", "currentLFclassConfig", "currentLFclassName", "currentLFDisplayPath", "currentLFSystemName", "currentLFSystemPath", "currentLWStyleName", "currentLFStyleNames", "currentLWStyleSet", "currentLFclassClass", "currentLFDisplayClass", "currentLWStyleNames", "currentLEFClassName", "currentLWClassName", "currentLEFClassNames", "currentLEFclassClass", "currentLFStyleName", "currentLWClassSet", "currentLFFullConfig", "currentLFStyleSet", "currentLFDisplayName", "currentLWClassNames", "currentLFclassPath"], "systemLFClassName": ["systemLFFFileNames", "systemLFScreenNames", "systemLEFClassName", "systemLFFClassString", "systemLFFileNames", "systemLFSystemString", "systemLEFClassPath", "systemLFFilename", "systemLFFFilePath", "systemLFClassPath", "systemLFclassname", "systemLFFileName", "systemLEFclassPath", "systemLFSystemNames", "systemLFFFileString", "systemLFScreenname", "systemLFclassName", "systemLFScreenPath", "systemLFClassNames", "systemLFClassString", "systemLFclassString", "systemLEFclassName", "systemLFFFileName", "systemLFFileString", "systemLFclassNames", "systemLFFClassName", "systemLFclassPath", "systemLFSystemName", "systemLFClassname", "systemLFFClassPath", "systemLFSystemPath", "systemLFFClassNames", "systemLEFClassNames", "systemLFScreenName", "systemLFFilePath", "systemLEFclassNames", "systemLEFclassname", "systemLEFClassname"], "mainWindowElement": ["MainWinElement", "mainScreenLE", "mainSessionelement", "MainWindowElement", "mainwindowPort", " mainWindowEntry", " mainWinE", " mainFrameEntry", "mainScreenEntry", " mainWindowLE", "mainWinUser", "mainWinPort", "mainWinelement", "mainWindowPort", "MainWindowPort", "mainFrameMENT", " mainWindowMENT", " mainFrameE", "mainWinEntry", "mainFramelement", "mainSessionE", "mainWindowEntry", " mainWinEntry", "mainWindowlement", "mainWindowLE", "mainWinMENT", "mainWinLE", "MainWindowEntry", "mainSectionE", "mainSessionElement", "mainWinE", "mainwindowE", "mainwindowElement", "mainwindowUser", "MainWindowE", " mainFrameMENT", "mainFrameEntry", "mainScreenE", "MainWinelement", "mainWindowMENT", " mainWinLE", "mainWindowE", "MainWindowelement", "mainWinElement", "mainFramePort", "mainFrameelement", "mainWinlement", " mainFrameElement", "mainSectionElement", "mainWindowelement", "mainSessionEntry", "mainFrameUser", "mainSectionEntry", "MainWindowUser", "mainFrameLE", "mainFrameE", "MainWinEntry", " mainFramelement", " mainWinElement", "mainScreenElement", "MainWinUser", "mainwindowEntry", "mainWindowUser", "MainWinPort", "MainWinE", " mainWindowlement", "mainFrameElement", "mainwindowMENT", " mainWindowE", "mainSectionlement"], "volumeElement": [" volumelement", "audioEntry", "volumeEntry", "voiceEntity", "volumelement", "vineelement", "audioEntity", "volumeEntity", "VolumeElement", " volumeEntry", "vineElement", "VolumeEntity", "uiEmail", "audioE", "musicE", "voicelement", "vineE", " volumeEntity", "voiceMember", " volumeEmail", "audioElement", "vinelement", "voiceEntry", "voiceelement", "musicEntry", "volumeE", "uiEntity", "volumeMember", "musicElement", " volumeMember", "musicMember", "VolumeEmail", "voiceE", "uiE", "volumeEmail", "VolumeE", " volumeelement", "volumeelement", " volumeE", "voiceElement"], "player": ["volume", " Player", "radio", "played", "movie", "pool", "display", "pipe", "loader", "sample", "layer", "pro", "file", "controller", "source", "profile", "video", "taker", "youtube", "user", "Player", "PLAY", "driver", "audio", "program", "worker", "peer", "console", "service", "lay", "playing", "play", "ser", "speaking", "uner", "er", "aster", " playing", "table", "position", "live", "score", "game"]}}
{"id1": "20247400", "id2": "3495460", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"in": ["inn", "inc", "up", "init", "is", "it", "and", "inner", "isin", "din", "info", "file", "ze", "source", "bin", "i", "io", "gin", "on", "from", "In", "check", "ins", "IN", "con", "ai", " din", "input", "rin", "cin", "net", "inf", "ind"], "out": ["name", "auto", "msg", "obj", "println", "ln", "other", "writer", "it", "Out", "ex", "r", "w", "outer", "cmd", "b", "log", "err", "sys", "io", "gt", "exit", "report", "we", "ot", "or", "check", "str", "ins", "t", "at", "o", "ne", "OU", "write", "output", "client", "line", "dir", "null", "os", "to", "oss", "con", "list", "screen", "OUT", "outs", "net", "print", "n", "ou"], "buffer": ["attribute", "sequence", "clear", "cache", "view", "key", "shape", "header", "display", "document", "message", "memory", "se", "sample", "stack", "flush", "database", "temp", "event", "b", "source", "bridge", "variable", "limit", "buf", "Buffer", "function", "append", "data", "template", "bar", "match", "channel", "available", "library", "processor", "result", "queue", "batch", "comment", "trace", "command", "pause", "buff", "binary", "history", "address", "phrase", "db", "table", "output", "length", "total", "iter", "position", "block", "component", "size", "filter", "window", "index"]}}
{"id1": "14820302", "id2": "5551393", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "label": 1, "substitutes": {"innerProcess": [" doRun", " innerHandle", "internalHandle", " inlineRun", "internalWork", " inlineHandle", " innerRun", "internalRun", " doHandle", " doWork", " doProcess", "internalProcess", " inlineWork", " innerWork", " inlineProcess"], "curi": ["cURI", "cpuri", "rcui", "curl", "cpu", "gcuri", "vcuri", "CURI", " cri", "cri", "lcuri", "ccumi", "cdu", "Curl", "ctURI", "gcui", " cdu", "pcdu", "gcdu", "cturi", "ctiti", "ciri", "pcumi", "Cri", "lcURI", " cris", "gcumi", " ciri", "rcdu", "ccris", " cumi", " cURI", " cui", "ccuri", "contpu", "conturi", "lciri", " curl", "cris", "cui", "mcURI", "cpiri", "lcri", "cpurl", "rcuri", " cpu", "mcri", "citi", "cpri", "Ciri", "contumi", "mciti", "vcris", "ctri", "Curi", " citi", "vcui", "pcpu", "rcumi", "ccui", "cumi", "contdu", "pcuri", "mcuri", "vcumi"], "regexpr": ["Regexfr", "reacepr", "regexPR", "rentaxPR", "reroxfr", "regexexpr", "fregexPR", "regexp", "rentaxexpr", "remapr", "revreexpr", "frentaxPR", "fregexpr", "cregexexpr", "Regexpr", "fregexexpr", "reroxpr", "remaPR", "remapre", "frentaxpre", "reactpr", "rentaxpre", "reactexpr", "remaexpr", "rentaxpr", "Regexp", "cregexPr", "regexpre", "reveloppr", "reveloppre", "cregexp", "revelopexpr", "reaceexpr", "reactp", "regexfr", "revelopPR", "frentaxpr", "fregexpre", "cregexpr", "revrePr", "reroxexpr", "reacePr", "reactfr", "reroxp", "regexPr", "Regexexpr", "revrep", "frentaxexpr", "reacep", "revrepr"], "cs": ["pc", "ces", "cons", "cas", "ws", "css", "ts", "bs", "cms", "cc", "rs", "cd", "cks", "ps", "ats", "tc", "CS", "ns", "Cs", "ck", "gc", "cos", "gs", "acts", "caps", "ss", "aches", "cer", "fc", "c", "fs", "sts", "res", "ctr", "nc", "wcs", "acs", "ms", "vs", "csv", "cf", "ctx", "sc", "cus", "rc", "js", "ics", "qs", "hs", "ks", "mc", "ls", "cp", "cn"], "digest": ["displayse", "Digest", "signist", " digum", " digist", "hashester", "diger", "dest", " digested", "Digester", "signest", "der", " diger", "hashse", "displayested", "mixest", "displayer", "mixse", "hashest", "columnum", "columnist", "digse", "signse", "Digist", "mixist", "Digum", "displayEST", "displayest", " digse", "dse", "displayester", "digum", "mixested", "digested", "Digse", " digester", "columnest", " digEST", "digEST", "Diger", "hashEST", "DigEST", "digester", "dist", "digist", "Digested", "signested"], "s": ["ws", "p", "is", "ts", "sq", "bs", "bytes", "rs", "ps", "ats", "reads", "ds", "ns", "gets", "sb", "e", "b", "S", "gs", "h", "ss", "es", "less", "sam", "c", "sv", "sts", "services", "fs", "space", "abs", "its", "sql", "ims", "ms", "ins", "t", "str", "sol", "https", "eps", "js", "qs", "hs", "ls", "prints", "has", "n"], "m": ["sm", "M", "p", "nm", "v", "dm", "mo", "mm", " M", "mac", "managed", "perm", "b", "gm", "i", "me", "om", "esm", "f", "mu", "rm", "md", "ms", "mem", "t", "d", "cm", "l", "met", "mr", "ma", "em", "tm", "vm", "mc", "mt", "n"], "newDigestValue": ["newDigistValue", "newDigumentValue", "newdigestedVal", "newDigestedValues", "newdigestedValue", "newDigseValues", "newdigestVal", "newDigumentV", "newdigistValue", "newdigestValue", "newDigestedData", "newDigestedVal", "newDigistData", "newDigestValues", "newDigumentValues", "newdigestValues", "newDigestV", "newDigestedV", "newdigestedValues", "newDigestedValue", "newDigseV", "newDigseValue", "newdigestV", "newDigestVal", "newDigseData", "newDigumentVal", "newDigistVal", "newdigestData", "newdigestedV", "newdigistData", "newDigseVal", "newdigistVal", "newDigestData"]}}
{"id1": "9687813", "id2": "8079516", "code1": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"getFileInputStream": ["newFileReadThread", "newFileStreamStream", "newFilesOutputStream", "newFileInputForm", "newFilesOutputForm", "newFileOutputForm", "newFileReadForm", "newFileReadStream", "newFileStreamForm", "newFileInputStream", "newFileInputFile", "newFileInputThread", "newFileStreamFile", "newFilesOutputFile", "newFileOutputThread", "newFileReadFile", "newFilesInputFile", "newFileOutputStream", "newFilesInputThread", "newFileOutputFile", "newFilesInputStream", "newFilesInputForm", "newFilesOutputThread", "newFileStreamThread"], "path": ["ix", "name", "link", "PATH", "ath", "key", "parent", "p", "string", "full", "select", "pattern", "mat", "clean", "this", "message", "entry", "w", "temp", "mount", "cl", "config", "location", "filename", "log", "join", "template", "txt", "cont", "form", "prefix", "set", "str", "text", "chain", "test", "kind", "pkg", "output", "dir", "Path", "pt", "route", "th", "transform", "print", "hex", "patch"], "is": ["tis", "bits", "im", "obs", "are", "ip", "init", "ois", "mi", "iss", "ts", "bs", "it", "ui", "rs", "si", "isin", "as", "info", "isa", "dis", "sis", "iso", "Is", "err", "i", "isf", "isal", "ris", "serv", "es", "IS", "isp", "fs", "sim", " are", "bis", "its", "in", "ios", "ims", "ms", "isl", "ins", "us", "vs", "ists", "ais", "iris", "ism", "nis", "get", "os", "ai", "mus", "oss", "isc", "mis", "can", "isi", "ls", "has", "lis"], "file": ["ile", "port", "name", "fp", "auto", "al", "link", "util", "mail", "le", "key", "File", "image", "full", "pool", "task", "job", "run", "e", "h", "resource", "local", "FILE", "bar", "library", "user", "f", "project", "base", "valid", "page", "object", "t", "chain", "out", "ref", "rule", "bo", "test", "spec", "load", "db", "table", "work", "open", "real", "null", "core", "to", "tree", "document", "be", "use", "handle"], "url": ["mail", "Url", "util", "html", "raw", "char", "mb", "r", "cl", "mount", "b", "gl", "ssl", "resource", "bb", "user", "f", "il", "dl", "uri", "web", "http", "nl", "sl", "el", "or", "rl", "fl", "impl", "str", "ll", "ref", "rect", "rel", "l", "null", "lr", "URL", "re", "ml", "ls", "ur", "ul"]}}
{"id1": "2022160", "id2": "6403868", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"write": ["port", "execute", "link", "fit", "writer", "find", "apply", "fail", "put", "process", "commit", "copy", "flush", "w", "connect", "writ", "run", "partial", "change", "log", "network", "walk", "rite", "read", "close", "next", "append", "export", "call", "wire", "sync", "batch", "see", "written", "save", "only", "send", "wait", "patch", "scale", "store", "set", "code", "Write", "create", "output", "get", "to", "render", "end", "size", "cycle", "print", "wrote", "writing", "register", "handle", "format"], "byteBuffers": ["byteCountters", "byteNamesers", "bytesPackerers", "byteIndexerers", "ByteBuffers", "byteOffer", "byteOffters", "bytesBuffators", " byteBuffusters", "bitBuffonents", "bytebuffodes", "byteFrags", " byteNamesines", "ByteBuffERS", "bitEnters", "ByteHeadrs", "byteCounters", "byteNamesERS", " bytePackers", "byteBytesERS", "byteBytess", " bytePackusters", "bytesPackators", "bytesHeadters", "bytesHeadered", "bytesHoldters", "bytesbufflers", "byteIndexators", "bytePackators", "bytebuffainers", "bytePacklers", "byteBuffines", "ByteHeadERS", "bytebufflers", "bytebuffERS", " byteBuffels", "byteEntrs", "bytePackters", " bytePacklers", "byteBuffrys", "bytePackrs", "bytePackainers", "byteHoldiers", "byteHeader", "bytesHeaders", "bytebuffines", "byteCombonents", "byteDeflers", "byteFragers", "byteEnters", "byteOrders", "byteBuffERS", " bytebuffters", " byteNameserers", "byteBuffonents", "bytesbuffrys", "byteBytesrys", " byteBufferers", "bitBuffrs", "byteOffered", "bitBuffers", "bytesBuffters", "byteCombers", " byteNamesers", " byteBuffs", "bytesBuffer", "byteBindERS", " byteDefERS", "bytebuffers", "bytesBufflers", "bytebuffiers", "byteBuffrs", "bytesBuffered", "bytebuffusters", "bytePackers", "bytesbuffers", "bytebufferers", "byteBufferines", "byteNamesines", "byteBuffiers", " byteBuffERS", "byteBuffters", "bitBuffters", "byteHolderers", "bytesBuffrys", "byteCountERS", "byteBufferlers", "byteEntters", "byteCorners", "byteCombters", " byteBuffainers", "bytebuffters", "bytesPackers", "bytesHoldERS", "byteHeadERS", "bytePackerers", " bytebuffERS", "byteBufferters", "bytePacker", "bitEntrs", "byteBytesers", " byteDefels", "ByteHeadered", "byteBufferERS", "byteHeadrs", " byteBuffines", " byteBuffters", "bytebuffs", "byteDefels", "bytebuffered", "byteBindodes", "byteHoldERS", "bytesbuffodes", "byteBinders", "byteBufflers", "byteBuffererers", " byteDeflers", "byteCountered", "byteBufferers", "byteHoldered", "byteCornerers", "byteBindlers", " bytebuffers", "bytesbuffs", "byteOffers", "byteCorniers", "byteBufferered", " byteBuffered", "bytesBuffodes", "byteBuffodes", "bitEntonents", "ByteBuffered", " bytebuffiers", "bytebuffrys", "bytesBuffs", "byteHoldters", " bytePacks", "byteHolders", "byteOrdrs", " bytePackainers", "byteWaitERS", "byteHeadters", "bytesHolders", "byteBuffels", " bytebufferers", "bytesBufferers", "byteOrdters", "byteBuffators", "byteIndexers", "bytesHoldered", "byteOrdonents", "byteBuffainers", "bytesPackrs", " byteBufflers", "bytePackered", "byteCombrs", "bytesBuffrs", " bytePackerers", "byteWaitainers", "bytePackrys", " byteDefers", "bitEntters", "bytesBuffers", "byteIndexrs", "byteBuffusters", "byteDefers", "bytePackusters", "byteEntonents", " bytebuffered", "bytesHeader", "ByteHeaders", "byteBufferels", " bytePackERS", "byteHeaders", "byteWaiterers", "bytesBuffERS", "byteFraglers", "bytePackERS", "ByteBuffrs", "byteCornters", "byteDefERS", " byteBuffiers", "byteFragusters", " byteNamesERS", "byteWaiters", "byteBuffer", "bytePacks", "bytesbuffERS", "byteHeadered", "byteBuffs", "byteNameserers", "byteBuffered"], "m_initialOutBuffer": ["m_finalOutputBuff", "m_initialoutCache", "m_InitialOutBuff", "m_initialEndLength", "m_initialInThread", "m_firstoutBuff", "m_initialInbuffer", "m_initialOutputBuffer", "m_initialOutLength", "m_currentInChannel", "m_currentoutCache", "m_initialInQueue", "m_currentOutBuffer", "m_initialByteBuffer", "m_initialNetBuffer", "m_currentoutBuffer", "m_InitialOutLength", "m_initialoutWriter", "m_finalOutputQueue", "m_initialNetThread", "m_InitialoutLength", "m_InitialOutCache", "m_initialNetQueue", "m_finalOutBuff", "m_currentoutBuff", "m_firstoutBuffer", "m_initialCheckBuff", "m_initialoutBuffer", "m_currentInBuff", "m_initialHostBuffer", "m_currentOutQueue", "m_initialOutChannel", "m_initialOutThread", "m_initialHostBuff", "m_finalOutQueue", "m_InitialoutCache", "m_firstOutBuff", "m_initialInLength", "m_currentOutCache", "m_initialCheckBuffer", "m_InitialoutBuff", "m_initialByteBuff", "m_initialInChannel", "m_initialOutputQueue", "m_firstoutWriter", "m_initialOutCache", "m_initialoutQueue", "m_initialCheckChannel", "m_initialCheckQueue", "m_initialByteWriter", "m_initialOutputThread", "m_currentoutQueue", "m_initialoutLength", "m_initialOutWriter", "m_initialOutputBuff", "m_initialOutbuffer", "m_currentInBuffer", "m_initialInBuff", "m_currentOutBuff", "m_initialHostView", "m_initialHostbuffer", "m_initialOutBuff", "m_currentOutChannel", "m_initialEndBuffer", "m_firstOutCache", "m_initialEndBuff", "m_initialInView", "m_finalOutThread", "m_firstoutCache", "m_finalOutputThread", "m_InitialoutBuffer", "m_initialEndCache", "m_firstOutBuffer", "m_firstOutWriter", "m_initialInBuffer", "m_finalOutputBuffer", "m_initialInWriter", "m_initialInCache", "m_initialOutView", "m_initialNetBuff", "m_currentInQueue", "m_finalOutBuffer", "m_initialNetCache", "m_InitialOutBuffer", "m_initialByteCache", "m_initialOutQueue", "m_initialNetChannel", "m_initialoutBuff"], "buffer": ["sequence", "cache", "server", "stream", "container", "holder", "builder", "context", "buf", "channel", "manager", "engine", "store", "bo", "table", "iter", "block", "tree", "list", "background", "document", "directory", "url", "timeout", "pool", "message", "stack", "source", "bridge", "Buffer", "processor", "button", "timer", "thread", "address", "connection", "row", "callback", "flash", "filter", "attribute", "response", "header", "memory", "database", "layer", "profile", "template", "bar", "queue", "batch", "comment", "base", "command", "chain", "loop", "length", "output", "null", "pair", "window", "iterator", "initial", "socket", "temp", "internal", "match", "map", "page", "buff", "binary", "phrase", "empty"], "buffers": ["ufers", "offers", "rendters", "buffings", " buffors", "bufards", "combers", "buffERS", " buffters", "ufERS", "combards", "comblers", "combERS", "ufors", "ufards", "holders", "holdERS", "buffors", "offters", "holdters", "bindERS", "renders", "uflers", "bufflers", "rendERS", "bufters", "rendlers", "bindlers", "ufters", "holdings", "bufings", "bufers", "offERS", "bindters", "binders", " buffings", "offors", "bufERS", " buffERS", "buffards", "buffters", "buflers"], "result": [" resulted", "response", "cache", "group", "other", "answer", "Result", "ver", "created", "true", "continue", "ret", "description", "process", "message", "r", "current", "progress", "json", "event", "success", "make", "product", "resource", "context", "reason", "results", "next", "profile", "data", "that", "match", "user", "error", "successful", "complete", "comment", "done", "see", "search", "res", "report", "role", "valid", "we", "status", "mate", "details", "cur", "ser", "load", "relation", "test", "output", "iter", "null", "request", "re", "runner", "diff", "pair", "wrapper", "uu"], "encrypted": ["sequence", "external", "other", "created", "confirmed", "temp", "ended", "internal", "secure", "channel", "context", "checked", "password", "error", "available", "engine", "chain", "verified", "armor", "finished", "table", "locked", "options", "flash", "extra", "selected", "secret"]}}
{"id1": "7872659", "id2": "536614", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": [" genCustRatingFileAndVideoIndexfile", " genCustRatingFileAndVideoIndexFile", " genCustRatingFileAndVideoindexFile", " genCustRatingFileAndMovieindexFiles", " genCustRatingFileAndMovieVersionTable", " genCustRatingFileAndMovieIndexfile", " genCustRatingFileAndVideoindexfile", " genCustRatingFileAndVideoIndexFiles", " genCustRatingFileAndMovieVersionFiles", " genCustRatingFileAndMovieIndexFiles", " genCustRatingFileAndVideoIndexTable", " genCustRatingFileAndMovieindexTable", " genCustRatingFileAndMovieIndexTable", " genCustRatingFileAndMovieVersionFile", " genCustRatingFileAndVideoindexTable", " genCustRatingFileAndMovieVersionfile", " genCustRatingFileAndVideoindexFiles", " genCustRatingFileAndMovieindexFile", " genCustRatingFileAndMovieindexfile"], "completePath": ["completeScript", "pletePath", "CompletePath", "completePod", "COMPLEDir", " completeDirectory", "totalLocation", " completesDir", "pleteLocation", "totalPod", "totalRoot", "completeNow", "COMPLELog", "fullRoot", "completeProject", "CompleteDir", "completeLog", "completeDir", "CompleteScript", "completeLocation", "pleteProject", "pletionDir", "CompleteLog", "COMPLEScript", "fullPod", "pleteNow", "totalPath", "pletionProject", " completeDir", "completeRoot", "pleteLog", "COMPLEPath", "completeDirectory", "CompleteDirectory", " completesLocation", " completeLocation", "CompleteLocation", "pletionPath", "pleteRoot", "pleteDir", "pleteScript", "pletionNow", "pletePod", " completesDirectory", "fullLocation", "fullPath", "CompleteNow", "CompleteProject", " completesPath"], "masterFile": ["currentName", "MasterName", "managerFilename", "managerfile", "completefile", "masterName", "MasterFilename", " masterPath", "masterPath", "managerFile", "masterFilename", "MasterFile", "Masterfile", "completeFile", "currentfile", " masterfile", "currentPath", "completeName", " masterFilename", "managerPath", "currentFile", "MasterPath", "masterfile"], "CustRatingFileName": ["CustRatingFileNames", "CustRatingFileType", "CustRankFilesInfo", "CustRatingTableNames", "CustRatingTablename", "CustRatingfileNames", "CustRatingfileName", "CustRatingFilename", "CustRatingFilesName", "CustRankFilesName", "CustRatingFilenameSet", "CustRatingFileSet", "CustRatingFieldName", "CustRatedfileSet", "CustRatedFileSet", "CustRatingfileSet", "CustRatingFileInfo", "CustRankFileInfo", "CustRatingfileType", "CustRatedFileType", "CustRatedFileName", "CustRankFilesname", "CustRatingFilesname", "CustRatingFieldname", "CustRatingFieldInfo", "CustRatingTableName", "CustRatingFilenameName", "CustRankFilesType", "CustRatingFilesInfo", "CustRatingTableType", "CustRankFileName", "CustRatedfileNames", "CustRatingFieldType", "CustRatedFileNames", "CustRatedfileName", "CustRatingFilesType", "CustRankFilename", "CustRatingTableSet", "CustRatingFilenameNames", "CustRatingTableInfo", "CustRatingFilenameType", "CustRatedfileType", "CustRankFileType"], "MovieIndexFileName": ["MovieIndexFileType", "MovieIndexFieldType", "MovieindexfileKey", "MovieindexFileNames", "MovieindexFileNumber", "MovieIndexFileNumber", "MovieindexFileType", "MovieIndexFILENames", "MovieIndexFILEType", "MovieIndexFILEName", "MovieIndexfileNumber", "MovieindexFileName", "MovieIndexfileName", "MovieIndexFileKey", "MovieindexFileKey", "MovieIndexfileNames", "MovieIndexTableType", "MovieindexfileType", "MovieIndexFieldName", "MovieIndexTableName", "MovieIndexFileNames", "MovieIndexTableKey", "MovieIndexFieldKey", "MovieIndexfileType", "MovieIndexTableNames", "MovieindexfileNumber", "MovieindexfileNames", "MovieIndexFILENumber", "MovieIndexFieldNames", "MovieIndexfileKey", "MovieindexfileName"], "inFile": ["outC", "localFILE", "outFile", "outfile", " inFILE", "INFILE", " infile", "INF", "INfile", "localC", "INFile", "outF", "localFile", "localfile", "infile", "INC", "inF", " inF", "inFILE"], "inC": ["outC", "outFile", "intC", "inputG", " inG", "inCL", "inputF", " inL", "intR", " inCL", "outG", "intCI", "outCL", " outL", " inCI", "outF", "iC", "iR", " inCS", " inR", " outC", "outL", " outF", "iCI", " outCL", "inputC", "inCS", "inputFile", "intCS", "inF", " inF", "inG", "inR", "iCS", "inCI", "inL"], "outFile1": ["outPage1", " outfile6", "outputFile1", "outputFileOne", " outfile0", "outPage6", "outFILE6", "outputFileOnce", " outfile2", "outputPage9", "outChannelOne", "outfile0", "outPage9", " outfile1", "outPage0", "outFile0", "outfile6", "outChannel9", "outfile1", "outfile2", "outChannelOnce", "outFILE2", "outputFile9", "outFILE0", "outFileOne", "outFileOnce", "outputPageOnce", "outFile9", "outPage2", "outFILE1", "outputPage1", "outChannel1", "outFile6", " outFile0", "outPageOnce", "outputPageOne", " outFile6", "outPageOne"], "outC1": ["outc2", "outFile3", "outR1", "outCB1", "outP1", "inC2", "inFile1", "outROne", "outR2", "outR3", "outCB0", "outPOne", "outC3", "outP3", "outCOne", "inC1", "outc0", "outCB3", "outFileOne", "inC0", "inC3", "outP2", "outCB2", "inFileOne", "outC0", "inFile2", "outc3", "inFile3", "outc1", "inCOne"], "outFile2": ["exChannel1", "outfileTwo", "outFile3", "outF0", "outTable2", "exChannel0", " outFile02", "outTableTwo", "outChannel2", " outFile3", "outfile0", "exFile3", "exChannel2", "outTable3", "outChannel3", "outFile0", "outfile2", "outfile1", "outTable02", "outF2", "exFile1", "outfile3", "outF3", "exFile0", "outfile02", "outChannel0", "outFileTwo", "outF1", "outChannel1", "outFile02", " outFileTwo", "exFile2", "exChannel3"], "outC2": ["allB22", "OutC4", "outR1", "outC4", "OutR2", "allB2", "outR2", "outR3", "outB22", "outR4", "outS22", "outC3", "outE4", "outB2", "OutR1", "outE3", "outM22", "outC22", "allB3", "outB3", "outBTwo", "allCTwo", "outE2", "outS3", "outCTwo", "outMTwo", "OutC2", "allBTwo", "OutR3", "outM3", "OutC3", "OutC1", "allC22", "outSTwo", "outM2", "outS2", "allC3", "outE1", "OutR4", "allC2"], "fileSize": ["FileName", "issueName", "issueSIZE", "baseSize", "fileSIZE", " fileSIZE", "baseName", "FileSize", "baseSIZE", "fileCount", "issueSize", "issueLength", "FileSIZE", " fileLength", "byteName", "baseCount", "byteSize", "byteSIZE", "fileLength", " fileCount", "fileName", "FileCount", " fileName", "FileLength", "byteLength"], "totalNoDataRows": ["totalNoDataSlues", "totalNoDataBoles", "totalNoDataSloles", "totalNoDataRecows", "totalNodataRecoles", "totalNoDataRocks", "totalNoDataSlocks", "totalNoDataRecues", "totalNodataRecocks", "totalNodataRecues", "totalNoDataRecocks", "totalNodataRecows", "totalNoDataBows", "totalNoDataSlows", "totalNoDataRues", "totalNoDataBues", "totalNoDataRoles", "totalNodataRows", "totalNoDataBocks", "totalNodataRues", "totalNodataRocks", "totalNodataRoles", "totalNoDataRecoles"], "mappedBuffer": [" mapperQueue", "MapedBB", "mapedFB", "mapperBuff", "mapperBuffer", "MapedBuff", "mressedFB", "MapperBuff", "MapedData", "mappedCounter", "matchedBuffer", "mappingData", "mmappingBuff", "mmappedBuff", "mmappingQueue", "mmappingbuffer", "mressedCallback", "mappedData", "maphFB", "mapedCallback", "mapedBuffer", "mappingCounter", " mapedCallback", "mapedData", "mappedFB", "MapedBuffer", "MapperBB", "mappingQueue", "mmappingBuffer", "mappingBuffer", "mattedBuff", "mapperQueue", "MappedData", "mattedData", "mappingBuff", "mapBB", "mattedBuffer", " mapperBuffer", "mappingbuffer", "mappedbuffer", "MappedBuff", " mappedCallback", "mressedBuffer", "MappedBB", " mapedFB", "mmappedBuffer", "mapBuffer", " mappedCounter", "mappedBB", "mappedQueue", " mapperCounter", "mapedBuff", "maphBuff", "matchedCounter", " mapperBuff", "mmappedbuffer", "mapBuff", " mappedBuff", "mressedBuff", "mapedQueue", " mappedFB", "maphCallback", "mappingBB", "matchedQueue", " mapedBuffer", "mapperCounter", "mattedBB", "mmappedQueue", " mappedQueue", "mapperbuffer", "MapperBuffer", "mapperBB", "mapedBB", "MappedBuffer", "mapedbuffer", "matchedBuff", " mapedBuff", "maphBuffer", "mappedCallback", "mappedBuff"], "startIndex": [" startPos", "StartPoint", "startPos", "StartPosition", "firstIndex", "initPosition", " startPage", " startInd", "endIter", "startindex", "Startindex", "startPage", "endPosition", "initindex", " startindex", "StartIndex", "endIndex", "currentPosition", "StartInd", "initIndex", "startIter", "startInd", "StartPage", "currentPoint", "currentPos", "firstPosition", "firstindex", "startPoint", " startPoint", " startIter", "StartIter", "endPage", " startPosition", "firstInd", "startPosition", "currentIndex", "StartPos"], "count": ["name", "counter", "amount", "first", "created", "find", "now", "act", "continue", "cloud", "order", "process", "add", "current", "info", "index", "max", "mount", "last", "number", "start", "i", "limit", "next", "ount", "user", "call", "id", "num", "result", "batch", "c", "type", "force", "coll", "conf", "sum", "ctr", "category", "status", "page", "check", "depth", "cast", "code", "length", "total", "con", "Count", "core", "list", "more", "size", "found", "n", "ind", "state"], "currentMovie": ["firstDate", " currentMusic", "firstMouse", "currentlyMovie", "reportedMusic", "reportedImage", "currentlyDate", "primaryDate", "reportedMedia", "currentMouse", "currentMonster", "presentHero", " currentMouse", " currentMedia", "currentDate", "primaryVideo", "currentlyHero", "firstMedia", "currentlyMonster", "activeVideo", "activePlayer", "currentlyVideo", "currentVideo", " currentMonster", "currentHero", "currentlyPlayer", " currentSpider", " currentPlayer", "activeMovie", " currentVideo", "currentMedia", "reportedHero", "presentMovie", "presentMusic", " currentImage", "currentImage", "presentImage", "currentlySpider", "primaryHero", "currentSpider", "firstHero", "primaryMovie", "currentPlayer", "firstVideo", " currentHero", "currentMusic", "reportedMovie", "firstMovie", "reportedMouse", "firstMonster", "activeSpider"], "movieName": ["Moviename", "filmTitle", "httpName", "movieTitle", "movieGroup", " movieType", "monstername", "httpNAME", "httpname", "filmNAME", "mpegName", "ovieGroup", "mpegGroup", "oviename", "ovieName", "movieNAME", "filmType", "filmGroup", " moviename", "mpegname", "moviename", " movieNAME", " movieTitle", "MovieName", "MovieType", "filmName", "MovieTitle", "movieType", "ovieNAME", "filmname", "mpegNAME", "monsterName", "monsterNAME"], "customer": ["developER", "ustomator", "Customer", "customER", "stickER", "ustomorder", "developator", "developity", "sticker", "customizer", "customator", "ustomER", " customator", "Customizer", "customity", "ustomer", "Customity", "stickity", "developizer", " customorder", " customER", "developorder", "customorder", "developer", "stickizer", "CustomER"], "rating": ["rated", "attribute", "option", "having", "rage", "rat", "reading", "ranking", "strength", "reporting", "testing", "rank", "credit", " Rating", "translation", "user", "error", "rate", "scoring", "saving", "type", "average", "ping", "setting", "scale", "tag", "heading", "boarding", "playing", "card", "weight", "ating", "review", "term", "core", "score", "Rating", "format"], "outBuf1": ["outBuffyone", "outBbuf5", "outBuc0", "outBuf5", "outRbufOne", "outBuf18", "outBBuff11", "outBool1", "outBuff1", "outBdfOnce", "outBuc5", "outBbufone", "outBuffy3", "outBooll", "outBool3", "outBlf1", "outBulp64", "outBBuff3", "outBufOnce", "outBdf3", "outBurg1", "outBBuff1", "outBuffy0", "outRuf5", "outBbuf18", "outBurg18", "outDbuf3", "outBuf64", "outBuf3", "outDbuf1", "outRbuf5", "outBbuf0", "outBufone", "outBoolone", "outBbuf64", "outBfx1", "outDbuf11", "outRbuf3", "outBfx3", "outBbufl", "outRuf1", "outDbuf0", "outRuf0", "outBdf64", "outBlf2", "outBlf3", "outBurg0", "outBlf0", "outDuf0", "outBuffyl", "outDuf1", "outBulp1", "outBfx0", "outBuffy18", "outBbuf11", "outBBuff0", "outRbuf18", "outBbufOnce", "outBuf11", "outBbuf3", "outBufl", "outBuff3", "outBbufOne", "outRufOne", "outRuf18", "outBurg3", "outDuf11", "outDuf3", "outBuf0", "outBulpOnce", "outBuffy1", "outBdf1", "outBuff2", "outBucOne", "outRbuf1", "outRbuf0", "outRuf3", "outBuc1", "outBbuf1", "outBulp3", "outBfx11", "outBuff0", "outBufOne"], "outBuf2": ["outBbuff42", "outMuf15", "outBbuff15", "outBbuf2", "outBbuf42", "outBuff42", "outFbuf4", "outFuf2", "outBuf3", "outBuf15", "outMbuf3", "outBuff2", "outBuffy4", "outBuffyTwo", "outMuf3", "outBbuff4", "outBuf02", "outBuff4", "outBbuff2", "outBuffy02", "outFbufTwo", "outFuf4", "outFuf02", "outBfgTwo", "outMbuf15", "outFbuf02", "outBbuf3", "outBbuf4", "outBuff3", "outBuff1", "outBbuff3", "outBufTwo", "outBfx1", "outBfg2", "outMuf1", "outBfx3", "outBbuf15", "outBfg02", "outMbuf2", "outBuffy2", "outBuffy3", "outBbuff1", "outMuf2", "outBuffj", "outBufj", "outBbuf1", "outBfx15", "outFufTwo", "outBbufj", "outFbuf2", "outBbuffj", "outBfg4", "outBfx2", "outBbufTwo", "outBbuf02", "outMbuf1", "outBuf42", "outBuffTwo", "outBuf4"], "endOfIndexFile": ["endOfIndexF", "endOfPositionFile", "endOfErrorFile", "endofIndexFile", "endofindexfile", "endOfPositionFiles", "endofindexF", "endOFindexfile", "endOFindexFile", "endOfindexFile", "endofindexTable", "endOfPositionTable", "endOfindexTable", "endOfindexFiles", "endOFindexLine", "endOfIndFile", "endedFile", "endofIndexF", "endOfIndfile", "endOfindexfile", " endFile", "endOfErrorfile", "endOfindexLine", "endOFIndexFile", "endOfErrorF", "endOFIndexLine", "endofIndexFiles", "endOfPositionfile", "endOFIndexfile", "endOfErrorFiles", "endFile", "endofindexFile", "endOfindexF", "endOfIndexTable", "EndFile", "endOfIndexfile", "endofIndexfile", "endOfIndexLine", "endOfIndLine", "endOfIndexFiles", "endofindexFiles", "endofIndexTable"]}}
{"id1": "22366505", "id2": "20685385", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "label": 1, "substitutes": {"incluir": ["incluiar", "incluar", "inCLuir", "incluator", "inclouar", "inclUir", "inclouir", "inCLuator", "inclUier", "inclouier", "incluier", "incluiator", "inclUator", "incluiir", "incluiier", "inCLuar", "inCLuier", "inCLUir", "inCLUator", "inCLUar", "inclouator", "inclUar", "inCLUier"], "igreja": ["igarreji", "igopenva", "igopenj", " igrejas", "igarreva", " iggrejas", "iggreja", "igvreja", "iggreva", " igcreJa", "iggreji", "igcreJa", " igrej", " iggreja", "igreJa", "igopenja", "igcreja", "igcreji", " iggreva", "igarreJa", "igreji", "igvrej", "iggrej", "iggrejas", "igreje", " igcreja", "igrej", " iggrej", "igarrej", "igvrejas", " igreji", " igreJa", " iggreje", "igrejas", "iggreje", "iggreJa", "igarreje", "igcrej", " igcreji", "igarrejas", "igreva", "igarreja", " igcrej", "igopenji", " igreva", " igreje", "igvreje", " iggreji"], "connection": ["established", "Connection", "link", "response", "server", "conn", "system", "created", "settings", "socket", "statement", "pool", "connected", "description", "message", "current", "which", "database", "connect", "management", "config", "container", "query", " Connection", "session", "network", "ion", "resource", "context", "city", "close", "function", "computer", "reference", "manager", "user", "library", "setup", "application", "c", "communication", "engine", "command", "instance", "generation", "language", "collection", "gate", "condition", "relation", "db", "component", "open", "client", "section", "con", "position", "to", "creator", "operation", "document", "directory", "n"], "sql": ["zip", "url", "pl", "ln", "string", "sq", "select", "statement", "shell", "inv", "sk", "xml", "scl", "description", "title", "expression", "lock", "series", "cmd", "query", "sys", "log", "sd", "plan", "template", "ql", "pel", "sv", "dl", "san", "spr", "login", "q", "nl", "command", "install", "form", "normal", "sol", "sf", "serial", "spec", "csv", "seed", "table", "SQL"], "sql2": ["SQL1", "sql3", "sd2", " sql3", "sql02", "sd4", "ql3", "SQL02", "sd3", "sql4", " sql02", "SQL2", "ql02", " sql1", "sql1", "SQL3", "ql1", "ql2", " sql4", "sd02", "SQL4"], "stmt": ["Stm", "statmn", "restmt", "strm", "reststat", "statMT", "estMT", "stMT", "statm", " stmn", "stmm", "STm", "stmb", "tMT", "tmb", "STmb", "strMT", "estmb", "STMT", "Stmm", " stm", " ststat", "estm", "ststat", "tmt", "Stmn", "STmt", " stmm", "Ststat", "tmm", "strmt", " stMT", "statmt", "Stmt", "StMT", "restm", "stmn", "restmm", "STmn", "STmm", "Stmb", "stm", "strmb", " stmb", "estmt"], "stmt2": ["Stmt1", "stmr4", "stmTwo", "stm2", "sttm2", "stMT3", "sttx2", "stMT2", " stmp4", "stmt02", "stmp3", "stmp1", "Stmem1", "stmt1", "StmtTwo", "stm02", " stmt1", "sttm4", "stmp4", " stmt4", "stMT1", "sttm3", " stmp3", "stmptwo", "stmpTwo", " stmtTwo", "stmrtwo", " stMT02", "stmr1", " stmttwo", "Stmem3", "stm1", "stmemTwo", " stmpTwo", " stmptwo", "sttx02", "StmemTwo", "Stmt2", " stMT3", "Stmt3", " stmp1", "stmem3", " stmt3", "stm3", "Stmem2", "stmr2", "stmt3", "sttx1", " stMT2", " stMT1", "sttx3", "stmttwo", "stmem2", " stmt02", " stmp2", "sttmTwo", "stMTTwo", "stMT4", "stmt4", "stMTtwo", "stMT02", "stmtTwo", "stmem1", "stmp2"], "rs": ["ras", "rt", "cs", "rd", "ws", "ts", "bs", "ps", "ats", "r", "ars", "ds", "rates", "ns", "sr", "RS", "ys", "vers", "gs", "ris", "results", "ss", "xs", "fs", "sts", "res", "rss", "rows", "its", "ims", "ms", "ins", "rys", "pers", "vs", "Rs", "usr", "eps", "mr", "rc", "s", "ros", "js", "qs", "ows", "hs", "ks", "ls"], "retorno": [" retorn", "retorne", "retorn", "retogo", "altorno", "gotorne", "gotora", "altogo", "montorno", "eltorno", "eltano", "altano", "gotorno", "eltorn", " retano", "eltogo", "altorn", "montrero", " retrero", "montora", "retano", "retrero", "montorne", " retogo", " retora", " retorne", "retora", "gotrero"]}}
{"id1": "16760971", "id2": "937612", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public String new2Password(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            String clearPassword = passwd;\n            md.update(clearPassword.getBytes());\n            byte[] digestedPassword = md.digest();\n            return new String(digestedPassword);\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 doesn't exist\");\n            System.out.println(e.toString());\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"generateHash": ["generateIndex", " GenerateIndex", "generatesKey", " GeneratesHash", " GeneratesIndex", " Generatehash", " Generateshash", "generificatehash", "generatedIndex", "generatedKey", " GenerateHash", "generatedhash", " GenerateKey", "generificateKey", "generatedHash", "generificateIndex", "generatehash", "generatesIndex", "generatesHash", "generificateHash", " GeneratesKey", "generateKey", "generateshash"], "key": ["name", "link", "path", "string", "x", "char", "sk", "message", "mac", "e", "value", "node", "json", "source", "k", "keys", "context", "data", "KEY", "template", "password", "id", "Key", "base", "type", "prime", "crypt", "sum", "command", "y", "prefix", "hash", "service", "code", "text", "phrase", "seed", "client", "policy", "input", "my", "token", "hex", "sign", "username", "secret"], "md": ["sm", " mac", "metadata", "msg", " MD", "comp", "dr", "dig", " mm", "def", "cd", "mb", "MD", " cmd", "add", "dm", "dh", "ds", "mm", "mo", "nt", "der", "od", "cmd", "grad", "ind", "bd", "de", "h", "sd", "mod", "ad", " mo", "di", "pd", "ld", "m", "det", " Md", " dd", " cd", " mc", "mp", "rm", " rm", "ms", "mg", " ms", "red", "desc", "mn", "d", "nd", "mand", "exec", "dd", "mc", "td", "mt", "mk", "df", "hd"], "bytes": ["bits", "bos", "clips", "frames", "bs", "some", "lines", "strings", "tes", "classes", "gets", "ions", "values", "b", "ebin", "blocks", "buffer", "gs", "keys", "es", "ones", "xs", "loads", "nets", "bys", "files", "seconds", "ies", "pieces", "fs", "cells", "steps", "bis", "gb", "its", "ashes", "ios", "ms", "ings", "binary", "vs", "bes", "Bytes", "words", "terms", "s", "bles", "bps", "ls"], "buff": ["zip", "ff", "printf", "bg", "comp", "tf", "pp", "alph", "prep", "aux", "bs", "cb", "frames", "mb", "backed", "nb", "prof", "cmd", "grow", "b", "bed", "buffer", "agg", "quit", "np", "buf", "Buffer", "bb", "uf", "append", "conv", "tab", "uff", "txt", "qq", "eb", "cond", "bj", "font", "butt", "ust", "Buff", "bo", "supp", "obb", "pb", "bound", "zz", "wind", "ob", "fr", "alf", "fb", "ary", " Buff", "pdf", "df"], "l": ["hl", "ell", "al", "pl", "le", "ln", "lv", "jl", "x", "g", "v", "yl", "cl", "lb", "b", "lit", "like", "i", "k", "L", "j", "ly", "lang", "ld", "kl", "m", "dl", "c", "il", "lp", "coll", "nl", "el", "sl", "q", "left", "lay", "fl", "t", "tl", "ll", " Li", "lc", "loc", "loop", "lo", "d", "la", "length", "dL", "list", "z", "ml", "ls", "n", "ul", "li"], "hx": [" hix", "ohex", "hX", "rxf", "Hix", "Hex", "rex", "hrxe", "ohxe", " hpx", "rx", "handleix", "hxf", "handleex", "Hpx", "ohX", "hpx", "hrx", "hix", "hrex", "hrX", "ohx", " hex", "hxe", "Hxe", "handlex", "HX", "rpx", "hex", "handlexf", " hxf", "Hxf", "Hx"]}}
{"id1": "6988216", "id2": "4118412", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" executeBasicContent", " testBasicContent", " executeSimpleContent", " testQueryQuestion", " testRawQuestion", " testRawQ", " testBasicQuestion", " testBasicQuery", " testRawQuery", " testSimpleQuestion", " executeSimpleQ", " executeBasicQuestion", " testQueryQuery", " executeSimpleQuery", " testQueryQ", " executeBasicQ", " testSimpleQ", " testRawContent", " executeBasicQuery", " executeSimpleQuestion", " testSimpleContent", " testQueryContent", " testBasicQ"], "dummySource": ["daummySource", "dummSource", "dummyFile", "dancySource", "dummSourceFile", "dummInput", "udeterminedFile", " duffySourceFile", " duffySource", " duffyInput", "dumpStore", "dancyFile", " dummyInput", "datumInput", "udummyFile", "determinedParent", "dummyInput", " duffyContent", "dummiesResource", "dummyResource", "dancyInput", "dumpSource", "daummyInput", "determinedSource", "datumResource", "determinedFile", "duffyContent", "daatumResource", "determinedContent", "udeterminedParent", "duffySource", "datalParent", "udummySource", "dumpResource", "daummyResource", "duffyInput", "datalFile", "datalContent", "udeterminedSource", "daatumInput", "dummySourceFile", "dummyParent", "datumStore", "udeterminedContent", "dummContent", "duffySourceFile", " dummySourceFile", "daatumSource", "dummiesInput", "dummiesSource", "daatumStore", "dumpInput", "dummiesStore", "dummyStore", "daummyStore", "dancyContent", "dancySourceFile", "dancyParent", "udummyParent", "udummyContent", "datumSource", "datalSource"], "os": ["bos", "obs", "oes", "ose", "conn", "Os", "is", "ols", "socket", "ts", "bs", "css", "ui", "si", "oS", "uts", "ats", "ox", "ds", "mos", "aos", "ants", "dis", "pos", "ost", "asis", "cos", "sys", "ys", "io", "ori", "om", "OS", "es", "osi", "fs", "oids", "ot", "oa", "or", "ops", "ios", "ims", "ms", "out", "o", "des", "oses", "los", "dos", "ors", "oss", "ros", "s", "js", "et", "ens", "ows", "windows", "oos"], "dummyContent": [" dummiesContents", "DummyMedia", "dynamicCode", "dumpingContents", "dummyInt", "dumpingCode", "deltaMedia", "determinedMedia", "deltaInt", "dummyTemplate", "dummyMedia", "dummiesContents", "dummyContents", "DumpText", "DummyText", "DumpContent", "determinedContent", "determinedInt", "DummyContent", " dummyContents", "DummyInt", "DumpInt", "dummyText", "dummiesCode", "dynamicTemplate", "dummyCode", "dumpInt", " dummyTemplate", "dynamicContents", "dumpMedia", "dummiesTemplate", " dummiesContent", "deltaText", "dumpText", "dumpingTemplate", " dummyCode", " dummiesCode", "dumpingContent", "dynamicContent", " dummiesTemplate", "dumpContent", "determinedText", "deltaContent", "DumpMedia", "dummiesContent"], "source": ["Source", "ace", "server", "image", "pse", "sin", "inner", "ource", "src", "scope", "se", "sample", "sr", "series", "sys", "resource", "join", "template", "user", "result", "from", "space", "search", "uri", "site", "status", "instance", "sql", "store", "in", "service", "ser", "sf", "google", "spec", "relation", "seed", "proxy", "table", "s", "core", "ie", "sp", "SOURCE", "use"], "content": ["sequence", "response", "cache", "html", "path", "key", "header", "version", "tx", "activity", "action", "xml", "description", "message", "current", " contents", "expression", "article", "title", "json", "value", "node", "config", "layout", "resource", "context", "data", "template", "example", "ext", "result", "application", "comment", "txt", "cont", "Content", "command", "status", "body", "text", "code", "summary", "editor", "output", "section", "tree", "license", "script", "quest", "document", "ontent", "format"], "qResult": ["QResult", "queryReport", "dqView", " qresult", "dqResult", "queryRes", "qReport", "iqResults", "qView", "queryResponse", " qRes", "qResponse", "QRes", " qResults", "qRes", "queryResult", "iqReport", "dqresult", "dqRes", "iqResult", "iqRes", "queryResults", "Qresult", " qView", "qresult", " qReport", "iqResponse", " qResponse", "qResults", "QView"], "results": ["views", "Contents", "resources", "assets", "ults", "posts", "settings", "olds", "forms", "pages", "members", "features", "xes", "runs", "users", "values", "reports", "thumbnails", "blocks", "relations", "archives", "RESULTS", "data", "ands", "result", "actions", "res", "rows", "ULTS", "photos", "tests", "its", "objects", "details", "Results", " Results", "ms", "children", "ries", "lections", "missions", "times", "items", "events", "s", "chains", "versions", "terms", "orders", "roads", "products", "hips"], "it": ["MIT", "stat", "ip", "init", "p", "is", "It", "v", "rit", "mit", "hit", "ait", "ite", "info", "iz", "IT", "lit", "i", "h", "read", "ci", "they", "id", "m", "pit", "he", "its", "ic", "in", "st", "op", "t", "out", "at", "iter", "exec", "et", "ul", "li"], "rSrc": ["rSers", "rSysource", "rDesRC", "rSourcerc", "rSrs", "rDesrc", "rSlcs", "crSsrc", "rSlRC", " rScs", "rSyssrc", "crDesrs", "rSerc", "rSysRC", "crSrc", " rSRC", "rSourcers", "rSourceRC", "crSRC", " rSource", "rSRC", "rSource", "rSlrc", "rSlrs", "rSourcesrc", "crSrs", " rSrs", "rSsrc", "rDesrs", "crDesRC", "rSysrc", "rSecs", "crDessrc", "crDesrc", "rScs", " rSsrc", "rSeRC", "rDessrc"], "rSrcIn": ["rSetrcIN", "rSrcInput", "rSetrcOut", "rSRCCon", "rSncOut", "rSRCIN", "rSrcCon", "rSrsInput", "rSldIn", "rSldInput", "rSrcin", "rSrsIN", "rSsrcInput", "rSRCOut", "rSncIn", "rSRCIn", "rSrcIN", "rSrcOut", "rSsrcin", "rSetsrcOut", "rSRCin", "rSldin", "rSldOut", "rSsrcIN", "rSldCon", "rSncin", "rSetrcIn", "rSrsOut", "rSetsrcin", "rSrsIn", "rSetrcin", "rSetsrcIN", "rSncCon", "rSsrcOut", "rSetsrcIn", "rSldIN", "rSsrcIn"], "actualOut": ["ualBytes", "ualout", "actualout", "ualOut", " actualout", "finalIn", "realIs", "actuallyIn", "ualIn", "UALBytes", "UALOut", "UALEnd", "actuallyIs", "actualIs", "actualBytes", "actualIn", " actualIs", "ualEnd", "actualEnd", " actualEnd", "virtualOut", "finalOut", "actualCopy", "realOut", "actuallyCopy", "realIn", "realCopy", "actuallyOut", " actualBytes", "finalout", "UALIn", " actualCopy", "virtualIn", " actualIn"]}}
{"id1": "350482", "id2": "8801436", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionscheck", "doBuildTest", "doFeatureCheck", "doBuildcheck", "doVersionQuery", " doVersionsCheck", " doVersionTest", "doVersionsCheck", "doVersionUpdate", " doVersionQuery", " doVersioncheck", "doBuildCheck", " doApplicationCheck", "doFeatureTest", "doImageCheck", "doApplicationTest", "doImageTest", "doApplicationInfo", "doVersionsUpdate", " doVersionscheck", "doImageInfo", "doVersioncheck", "doImageQuery", "doApplicationCheck", "doFeatureUpdate", "doVersionsTest", " doVersionsUpdate", " doApplicationInfo", "doFeatureInfo", "doFeaturecheck", " doVersionUpdate", " doVersionInfo", " doApplicationQuery", "doVersionInfo", "doVersionTest", "doApplicationQuery", "doFeatureQuery", " doVersionsTest", "doBuildUpdate", " doApplicationTest"], "view": ["views", "port", "html", "server", "cv", "image", "version", "model", "display", "this", "pool", "v", "subject", "lock", "View", "file", "controller", "query", "update", "buffer", "layout", "eye", "VIEW", "h", "context", "manager", "tv", "box", "call", "project", "see", "report", "engine", "http", "q", "page", "cell", "form", "virtual", "check", "browser", "widget", "review", "component", "client", "iew", "block", "tree", "row", "input", "ml", "show", "vm", "self", "print", "document", "window", "index"], "url": ["mail", "Url", "link", "hl", "html", "pl", "oul", "domain", "char", "v", "r", "job", "mount", "file", "lb", "b", "log", "gl", "ssl", "host", "build", "bel", "f", "dl", "uri", "http", "nl", "sl", "rl", "str", "ll", "browser", "address", "ref", "loc", "rel", "l", "client", "get", "URL", "ur", "ul"], "in": ["inn", "inc", "ln", "init", "is", "ain", "mat", "sin", "inner", "stream", "isin", "din", "info", "source", "i", "asin", "gin", "on", "f", "from", "In", "body", "ins", "out", "mn", "IN", "l", "n", " din", "cin", "input", "rin", "can", " IN", "reader", "vin", "inf"], "bin": ["inn", "bi", "bn", "cache", "bg", "len", "ln", "abin", "init", "cb", "sin", "inner", "jin", "bl", "din", "spin", "nb", "brain", "file", "ebin", "b", "mon", "bed", "buffer", "cos", "session", "all", "stock", "gin", "local", "ran", "conv", "sam", "win", " bins", "body", "ins", " Bin", "lib", "binary", "buff", "out", "by", "db", "con", " din", "bur", "rb", "cin", "rin", "re", "obin", "reader", "thin"], "line": ["port", "link", "lane", "sequence", "liner", "ln", "key", "le", "tile", "string", "stay", "ine", "part", "char", "lines", "stream", "message", "sample", "job", "entry", "detail", "cmd", "Line", "file", "point", "log", "err", "channel", "parse", "next", "LINE", "record", " block", "eline", "comment", "base", "lin", "cell", "page", "status", "trace", "frame", "range", "code", "chain", "rule", "zone", "lo", "l", "section", "iter", "word", "block", "ice", "row", "inline", "field", "cat", "print", "style", "column"], "develBuild": ["depoLog", "duvelBuild", "devBuilder", "devBuilt", "deVELBuild", "devbuild", "duvelBuilder", "DevelLog", "deployRelease", "DevelBuild", "depoBuild", "duvelBuilt", "deployBuilder", "DeVELLog", "desVELBuild", "devBuild", "duffbuild", "deVELBoot", "DevelBuilt", "develLoad", "devBoot", "deffBuilder", "duVELBuild", "develbuild", "develRelease", "develBoot", "devLog", "develLog", "duffBuild", "deVELLog", "develBuilder", "desVELLoad", "deployLoad", "deVELBuilder", "desVELRelease", "depobuild", "deployBuilt", "deffbuild", "deploybuild", "DeVELbuild", "DeVELBuild", "duVELbuild", "deVELBuilt", "desvelRelease", "desvelLoad", "deVELLoad", "deVELbuild", "desvelBuild", "deeltaLoad", "deeltabuild", "DeVELBuilt", "deployBoot", "deeltaBuild", "duvelBoot", "duVELBuilder", "duffBuilder", "deVELRelease", "desVELbuild", "deployBuild", "deffBuilt", "Develbuild", "deffBuild", "duvelbuild", "duffBuilt", "desvelbuild", "develBuilt", "duVELBoot", "depoBuilt", "deeltaRelease"], "stableBuild": ["devBuilder", "stableCraft", "confirmedLong", " stableLong", "devbuild", "secureBuilder", "devBuild", "confirmedbuild", "securebuild", " stablebuild", "activeMake", "stableLong", " stableMake", "devMake", "secureBuild", " unstableBuilder", " unstableBoot", "stablebuild", " unstableBuild", " stableBoot", " stableBuilder", "stableMake", "activeBuilder", "activebuild", "activeBuild", "devBind", " unstableBind", "confirmedBuild", " unstablebuild", "secureCraft", "stableBind", "stableBoot", " unstableLong", "confirmedBoot", "stableBuilder", " stableCraft", " unstableCraft", " stableBind"]}}
{"id1": "3584508", "id2": "12055086", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": [" copiedUrl", "downloadFile", "downloadAddress", " copyUrl", "downloadResource", "copyAddress", "downloadUrl", "copyUrl", "copyFile", " copyAddress", " copiedResource", " copiedFile", " copyFile", " copiedAddress"], "url": ["mail", "Url", "util", "hl", "link", "html", "path", "cert", "string", "char", "ret", "mb", "r", "mount", "cl", "file", "source", "gl", "ssl", "resource", "host", "f", "base", "dl", "uri", "github", "web", "http", "nl", "sl", "el", "rl", "service", "fl", "str", "ll", "browser", "address", "ref", "https", "loc", "rel", "l", "null", "URL", "re", "ml", "gif", "ls", "ur", "ul"], "input": ["access", "active", "up", "ip", "init", "initial", "image", "PUT", "select", "it", "ain", "act", "enter", "inner", "stream", "before", "add", "info", "unknown", "feed", "file", "config", "source", "start", "ssl", "context", "read", "parse", "local", "user", "base", "accept", "cont", "audio", "http", "sum", "form", "in", "inside", "text", "op", "upload", "Input", "open", "get", "iter", "null", "focus", "exec", "request", "pull", "qa", "empty", "acl", "missing", "reader", "can", "index", "eval", "raw", "state"], "output": ["remote", "auto", "response", "four", "online", "group", "icon", "secondary", "other", "image", "you", "display", "continue", "put", "current", "outer", "Output", "entity", "success", "file", "update", "network", "secure", "next", "exit", "beta", "unsigned", "format", "web", "bool", "object", "console", "text", "out", "o", "ne", "write", "table", "client", "component", "ilo", "null", "position", "connection", "net", "print", "hidden", "ou"], "b": ["bi", "bits", "obj", "ib", "p", "bc", "bs", "cb", "char", "mb", "g", "v", "B", "r", "ab", "sb", "nb", "u", "i", "k", "ba", "bb", "j", "bp", "bit", "f", "eb", "base", "m", "c", "bf", "ble", "br", "gb", "body", "y", "t", "wb", "buff", "binary", "d", "by", "l", "db", "ob", "block", "rb", "z", "fb", "be"]}}
{"id1": "7166270", "id2": "22368133", "code1": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "code2": "    public static void testMapSource(MapSource mapSource, EastNorthCoordinate coordinate) {\n        try {\n            System.out.println(\"Testing \" + mapSource.toString());\n            int zoom = mapSource.getMinZoom() + ((mapSource.getMaxZoom() - mapSource.getMinZoom()) / 2);\n            MapSpace mapSpace = mapSource.getMapSpace();\n            int tilex = mapSpace.cLonToX(coordinate.lon, zoom) / mapSpace.getTileSize();\n            int tiley = mapSpace.cLatToY(coordinate.lat, zoom) / mapSpace.getTileSize();\n            url = new URL(mapSource.getTileUrl(zoom, tilex, tiley));\n            System.out.println(\"Sample url: \" + url);\n            c = (HttpURLConnection) url.openConnection();\n            System.out.println(\"Connecting...\");\n            c.connect();\n            System.out.println(\"Connection established - response HTTP \" + c.getResponseCode());\n            if (c.getResponseCode() != 200) return;\n            String contentType = c.getContentType();\n            System.out.print(\"Image format          : \");\n            if (\"image/png\".equals(contentType)) System.out.println(\"png\"); else if (\"image/jpeg\".equals(contentType)) System.out.println(\"jpg\"); else System.out.println(\"unknown\");\n            String eTag = c.getHeaderField(\"ETag\");\n            boolean eTagSupported = (eTag != null);\n            if (eTagSupported) {\n                System.out.println(\"eTag                  : \" + eTag);\n                testIfNoneMatch();\n            } else System.out.println(\"eTag                  : -\");\n            long date = c.getDate();\n            if (date == 0) System.out.println(\"Date time             : -\"); else System.out.println(\"Date time             : \" + new Date(date));\n            long exp = c.getExpiration();\n            if (exp == 0) System.out.println(\"Expiration time       : -\"); else System.out.println(\"Expiration time       : \" + new Date(exp));\n            long modified = c.getLastModified();\n            if (modified == 0) System.out.println(\"Last modified time    : not set\"); else System.out.println(\"Last modified time    : \" + new Date(modified));\n            testIfModified();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"\\n\");\n    }\n", "label": 0, "substitutes": {"issueCommandToServer": [" sendCmdToserver", " sendCommandFromserver", " sendCommandtoserver", " sendCommandToserver", " sendCommandFromClient", " sendCmdtoRemote", " sendCmdToRemote", " sendCommandtoClient", " sendCmdtoServer", " sendCmdToServer", " sendCommandTOClient", " sendCommandToServer", " sendCommandtoRemote", " sendCommandTOServer", " sendCmdToClient", " sendCmdtoClient", " sendCmdtoserver", " sendCommandToRemote", " sendCommandtoServer", " sendCommandTOserver", " sendCommandFromServer", " sendCommandToClient", " sendCommandTORemote", " sendCommandFromRemote"], "command": ["attribute", "execute", "sequence", "clear", "power", "string", "action", "pattern", "comm", "document", "description", "message", "title", "menu", "argument", "cmd", "event", "controller", "query", "Command", "channel", "template", "password", "method", "application", "uri", "mode", "communication", "send", "form", "help", "code", "text", "direction", "history", "requisite", "request", "connection", "operation", "program", "directory"], "changeCapsule": ["changeCpsal", "changeClapsules", "changeClapsal", "changeClapsularity", "changeCcapsularity", "changeCcapsule", "changeClapsue", "changeClcapsule", "changeClpsal", "changeClcapsULE", "changeCpsule", "changeCmsule", "changeCmsue", "changeCpsularity", "changeCmsULE", "changeCcapsue", "changeCapsal", "changeClapsULE", "changeCcapsULE", "changeClapsale", "changeCipherULE", "changeCipherule", "changeClpsularity", "changeCmsale", "changeCipherale", "changeCcapsal", "changeCapsue", "changeClapsule", "changeClpsule", "changeClpsules", "changeCarsule", "changeCarsules", "changeCapsale", "changeCapsularity", "changeCcapsules", "changeCpsules", "changeCarsularity", "changeClcapsue", "changeCapsules", "changeCcapsale", "changeClcapsale", "changeCipherue", "changeCarsal", "changeCapsULE"], "urlConn": ["fileConnect", " urlCo", " urlCon", "urlConnection", "httpCon", "UrlConnect", "httpConnection", "urlCo", "Urlconn", "logConnection", " urlConnect", "UrlConn", "UrlNum", "urlConnect", "retconn", "retConn", "strConnection", "strConn", "logConnect", "httpConnect", "urlCons", "logConn", "urlconn", "strCo", "logconn", "strConnect", " urlNum", "dlconn", "dlConnect", " urlconn", "dlConn", "retConnect", " urlCons", "strconn", "httpCons", "urlNum", "httpConn", "strNum", "fileconn", "fileConn", "urlCon", "httpCo", "strCon", "retCons", "httpconn"], "wr": ["wy", "wk", "writers", "Writer", "conn", "wa", "RW", "writer", "vo", "Wr", "wn", "hr", "nw", "w", "writ", "tn", "wx", "iw", "fw", "vet", "wm", "sw", "spr", "vr", "we", "ew", "wb", "pr", "rew", "rw", "write", "wid", "wo", "wp", "mr", "cr", "WR", "fr", "tw", "wer", "wt", "kr"], "content": ["sequence", " Content", "metadata", "equ", "key", "header", "version", "string", "css", "description", "message", "add", "current", "expression", "value", "label", "json", "config", "source", "update", "layout", "resource", "context", "reason", "join", "data", "template", "ext", "application", "media", "comment", "txt", "c", "cont", "search", "Content", "body", "text", "code", "address", "load", "write", "output", "section", "core", "script", "ce", "document", "ontent", "format"], "input": ["iterator", "inc", "active", "ahead", "ip", "enter", "init", "initial", "image", "raw", "it", "pattern", "inner", "xml", "via", "add", "current", "info", "unknown", "partial", "feed", "submit", "file", "query", "update", " Input", "internal", "ssl", "read", "local", "data", "storage", "accept", "http", "q", "form", "in", "alpha", "inside", "qi", "Input", "output", "get", "open", "iter", "request", "ao", "acl", "background", "reader", "upload"], "response": ["sequence", "view", "server", "answer", "image", "resp", "still", "version", "continue", "display", "description", "message", "detail", "value", "pos", "network", "buffer", "next", "verse", "related", "respond", "respons", "library", "application", "alert", "result", "report", "vector", "trace", "onse", "frame", "Response", "service", "object", "collection", "summary", "relation", "csv", "output", "line", "position", "block", "request", "dict", "reset", "reply", "format"], "str": ["name", "msg", "obj", "cs", "le", "cert", "exp", "tr", "p", "string", "bc", "del", "comm", "char", "expr", "part", "g", "r", "ent", "STR", "err", "i", "dat", "data", "j", "txt", "cont", "arr", "ctr", "status", "br", "st", "set", "piece", "text", "t", "chain", "gr", "line", "iter", "Str", "s", "exec", "list", "fr", "re", "sp", "print", "hex", "cat", "dr", "n"]}}
{"id1": "21092340", "id2": "9846843", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToExFile", "addInHarFile", "addToZipive", "addToArchZip", "addInArchZip", "addToArchFile", "addToArchiver", "addToZipZip", "addInArchFile", "addToZipFile", "addToExiver", "addInArchive", "addInHarive", "addToExZip", "addToHarZip", "addToHariver", "addInArchiver", "addInHarZip", "addToZipiver", "addInHariver", "addToHarive", "addToExive", "addToHarFile"], "pod": ["volume", "pc", "p", "ods", "task", "message", "job", "device", "ack", "pack", "od", "Pod", "start", "point", "pad", "archive", "ad", "top", "project", "pick", "report", "poll", "body", "post", "check", "op", "spec", "zone", "proc", "pkg", "module", "component", "table", "policy", "wp", "disk", "cp"], "podArchiveOutputStream": ["podArchiveOUMap", "podArchiverInputStreamer", "podArchiveOUStream", "podArchiverOutputContext", "podArchiverInputMap", "podArchiveInputContext", "podArchiveStreamForm", "podArchiveEntrySteam", "podArchiveOUSync", "podArchiveOutputSync", "podArchiveOutputstream", "podArchiveInputSync", "podArchiverInputstream", "podArchiveOutputMap", "podArchiveOutstream", "podArchiveOutContext", "podArchiveInputstream", "podArchiveMainStreamer", "podArchiveInputSteam", "podArchiveOutputStreamer", "podArchiveResourceSteam", "podArchiverOutputStream", "podArchiveOutputPoint", "podArchiverOutputStreamer", "podArchiveoutputSteam", "podArchiveEntryStream", "podArchiveOutSteam", "podArchiveInputStream", "podArchiverInputForm", "podArchiverInputSync", "podArchiveOutputContext", "podArchiveOutPoint", "podArchiveResourceContext", "podArchiveOUForm", "podArchiveInputMap", "podArchiveMainForm", "podArchiveInputPoint", "podArchiverInputStream", "podArchiveInputForm", "podArchiverInputPoint", "podArchiveOutputSteam", "podArchiveInputStreamer", "podArchiverInputContext", "podArchiveMainStream", "podArchiverInputSteam", "podArchiverOutputForm", "podArchiveoutputStreamer", "podArchiveStreamStream", "podArchiverOutputPoint", "podArchiverOutputSteam", "podArchiveoutputStream", "podArchiveEntryPoint", "podArchiveResourcestream", "podArchiverOutputMap", "podArchiveStreamSync", "podArchiveoutputForm", "podArchiverOutputSync", "podArchiveMainSteam", "podArchiverOutputstream", "podArchiveOutStream", "podArchiveResourceStream", "podArchiveOutputForm", "podArchiveStreamMap"], "filename": ["fp", "name", "url", "println", "FN", "path", "key", "NAME", "version", "string", "nm", "p", "png", "description", "fn", "jpg", "subject", "ename", "message", "original", "title", "nil", "file", "location", "folder", "fil", "archive", "resource", "FILE", "kl", "txt", "uri", "release", "stem", "prefix", "binary", "Filename", "output", "ame", "family", "latest", "names", "directory", "username", "upload"], "source": ["Source", "iterator", "sequence", "view", "image", "select", "shell", "inner", "stream", "ource", "src", "loader", "sample", "info", "copy", "series", "file", "start", "resource", "context", "template", "password", "from", "force", "sql", "body", "store", "service", "ser", "address", "spec", "seed", "proc", "supp", "component", "get", "input", "SOURCE", "style", "use"], "entry": ["zip", "attribute", "link", "obj", "ace", "key", "enter", "system", "quick", "char", "task", "nt", "se", "job", "cue", "ent", "file", "query", "log", "resource", "archive", "tmp", "channel", "Entry", "record", "data", "ry", "ment", "book", "comment", "cell", "good", "or", "set", "card", "element", "sheet", "component", "word", "line", "connection", "row", "ie", "ce"]}}
{"id1": "14303294", "id2": "23161545", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getClientMac", "getserverPassword", "getserverSalt", "getUserHash", "toClientMac", "getClientPassword", "toClientPassword", "getServerSalt", "getserverHash", "getClientHash", "getUserPassword", "getUserSalt", "getUserMac", "toServerMac", "getserverMac", "toClientSalt", "getServerMac", "getClientSalt", "toServerSalt", "toClientHash", "toServerHash", "getServerPassword", "toServerPassword"], "passwordHash": ["passwordHas", "PasswordPassword", "swordSalt", "passwordSalt", "serverKey", "PasswordHas", "PasswordHash", " passwordSalt", "passwordPassword", "swordHash", "emailHas", "PasswordKey", "passwordHTML", " passwordKey", "emailHTML", "emailSalt", " passwordPassword", "serverHash", "serverSalt", "PasswordHTML", "passwordKey", "swordHas", "emailHash", "swordHTML", "serverPassword"], "PasswordSalt": ["passwordToken", "PasswordPassword", "UserToken", "passwordSalt", " PasswordHash", "UserHash", "PasswordHash", " passwordSalt", "passwordPassword", "UserSalt", "passwordSecret", " PasswordSecret", " passwordToken", " passwordPassword", " PasswordToken", "PasswordToken", " PasswordPassword", "UserSecret", "PasswordSecret"], "hash": ["cache", "response", "html", "key", "dig", "height", "char", "sh", "message", "sample", "copy", "shift", "mac", "value", "json", "log", "h", "build", "score", "match", "ash", "map", "password", "echo", "result", "search", "Hash", "report", "crypt", "sum", "tag", "mask", "serial", "address", "test", "component", "total", "word", "block", "row", "transform", "hex", "print", "filter", "index", "handle", "sha"], "digest": ["mdested", "dEST", "Digest", "dester", "decse", "mdEST", "hashester", "dest", " digested", "descester", "Digester", "Diggest", "descested", "hashested", "displayested", "diggest", "mdest", "hashest", "digse", "mdester", "displayest", " digse", "decested", "displayester", "digested", "Digse", " digester", "descest", " digEST", "digEST", "hashgest", "DigEST", "digester", "decester", "displaygest", "dested", "decest", "Digested", "descse"]}}
{"id1": "6403868", "id2": "20019847", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractuninstallItems", "extractuninstallFiles", "extractunInstallFiles", "extractUnpackFile", "extractunInstallFile", "extractunInstallItems", "extractUninstallFile", "extractUnpackFiles", "extractUnInstallFiles", "extractUninstallItems", "extractuninstallFile", "extractUnInstallFile", "extractUnpackItems", "extractUnInstallItems"], "_destPath": ["_restPath", "_destDir", "_srcKey", "_tempPoint", "_sourceDir", "_srcPoint", "_DestKey", "_privDir", "_destKey", "_DestPath", "_srcPath", "_privPath", "_destPoint", "_privTh", "_DestDir", "_tempPath", "_combDir", "_restPoint", "_srcDir", "_sourceFormat", "_DestPoint", "_restKey", "_destTh", "_DestTh", "_destFormat", "_sourcePath", "_restDir", "_tempFormat", "_combFormat", "_tempTh", "_privPoint", "_combPath", "_tempDir"], "upgrade": ["equcp", "downcheck", " upgrad", "exchange", "equgrad", " upchange", "unate", "exgrades", "upcp", "ungrade", "downchange", "ungrad", "upgrades", " upcheck", "upate", " upgrades", "equate", " upcp", "uncp", "downgrade", " upate", "upchange", "upgrad", "upcheck", "excheck", "equgrade", "downgrades", "exgrade"], "lastVer": ["nextRes", "oldVer", "nextServ", " lastver", "LastVersion", " lastVersion", " lastRes", "oldVersion", " lastVers", "LastVer", "oldVers", "lastVersion", "oldver", "latestVers", "latestVer", "latestServ", "Lastver", "lastVers", "lastServ", "nextVer", "latestRes", "nextVers", "lastRes", "LastVers", " lastServ", "lastver"], "oldlog": ["olderlog", "OLDpath", "OldLog", "OLDLog", "oldererr", "OLDlog", "oldLog", "Oldpath", " oldog", "olderog", "olderr", " olderr", "oldpath", "oldog", "Oldog", "OLDerr", "OLDog", "Oldlog", " oldpath", " oldLog", "olderLog", "olderpath"], "destPath": ["destTime", " destDir", "estName", "potPod", "DestFont", "gestName", "estPos", "destHost", "destNode", "destTh", "gestHost", "DestName", "estRef", " destTh", "locDisk", "descPath", "declFont", " destDirectory", "destFont", " destLog", "privRoot", "destDir", "altNode", "descKey", "destRoot", "srcDirectory", "srcDir", "destFull", "declFull", "foreignStream", "identPath", " destKey", "gestPath", " destParent", "restDir", "DestDir", "destRef", "DestPath", " destHost", "destName", " destPort", "gestTime", "sortFont", "DestFile", " destPoint", "DestRoot", "foreignDir", "DestRef", "identTh", "srcPath", "srcLog", " destRoot", "descNet", "gestDisk", "restPoint", "gestNet", "DestPod", "destPoint", "estDir", "gestNode", "destDirectory", "sortDir", "destPod", "destPos", "destKey", "altName", "destPort", "altPath", "identPort", "destDisk", "DestPoint", "DestFull", "privDir", "srcFile", " destName", "DestParent", "DestPort", "descPos", "srcPort", "destFile", "declDir", "descName", "identPoint", "sortPath", "foreignPath", "potStream", "originPoint", "altDir", "DestLog", "altPoint", "foreignPod", "sortFull", "locPath", " destRef", "potDir", "restFile", " destFile", " destNode", "destLog", "originTh", "originPath", " destPos", "restPath", "DestDirectory", "altHost", "altParent", "originPort", "estKey", "descTime", "privPath", "destParent", "DestPos", "declPath", "destStream", "locTime", "locNet", "descDisk", "potPath", "estPath", "privPos", "DestStream", "destNet"], "lastVerPath": ["lastVERDir", "lastVERVal", "lastVersPath", "lastResPath", "lastVerDir", " lastVersCh", " lastverPath", "highestVerVal", "lastVerspath", "lastverLog", "lastResForm", "highestVerFile", "lastVerForm", " lastVerpath", "lastVERpath", "lastverVal", "lastVERFile", "lastVersionpath", "lastRespath", " lastverDir", "lastResDir", "highestVerpath", "lastVerVal", "lastVERPath", "lastVersionFile", " lastverpath", " lastVerCh", "lastVersCh", "lastVerFile", "lastverDir", " lastVersPath", "lastVersVal", " lastVerFile", "highestVERpath", "lastverForm", " lastVerDir", " lastverForm", " lastVerLog", "lastVersionPath", " lastVerName", "lastVersLog", " lastVerForm", "highestVERVal", "highestVERPath", "lastverCh", "lastVersFile", "lastVersName", "lastVerCh", "highestVERFile", "lastverPath", "lastVerName", "lastVERForm", "lastVerLog", "lastverpath", "lastVerpath", "lastverFile", " lastVersLog", "lastverName", "highestVerPath", " lastVersFile", "lastVersionCh"], "bkdir": ["bkdi", "bckDir", "bckdi", "blkjgroup", "BkDir", "blkjdir", "bakDir", " bakDir", " bkrel", "bkpath", " bakfolder", "Bckdir", " bkkdir", " bkfolder", "bkjdi", "bakdir", "bukpath", " bakdir", "bqdir", "bkkdir", "bkjdir", "Bkpath", "BkDIR", "bckpath", "bukDIR", " bkkDir", "bakdi", "bqgroup", "blkjfd", "blkdi", "bkgroup", "blkjdi", "bkgDir", "bqfd", "bkgdir", " bakdi", " bkkfolder", "bkkfolder", "Bkdir", " bkkrel", "bakrel", "bkDIR", "bkkrel", "bkDir", "bkgfolder", "bkkdi", "bkfolder", "bkjgroup", "bkjfd", "bukDir", "blkdir", "bkkDir", "bckdir", "BckDIR", "blkgroup", "bukdi", "bukfd", "bqdi", "bkkDIR", "bukgroup", " bkDir", "bckDIR", "bkgrel", " bkdi", "blkfd", "Bckpath", "bukdir", "bckfolder", "bakfolder", "BckDir", "bkrel", "bkkpath", "bkfd"], "oldClassCopied": ["oldClassCopie", "oldclasscopies", "oldClassColied", "oldClassReplried", "oldClasscopified", "oldclasscopified", "oldClassCopyified", "oldclasscopie", "oldClassCopyied", "oldClasscopiated", "oldclassCopies", "oldClassChies", "oldclassCopified", "oldClassReplified", "oldDirCopiated", "oldClasscopried", "oldDirReplried", "oldDirCopied", "oldClassCopried", "oldClassChied", "oldDirReplies", "oldClassCopyies", "oldClasscopie", "oldClassCopies", "oldClassReplaced", "oldClassChried", "oldClassRepliated", "oldClassCopiated", "oldclassCopied", "oldClassColaced", "oldClassChiated", "oldClassCopaced", "oldDirReplied", "oldClassCopified", "oldClasscopied", "oldclassCopie", "oldClassReplied", "oldDirCopies", "oldClassCopyie", "oldClassColies", "oldDirCopried", "oldClassColified", "oldClasscopies", "oldClassReplies", "oldDirRepliated", "oldclassCopaced", "oldclasscopied"], "ls": ["cs", "ln", "ws", "ols", "ts", "bs", "rs", "lines", "ps", "las", "els", "irs", "ds", "ats", "ns", "ars", "ils", "gs", "acts", "es", "xs", "less", "LS", "lt", "dl", "abs", "fs", "lists", "lf", "its", "rl", "ms", "lv", "tl", "lc", "vs", "ists", "la", "los", "l", "sels", "lbs", "ics", "les", "qs", "ks", "lis"], "i": ["ix", "bi", "im", "ip", "init", "oi", "key", "mi", "is", "x", "ri", "phi", "gi", "ui", "ji", "it", "si", "a", "ini", "hi", "ami", "u", "cli", "b", "ski", "gu", "io", "ci", "me", "ti", "zi", "j", "multi", "di", "id", "xi", "fire", "m", "batch", "iq", "y", "ic", "eu", "ims", "ei", "qi", "ij", "chain", "us", "ki", "l", "I", "pi", "sim", "index", "ii", "li"]}}
{"id1": "5683576", "id2": "14231545", "code1": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 0, "substitutes": {"shorten": ["Shortener", "shortense", " Shortener", "shortener", " shortens", " Shortens", " Shortense", " Shorten", "shortens", " shortener", "Shortense", " shortense", "Shorten", "Shortens"], "url": ["Url", "name", "link", "html", "path", "domain", "key", "version", "string", "p", "pattern", "ret", "message", "json", "location", "b", "log", "host", "user", "password", "id", "base", "dl", "web", "http", "sl", "page", "str", "ll", "api", "address", "l", "URL", "document", "ls", "username", "ul", "format"], "qparams": ["qualpackages", "qualparam", "qoptions", "sqblocks", "iqpins", "qualparams", "qvparam", "qsfields", "dqparams", "quams", "qvargs", "iqblocks", "iqmarks", "quparams", "sqparts", "qqfields", "quargs", "qParameters", "qupins", "sqParameters", "QParameters", "qams", "qualparts", "sqdetails", "qupackages", "qumarks", "Qparams", "iqoptions", "qmarks", "iqparams", "sqterms", "qterms", "qqparams", "qunames", "qsparams", "qudetails", "dqmarks", "Qparam", "quterms", "qdetails", "qsargs", "qvparams", "qublocks", "quparam", "quoptions", "qmembers", "qparam", "iqterms", "sqoptions", " qams", "qfields", "quparts", "sqpackages", " qargs", "sqams", "dqmembers", "qpackages", "qvfields", "iqmembers", "qqargs", "sqnames", "qpins", "sqargs", " qdetails", "iqnames", "sqpins", "qblocks", "qargs", "iqparam", "dqparam", "sqparam", "qumembers", "Qpins", "qqparam", "iqParameters", "qnames", "sqparams", "qparts", "qsparam"], "params": ["eters", "parent", "pres", "atos", "settings", "cms", " parameters", "rs", "ps", "stats", "mm", "json", "Parameters", "config", "AMS", "param", "gs", "caps", "keys", "parser", "data", "pps", "conf", "details", "parts", "api", "spec", "changes", "types", "Par", "ctx", "terms", "ams", "options", "pi", "headers", "names", "cp", "properties"], "httpclient": ["Httpconnection", " httpcache", "Httpclient", "httpscache", "httpscli", " httpClient", "httpconnection", "httpcache", "HttpClient", "httpsclient", "httpsconnection", " httpmanager", "Httpmanager", "Httpcache", "httpsClient", "httpClient", "httpmanager", "httpsmanager", " httpcli", "Httpcli", "httpcli", " httpconnection"], "uri": ["remote", "unit", "html", "origin", "ri", "domain", "path", "ui", "ugi", "wiki", "via", "URI", "subject", "description", "u", "database", "doi", "source", "location", "query", "filename", "folder", "i", "resource", "base", "storage", "http", "du", "prefix", "range", "qi", "universal", "address", "api", "nu", "iri", "term", "pi", "ur", " URI", "uni"], "httpget": ["ttpsearch", "hoverGet", "hoverquery", "ttpGet", "httrequest", "httpscall", "httpcall", " httpcall", "HTTPget", "HTTPsearch", "httquery", "httpsearch", "ttprequest", "httpull", "httpscreate", "httpGet", "httget", "httpsget", "ttpget", "httprequest", "httpspull", "httpcreate", "httppull", "HTTPGet", "httpquery", "httGet", " httpsearch", " httpcreate", " httppull", " httpGet", "hoverget", "httcall", "httcreate", "hoverrequest", "ttpquery"], "response": ["sequence", "yes", "answer", "image", "resp", "still", "description", "message", "entry", "content", "json", "success", "given", "close", "one", "respond", "result", "application", "successful", "report", "http", "page", "status", "onse", "object", "Response", "frame", "body", "summary", "out", "output", "block", "connection", "request", "reply", "document"], "entity": ["obj", "existent", "icon", "le", "image", "activity", "tex", "enc", "Entity", "info", "entry", "content", "oe", "member", "ent", "e", "json", "ee", "event", "node", "resource", "email", "om", "orm", "existing", "error", "result", "person", "eme", "el", "valid", "peer", "status", "good", "body", "object", "ity", "output", "client", "em", "encrypted", "ce", "empty", "document", "pe"], "instream": ["imform", "inloader", "outStream", "INStream", "INform", "INconsole", "imloader", "inputform", " inform", "inform", "imstream", "incase", "inputcase", "inStream", "INstream", "intstream", "inconsole", "outstream", "intloader", "inputstream", "outform", "outconsole", " inStream", "imcase", "inputloader", "intform", " inconsole", "intcase"], "f": ["fp", "ff", "rf", "fab", "tf", "p", "full", "fm", "fo", "v", "F", "w", "e", "ph", "fx", "uf", "c", "fs", "fi", "fd", "conf", "bf", "lf", "fg", "sf", "t", "of", "foreign", "cf", "l", "Factory", "fr", "fac", "af", "alf", "ct", "df"], "jp": ["fp", "fps", "obj", "conn", "hp", "p", "jump", "jl", "uj", "ps", "ja", "pai", "ijk", "jo", "jc", "vp", "Ja", "np", "parse", "j", "JP", "bp", "lp", "kj", "jen", "pas", "java", "mp", "bj", "prot", "op", "dj", "adj", "dp", "pb", "pkg", "eps", "xp", "jj", "wp", "jas", "iat", "fr", "js", "peg", "sp", "gp", "cp", "tp"], "responseObj": [" responseBody", " responseVal", "responseObject", "ResponseVal", "ResponseObj", "requestOb", " responseOb", "ResponseCtrl", "ResponseBody", " responseObject", " responseCtrl", "ResponseOb", "responseOb", "replyObject", "responseVal", "requestCtrl", "ResponseObject", "requestObj", "replyBody", "responseBody", "replyVal", "requestObject", "responseCtrl", "replyObj"], "token": ["name", "KEN", "stat", "key", "span", "initial", "p", "notice", "operator", "task", "document", "before", "typ", "current", "pointer", "tick", "node", "json", "value", "ski", "number", "start", "variable", "session", "event", "when", "buffer", "function", "next", "parse", "local", "j", "template", "kt", "data", "channel", "error", "zero", "atom", "step", "complete", "txt", "type", "trigger", "lex", "tag", "object", "normal", "t", "browser", "element", "kn", "no", "relation", "ok", "table", "total", "word", "oken", "to", "tree", "list", "topic", "field", "reset", "note", "Token", "state"], "fieldname": [" fieldtype", "columnName", "columnid", "Fieldkey", "ieldName", "fieldtype", "columnname", "FIELDname", "cellname", "columnkey", "fieldval", "FIELDtype", "FIELDlen", "fieldid", "FIELDkey", " fieldid", "ieldname", "cellkey", "FIELDval", "FieldName", "cellName", "keyname", "ieldlen", "keyName", "fieldlen", "FIELDName", "Fieldval", "ieldtype", "keykey", "Fieldname", "fieldkey", " fieldkey", "fieldName", " fieldlen", "cellid", " fieldName", "keyval"]}}
{"id1": "17630906", "id2": "16572931", "code1": "    public static int[] sortAscending(float input[]) {\n        int[] order = new int[input.length];\n        for (int i = 0; i < order.length; i++) order[i] = i;\n        for (int i = input.length; --i >= 0; ) {\n            for (int j = 0; j < i; j++) {\n                if (input[j] > input[j + 1]) {\n                    float mem = input[j];\n                    input[j] = input[j + 1];\n                    input[j + 1] = mem;\n                    int id = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = id;\n                }\n            }\n        }\n        return order;\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 0, "substitutes": {"sortAscending": ["sortAucender", "sortAsScend", "sortAsScended", "sortAsscend", "sortAScended", "sortAsscending", "sortASCend", "sortAScending", "sortAsScending", "sortAsScender", "sortAscend", "sortAScend", "sortASCended", "sortAsscended", "sortAucending", "sortAucend", "sortASCender", "sortAscended", "sortAscender", "sortAsscender", "sortASCending", "sortAScender", "sortAucended"], "input": ["sequence", "cache", "array", "p", "stream", "content", "buffer", " Input", "context", "data", "bit", "accept", "from", "valid", "form", "in", "img", "cur", "text", "table", "list", "document", "xml", "before", "current", "sample", "config", "source", "start", "read", "error", "focus", "request", "exec", "filter", "raw", "inc", "view", "up", "active", "ip", "select", "pattern", "query", "parse", "batch", "base", "comment", "q", "command", "alpha", "out", "history", "Input", "output", " inputs", "qa", "hidden", "initial", "image", "it", "quick", "inner", "um", "feed", "file", "internal", "local", "check", "open", "get", "need"], "order": ["sequence", "cache", "where", "group", "are", "unit", "array", "Order", "ord", "and", "after", "master", "ordering", "before", "message", "memory", "info", "v", "r", "der", "allow", "priority", "sort", "rank", "here", "record", "error", "result", "comment", "force", "search", "only", "q", "arr", "command", "good", "page", "store", "random", "or", "trace", "code", "direction", "address", "er", "move", "rule", "test", "create", "condition", "grade", "dir", "iter", "position", "count", "core", "ice", "graph", "over", "list", "orders", "show", "cycle", "ordered", "index", "use"], "i": ["ix", "bi", "im", "ip", "init", "ri", "p", "mi", "it", "is", "phi", "gi", "ui", "si", "v", "g", "ini", "hi", "info", "ami", "integer", "MI", "mm", "iu", "cli", "ind", "ir", "io", "ci", "ori", "ti", "zi", "multi", "di", "xi", "f", "m", "eni", "sim", "q", " I", "y", "ic", "ity", "ims", "qi", "ij", "t", "ki", "at", "l", "ai", "I", "iat", "ie", "pi", "iti", "iq", "index", "ii", "li"], "j": ["ix", "obj", "server", "other", "key", "tr", "jump", "uj", "jl", "it", "ji", "bs", "ret", "g", "v", "ja", "job", "r", "je", "json", "last", "jo", "b", "jc", "ion", "kid", "og", "jack", "opt", "next", "user", "oj", "kj", "res", "el", "q", "J", "jac", "bj", "br", "y", "jet", "str", "ij", "aj", "dj", "out", "er", "pr", "jp", "adj", "o", "at", "l", "jit", "by", "rel", "jj", "pt", "req", "js", "z", "fr", "my", "note", "bot", "window", "ind", "state"], "mem": ["sm", "ram", "cpu", "ib", "lim", "mi", "mat", "pool", "mb", "dim", "memory", "mm", "temp", "cmd", "slot", "dem", "sam", "m", "med", "reg", "tim", "sum", "mu", "Mem", "md", "ms", " Mem", "buff", "mop", "alloc", "ame", "met", "req", "em", "js", "my", "size", "sim", "mt", "use"], "id": ["name", "link", "sid", "use", "orig", "key", "mi", "tx", "and", "oid", "mid", "info", "rand", "ide", "rid", "hd", "uid", "kid", "ID", "sd", "ad", "aid", "ld", "med", "fd", "ids", "tag", "md", "red", "jp", "d", "wid", "pid", " tid", "bid", "Id", "ident", " fid", "index", "vid", "ind"]}}
{"id1": "5723876", "id2": "17558353", "code1": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            URL urlhome = new URL(\"http://www.verussolutions.biz/NGLDashBoard.xml\");\n            URLConnection uc = urlhome.openConnection();\n            InputStreamReader input = new InputStreamReader(uc.getInputStream());\n            BufferedReader in = new BufferedReader(input);\n            String inputLine;\n            String xmlData = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                xmlData += inputLine;\n            }\n            in.close();\n            PrintWriter fw = new PrintWriter(new FileWriter(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            fw.println(xmlData);\n            fw.flush();\n            fw.close();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n        try {\n            Document doc = new SAXBuilder().build(new File(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            String onlinsuppcdat = doc.getRootElement().getChild(\"OnlineSupportInformation\").getText();\n            CDATA cdata = new CDATA(onlinsuppcdat);\n            host.setOnlineInformationHTML(cdata.getText());\n            onlinsuppcdat = doc.getRootElement().getChild(\"News\").getText();\n            cdata = new CDATA(onlinsuppcdat);\n            host.setNewsHTML(cdata.getText());\n            host.fillData();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"calculate": ["calural", "calculator", "calateate", "Calculate", "Calural", "calcator", "Calurate", "calateal", "calcate", "Calurator", "calculation", "calcation", "Calculator", "calurate", "calateator", "Caluration", "calculal", "calcal", "calateation", "caluration", "Calculal", "calurator", "Calculation"], "f": ["fp", "xf", "rf", "tf", "p", "g", "v", "fn", "r", "F", "w", "e", "file", "i", "h", "fa", "fc", "m", "c", "fs", "fi", "fd", "bf", "t", "sf", "d", "l", "cf", "s", "fr", "fac", "alf", "fb"], "md": ["sm", "metadata", "dig", " mm", "mt", "cd", "MD", " m", "ming", " cmd", "dm", "mm", "mac", "der", "cmd", "managed", "grad", "ind", "bd", "gm", "sd", "mod", "esm", "pd", "rpm", "m", "det", "mark", " dd", " cd", " mc", "pm", "mp", "rm", " rm", "red", "mg", "ms", " mg", "mn", "d", "met", "ma", "pt", "mand", "dd", "mc", "dr", "mk", "hd", "sha"], "rd": ["ri", "rer", "rs", "nder", "hr", "ru", "r", "din", "rr", "rand", "rn", "sr", "rid", "ren", "rad", "rown", "rar", "RD", "dra", "rog", "ry", "rus", "ld", "rm", "rl", "rob", "red", "xd", "rg", "ro", "rw", "d", "rh", "nd", "ra", "mr", "erd", "rc", "rb", "dq", "fr", "dd", "rt", "dr", "reader"], "buffer": ["sequence", "cache", "now", "display", "document", "mb", "message", "memory", "sample", "database", "source", "bridge", "black", "buf", "Buffer", "template", "bar", "library", "queue", "batch", "base", "command", "relative", "buff", "binary", "bo", "bm", "phrase", "bound", "table", "output", "null", "ob", "block", "connection", "row", "que", "input", "screen", "reset", "background", "print", "bare", "directory", "window", "absolute"], "line": ["link", "sequence", "online", "ln", "liner", "ip", "header", "le", "stroke", "string", "ine", "part", "lines", "message", "sample", "entry", "Line", "source", "point", "log", "date", "email", "LINE", "record", "eline", " lines", "user", "comment", "lin", "nl", "page", "cell", "frame", "range", "set", "text", "chain", "no", "phrase", "lo", " Line", "l", "iter", "word", "block", "row", "inline", "column"], "digest": ["dEST", "Digest", "derEST", "dependEST", "dester", "dest", "Digester", "decgest", "derest", "validest", "Diggest", "mdest", "dependests", "diggest", "validests", "digse", "digests", "validse", "dependest", "validested", "digested", "derested", "dependgest", "mdse", "Digse", "decests", "digEST", "decEST", "DigEST", "digester", "Digests", "dested", "decest", "Digested", "derester", "mdests", "mdested"], "result": ["name", "sequence", "response", "answer", "string", "Result", "true", "continue", "cup", "description", "message", "r", "content", "value", "currency", "success", "params", "json", "product", "date", "join", "reason", "results", "profile", "data", "complete", "comment", "res", "report", "command", "status", "prefix", "str", "mask", "text", "summary", "out", "relation", "csv", "length", "output", "section", "term", "word", "table", "list", "wrapper"], "b": ["bi", "obj", "p", "bc", "bs", "cb", "mb", "v", "a", "B", "r", "sb", "nb", "e", "bd", "bin", "i", "h", "k", "bb", " B", "m", "c", "base", "bu", "bis", "bf", "gb", "y", "br", "t", "binary", "bo", "d", "l", "bound", "db", "ob", "rb", "fb", "be", "n"]}}
{"id1": "22993368", "id2": "11645260", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeString2file", "decodeFileAsfile", "decodeFile2Files", "decodeStringToFiles", "decodeStringTofile", "decodeFileAsFile", "decodeFileTofile", "decodeFileToString", "decodeFileFilefile", "decodeFileAsFiles", "decodeFileToFiles", "decodeFile2file", "decodeFileFileFiles", "decodeString2String", "decodeFileFileString", "decodeString2File", "decodeString2Files", "decodeStringToFile", "decodeFileAsString", "decodeFile2File", "decodeStringToString", "decodeFile2String", "decodeFileFileFile"], "infile": ["inFile", "infolder", "outFile", "InFile", "fromfile", "isinname", "Inbase", "inbase", "frombase", "infilename", "isinfolder", "outname", "isinfile", "outbase", "fromFile", "inputname", "inputfolder", "Infile", "inname", "outfilename", "fromfilename", "Infilename", "outfolder", "inputfile", "inputFile", "isinFile"], "outfile": ["otfile", "inFile", " outname", "Outfilename", " outFILE", "outFile", " outFile", "todir", "Outfile", "outdir", "otFILE", "infilename", "toFile", "tofilename", "indir", "otname", "outname", "inname", "outfilename", "Outdir", "otFile", "outFILE", "OutFile", "tofile", "inFILE"], "in": ["inn", "im", "al", "inc", "up", "pin", "conn", "init", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "gin", "on", "id", "from", "In", "form", "or", "amin", "ins", "inside", "t", "en", "IN", "by", "get", "iter", "con", " din", "cin", "rin", "input", "re", "ar", "inf", "oin", "ind"], "out": ["auto", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "aos", "outer", "flush", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "null", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "character", "sequence", "cache", "view", "shape", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "variable", "bone", "pad", "buf", "black", "Buffer", "append", "template", "bar", "padding", "library", "available", "password", "button", "note", "batch", "base", "comment", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "block", "row", "print", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "shift", "run", "connect", "allow", "through", "query", "start", "i", "push", "close", "give", "send", "wait", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "req", "count", "iter", "seek", "end", "skip", "input", "readable", "need", "n", "size", "print", "reader", "index", "ind", "Read"], "success": ["response", "town", " okay", "first", "same", "fail", "continue", "primary", "scope", " successes", "support", " successful", "commit", "positive", "growth", "photo", " succeeds", "safe", " succeed", "submit", "value", " succ", "second", "snap", "Success", "city", "ccess", "successfully", "error", "ceed", "result", "successful", "complete", "setup", "done", "accept", "crit", "sufficient", "release", "democracy", "valid", "status", "good", "surv", "danger", "summary", "condition", "please", "ok", " failure", "unity", "ratulations", "cess", "exist"]}}
{"id1": "19747399", "id2": "11305840", "code1": "    @Before\n    public void setUp() throws Exception {\n        connectionDigestHandler = new ConnectionDigestHandlerDefaultImpl();\n        URL url = null;\n        try {\n            url = new URL(\"http://dev2dev.bea.com.cn/bbs/servlet/D2DServlet/download/64104-35000-204984-2890/webwork2guide.pdf\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n        try {\n            uc = url.openConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"setUp": ["setup", " setup", "startUP", "startUp", "settingup", "setUP", "settingUp", "settingUP", "startDown", "startup", "setDown", " setUP", " setDown", "settingDown"], "connectionDigestHandler": ["connectionDigestingFilter", "connectionSequestingHandler", "connectionDigestedManager", "connectionSequestManager", "connectionDigestReader", "connectionSequestingReader", "connectionSequestingManager", "connectionDigestsManager", "connectionDigestingManager", "connectionSequestingFilter", "connectionSequestFilter", "connectionDigestsReader", "connectionDigestsHandler", "connectionDigestFilter", "connectionSequestHandler", "connectionDigestedHandler", "connectionDigestingHandler", "connectionDigestedReader", "connectionDigestedFilter", "connectionSequestReader", "connectionDigestingReader", "connectionDigestManager", "connectionDigestsFilter"], "url": ["mail", "Url", "name", "link", "obj", "html", "conn", "path", "cert", "pl", "p", "ret", "xml", "loader", "r", "u", "mount", "file", "config", "location", "b", "gl", "resource", "ssl", "host", "context", "bel", "id", "result", "base", "il", "dl", "github", "web", "http", "nl", "sl", "el", "page", "impl", "str", "ll", "browser", "out", "address", "https", "loc", "rel", "l", "db", "open", "null", "ob", "lr", "URL", "ml", "ls", "ur"], "uc": ["access", "cas", "ac", "ec", "ocr", "tc", "u", "cl", "gc", "ssl", "unc", "c", "res", "oc", "ucc", "nc", "ocl", "orc", "lc", "dc", "sc", "con", "os", "rc", "UC", "mc", "cp", "uu"]}}
{"id1": "9413074", "id2": "11341711", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getLocation": ["newLocation", " getlocation", "loadLocation", "getURL", "getURI", " getURL", "GetLoc", "newlocation", "loadURL", "getDescription", "getLoc", "GetDescription", "newLoc", " getLoc", "Getlocation", "GetURI", "loadURI", "GetLocation", "newDescription", " getDescription", " getURI", "loadDescription", "GetURL", "getlocation"], "clazz": ["ClClass", "scamp", "klClass", "scaz", "claz", "klaz", " claz", "Clazz", " clos", "CLazz", "klclass", "Clamp", "CLclass", "Claz", "clclass", "klazz", "CLaz", " clamp", "clClass", "Clos", "scazz", "clos", "scos", "clamp", "CLClass", "Clclass"], "url": ["remote", "Url", "link", "util", "mail", "hl", "conn", "path", "cert", "string", "handle", "socket", "org", "char", "ret", "this", "xml", "loader", "r", "u", "sb", "run", "mount", "log", "err", "gl", "buffer", "ssl", "resource", "host", "build", "channel", "user", "result", "f", "dl", "base", "abs", "uri", "web", "nl", "http", "q", "sl", "sql", "rl", "impl", "str", "ll", "browser", "address", "ref", "https", "loc", "rel", "l", "client", "get", "ob", "lr", "row", "URL", "ml", "ls", "ur", "ul", "addr"], "location": ["name", "where", "origin", "path", "none", "Location", "string", "display", "description", "scope", "availability", "message", "usage", "title", "expression", "ocation", "value", "update", "filename", "layout", "ion", "slot", "resource", "resolution", "function", "local", "reference", "behavior", "padding", "translation", "library", "media", "result", "selection", "application", "comment", "displayText", "type", "nl", "command", "trace", "peer", "region", "color", "feature", "range", "language", "summary", "direction", "address", "history", "loc", "relation", "l", "length", "family", "position", "row", "operation", "document", "directory", "area"], "file": ["ile", "port", "name", "fp", "path", "parent", "le", "File", "image", "full", "face", "entity", "run", "folder", "filename", "resource", "io", "channel", "FILE", "checked", "library", "user", "files", "f", "page", "object", "out", "binary", "angle", "ref", "db", "table", "output", "module", "dir", "block", "ca", "ory", " File", "pe", "format"]}}
{"id1": "15896098", "id2": "15904772", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 1, "substitutes": {"getSHA256Checksum": ["getSHA256Checkchecksums", "getSHA256Checkcksume", "getSHA256Checkchecksume", "getSHA256Checsums", "getSHA256Checksam", "getSHA256Checkums", "getSHA256Checksums", "getSHA256Chechecksum", "getSHA256Chechecksam", "getSHA256Checkchecksum", "getSHA256Checsum", "getSHA256Checsume", "getSHA256Checkcksum", "getSHA256Checkcksums", "getSHA256Chechecksume", "getSHA256Checkume", "getSHA256Chechecksums", "getSHA256Checkcksam", "getSHA256Checksume", "getSHA256Checkum", "getSHA256Checsam", "getSHA256Checkchecksam", "getSHA256Checkam"], "source": ["Source", "name", "url", "sequence", "path", "image", "string", "this", "ource", "src", "message", "sample", "subject", "target", "content", "value", "file", "filename", "buffer", "context", "reason", "data", "template", "base", "from", "status", "body", "in", "text", "out", "seed", "output", "s", "input", "SOURCE", "style", "secret", "raw", "format"], "checksum": ["checkum", "cksume", " checkssum", "checkume", "cssum", "checkumb", "checksim", " checksums", "checkssum", " checksume", "csim", "checkim", "ckssum", "checksume", " checksumb", "csume", "checksums", "cksim", "cksums", "cksum", "checksumb", " checksim", "cksumb", "checkums", "csum"], "md": ["sm", " MD", "dr", "mt", "wd", "def", "cd", "mb", "MD", "nt", "dm", "dh", "mo", "mm", "der", "od", "cmd", "grad", "hd", "ind", "bd", "sd", "mod", "ad", "di", "ld", "m", "det", " Md", "down", "Cmd", "pm", "mp", "red", "ms", "mg", "mn", "d", "mand", "dd", "mc", "pdf", "mk", "df", "pd"], "byteData": ["byteRel", "ByteBytes", "ioDATA", "routeDATA", "sliceDat", "bytesData", "byteParts", "wordArray", "routeData", "ioDat", "ioData", "bleRel", "ByteParts", "reverseDat", " byteParts", "bytedata", "wordData", "channeldata", "channelRel", "reverseDATA", "reverseCount", " byteCount", "byteCount", "ioList", "phraseBytes", " bytedata", "channelData", "wordBytes", "channelParts", "ByteData", " byteArray", "phraseData", "ByteDATA", "bytesDATA", "bleData", "sliceList", "bytesArray", "phraseParts", "byteDATA", "reverseData", "sliceDATA", "routeCount", "byteDat", " byteDATA", "byteArray", "bleParts", "routeDat", " byteDat", "bytesBytes", "sliceData", " byteList", " byteBytes", "bledata", "wordDATA", "byteList", "byteBytes", "phraseDATA", " byteRel"], "sb": ["sm", "erb", "bg", "ib", "SF", "sq", "shell", "bs", "cb", "mb", "si", "sa", "bh", "sbm", "sh", "nb", "lb", "b", "ssl", "bsp", "bb", "sg", "sam", "sw", "sv", "lp", "eb", "bash", "bis", "gb", "bj", "bf", "sf", "wb", "ub", "kb", "pb", "db", "obb", "bt", "ob", "rb", "SB", "zb", "sp", "bps", "xb"], "i": ["ix", "im", "ime", "phi", "ui", "hi", "major", "info", "ski", "gu", "io", "ci", "multi", "di", "uri", "ic", "set", "ity", "ei", "qi", "I", "list", "my", "sim", "ind", "ii", "si", "life", "iu", "series", "point", "xi", "m", "ki", "remote", "ip", "ri", "this", "g", "u", "cli", "json", "\u0438", "err", "me", "id", "q", "y", "ims", "ms", "ij", "chain", "history", "loop", "o", "ai", "ie", "print", "bi", "init", "oi", "any", "mi", "it", "gi", "ji", "ini", "ion", "ti", "j", "iy", "er", "l", "client", "to", "pi", "iq", "li"], "hexString": ["hexResource", "hashstring", "shortArray", "fullBuffer", " hexArray", "htmlBuffer", "hexArray", "hexStore", " hexstring", " hexBuffer", "htmlstring", "exArray", " HexResource", " HexBuffer", " hexResource", "htmlString", "fullStore", "exString", "hashArray", "exBuffer", "shortstring", "hashString", " hexStore", "shortString", "exstring", "shortBuffer", "fullstring", " HexString", "hashBuffer", " Hexstring", "fullString", "shortResource", "htmlArray", "hexstring", "hexBuffer", "exStore"], "hex": ["zh", "hl", "php", "html", "comp", "exp", "alph", "none", " ex", "full", "tx", "x", "tex", "def", "sh", "rex", "ex", "temp", "json", "hello", "lit", "ph", "alias", "h", "prop", "sex", "ext", "dump", " Hex", "cont", "mix", "solid", "oct", "he", "com", "form", "pex", "des", "rh", "term", " sex", "flash", "cat", "rendered", "raw"]}}
{"id1": "2668853", "id2": "14191679", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2Files", "decodeFileAsFile", "decodeFileTOString", "decodeFileToString", "decodeFileTOFile", "decodeFileAsFiles", "decodeFileToFiles", "decodeFileToPage", "decodeFilesToFiles", "decodeFilesToFile", "decodeFileTOPage", "decodeFiles2Files", "decodeFiles2Page", "decodeFilesToPage", "decodeFileAsString", "decodeFileTOFiles", "decodeFile2File", "decodeFileAsPage", "decodeFiles2File", "decodeFile2Page", "decodeFilesToString", "decodeFiles2String", "decodeFile2String"], "infile": ["inFile", "inputwhere", "outFile", "InFile", " inwhere", "innfile", "inputfilename", "inwhere", "inbase", " inbase", "Inbase", "innwhere", "infilename", "inpath", "innbase", "Inpath", "outbase", "innfilename", "Infile", "outpath", "inputfile", "inputpath", "inputFile", "inputbase", " infilename"], "outfile": ["inFile", "Outfilename", "outFile", "listfile", "infp", " outFile", "tofp", "listfilename", "listFile", "Outfile", "infilename", "toFile", "inpath", "tofilename", " outpath", "Outpath", "outfp", "outfilename", "outpath", "listfp", " outfilename", "OutFile", "tofile"], "in": ["inn", "im", "al", "inc", "pin", "conn", "init", "image", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "io", "gin", "user", "on", "from", "In", "form", "amin", "ins", "inside", "en", "IN", "ro", "o", "by", "get", "iter", "con", "ai", "n", " din", "cin", "rin", "input", "re", "inf", "oin", "ind"], "out": ["ln", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "w", "aos", "outer", "flush", "ent", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "sequence", "cache", "view", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "bone", "variable", "pad", "black", "buf", "Buffer", "append", "template", "bar", "padding", "zero", "available", "password", "note", "batch", "base", "comment", "queue", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "length", "block", "tree", "row", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "shift", "run", "connect", "through", "query", "start", "i", "push", "close", "give", "data", "send", "wait", "q", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "iter", "count", "seek", "end", "skip", "need", "readable", "input", "size", "print", "reader", "index", "pe", "Read"], "success": [" convergence", "response", "town", " okay", "first", "same", "continue", "master", "support", " successes", "commit", " successful", "growth", "photo", " succeeds", "safe", " succeed", "submit", " succ", "second", "snap", "Success", "city", "close", "ccess", "successfully", "error", "warning", "ceed", "result", "successful", "complete", " successfully", "security", "accept", "crit", "sufficient", "done", "cont", "release", "democracy", "valid", "status", "good", "surv", "danger", "green", "summary", " Success", "please", "ok", " failure", "setup", "unity", "ratulations", " succeeded", "top", "cess", "primary", "exist"]}}
{"id1": "23672408", "id2": "23273706", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"copyIconFiles": [" copyIconImages", " copyiconFiles", " copyiconDocuments", "copyIconfiles", " copyIconDocuments", "copyiconDocuments", "copyIndexImages", "copyiconFiles", "copyiconImages", " copyIconfiles", "copyIndexDocuments", " copyiconImages", " copyiconfiles", "copyIndexfiles", "copyIndexFiles", "copyIconImages", "copyiconfiles", "copyIconDocuments"], "clazz": ["crus", "relazz", "clbo", " clbean", "escojure", "callace", "classazz", "plaz", " classe", "classotted", " claz", "descab", "clashed", "escazz", "escace", "descose", "clace", " clotted", " cluster", "classuddy", "clab", "CLace", "classe", "descazz", "chojure", " plub", " cluddy", "descaz", "clbean", "colluddy", " clbo", " club", "cluster", "callazz", "relaz", "pkgasse", "scloser", "sclazz", "sclbean", " clace", "pkgashed", "club", "sclace", "pkgazz", "clus", "Clbo", "craz", "relab", "crub", "plazz", "plasse", "clotted", "callaz", "Clab", "chazz", "CLbean", "closer", "collotted", "claz", "Clazz", "callbo", "CLazz", "Close", "Claz", "pkgaz", "cluddy", " clojure", " plus", " clashed", "plashed", " plazz", " closer", "relose", "chace", " clus", "Clace", "close", "escotted", "collazz", " plaz", "classuster", "clojure", "CLoser", "crazz", "colluster", "chotted"], "i16": ["ri16", "pi150", "ii24", "i6", "ami150", "ami19", " i160", "iri6", "i24", "pi6", "ji6", "i216", "ji150", "ji63", "i150", "ami63", " i2016", "pi63", "ini19", "pi16", " i157", "i157", "ini2016", " i6", "ini160", "iniShort", "li16", "ini216", "i63", "ii16", "iri16", "ami2016", "iri2016", " i216", "ami6", "iri157", "ri2016", "amiShort", "ini16", "ji16", "ii216", "liShort", "ri6", "li2016", "ami16", "li19", "ri157", " i24", "i2016", "iShort", "i19", "i160", "ii160", "ini24"], "fileType": ["fileValue", " fileTyp", " fileList", "relationType", "resourceUnit", "fileFamily", "FileName", "resourceFormat", "fieldType", "fileTYPE", " filetype", "coreType", "fieldDef", "fileTyp", "treeTime", "resourceTYPE", "policyHandler", "issuePattern", "webDef", "issueType", "policyFamily", "eventUnit", "policyTyp", "webTyp", "formattype", "ileType", " fileValue", "fileName", "fileDef", "formatType", "relationTyp", "ilePattern", " fileFormat", "FILEType", "eventTYPE", "treeType", "viewTYPE", "fileHandler", "webList", "fieldTYPE", "filetype", "FILEtype", "formName", "formatTYPE", "webType", "formType", "treetype", "Filetype", "fileList", "issuetype", " fileTYPE", "eventList", "eventType", "relationFamily", " fileTime", "coreFamily", "formatTime", "policyType", "formtype", "ileTyp", "fileUnit", " fileUnit", "issueTyp", "viewtype", "formatValue", "coreDef", "filePattern", "coreTYPE", "viewType", "coreHandler", "coreTyp", "FILEName", "treeTYPE", "fileTime", " filePattern", "viewValue", "resourceType", "webTYPE", "eventFormat", "relationHandler", "fieldTyp", "FileType", "fileFormat", "iletype"], "desti16": ["destsi160", "destgi2016", "desti24", "resultii24", "destui24", " destsi160", "destii2016", "resulti2016", "destgi16", " destsi18", " desti18", " destsi16", "desti216", " destsi32", "destxi16", "destii16", "resulti216", "desti18", "destui160", "destui16", "destii24", "desti160", "destsi32", "destui18", "destgi24", "resulti16", "desti2016", "resultii216", " desti160", "destsi18", "destsi16", "resultii2016", "destxi160", "destii216", "destui2016", "destgi216", "destxi32", "destui32", "destui216", "resultii16", "resulti24", "destxi18"], "src": ["scan", "hl", "sec", "obs", "bg", "comp", "ln", "inst", "sq", "cmp", "bc", "addr", "cb", "inner", "rs", "dest", "bh", "via", "sr", "sb", "rx", "cli", "syn", "sel", "source", "sys", "bin", "etc", "sit", "ssl", "gs", "tmp", "ptr", "fc", "sync", "txt", "cont", "std", "nl", "sl", "ctr", "vr", "rl", "st", "rob", "sol", "ser", "isl", "cur", "ins", "ibl", "urg", "img", "loc", "rg", "rel", "usr", "pkg", "sn", "proc", "ctx", "sc", "iter", "req", "rc", "sub", "rb", "input", "sp", "ls", "desc", "rest", "iv"], "dst": [" dnd", "dnet", "Ddest", "ddest", "dsot", "ddst", "tgt", "dsest", "dput", " dput", " dgt", "dmt", "rdsts", " dsts", "rst", "nst", " dmt", "dsst", "ndest", "rcut", "tput", "ndst", "dLbl", "rbl", "dest", "nput", "ddr", "derst", "rdst", "dnd", "fnd", " dot", "ndsts", "dsnet", "Ddr", "dmn", " dmn", "dddest", "dcut", "ddmn", "dsts", "dLest", "nnd", "Dnd", "ngt", "tnd", "dLdest", " dnet", "dgt", " dbl", "dLcut", "dbl", " ddr", "rdest", " ddest", "dot", "tst", "fdest", "dLst", "derdest", "ndmt", " dest", "dermn", "fst", "ddnd", "rdmt", " dcut", "Dst", "dernd", "fdr", "dLnet", "dLot"], "i32": ["i342", "ic32", " i342", "ic342", "ini22", "i34", "ii342", "ii34", "ini31", " i86", "isi86", "pi64", "pi34", " i31", " i34", "ini48", "isi64", "ic31", "ii28", " i40", "ic48", "xi31", "ic86", "ic22", "isi40", "i40", " i28", "ip32", "pi32", "ip34", "i86", "ip64", "xi48", "xi32", "i64", "i28", "isi32", "ic40", "ini32", " i64", "ic28", "ic34", "ii32", "ic64", "xi22", "ip31", "i48", "i31", "i22", "pi31"], "desti32": ["DestI256", "destI256", "Desti90", "destdi34", "Desti31", "targeti31", "destI90", "destu256", "targetpi30", "destu90", "desti30", "targetpi31", "destu31", "DestI90", "destI32", "Desti256", "Desti32", "desti31", "destic34", "destic32", "targetpi34", "destpi30", "targetpi32", "destdi32", "destpi31", "desti90", "targeti34", "destdi30", "targeti30", "destic31", "destI31", "destic30", "destu32", "DestI31", "destdi31", "destpi32", "desti256", "desti34", "DestI32", "destpi34", "targeti32"]}}
{"id1": "9261777", "id2": "4938100", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"source": ["Source", "volume", "sequence", "where", "view", "origin", "path", "init", "parent", "string", "back", "char", "ui", "ource", "scope", "src", "subject", "sample", "se", "target", "content", "copy", "title", "info", "expression", "file", "config", "query", "start", "filename", "resource", "context", "reason", "template", "base", "from", "uri", "search", "clip", "site", "status", "form", "sql", "body", "prefix", "store", "service", "details", "str", "text", "language", "check", "spec", "address", "component", "table", "tree", "input", "script", "ce", "size", "SOURCE", "style", "index", "use", "lower"], "destination": ["destinate", "testination", "portine", "tempinator", " destend", "destend", "testinate", "certinator", "origination", " destine", "combinator", "goodination", "declinations", "destino", "declacement", "certination", "destacement", "declinate", "combinant", "tempino", "destinant", "origend", "testino", "goodinate", "certacement", "destinator", " destinate", "combination", "testinator", "origine", "goodinator", " destino", "combinations", "tempination", "portend", "destinations", " destinator", "distinator", "originator", "distination", "certinate", "declinant", "destine", "portination", "declinator", "portinator", "distinant", "goodacement", "tempinate", "declination", "distinations"], "is": ["tis", "im", "bits", "obs", "are", "ri", "ib", "init", "ip", "ois", "icks", "iss", "ts", "bs", "si", "isin", "ps", "info", "ns", "isa", "dis", "sis", "iso", "Is", "ir", "i", "isf", "ris", "sys", "es", "IS", "zes", "abs", "webkit", "bis", "its", "ic", "in", "ios", "ims", "ms", "isl", "ins", "has", "us", "ains", "vs", "ais", "iris", "vis", "was", "iter", "mus", "s", "isc", "oss", "js", "ires", "ics", "ie", "mis", "isi", "ist", "nis", "lis"], "os": ["bos", "obs", "oes", "ose", "Os", "ols", "ts", "css", "bs", "uts", "oS", "ox", "mos", "aos", "ns", "dis", "ost", "pos", "asis", "sys", "cos", "ys", "io", "ss", "OS", "es", "ones", "zero", "on", "mot", "osi", "fs", "ot", "bis", "oa", "or", "ops", "ios", "ms", "mes", "o", "oses", "los", "dos", "ob", "s", "oss", "\u00f3", "outs", "ks", "oos"], "buffer": ["sequence", "cache", "view", "shape", "display", "document", "message", "sample", "memory", "stack", "database", "temp", "event", "variable", "pad", "buf", "Buffer", "append", "template", "bar", "padding", "library", "available", "button", "queue", "batch", "comment", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "word", "block", "row", "background", "window"], "length": ["character", "volume", "sequence", "len", "offset", "path", "span", "shape", "full", "string", "height", "bus", "display", "capacity", "reading", "ty", "before", "distance", "integer", "ence", "database", "partial", "last", "number", "hello", "start", "point", "pad", "ENGTH", "padding", "ment", "tail", "ength", "l", "type", "needed", "time", "ith", "frequency", "bow", "text", "of", "collection", "load", "angle", "history", "loop", "duration", "enth", "component", "split", "total", "position", "count", "width", "end", "family", " Length", "th", "size", "Length", "ind", "stop"]}}
{"id1": "807346", "id2": "18570190", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"runScript": ["executeCode", "runCode", " runCode", "executeProgram", " runscript", "callProgram", "callCode", "callScript", " runProgram", "executeScript", "runProgram", "executescript", "callscript", "runscript"], "scriptName": [" scriptBody", " scriptPath", "criptFile", " scriptFile", "criptPath", "scriptBody", "criptBody", " scriptKey", "fileKey", "filename", " scriptname", "scriptKey", "templateFile", "filePath", "templateBody", "templatePath", "scriptPath", "scriptname", "ScriptKey", "criptName", "ScriptPath", "ScriptName", "Scriptname", "fileName", "templateName", "scriptFile"], "data": ["name", "sequence", "response", "cache", "html", "image", "raw", "ata", "action", "p", "string", "some", "this", "description", "a", "message", "info", "what", "content", "title", "partial", "value", "json", "source", "div", "buffer", "all", "debug", "log", "comments", "reason", "dat", "next", "results", "video", "default", "padding", "error", "result", "step", "alert", "comment", "type", "res", "report", "command", "str", "text", "t", "chain", "out", "rew", "rel", "table", "output", "to", "DATA", "row", "input", "list", "empty", "extra", "missing", "window", "n", "format"], "url": ["mail", "Url", "link", "hl", "pl", "char", "r", "job", "mount", "lb", "b", "log", "gl", "ssl", "resource", "build", "bel", "user", "f", "base", "dl", "abs", "uri", "web", "http", "sl", "nl", "str", "ll", "browser", "address", "out", "https", "loc", "rel", "l", "open", "get", "URL", "ur", "ul"], "in": ["inn", "inc", "al", "is", "it", "mat", "act", "inner", "stream", "isin", "r", "din", "info", "mm", "source", "all", "bin", "i", "io", "serv", "gin", "val", "on", "In", "body", "check", "ins", "en", "out", "IN", "l", "ma", " din", "input", "cin", "rin", "pi", "mc", "inf", "ind"], "buffIn": ["BuffIn", " buffedIn", " BuffIn", "bufOut", " BuffCon", "buffOut", " buffOut", " BuffOut", "bufIn", "BuffOut", "bufferIn", "bufferCon", "buffedIn", "buffIns", "bufferOut", "BuffedIn", "BuffCon", "buffCon", " BuffIns", "BuffIns", "bufferIns", "bufedIn"], "temp": ["character", "sequence", "cap", "tem", "cert", "cel", "tc", "current", "index", "acc", "deg", "perm", "perature", "wr", "buffer", "variable", "i", "read", "tmp", "Temp", "dat", "mod", "j", "template", "ptr", "there", "result", "txt", "fake", "stem", "tim", "cell", "Temperature", "cur", "porary", "t", "relative", "thread", "test", "length", "output", "term", "pt", "input", "emp", "mint"]}}
{"id1": "4223002", "id2": "421042", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getPasswordMD5": ["getPasswordHS5", "getPasswordSM5", "getPasswordSM6", "getTokenSM512", "getTokenMD5", "getPasswordHS512", "getPasswordHS4", "getTokenMD4", "getTokenSM5", "getTokenSM6", "getTokenMD6", "getPasswordSM512", "getTokenSM4", "getPasswordSM4", "getPasswordMD4", "getPasswordMD6", "getPasswordmd5", "getPasswordmd4", "getPasswordmd512", "getPasswordmd6", "getTokenMD512", "getPasswordMD512", "getPasswordHS6"], "algorithm": ["thegorith", "almother", "algo", "Algorithm", " Algorith", "eargebra", " Algorithm", "already", "alphgorithm", "omalgorithm", "halric", "aluristic", "omaluristic", " algorith", "alphgorith", "alignment", "thechemist", "eargorith", " aluristic", "approgorithm", "halready", "approignment", "algebra", "Aluristic", "alphric", "halgorithm", "malgorith", " alignment", "halgorith", "alchemist", "eargorithm", "thegorithm", "malmother", "alric", "omalgo", "approready", " already", "Algorith", "themother", "Algo", " Alchemist", "algorith", "omalgorith", " algo", "approgorith", "halignment", "malchemist", "alphgebra", "halgebra", " Almother", "malgorithm", "earric"], "messageDigest": [" messagedigested", "messageMixse", " messageDigested", "MessageDigse", "messageMixest", "messageMixEST", " messageDigester", "MessageDigEST", "messageDriester", "Messagedigest", "messageDigitalEST", "messagedigests", "Messagedigests", "messagedigse", "messageDEST", "messageDriist", "MessageDigests", "messagedigested", "messageAndester", "messageDigitalester", "messageDesignest", "Messagedigse", "messageDests", "messageAndse", "messageMixests", "messageDesignester", "messageAndist", "messageDigester", "messageDesignested", "messageDigse", "messageDigEST", "messageDigitalest", "messagedigester", "messagedigist", " messagedigEST", "MessageDigist", "MessageDigest", "messageAndest", "Messagedigester", " messagedigester", "messagedigest", "messageDse", "messageDesignEST", "MessageDigester", "messageDriest", "messageDigests", "messageDigested", "messageDrise", "Messagedigist", "messagedigEST", "messageDigist", " messageDigEST", "messageDigitalested", " messagedigest", "MessagedigEST", "messageDest"], "hexString": ["stringstring", "octArray", "httpsScreen", " hexArray", "octScreen", "hexArray", "textStatement", "httpsBuffer", "httpsstring", " hexstring", " hexBuffer", "exArray", "textBuffer", "httpsArray", "httpsStatement", "hexScreen", "textArray", "textString", "exString", "stringArray", "exBuffer", "stringString", "httpsString", "octString", "exScreen", "exstring", " hexStatement", "octstring", "stringBuffer", "hexstring", "hexBuffer", "hexStatement"], "i": ["ix", "im", "bi", "ip", "init", "key", "span", "ri", "is", "mi", "x", "it", "phi", "gi", "ui", "ji", "si", "ex", "a", "hi", "u", "cli", "\u0438", "ski", "point", "gu", "io", "ci", "ti", "zi", "multi", "j", "di", "xi", "m", "c", "uri", "ii", "q", "y", "ei", "set", "ic", "in", "ms", "qi", "chain", "us", "loop", "o", "client", "ai", "I", "ie", "my", "pi", "yi", "sim", "n", "ind", "li"]}}
{"id1": "6418781", "id2": "12490144", "code1": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String[] names = client.listNames();\n            for (String name : names) {\n                System.out.println(\"Name = \" + name);\n            }\n            FTPFile[] ftpFiles = client.listFiles();\n            for (FTPFile ftpFile : ftpFiles) {\n                if (ftpFile.getType() == FTPFile.FILE_TYPE) {\n                    System.out.println(\"FTPFile: \" + ftpFile.getName() + \"; \" + FileUtils.byteCountToDisplaySize(ftpFile.getSize()));\n                }\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private void createJCoPluginProject(IProgressMonitor monitor, String sourceFileName, String pluginName) throws CoreException, IOException {\n        monitor.subTask(MessageFormat.format(Messages.ProjectGenerator_CreatePluginTaskDescription, pluginName));\n        final Map<String, byte[]> files = readArchiveFile(sourceFileName);\n        monitor.worked(10);\n        IProject project = workspaceRoot.getProject(pluginName);\n        if (project.exists()) {\n            project.delete(true, true, new SubProgressMonitor(monitor, 5));\n        } else {\n            monitor.worked(5);\n        }\n        project.create(new SubProgressMonitor(monitor, 5));\n        project.open(new SubProgressMonitor(monitor, 5));\n        IProjectDescription description = project.getDescription();\n        description.setNatureIds(new String[] { JavaCore.NATURE_ID, PLUGIN_NATURE_ID });\n        project.setDescription(description, new SubProgressMonitor(monitor, 5));\n        IJavaProject javaProject = JavaCore.create(project);\n        IFolder binDir = project.getFolder(\"bin\");\n        IPath binPath = binDir.getFullPath();\n        javaProject.setOutputLocation(binPath, new SubProgressMonitor(monitor, 5));\n        project.getFolder(\"jni\").create(true, true, new SubProgressMonitor(monitor, 5));\n        project.getFile(\"sapjco3.jar\").create(new ByteArrayInputStream(files.get(\"sapjco3.jar\")), true, new SubProgressMonitor(monitor, 10));\n        IFolder metaInfFolder = project.getFolder(\"META-INF\");\n        metaInfFolder.create(true, true, new SubProgressMonitor(monitor, 5));\n        StringBuilder manifest = new StringBuilder();\n        manifest.append(\"Manifest-Version: 1.0\\n\");\n        manifest.append(\"Bundle-ManifestVersion: 2\\n\");\n        manifest.append(\"Bundle-Name: SAP Java Connector v3\\n\");\n        manifest.append(MessageFormat.format(\"Bundle-SymbolicName: {0}\\n\", pluginName));\n        manifest.append(\"Bundle-Version: 7.11.0\\n\");\n        manifest.append(\"Bundle-ClassPath: bin/,\\n\");\n        manifest.append(\" sapjco3.jar,\\n\");\n        manifest.append(\" jni/\\n\");\n        manifest.append(\"Bundle-Vendor: SAP AG, Walldorf (packaged using RCER)\\n\");\n        manifest.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n        manifest.append(\"Export-Package: com.sap.conn.jco,\\n\");\n        manifest.append(\" com.sap.conn.jco.ext,\\n\");\n        manifest.append(\" com.sap.conn.jco.monitor,\\n\");\n        manifest.append(\" com.sap.conn.jco.rt,\\n\");\n        manifest.append(\" com.sap.conn.jco.server\\n\");\n        manifest.append(\"Bundle-ActivationPolicy: lazy\\n\");\n        writeTextFile(monitor, manifest, metaInfFolder.getFile(\"MANIFEST.MF\"));\n        final IPath jcoPath = new Path(MessageFormat.format(\"/{0}/sapjco3.jar\", pluginName));\n        IClasspathEntry jcoEntry = JavaCore.newLibraryEntry(jcoPath, Path.EMPTY, Path.EMPTY, true);\n        final IPath jniPath = new Path(MessageFormat.format(\"/{0}/jni\", pluginName));\n        IClasspathEntry jniEntry = JavaCore.newLibraryEntry(jniPath, Path.EMPTY, Path.EMPTY, true);\n        javaProject.setRawClasspath(new IClasspathEntry[] { jcoEntry, jniEntry }, new SubProgressMonitor(monitor, 5));\n        StringBuilder buildProperties = new StringBuilder();\n        buildProperties.append(\"bin.includes = META-INF/,\\\\\\n\");\n        buildProperties.append(\"               sapjco3.jar,\\\\\\n\");\n        buildProperties.append(\"               jni/,\\\\\\n\");\n        buildProperties.append(\"               .\\n\");\n        writeTextFile(monitor, buildProperties, project.getFile(\"build.properties\"));\n        exportableBundles.add(modelManager.findModel(project));\n    }\n", "label": 0, "substitutes": {"client": ["cache", "obj", "server", "conn", "and", "bolt", "cmd", "builder", "secure", "channel", "manager", "call", "web", "cell", "store", "block", "tree", "list", "self", "sim", "url", "ace", "Client", "man", "controller", "resource", "type", "force", "http", "prefix", "google", "contact", "component", "con", "connection", "row", "ce", "control", "remote", "util", "response", "pattern", "nt", "cli", "cl", "query", "template", "batch", "c", "base", "command", "chain", "cm", "policy", "co", "patch", "wrapper", "window", "key", "system", "tc", "entry", "close", "local", "plugin", "console", "service", "check", "get", "to"], "names": ["ls", "said", "pres", "idents", "AMES", "olds", "some", "lines", "strings", "rs", "members", "ns", "ons", "aos", "users", "aps", "named", "ren", "keys", "nam", "roots", "these", "nets", "files", "ans", "states", "sts", "ames", "ids", "models", "objects", "ms", "spe", "nos", "types", "books", "terms", "s", "chains", "papers", "orders", "prints", "n", "mas"], "name": ["path", "key", "NAME", "p", "string", "nm", " Name", "a", "ename", "entry", "member", "e", "value", "brain", "node", "named", "filename", " named", "nam", "me", "nan", "data", "user", "id", "comment", "c", "in", " NAME", "Name", "str", "t", "out", "create", "l", "common", "ame", "word", "core", "n", "cn"], "ftpFiles": ["ftfTypes", "ftfFile", "afpOps", "aftpTypes", "fttpfiles", "fttpFile", "ftnFiles", "etpsfiles", "etpsFiles", "etpsiles", "aftpFiles", "ftpsfiles", "afpFile", "ftpsiles", "etpsFile", "afpFiles", "fttpiles", "ftnFile", "ftpsFile", "etpFiles", "aftpOps", "etpfiles", "afpTypes", "fttpOps", "ftpTypes", "ftfOps", "aftpFile", "fttpTypes", "fttpFiles", "etpiles", "ftpfiles", "ftniles", "ftpOps", "ftnTypes", "ftnOps", "ftfFiles", "ftpsFiles", "ftnfiles", "ftpiles", "etpFile"], "ftpFile": ["fttpfile", "ftpnFiles", "ftrFile", "ftpnfile", "fttpItem", "ftrEntity", "fftpDocument", "fttpFile", "aftpStyle", " ftpfile", "ftnDocument", "ftnFiles", "ffpFiles", "fltpFile", "fttpDocument", "aftpFiles", "flpEntity", "fttpStyle", "fltpfile", "fftpfile", "ffpFile", "ftpDocument", "aftnStyle", "ftrfile", "ftpnDocument", "ftpfile", "flpfile", " ftnFiles", "ftnFile", "ftnItem", "ftrFiles", " ftnItem", "fltpFiles", "ftpnFile", "fttpEntity", "fftpFiles", "ftpItem", "ftpEntity", " ftpItem", "aftpFile", "aftnFiles", "ftPFile", "ftPFiles", "fttpFiles", "ftPStyle", "fltpEntity", "flpFile", "ftnStyle", "aftnFile", "ffpfile", " ftnfile", "ftpStyle", "flpFiles", "fftpFile", "ftrItem", " ftnFile", "ffpDocument", "ftnEntity", "ftnfile"]}}
{"id1": "596993", "id2": "8216539", "code1": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 0, "substitutes": {"makeLoginRequest": ["makeLoginMessage", " makeFacebookRequest", " makeFacebookPost", " makeFacebookResponse", "makeFacebookRequest", "makeFacebookPost", " makeLoginPost", "makeSubmitResponse", "makeFacebookMessage", " makeLoginMessage", "makeloginRequest", "makeLoginResponse", "makeSubmitRequest", " makeLoginResponse", "makeloginPost", "makeSubmitMessage", "makeloginMessage", " makeFacebookMessage", "makeloginResponse", "makeFacebookResponse", "makeSubmitPost", "makeLoginPost"], "url": ["Url", "name", "path", "string", "char", "ul", "r", "job", "cl", "file", "location", "b", "ssl", "k", "build", "bel", "call", "dl", "base", "abs", "uri", "web", "http", "sl", "nl", "el", "str", "ll", "browser", "address", "ref", "https", "un", "l", "open", "URL", "re", "ls", "ur"], "urlConnection": ["mountConnection", " urlConn", "xmlConnection", "browserConn", "UrlSession", " urlConnect", " urlConnector", "UrlLink", "handleConnect", "mountConn", "loadConnection", "loadConn", "browserconnection", "urlConnector", "browserConnection", "httpStream", "browserConnect", "urlconnection", "UrlConnect", "mountClient", "nlLink", "UrlConn", "nlConnect", "urlConnect", " urlInstance", "sslPort", "sslSession", "loadInstance", "consoleConnect", "sslStream", "nlconnection", "httpLink", "browserInstance", "consoleConnection", "consoleConn", "xmlConnector", " urlClient", "fileConnect", "httpConnection", "fileconnection", "mountConnect", "logConnection", "handleStream", "urlTree", "urlLink", "loadConnect", "UrlInstance", "logConnect", "httpConnect", "fileConnection", "sslConnector", "urlSession", "sslTree", "urlConn", "browserClient", "fileSession", "handleConn", "httpSession", "urlClient", "httpConn", "mountSession", " urlTree", "Urlconnection", " urlPort", "sslConnect", "nlConnection", "urlStream", "xmlPort", " urlconnection", "consoleSession", "httpconnection", "sslconnection", "sslConnection", "urlPort", "mountconnection", "urlInstance", "xmlTree", " urlSession", "logConn", "UrlConnection", "logLink", "handleConnection", "sslConn"], "content": ["sequence", "metadata", "cache", "lead", "conn", "any", "version", "image", "action", "settings", "activity", "pattern", "const", "continue", "filter", "handle", "xml", "description", "message", "current", "subject", "title", "expression", "json", "value", "config", "values", "cmd", "label", "network", "layout", "comments", "node", "context", "reason", "function", "data", "template", "example", "media", "comment", "cont", "search", "Content", "format", "report", "command", "form", "body", "object", "mask", "text", "summary", "language", "address", "create", "code", "contact", "cm", "output", "trust", "core", "license", "script", "size", "document", "names", "ontent", "control", "raw", "properties"], "outputStream": ["outputBlock", " outputStyle", "networkSteam", " outputstream", "OutputForm", "Outputstream", " outputSteam", "outputForm", "outputStyle", "networkStreamer", "OutputView", "OutputStyle", "OutputStream", "OutputStreamer", "OutputBlock", "inputForm", "inputView", " outputBlock", "outputView", "OutputSteam", "inputSteam", "networkStream", "outputstream", " outputView", "outputSteam", " outputForm", "inputBlock", "networkstream", "inputStyle", " outputStreamer", "outputStreamer"], "responseCode": ["ResponseCount", "usageCount", "responseCount", "usageCategory", "statusType", " responseCategory", "sequenceCode", "usageCode", "sequenceCount", "responseType", "ResponseType", "sequenceType", "statusCode", "ResponseCategory", " responseChoice", "sequenceStatus", "responseCategory", "usageChoice", "ResponseChoice", "ResponseStatus", "ResponseCode", "responseStatus", "responseChoice", " responseCount", "statusStatus", "statusCount"], "inputStream": ["thisSteam", "fileStream", "InputSteam", "viewThread", "fileStreamer", " inputSteam", "InputView", "thisStream", "errorView", "errorForm", " inputStreamer", "outputStyle", "outputForm", "thisStreamer", "viewSteam", "inputStreamer", "InputStream", "inputView", "viewStream", "inputForm", "outputView", "actStyle", "inputSteam", "errorSteam", "actStream", " inputView", "inputThread", "fileSteam", "outputThread", "errorStream", " inputQueue", "actView", "outputSteam", "actSteam", " inputThread", "fileQueue", "viewView", "inputStyle", " inputStyle", "thisQueue", "inputQueue", "InputForm"]}}
{"id1": "804637", "id2": "21824901", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewrites", "readAndrewWrite", "readAndReprites", "readAndResWrite", "readAndResend", "readAndReprite", "readAndResrites", "readAndrewrites", "readAndRepWrite", "readAndrewend", "readAndRewWrite", "readAndResrite", "readAndRepend", "readAndRewend", "readAndrewrite"], "inFile": [" inFilename", "outFilename", "InFile", "outfile", "inTime", "INTime", "inputPlace", "inFace", "INFILE", "initPlace", " infile", "docFILE", "initFilename", "inFilename", "inputFilename", "iTime", "INFile", "initFace", "INFace", "InFilename", "iFILE", "Infile", "infile", "INPlace", "docFilename", "docFile", "inputFile", "INFilename", "inPlace", "iFile", "docTime", "iFilename", "initFile", "inFILE", "inputFace"], "outFile": [" outFILE", "outFilename", "reportFile", "outfile", "reportFILE", "nameFile", "nameFilename", "checkfile", "toFile", "inFilename", " outFilename", "reportfile", "checkFile", "nameFILE", "checkFILE", "checkFilename", "reportFilename", "infile", "toFilename", "outFILE", "toFILE", "namefile", "tofile", " outfile", "inFILE"], "iis": ["diIs", " iisc", " iIS", "IIs", "Ii", "eis", "liIs", "diiss", " ii", "iisc", "dii", "liisc", " iIs", " iiss", "Iis", "iIs", "iiss", "liis", "aiis", "iiris", "aiIS", "Iiss", "iiIs", "aiIs", "iris", "iiisc", "liris", " iris", "eIS", "iiis", "eIs", "diis", "iIS", "ii"], "dcmParser": ["dpmStatement", " dcmLoader", "dmmparser", "DpmParser", "DpmReader", "dpmPar", "dmmmParser", "decmarser", "Dpmparser", "dfmLoader", "dmmReader", " dpmarser", "decmReader", "DcmReader", "dcommParser", "dpmParser", "dpmPrivate", " dcmAssistant", " dpmparser", "deromReader", "dmReader", "dcfStatement", "deromParser", " dpmAssistant", "DcmBuilder", "DcmAdapter", "dcomBuilder", "deromarser", " dpmParser", " dpmPrivate", " dcmStatement", "dmarser", "dcrparser", "dcomLoader", "dromReader", "dmmarser", "dmmParser", "dmmmparser", "dcomParser", "dcfReader", "dpmBuilder", "dgrPar", "dpmReader", "dromparser", "dcmStatement", "dcmPrivate", " dpmListener", " dpmStatement", "dmparser", "dpmLoader", "dfmReader", "drumPar", "dpmListener", " dcmarser", "dfmParser", "Dcmparser", "dgrReader", "dcmAdapter", "dmoduleAssistant", "dmmAdapter", "DcmPar", "dcmLoader", "dromListener", "dpcParser", "dpcReader", "dcrBuilder", " dcmReader", "dromarser", "dfmBuilder", "DpmBuilder", " dcmparser", "dpcAssistant", "dcmPar", "dcommListener", " dcmPrivate", " dcmBuilder", "decmParser", "dgrStatement", "decmparser", "dcmAssistant", "drumBuilder", "dcmListener", "dcommReader", "DcmParser", " dpmPar", "drumReader", " dpmLoader", "dmParser", "dcmReader", " dcmListener", "dcommAssistant", "dmodulePrivate", " dcmPar", "DpmAdapter", "dcomReader", "dcmarser", "dgrParser", "dpmparser", "dmmmReader", "dromParser", "DpmPar", "dpmAssistant", "dcfParser", "dcrParser", "dpmAdapter", "dromAssistant", "drumParser", " dpmBuilder", " dpmReader", "dpmarser", "dcfPar", "deromparser", "dpcPrivate", "dmoduleReader", "dmoduleParser", "dmmmAdapter", "dcmparser", "dcmBuilder", "dcrReader"], "ds": ["obs", "cs", "ws", "gd", "bs", "ods", "Ds", "rs", "tes", " DS", "ps", "drivers", "sets", "dh", "ns", "aos", "dx", "der", "DS", "hd", "bd", "sys", "ys", "ils", "gs", "sd", "dat", "ss", "es", "data", "uds", "xs", " des", "sv", "dl", "fs", "services", "ads", "eds", "its", "details", "in", "da", "ims", "ins", "dds", "pers", "vs", "d", "des", "db", "eps", "dos", "os", "dt", "s", "dq", "js", "outs", "qs", "dd", "hs", "ks", "ls", "as", "df", "pd"], "pdReader": ["vdWriter", "pedRunner", "xdHelper", "ddHelper", "tdParser", "pdParser", "dpLoader", "pdCar", "ddParser", "ddRunner", "vdReader", "pedReader", "pdRunner", "pdHelper", "ddLoader", "pedLoader", "pdLoader", "ddRead", "ddWriter", "hdReader", "dpReader", "ddReader", "vdHelper", "pedCar", "pdRead", "tdRead", "hdWriter", "xdReader", "xdLoader", "xdWriter", "dpRunner", "vdLoader", "ddCar", "dpCar", "hdRead", "hdParser", "tdWriter", "tdReader"], "out": ["obj", "cache", "conn", "p", "Out", "ex", "v", "cmd", "pos", "io", "one", "data", "res", "in", "str", "end", "list", "name", "auto", "msg", " err", "full", "writer", "cb", "inv", "pool", "opt", "on", "sw", "cfg", "we", "at", "gr", "os", "con", "oss", "outs", "screen", "OUT", "net", "raw", "cn", "up", "nt", "w", "outer", "ent", "all", "nr", "err", "tmp", "conv", "gt", "gen", "id", "c", "sum", "ins", "o", "output", "null", "co", "js", "desc", "ou", "go", "ch", "it", "inner", "aos", "flush", "sys", "log", "serv", "inter", "txt", "status", "t", "en", "client", "s", "to", "over", "n"], "dcmEncParam": ["dcmencMsg", "dmmencMsg", "dmmEncPar", "dmmEnNum", "dmmencNum", "dmmEncParam", "dcmEncVal", "dmmEnParam", "dcmEscNum", "dmmEncMsg", "dmmEnPar", "dcmDecCmd", "dcmEnParam", "dcmencParam", "dcmencPar", "dcmDecMsg", "dcmEnPar", "dcmDecParam", "dcmEscVal", "dcmEnNum", "dcmEncPar", "dmmencCmd", "dcmencCmd", "dmmEncVal", "dcmEnVal", "dcmencNum", "dcmDecNum", "dcmEncNum", "dcmEncMsg", "dmmEncNum", "dmmEncCmd", "dcmEscParam", "dcmEncCmd", "dcmEscPar", "dmmencParam"], "pdWriter": ["PDEditor", "pcWriter", "tdWriter", "dpEditor", "PDReader", "PDWrite", "pdWrite", "pidWriting", "PDWriter", "pdwriter", "dpReader", "dpWriter", "tdEditor", "pdEditor", "pidWriter", "pcWrite", "pcWriting", "pcwriter", "dpWrite", "pidwriter", "tdWriting", "tdwriter", "pidWrite", "pdWriting", "tdWrite", "tdReader"]}}
{"id1": "160705", "id2": "8801182", "code1": "    public static boolean downloadFile(String url, String destination) throws Exception {\n        BufferedInputStream bi = null;\n        BufferedOutputStream bo = null;\n        File destfile;\n        byte BUFFER[] = new byte[100];\n        java.net.URL fileurl;\n        URLConnection conn;\n        fileurl = new java.net.URL(url);\n        conn = fileurl.openConnection();\n        long fullsize = conn.getContentLength();\n        long onepercent = fullsize / 100;\n        MessageFrame.setTotalDownloadSize(fullsize);\n        bi = new BufferedInputStream(conn.getInputStream());\n        destfile = new File(destination);\n        if (!destfile.createNewFile()) {\n            destfile.delete();\n            destfile.createNewFile();\n        }\n        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n        int read = 0;\n        int sum = 0;\n        long i = 0;\n        while ((read = bi.read(BUFFER)) != -1) {\n            bo.write(BUFFER, 0, read);\n            sum += read;\n            i += read;\n            if (i > onepercent) {\n                i = 0;\n                MessageFrame.setDownloadProgress(sum);\n            }\n        }\n        bi.close();\n        bo.close();\n        MessageFrame.setDownloadProgress(fullsize);\n        return true;\n    }\n", "code2": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "label": 0, "substitutes": {"downloadFile": ["createResource", "downloadResource", " downloadResource", "createFile", "copyResource", " downloadfile", " downloadPage", "copyPage", "createfile", "downloadPage", "copyFile", "createPage", "copyfile", "downloadfile"], "url": ["mail", "Url", "link", "external", "html", "path", "string", "fail", "ret", "u", "mount", "file", "source", "location", "gl", "ssl", "host", "dl", "base", "uri", "web", "http", "nl", "sl", "el", "sql", "rl", "str", "ll", "browser", "address", "ref", "loc", "l", "lr", "ud", "URL", "ls", "ur", "ul", "addr"], "destination": ["destinate", " destinations", "Destinate", "origification", "delinator", "origination", "delino", "destino", "declinations", "delinations", " destification", "destinator", " destinate", "Destinator", "destification", " destino", "originate", "destinations", " destinator", "originator", "declino", "delination", "declinator", "Destification", "Destination", "declination"], "bi": ["ni", "ibe", "ib", "ri", "oi", "bc", "mi", "gi", "phi", "bra", "bs", "si", "bh", "ini", "bie", "b", "bin", "ti", "ci", "Bi", "ba", "bb", "zi", "di", "fi", "obi", "bis", "ble", "mu", "rob", "qi", "ki", "bm", "ibi", "iri", "ai", "vi", "pi", "yi", "isi", "abi", "ii", "li"], "bo": ["bos", "ato", "go", "bc", "soc", "zo", "ho", "vo", "cho", "fo", "bh", "bl", "mo", "oo", "cro", "ko", " Bo", "so", "bd", "mon", "bin", "ba", "yo", "lu", "bu", "po", "fi", "mu", "BO", "flo", "Bo", "gro", "bol", "ta", "cu", "no", "ro", "o", "lo", "pb", "wo", "bro", "ilo", "ao", "co", "aco", "oos"], "destfile": ["Destfield", "sourcef", "sourceFile", "Destile", "sourceprint", " destfield", "sourcedir", "destf", " destFile", "destile", "Destfile", " destf", " destpo", "foreignfield", " destparent", "foreignfile", "declfolder", " destprint", "Destdir", "destrule", "newprint", "estpo", "nullrule", "sourcefield", "declfile", "destparent", "estrule", "DestFile", "estparent", "Destf", "estFile", "nullparent", "newile", " destdir", "destpo", "nullpo", "destFile", " destile", "sourceile", "newfile", "nullfile", "destfield", " destrule", "Destfolder", "Destport", "newFile", "declport", " destport", " destfolder", "foreignf", "estfield", "declile", "destfolder", "sourcefile", "foreignFile", "destdir", "destprint", "estfile", "destport", "estf"], "BUFFER": [" BUDER", "BYbuffer", "FILBuffer", "BFFER", " BUbuffer", "BACKBuffer", "BYMENT", "BUMENT", "CHFFER", "BYDER", "BUbuffer", "BACKDER", "BYFFER", "Bbuffer", "CHBuffer", "CHbuffer", "BYBuffer", "BMENT", "FILFFER", "CHMENT", " BUBuffer", "BUBuffer", "BBuffer", "BACKbuffer", "FILbuffer", "BACKFFER", "FILDER", "BUDER"], "fileurl": [" fileutil", "fileutil", "tileUrl", "FILEurl", " fileURL", " fileconn", " filel", "Fileurl", "FILEUrl", "FileUrl", "resourceconn", "FILEutil", " fileUrl", " filenet", "resourceurl", "resourceUrl", "tileconn", "filel", "filenet", "tilenet", "resourcel", "Fileutil", "FileURL", "resourceURL", "tileurl", "fileconn", "fileURL", "resourcenet", "Filel", "FILEURL", "fileUrl"], "conn": ["Connection", "pc", "obj", " cs", "gn", "ch", "cert", "cs", "yn", "resp", "addr", "comm", "cb", "act", "cc", "enc", "nt", "ns", "connect", "cmd", "pg", "syn", "err", "close", "serv", "j", "conv", "gen", "lang", "c", "cont", "conf", "nc", "sql", "cur", "jp", "ctx", "client", "open", "con", "connection", "n", "ann", "co", "Conn", "cod", "net", "att", "cp", "cn"], "fullsize": ["fullstart", " fullstart", "fulsum", "largesize", "longSize", " fullsum", "fullsum", "FullSize", " fullname", "fullysize", " fulllength", "fullSIZE", "largesum", "fullyspace", "totalSIZE", "fulSIZE", "largeSize", " fullspace", "fulspace", "fullname", "fullylength", "longSIZE", "totalsize", "longsize", "fullSize", "FullSIZE", " fullSIZE", "fullySize", " fullSize", "fullspace", "totalSize", "fullength", "largestart", "fulstart", "Fullsize", "Fullname", "fulSize", "longname", "fulsize", "fulllength"], "onepercent": ["Oneprop", "oneprop", " oneopen", " oneprop", "OnePercent", " onePercent", "twocent", "Onepercent", "twopercent", "Oneopen", "twoPercent", "ONEprop", "oneopen", "onePercent", "ONEopen", " onecent", "ONEpercent", "onecent", "Onecent"], "read": ["READ", "len", "key", "raw", "each", "select", "find", "bind", "height", "handle", "x", "reading", "char", "ready", "stream", "add", "se", "r", "index", " Read", "reads", "shift", "run", "connect", "gets", "last", "through", "hello", "query", "start", "log", "buffer", "push", "parse", "give", "val", "send", "q", "range", "check", "in", "str", "text", "play", "set", "load", "write", "length", "open", "get", "output", "iter", "hold", "count", "core", "end", "word", "skip", "input", "readable", "row", "seek", "size", "print", "reader", "n", "fill", "ind", "Read"], "sum": ["cum", "unit", "ass", "su", "full", "vol", "Sum", "si", "sa", "v", "add", "index", "max", "um", "u", "temp", "prof", "acc", "so", "hum", "j", "sam", "cal", "num", "med", "mean", "scale", " SUM", "set", "hash", "mem", "summary", "out", "us", "ful", "total", "count", "na", "size", "cat", "sim", "n"], "i": ["ix", "im", "ip", "p", "mi", "is", "it", "x", "phi", "gi", "ui", "chi", "si", "v", "ini", "hi", "info", "u", "e", "iu", "ind", "ti", "ci", "ori", "io", "j", "multi", "di", "xi", "f", "m", "c", "med", " I", "y", "ic", "in", "ei", "qi", "t", "o", "d", "l", "iter", "ai", "I", "pi", "sim", "index", "ii", "li"]}}
{"id1": "10936821", "id2": "15445861", "code1": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 0, "substitutes": {"doIt": ["doThis", "DoWhatever", "makeThis", "DoThis", "DoWhat", " doWhat", "DoIt", "doWhat", "makeWhat", " doThis", "makeIt", "doWhatever", " doWhatever", "makeWhatever"], "client": ["remote", "util", "url", "cache", "response", "server", "conn", "parent", "key", "quick", "socket", "pattern", "pool", "cc", "cloud", "Client", "utils", "connect", "cli", "cl", "cmd", "network", "resource", "secure", "ssl", "channel", "local", "close", "template", "call", "phone", "force", "web", "http", "cell", "simple", "console", "service", "lib", "api", "contact", "google", "cm", "open", "con", "connection", "core", "to", "co", "dial", "net", "ct", "wrapper", "control"], "ff": ["fp", "tf", "ef", "pp", "cb", "fm", "fo", "cl", "ck", "eff", "ph", "fact", "fx", "uf", "fc", "uff", "ffer", "fi", "fd", "bf", "FF", "lf", "fg", "aff", "sf", "xff", "buff", "cf", "tif", "ft", "nd", "aft", "af", "dd", "alf", " fid", "df", "off"], "jfc": ["qfc", " jFC", "ncf", "npc", "tpc", "jlc", "qFC", "lvc", " jlc", "tfc", "qpc", "Jfc", "jcf", "tcf", "lfc", "fvc", "ffc", "nfc", " jmc", " jcf", " jvc", "Jcf", "qcf", "jspc", "Jmc", "jsFC", " jpc", "flc", "jsmc", "jmc", "llc", "lcf", "jvc", "JFC", "tFC", "nFC", "jpc", "jFC", "fcf", "Jpc", "jsfc"], "f": ["rf", "xf", "fab", "tf", "ef", "p", "g", "v", "fo", "F", "w", "e", "file", "b", "i", "h", "fx", "fa", "fc", "m", "c", "fs", "fi", "fd", "only", "bf", "lf", "fg", "t", "sf", "l", "cf", "inf", "df"], "selection": ["sea", " selected", "where", "wa", "ION", "state", "select", "soc", "reading", "ification", "which", "sel", "location", "opening", "ion", "slot", "lection", "security", "from", "search", " Selection", "finding", "choice", "icing", "election", "elect", "xxx", "position", "focus", "connection", "binding", "something", " selecting", "ing", "selected", "SELECT", "pling"], "msg": ["mail", "sm", "bg", "html", "init", "nm", "news", "cmp", "notice", "comm", "Msg", "task", "resp", "mb", "g", "message", "dm", "info", "cmd", "ck", "irm", "gm", "log", "alg", "sys", "gs", "og", "wx", "sg", "map", "cal", "comment", "gent", "txt", "crit", "cfg", "sum", "conf", "mu", "body", "mess", "mg", "str", "md", "ms", "summary", "mem", "mn", "pkg", "doc", "gr", "print", "desc", "mk"]}}
{"id1": "22410173", "id2": "15768167", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpFiles", "transferFile", "transferFiles", "cpfile", "copyStream", " cpfile", " cpFile", "transferStream", " cpStream", "cpFile", " cpFiles", "copyfile", "cpStream", "copyFiles", "transferfile"], "source": ["Source", "origin", "parent", "init", "ource", "src", "scope", "se", "sample", "subject", "target", "original", "copy", "file", "query", "start", "so", "resource", "me", "local", "template", "scene", "base", "from", "search", "space", "site", "service", "spec", "seed", "iter", "s", "input", "ce", "sp", "SOURCE", "style"], "dest": ["origin", "orig", "est", "nom", "del", "exp", "Dest", "it", "master", "src", "nw", "target", "home", "temp", "deg", "lit", "de", "tmp", "that", "crit", "cont", "search", "way", "pot", "good", "st", "img", "desc", "them", "loc", "test", "usr", "d", "des", "dir", "null", "pub", "dist", "trans", "tom", "sp", "rest"], "in": ["inn", "al", "inc", "up", "pin", "conn", "ch", "init", "ln", "is", "it", "mi", "ain", "and", "sin", "inner", "isin", "ini", "r", "din", "all", "bin", "i", "internal", "read", "ci", "gin", "local", "win", "on", "m", "from", "In", "or", "ins", "inside", " input", "an", "en", "IN", "vin", "doc", "l", "client", "con", "ai", "ma", "iter", "n", "ca", "co", "cin", "rin", "input", "re", " IN", "net", "ar", "can", "inf", "ind"], "out": ["off", "obj", "up", "not", "ch", "conn", "ac", "it", "Out", "inner", "v", "ex", "nt", "aos", "outer", "w", "dis", "ent", "ns", "cmd", "log", "ion", "cos", "io", "channel", "rem", "conv", "gt", "user", "on", "again", "nl", "sum", "ot", "cn", "t", "en", "chain", "at", "o", "ne", "OU", "write", "un", "output", "client", "con", "os", "null", "to", "oss", "co", "na", "outs", "OUT", "net", "note", "can", "n", "ou"]}}
{"id1": "12349563", "id2": "11334468", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"resourceExists": [" pathExists", " resourceIsists", " resourceexistent", " resourceIsits", " resourceexists", " pathexistent", " resourceExisted", " resourceIsisted", " pathExisted", " pathexisted", " pathExistent", " pathExits", " resourceExits", " resourceexisted", " resourceexits", " pathexists", " resourceExistent", " resourceIsistent", " pathexits"], "location": ["remote", "name", "where", "server", "path", "Location", "string", "zo", "system", "uration", "description", "availability", "usage", "href", "message", "localhost", "ocation", "value", "file", "hello", "point", "filename", "layout", "ion", "slot", "resource", "resolution", "local", "reference", "template", "behavior", "translation", "library", "padding", "available", "comment", "uri", "search", "program", "command", "color", "LOC", "direction", "country", "address", "zone", "history", "loc", "module", "family", "position", "connection", "document", "directory", "window", "area", "human"], "url": ["mail", "Url", "hl", "pl", "cert", "char", "ret", "r", "u", "mount", "cmd", "b", "gl", "h", "ssl", "build", "bel", "user", "call", "f", "base", "dl", "res", "http", "sl", "nl", "str", "ll", "google", "address", "t", "out", "loc", "https", "pkg", "l", "open", "client", "con", "www", "URL", "ls", "ur", "n", "ul"], "cxn": [" cxN", "cxns", "Ctxn", "conn", "ctxN", "cexN", "connn", "Ctxnn", "conN", "cxN", "cxxns", "cwxn", "conns", "cxxN", " cexn", "ctxn", "cxnn", "cexns", "cexn", "Cxn", "cwxnn", "cwxN", "ctxns", " cexnor", "Cxnn", "CxN", " cexns", "cwxns", "cxxn", " cxns", "Ctxns", " cexN", "cxxnor", "ctxnn", "ctxnor", "cexnor", "Cxns", "cxnor", "CtxN", " cxnor"], "is": ["tis", "bits", "im", "ip", "ois", "does", "init", "still", "iss", "ts", "bs", "rs", "si", "isin", "ps", "as", "info", "isa", "dis", "sis", "iso", "Is", "ir", "i", "isf", "sys", "ris", "serv", "ys", "es", "IS", "abs", "fs", "bis", "its", "in", "ios", "ims", "ms", "isl", "ists", "ais", "iris", "was", "os", "s", "isc", "oss", "ires", "isi", "has", "lis"], "byteBuffer": ["basicMatrix", "binaryWindow", " byteSet", " byteQueue", "byteSet", "byteQueue", "basicQueue", "byteMatrix", "basicFlow", "binaryContext", "byteContext", "bufferSet", "noteQueue", "noteMatrix", "byteWindow", "basicBuffer", " byteMatrix", "byteFlow", "noteFlow", "bufferWindow", "noteBuffer", " byteWindow", "binarySet", " byteContext", "bufferContext", "binaryBuffer", " byteFlow", "bufferBuffer"]}}
{"id1": "19335986", "id2": "18696387", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncurredFailure", " uncaughtception", " uncuredException", "uncurredException", "uncappedception", "uncaughtError", "uncappedError", "uncuredFailure", " uncaughtError", "uncuredception", " uncuredFailure", "uncuredError", "uncaughtFailure", " uncuredception", "uncurredception", "uncurredError", "uncappedFailure", " uncuredError", "uncaughtception", " uncaughtFailure", "uncuredException", "uncappedException"], "t": ["tf", "p", "task", "g", "w", "title", " th", "b", "h", " st", "f", "m", "c", "Thread", "y", "thread", "out", " T", "o", "d", "T", "l", " title", "to", " tid", "window", "n", " ti"], "e": ["xe", "ele", "ef", "p", "Error", "it", "E", "x", "ec", "ea", "ex", "a", "se", "r", "oe", "u", "ee", "event", "b", "de", "err", "i", "es", "error", "f", "m", "c", "eg", "el", "te", "eu", "en", "er", "eeee", "o", "d", "exc", "fe", "ae", "ie", "ce", "et", "ev", "ed", "pe"], "display": ["name", "link", "view", "server", "present", "this", "dis", "label", "b", "log", "layout", "session", "Display", "DIS", "scroll", "report", "body", "details", "console", "draw", "lay", "play", "browser", "d", "l", "table", "output", "position", "s", "render", "list", "screen", "show", "print", "window", "style"], "shell": ["view", "server", "system", "ssh", "ui", "sh", "scope", "board", "expression", "sb", "dis", "cli", "b", "buffer", "session", "layout", "log", "quit", "scroll", "sound", "library", "echo", "storage", "report", "nl", "hell", "command", "form", "body", "console", "or", "help", "environment", "browser", "ro", "l", "output", "tool", "tree", "screen", "print", "program", "window", "control", "handle", "Shell"], "message": ["mail", "msg", "response", "metadata", "view", "image", "system", "Message", "description", "memory", "subject", "content", "menu", "title", "management", "member", "detail", "label", "hello", "question", "log", "layout", "buffer", "session", "meter", "email", "manager", "one", "template", "translation", "error", "button", "application", "echo", "payment", "m", "comment", "result", "report", "say", "command", "trace", "body", "object", "console", "language", "summary", "essage", "module", "open", "position", "request", "show", "field", "document", "window"], "e1": ["ee1", "ee2", "e0", "e3", " e3", "E2", " e2", "E3", "ee0", "E0", "e2", "E1", "ee3", " e0"]}}
{"id1": "13439950", "id2": "15409512", "code1": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 0, "substitutes": {"readRemoteFile": ["downloadStaticFrom", "downloadRemoteFilename", "readLocalRemote", "readRemoteFrom", "readStaticFrom", "downloadRemoteRemote", "downloadStaticFile", "downloadStaticRemote", "readStaticFilename", "readLocalFile", "readLocalFrom", "downloadRemoteFrom", "readStaticRemote", "readStaticFile", "readremoteRemote", "readremoteFilename", "downloadRemoteFile", "downloadStaticFilename", "readremoteFrom", "readRemoteFilename", "readremoteFile", "readLocalFilename", "readRemoteRemote"], "response": ["sequence", "cache", "view", "server", "answer", "version", "resp", "string", "image", "settings", "continue", "description", "message", "sample", "value", "json", "source", "network", "resolution", "next", "data", "respons", "example", "result", "application", "res", "report", "send", "vector", "command", "status", "onse", "body", "Response", "service", "str", "summary", "address", "relation", "output", "line", "block", "request", "connection", "reset", "reply", "print", "secret", "format"], "url": ["mail", "Url", "link", "hl", "name", "pl", "char", "ret", "r", "mount", "cmd", "lb", "b", "gl", "ssl", "resource", "build", "bel", "base", "dl", "abs", "uri", "web", "http", "nl", "sl", "el", "rl", "fl", "str", "ll", "browser", "ref", "https", "loc", "rel", "l", "lr", "URL", "ur", "ul"], "is": ["ri", "ip", "does", "it", "iss", "bs", "rs", "as", "isa", "sis", "iso", "Is", "ir", "i", "sys", "isf", "ris", "serv", "es", "IS", "\u00eds", "fs", "bis", "its", "ic", "in", "ios", "isl", "ins", "ms", "ists", "ais", "iris", "sels", "os", " Is", "isc", "ates", "isi", "nis", "lis"], "br": ["bi", "bn", "dr", "tr", "bc", "BR", "ver", "bs", "adr", "bh", "hr", "r", "bl", "repl", "Br", "b", "bd", "bridge", "wr", "nr", "buf", "ber", "bp", "res", "vr", "bf", "rob", "str", "browser", "pr", "bm", "rel", "jp", "ro", "gr", "bt", "bro", "shr", "mr", "cr", "lr", "rb", "fr", "sp", "be"], "s": ["p", "string", "ts", "sq", "bs", "still", "a", "rs", "strings", "g", "ps", "v", "ats", "r", "se", "stats", "sample", "ns", "w", "gets", "sb", "e", "series", "value", "b", "i", "S", "gs", "h", "sports", "ss", "es", "j", "less", "ves", " gets", " samples", "m", "ies", "sv", "sts", "txt", "res", "its", "y", "sql", "single", "str", " ts", "ms", "ins", "t", "o", "csv", "l", "sn", "tes", "os", "sym", " inputs", "js", "z", "qs", "ls", "n"], "eof": ["eeos", "eot", "Eef", "ef", " eomp", " eif", " ef", "eOF", " eef", "eeot", "seot", "eeol", "Eol", "eeomp", " eov", "eOf", "seef", "geif", "eomp", "eow", "eos", "Eomp", "Eof", "eeOF", "eeow", " eow", "eif", "eeif", "sef", "geOF", "Eos", " eOf", "eeof", "geof", "eeef", "geow", "Eov", "eol", " eot", " eos", "eeov", "eef", "eeOf", "seof", " eOF", "EOf", "eov", " eol"]}}
{"id1": "22135199", "id2": "6188784", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": [" testCodingSizeFile", " testCodingemptyStream", " testCachingEmptyFile", " testCachingEmptyFiles", " testCodingSizeFiles", " testCodingEmptyFiles", " testCodingSizeStream", " testCodingFullfile", " testCodingemptyFile", " testCodingEmptyfile", " testCachingemptyFile", " testCodingFullFiles", " testCodingEmptyStream", " testCodingFullFile", " testCodingemptyfile", " testCachingemptyFiles", " testCodingemptyFiles", " testCachingEmptyfile", " testCodingFullStream", " testCodingSizefile", " testCachingemptyfile", " testCachingemptyStream", " testCachingEmptyStream"], "baos": ["baOs", " baoss", "bao", "tao", "boOs", "caoS", "caOs", " bao", "taoS", "boos", "caos", "aoo", "Baos", "aoos", "aoOs", "booss", "Bao", "baOS", "aoOS", "BaOs", "cao", " baOS", " baOs", "boo", "baoS", "taOs", "boOS", "baoss", "Baoss", " baoS", "taos"], "channel": ["room", "cache", "server", "ch", "system", "socket", "stream", "message", "window", "file", "container", "controller", "buffer", "session", "network", "resource", "io", "context", "password", "application", "queue", "batch", "c", "handler", "command", "caster", "console", "service", "chain", "out", "chan", "cm", "component", "client", "con", "block", "connection", "input", "Channel", "can"], "params": ["radius", "name", "units", "fps", "p", "cmp", "settings", "cms", " parameters", "pool", "rs", "ps", "names", "mm", "json", "Parameters", "config", "AMS", "sys", "par", "param", "caps", "tags", "data", "pps", "password", "phys", "services", "pins", "conf", "details", "ops", "parts", "spec", "types", "proc", "Par", "ctx", "ams", "limits", "pi", "options", "headers", "pretty", "properties"], "outbuf": ["outbuffer", "outrb", "outputbuf", "OutBuffer", " outBuffer", "inBuffer", "outBuffer", "Outbuff", "outbuff", "inbuff", "Outbuffer", " outbuffer", "inrb", "outputbuffer", "Outbuf", " outbuff", "outputrb", " outrb", "outputbuff", "inbuffer", "inbuf"], "metrics": ["metric", "Metrics", "metcs", "mutcs", "matrors", "mtcs", "mtths", "metrors", "mutrics", "monrix", "matrics", "monrors", "mutrices", "mtrics", " metths", "matrix", "metrix", "metths", "mtrices", "metrices", "Metrix", "matric", "mutths", "Metric", " metrices", "monrics", "Metrors", "monric", " metcs"], "encoder": ["execrier", "Encoding", "ecoded", "Encramer", "enoding", "enoded", "ecrier", "ecramer", "encressor", " encressor", "executer", "execoder", "encuter", "eciever", "eniever", "encoding", "Encoder", " encoding", "Encrier", "ecoder", "Enciever", "encoded", " encuter", "encrier", "Encuter", " encrier", "ecressor", "enoder", "ecoding", "execoding", " encramer", "enciever", "enressor", "enrier", "encramer", "enramer", " encoded"], "tmpFile": ["mpFile", " tmpKey", "tmpFiles", "tmpFILE", " tmpFILE", " tmpFiles", "tmpName", "tmpFilename", "tempFiles", "tmpPath", "txtPath", "fakeFiles", "tmpKey", "testName", "imgKey", "mpFilename", " tmpFilename", "imgFILE", "testfile", "tempKey", " tmpPath", "tempPath", "txtFile", "mpName", "tempfile", "tempFILE", "tempFilename", "testFilename", "fakefile", "testFile", "fakeFilename", "mpfile", "tempFile", "fakeFile", "tmpfile", "imgFile", " tmpfile", "imgfile", " tmpName", "txtfile"], "fout": ["fOUT", "fbal", "wOut", "sfout", "fullbal", "lOUT", "foutput", "wout", "dfOUT", "vOut", "fouts", "fullOUT", "sfouts", "vao", "fullout", "wao", "sfao", "vouts", "dfout", "vout", "dfoutput", "fao", "lout", "fOut", "wouts", "lbal", "dfbal", "sfOut", "loutput", "fulloutput"], "wrtout": ["wrdin", "wgtw", "wgtout", "ewrtwriter", "hwrtwriter", "hwrtw", "wrtin", "wrcw", "hwrcwriter", "hwrcw", "ewltwriter", "ewrtin", "wrtio", "wttout", "Wrtio", "Wrdwriter", "wrdgen", "Wrdio", "ewrtout", "wrtwriter", "wltgen", "Wrtn", "wwtwriter", "wrtgen", "wttwriter", "wdrout", "ewltout", "wltwriter", "hwrtout", "wwtex", "wrtn", "wrcex", "ewltin", "wdrgen", "wRTio", "wrcout", "wwtw", "wrdn", "hwrcout", "hwrtex", "wgtwriter", "wrdout", "wrtw", "wttn", "Wrdn", "wdrin", "wRTout", "ewrtgen", "wdrwriter", "ewltgen", "wrcwriter", "wwtout", "wgtex", "wrtex", "wRTn", "Wrdout", "hwrcex", "wrdio", "wRTwriter", "wttio", "wltin", "Wrtout", "Wrtwriter", "wltout", "wrdwriter"], "fchannel": [" fconnection", " fcontroller", "Fnet", " fnet", " fChannel", "fcconnection", " fchan", "Fconsole", "fnet", "fcchan", "flnet", "wconnection", "fccontroller", "Fchannel", "fconnection", "fcchannel", "FChannel", "flchannel", "fchan", "fChannel", "flChannel", "fconsole", "wchan", "flconsole", "fcontroller", "wcontroller", "wchannel", " fconsole"], "s": ["ws", "string", "sq", "ts", "p", "is", "rs", "g", "v", "a", "r", "ds", "w", "ns", "gets", "e", "b", "i", "S", "h", "gs", "ss", "j", "sg", "f", "sv", "c", "m", "str", "t", "csv", "js", "qs", "ls", "n"]}}
{"id1": "14047629", "id2": "3266833", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "label": 1, "substitutes": {"source": ["Source", "iterator", "sequence", "image", "system", "shell", "stream", "ource", "src", "message", "sample", "se", "copy", "content", "expression", "file", "event", "query", "buffer", "resource", "channel", "data", "result", "from", "q", "sql", "console", "service", "in", "address", "seed", "proc", "output", "position", "request", "input", "SOURCE", "reader", "format"], "process": ["cp", "execute", "link", "flow", "pp", "init", "p", "complex", "and", "task", "pipe", "se", "memory", "job", "run", "connect", "cmd", "node", "file", "make", "network", "session", "sys", "context", "function", "parse", "build", "processor", "method", "call", "project", "Process", "command", "status", "pm", "store", "frame", "object", "service", "post", "check", "thread", "console", "chain", "mem", "condition", "code", "create", "class", "proc", "work", "component", "place", "term", "exec", "pid", "script", "processing", "program", "use", "handle", "state"], "processStdOut": ["processStrrEr", "processStstdEr", "processStrrIn", "processStdEx", "processStrdOut", "processStstEx", "processStdEr", "processStrrEx", "processStstdEx", "processStrIn", "processStrEx", "processStrdEr", "processStrEr", "processStstdIn", "processStstEr", "processStrdEx", "processStrdIn", "processStstdOut", "processStstOut", "processStstIn", "processStrOut", "processStrrOut"], "processStdIn": ["processStrIN", "processStdin", "processStsIN", "processStdsIns", "processStackdsIN", "processSTdIN", "processStackdsOut", "processStackdsin", "processStrIns", "processStackdin", "processStackdIN", "processStrIn", "processStrin", "processSttIN", "processSttIns", "processStdsIN", "processSTtIN", "processStackdsIn", "processStsOut", "processSTtOut", "processStackdOut", "processStdIns", "processSttOut", "processSttIn", "processStdsIn", "processStdsin", "processStrOut", "processSTdIn", "processStsIn", "processStdsOut", "processSTdOut", "processSTtIn", "processSTtIns", "processStsin", "processStdIN", "processStackdIn", "processSTdIns"]}}
{"id1": "13233761", "id2": "2199604", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 0, "substitutes": {"executeUpdateTransaction": ["startUpdateStatement", "executeUpdateStatement", "startUpdateTx", "executeInsertStatement", "executeQueryStatement", "executeWriteTransaction", "executeWriteTx", "executeQueryTask", "startQueryTask", "startUpdateTransaction", "executeWriteTask", "executeInsertTx", "startQueryStatement", "startQueryTransaction", "executeUpdateTx", "executeQueryTx", "executeWriteStatement", "executeQueryTransaction", "executeInsertTask", "executeInsertTransaction", "executeUpdateTask", "startUpdateTask", "startQueryTx"], "queries": ["quiries", "qualenges", "qualands", "quands", "gallands", "Quarks", "quues", "Quands", "galleries", "queues", "quarks", "aquands", " Queries", "Queries", "quearks", "qualiries", "Quues", "queeries", "qualeries", "gallenges", " Quands", "aquenges", "aqueries", "quenges", " Quues", "galliries", " Quarks", "aquiries", "queands"], "autoCommit": ["automaticCompate", "autoAmits", "autoClmit", "autoAmit", "autoCommist", "autoClit", "AutoCommmit", "autoCompist", "autoDebist", "autoBeport", "automaticCommcommit", "AutoCommits", "automaticCommist", "autoCommits", "autoBeits", "autoDebate", "automaticCompist", "autoCommate", "autoBemit", "autoClport", "autoBeit", "AutoClits", "automaticCommit", "autoCommmit", "autoAmport", "autoAbsist", "AutoClit", "autoAbscommit", "autoDebit", "automaticCommate", "autoAmmit", "autoCommcommit", "autoCompit", "autoCommport", "automaticCompit", "autoClits", "AutoCommit", "AutoClmit", "automaticCompcommit", "autoCompcommit", "autoCompate", "autoAbsit", "autoDebcommit", "autoAbsate", "AutoCommport", "AutoClport"], "iterator": ["sequence", "former", "ter", "liner", "writer", "giving", "oser", "operator", "interstitial", "continue", "inner", "stream", "rounder", "loader", "ator", "sample", "current", "integer", "members", "menu", "outer", "internet", "series", "number", "encer", "starter", "ski", "values", "folder", "walker", "Iterator", "pie", "information", "next", "pler", "video", "taker", "processor", "pee", "zero", "gener", "seconds", "storage", "issues", "pour", "rows", "trace", "vector", "instance", "page", "bis", "ner", "set", "directory", "immigrant", "finder", "collection", "loop", "started", "upper", "iter", "creator", "udder", "list", "runner", "size", "river", "reader"], "query": ["name", "execute", "sequence", "key", "version", "string", "Query", "sq", "qu", "task", "description", "subject", "message", "escape", "menu", "title", "lock", "series", "question", "update", "resource", "join", "parse", "password", "result", "comment", "q", "command", "quote", "sql", "prefix", "check", "code", "condition", "test", "table", "term", "family", "request", "row", "script", "quest"], "statement": ["execute", "sequence", "Statement", "group", "system", "shell", "continue", "task", "confirmed", "description", "usage", "message", "expression", "minute", "session", "slot", "resource", "parse", "template", "call", "ment", "fire", "comment", "batch", "command", "status", "quote", "sql", "set", "rule", "binary", "condition", "phrase", "table", "line", "word", "block", "connection", "print", "mt", "state"]}}
{"id1": "11968328", "id2": "9550506", "code1": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": [" calculatemd1", " calculateMD2", " calculatemd5", " getMT5", " getmd5", " getMDState", " getHash2", " getMD1", " getMTState", " getMD2", " getHash5", " calculateMD5", " getHashState", " getmdState", " getmd1", " getmd2", " calculateMDState", " calculatemdState", " calculatemd2", " getHash1", " calculateMD1", " getMT2", " getMT1"], "_pwd": ["_wppriv", " _spw", " _pw", "_cwd", "_cfx", "_vppriv", "_pword", "_sppriv", "_wpword", "_vpw", "_passwords", "_vpwd", " _passw", "_pwords", "_passwd", "_ppriv", "_passw", "_passfx", " _pfx", "_wpw", "_cw", " _passwd", "_vpword", " _pword", "_cwords", " _passwords", "_pw", " _sppriv", " _passfx", "_spwd", " _spwd", "_spwords", "_pfx", " _pwords", "_spword", "_spfx", " _spword", "_spw", " _ppriv", "_wpwd"], "md": ["mail", "sm", "msg", "del", "dig", "and", "cd", "mb", "MD", "add", "dm", "dh", "mm", "man", "der", "od", "cmd", "ng", "hd", "ind", "bd", "de", "h", "sd", "tmp", "mod", "ld", "m", "det", " Md", "down", "pm", "bf", "rm", "mp", "mg", "ms", "red", "mn", "d", "db", "nd", "dir", "mand", "dd", "mc", "mt", "mk", "df", "pd"]}}
{"id1": "12236729", "id2": "15645004", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"copy": [" dup", " append", " merge", " Copy", " combine", " paste", " replicate", "read", "transfer", " move", " cat", " parallel", " download", " duplicate", " operate", " transfer", " cp", " delete", " seek", " clone", " upload", "paste", "Copy", " join", " copying", " restore", " recover", "cp"], "inputFile": ["inFile", "outputPath", "configPath", " inputfile", "inputDir", "argumentPost", "inile", "configFile", "configPost", "argumentPath", "inputPost", " inputPath", "outputile", "inputPath", "inPath", "outputDir", "inputile", "argumentfile", " inputPost", "inputfile", "configfile", "argumentFile", " inputile", " inputDir", "inDir"], "outputFile": ["outFile", "outFilename", "outputPath", "outfile", "targetfile", "targetDir", "outputfile", "outPlace", "inputDir", " outputPlace", "writeFile", " outputDir", "targetPath", "outputFilename", "outDir", "outputPlace", " outputFilename", "inputPath", "writeDir", "outputDir", "writePlace", "writeFilename", "inputfile", "targetFile", "outPath"], "in": ["inn", "al", "inc", "up", "ri", "init", "is", "per", "it", "sin", "inner", "isin", "old", "ini", "din", "info", "min", "all", "ir", "i", "bin", "read", "gin", "on", "from", "In", "ic", "ins", "inside", "en", "IN", "inf", "iter", "ai", "con", " din", "input", "rin", "cin", "reader", "ze", "ind"], "out": ["auto", "cache", "obj", "writer", "it", "Out", "g", "ex", "v", "nt", "aos", "outer", "flush", "dis", "sys", "log", "cos", "io", "one", "user", "on", "res", "ot", "cn", "check", "en", "at", "o", "by", "ne", "write", "output", "client", "os", "null", "con", "to", "end", "co", "outs", "OUT", "net", "print", "can", "n", "ou"], "c": ["character", "pc", "cap", "cache", "cs", "ch", "ac", "bc", "ec", "x", "char", "arc", "cc", "cd", "cb", "v", "r", "current", "u", "cl", "gc", "cos", "i", "k", "f", "uc", "unc", "cont", "conf", "nc", "code", "t", "cu", "chain", "lc", "d", "cm", "cf", "l", "con", "count", "rc", "cr", "z", "cod", "ce", "mc", "C", "n", "cp", "ct"]}}
{"id1": "1698200", "id2": "5744992", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginbitshare", "loginbitShare", " loginbitStock", " loginbitshare", "loginByteShare", " loginBitStock", " loginBitshare", "loginByteStock", "loginByteshare", "loginBitshare", "loginbitStock", " loginbitShare", "loginBitStock"], "params": ["metadata", "pres", "p", "posts", "settings", "cms", "auth", "ports", "rs", "ps", "stats", "members", "mm", "json", "Parameters", "config", "points", "comments", "param", "caps", "keys", "gs", "parser", "tags", "requires", "pps", "services", "pins", "pas", "http", "photos", "details", "hash", "parts", "changes", "types", "Par", "terms", "chains", "options", "ams", "headers", "acl", "pi", "names", "pretty", "cp", "properties"], "httpclient": ["Httpconnection", "httcontroller", "http2", "Httpclient", "httco", "httpsco", "hyper2", "ttpcontroller", "Httprequest", "https2", "httpscli", " httpClient", "httpconnection", "httclient", "ttpClient", "httpsrequest", "HttpClient", "httpsclient", " http2", "hyperconnection", "httpsClient", "httprequest", "httpClient", "httpco", "hyperclient", "ttpclient", "httpscontroller", " httpcli", "httClient", "httpcontroller", " httprequest", "ttpco", "httpcli", " httpconnection", "httpsconnection", "hypercli"], "httppost": ["httpppop", "httplost", " httpop", "httphost", "httmpost", "httppart", "httploster", "httpppoint", "httmpop", "httpplop", "httppoint", " httpppost", "httplpost", " httpost", "httpposter", "httplom", "httploint", "httpost", "httmppost", "httphpost", "httppppost", "httpoint", "httpplost", "httpom", "httpop", "httphoint", "httpperop", "httphoster", "httpplart", "httppposter", "httpploint", "httposter", " httppop", "httpplpost", "httpploster", "httppop", " httpom", "httplart", "httppom", "httpart", "httpppart", "httmpart", " httppom", "httpperom", "httpperost", "httpppost", "httpperpost", "httplop"], "formparams": ["foreargs", "formargs", "functionproperties", "feedparam", " formauthors", "functionauthors", "foreproperties", "foreauthors", "condnames", "feeddetails", "inputdetails", "batchnames", "functionargs", "formmembers", "formsettings", "condsettings", "forechanges", "condproperties", "functiondetails", "formednames", "formedparams", "batchtags", "functionchanges", " formdetails", "formparam", "formerrors", "formedtags", "inputparams", " formnames", "forenames", "inputParameters", "feedParameters", "inputparam", "inputnames", "batchparams", "batcherrors", "functionmembers", "formproperties", "formauthors", "functionparams", "foremembers", " formchanges", " formargs", "inputerrors", " formmembers", " formparam", " formsettings", "condparams", "inputtags", "formederrors", "foreparams", "formParameters", "foredetails", "formnames", "formdetails", "foresettings", " formproperties", " formParameters", "feedparams", "formchanges", "formtags"], "entity": ["metadata", "ell", "html", "activity", "inv", "xml", "enc", "Entity", "entry", "content", "ENT", "ent", "json", "ee", "event", "buffer", "ITY", "profile", "orm", "template", "data", "user", "note", "comment", "person", "eme", "security", "el", "quote", "form", "body", "ew", "object", "ity", "create", "out", "component", "fee", "line", "em", "ce", "empty", "document"], "httpresponse": [" httpreply", "HTTPResponse", "httpResponse", "procreply", "HTTPresult", "HTTPresp", "httpresp", "ttpResponse", " httpresult", "httpconnection", "procresult", "HTTPreply", "ttpconnection", "httpresult", "ttpresponse", "HTTPresponse", "HTTPconnection", " httpresp", "procresponse", " httpResponse", " httpconnection", "httpreply", "procResponse", "ttpresp"], "it": ["im", "al", "MIT", "est", "ip", "init", "is", "you", "act", "itter", "ul", "ex", "v", "mit", "It", "rit", "ite", "iz", "ut", "IT", "ent", "lit", "itted", "ate", "i", "sit", "il", "el", "ot", "he", "its", "ic", "st", "t", "at", "l", "ert", "iter", "et", "ect", "ist", "ed", "ind", "li"], "escookie": ["eyancel", "ecookie", "eccake", "espookie", "ectrl", "occookie", "httpsog", "escotton", "Escookie", "httpsotton", "Esccookie", "eccookie", "desctrl", "escue", "Escue", "ecoder", "iseccake", "descue", "espcookie", "ecog", "isecookie", "descookie", "occoder", "eycookie", "espace", "desccookie", "httpsookie", "escace", "httpscookie", "isecoder", "espancel", "esctrl", "eyace", "escog", "occcookie", "esccake", "escancel", "iseccookie", "occotton", "ecace", "ecotton", "occog", "escoder", "occcake", "eyookie", "ecancel", "Esctrl", "ecue", "esccookie"]}}
{"id1": "6501291", "id2": "8490297", "code1": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"extractFile": ["ExtractStream", "extressFile", "extlatefile", "extactStream", "extressFiles", "Extractfile", "extactFile", "extactFiles", "ExtactFile", "extlateFile", "ExtactFiles", "extractStream", "extractfile", "extractFiles", "extressStream", "ExtractFiles", "extlateStream", "extressfile", "ExtractFile", "extlateFiles", "Extactfile", "extactfile", "ExtactStream"], "input": ["url", "ip", "init", "initial", "select", "pattern", "add", "sample", "current", "run", "feed", "file", "config", "source", "query", "start", "hello", "read", "io", "local", "error", "base", "accept", "from", "cont", "audio", "q", "form", "prefix", "check", "text", "Input", "open", "get", "request", "list", "index", "raw", "upload"], "output": ["port", "four", "response", "icon", "parent", "full", "display", "put", "current", "target", "w", "Output", "temp", "file", "success", "source", "log", "io", "export", "result", "exit", "phone", "pot", "web", "prefix", "console", "directory", "o", "monitor", "write", "to", "net", "hidden", "absolute", "ou"], "reader": ["zip", "Larry", "ri", "rd", "rer", "writer", "per", "reading", "inner", "rs", "loader", "se", "r", "info", "reads", "rr", "entry", "rx", "author", "read", "parser", "parse", "rar", "io", "ry", "driver", "ner", "rl", "red", "cur", "Reader", "er", "ro", "ra", "iter", "mr", "rc", "row", "fr", "rot", "rt", "dr", "rator"], "in": ["inn", "inc", "is", "it", "per", "and", "sin", "inner", "din", "info", "mm", "source", "bin", "i", "io", "read", "gin", "on", "In", "ic", "inside", "ins", "en", "IN", "ro", "o", "get", "iter", "con", "cin", "mc", "inf", "ind"], "out": ["auto", "obj", "up", "conn", "writer", "it", "and", "Out", "inner", "ex", "nt", "aos", "outer", "b", "all", "sys", "bin", "log", "io", "one", "conv", "gt", "on", "res", "po", "ot", "cn", "check", "t", "en", "at", "o", "write", "client", "os", "null", "con", "to", "co", "outs", "OUT", "net", "n", "ou"], "buf": ["cap", "msg", "cv", "tr", "bc", "bus", "cb", "bytes", "bh", "bl", "fam", "seq", "cmd", "b", "bed", "buffer", "bin", "log", "uf", "Buffer", "conv", "bar", "box", "gen", "tab", "queue", "batch", "arr", "cam", "mu", "good", "br", "img", "bag", "cur", "Buff", "buff", "pkg", "vec", "db", "cf", "block", "rb", "cat", "aka", "var"], "len": ["cap", "elt", "pl", "le", "ln", "exp", "del", "cmp", "lon", "v", "nt", "seq", "dec", "lit", "pos", "h", "fin", "val", "fun", "ld", "il", "dl", "coll", "el", "nl", "lf", "mil", "str", "fl", "ll", "en", "t", "lib", "no", "loc", "rel", "la", "l", "length", "lan", "Len", "wid", "lic", "z", "et", "compl", "lif", "ler", "ls", "n"]}}
{"id1": "17716716", "id2": "19206412", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"plainToMD": [" stringAsmd", " stringFromDM", " stringToDM", " stringTomd", " stringAsMC", " convertTomd", " stringAsDM", " stringFromMD", " stringToMD", " convertAsMC", " convertToMC", " stringToMC", " convertToMD", " convertAsMD", " stringFrommd", " stringFromMC", " convertToDM", " convertAsDM", " convertAsmd", " stringAsMD"], "loggerCol": [" logggerColumn", "badinatorColl", " logggerCol", "badinatorCOL", " loggerCOL", "logggerColumn", "logGERCOL", "logGERColumn", "logggerCl", "logggerCOL", "logGERCol", "loginatorCOL", "loggerColl", "logggerCol", "loggerCl", "badinatorCol", "badinatorCl", "logiderCOL", "loginatorColl", "logiderCol", "badgerCol", "logggerColl", "badgerCl", " logggerCOL", "loginatorCl", "badgerColl", "loggeCol", "loggeColl", "loginatorCol", "loggerColumn", " loggerColumn", "loggerCOL", "loggeCOL", "loggeCl", "badgerCOL", "logiderColumn"], "input": ["url", "active", "up", "image", "string", "it", "initial", "pattern", "char", "this", "subject", "value", "file", "hello", "source", "config", "buffer", " Input", "context", "data", "example", "result", "base", "from", "q", "command", "form", "prefix", "in", "hash", "str", "text", "out", "Input", "output", " inputs", "request", "background", "document", "raw"], "byteHash": ["binaryHash", " byteHas", "bytesHash", "bytesMap", "byteshash", "bytehash", "bytesHas", " byteTr", "byteTr", "binaryHas", " bytehash", "ueHash", "byteMap", " byteMap", "uehash", "ueLength", "ByteHas", "ByteHash", "binaryhash", "byteHas", "ByteLength", "Bytehash", " byteLength", "ByteMap", "ByteTr", "byteLength", "ueTr"], "md": ["sm", "msg", " MD", "comp", "dig", "mt", "def", "cd", "mb", "MD", "add", "dm", "mo", "ds", "mm", "mac", "od", "cmd", "ng", "der", "grad", "ind", "bd", "de", "gm", "ct", "sd", "mod", "di", "sam", "ded", "pd", "ld", "m", "det", "med", " Md", " mc", "cond", "mp", "rm", "pm", "hash", "mg", "red", "ms", "mn", "d", "doc", "gr", "nd", "met", "dd", "mc", "dr", "material", "mk", "df", "hd"], "md5result": ["md3results", "MD5results", "MD5result", "md65Result", " md8message", "md64result", " md5message", "md8proc", "md65proc", "md2Result", "md7Result", "md2string", "md8result", "md45results", "md64response", "MD2comment", "MD5Result", "MD5string", "MD5response", "MD2results", "MD2string", "md8Result", "md3proc", " md8Result", "md3Result", "md65message", "md2results", "md3message", "md5message", "md64comment", " md8result", "MD5comment", "md3string", " md5Result", "md7results", " md8proc", "md45result", "md5proc", "MD2Result", "MD2response", "md8message", "md45response", "md2comment", "md5response", "md3result", "md5results", "md5Result", "md2result", "md5comment", "md64results", "MD2result", "md65result", "md45comment", "md5string", "md2response", " md5proc", "md7result", "md7string"], "i": ["ix", "im", "bi", "ip", "init", "key", "span", "is", "mi", "x", "it", "phi", "gi", "ui", "ji", "si", "v", "a", "u", "cli", "\u0438", "b", "gu", "io", "ci", "me", "ti", "multi", "j", "di", "id", "xi", "m", "c", "uri", "fi", "ii", "q", "y", "ic", "ei", "in", "ims", "qi", "us", "o", "l", "iter", "ai", "I", "n", "z", "ie", "my", "pi", "sim", "index", "ind", "li"]}}
{"id1": "2518655", "id2": "5237257", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fnOut": ["bfIn", "fnOutput", " fnOs", "synOut", "fnIn", "fnOs", "dnIn", " fnIn", "dnOut", " fnNet", "dnOutput", "synOr", " fnOr", " fnOutput", "bfOs", "synOutput", "pdfOs", "pdfOut", "pdfNet", "fnOr", "synIn", "dnOr", "pdfIn", "bfOut", "fnNet", "bfNet"], "writer": ["writers", "auto", "println", "Writer", "external", "journal", "and", "operator", "white", "inner", "master", "fn", "wright", "loader", "commit", "flush", "outer", "wrapper", "writ", "w", "file", "buffer", "walker", "variable", "her", "builder", "parser", "close", "zero", "comment", "handler", "written", "driver", "maker", "report", "worker", "send", "format", "caster", "console", "service", "widget", "riter", "editor", "aster", "write", "table", "client", "width", "creator", "runner", "print", "reader", "window", "rator", "writing"], "i": ["ix", "im", "bi", "ip", "init", "key", "ri", "is", "it", "x", "mi", "phi", "gi", "ui", "si", "g", "v", "ini", "hi", "u", "\u0438", "iu", "ski", "gu", "ti", "ci", "me", "multi", "j", "di", "id", "xi", "m", "c", "batch", "uri", "ii", "q", "y", "ic", "ei", "ims", "ogi", "qi", "ij", "chain", "us", "ki", "client", "ai", "I", "ma", "ie", "my", "pi", "sim", "ind", "li"], "fInput": ["linput", "sfIn", "lNew", "sfinput", "cfinput", "fileIn", "sfOutput", " finput", "fOutput", "fNew", " fNew", " fOutput", "fIn", "fileInput", "lInput", "cfOutput", "finput", "cfInput", "sfInput", " fIn", "fileOutput", "cfNew", "fileinput", "lOutput"], "in": ["inn", "al", "inc", "pin", "kin", "ln", "is", "it", "sin", "inner", "isin", "ini", "r", "din", "info", "all", "bin", "serv", "gin", "conv", "again", "In", "conf", "or", "check", "inside", "ins", "t", "en", "out", "IN", "inf", "client", "con", "ma", " din", "cin", "rin", "input", "re", "vin", "n", "ind", "thin"]}}
{"id1": "23161545", "id2": "19784131", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static String getMD5Hash(String original) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            StringReader sr = null;\n            int crypt_byte = 0;\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(original.getBytes());\n            byte[] digest = md.digest();\n            sr = new StringReader(new String(digest, \"ISO8859_1\"));\n            while ((crypt_byte = sr.read()) != -1) {\n                String hexString = Integer.toHexString(crypt_byte);\n                if (crypt_byte < 16) {\n                    hexString = \"0\" + hexString;\n                }\n                sb.append(hexString);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n        } catch (IOException ioe) {\n        }\n        return sb.toString();\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomSuid", "getRandomSUID", "getRandomUuid", "getRandUuid", "getRandomUUID", "getRandUID", "getRandGUID", "getRandUUID", "getRandomCuid", "getRandomGuid", "getRandUid", "getRandomCID", "getRandomGID", "getRandomCUID", "getRandGid", "getRandomUID", "getRandomUid", "getRandomSid", "getRandGuid", "getRandomSID", "getRandGID", "getRandomCid", "getRandomGid"], "secure": ["sec", "clear", "active", "server", " Secure", "confirmed", "sr", "safe", "sys", "ssl", "weak", "sync", "security", "force", "prime", " insecure", "http", "status", "nice", "service", "protect", " securely", "Secure", "google", "https", "dirty", "sensitive", "client", "quiet", "stable", "strong", "ie", "pretty", "trust", "secret", "encrypted"], "md5": ["MD512", "metadata3", "MD2", " md6", " md2", " mdle", "md45", "dig4", "md3", " md45", "metadata5", "metadata2", "md4", "sha5", "sha512", " md512", "dig5", "metadata45", "md512", "sha3", "MD5", " md4", "md2", "dig3", "sha2", "md6", "MD45", " md3", "MD4", "MD3", "digle", "sha6", "MD6", "MDle", "mdle"], "sbValueBeforeMD5": ["sbValueBeforeIM1", "sbValueAfterMDson", "sbValueBeforeOLD5", "sbValueBeforeSMson", "sbValueBeforeDD512", "sbValueAfterMD5", "sbValueBeforeLM2", "sbValueAfterND4", "sbValueAfterMDLeft", "sbValueBeforeAMD2", "sbValueBeforeMDson", "sbValueBeforeAMDFound", "sbValueBeforeMAC5", "sbValueBeforeSM5", "sbValueWithoutMD512", "sbValueBeforeLM512", "sbValueAfterMD1", "sbValueAfterMD4", "sbValueBeforeMDLeft", "sbValueAfterMDFound", "sbValueBeforeDD65", "sbValueBeforeDS5", "sbValueBeforeLM5", "sbValueAfterMD2", "sbValueBeforeND2", "sbValueBeforeDDFive", "sbValueBeforeOLD512", "sbValueAfterMDFive", "sbValueBeforeND4", "sbValueWithoutDD5", "sbValueBeforeMP2", "sbValueBeforeMS2", "sbValueBeforeOLD2", "sbValueBeforeAMDson", "sbValueBeforeNDson", "sbValueAfterND2", "sbValueBeforeMS3", "sbValueBeforeMD512", "sbValueBeforeMS1", "sbValueBeforeDS2", "sbValueWithoutMD5", "sbValueAfterNDson", "sbValueBeforeMP1", "sbValueBeforeMOD2", "sbValueBeforemdFound", "sbValueBeforeIM2", "sbValueBeforeMT5", "sbValueBeforeMACFive", "sbValueBeforeSM2", "sbValueAfterMD3", "sbValueBeforeMTson", "sbValueBeforeMDFound", "sbValueBeforeMS5", "sbValueBeforeIM5", "sbValueBeforeMOD3", "sbValueBeforeMPLeft", "sbValueWithoutDD2", "sbValueBeforeMOD1", "sbValueBeforeMOD5", "sbValueBeforeDS512", "sbValueWithoutDD512", "sbValueBeforeND5", "sbValueBeforemd2", "sbValueBeforeMD4", "sbValueBeforeMD3", "sbValueBeforeDD5", "sbValueBeforeAMD5", "sbValueBeforeSM4", "sbValueBeforeMAC65", "sbValueBeforeMAC2", "sbValueBeforeDD2", "sbValueBeforeIMLeft", "sbValueBeforeMD2", "sbValueBeforeMDFive", "sbValueBeforeMT2", "sbValueAfterND5", "sbValueBeforeMT4", "sbValueBeforeMD65", "sbValueAfterMD65", "sbValueBeforeMP5", "sbValueWithoutMD2", "sbValueBeforemd5", "sbValueBeforemdson", "sbValueBeforeMD1"], "time": ["name", "ime", "timeout", "counter", "race", "est", "now", "system", "ts", "ty", "estamp", "current", "TIME", "clock", "value", "start", "date", "when", "user", "top", "year", "id", "rate", "timer", "tim", "today", "frame", "set", "age", "t", "history", "Time", "duration", "etime", "work", "length", "total", "times", "client", "size", "runtime", "hour"], "rand": ["rev", "sid", "init", "rd", "and", "inv", "mid", "sample", "r", "nt", "rid", "grad", "ng", "uid", "round", "rank", "rad", "quant", "sam", "gt", "gen", "rate", "id", "pick", "Rand", "res", "reg", "rss", "std", "random", "range", "hash", "red", "serial", "seed", "rh", "frac", "gz", "nd", "rc", "cr", "pid", "dist", "roll", "z", "did", "rot", "rt", "dr"], "valueBeforeMD5": ["valueBeforeMT3", "valueAfterND7", "valueBeforeMOD7", "valueAfterMD3", "valueAfterND5", "valueBeforeMC2", "valueAfterMD2", "valueBeforeMC7", "valueBeforeMOD5", "valueBeforeMT2", "valueBeforeMC3", "valueAfterMD7", "valueBeforeND2", "valueBeforeMT5", "valueBeforeMOD2", "valueAfterND2", "valueAfterND3", "valueBeforeMD7", "valueBeforeMD2", "valueBeforeMOD3", "valueBeforeMD25", "valueBeforeND3", "valueBeforeMT25", "valueBeforeND7", "valueBeforeMC5", "valueBeforeMD3", "valueBeforeND5", "valueBeforeMC25"], "array": ["attribute", "response", "rays", "external", "ray", "image", "Array", "our", "raw", "arrow", "sh", "a", "sample", "RAY", "expression", "number", "buffer", "archive", " Array", "data", "record", "ash", "map", "av", "batch", "atomic", "storage", "audio", "arr", "vector", "instance", "angular", "random", "range", "hash", "object", "feature", "collection", "address", "binary", "angle", "app", "length", "share", "list", "row", "ary", "pair", "var", "area"], "sb": ["obs", "erb", "bg", "ib", "sq", "soc", "bs", "cb", "sth", "sh", "si", "sa", "bh", "sr", "abb", "nb", "lb", "gc", "ssl", "bsp", "bb", "sg", "bp", "sw", "sv", "lp", "eb", "bis", "bf", "gb", "ctrl", "rob", "sf", "wb", "ub", "kb", "pb", "db", "bt", "ob", "rb", "SB", "hs", "zb", "bps", "xb"], "j": ["ix", "msg", "obj", "off", "key", "jump", "uj", "jl", "it", "ji", "g", "v", "ja", "job", "yy", "je", "json", "ju", "jo", "jc", "i", "k", "jack", "oj", "m", "kj", "q", "_", "J", "br", "bj", "__", "str", "ij", "aj", "t", "dj", "us", "jp", "jit", "jj", "js", "z", "att", "bot", "ct", "index", "ind"], "b": ["bi", "bg", "ib", "bc", "bs", "cb", "mb", "v", "B", "a", "ab", "nb", "u", "bd", "k", "ba", "bb", "bar", "bp", "beta", "eb", "bu", "bis", "gb", "bf", "y", "br", "d", "db", "bound", "bt", "rb", "fb", "be", "xb"], "valueAfterMD5": ["valueAfterMD3", "valueAftermd7", "valueAfterID2", "valueAfterMD2", "valueAfterID3", "valueAfterMD7", "valueBeforeMD7", "valueBeforeMD2", "valueAftermd2", "valueAfterID7", "valueBeforeMD3", "valueAftermd3", "valueAfterID5", "valueAftermd5"]}}
{"id1": "21998571", "id2": "8417584", "code1": "    private String readTwitterFead() {\n        StringBuilder builder = new StringBuilder();\n        HttpClient client = new DefaultHttpClient();\n        HttpGet httpGet = new HttpGet(\"http://twitter.com/statuses/user_timeline/vogella.json\");\n        try {\n            HttpResponse response = client.execute(httpGet);\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n            if (statusCode == 200) {\n                HttpEntity entity = response.getEntity();\n                InputStream content = entity.getContent();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(content));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n            } else {\n                Log.e(AndroidJsonTestingActivity.class.getName(), \"Failed to download file\");\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return builder.toString();\n    }\n", "code2": "    private String getResultFromHttpUrl(String href) {\n        String result = null;\n        try {\n            URL url = new URL(href);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Object o = conn.getContent();\n            log.debug(\"Opened \" + href + \" and got class \" + o.getClass().getName());\n            StringBuffer version = new StringBuffer();\n            String inputLine;\n            DataInputStream dis = new DataInputStream(conn.getInputStream());\n            while ((inputLine = dis.readLine()) != null) {\n                version.append(inputLine + \"\\n\");\n            }\n            result = version.toString();\n            log.debug(\"Read from URL:\\n\" + result);\n            dis.close();\n        } catch (Exception e) {\n            log.debug(\"Caught exception \" + e + \" whilst attempting to query URL \" + href);\n            e.printStackTrace();\n        } finally {\n            return result;\n        }\n    }\n", "label": 0, "substitutes": {"readTwitterFead": ["readTwitterFleetch", "readTwitterFork", "readTwitterFleead", "readTwitterFleork", "readtwitterFead", "readtwitterFetch", "readtwitterfeed", "readtwitterfead", "readTwitterfead", "readTwitterFetch", "readTwitterBork", "readTwitterBead", "readTwitterBetch", "readTwitterBeed", "readtwitterFeed", "readtwitterfetch", "readtwitterfork", "readtwitterFork", "readTwitterfeed", "readTwitterfetch", "readTwitterFleeed", "readTwitterfork", "readTwitterFeed"], "builder": ["building", "full", "string", "writer", "bean", "operator", "inner", "order", "loader", "message", "board", "job", "outer", "sb", "oster", "der", "feed", "number", "file", "b", "ener", "buffer", "log", "black", "parser", "build", "buf", "bar", "library", "instead", "builders", "Builder", "trace", "command", "ner", "address", "er", "length", "atter", "built", "upper", "word", "block", "row", "fb", "found", "control", "BU"], "client": ["remote", "url", "cache", "server", "ch", "ip", "conn", "Client", "tc", "current", "cli", "cl", "config", "network", "resource", "io", "city", "context", "close", "secure", "call", "phone", "c", "force", "http", "console", "service", "google", "api", "create", "https", "cm", "con", "connection", "request", "co", "acl", "net", "window", "control"], "httpGet": ["htmlGet", "HttpPost", "ttpGet", "htmlGetting", "HTTPGetting", "httpPost", "httpGET", "HTTPget", "htmlget", "HTTPGET", "ttpGetting", "ttpPost", "HttpPut", "httpPut", " httpPost", "ttpGET", "ttpget", " httpPut", "HttpGet", "HTTPGet", "htmlGET", "Httpget", "ttpPut", " httpget", "httpGetting", "httpget"], "response": ["remote", "attribute", "sequence", "view", "cache", "server", "yes", "answer", "image", "resp", "still", "version", "description", "message", "info", "entry", "json", "success", "pos", "given", "ve", "resource", "function", "next", "channel", "respond", "data", "example", "result", "application", "successful", "res", "report", "http", "page", "status", "frame", "Response", "service", "console", "output", "block", "connection", "tree", "reply", "document"], "statusLine": ["staticNet", " statusline", "StatusLine", "serviceLine", "statNet", "StatusCode", "StatusL", "staticLine", "serviceline", "staticCode", "statusL", "serviceL", "statLine", "StatusNet", "statusNet", "statCode", " statusL", "staticline", "Statusline", "statusline", "serviceCode", "statline"], "statusCode": [" statusCount", "StatusPoint", " StatusCount", "statusPoint", " statusStatus", " StatusCE", "StatusCode", "styleCode", " statuscode", "statusCE", " statusCE", "Statuscode", " StatusCode", "styleStatus", "statuscode", "styleCount", "stylePoint", " statusPoint", "StatusStatus", "StatusCE", "StatusCount", " Statuscode", "statusStatus", "statusCount"], "entity": ["attribute", "metadata", "unit", "icon", "model", "image", "activity", "description", "message", "Entity", "entry", "detail", "ent", "json", "event", "resource", "profile", "email", "data", "user", "translation", "note", "comment", "person", "el", "peer", "status", "quote", "instance", "body", "object", "details", "ity", "code", "connection", "encrypted", "ce", "document", "pe"], "content": ["sequence", "view", "active", "parent", "initial", "activity", "xml", "stream", "message", "sample", "current", "json", "source", "network", "resource", "data", "media", "comment", "accept", "cont", "Content", "sum", "page", "status", "form", "body", "text", "code", "load", "cm", "output", "null", "core", "input", "document", "ct", "ontent"], "reader": ["iterator", "writer", "per", "older", "reading", "inner", "stream", "loader", "r", "rx", "layer", "file", "buffer", "ger", "read", "parser", "rar", "dra", "roller", "handler", "driver", "worker", "anger", "ner", "rl", "fighter", "Reader", "er", "ader", "ro", "editor", "iter", "row", "runner", "input", "river"], "line": ["name", "link", "sequence", "lane", "online", "liner", "key", "ln", "header", "le", "string", "stroke", "ine", "continue", "message", "sample", "entry", "e", "label", "Line", "number", "file", "source", "point", "log", "err", "LINE", "column", "eline", "comment", "lin", "page", "cell", "frame", "range", "text", "code", "chain", "rule", "no", "phrase", "l", "word", "block", "ice", "row", "list", "inline", "field", "print", "n"]}}
{"id1": "21125261", "id2": "23611215", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    public String uploadFile(String url, int port, String uname, String upass, InputStream input) {\n        String serverPath = config.getServerPath() + DateUtil.getSysmonth();\n        FTPClient ftp = new FTPClient();\n        try {\n            int replyCode;\n            ftp.connect(url, port);\n            ftp.login(uname, upass);\n            replyCode = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(replyCode)) {\n                ftp.disconnect();\n                return config.getServerPath();\n            }\n            if (!ftp.changeWorkingDirectory(serverPath)) {\n                ftp.makeDirectory(DateUtil.getSysmonth());\n                ftp.changeWorkingDirectory(serverPath);\n            }\n            ftp.storeFile(getFileName(), input);\n            input.close();\n            ftp.logout();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return serverPath;\n    }\n", "label": 0, "substitutes": {"test": [" evaluate", "execute", "fit", "unit", "server", "sample", "run", "train", "hello", "testing", "debug", "volt", "read", "launch", "example", " sample", "Test", "evaluate", " testing", "tests", "feature", " tests", "t", "load", "T", "show"], "is": ["tis", "are", "ri", "does", "ws", "bs", "rs", "xml", "stream", "ps", "isa", "sis", "iso", "sys", "Is", "i", "sit", "ris", "serv", "es", "IS", "xs", "fs", "its", "in", "ios", "ms", "has", "out", "us", "ais", "os", "ai", "s", "isc", "mis", "input", "isi", "ls", "as", "lis"], "byteArrayOutputStream": ["byteStringInputView", "byteArrayByteStream", "byteStreamOutputSteam", "byteStreamInputSteam", "byteStringInputSteam", "byteArrayOutputSteam", "byteArrayOutputStyle", "byteStringInputString", "byteStreamOutputStream", "byteArrayInputStyle", "byteArrayByteStyle", "byteStreamOutputStyle", "byteStreamInputForm", "byteStringOutputForm", "byteArrayApplicationForm", "byteArrayInputString", "byteArrayInputView", "byteArray4View", "byteArrayoutputString", "byteArrayInputSteam", "byteArrayByteString", "byteArrayOutputForm", "byteStreamInputStyle", "byteArrayoutputStream", "byteStringOutputView", "byteArrayOutputView", "byteArrayInputStream", "byteArrayoutputSteam", "byteArrayByteView", "byteArrayApplicationStyle", "byteStringoutputStream", "byteStringOutputSteam", "byteStringOutputString", "byteArray4Stream", "byteArrayApplicationStream", "byteStringOutputStream", "byteArrayApplicationSteam", "byteArrayByteForm", "byteArray4Steam", "byteStringInputStream", "byteArrayOutputString", "byteArray4String", "byteArrayByteSteam", "byteArrayoutputForm", "byteStreamInputStream", "byteStringoutputForm", "byteStringoutputSteam", "byteArrayInputForm", "byteStreamOutputForm", "byteStringoutputString"], "def": ["ef", "del", "cd", "DE", "ds", "dec", "pro", "json", "de", "Def", "sd", "sche", "dem", "defined", "default", "ded", "dev", "dl", "det", "crit", "dal", "conf", "Definition", "da", "md", "desc", "DEF", "d", "definition", "des", "db", "dict", "define", "decl", "df", "hd"], "se": ["sea", "ense", "sec", "SE", "le", "su", "est", "pse", "ine", "sa", "ide", "e", "ee", "sel", "so", "de", "ve", "ade", "sd", "me", "sche", "parse", "es", "be", "sed", "ses", "sem", "see", "engine", "sl", "we", "he", "te", "ge", "set", "ser", "spe", "ste", "ne", "Se", "ke", "ase", "ene", "ae", "ie", "ce", "sp", "ane", "ode", "ese", "ze", "she", "pe"], "linkId": ["linkedId", "chainIdent", " linkID", "linkedIdent", "connectionIdent", "LinkID", "chainId", "LinkId", "linkIdent", "chainID", "lineID", "linkName", "Linkid", "linkid", "lineId", "linkedID", " linkName", " linkid", "connectionId", "linkID", "LinkName", "lineName", "connectionID", "lineid"], "segmentId": ["begroupID", "segmentRef", "semissionName", "begroupName", "semissionRef", "segementID", "sementId", "sementID", "segroupById", "idegementid", "idegmentId", "idegementId", "idegementName", "semissionid", "sementid", "segroupID", "begmentById", "begmentID", "semissionId", "sementById", "idegmentRef", "segmentById", "sementName", "segementById", "segementId", "begmentId", "sementRef", "segmentName", "segmentID", "idegmentName", "segroupId", "segementRef", "segroupName", "begmentName", "begroupById", "segementid", "begroupId", "idegementRef", "segementName", "idegmentid", "segmentid"], "linkSegments": [" linkThreadgments", "linkGment", " linkBuildets", "linkGroups", "linkSegment", " linkBuildments", "linkConnectments", " linkSegables", "linkSements", " linkThreadlements", "linkConnectables", "linkFragment", "linkSegables", " linkSegets", "linkThreadroups", "linkParlements", "linkThreadments", "linkConnectlements", "linkFragroups", " linkSegment", "linkPargments", " linkSeggments", " linkBuildgments", " linkThreadroups", "linkConnectgments", " linkGgments", "linkBuildgments", "linkSeglements", " linkGroups", "linkBuildroups", " linkGment", " linkBuildables", "linkParments", "linkSeggments", "linkThreadlements", "linkSegets", "linkBuildment", " linkSeglements", "linkBuildments", " linkThreadments", "linkConnectets", " linkGments", "linkParroups", "linkGments", "linkConnectroups", "linkSegroups", "linkSeets", "linkFraggments", "linkThreadgments", " linkSegroups", "linkFragments", "linkBuildets", "linkSeables", "linkBuildables", "linkGgments"], "segments": ["velements", " sevals", "begments", "parselements", " sements", "beges", " Sements", "sevals", "sements", " Segments", "usements", "usegs", " seges", "parsements", "parsegments", "sectors", "bevals", " Sevals", "vegments", "usegins", "seges", "usegments", "segs", " segs", "megments", "megins", "segins", " segins", "vectors", "parsectors", " sectors", "bements", "megs", " selements", " Seges", "vements", "mements", "selements"], "frameProperties": ["frameParptions", "frameComrics", "framePrperties", "frameProptions", "frameProfps", "frameProrics", "frameProps", "frameProfptions", " frameProptions", " framePrps", "framePropptions", "frameComperties", " frameProrics", "frameByperties", "framePrptions", " frameProps", " frameByps", "frameParrics", "framePropps", " frameByilities", "frameComptions", "frameProfperties", "frameByps", "framePropilities", "framePrrics", " framePrperties", "frameByptions", "framePropperties", "frameProfilities", "frameByilities", " framePrptions", "frameParps", "framePrps", " frameByptions", " frameByperties", "frameComps", " frameProilities", "frameProilities", " framePrrics", "frameParperties"], "time": ["ime", "timeout", "sequence", "counter", "version", "now", "system", "x", "each", "tx", "ts", "delay", "task", "before", "message", "estamp", "distance", "TIME", "clock", "value", "second", "event", "start", "point", "date", "tt", "context", "rate", "money", "step", "year", "timer", "tim", "trace", "think", "set", "depth", "frequency", "check", "t", "slow", "Time", "duration", "etime", "times", "length", "trust", "total", "count", "speed", "size", "transform", "runtime", "window"], "vehicle": ["heroICLE", "vehogram", "vehic", "heroicle", "vehicles", " vehocity", "vericle", "survocity", "vehocity", "yardocity", "yardogram", "survendor", "venticle", "yardicle", "yardendor", "ventic", " vehICLE", "heroocity", "verocity", "ventocity", "Vehic", "Vehicles", "venticles", " vehicles", "survogram", "heroicles", "verendor", "vehendor", "verticles", "VehICLE", "survicle", "verticle", "verogram", "Vehicle", "vehICLE", "Vehocity", "vertic", "vertocity"]}}
{"id1": "22552318", "id2": "12417893", "code1": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"loadDDL": ["LoadCDDL", "LoadDDML", "LoadCDML", "LoadCDL", "LoadDDDL", "LoadDDl", "loadDSML", "loadDDML", "loadCDDL", "loadDSl", "loadPDML", "loadCDL", "loadDDl", "LoadDDL", "loadPDl", "loadCDML", "loadDDDL", "loadPDDL", "loadPDL", "loadDSDL", "loadDSL", "LoadCDl", "loadCDl"], "stmt": [" stmp", "STmp", "Stm", "frct", "stpt", "stct", "frpt", "astm", "strm", "strmp", "stMT", " stpt", "strmm", "stst", " superstmt", "stmm", "STm", " sttm", "frmt", "astmt", "sttm", "STMT", "asttm", "Stmm", "utm", "Sttm", " stm", " superstm", "utst", "stmp", "utmt", "STmt", " superstpt", " stmm", "Stst", "strmt", " stMT", "utMT", " stct", "Stmt", " superstct", "StMT", " stst", "STmm", "astMT", "stm", "frm"], "qry": ["qRY", "qury", "quri", "Qrys", " qary", "Qri", "quary", "qrys", "Qry", " qRY", "sqary", "qary", " qri", "sqrys", "sqRY", "qurys", "sqri", "sqry", " qrys", "qri", "QRY"], "q": ["p", "sq", "qu", "qt", "g", "v", "r", "w", "u", "e", "query", "i", "h", "k", "j", "ql", "ry", "f", "m", "qq", "c", "comment", "Q", "qi", "t", "qv", "o", "d", "pkg", "s", "dq", "z", "qa", "qs", "iq", "n"]}}
{"id1": "4852691", "id2": "7468819", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"hash": [" mac", "string", " message", " key", "run", "update", " fingerprint", " h", " encoding", "h", " salt", " check", "id", "dump", " sum", " signature", "Hash", " Hash", "sum", " hashing", "code", " equals", " text", "print", "sign", "hex"], "data": ["name", "sequence", "image", "string", "action", "ata", "any", "this", "message", "sample", "what", "info", "content", "value", "json", "hello", "buffer", "dat", "padding", "password", "area", "result", "dump", "batch", "space", "command", "form", "text", "d", "output", "DATA", "input", "bytes", "secret", "raw", "state"], "digest": [" hexests", "deest", "Digest", " digist", "mdEST", "redose", " digested", "Digester", " hexest", "deEST", "signest", "duist", "duose", "mdest", "dese", "digse", "signse", "mdester", "Digist", "duest", "digests", "redist", " digger", " digose", "digger", "redest", "signEST", " digse", " hexute", "digested", "Digse", " digester", " digests", "duger", "digose", "redger", " digEST", "deist", "digEST", "digute", "DigEST", "digester", "Digests", "digist", " hexested", "Digested", " digute", "mdse", "signested", "Digute", "mdested"]}}
{"id1": "1798720", "id2": "411595", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"save": ["zip", "Save", "delete", "init", "version", " seal", "download", "pack", "update", "filename", "folder", "archive", "aw", "data", "export", "dump", "saving", "accept", "release", "send", "install", "store", "pkg", " Save", "register", "upload"], "packageName": ["pkgKey", " packageCode", "packageId", "pkgId", "pkgNames", "PackageNames", "modulename", "moduleCode", "PackageId", "pkgname", "packageNames", "moduleKey", " packageKey", "packagename", "pkgType", "PackageType", "moduleId", "packageType", " packageNames", "PackageName", "pkgCode", " packageId", "packageCode", "pkgName", "packageKey", "moduleName", " packagename", "moduleNames", " packageType"], "fileContents": [" fileIngredients", "fileIngredients", "FileIngredients", " fileBytes", "FileValues", "FileItems", "FileNames", " fileItems", "packageNames", "pageItems", "pageNames", "byteNames", "packageContents", "FileContents", "fileValues", "byteContent", "FileBytes", "pageBytes", "byteContents", " fileContent", "packageIngredients", "fileContent", "packageContent", "fileBytes", "fileItems", " fileValues", "byteValues", "FileContent", "pageContents"], "fileNames": ["issueNames", "moduleContents", "issueVaults", "dirNames", "fieldNumbers", "FileTypes", "dirLeaks", "messageKeys", "dirTypes", "FileName", " fileKeys", "issueName", "FileValues", "FileNames", " fileLeaks", "resourceNumbers", "fileTypes", " fileTypes", "messageNames", "fileNumbers", "resourceContents", "fileLeaks", "resourceTypes", " fileVaults", "fieldContents", "moduleVaults", "FileKeys", "fieldTypes", "resourceValues", "fileVaults", "fileValues", "FileContents", "resourceNames", "fieldNames", " fileNumbers", "FileLeaks", "dirKeys", "moduleName", "messageName", "fileKeys", "fileName", " fileName", " fileValues", "messageValues", "issueContents", "moduleNames"], "dirBase": ["DIRBas", "DIRBase", "directoryBase", "DirBottom", "irBase", "pathBas", "DIRBuilder", "directorybase", "pkgbase", "folderBas", "dirSet", " directoryBas", "pkgSet", "directoryBasic", "pkgBase", "folderbase", "irBas", "dirBas", "dirBasic", "irbase", "DirBuilder", " directoryBase", "pathBasic", "dirBottom", " directoryBuilder", "dirBuilder", "DIRBottom", "pathbase", "directorySet", "pkgBas", "DirBas", "folderBasic", "folderBase", "directoryBas", "DirBase", " directoryBottom", "irSet", "dirbase", "pathBase"], "packageDir": [" packageFolder", "installDir", "pkgFolder", "pkgRel", "podD", "podDef", "moduleRel", "podDist", " packageRel", "packagePath", "moduleFolder", "packageRel", "installD", "moduleDir", "packageFolder", "packageD", "pkgDir", "packageDef", " packageDef", "installDist", "podDir", "packageDist", "pkgPath", " packagePath", " packageD", " packageDist", "pkgDef", "moduleDef", "modulePath", "installDef"], "created": ["loaded", "printed", "recorded", "provided", "added", "existent", "founded", "present", "ready", "confirmed", "registered", " started", "TED", "installed", "associated", "raised", "ced", "activated", "creat", "given", "mounted", " generated", "called", "creation", "produced", "defined", "checked", "successful", "generated", "joined", "filled", "released", "arted", "forced", "allowed", "create", "started", "reported", "made", "locked", "Created", "creator", "developed"], "currentPath": ["currentlyPath", "currentName", "currentlyName", "recentParent", "currentlyFile", " currentCh", "currentCh", " currentName", " currentParent", " currentFile", "CurrentPoint", "recentPoint", "recentPath", "currentPoint", "CurrentCh", " currentPoint", "CurrentParent", "CurrentPath", "currentlyCh", "currentFile", "CurrentFile", "CurrentName", "recentName", "currentParent"], "i": ["ix", "im", "cgi", "p", "phi", "ui", "ex", "v", "hi", "major", "info", "ski", "ci", "multi", "di", "f", "uri", "ei", "ic", "ity", "in", "qi", "I", "my", "sim", "index", "ii", "ind", "si", "iu", "xi", "m", "iii", "slice", "ki", "jj", "os", "ip", "ri", "exp", "this", "g", "u", "cli", "me", "zi", "id", "batch", "q", "y", "ij", "chain", "o", "ai", "ie", "yi", "them", "bi", "go", "init", "oi", "key", "mi", "it", "gi", "ji", "ini", "ami", "ti", "j", "iy", "mu", "status", "pi", "iq", "li"], "file": ["ile", "port", "name", "link", "child", "le", "path", "parent", "File", "header", "p", "handle", "pool", "fo", "info", "source", "buffer", "log", "h", "resource", "io", "local", "template", "FILE", "f", "comment", "base", "type", "handler", "page", "body", "set", "play", "sf", "rule", "l", "table", "db", "disk", "dir", "row", "et", "format"], "fos": ["Fo", "fOS", " foes", "fbos", "ffos", "woses", "fo", " fow", "oo", "foes", "oaos", "Faos", "woss", "sfoss", "sfOS", "ffoes", "fbaos", "faos", "floes", "ffo", "sfaos", "foses", "flos", "wos", "foss", "Foss", "flaos", " fOS", " faos", "woes", "flo", "fbow", "Fos", "FOS", " fo", "sfos", " foses", "floses", "ffaos", "fow", "Foes", "fbo", "floss", "oow", " foss", "oos"], "fileSrc": ["fileInssrc", "fileInource", " fileInsource", "fileNrl", "jobSrc", "fileNri", " fileInsrc", "fileSRC", "fileInsrc", "fileDsrc", "fileSci", "fileSource", "jobNrc", "jobSrl", "fileErc", "fileInrc", "jobNci", "fileInsource", " fileInsRC", "fileInsRC", "fileInRC", "fileSrl", " fileSRC", "fileNrc", "fileErl", "fileDrl", "fileSri", " fileInssrc", "fileDri", "jobNrl", "jobSri", "fileEri", "fileEci", "jobNri", "fileDRC", "fileDci", " fileSource", " fileSsrc", "jobSci", "fileDrc", "fileDource", "fileSsrc", "fileNci"], "fileDst": ["fileSlt", "FileDlt", "FileDst", "FileSlt", "fileDnd", "fileNld", "fileSnd", "fileScr", "fileDld", "fileSst", "fileSot", "fileNnd", "fileSpl", "FileScr", "FileSld", "fileNot", "fileWpl", "filedcr", "FileSot", "fileDot", "fileWot", "FileDld", "FileSpl", "FileSst", "fileNpl", "fileDcr", "fileDlt", "fileWlt", "fileSld", "filednd", "filedst", "FileDcr", "fileDpl", "filedld", "FileDnd", "FileSnd", "FileDpl", "fileWst", "FileDot", "fileNcr", "fileNst", "fileNlt"], "reader": ["iterator", "Larry", "ri", "rer", "reading", "inner", "stream", "ocker", "loader", "r", "entry", "rr", "oder", "rx", "controller", "query", "buffer", "author", "resource", "read", "parser", "context", "rar", "roller", "book", "handler", "actor", "driver", "ner", "rl", "Reader", "er", "ader", "ro", "review", "upper", "iter", "rc", "row", "runner", "readable", "ler", "rot", "dr"], "writer": ["writers", "iterator", "ter", "println", "writing", "Writer", "server", "liner", "operator", "order", "stream", "wright", "loader", "entry", "w", "adder", "flush", "wrapper", "outer", "query", "buffer", "walker", "variable", "builder", "read", "function", "parser", "manager", "user", "later", "wire", "handler", "storage", "driver", "maker", "report", "worker", "caster", "store", "draw", "console", "service", "Reader", "riter", "browser", "test", "editor", "write", "table", "client", "word", "iter", "creator", "runner", "player", "print", "document", "window", "format"], "line": ["port", "link", "sequence", "liner", "ln", "le", "kin", "header", "stroke", "string", "ine", "continue", "message", "sample", "lined", "entry", "edge", "entity", "detail", "label", "Line", "number", "source", "node", "point", "date", "ole", "LINE", "record", "eline", "user", "comment", "lin", "nl", "valid", "page", "cell", "frame", "range", "code", "text", "chain", "rule", "l", "word", "block", "row", "inline", "print", "style", "column", "pe"]}}
{"id1": "9796161", "id2": "5808579", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": ["toMD7", "toSHA4", "getMD2", "toMD5", "getSHA5", "toSHA7", "getMD7", "getSHA2", "getSHA7", "toSHA5", "getmd7", "getMD4", "getSHA4", "toSHA2", "toMD2", "getmd5", "getmd2", "getmd4", "toMD4"], "s": ["p", "is", "sq", "ts", "ws", "bs", "string", "bytes", "rs", "strings", "v", "ps", "ats", "src", "g", "ns", "sb", "gets", "b", "source", "i", "S", "h", "gs", "ss", "es", "xs", "data", "ends", " gets", "ses", "f", "sv", "ies", "c", "sts", "space", "fs", "abs", "its", "y", "sql", "str", "ms", "text", "t", "ins", "l", "aws", "os", "js", "ls", "n"], "m": ["sm", "M", "nm", "am", "mi", "fm", "g", "v", "dm", "mo", "mm", "man", "e", "mac", "managed", "perm", "gm", "h", "mod", "me", "om", "manager", "rem", "mut", "mu", "pm", "rm", "y", "md", "ms", "hm", "mask", "bm", "cm", "l", "made", "mr", "em", "tm", "vm", "mc", "mt", "mk"]}}
{"id1": "13012591", "id2": "21488868", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"getPasswordHash": [" getPassSum", "getUserHash", "getPassHash", " getPasswordSum", "getPasswordhash", "getpasswordMac", "getUserMac", "getPasswordMac", "getPasswordSum", " getPassHash", "getUserSum", "getPasshash", "getpasswordHash", "getpasswordhash", " getPasswordMac", " getPassMac", "getUserhash", "getpasswordSum", " getPasswordhash", " getPasshash", "getPassSum", "getPassMac"], "password": ["attribute", "name", "key", "string", "pattern", "wd", "description", "message", "entry", "content", "w", "database", "value", "hello", "Password", " Password", "email", "data", "padding", "user", "login", "sword", "command", "prefix", "text", "address", "phrase", "word", "shadow", "input", "reset", "pass", "token", "username", "secret", "raw"], "md": ["sm", "metadata", "df", "and", " mm", "cd", "MD", "add", "dm", "dh", "mo", "mm", "e", "der", "cmd", "od", "ind", "ent", " sd", "bd", "grad", "mac", "sd", "mod", " mo", "di", "pd", "ld", "m", "det", "med", " Md", " dd", " mc", "mp", "rm", "ms", "mg", " ms", "mem", "red", "mn", "d", "gr", "nd", "dir", "mand", "dd", "mc", "mt", "mk", " ma", "hd"], "hash": ["style", "ashed", "where", "cache", "html", "array", "oh", "dig", "used", "char", "sh", "bh", "sample", "shift", "stack", "mac", "square", "number", "all", "h", "here", "host", "match", "ash", "hz", "map", "box", "esh", "search", "Hash", "report", "sum", "color", "ashes", "mask", "check", "address", "test", "table", "total", "block", "hex", "score", "filter", "print", "has", "index", "handle", "sha"], "buf": ["printf", "bn", "msg", "cap", "bg", "alph", "cv", "bc", "aux", "bs", "cb", "forge", "bytes", "bh", "bl", "foo", "fam", "nb", "cmd", "b", "bed", "buffer", "agg", "Buffer", "uf", "next", "tmp", "bar", "ov", "box", "bp", "av", "txt", "abs", "bu", "hung", "mu", "br", "cur", "bag", "img", "Buff", "buff", "bo", "proc", "pb", "db", "pkg", "cf", "ob", "block", "rb", "cat", "var"], "i": ["ix", "im", "bi", "ip", "key", "ri", "is", "mi", "x", "it", "phi", "gi", "ui", "ji", "si", "v", "a", "ini", "hi", "ex", "u", "e", "cli", "\u0438", "iu", "json", "ski", "gu", "ti", "ci", "j", "multi", "di", "xi", "m", "c", "iq", "uri", "ii", "q", "y", "ei", "ic", "in", "ims", "ms", "qi", "ogi", "chain", "us", "ki", "o", "ai", "I", "n", "z", "my", "pi", "yi", "sim", "index", "ind", "li"]}}
{"id1": "1180878", "id2": "6403868", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fectURLFrame", "fetchUrldata", "fectURLStream", "fectURLdata", "fetchGETdata", "fetchStringFrame", "fectUrlStream", "fetchGETData", "fetchStringData", "fectUrlData", "fetchURLStream", "fetchURLFrame", "fectUrlFrame", "fectURLData", "fetchUrlFrame", "fectUrldata", "fetchGETStream", "fetchGETFrame", "fetchURLdata", "fetchUrlStream", "fetchStringdata", "fetchUrlData", "fetchStringStream"], "url": ["mail", "Url", "name", "link", "html", "pl", "path", "domain", "lim", "string", "full", "pattern", "xml", "mount", "cl", "file", "location", "b", "log", "gl", "ssl", "host", "resource", "default", "dl", "base", "uri", "web", "nl", "http", "sl", "el", "sql", "ll", "address", "ref", "https", "loc", "rel", "l", "null", "URL", "print", "ls", "ur", "ul"], "proxyHost": ["serverhost", "proxyName", " proxyhost", "roxyHost", "roxyUrl", "slaveCheck", "proxyUrl", "proxyOver", "slaveUrl", "proxyCheck", "ProxyHost", "roxyAddress", "slavehost", "slaveHost", "slaveLabel", "Proxyhost", "serverPort", "proxyAddress", "roxyOver", "slaveOver", "roxyCheck", "ProxyName", "serverName", "ProxyUrl", "ProxyLabel", " proxyOver", "proxyLabel", "proxyhost", "roxyhost", "roxyLabel", "serverHost", " proxyAddress", " proxyCheck", "slaveAddress", " proxyName", "ProxyPort"], "proxyPort": ["aliasHost", "serverAddress", "proxyPORT", "aliasPort", "aliasAddress", "Proxyport", "ProxyPORT", "ProxyHost", "serverPORT", " proxyport", "aliasport", "serverPort", "proxyAddress", " proxyPORT", "serverport", "serverHost", " proxyAddress", "proxyport", "ProxyPort"], "con": ["pc", "cons", "cgi", "cs", "conn", "go", "ln", "bc", "ver", "ocon", "ain", "comm", "const", "cc", "pan", "act", "xc", "rec", "ex", "don", "mo", "connect", "pen", "lock", "cmd", "syn", "cos", "cone", "fin", "func", "close", "ran", "col", "conv", "cover", "cal", "call", "fc", "c", "cont", "po", "non", "conf", "cond", "nc", "com", "ctrl", "CON", "cur", "canon", "en", "gate", "bo", "un", "proc", "cf", "client", "open", "Con", "sub", "connection", "dial", "co", "fac", "Conn", "trans", "cat", "mc", "can", "cp", "cn"], "is": ["im", "bits", "are", "cs", "ip", "init", "ois", "ri", "iss", "ts", "bs", "rs", "si", "isin", "ps", "as", "gets", "isa", "dis", "sis", "iso", "sys", "Is", "i", "isf", "ys", "ris", "es", "IS", "xs", "isp", "abs", "fs", "bis", "its", "in", "ios", "ims", "ms", "isl", "ins", "us", "ains", "ists", "ais", "iris", "eps", "was", "os", "iter", "s", "isc", "oss", "mis", "isi", "ist", "has", "lis"], "u": ["tu", "ue", "up", "U", "su", "uj", "ui", "g", "ru", "ut", "iu", "uv", "uid", "i", "uf", "pu", "user", "lu", "c", "bu", "uri", "hu", "mu", "uu", "fu", "eu", "cu", "us", "au", "nu", "o", "un", " nu", "ud", "yu", "ur", "uni", "ul", "ou"], "proxy": ["port", "zip", "link", " prox", "timeout", "cache", "pin", "server", "ip", "go", "domain", "cas", "roxy", "version", "pse", "x", "socket", "pool", "pipe", "via", "pointer", " proxies", "slave", "pro", "py", "cone", "alias", "ssl", "host", "profile", "embed", "map", "password", "library", "translation", "echo", "project", "phone", "xy", "base", "po", "prime", "PRO", "web", "http", "ping", "browser", "pre", "address", "https", "bo", "jp", "friend", "client", "policy", "Proxy", "null", "shadow", "connection", "pi", "token", "aco", "gp", "cp", "pe", "XY"], "baos": ["baOs", " baoss", "bao", "naoss", "poose", "BAo", "naos", "aois", "aooS", "bais", " bao", " baose", "naows", "baows", "BAoss", " baows", "baose", " bais", "aoos", "nao", "baOS", "aoOS", "BAows", "BAose", "BAOs", " baOS", " baOs", "baoS", "vaoS", "poOs", "vaos", "poo", "vaOS", "BAos", "baoss", "vais", " baoS", "poos"]}}
{"id1": "1180878", "id2": "411595", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fectURLFrame", "fetchUrldata", "fectURLStream", "fectURLdata", "fetchGETdata", "fetchStringFrame", "fectUrlStream", "fetchGETData", "fetchStringData", "fectUrlData", "fetchURLStream", "fetchURLFrame", "fectUrlFrame", "fectURLData", "fetchUrlFrame", "fectUrldata", "fetchGETStream", "fetchGETFrame", "fetchURLdata", "fetchUrlStream", "fetchStringdata", "fetchUrlData", "fetchStringStream"], "url": ["mail", "Url", "name", "link", "html", "pl", "path", "domain", "lim", "string", "full", "pattern", "xml", "mount", "cl", "file", "location", "b", "log", "gl", "ssl", "host", "resource", "default", "dl", "base", "uri", "web", "nl", "http", "sl", "el", "sql", "ll", "address", "ref", "https", "loc", "rel", "l", "null", "URL", "print", "ls", "ur", "ul"], "proxyHost": ["serverhost", "proxyName", " proxyhost", "roxyHost", "roxyUrl", "slaveCheck", "proxyUrl", "proxyOver", "slaveUrl", "proxyCheck", "ProxyHost", "roxyAddress", "slavehost", "slaveHost", "slaveLabel", "Proxyhost", "serverPort", "proxyAddress", "roxyOver", "slaveOver", "roxyCheck", "ProxyName", "serverName", "ProxyUrl", "ProxyLabel", " proxyOver", "proxyLabel", "proxyhost", "roxyhost", "roxyLabel", "serverHost", " proxyAddress", " proxyCheck", "slaveAddress", " proxyName", "ProxyPort"], "proxyPort": ["aliasHost", "serverAddress", "proxyPORT", "aliasPort", "aliasAddress", "Proxyport", "ProxyPORT", "ProxyHost", "serverPORT", " proxyport", "aliasport", "serverPort", "proxyAddress", " proxyPORT", "serverport", "serverHost", " proxyAddress", "proxyport", "ProxyPort"], "con": ["pc", "cons", "cgi", "cs", "conn", "go", "ln", "bc", "ver", "ocon", "ain", "comm", "const", "cc", "pan", "act", "xc", "rec", "ex", "don", "mo", "connect", "pen", "lock", "cmd", "syn", "cos", "cone", "fin", "func", "close", "ran", "col", "conv", "cover", "cal", "call", "fc", "c", "cont", "po", "non", "conf", "cond", "nc", "com", "ctrl", "CON", "cur", "canon", "en", "gate", "bo", "un", "proc", "cf", "client", "open", "Con", "sub", "connection", "dial", "co", "fac", "Conn", "trans", "cat", "mc", "can", "cp", "cn"], "is": ["im", "bits", "are", "cs", "ip", "init", "ois", "ri", "iss", "ts", "bs", "rs", "si", "isin", "ps", "as", "gets", "isa", "dis", "sis", "iso", "sys", "Is", "i", "isf", "ys", "ris", "es", "IS", "xs", "isp", "abs", "fs", "bis", "its", "in", "ios", "ims", "ms", "isl", "ins", "us", "ains", "ists", "ais", "iris", "eps", "was", "os", "iter", "s", "isc", "oss", "mis", "isi", "ist", "has", "lis"], "u": ["tu", "ue", "up", "U", "su", "uj", "ui", "g", "ru", "ut", "iu", "uv", "uid", "i", "uf", "pu", "user", "lu", "c", "bu", "uri", "hu", "mu", "uu", "fu", "eu", "cu", "us", "au", "nu", "o", "un", " nu", "ud", "yu", "ur", "uni", "ul", "ou"], "proxy": ["port", "zip", "link", " prox", "timeout", "cache", "pin", "server", "ip", "go", "domain", "cas", "roxy", "version", "pse", "x", "socket", "pool", "pipe", "via", "pointer", " proxies", "slave", "pro", "py", "cone", "alias", "ssl", "host", "profile", "embed", "map", "password", "library", "translation", "echo", "project", "phone", "xy", "base", "po", "prime", "PRO", "web", "http", "ping", "browser", "pre", "address", "https", "bo", "jp", "friend", "client", "policy", "Proxy", "null", "shadow", "connection", "pi", "token", "aco", "gp", "cp", "pe", "XY"], "baos": ["baOs", " baoss", "bao", "naoss", "poose", "BAo", "naos", "aois", "aooS", "bais", " bao", " baose", "naows", "baows", "BAoss", " baows", "baose", " bais", "aoos", "nao", "baOS", "aoOS", "BAows", "BAose", "BAOs", " baOS", " baOs", "baoS", "vaoS", "poOs", "vaos", "poo", "vaOS", "BAos", "baoss", "vais", " baoS", "poos"]}}
{"id1": "8430178", "id2": "18974466", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpLine", "cpFiles", "copyLine", "CopyLine", "CopyFile", "CopyPath", " copyLine", "cpPath", "CopyFiles", " copyFiles", "cpFile", "copyPath", "copyFiles", " copyPath"], "source_name": ["src_names", "source_check", "src_check", "src_format", "Source_NAME", "source09names", "src_file", "sourceptname", "src_name", "sourcePlocal", "src_link", "sourceEname", "source_format", " source_names", "src_case", "source_Name", "src_Name", "source_word", " source_word", "Source_local", "source_local", "source_link", "sourceptnames", "sourceEName", "source09name", "source09link", "sourceEnames", "source_names", "sourceEcase", "source_case", "Source_name", "sourcePname", "sourceptcheck", "source_NAME", "source09file", "sourceptName", "sourcePNAME"], "dest_name": ["start_admin", "destityname", "startityName", "destityadmin", "destipcreate", "dest_create", "src_file", "dest__key", "Dest_admin", "destaxynames", "dest_NAME", "destationName", "dest_file", "dest_common", "src_name", "destipid", "Dest_Name", "destitycommon", "dest_nam", "destipname", "dest_admin", " dest_size", "destationcommon", "dest__names", "dest__name", "source_Name", "source_nam", " dest_key", "dest_group", "destipfile", "dest9group", "dest_min", " dest_time", "dest9admin", "destaxyname", " dest_no", "src_create", "start_common", "dest_key", "start_Name", " dest_min", "src_id", "startityadmin", "dest9name", " dest_names", "dest_id", "Dest_group", "dest9Name", "source_names", "destaxynam", " dest_file", "destaxyName", "start_name", "destationname", " dest_Name", "destationadmin", "dest_size", "dest_no", "dest__size", "dest_Name", "source_NAME", "dest_time", "destityName", "startityname", "Dest_name", "dest_names", "startitycommon"], "source_file": ["source___le", "sourcepyfile", "site_service", "sourceistlink", "source_service", "source_time", "src_file", "src_path", "site___service", "src_name", "source1name", "site___file", "source_path", "source___stream", "source_info", "source2info", "source1path", "ource_file", "source1file", "sourcepyservice", "source_link", "source_class", "source___File", "ource_time", "ource_File", "source_id", "source___service", "sourcephpstream", "sourcepyle", "site___stream", "sourcephpservice", "site_stream", " source_info", "sourcephple", "source___file", "sourceistfile", " source_entry", "source2entry", "ource_class", "source_le", "src_stream", "site_file", "source2file", "site_le", "sourcephpfile", "source_stream", " source_id", "sourceistid", "sourceistname", "source_File", "source___class", "source___time", " source_link", "site___le", "sourcepystream", "source1stream", "source_entry"], "destination_file": ["destination_db", "destination____db", "destrant_image", "destination_image", "destinant_domain", "destination_port", "destinationJpath", "destrantJimage", "destination_do", "destinate_file", "destination_dir", "destrantJfp", "destinant_File", "destination____file", "destinant_port", "destinant____file", "destinant____File", "destification_ile", "destination_File", "destinate_dir", "destrantJpath", "destrant_file", "destination_fp", "destification_file", "destinant_fp", "destination__db", "destification_port", "destinant_file", "destinate_do", "destinationJfp", "destination_domain", "destination_path", "destification_path", "destinationJfile", "destination____File", "destination__file", "destinant_db", "destinant_link", "destinant____db", "destination__domain", "destinationJimage", "destinant____domain", "destrantJfile", "destrant_path", "destination_ile", "destrant_fp", "destinate_ile", "destination____domain", "destination_link", "destination__File"], "source": ["Source", "volume", "sequence", "cause", "unit", "server", "origin", "parent", "image", "system", "sin", "dest", "master", "ource", "src", "scope", "major", "sample", "target", "copy", "content", "title", "argument", "file", "config", "query", "start", "product", "session", "resource", "join", "local", "template", "existing", "base", "from", "search", "or", "site", "status", "feature", "object", "directory", "service", "set", "ources", "ser", "store", "out", "class", "proxy", "client", "tool", "iter", "secret", "connection", "shadow", "input", "ie", "ce", "script", "note", "SOURCE", "reader", "use"], "destination": ["destinate", "termininator", "alterninate", "alterninated", "estination", "gestinated", "coordinate", "Destinations", "targetinated", "destociation", "restinated", "originification", "targetination", "terminociation", "terminination", "estinate", "Destion", "estication", "gestination", " destification", "origininated", "destion", "destication", "Destation", "restinator", "coordication", "destinator", " destinate", "Destinator", "restinations", "coordination", " destication", "destinated", "destification", " destation", "methodination", "alternination", "restation", "Destinated", "targetinator", "methodinate", "gestinator", "destinations", "originination", "destation", " destinator", "termininated", "restion", " destinated", "targetinations", "alterninator", "targetion", "coordinated", "restinate", "estinated", "origininator", "restination", "methodinator", "gestociation", "targetification", "methodinated", "Destination", "targetociation"], "buffer": ["sequence", "cache", "stream", "message", "b", "read", "buf", "Buffer", "bb", "transfer", "append", "context", "batch", "base", "comment", "command", "frame", "text", "buff", "binary", "length", "table", "paste", "iter", "block", "document", "window"], "bytes_read": ["bytes_left", "bytes2read", " bytes_written", "bytesunwritten", "bytes_Read", "bytes2left", "bytes2Read", "bytesunread", "bytesunRead", "bytes2written", "bytes_written", " bytes_left", " bytes_Read", "bytesunleft"], "in": ["inn", "p", "is", "it", "inner", "stream", "isin", "ini", "r", "din", "add", "mm", "file", "all", "nin", "bin", "err", "log", "io", "read", "gin", "ar", "user", "id", "from", "In", "std", "sum", "conf", "body", "ic", "ins", "t", "en", "out", "mn", "IN", "l", "doc", "client", "get", "con", "n", "input", "cin", "rin", " IN", "diff", "reader", "inf", "ind"], "response": ["sequence", "answer", "version", "resp", "notice", "remember", "continue", "description", "message", "sample", "entry", "offer", "value", "json", "success", "bye", "hello", "query", "question", "network", "one", "respond", "respons", "data", "zero", "example", "echo", "result", "exit", "application", "res", "ping", "vector", "command", "page", "status", "onse", "Response", "python", "hash", "choice", "relation", "output", "line", "block", "request", "connection", "reset", "reply", "print", "window", "format"], "parentdir": [" parentDir", "parentDir", "rootdirectory", " parentdirect", "fatdirectory", "parentfolder", "Parentfile", "rootd", "parentdirect", "masterdir", "rootfolder", " parentdirectory", "Parentfolder", "masterdirectory", " parentfolder", " parentd", "fatdirect", "masterDir", " parentfile", "ParentDir", "rootDir", "Parentdir", "parentd", "parentfile", "fatdir", "rootdir", "Parentdirectory", "parentdirectory", "rootdirect", "fatd", "masterfile"]}}
{"id1": "3994258", "id2": "9257487", "code1": "    public boolean connectServer(String server, String user, String password) {\n        boolean result = true;\n        try {\n            if (user.equals(\"\")) {\n                user = \"anonymous\";\n                password = \"anonymous\";\n            }\n            this.server = server;\n            this.user = user;\n            this.password = password;\n            ftpClient = new FTPClient();\n            ftpClient.setControlEncoding(encode);\n            ftpClient.connect(server);\n            ftpClient.setSoTimeout(1000 * 30);\n            ftpClient.setDefaultTimeout(1000 * 30);\n            ftpClient.setConnectTimeout(1000 * 30);\n            ftpClient.enterLocalPassiveMode();\n            ftpClient.login(user, password);\n            if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {\n                ftpClient.disconnect();\n                return false;\n            }\n            queFilePath = \"data\\\\\" + this.server + \".que\";\n            bufFilePath = \"data\\\\\" + this.server + \".buf\";\n            startGetList();\n        } catch (java.net.SocketTimeoutException e1) {\n            errMsg = ftpClient.getReplyString();\n            errCode = ftpClient.getReplyCode();\n            result = false;\n            setArrToFile(dirQueue, queFilePath);\n            setArrToFile(fileList, bufFilePath);\n            cn.imgdpu.util.CatException.getMethod().catException(e1, \"\u8fde\u63a5\u8d85\u65f6\");\n        } catch (Exception e) {\n            errMsg = ftpClient.getReplyString();\n            errCode = ftpClient.getReplyCode();\n            result = false;\n            setArrToFile(dirQueue, queFilePath);\n            setArrToFile(fileList, bufFilePath);\n            cn.imgdpu.util.CatException.getMethod().catException(e, \"\u672a\u77e5\u5f02\u5e38\");\n        } finally {\n            if (ftpClient.isConnected()) {\n                try {\n                    ftpClient.disconnect();\n                } catch (IOException ioe) {\n                    cn.imgdpu.util.CatException.getMethod().catException(ioe, \"IO\u5f02\u5e38\");\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"connectServer": ["openServer", "connectDatabase", "selectServer", "connectionServer", "connectionDatabase", "connectSite", "openSer", "connectionSer", "selectSite", "selectDatabase", "openDatabase", "connectionSite", "connectSer", "selectSer", "openSite"], "server": ["port", "remote", "name", "free", "url", "ter", "ip", "domain", "enter", "model", "version", "system", "ver", "socket", "parent", "erver", "description", "master", "mobile", "sample", "localhost", "slave", "entry", "device", "database", "cookie", "value", "node", "hello", "source", "query", "folder", "Server", "controller", "ve", "host", "serv", "computer", "email", "manager", "column", "template", "project", "base", "search", "uri", "engine", "site", "http", "page", "peer", "scale", "instance", "store", "console", "service", "ser", "code", "browser", "address", "er", "test", "seed", "table", "client", "total", "connection", "row", "directory", "center"], "user": ["port", "attribute", "name", "util", "path", "key", "User", "any", "string", "consumer", "per", "you", "ver", "auth", "char", "owner", "order", "usage", "issue", "device", "info", "database", "u", "file", "admin", "uid", "query", "author", "host", "profile", "me", "manager", "data", "error", "root", "basic", "person", "type", "from", "login", "usa", "student", "command", "form", "store", "or", "post", "ername", "rule", "er", "usr", "by", "client", "term", "word", "USER", "account", "creator", "field", "token", "note", "nick", "used", "username", "use", "human"], "password": ["port", "attribute", "picture", "power", "p", "PASS", "pattern", "auth", "remember", "wd", "pool", "description", "wordpress", "device", "database", "number", "hello", "Password", "sudo", "session", "parser", "profile", "data", "padding", "application", "comment", "security", "login", "pty", "crypt", "worker", "sword", "command", "prefix", "hash", "mask", "code", "language", "chain", "phrase", "paste", "policy", "word", "client", "wp", "words", "shadow", "account", "pass", "token", "directory", "username", "secret"], "ftpClient": ["ftppclient", "factpatDo", "aftcHandler", "ftcpStore", "aftpConnection", "ftpDo", "aftPConnection", "fftpclient", "aftpControl", "ftpatClient", "ftpCan", "fttpStore", "ftpiClient", "ctpClient", "ftwpDo", "ftpiContent", "fttStore", "aftcpclient", "ffpClient", " ftcpBody", "aftcpControl", "ftppControl", "ftcConnection", "ftcpClient", "ftphpClient", "ctpclient", "fttpControl", "factpatNode", "aftpHandler", "fttpConnection", "aftPClient", "ftlpClient", "ftpBuilder", "ftpMethod", "ftppCan", "ftcDo", "aftpClient", " ftpConnection", "aftPBuilder", "aftpMethod", "ftwpclient", "ftpatDo", "ftfControl", "ftpatclient", "ftcpMethod", "fttAdmin", "ftcpContent", "aftPDo", "ftPStore", "ftcpHandler", " ftPStore", " ftpclient", "ftcHandler", "fftclient", "fftClient", "ftcclient", "ftpContent", "fttClient", "ftpaclient", "ftpaMethod", "ftpAdmin", " ftpContent", "ftfConnection", "ftpBody", "aftcpClient", " fttclient", " ftcpContent", "factpatclient", " ftcpClient", "ftpatNode", "ftwpClient", "ftlpDo", "ftcpConnection", "ctcpContent", "fttclient", "ftpNode", "ftcNode", "ffpCan", "ftwpNode", "ftppClient", " fttClient", "fftpConnection", "ctcpclient", "ftpiBody", " ftPConnection", "ftpStore", "ftcpBody", " ftPClient", "ftpatAdmin", "ftPClient", "ffpclient", "fttMethod", "ftPConnection", "aftcClient", "ftPBuilder", "fttpClient", "ftpaClient", "ftpatControl", "ftphpclient", "aftcpConnection", "aftcControl", "ffpControl", "ftpclient", "aftpBuilder", "ftfclient", " fttStore", "fttpDo", "fttConnection", "ftPDo", "ctcpClient", "factpDo", "ftpControl", " ftpStore", "ftcpclient", "aftpDo", "factpclient", "ctpContent", "ftpHandler", "ftcpControl", "fftControl", "fttCan", "ftcContent", "ffpConnection", " fttConnection", "aftcpMethod", "fftpClient", "fttHandler", "fttControl", "ftcAdmin", "ffpAdmin", "fftAdmin", "ftcStore", "fttpclient", " ftpBody", "factpClient", "ftcControl", " ftPclient", "ftphpContent", "factpNode", "ftlpContent", "ftPclient", "ftpConnection", "ftfClient", "aftcclient", "ftcCan", "ftlpBody", "aftpclient", "ftcBuilder", "ftcClient", "factpatClient", "fftCan", "fttpBuilder"], "queFilePath": ["queFPath", "quFilePath", "quItemPath", "queLineFormat", "queTimePath", "queStoreStep", "quefilePath", "queTimePart", "queLinePos", "quFilePart", "quFileStep", "quFileInfo", " queTableId", "queFileStep", "queTablePath", "queTimeInfo", "queTimeStep", "queFileDir", "quefileDir", "quItemInfo", "queLinePath", "queFFormat", "queStoreInfo", "queFileName", "queItemStep", "queFileId", "queFpath", "queDirId", "quefileName", "queItemPart", "quItemStep", "queFileInfo", "queFileFormat", "queItemInfo", "queStorePath", "bufFilepath", "queFilePart", " queTableName", "quItemPart", "queTableName", " queFileId", "queFilepath", "queDirPath", "bufFileFormat", " queFileName", " queTablePath", "quefileId", " queFileDir", "queStorePart", "queDirDir", "queFPos", "queFilePos", " queTableDir", "queTableId", "queTableDir", "queLinepath", "queItemPath", "bufFilePos", "queDirName"], "bufFilePath": ["bufTableName", " bufByteLocation", " bufBytePath", "bufferFilepath", "bufLineTime", "bufByteName", "vecQueueName", "bufBytePath", "bufFilenameDef", "buffileDef", "bufQueuePath", "bufTableLocation", " bufByteName", "bufFilenamePath", "vecFileName", "bufLinepath", "vecQueueStr", "bufFilenameStr", "buffileTime", "bufRelPath", "vecFileDef", " bufFileData", "bufferfilePath", "bufferFilePath", "bufLineName", "bufferfileName", " bufByteData", "bufQueueName", "buffileData", "bufFilenameName", "bufRelpath", "bufByteLocation", "bufferFileTime", "vecFilePath", "bufFileTime", "vecFileStr", "vecQueueDef", "bufFileLocation", "bufLinePath", "bufFilepath", "buffilepath", "bufferfilepath", " bufFileName", "buffileLocation", "bufQueueStr", "buffileName", "bufByteData", " bufFileLocation", "bufferfileTime", "buffilePath", "buffileStr", "bufFileStr", "vecQueuePath", "bufTablePath", "bufRelName", "bufTableData", "bufferFileName", "bufFileDef", "bufFileName", "bufFileData", "bufRelTime", "bufQueueDef"], "errMsg": ["cfgMessage", " errSm", "erMessage", "failSm", "erLog", " errStr", " errLog", "cfgLog", "erMess", "cfgMess", "sprStr", "errMessage", "errMess", "cfgMsg", "errLog", " errMess", "sprMsg", "errStr", "erMsg", "sprMess", " errMessage", "failMsg", "failMess", "errSm", "failStr", "sprSm"], "errCode": ["urgNo", "sprSc", " errSc", "sprCode", "errCheck", "urgCheck", "rrNo", "urgCon", " errCheck", "sprCount", "errSc", "eorSc", " errNo", " errCon", "rrCode", "errCon", " errDef", "eorCode", " errCount", "rrCheck", "urgCode", "errNo", "eorDef", "errCount", "rrCon", "eorCount", "errDef", "sprDef"], "result": ["sequence", "msg", "cache", "su", " res", "answer", "cert", "journal", "Result", "continue", "ret", "description", "false", "process", "r", "run", "flag", "value", "perm", "success", "event", "make", "goal", "date", "global", "results", "profile", "data", "match", "res", "report", "valid", "status", "feature", "draw", "details", "mask", "chain", "out", "relation", "know", "duration", "table", "were", "fac", "show", " Result"]}}
{"id1": "364438", "id2": "20851065", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["Converting", "conVERT", "consvert", "CONversion", "conversion", "unfer", "converted", "compvert", "compversion", "consversion", "compverts", "Converted", "unversion", "converting", "CONverted", "CONfer", "unvert", "converts", "consVERT", "Conversion", "CONverting", "conprocess", "ConVERT", "CONVERT", "CONvert", "consverting", "Confer", "unverted", "confer", "Conprocess", "unverts", "compprocess", "Convert", "Converts", "unprocess"], "src": ["Source", "scan", "url", "hl", "path", "orig", "attr", "sq", "inst", "addr", "cc", "sin", "rs", "stream", "ource", "href", "sr", "rx", "file", "config", "source", "ebin", "start", "filename", "sys", "SourceFile", "sit", "ipl", "host", "func", "RC", "scene", "iv", "txt", "from", "cont", "uri", "http", "its", "st", "str", "ser", "ins", "cur", "img", "loc", "rel", "usr", "pkg", "buster", "sc", "ur", "req", "rc", "s", "dist", "input", "SOURCE", "rest", "upload"], "dest": ["port", " destinations", "orig", "est", "Dest", "mat", " Destination", "target", "temp", " orig", "source", " destination", "gin", "dat", "result", "txt", " dst", " Dest", "img", "test", "foreign", "write", "table", "tif", "disk", "dir", "dist", "rest"], "in": ["inn", "up", "is", "inner", "stream", "isin", "r", "din", "file", "source", "b", "bin", "i", "io", "serv", "ad", "ar", "m", "from", "res", "In", "el", "sql", "st", "ins", "en", "IN", "d", "l", "input", "cin", "rin", "reader", "as", "inf", "ind"], "p": ["fp", "pc", "php", "pl", "pp", "per", "it", "part", "g", "ps", "r", "pro", "py", "pg", "vp", "b", "ph", "i", "h", "ap", "parser", "P", "parse", "j", "pa", "pd", "f", "m", "lp", "c", "ping", "rep", "pm", "post", "prot", "op", "t", "pre", "er", "pers", "at", "jp", "dp", "d", "pb", "l", "pkg", "wp", "pt", "pi", "sp", "cp", "pe", "tp"], "ds": ["cs", " os", "ports", "drivers", "dh", " ads", "ss", "scripts", "di", "dates", "edes", "sts", " d", "tests", "nas", "dds", "aws", "hd", "obs", "posts", "bs", "rs", "cks", "DS", "ys", "uds", " dd", "eds", "its", "vs", "dp", "d", "os", "terms", "outs", "qs", "dd", "pd", "tp", "ras", "ts", "ods", "Ds", "tes", " DS", "ps", "points", "ils", "gs", "amps", "docs", "xs", "ands", " des", "workers", "lists", "ads", "des", "db", "eps", "dos", "iffs", "dt", "js", "ks", "ls", "mys", "yes", "ws", "gd", "ats", "els", "sets", "ns", "sd", "tags", "loads", "dl", "ags", "s", "hs", "df"], "format": ["name", "unit", "lat", "path", "shape", "version", "it", "settings", "mat", "pattern", "act", "fm", "MAT", "ats", "title", "file", "source", "layout", "parse", "sche", "template", "top", "id", "fc", "f", " Format", "type", "mode", "status", "form", "tag", "feature", "set", "t", "spec", "at", "cf", "table", "output", "module", "l", "policy", "feat", "size", "pretty", "pi", "filter", "mt", "ct", "style", "Format"], "hasPixelData": ["haspixelDATA", "hasFramedata", "HaspixelData", "hasixelData", "hasPixeldata", "hasixelDATA", "hasFrameDATA", "hasFrameData", " hasPixelDATA", "HasPixelDATA", "hasPixelDATA", "HasPixelData", "HaspixelDATA", "haspixeldata", "Haspixeldata", "HasPixeldata", " hasPixeldata", "hasixeldata", "haspixelData"], "inflate": ["Informate", "inFlocate", "informate", "invalidocate", " invalidATE", "inflATE", "inflated", "informated", "inFLated", "infolat", "incelicate", "inFlATE", "informat", "Inflat", "infolated", "invalidicate", "inFLat", "informocate", "incelocate", "Inflocate", "inFlate", "Informocate", "inFLocate", "incelate", "inflocate", "invalidate", "inFLate", " inflocate", "infolate", "inflicate", "invalidATE", "infolocate", "inFlicate", "Informated", " invalidicate", "Inflated", " invalidate", "incelATE", "inflat", " invalidocate", "Inflate", " inflicate", " inflATE", "Informat"], "pxlen": ["packls", "mxdec", "pexlen", "packln", "pxls", "pexfun", "xpden", "mxln", "phpdec", "tmpln", "pxden", "mxlength", "mmlen", "xyln", "mmln", "phpln", "pixellength", "pxdec", "xplen", "pixells", "pexln", "tmplength", "xylength", "cpden", "pxlin", "tmplin", "mmlength", "phplength", "pixelfun", "xylin", "cplength", "mmlin", "packdec", "pxln", "pexlength", "xylen", "tmplen", "xplength", "pxfun", "phplen", "mxlen", "pxlength", "pexls", "pexden", "pixellen", "packlen", "xpln", "packfun", "cplen", "cpln", "packlength"], "out": ["name", "msg", "obj", "group", "up", "conn", "ln", "init", "writer", "gov", "inv", "Out", "ex", "aos", "outer", "temp", "cmd", "log", "err", "sys", "io", "inter", "user", "crit", "res", "cfg", "sum", "store", "prefix", "client", "output", "dir", "gr", "list", "outs", "OUT", "screen", "net", "pretty", "print", "ou"]}}
{"id1": "20091126", "id2": "20019847", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copy": ["delete", " Copy", "system", "download", "Cop", "file", "io", "transfer", "map", "call", "Transfer", "sync", "save", "y", "store", "create", "move", "load", "write", "clone", "open", "paste", "get", "to", "Copy", "cat", "cp", "upload"], "in": ["inn", "inc", "up", "init", "ain", "inner", "isin", "old", "ini", "r", "din", "info", "mm", "file", "ck", "b", "source", "i", "io", "gin", "id", "from", "In", "el", "ins", " input", "en", "IN", "l", "n", " din", "input", "rin", "cin", "inf", "ind"], "out": ["msg", "ch", " os", "p", "it", "x", "Out", "bytes", "ex", "v", "nt", "w", "e", "file", "b", "log", "err", "io", "channel", "tmp", "one", "gt", " output", "result", " it", "c", "res", "_", "ot", "y", "or", "t", "at", "o", "l", "write", "output", "os", "null", "to", "s", "end", "co", "outs", "OUT", "self", "net", "as", "n", "ou"], "inChannel": ["binCommand", "Inchannel", "insideSection", "innchannel", " inConnection", "insideRow", "inBlock", "conChannel", "inCommand", " inBlock", "cinchannel", " inSection", "InChannel", "inSection", "outCommand", "inListener", "conChan", "binSection", " inRow", "binChannel", "outBlock", "ginChannel", "ginChuck", "outchannel", " inCommand", "cinCommand", "INChannel", "innConnection", "InConnection", "incChain", "incChuck", "inchannel", "insideCommand", "inChuck", "cinChannel", "inConnection", "incPanel", "ginPanel", "innChannel", " inListener", "binRow", " inChan", "binChain", "INConnection", "incChannel", "INListener", "innChan", "ginChain", "inChain", "inPanel", "binPanel", "inRow", "InChan", "binChuck", "conListener", "INChan", "conConnection", "inChan", " inchannel", "cinBlock", "insideChannel"], "outChannel": ["cosChannel", "outputPassword", " outMany", " outChan", "outCh", "skyGate", "OutChan", "OutChannel", "outManager", " outCh", "outMany", "moduleManager", "OUTUser", "moduleChannel", " outGate", "outputChan", "skyMany", "cmdGate", "Outchannel", "cosUser", "OUTChannel", "cosChan", "outSlot", "cosSlot", "OUTSlot", "inSlot", "outGate", "outchannel", "inUser", "outPassword", " outchannel", "outChan", "OutCh", "outUser", "skyChannel", "outputChannel", "inchannel", "OUTChan", "moduleChan", "modulePassword", "cmdChannel", " outManager", "inCh", "outputManager", "cmdMany", "skyChan", "cmdChan", "inChan", " outPassword"]}}
{"id1": "3024970", "id2": "20619879", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamToOutputFile", "testCopy_inputStreamtoInputstream", "testCopy_inputStreamtoInputSteam", "testCopy_inputStreamtoOutputSteam", "testCopy_inputStreamTooutputSteam", "testCopy_inputStreamTooutputFile", "testCopy_inputStreamtoOutputstream", "testCopy_inputStreamToInputstream", "testCopy_inputStreamToInputSteam", "testCopy_inputStreamTooutputstream", "testCopy_inputStreamToOutputSteam", "testCopy_inputStreamtoInputFile", "testCopy_inputStreamToInputStream", "testCopy_inputStreamtoOutputStream", "testCopy_inputStreamTooutputStream", "testCopy_inputStreamtoOutputFile", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamToInputFile", "testCopy_inputStreamtoInputStream"], "in": ["inn", "scan", "im", "al", "up", "init", "p", "is", "it", "ac", "ain", "mi", "inv", "sin", "inner", "xml", "this", "isin", "ini", "r", "din", "copy", "mm", "source", "log", "bin", "i", "h", "nin", "read", "io", "gin", "on", "c", "from", "In", "q", "el", "sql", "ic", "ins", "inside", "en", "IN", "doc", "l", "con", "iter", "ai", "n", " din", "input", "cin", "rin", "mc", "inf", "ind"], "baout": [" bain", "oaOut", "abaOut", "BaOut", "kain", "caOut", " baot", "kaOut", "baOut", "BAOut", "Balog", "BAin", " baOut", "calog", "baend", "boio", "baot", "abaot", "boout", "abaout", "balog", "abain", "kaend", "caio", " baend", "oaio", "kaout", " baouts", "boin", "Baouts", "bain", "BAot", "BAout", "baio", "Baout", "baouts", "oain", "cain", "caouts", "caout", " balog", "boOut", "caend", "oaout"], "out": ["obj", "up", "it", " Out", "Out", "g", "ex", "copy", "aos", "cmd", "all", "b", "sys", "log", "io", "serv", "conv", "gt", "res", "sum", "ot", "set", "check", "t", "at", "o", "OU", "output", "gr", "client", "con", "null", "to", "oss", "list", "co", "outs", "OUT", "net", "n", "ou"], "count": ["counter", "amount", "resp", "nt", "current", "nb", "number", "start", "read", "ount", "id", "num", "c", "sum", "ctr", "code", "length", "total", "Count", "skip", "z", "size", "N", "found", "ct", "index"]}}
{"id1": "3558512", "id2": "8625346", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"serialize": ["serialate", "serialized", "Serializer", "erialate", "erializer", "finalized", "initialization", "serializer", "erialized", "finalization", "finalize", "erialize", "Serialze", "finalze", "Serialate", "serialze", " serialate", "serialization", "Serialization", "initialize", " serialized", "initialze", "initialized", "Serialized", " serializer", "Serialize"], "out": ["up", "ch", "p", "it", "Out", "pool", "stream", "v", "a", "w", "aos", "file", "b", "log", "err", "i", "io", "serv", " OUT", "result", "f", "sw", "c", "res", "report", "sum", "t", "o", "d", "OU", "output", "os", "to", "outs", "OUT", "n", "ou"], "parser": ["aser", "util", "rer", "magic", "writer", "p", "per", "now", "part", "inner", "xml", "loader", "job", "tp", "layer", "file", "ker", "Parser", "ger", "walker", "builder", "jack", "parse", "manager", "bank", "plan", "processor", "password", "arser", "base", "handler", "lp", "worker", "peer", "command", "instance", "tar", "asser", "language", "er", "proc", "pkg", "policy", "tree", "ler", "token", "reader", "style", "format"], "on_disk": ["on_link", "On2disk", "on_Disk", "on2Disk", " on_disc", "on_download", "On2link", "On_file", "On_Disk", " on_Disk", "on_volume", "On_cloud", "on_file", "On_link", "On2Disk", " on_volume", "on2link", " on_download", "on_dis", "On_disk", "on_disc", "on2file", " on_file", "on_cloud", "On2file", "on2disk", " on_dis"], "in": ["inn", "inc", "mi", "is", "it", "ain", "and", "sin", "inner", "isin", "r", "din", "min", "bin", "i", "io", "gin", "ad", "on", "id", "from", "In", "body", "ins", "inside", "en", "IN", " din", "input", "cin", "rin", " IN", "vin", "inf", "ind"]}}
{"id1": "12055086", "id2": "16557837", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copydeleving", " copyDeleging", " copyDelingting", " copydeletging", " copyDeleving", " copyDeletving", " copyDeletging", " copyDeeleing", " copydeletving", " copyDeleing", " copyDeeleving", " copyDeletting", " copydeletting", " copydeleging", " copyDelingging", " copydeleing", " copyDelinging", " copydeleting", " copyDeeleging", " copyDelingving", " copyDeeleting"], "source": ["Source", "ace", "origin", "parent", "init", "image", "back", "ource", "scope", "src", "se", "sample", "original", "target", "query", "start", "resource", "local", "template", "base", "from", "search", "site", "form", "sql", "body", "store", "service", "spec", "seed", "oss", "input", "ce", "sp", "SOURCE", "style"], "dest": ["port", "origin", "est", "orig", "nom", "del", "cas", "exp", "Dest", "it", "master", "src", "target", "w", "mm", "temp", "lit", "bin", "comb", "way", "pas", "st", "img", "https", "loc", "them", "d", "dir", "null", "end", "dist", "pub", "trans", "tom", "th", "sp", "cat", "rest", "decl"], "buf": ["cap", "alph", "cv", "bc", "tx", "bus", "bs", "cb", "bh", "bl", "seq", "cmd", "b", "buffer", "comb", "prop", "meg", "uf", "Buffer", "data", "conv", "capt", "box", "tab", "batch", "eb", "arr", "br", "fg", "pause", "str", "bag", "cur", "Buff", "cast", "buff", "img", "ref", "pkg", "vec", "db", "cf", "block", "rb", "cat", "fb", "aka", "bytes", "cp"], "in": ["inn", "al", "inc", "ri", "init", "is", "per", "it", "inner", "isin", "ini", "din", "info", "mm", "ze", "bin", "i", "read", "gin", "user", "on", "from", "In", "el", "or", "ic", "inside", "ins", "en", "IN", "by", "un", "con", "iter", "ai", "input", "rin", "cin", "inf", "ind"], "out": ["auto", "obj", "up", "conn", "writer", "Out", "inner", "v", "nt", "aos", "flush", "outer", "dis", "sys", "ion", "i", "log", "io", "conv", "on", "res", "sum", "page", "cn", "t", "en", "at", "o", "ne", "by", "write", "output", "client", "con", "os", "to", "oss", "end", "co", "outs", "OUT", "net", "can", "n", "ou"], "count": ["deep", "cap", "counter", "len", "ch", "amount", "span", "now", "char", "cc", "cloud", "nt", "add", "current", "index", "max", "acc", "nb", "number", "start", "read", "ount", "num", "comment", "c", "batch", "cont", "coll", "q", "sum", "ctr", "cond", "conf", "check", "code", "t", "length", "total", "common", "Count", "core", "z", "size", "found", "ct", "n", "ind"]}}
{"id1": "5061606", "id2": "3958807", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNecessesed", "createSettingsIfNecessesar", "createSettingsIfNeccessed", "createSettingsIfNeccesar", "createSettingsIfNacessible", "createSettingsIfNecessar", "createSettingsIfNacessary", "createSettingsIfNeccessible", "createSettingsIfNecessed", "createSettingsIfNecessesary", "createSettingsIfNacessesar", "createSettingsIfNeccesary", "createSettingsIfNeccessar", "createSettingsIfNacessesed", "createSettingsIfNecessible", "createSettingsIfNacessed", "createSettingsIfNeccesible", "createSettingsIfNacessesible", "createSettingsIfNacessar", "createSettingsIfNeccesed", "createSettingsIfNecessesible", "createSettingsIfNacessesary", "createSettingsIfNeccessary"], "out": ["timeout", "obj", "up", "server", "conn", "go", "ch", "init", "yes", "writer", "it", "Out", "cho", "inv", "ex", "nt", "flush", "oe", "outer", "w", "aos", "ent", "max", "file", "gc", "cos", "ion", "log", "err", "sys", "io", "one", "that", "conv", "on", "exit", "f", "comment", "ou", "again", "res", "report", "ot", "or", "t", "bo", "o", "ne", "OU", "write", "output", "client", "con", "null", "os", "to", "oss", "end", "co", "list", "outs", "OUT", "net", "print", "note", "can", "n", "off", "cn"], "fSettings": ["fsettings", "cfSetting", "bfsettings", "cfSettings", "fOptions", "bfSettings", "cfSetup", "finalsettings", "bfChanges", " fOptions", " fSetting", "sfsettings", "fSetup", "hSettings", "sfOptions", "cfsettings", " fChanges", "fChanges", "eSettings", " fsettings", "sfSetup", "eSetting", "sfSettings", "finalSetting", "finalOptions", "sfChanges", "finalSettings", " fSetup", "esettings", "sfSetting", "hsettings", "hSetting", "bfSetting", "fSetting"], "src": ["url", "ls", "view", "attr", "sq", "rs", "dest", "fn", "sr", "sb", "rx", "syn", "config", "source", "sys", "filename", "sit", "resource", "tmp", "root", "txt", "cont", "rl", "cur", "ser", "img", "sf", "spec", "loc", "rel", "pkg", "sc", "ur", "dir", "rc", "th", "rt", "desc", "upload"], "in": ["inn", "ln", "init", "is", "and", "sin", "inner", "isin", "r", "din", "info", "source", "bin", "i", "gin", "ad", "id", "from", "In", "ins", "inside", "en", "IN", "l", "iter", "n", " din", "input", "rin", "cin", "vin", "inf"]}}
{"id1": "5551393", "id2": "8047989", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMD2", "getSHA5", " getMD4", "getmd3", " getMD3", " getMD2", "getSHA2", "getMD4", "getSHA3", "getSHA4", "getmd5", "getmd2", "getmd4", "getMD3"], "source": ["Source", "name", "url", "sequence", "image", "string", "now", "ource", "src", "message", "sample", "subject", "target", "content", "value", "file", "config", "start", "filename", "resource", "context", "reason", "data", "template", "base", "from", "force", "space", "site", "body", "object", "text", "spec", "seed", "output", "s", "input", "SOURCE", "style"], "tmp": ["msg", "obj", "cache", "rup", "pp", "cv", "p", "cmp", "attr", "resp", "cb", "src", "nt", "foo", "temp", "managed", "perm", "tn", "tt", "etc", "np", "snap", "Temp", "bb", "buf", "data", "result", "txt", "qq", "m", "cont", "po", "tar", "mp", "gb", "lambda", "mobi", "img", "bag", "t", "buff", "out", "jp", "test", "pkg", " mp", "db", "output", "bt", "nd", "input", "sp", "found", "mk", "aaa", "cp", "MP"], "md": ["sm", "amd", " MD", "and", "mt", "wd", "cd", "mb", "MD", "nt", "dm", "dh", "mm", "der", "od", "cmd", "mac", "hd", "ind", "bd", "de", "sd", "mod", "ad", "di", "sam", "ld", "m", "det", "pdf", " Md", "pm", "mp", "rm", "ms", "red", "desc", "mn", "d", "nd", "mand", "dd", "td", "dr", "mk", "df", "pd"]}}
{"id1": "19810820", "id2": "10795866", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyBytechannel", " copyFilesChannel", "copyFilechannel", " copyFileStream", " copyStreamChannel", " copyByteStream", " copyBytechannel", "copyByteFile", " copyFilechannel", " copyFilesFile", " copyStreamchannel", " copyStreamFile", " copyByteFile", "copyFileStream", " copyFilesStream", "copyFileFile", "copyByteChannel", "copyByteStream", " copyByteChannel", " copyFileschannel", " copyFileFile", " copyStreamStream"], "src": ["Source", "sec", "ls", "obs", "init", "inst", "sq", "bs", "rs", "dest", "sr", "sb", "rx", "syn", "source", "start", "sys", "filename", "SourceFile", "tmp", "RC", "txt", "usc", "sync", "from", "cont", "sl", "ctr", "rl", "st", "in", "cur", "ser", "ins", "sf", "img", "loc", "usr", "rel", "sc", "req", "rc", "s", "input", "js", "rt", "SOURCE"], "dst": [" dnd", "Ddest", "ddest", " dist", "jest", "Dth", "Dut", "Dest", "bist", "sest", "sth", "dest", "dth", "dnd", "best", " dth", "jut", "sst", "sut", "Dnd", "snd", "dut", " ddest", "jdest", "bdest", "jst", "bst", " dest", "sdest", "Dist", "dist", "Dst"], "preserveModificationTime": ["preserveQualificationsTime", "preserveModificationsTim", "preserveModifyPoint", "preserveModificationsTime", "preserveModifiedTime", "preserveModifierTimes", "preserveModificationTim", "preserveModifyTimes", "preserveModificationPoint", "preserveSpecificationTim", "preserveModificationsLength", "preserveModifyingLength", "preserveModifyingPoint", "preserveSpecificationTimes", "preserveSpecificationsTime", "preserveModificationLength", "preserveModifiedTimes", "preserveModifyTime", "preserveModifiedTim", "preserveSpecificationTime", "preserveQualificationsPoint", "preserveQualificationTime", "preserveModifierTim", "preserveQualificationsTimes", "preserveModificationsPoint", "preserveModifierTime", "preserveQualificationLength", "preserveQualificationsLength", "preserveSpecificationsTimes", "preserveModificationTimes", "preserveSpecificationsTim", "preserveModificationsTimes", "preserveModifyingTimes", "preserveModifyLength", "preserveQualificationPoint", "preserveModifyingTime", "preserveQualificationTimes"], "inputChannel": ["outputChuck", "innerChannel", "clientConnection", "inputCategory", "innerStream", "innerchannel", "clientChan", "infoChuck", "openConnection", "outputchannel", "inputBuffer", "outputStream", "outputChan", "inputListener", " inputConnection", "interfaceChannel", "inputChuck", "InputChan", " inputBuffer", "infoChannel", "innerChan", "inputStream", "InputStream", "outputBuffer", " inputGray", "inputChan", "evalChannel", " inputListener", " inputCategory", "openChannel", "entityChan", "interfaceListener", "hiddenChannel", "clientGray", " inputChuck", "entityChannel", "InputBuffer", "hiddenListener", "inputchannel", " inputStream", "inputConnection", "openGray", "openChan", "infoChan", "hiddenCategory", "infochannel", "interfaceCategory", " inputChan", "clientChannel", " inputchannel", "inputGray", "Inputchannel", "evalChan", "InputChannel"], "outputChannel": [" outputConnection", "coinChannel", "writeChannel", " outputButton", "displayButton", "writeChan", "putchannel", "outputchannel", " outputManager", "Outputchannel", "outputStream", "outputChan", "writeStream", "putChan", "writechannel", "writeManager", " outputchannel", "OutputStream", "putButton", "doubleChannel", "inputChan", " outputStream", "displayChan", "putChannel", "outputConnection", "coinInstance", "coinField", "doubleField", "inputManager", "webchannel", "inputConnection", "doubleChan", "OutputChan", "webChannel", " outputChan", "webManager", "outputButton", "coinChan", "inputField", "OutputChannel", "OutputConnection", "outputManager", "doubleInstance", "displaychannel", "displayChannel", "outputInstance", "outputField", "inputInstance", "OutputManager"], "length": ["volume", "then", "sequence", "len", "offset", "amount", "shape", "required", "full", "height", "present", "capacity", "max", "partial", "number", "json", "value", "all", "buffer", "start", "limit", "join", "ENGTH", "data", "padding", "available", "library", "ength", "base", "type", "needed", "time", "HH", "left", "details", "text", "load", "history", "loop", "duration", "l", "component", "term", "family", "expected", "count", "to", "position", "width", "list", "end", "size", "Length", "bytes"], "total": ["free", "sequence", "active", "offset", "amount", "full", "required", "equal", "created", "unique", "this", "description", "current", "info", "title", "max", "unknown", "last", "number", "all", "quant", "local", "less", "bar", "checked", "zero", "translation", "available", "num", "successful", "complete", "base", "done", "otal", "sum", "valid", "meta", "scale", "good", "ta", "t", "summary", "eta", "no", "count", "to", "stable", " Total", "size", "Total", "note", "used", "index", "raw", "human"]}}
{"id1": "20920051", "id2": "10795866", "code1": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"copyTo": ["copyPhoto", "copyOver", "opyTo", "opyOver", "copyFrom", "transferFiles", " copyDir", "CopyFile", "transferTo", "opyPhoto", "CopyTo", "moveDir", " copyFiles", " copyFile", " copyPhoto", "CopyFrom", "movePhoto", "copyDir", "opyDir", "transferFrom", " copyOver", " copyFrom", "transferFile", "CopyFiles", "moveOver", "copyFile", "moveTo", "copyFiles"], "source": ["scan", "origin", "sin", "src", "old", "subject", "sort", "secure", "from", "store", "sf", "spec", "iter", "input", "Source", "name", "unit", "ace", "part", "ource", "original", "sample", "config", "start", "resource", "sql", "details", "flat", "component", "oss", "size", "SOURCE", "style", "use", "raw", "none", "shell", "select", "scope", "se", "target", "query", "template", "id", "base", "search", "site", "seed", "null", "ie", "sp", "missing", "parent", "init", "image", "pse", "entry", "copy", "file", "local", "sl", "visible", "status", "service", "get", "s", "empty", "note"], "dest": ["port", "name", "origin", "est", "orig", "nom", "del", "path", "parent", "Dest", "it", "this", "master", "src", "nt", "target", "w", "deg", "pro", "folder", "opt", "tmp", "dat", "dev", "result", "txt", "good", "st", "desc", "out", "ref", "dc", "test", "loc", "d", "des", "doc", "dir", "null", "to", "end", "dist", "trans", "tom", "self", "rest"], "temp": ["zip", "tem", "mk", "pl", "orig", "path", "por", "EMP", "p", "parent", "mm", "w", "make", "alt", "buffer", "unt", "tmp", "Temp", "dat", "mod", " Temp", "template", "local", "rem", " temporary", "tab", "txt", "fake", "stem", "tar", "mp", "rm", "porary", "t", "out", "test", "Tem", "null", "pt", " tmp", "em", "tm", "empty", "mt", "emp", "cp"], "sel": ["zh", "nav", "ele", "pl", "le", "del", "select", "cel", "se", " sl", "cl", "kel", "syn", "so", "ael", "sil", "fol", "selection", "kl", "sv", "Sel", " lic", "sl", "el", "nl", "cell", "rol", "lf", "rl", "mil", "nel", "sol", "El", "ser", "fl", "lv", "elect", "sels", "Se", "sc", "sen", "ml", "ial", "ls", "selected"], "tempDest": [" temporaryNeg", " tempdest", "mmDest", "mmDec", "mmLoc", "tempDe", "ptTemp", "porarydest", "temDir", "tempLoc", "tempdest", "ptDest", "tempDec", "poraryTemp", " tempNeg", "destTemp", "poraryDir", " temporaryDest", "tempNeg", " tempDir", "temDest", "ptNeg", "poraryDest", "temDe", " tempTemp", "mmTemp", "poraryDec", "poraryLoc", "destDest", " temporarydest", "ptdest", " tempDe", "destLoc", "tempTemp", "tempDir", " temporaryTemp", "temdest", "poraryDe", "destDec"], "sourceCh": ["srcCor", "seedCol", " sourceCor", "ourceComp", "ourceCh", "sourceCor", "startCol", "sourcech", "ourceCH", "seedCh", "srcch", "sourceCH", "sourceComp", "ourceCol", "srcCh", "ourceColl", " sourceComp", "statusCh", "srcComp", " sourceCH", "srcCol", "sourceCr", "seedChan", "ourceChan", "statusCr", "srcCH", "samplech", "startCh", "startCH", "statusCol", "sourceCol", "sourceChan", "sampleComp", "sampleCh", " sourcech", "sampleCor", "srcChan", "seedColl", "ourceCr", "srcColl", "sourceColl", " sourceCr", "statusCH", "startComp", " sourceCol"], "destCh": ["destChan", "tempChan", "restCol", " destCol", "targetC", "usrChar", "tempCol", "tempCl", "targetChan", "restChan", "destCol", "estC", "destChar", "usrChan", "usrCh", "destC", "restCh", "estCh", "tempC", "estCl", "destDest", "targetCh", " destC", " destChan", "usrC", " destCl", "targetChar", " destDest", "tempCh", "estDest", " destChar", "restC", "destCl"]}}
{"id1": "21531069", "id2": "8754809", "code1": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 0, "substitutes": {"updateuser": ["updateusername", " updateusername", "setusername", " updateusers", "UPDATEusers", "setusers", "setuser", "updateusers", "updateaccount", " updateaccount", "UPDATEuser", "UPDATEaccount", "UPDATEusername", "setaccount"], "u": ["util", "tu", "ue", "up", "U", "su", "uj", "you", "ui", "ul", "ru", "ut", "iu", "uv", "ju", "b", "uid", "gu", "uf", "pu", "user", "lu", "c", "bu", "hu", "ux", "mu", "du", "fu", "eu", "cu", "us", "nu", "au", "bo", "out", "o", "un", "ud", "ur", "uni", "uu", "ou"], "i": ["im", "bi", "ri", "oi", "p", "is", "it", "x", "mi", "phi", "gi", "si", "v", "ini", "hi", "r", "index", " Ai", " j", "e", "cli", "iu", " bi", "ti", "ci", " im", "j", "di", "xi", "f", " iT", "m", "c", "fi", " I", "y", "ei", "ic", "in", "qi", "t", "ki", "o", "l", "iri", "ai", "I", "iat", " n", "pi", "iti", "n", "ii", "li"], "conn": ["port", "obj", "p", " core", "enc", "cmd", "tn", "dat", "win", "cont", "conf", "cell", " connection", "cur", "bo", "ctx", "Con", "pt", "req", "ca", " cur", "Connection", " con", " cs", "yn", " comm", "org", "cb", "cc", "pool", " ac", "iw", " mc", " cc", "con", "connection", "nec", "net", "att", "addr", "tp", "cn", "ln", "cert", " ex", "resp", "comm", "nt", "cl", " net", "ont", "conv", " ce", "c", " ch", "pas", "nc", "gate", " cont", "pkg", "db", "cm", "dial", "co", "js", "sp", "ct", "gn", "ch", "socket", "ns", "connect", "pg", " cx", "close", "j", "po", " c", "en", "loc", " pc", "jp", "open", "client", "wp", "ann", "Conn", "ht", "n", "cp"], "pm": ["arm", "pc", "pl", "pp", "p", "nm", "am", "pse", "pn", "lem", "mi", "pool", "fm", "ps", "ym", "mm", "mmm", "perm", "py", "vp", "gm", "ph", "om", "dem", "rem", "esm", "pa", "pol", "rpm", "m", "lp", "po", "mx", "mp", "rm", "md", "ms", "hm", "asm", "bm", "pr", "jp", "pb", "cm", "pkg", "term", "wp", "pt", "mr", "em", "tm", "px", "js", "ams", "vm", "pi", "mt", "mk", " mp", "cp", "pd", "PM"]}}
{"id1": "23672408", "id2": "536614", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyIconFiles": [" copyIconImages", " copyiconFiles", " copyiconDocuments", "copyIconfiles", " copyIconDocuments", "copyiconDocuments", "copyIndexImages", "copyiconFiles", "copyiconImages", " copyIconfiles", "copyIndexDocuments", " copyiconImages", " copyiconfiles", "copyIndexfiles", "copyIndexFiles", "copyIconImages", "copyiconfiles", "copyIconDocuments"], "clazz": ["crus", "relazz", "clbo", " clbean", "escojure", "callace", "classazz", "plaz", " classe", "classotted", " claz", "descab", "clashed", "escazz", "escace", "descose", "clace", " clotted", " cluster", "classuddy", "clab", "CLace", "classe", "descazz", "chojure", " plub", " cluddy", "descaz", "clbean", "colluddy", " clbo", " club", "cluster", "callazz", "relaz", "pkgasse", "scloser", "sclazz", "sclbean", " clace", "pkgashed", "club", "sclace", "pkgazz", "clus", "Clbo", "craz", "relab", "crub", "plazz", "plasse", "clotted", "callaz", "Clab", "chazz", "CLbean", "closer", "collotted", "claz", "Clazz", "callbo", "CLazz", "Close", "Claz", "pkgaz", "cluddy", " clojure", " plus", " clashed", "plashed", " plazz", " closer", "relose", "chace", " clus", "Clace", "close", "escotted", "collazz", " plaz", "classuster", "clojure", "CLoser", "crazz", "colluster", "chotted"], "i16": ["ri16", "pi150", "ii24", "i6", "ami150", "ami19", " i160", "iri6", "i24", "pi6", "ji6", "i216", "ji150", "ji63", "i150", "ami63", " i2016", "pi63", "ini19", "pi16", " i157", "i157", "ini2016", " i6", "ini160", "iniShort", "li16", "ini216", "i63", "ii16", "iri16", "ami2016", "iri2016", " i216", "ami6", "iri157", "ri2016", "amiShort", "ini16", "ji16", "ii216", "liShort", "ri6", "li2016", "ami16", "li19", "ri157", " i24", "i2016", "iShort", "i19", "i160", "ii160", "ini24"], "fileType": ["fileValue", " fileTyp", " fileList", "relationType", "resourceUnit", "fileFamily", "FileName", "resourceFormat", "fieldType", "fileTYPE", " filetype", "coreType", "fieldDef", "fileTyp", "treeTime", "resourceTYPE", "policyHandler", "issuePattern", "webDef", "issueType", "policyFamily", "eventUnit", "policyTyp", "webTyp", "formattype", "ileType", " fileValue", "fileName", "fileDef", "formatType", "relationTyp", "ilePattern", " fileFormat", "FILEType", "eventTYPE", "treeType", "viewTYPE", "fileHandler", "webList", "fieldTYPE", "filetype", "FILEtype", "formName", "formatTYPE", "webType", "formType", "treetype", "Filetype", "fileList", "issuetype", " fileTYPE", "eventList", "eventType", "relationFamily", " fileTime", "coreFamily", "formatTime", "policyType", "formtype", "ileTyp", "fileUnit", " fileUnit", "issueTyp", "viewtype", "formatValue", "coreDef", "filePattern", "coreTYPE", "viewType", "coreHandler", "coreTyp", "FILEName", "treeTYPE", "fileTime", " filePattern", "viewValue", "resourceType", "webTYPE", "eventFormat", "relationHandler", "fieldTyp", "FileType", "fileFormat", "iletype"], "desti16": ["destsi160", "destgi2016", "desti24", "resultii24", "destui24", " destsi160", "destii2016", "resulti2016", "destgi16", " destsi18", " desti18", " destsi16", "desti216", " destsi32", "destxi16", "destii16", "resulti216", "desti18", "destui160", "destui16", "destii24", "desti160", "destsi32", "destui18", "destgi24", "resulti16", "desti2016", "resultii216", " desti160", "destsi18", "destsi16", "resultii2016", "destxi160", "destii216", "destui2016", "destgi216", "destxi32", "destui32", "destui216", "resultii16", "resulti24", "destxi18"], "src": ["scan", "hl", "sec", "obs", "bg", "comp", "ln", "inst", "sq", "cmp", "bc", "addr", "cb", "inner", "rs", "dest", "bh", "via", "sr", "sb", "rx", "cli", "syn", "sel", "source", "sys", "bin", "etc", "sit", "ssl", "gs", "tmp", "ptr", "fc", "sync", "txt", "cont", "std", "nl", "sl", "ctr", "vr", "rl", "st", "rob", "sol", "ser", "isl", "cur", "ins", "ibl", "urg", "img", "loc", "rg", "rel", "usr", "pkg", "sn", "proc", "ctx", "sc", "iter", "req", "rc", "sub", "rb", "input", "sp", "ls", "desc", "rest", "iv"], "dst": [" dnd", "dnet", "Ddest", "ddest", "dsot", "ddst", "tgt", "dsest", "dput", " dput", " dgt", "dmt", "rdsts", " dsts", "rst", "nst", " dmt", "dsst", "ndest", "rcut", "tput", "ndst", "dLbl", "rbl", "dest", "nput", "ddr", "derst", "rdst", "dnd", "fnd", " dot", "ndsts", "dsnet", "Ddr", "dmn", " dmn", "dddest", "dcut", "ddmn", "dsts", "dLest", "nnd", "Dnd", "ngt", "tnd", "dLdest", " dnet", "dgt", " dbl", "dLcut", "dbl", " ddr", "rdest", " ddest", "dot", "tst", "fdest", "dLst", "derdest", "ndmt", " dest", "dermn", "fst", "ddnd", "rdmt", " dcut", "Dst", "dernd", "fdr", "dLnet", "dLot"], "i32": ["i342", "ic32", " i342", "ic342", "ini22", "i34", "ii342", "ii34", "ini31", " i86", "isi86", "pi64", "pi34", " i31", " i34", "ini48", "isi64", "ic31", "ii28", " i40", "ic48", "xi31", "ic86", "ic22", "isi40", "i40", " i28", "ip32", "pi32", "ip34", "i86", "ip64", "xi48", "xi32", "i64", "i28", "isi32", "ic40", "ini32", " i64", "ic28", "ic34", "ii32", "ic64", "xi22", "ip31", "i48", "i31", "i22", "pi31"], "desti32": ["DestI256", "destI256", "Desti90", "destdi34", "Desti31", "targeti31", "destI90", "destu256", "targetpi30", "destu90", "desti30", "targetpi31", "destu31", "DestI90", "destI32", "Desti256", "Desti32", "desti31", "destic34", "destic32", "targetpi34", "destpi30", "targetpi32", "destdi32", "destpi31", "desti90", "targeti34", "destdi30", "targeti30", "destic31", "destI31", "destic30", "destu32", "DestI31", "destdi31", "destpi32", "desti256", "desti34", "DestI32", "destpi34", "targeti32"]}}
{"id1": "13414771", "id2": "17158020", "code1": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"encriptPassword": [" descryptField", "EnribePassword", " descryptAuth", " desribePassword", " desribeAuth", " descryptPassword", "EncriptAuth", " desizeAuth", " desribeField", " descriptAuth", "EnribeAuth", " desizeKey", " descriptField", "EncriptField", " desribeKey", "EnribeField", "EnribeKey", " descriptKey", " desizePassword", " descriptPassword", "EncriptPassword", " desizeField", " descryptKey", "EncriptKey"], "passwd": ["passw", "defword", "mailw", " password", "assphrase", "psword", "pasw", "assword", "mailword", "mailphrase", "mailwd", "defw", "pwd", "paswd", "password", " passsword", "passsword", "pw", "passphrase", " passw", "pword", "defphrase", "pasword", "asswd", "assw", "defwd"], "md": ["mail", "sm", " MD", "and", "mt", "cd", "mb", "MD", "add", "nt", "dm", "dh", "ds", "mm", "mo", "der", "od", "cmd", "managed", "hd", "ind", "bd", "sd", "mod", "di", "ld", "m", "pdf", "down", "pm", "rm", "ms", "red", "desc", "mask", "mg", "hm", "mn", "at", "d", "ma", "dd", "td", "mc", "dr", "mk", "df", "pd"], "hash": ["cache", "ashed", "key", "uh", "sq", "ssh", "sh", "bh", "message", "sample", "mac", "h", "her", "ash", "checked", "password", "hed", "mass", "Hash", "ah", "sum", "check", "mask", "proof", "rh", "trust", "shadow", "kernel", "hex", "score", "filter", "hidden", "has", "oh", "hd", "sha"]}}
{"id1": "17791385", "id2": "9846843", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"copyFile": ["clonefile", " cpfile", "copyResource", " cpFile", " copyResource", "cloneResource", " cpFiles", "copyFiles", "copyfile", " copyFiles", " cpResource", " copyfile", "cloneFiles", "cloneFile"], "src": ["Source", "sec", "obs", "init", "inst", "sq", "bs", "sin", "rs", "via", "sr", "sb", "rx", "ck", "sel", "source", "start", "sys", "ys", "sit", "ipl", "txt", "usc", "from", "cont", "ctr", "ux", "rl", "st", "sur", "cur", "ins", "sf", "ser", "usr", "rel", "sc", "req", "rc", "input", "iv"], "dst": [" dnd", "Ddest", "ddest", "ddst", "Dth", "dnt", "dth", "dnd", " dth", "sst", "wdest", "dddest", "Dnt", "wst", "Dnd", "snd", "wth", "ddnt", " ddest", "sdest", "snt", "ddnd", "wnd", "Dst"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "is", "it", "ain", "act", "sin", "inner", "rec", "isin", "din", "info", "mm", "ze", "min", "source", "i", "bin", "gin", "on", "from", "In", "ic", "st", "inside", "ins", "en", "IN", "iter", "con", "ai", "input", "cin", "rin", "ar", "inf", "oin", "ind"], "out": ["auto", "obj", "up", "writer", "it", "and", "Out", "inner", "g", "ex", "nt", "oe", "outer", "aos", "dis", "sys", "bin", "io", "conv", "gt", "on", "ou", "res", "po", "sum", "ot", "st", "t", "at", "o", "ne", "by", "write", "output", "client", "os", "con", "to", "oss", "co", "outs", "OUT", "net", "can", "n", "cn"], "buf": ["msg", "cap", "pl", "cv", "tx", "bus", "cb", "bytes", "bh", "seq", "cmd", "ck", "b", "bed", "buffer", "log", "prop", "uf", "Buffer", "conv", "bar", "box", "gen", "tab", "batch", "arr", "cam", "mu", "good", "br", "cur", "bag", "Buff", "buff", "pkg", "vec", "db", "cf", "stab", "block", "norm", "cat", "fb", "aka", "var", "cp"], "len": ["cap", "elt", "ln", "le", "exp", "lim", "vol", "cmp", "lon", "v", "nt", "seq", "e", "pos", "all", "ren", "h", "fin", "L", "val", "fun", "ld", "num", "il", "dl", "coll", "el", "lf", "str", "fl", "t", "ll", "en", "lib", "no", "loc", "rel", "l", "length", "lan", "Len", "wid", "count", "lic", "end", "z", "compl", "size", "ls", "n"]}}
{"id1": "13783898", "id2": "2834524", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringAsDisk", "encodeStringAsStream", "encodeFileAsStream", "encodeFiletoDisk", "encodeStringAsFile", "encodeStringToStream", "encodeFileToFiles", "encodeStringToFiles", "encodeStringToDisk", "encodeStringAsFiles", "encodeFileAsFile", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileAsDisk", "encodeFiletoStream", "encodeFileFromFiles", "encodeFileAsFiles", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk", "encodeFileFromDisk", "encodeFileFromFile", "encodeFileToStream"], "infile": ["inFile", "outFile", "InFile", "inputfilename", "inbase", "Inbase", " inbase", " inFile", "infilename", "inpath", "Inpath", " inpath", "outbase", "Infile", "outfilename", "outpath", "inputfile", "inputpath", "inputFile", " infilename"], "outfile": ["inFile", " outname", "outFile", "infp", " outFile", "fromfile", "tofp", "newfilename", "todir", "outdir", "infilename", "toFile", "fromfp", "indir", "outname", "fromFile", "inname", "outfp", "outfilename", " outfilename", "newfile", "newFile", "fromdir", "newname", "tofile"], "in": ["inn", "im", "al", "inc", "up", "pin", "conn", "init", "image", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "gin", "on", "id", "from", "In", "form", "or", "amin", "ins", "inside", "t", "en", "IN", "ro", "by", "get", "iter", "con", " din", "cin", "rin", "input", "re", "ar", "inf", "oin", "ind"], "out": ["up", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "aos", "outer", "flush", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "null", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "character", "sequence", "cache", "view", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "bone", "variable", "pad", "buf", "black", "append", "Buffer", "template", "bar", "padding", "library", "available", "password", "button", "note", "batch", "base", "comment", "queue", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "length", "block", "row", "print", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "run", "connect", "allow", "through", "query", "start", "i", "push", "close", "give", "send", "wait", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "req", "count", "iter", "seek", "end", "skip", "input", "readable", "need", "n", "size", "print", "reader", "index", "ind", "Read"], "success": ["response", "town", " okay", "first", "same", "fail", "continue", "primary", "support", " successes", "commit", " successful", "positive", "growth", "photo", "safe", "value", "submit", " succ", "second", "snap", "Success", "city", "ccess", "successfully", "error", "warning", "ceed", "result", "successful", "complete", "setup", "done", "accept", "crit", "sufficient", "release", "democracy", "valid", "status", "good", "surv", "danger", "summary", " Success", "condition", "please", "ok", " failure", "unity", "ratulations", "cess", "ith"]}}
{"id1": "13720140", "id2": "23296117", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException {\n        String fullname = System.mapLibraryName(name);\n        String path = \"native/\" + sysName + \"/\" + fullname;\n        URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n        if (url == null) {\n            if (!warning) {\n                logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname });\n            }\n            return;\n        }\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        File targetFile = new File(getExtractionDir(), fullname);\n        OutputStream out = null;\n        try {\n            if (targetFile.exists()) {\n                long targetLastModified = targetFile.lastModified();\n                long sourceLastModified = conn.getLastModified();\n                if (targetLastModified + 1000 > sourceLastModified) {\n                    logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname);\n                    return;\n                }\n            }\n            out = new FileOutputStream(targetFile);\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n            in.close();\n            in = null;\n            out.close();\n            out = null;\n            targetFile.setLastModified(conn.getLastModified());\n        } catch (FileNotFoundException ex) {\n            if (ex.getMessage().contains(\"used by another process\")) {\n                return;\n            }\n            throw ex;\n        } finally {\n            if (load) {\n                System.load(targetFile.getAbsolutePath());\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n        logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile });\n    }\n", "label": 0, "substitutes": {"modifyProperty": ["modateProperty", "modifyProp", "ModifiesProp", "modateAttribute", "ModifyAttribute", "ModifiesAttribute", "modureValue", "ModifyProperty", "modifiesAttribute", "modureAttribute", "modateProp", "ModifiesProperty", "modureProperty", "ModifyValue", "ModifiesValue", "modateValue", "modureProp", "modifiesProp", "modifiesProperty", "ModifyProp", "modifyValue", "modifiesValue", "modifyAttribute"], "valueID": ["versionIDs", "versionId", "versionid", "propertyid", " valueid", " valueMD", "valueIDs", "valueid", " valueId", "versionUID", "VALUEId", " valueUID", "valueId", "VALUEMD", "propertyId", "valueUID", "propertyIDs", "VALUEID", "VALUEUID", "versionID", "valueMD", "propertyID", "versionMD", " valueIDs"], "value": ["attribute", "name", "key", "version", "string", "description", "v", "message", "current", "memory", "entry", "content", "expression", "label", "hello", "values", "update", "buffer", "variable", "function", "val", "data", "padding", "default", "password", "example", "Value", "application", "comment", "type", "save", "format", "vector", "instance", "text", "code", "address", "output", "get", "VALUE", "input", "field", "state"], "userID": ["UserURL", "usernameID", "UserType", "usernameName", "ownerName", "userName", "ownerID", "userId", " userName", "UserID", " userId", " userURL", "userURL", "usernameId", " userType", "usernameURL", "userType", "UserId", "ownerType", "UserName", "ownerId"], "property": ["attribute", "name", "option", "metadata", "key", "state", "claim", "p", "operator", "display", "this", "ty", "description", "message", "title", "expression", "associated", "label", "config", "second", "alias", "prop", "resource", "profile", "function", "data", "translation", "method", "media", "setup", "project", "type", "prototype", "command", "feature", "object", "Property", "prefix", "language", "item", "address", "relation", "module", "table", "policy", "term", "section", "position", "to", "license", "field", "print", "pair", "style", "pe", "properties"], "newValue": ["NEWValue", " newValues", "oldMessage", "Newvalue", "newMessage", "newValues", "newVersion", "newString", " newResult", "newName", " newVersion", "oldName", "oldResult", "uniqueValue", "oldVersion", "uniqueName", "newvalue", "NewString", "oldValue", " newName", " newvalue", "uniqueMessage", "NEWString", "oldValues", "oldvalue", "oldString", "NEWResult", "newResult", "NewValue", "NewValues", " newString", " newMessage", "NEWvalue", "uniqueVersion"], "crypt": ["bec", "sm", "roy", "cs", "ch", "go", "init", "cert", "magic", "cmp", "comm", "auth", "cc", "cot", "enc", "ocr", "nt", "mac", "dec", "cmd", "gc", "cos", "sys", "ssl", "cry", "col", "conv", "rem", "password", "Crypt", "arch", "sync", "cont", "coll", "ctr", "CR", "cook", "check", "hash", "prot", "coin", "mem", "code", "cy", "cur", "rh", "cm", "pt", "cr", "core", "dict", "reset", "rot", "hex", "trust", "ct", "cp", "rypt"], "digest": ["hexEST", " Digest", "mdested", "dEST", "Digest", "digestamp", "dester", "mdEST", "mdge", "dest", " digested", "Digester", " digestamp", " DigEST", "Digge", "digert", "Diggest", "diggest", "mdest", "hashest", "mdester", "digge", "digests", "mdgest", "Digestamp", "Digert", "digested", "hashge", " Digert", "hexest", "digEST", " Digester", " digEST", "hashgest", "DigEST", "digester", "hexert", "Digests", "mdestamp", "dested", "Digested", "hexester", "mdests", "hashests"], "hexString": ["hexBytes", "shortStr", "hashstring", " hexArray", "hexArray", " hexstring", " hexBuffer", "exArray", "exBytes", "formBytes", " hexBytes", "hashStr", "hexstring", "exString", "hashArray", "formBuffer", "exBuffer", "formStr", "shortstring", "formString", "hashString", "exstring", "shortString", "shortBuffer", " hexStr", "exStr", "hexStr", "hexBuffer"], "i": ["ix", "bi", "im", "ip", "init", "span", "is", "it", "x", "mi", "phi", "gi", "ui", "ji", "si", "v", "a", "ex", "ini", "info", "hi", "major", "u", "e", "cli", "\u0438", "number", "point", "gu", "io", "ci", "ti", "j", "multi", "di", "id", "m", "uri", "ii", "q", "y", "ic", "ei", "slice", "ms", "qi", "chain", "us", "ki", "o", "ai", "I", "ie", "pi", "sim", "index", "ind", "li"]}}
{"id1": "13122204", "id2": "5441579", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 0, "substitutes": {"unzipModel": ["unzipmodel", "unlateImage", "unarchiveModule", "Unzipmodel", "uncodeModule", "unarchiveModel", "UnzipImage", "UnzipModel", "UnzipModule", "uncodeModel", "unlatemodel", "uncodeImage", "UnarchiveModel", "UnarchiveModule", "unarchivemodel", "UnarchiveImage", "Unarchivemodel", "unarchiveImage", "unlateModel", "unzipImage", "unzipModule", "unlateModule", "uncodemodel"], "filename": ["fp", "name", "println", "FN", "origin", "path", "ln", "mson", "journal", "ivo", "nm", "jpg", "fn", "original", "ename", "subject", "title", "download", "nil", "file", "location", "source", "SourceFile", "fil", "til", "dra", "FILE", "kl", "txt", "FIL", "stem", "nl", "wl", "sql", "Filename", "fle", "output", "n", "river", "directory", "username"], "tempdir": ["testdir", "Tempdir", "tmppath", "tmpdir", "tmpDIR", "tempfolder", "Tempdirectory", "temdirectory", "temDir", " tempfile", "Tempfile", "tempath", "tmpDir", "TempDir", "testDir", " tempDir", "temppath", "testfolder", "tempfile", "temDIR", " tempdirectory", "tempDIR", " tempDIR", "tempdirectory", "tmpfile", "tempDir", "tmpfolder", "testpath", "temdir", "tmpdirectory", "temfolder"], "dest": ["port", "deep", "obj", "origin", "est", "parent", "nom", "del", "tr", "writer", "Dest", "inv", "display", "pipe", "master", "src", "stream", "nt", "target", "slave", "temp", "source", "pos", "buffer", "bin", "comb", "tmp", "dat", "ptr", "coord", "default", "dev", "result", "generated", "tail", "cont", "send", "sum", "peer", "ctr", "store", "st", "desc", "out", "loc", "foreign", "test", "usr", "des", "dc", "table", "output", "write", "null", "dist", "trans", "document", "rest", "decl"], "fis": ["ifatis", "zos", "li", "zatis", "fatis", "zjs", "flis", "zi", "ifis", "flos", "fljs", "fi", "fjs", "fli", "flatis", "los", "ifos", "ljs", "lis", "ifi"], "BUFFER": ["BAOUNT", "BUFR", "CUFR", "BABER", "BUULT", "BFFER", "BBER", "BLOUNT", "FFERMT", "MAXBuffer", " BUMT", "BUBER", "LOCKFR", "BUOUNT", "LOCKFFER", "BAULT", " BUULT", "BLFFER", "BOUNT", "BLBuffer", "BufferBER", "BLBER", "MAXFFER", "BufferFFER", "CUBER", " BUBER", "BUMT", " BUOUNT", "BAFFER", "BufferBuffer", " BUFR", "FFERBER", "CUBuffer", "FFERBuffer", " BUBuffer", "BUBuffer", "LOCKBuffer", "CUFFER", "MAXOUNT", "LOCKBER", "BULT", "MAXBER", "BufferMT", "FFERFFER"], "zis": ["zip", "xos", " zos", "Zi", "zos", "Ziss", "oziss", " zris", "fiss", "zoneis", "Zis", "zris", " zIS", "ziIS", " zes", "zeits", "zeos", "zIS", "ozi", "zits", "zi", "zes", "zios", "xi", "zeiss", "zeris", " ziss", "zeIS", "fi", "xis", " zi", "zoneris", "fip", "ozis", "zoneits", "ozip", " zip", "ziss", "zees", "zoneiss", "xiss", "Zos", "zeis", " zits", "ziis", "zies"], "entry": ["zip", "name", "link", "existent", "key", "enter", "header", "image", "system", "zo", "part", "char", "def", "se", "nt", "index", "escape", "je", "member", "e", "ent", "file", "jo", "source", "log", "inter", "Entry", "record", "match", "ry", "result", "comment", "way", "cell", "or", "card", "piece", "chain", "element", "item", "jar", "table", "word", "connection", "row", "ie", "ce", "ze", "pe"], "count": ["cache", "counter", "len", "child", "OUNT", "amount", "part", "cc", "cloud", "nt", "current", "add", "index", "max", "acc", "nb", "number", "all", "start", "buffer", "read", "ount", "match", "call", "num", "f", "comment", "c", "base", "batch", "force", "cont", "sum", "page", "cond", "cell", "ctr", "check", "code", "length", "total", "common", "Count", "core", "z", "ce", "size", "found", "ct", "n"], "data": ["cache", "image", "raw", "ata", "mat", "part", "p", "message", "sample", "content", "dec", "value", "all", "buffer", "dat", "results", "next", "zero", "result", "step", "batch", "dl", "done", "accept", "ATA", "valid", "str", "text", " DATA", "out", "rel", "d", "table", "output", "n", "DATA", "size", "window", "bytes", "area", "format"], "fos": [" foes", " fios", "fOS", "voes", "voses", "foes", "fios", "Foses", "lios", "foses", "foss", "Foss", " fOS", "Fios", "lOS", "loss", "FOS", "Fos", " foses", "los", "voss", "Foes", "vos", " foss"]}}
{"id1": "14877116", "id2": "14231545", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"cpFile": [" copBuffer", "pasteSingle", " cpSingle", " dupStream", " copSingle", " cpBuffer", " dupFile", " cpStream", "pasteFile", " copFile", "pasteBuffer", " dupSingle", " copStream", " dupBuffer", "pasteStream"], "source": ["scan", "origin", "stream", "old", "subject", "secure", "from", "form", "store", "in", "spec", "create", "input", "self", "Source", "name", "ace", "unit", "comp", "path", "ource", "before", "original", "sample", "current", "series", "config", "start", "resource", "scene", "sql", "component", "ce", "SOURCE", "style", "use", "remote", "attribute", "up", "none", "select", "shell", "find", "this", "dest", "scope", "se", "query", "template", "base", "search", "site", "peer", "null", "ie", "sp", "parent", "init", "image", "string", "char", "copy", "file", "local", "status", "service", "get", "format"], "target": ["port", "link", "origin", "master", "bolt", "mount", "tor", "buffer", "alias", "host", "that", "set", "range", "normal", "table", "tree", "theme", "path", " targ", "current", "point", "resource", "join", "top", "project", "type", "force", "style", "remote", "this", "dest", "scope", "arg", "localhost", "Target", "goal", "tmp", "arget", "template", "gt", "root", "dev", "base", " dst", "site", "peer", "test", "output", "null", "print", "primary", "window", "handle", "ARGET", "secondary", "parent", "it", " Target", "file", "update", "internal", "global", "build", "next", "local", "default", "t", "tif", "tool", "to", "transform", "format"], "replace": ["remote", "delete", "link", "hide", "use", "include", "first", " Replace", "apply", "find", "ignore", "display", "keep", "repl", "add", "fix", "copy", "repair", "repeat", "change", "update", "compatible", "join", "close", "append", "match", "record", "places", "save", "force", "search", "report", "only", "enable", "rm", "store", "prefix", "load", "insert", "write", "placed", "place", "share", "null", "remove", "inline", "register", "fill", "format"], "bufferSize": ["bufferStyle", "windowCount", "BufferSize", "blockCount", "bufferName", "blockSize", "blockStyle", " bufferStyle", "BufferCount", "BufferSIZE", "BufferStyle", "windowName", "bufferCount", "bufferSIZE", "BufferName", "windowSize", " bufferCount", " bufferName", "windowSIZE", "blockSIZE", " bufferSIZE"], "src": ["Source", "sec", "obj", "init", "inst", "sq", "sin", "rs", "dest", "stream", "copy", "sr", "sb", "rx", "syn", "sys", "bin", "secure", "tmp", "read", "conv", "RC", "fc", "txt", "sync", "std", "sl", "http", "ctr", "rl", "in", "st", "img", "ser", "ins", "sf", "str", "out", "cur", "usr", "proc", "supp", "sc", "iter", "req", "rc", "sub", "rb", "input", "sp", "rt", "SOURCE"], "tarn": [" tara", "wtara", "starn", "utorn", "tara", " tarp", "Tard", "vtarm", "Tarm", "Tann", " tourn", " torn", "utarn", "Tinn", "vtorn", "tarp", "wtinn", "thorn", "vtann", "starp", "tinn", "tourn", "torn", "tard", "yarm", "tharl", "Tarn", "utann", " tinn", "wtarn", "yourn", "pourn", " tann", "pann", "thourn", "yarn", " tard", "wtann", "vtarn", "stourn", "parn", "Tara", "parm", "Tourn", "tarl", "starm", "utard", "tann", "yarp", "storn", "Torn", "tharn", "starl", " tarl", " tarm", "porn", "tarm"], "tardir": [" tartart", " tartir", " tarnar", " tarnr", "tartore", "tardr", "tarnr", " tardr", " tardint", "tarnint", "taredint", " tartr", " tartore", "tarnar", "tareddir", " tardore", "tarddir", "tradore", "taredar", "tartar", "tartr", "tarnore", "tardore", "tradart", "tardart", "tradir", "tadint", " tarnint", "taddir", "tartdir", "taredir", "tarndir", "tadr", "tarnart", "tadir", " tarnir", "tadar", "tarnir", "tartart", " tarndir", "tradr", " tarddir", "tartir", "tardar", " tardart", "tardint", " tardar"], "n": ["ln", "nm", "x", "g", "nt", "index", "ns", "max", "w", "nn", "nb", "number", "ind", "nr", "i", "k", "nan", "next", "j", "on", "num", "m", "c", "nl", "nc", "y", "t", "en", "nu", "mn", "d", "un", "sn", "l", "con", "count", "z", "na", "norm", "N", "cn"], "tar": ["sea", "zip", "tf", "dr", "tr", "vol", "part", "cot", "add", "bolt", "copy", "drop", "cro", "pack", "tor", "par", "buffer", "archive", "tan", "rar", "gre", "parse", "dra", "car", "box", "tg", "roo", "txt", "sv", "mar", "tap", "sum", "ctr", "te", "nut", "store", "or", "gob", "trap", "Tar", "mask", "cast", "csv", "tif", "gz", "cube", "stable", "war", "qa", "star", "cat", "bare", "ar"], "bytes": ["resources", "bits", "groups", "elines", "cs", "ips", "unks", "bags", "frames", "bs", "some", "strings", "tes", "lines", "pages", "classes", "gets", "series", "users", "values", "reports", "blocks", "gs", "es", "ones", "files", "seconds", "cells", "pieces", "steps", "services", "pins", "rows", "boxes", "its", "parts", "ings", "vals", "Bytes", "words", "versions", "outs", "qs", "les", "bles", "bps", "ls"], "readn": [" Readl", "Readnl", "Readnn", "ReadN", "rolll", "writel", "Readn", "writele", "rolln", " Readn", "readl", "printle", "readN", "loadnn", "readle", "loadl", "printn", " Readnl", "Readl", "loadn", " readl", "writen", "rollle", "printl", "readnn", "readns", "writens", "readnl", "writenn", "loadN", "rollns", "writeN", "printns", " readnl"]}}
{"id1": "21224967", "id2": "6418781", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String[] names = client.listNames();\n            for (String name : names) {\n                System.out.println(\"Name = \" + name);\n            }\n            FTPFile[] ftpFiles = client.listFiles();\n            for (FTPFile ftpFile : ftpFiles) {\n                if (ftpFile.getType() == FTPFile.FILE_TYPE) {\n                    System.out.println(\"FTPFile: \" + ftpFile.getName() + \"; \" + FileUtils.byteCountToDisplaySize(ftpFile.getSize()));\n                }\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"crear": [" necessar", " Crear", " executado", " executada", " executas", " necessas", "creas", " Creado", " executar", " necessada", " necessado", " Creada", "creado", "creada", " Creas"], "result": ["sequence", "die", "su", "power", "tr", "Result", "true", "continue", "ret", "unique", "order", "process", "message", "r", "integer", "run", "currency", "number", "success", "value", "event", "date", "results", "successfully", "user", "successful", "complete", "comment", "num", "res", "search", "report", "valid", "command", "status", "conf", "br", "feature", "draw", "card", "test", "duration", "relation", "length", "total", "count", "rc", "row", "diff", "ULT", "df"], "sql": ["mail", "url", "ws", "string", "sq", "select", "xml", "description", "fn", "expression", "sb", "cmd", "sel", "params", "query", "join", "sd", "serv", "template", "ql", "pel", "sv", "dl", "spr", "q", "nl", "quote", "status", "sol", "sf", "condition", "csv", "seed", "db", "s", "SQL", "qs", "sp", "ls"], "connection": ["port", "character", "Connection", "link", "response", "server", "conn", "writer", "system", "statement", "socket", "created", "pool", "connected", "pointer", "current", "connect", "database", "number", "location", "query", "network", "ion", "session", " Connection", "resource", "computer", "channel", "close", "function", "context", "reference", "library", "application", "handler", "c", "driver", "communication", "engine", "command", "we", "nc", "collection", "condition", "relation", "client", "open", "con", "position", "creator", "to", "platform", "reset", "document", "directory"], "ps": ["fp", "fps", "cs", "pp", "prep", "ips", "p", "pse", "ts", "statement", "bs", "rs", "PS", "ds", "Ps", "pg", "aps", "pps", "pa", "ptr", "pd", "po", "ping", "pas", "res", "mp", "pers", "pr", "jp", "proc", "eps", "pb", "pt", "s", "sp", "gres", "pi", "cp", "pe"]}}
{"id1": "23510383", "id2": "7911686", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"saveProject": [" SaveApp", " saveApp", " SaveProject", " SaveFile", " savePackage", "saveFile", "createFile", "createApp", "saveApp", " saveFile", " SavePackage", "savePackage", "createPackage", "createProject"], "file": ["ile", "port", "link", "parent", "path", "File", "image", "full", "foo", "info", "e", "filename", "log", "resource", "io", "local", "data", "FILE", "files", "id", "project", "complete", "base", "report", "in", "create", "db", "table", "open", "get", "ame", "dir", "real", "use", "handle"], "types": ["views", "resources", "assets", "packs", "groups", "posts", "ts", "ports", "strings", "ypes", "pages", "sets", "features", "classes", " Types", "plugins", "values", "sites", "thumbnails", "keys", "tags", "scripts", "projects", "apps", "files", "otypes", "issues", "services", "actions", "packages", "ids", "tests", "models", "objects", "pes", "parts", "times", "items", "styles", "events", "ties", "versions", "codes", "options", "names", "Types"], "images": ["views", "assets", "picture", "groups", "image", "frames", "uploads", "pages", "classes", "Images", "thumbnails", "blocks", "links", "Image", "tags", "scripts", "files", "media", "faces", "photos", "boxes", "models", "videos", "styles", "events", "versions", "icons"], "trajectories": ["tractables", "Trajectories", "Trajory", "tractories", "Trajectors", "trajory", "trajectables", "trajories", "traceptories", "traceptables", "tractors", "traceptory", "Trajectables", "Trajories", "Trajables", "tractory", "Trajectory", "trajors", "traceptors", "Trajors", "trajectors", "trajectory", "trajables"], "databasesIncluded": ["databasesedIncluded", "databasesInclusions", "databasesedInclusion", "daturesInclusions", "databasesInlisted", "datadesInscluded", "databasesINified", "databasesIngcluded", "datadesInclusion", "databasesINjected", "databasesINclusion", "databasesInscluded", "databasesedInlisted", "datadesInified", "databasesInsified", "databasesedInjected", "databasesInjected", "daturesIncluded", "datadesInsjected", "databasesedInified", "databasesInsclusion", "databasesInsclusions", "daturesInsclusions", "databasesInslisted", "datadesInjected", "databasesInified", "datadesIncluded", "daturesInslisted", "daturesInlisted", "databasesIngclusions", "datadesInsclusion", "databasesINcluded", "databasesInsjected", "daturesInscluded", "databasesedInclusions", "databasesInglisted", "datadesInsified", "databasesInclusion"], "onlyLinks": ["forceLink", "forceLinks", "alsoLinks", "Onlylinks", "alsoLink", "onlyLink", " onlylinks", "OnlyLinks", "onlylinks", "onlyRelations", "OnlyRelations", "forcelinks", "OnlyLink", " onlyRelations", " onlyLink", "alsoRelations"], "index": ["sequence", "inc", "offset", "amount", "initial", "first", "find", "x", "fail", "ex", "add", "info", "max", "connect", " sidx", "nn", "number", "second", "pos", "all", "update", "ion", "i", "match", "zero", " Index", "num", "set", "check", "address", "no", "loc", "length", "open", "position", "n", "end", "Index", "ind"], "name": ["path", "NAME", "parent", "system", "string", "about", "full", "image", "none", "nm", "title", "run", "man", "named", "filename", "me", "local", "data", "default", "root", "id", "m", "base", "prefix", "Name", "create", "table", "ame", "word", "names", "primary", "n"], "format": ["printf", "util", "unit", "init", "it", "pattern", "fm", "v", "MAT", "value", "layout", "parse", "data", "default", "cal", " Format", "base", "percent", "scale", "form", "color", "prefix", "set", "language", "table", "get", "term", "list", "pretty", "print", "mt", "style", "use", "Format"], "count": ["counter", "amount", "order", "process", "add", "flag", "start", "err", "ount", "error", "num", "c", "mark", "sum", "set", "depth", "code", "length", "total", "table", "Count", "skip", "z", "reset", "size", "found"], "version": ["server", "parent", "journal", "draft", "header", "ver", "about", "description", "v", "xml", "current", "major", "alone", "database", "json", "number", "vers", "information", "build", "j", "video", "record", "translation", "VER", "root", "result", "release", "VERSION", "page", "java", "virtual", "python", "summary", "section", "latest", "connection", "tree", "versions", "Version", "document", "mint"], "writer": ["access", "writers", "iterator", "counter", "writing", "Writer", "external", "server", "journal", "wrote", "operator", "inner", "stream", "description", "order", "wright", "entry", "w", "outer", "wrapper", "writ", "flush", "buffer", "walker", "variable", "author", "builder", "function", "data", "sw", "comment", "handler", "written", "driver", "maker", "report", "caster", "console", "service", "language", "browser", "er", "editor", "write", "woman", "output", "client", "to", "connection", "creator", "print", "document", "reader", "window"], "xmlDir": ["xmlDirectory", "xmlFile", " xmldir", "xmldir", "logDir", "imageDirectory", " xmlFile", "imageDir", "logdir", "xmlFolder", " xmlDirectory", "logFolder", " xmlFolder", "logFile", "mlDirectory", "imageFolder", "imagedir", "mlFolder", "logDirectory", "mlDir", "mlFile"], "databases": ["datures", "Databases", "datables", "basures", " datables", "Datelines", "basabases", " datases", "datases", "datates", "Datasha", "datelines", "Datas", "database", "notures", " database", "mutabases", "Datases", " datasha", "Datures", "Datables", "notelines", "notables", " datates", " datas", "generabases", "datasha", "Datates", "mutasha", "mutases", "Database", "generates", "notabases", "mutables", "basables", "baselines", "datas", "generas", "generabase"], "t": ["tr", "p", "it", "ts", "x", "v", "tc", "typ", "w", "e", "temp", "tt", "i", "k", "h", "j", "template", "id", "txt", "c", "q", "ot", "te", "y", "str", "o", "T", "term", "pt", "s", "tm", "mt", "ct", "n"], "type": ["link", "ime", "unit", "ype", "TYPE", "other", "key", "shape", "p", "ver", "action", "this", "ty", "typ", "info", "title", "config", "resource", "parse", "match", "template", "top", "error", "root", "result", "id", "base", "time", "role", "ping", "site", "instance", "tag", "y", "object", "single", "te", "check", "language", "class", "rule", "address", "test", "kind", "relation", "module", "tool", "null", "to", "Type", "style", "pe"], "currentName": ["currentlyPath", "currentlyName", "updatePort", "baseOrder", "reportedNames", "baseFace", "currentKey", "reportedName", "basePort", "currentLock", " currentOrder", " currentParent", "currentlySet", "reportedDir", "thisSet", " currentPort", "completeYear", "CurrentDir", "reportedLock", "currentSet", "currentlyLock", "completeKey", "reportedParent", "baseName", "currentlyKey", "reportedTime", " currentDir", "thisName", "completeName", "CurrentTime", "updateOrder", "updateName", "CurrentPath", "currentPath", "currentlyTime", "CurrentParent", "currentFace", "currentPort", "currentlyYear", "CurrentLock", " currentFace", "currentOrder", "CurrentNames", "CurrentName", "updateFace", "currentDir", "currentNames", " currentNames", "thisYear", "thisKey", "currentYear", "currentTime", "completeSet", "reportedPath", "currentParent"], "baseCopy": ["basicStore", "parentCopy", "buffercopy", " baseName", "basiccopy", "baseCop", "basecopy", "baseName", "parentcopy", "bufferCopy", "BaseCopy", "BaseStore", "parentCop", "BaseCop", " basecopy", "bufferCop", "Basecopy", "basicCop", "basicCopy", " baseStore", "BaseName", " baseCop", "parentName", "baseStore"], "source": ["Source", "scan", "iterator", "sequence", "origin", "parent", "init", "initial", "system", "select", "shell", "inner", "stream", "ource", "scope", "src", "master", "sample", "se", "target", "before", "subject", "original", "start", "resource", "join", "channel", "local", "data", "base", "from", "space", "search", "site", "store", "console", "service", "ources", "create", "connection", "input", "size", "SOURCE", "reader", "owner"], "destination": [" destructure", " destinations", "destructure", "Destructure", "Destinations", " destuation", "messinated", "Destregation", "declinations", "messructure", "destregation", "datinator", "Destuation", "datinations", "destinator", "Destinator", "declregation", "destinated", "Destinated", "messination", "destinations", "messuation", "datination", "destuation", " destinated", "messinations", "declinator", "datregation", "Destination", "declination"], "clefs": ["CleFS", "CLEcs", " Clefs", " cleFS", "CleFs", " Clebs", "CLEFs", "clebs", " cleFs", " Clefits", "Clebs", " CleFS", "Clefs", "clefits", "CLEfits", " CleFs", " clebs", "CLEfs", " Clecs", "cleFs", "cleFS", "Clecs", "clecs", "Clefits"], "st": ["sm", "stat", "est", "inst", "statement", "it", "ts", "sth", " ST", "bl", "se", "ist", "sb", "cl", "sy", "query", "ost", "start", "tt", "h", "stra", "sw", "storage", "sts", "std", "sl", "str", "ste", "sn", "ST", "bt", "sc", "pt", "cr", "St", "rest", "fr", "dd", "irst", "sp", "mt", "ct"], "rs": [" cs", "rt", "cs", "rd", "ts", "ps", "as", " ps", "ds", "ers", " ins", "RS", " RS", "ris", "sts", "res", " pts", " iss", "ins", "rys", " ms", "Rs", "os", "mr", "rc", "ks", "ls", " sr"]}}
{"id1": "1985677", "id2": "16142024", "code1": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 0, "substitutes": {"initialURL": ["initialURI", "currentUrl", "currentURI", "originalURL", "initialHTTP", "InitialUR", "InitialURL", "defaultUrl", "newUrl", "InitialHTML", " initialSSL", "currentUR", "finalLocation", "currentHTTP", "currentLocation", "originalURI", "originalUrl", "initialSSL", "originalHTML", " initialHTTP", "InitialHTTP", "newUR", "newURI", "finalURI", "defaultLocation", "initialUR", "finalUrl", "initialUrl", " initialUR", " initialUrl", " initialURI", "InitialSSL", "InitialUrl", "initialHTML", "originalUR", "newURL", "defaultURI", "defaultURL", "finalHTML", "originalSSL", "initialLocation", "currentURL", "InitialURI", "finalURL"], "topPanel": ["contentPanel", "rootBox", "rootFrame", "TopPal", " topCenter", "TOPPanel", " topPal", "topCenter", "TOPConsole", "botPool", "topScreen", "botPanel", "TopConsole", "TOPCenter", "topBox", "TopContainer", "displayContainer", " topFrame", "TopComponent", "topPan", " topContainer", " topComponent", " topModule", "TopPan", "TopModule", "TopScreen", " topScreen", " topPan", "displayPan", " topBox", "TopBox", " topConsole", "topContainer", "TopPool", "rootPanel", "rootModule", "rootScreen", "TopCenter", "topModule", "topComponent", "displayFrame", "TopPanel", " topPool", "contentComponent", "topFrame", "contentPal", "topPal", "topPool", "displayPanel", "botPan", "topConsole", "TopFrame"], "homeButton": ["hotOption", " homePanel", " homeLabel", "HOMEPanel", " homePin", "HomeOption", "HomeLabel", "homePanel", "homeLabel", "HomePanel", "homePin", "hotButton", "HomePin", " homeOption", "HOMEButton", "bumPin", "homebutton", "bumButton", "HomeButton", "homeOption", "HOMEbutton", " homebutton", "Homebutton", "HOMELabel", "hotLabel"], "urlLabel": ["linkLabel", "dateButton", "linkLAB", "urlLAB", " URLField", "UrlLink", "urlLink", "UrlButton", "linkButton", "UrlField", " URLButton", "userField", "dateField", "UrlLabel", "linkField", "dateLabel", " urlButton", " URLLink", "urlButton", "userLabel", " URLLabel", "userButton", "userLAB", "dateLAB", " urlLink"], "urlField": ["linkLabel", "urlfield", "URLField", "Urlfield", "uriField", " urlVar", "webButton", "webLabel", "linkButton", "linkArea", "UrlField", "urlArea", " urlArea", "webfield", "urifield", "textField", "textLabel", "UrlLabel", "linkField", "UrlVar", "webField", "uriVar", "URLfield", "urlButton", "textArea", "urlVar", "URLLabel", "URLButton", "linkfield", " urlfield"], "url": ["mail", "Url", "link", "util", "hl", "path", "handle", "org", "char", "this", "loader", "r", "u", "mount", "json", "file", "location", "all", "buffer", "log", "gl", "ssl", "resource", "parser", "host", "bel", "library", "dl", "base", "il", "uri", "res", "github", "web", "http", "nl", "sl", "el", "page", "sql", "rl", "str", "impl", "ll", "browser", "out", "ref", "address", "https", "rel", "l", "get", "term", "null", "lr", "URL", "re", "ml", "document", "ls", "ur", "window", "ul"], "in": ["inn", "im", "up", "init", "is", "it", "inner", "stream", "isin", "ini", "r", "din", "info", "add", "mm", "file", "b", "all", "bin", "ssl", "io", "gin", "on", "from", "In", "conf", "or", "ins", "t", "en", "out", "er", "IN", "l", "get", "con", "ma", "to", " din", "cin", "input", "reader", "n"], "inputLine": ["quickLine", "formatLINE", "cmdLine", "indexLin", " inputByte", "requestLin", "indexLine", "InputLINE", " inputChain", "inputMe", " inputLINE", "contentRow", "printLINE", "helloLINE", "requestBlock", "inputByte", "patternByte", "uploadBlock", "commandLine", "singleLINE", "formatLine", "requestLINE", "outputLINE", "quickLINE", " inputEntry", "execBlock", "indexLINE", "infoLine", " inputLin", "cmdBlock", "InputLock", "Inputline", "outputLine", "commandLINE", "requestLine", "inputChain", "commandRow", "feedLINE", "feedLine", "uploadLock", "cmdLINE", "inputEntry", "inLINE", "infoLin", "inLine", "InputLine", "inChain", "inputBlock", "singleDe", "singleEntry", "inputDe", "InputBlock", " inputDe", "inBlock", "infoLINE", "quickRow", "singleLine", "outputByte", "contentLINE", " inputMe", "outputRow", "inputRow", "patternLine", "quickByte", "printRow", " inputLock", "inputLin", "infoline", "inputline", "patternLINE", "InputRow", "helloEntry", "formatRow", "execLin", "httpline", "helloDe", "cmdChain", " inputline", "inputLock", "printMe", "feedByte", "uploadLine", "commandByte", "httpLINE", "contentLine", "execLine", "httpRow", " inputBlock", "helloLine", " inputRow", "inputLINE", "indexline", "printLine", "contentMe", "httpLine", "execLINE"], "content": ["resources", "Contents", "sequence", "metadata", "cache", "response", "settings", "description", "message", "current", "title", "values", "buffer", "comments", "layout", "context", "results", "data", "media", "comment", "cont", "Content", "articles", "status", "body", "object", "text", "children", "code", "create", "summary", "output", "styles", "tree", "list", "document", "ontent", "format"], "stylesheet": ["transcript", "transheet", "transpace", "lesheet", "lescript", "styleset", "stylespace", " stylespace", "leset", " styleset", "stylescript", " stylescript", "lespace", "transet"], "transformer": ["ransformer", "reition", "traformer", "transformformation", "transactor", "ransition", "reformer", "reactor", "transition", "reporter", "ransformation", "performer", "traformation", "transmission", "transformpler", "repler", "perpler", "remission", "transformformer", "transpler", "peractor", "transformation", "ransmission", "ransporter", "ranspler", "transformmission", "traition", "reformation", "ransactor", "tramission", "trapler", "transporter", "traporter", "performation"], "xml": ["mail", "php", "htm", "external", "model", "image", "complex", "css", "x", "aml", "cloud", "png", "physical", "memory", "many", "apache", "json", "file", "log", "dom", "parse", "om", "files", "ocument", "sv", "plain", "rss", "http", "java", "pic", "text", "javascript", "binary", "https", "csv", "tml", "inx", "quiet", "events", "tree", "ml", "print", "document", "pdf", "material", "format"], "offset": ["attribute", "name", "link", "key", "pointer", "info", " index", "shift", "Offset", "pos", "location", "start", "ptr", "error", "id", "type", "meta", " pos", "hash", "address", "ref", "length", "line", "count", " offsets", "index", "off"], "href": ["attribute", "link", "htm", "stat", "external", "path", "cert", "header", "attr", "css", "about", "dest", "src", "physical", "target", "index", "title", "utils", "temp", "json", "source", "location", "alt", "filename", "folder", "alias", "prop", "resource", "urn", "id", "result", "alert", "handler", "uri", "prototype", "format", "http", "impact", "status", "prefix", "hash", "relative", "ref", "https", "test", "rel", "foreign", "tif", "hex", "absolute", "handle", "addr"], "stylesheetURL": ["stylesheetID", "stylesitePath", "stylescriptPath", " stylesheetID", "stylesetPath", "lesiteUR", "stylescriptUR", " stylesheetUrl", "stylesheetUR", "lesheetID", " stylesiteUrl", "stylescriptURL", "lesiteID", "stylescriptUrl", "lesheetUrl", "stylesetURL", "lesiteURL", "stylescriptID", "stylesiteID", "lesiteUrl", " stylesiteURL", " stylesiteID", "stylesheetPath", " stylesheetPath", "stylesetID", "stylesetUR", "stylesiteURL", "stylesetUrl", "lesheetURL", "stylesiteUR", "lesheetUR", "stylesheetUrl", "stylesiteUrl", " stylesitePath"], "sheetIn": [" pageCl", " schemeOut", " backendIf", " pageOut", " backendIn", " backendCl", " backendOut", " sheetOut", " schemeIf", " schemeCl", " sheetIf", " pageIf", " schemeIn", " sheetCl", " pageIn"]}}
{"id1": "12678045", "id2": "10540676", "code1": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void checkForUpgrade(Event event) throws Exception {\n        ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"applyUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(false);\n        new Command(\"DELETE FROM TBLINSTALLATION WHERE STATUS<>'APPLIED'\").executeNonQuery();\n        String clientAppliedVersion = new Command(\"SELECT MAX(VERSION) FROM TBLINSTALLATION WHERE STATUS='APPLIED'\").executeScalarAsString();\n        if (NullStatus.isNull(clientAppliedVersion)) {\n            clientAppliedVersion = \"20050101\";\n        }\n        String macquery = \"\";\n        String clientMAC = \"\";\n        String clientUNITID = UiUtil.getUNITUID();\n        ArrayList<String> macList = getMacList();\n        for (int i = 0; i < macList.size(); i++) {\n            clientMAC += macList.get(i) + \",\";\n            macquery += \"'\" + macList.get(i) + \"'\";\n            if (i < macList.size() - 1) {\n                macquery += \",\";\n            }\n        }\n        URL urlLICENSEQUERY = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC + \"&tegsoftCOMMAND=LICENSEQUERY\");\n        URLConnection urlConnection = urlLICENSEQUERY.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String commingList = \"\";\n        String line;\n        while ((line = in.readLine()) != null) {\n            commingList += line;\n        }\n        in.close();\n        String licenseArray[] = commingList.split(\"</ROW>\");\n        if (licenseArray.length > 0) {\n            String fields[] = licenseArray[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        Dataset TBLLICENSE = new Dataset(\"TBLLICENSE\", \"TBLLICENSE\");\n        Command command = new Command(\"DELETE FROM TBLLICENSE WHERE UNITUID={UNITUID} AND (NOTES IN (\");\n        command.append(macquery);\n        command.append(\") OR NOTES IS NULL) \");\n        command.executeNonQuery();\n        for (int i = 1; i < licenseArray.length; i++) {\n            String fields[] = licenseArray[i].split(\"</FLD>\");\n            String LICTYPE = fields[0];\n            String UNIQUEKEY = fields[1];\n            String LICKEY = fields[2];\n            DataRow dataRow = TBLLICENSE.addNewDataRow();\n            dataRow.set(\"LICENSENAME\", LICTYPE);\n            dataRow.set(\"LICENSE\", LICKEY);\n            dataRow.set(\"NOTES\", UNIQUEKEY);\n            TBLLICENSE.save();\n        }\n        URL url = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC);\n        urlConnection = url.openConnection();\n        in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String upgradeList = \"\";\n        while ((line = in.readLine()) != null) {\n            upgradeList += line;\n        }\n        in.close();\n        Dataset TBLINSTALLATION = new Dataset(\"TBLINSTALLATION\", \"TBLINSTALLATION\");\n        String upgrades[] = upgradeList.split(\"</ROW>\");\n        if (upgrades.length > 0) {\n            String fields[] = upgrades[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        boolean restartRequired = false;\n        boolean updateAvailable = false;\n        for (int i = 1; i < upgrades.length; i++) {\n            String fields[] = upgrades[i].split(\"</FLD>\");\n            String VERSION = fields[0];\n            String ORDERID = fields[1];\n            String UPGRADETYPE = fields[2];\n            String DESCRIPTION = fields[3];\n            String STATUS = \"UNAPPLIED\";\n            String PRDNAME = \"TegsoftCC\";\n            if (\"TEGSOFTJARS\".equals(UPGRADETYPE) || \"TOBEJARS\".equals(UPGRADETYPE) || \"ALLJARS\".equals(UPGRADETYPE) || \"CONFIGASTERISK\".equals(UPGRADETYPE)) {\n                restartRequired = true;\n            }\n            DataRow dataRow = TBLINSTALLATION.addNewDataRow();\n            dataRow.set(\"ORDERID\", ORDERID);\n            dataRow.set(\"PRDNAME\", PRDNAME);\n            dataRow.set(\"UPGRADETYPE\", UPGRADETYPE);\n            dataRow.set(\"VERSION\", VERSION);\n            dataRow.set(\"STATUS\", STATUS);\n            dataRow.set(\"DESCRIPTION\", DESCRIPTION);\n            TBLINSTALLATION.save();\n            updateAvailable = true;\n        }\n        UiUtil.getDataset(\"TBLINSTALLATION\").reFill();\n        if (restartRequired) {\n            ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(true);\n            ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(true);\n        }\n        if (updateAvailable) {\n            ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(true);\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_4));\n        } else {\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_5));\n        }\n    }\n", "label": 0, "substitutes": {"addQDInformation": ["addQuestiondinformation", "addQuestiondInformation", "addQuestionDinformation", "addQDMInfo", "addQDMinformation", "addQdinformation", "addQuestionDInfo", "addQuestionDinfo", "addQDinfo", "addQSinformation", "addQuestiondInfo", "addQuestiondinfo", "addQSinfo", "addQDMinfo", "addQDInfo", "addQDMInformation", "addQdinfo", "addQdInfo", "addQSInfo", "addQDinformation", "addQSInformation", "addQuestionDInformation", "addQdInformation"], "qdDate": ["requduDat", " qddate", "qdodate", "qldDat", "qdmFile", "qdxDo", "qdTime", "qedDo", "requduDisplay", "qdxDate", "qdxNow", "requdDat", "qdDat", "qlDat", "qdDisplay", "questdDate", "qdxdate", "qedNow", "qdtNow", " qdDat", "qadNow", " qdodate", "qlDate", "qadDate", "requdDate", "qdsDate", " qdoNow", "questdNow", "requduDate", "qdxFile", " qdDo", "qdoNow", " qdoDat", "questedDat", "qadDo", "qdsDisplay", "requduTime", "questedDate", "requdDisplay", "qdmDo", "qddate", "questdDo", "qadDat", "qdtdate", " qdoDate", "qdxDat", "qdmTime", "qdxTime", "qduTime", "qduDisplay", "qldDate", "qdtDate", "qdNow", "questedDo", "qduDat", " qdNow", "qdtDat", "qlNow", " qdTime", "qldDisplay", "qdsDat", "qedDate", "qduDate", "qdDo", "requdTime", "questdDat", "qdsTime", "qlDo", "qedDat", "qldTime", "questedNow", "qdoDate", "qdoDat", "qdmDate"], "qdFile": ["qsdFile", "qdmByte", "qdmFile", "qdsfile", " qdfile", "querydByte", "qdsFile", "qdTable", "querydFile", "qdTime", "qdoSourceFile", "qdrfile", "iqdFile", "qdSourceFile", "qdsTime", "qdsTable", "qrdByte", "querysdSourceFile", "qmdSourceFile", "querydTime", "qmdfile", "iqdoFile", "iqdoByte", "qdrFile", "qdrFilename", "querysdByte", "qrdfile", "qdmTime", "qdFilename", "qrdSourceFile", "qdsFilename", "qdsByte", "iqdfile", "qdrTable", "querydSourceFile", "iqdofile", "qrdFile", " qdFilename", "qsdSourceFile", "qdsSourceFile", "qmdFile", " qdTable", "qdoFile", "qdmSourceFile", "qmdByte", "iqdoSourceFile", "iqdSourceFile", "qsdByte", "qsdTime", "querysdFile", "iqdByte", "qdoByte", "qdofile", "querysdTime", "qdfile", "qdByte"], "_qdFileDate": ["_qdfileMap", "_qdDirMap", "_qdsFileMap", "_qpFileDate", "_qdfileNumber", "_qdDirNumber", "_qdDirFormat", "_qdDirDo", "_qdUnitFormat", "_qdFileNumber", "_qdsFileDate", "_qdsfileNumber", "_qdsfileMap", "_qdSetMap", "_qpTotalFormat", "_qpFileYear", "_qdTotalDate", "_qpFileFormat", "_qdsfileDate", "_qdTotalWrite", "_qdTotalFormat", "_qdsFileNumber", "_qdDirYear", "_qdsFileDo", "_qdFileDo", "_qdsfileDo", "_qdDirDate", "_qdSetDate", "_qdDirWrite", "_qdFileFormat", "_qpTotalWrite", "_qpTotalDate", "_qdSetNumber", "_qdFileYear", "_qdFileWrite", "_qdfileDate", "_qdfileDo", "_qdFileMap", "_qdUnitDate", "_qpTotalYear", "_qdSetDo", "_qdUnitYear", "_qpFileWrite", "_qdUnitWrite", "_qdTotalYear"], "ii": ["ni", "ix", "ku", "iona", "cgi", "ani", "oi", "mi", "chi", "gi", "inch", "si", "Si", "ini", "hi", "ami", "ishi", " iii", "ind", "ski", "iso", "i", "ti", "ci", "ori", "zi", "di", "oci", "xi", "aii", "qq", "ou", "fi", "umi", "sim", "iii", " ni", "iy", "II", "ei", "ati", "ims", "ico", "qi", "cu", "ta", "aa", "ij", "iri", "jj", "ai", "ice", "iat", "co", "ie", "pi", "yi", "iq", "ia", "li"], "info": ["name", "ip", "key", "init", "none", "is", "about", "notice", "def", "inner", "fo", "Info", "entry", "what", "tip", "unknown", "success", "query", "iso", "alias", "i", "information", "io", "join", "ti", "data", "translation", "error", "id", "f", "type", "time", "http", "conf", "status", "instance", "details", "object", "INFO", "check", "summary", "item", "history", "inf", "pi", "note", "used", "index"], "_qdValue": ["_qdInfo", "_qdvalue", "_dqDValue", "_qdResult", "_qDResult", "_qldValue", "_qdoInfo", "_dqdResult", "_dqDInfo", "_qDInfo", "_dqdvalue", "_dqdValue", "_dqDvalue", "_qldvalue", "_dqDResult", "_qldResult", "_qldInfo", "_qdoResult", "_qdovalue", "_qdoValue", "_qDvalue", "_dqdInfo", "_qDValue"], "reader": ["then", "iterator", "READ", "writer", "reading", "inner", "loader", "r", "rr", "rx", "redo", "feed", "buffer", "holder", "builder", "read", "parser", "resource", "rar", "data", "library", "handler", "driver", "worker", "ner", "body", "rl", "random", "Reader", "er", "relation", "ro", "iter", "upper", "lr", "row", "runner", "pull", "dd", "rot", "dr", "wrapper", "handle"], "urlName": ["URLNames", "URLKey", "lName", " urlPath", "UrlKey", "urlNames", "strName", "UrlNames", "UrlDefault", "rowName", "urlDefault", "urlKey", "urlname", "urlPath", "strname", " urlString", "lN", "rowN", "URLname", "strKey", "rowname", " urlNames", "UrlPath", " urlDefault", "urlString", "URLDefault", "UrlN", "rowNames", "UrlString", "URLString", "lNames", "UrlName", "strNames", "URLName", "urlN", "lname", " urlKey", "URLPath", " urlname", "Urlname"], "url": ["mail", "Url", "link", "hl", "name", "string", "char", "mb", "r", "mount", "b", "location", "gl", "ssl", "resource", "host", "bel", "user", "f", "uri", "http", "nl", "sl", "rl", "console", "str", "ll", "browser", "address", "ref", "loc", "rel", "l", "open", "lr", "URL", "re", "ur"], "stream": ["iterator", "system", "socket", "clean", "present", "inner", "message", "sample", "stack", "REAM", "feed", "buffer", "network", "resource", "channel", "stage", "data", "sw", "cont", "Stream", "sl", "pod", "form", "poll", "body", "instance", "console", "in", "str", "iter", "row", "ream", "input", "platform", "screen", "window"], "file": ["ile", "fp", "port", "File", "header", "writer", "loader", "message", "r", "run", "buffer", "filename", "io", "data", "FILE", "files", "f", "handler", "fs", "fd", "report", "page", "body", "in", "range", "rule", "fast", "db", "table", "open", "dir", "tree", "input", "fr", "document", "handle", "format"], "line": ["port", "link", "sequence", "online", "cmd", "buffer", "channel", "LINE", "one", "user", "trace", "cell", "store", "frame", "range", "normal", "piece", "no", "iter", "block", "field", "le", "ine", "part", "message", "sample", "detail", "e", "point", "error", "lin", "sql", "body", "rule", "lo", "position", "ice", "row", "inline", "dd", "level", "raw", "ln", "ip", "header", "se", "job", "node", "query", "record", "eline", "queue", "comment", "chain", "out", "section", "print", "column", "handle", "liner", "string", "char", "continue", "lines", "entry", "side", "Line", "log", "next", "page", "code", "phrase", "l", "word", "note"], "_qdDate": ["_qdxGeneral", "_qudtPort", "_kdFile", "_qdFile", "_iqtTime", "_qdoDate", "_qlTime", "_qdTotal", "_iqtDat", "_qdoTotal", "_qdxTotal", "_iqtValue", "_qdsTime", "_qdmGeneral", "_qdxFile", "_kdGeneral", "_qdtTime", "_qdoFile", "_qdTime", "_iqdDate", "_qlDate", "_qdtDat", "_qtDat", "_qudDat", "_qdoPort", "_kdxGeneral", "_qdoGeneral", "_qudTime", "_qtTime", "_kdDate", "_iqdDat", "_iqdValue", "_qdDat", "_iqtDate", "_qudtDat", "_kdxTotal", "_kdxFile", "_qudDate", "_kdTotal", "_qdsDat", "_qdmDate", "_qdmTotal", "_qdPort", "_qdoDat", "_qudPort", "_kdxDate", "_qdsValue", "_qdmFile", "_qdsPort", "_qtDate", "_qdsDate", "_iqdTime", "_qlDat", "_qdoTime", "_qlValue", "_qudtDate", "_qtValue", "_qdGeneral", "_qdtPort", "_qudtTime", "_qdtDate", "_qdxDate"], "pos": ["port", "pc", "yes", "len", "offset", "exp", "pres", "p", "axis", "part", "present", "def", "ps", "add", "max", "neg", "pro", "Pos", "min", "start", "cos", "point", "i", "snap", "slot", "pad", "win", "zero", "top", "num", "po", "conf", "cond", "or", "prefix", "prot", "nos", "loc", "no", "o", "proc", "pose", "pr", "length", "os", "position", "pt", "n", "pid", "apo", "pat", "px", "size", "sp", "POS", "index", "ind"], "projectNum": [" projectDir", "componentDir", "projectnum", "componentNum", "modelDir", " projectNo", "componentnum", "componentNo", "componentNumber", " projectNumber", "modelNo", "componentConn", "ProjectNum", "projectNumber", "projectNo", "ProjectConn", "modelnum", "projectConn", "ProjectNumber", " projectnum", "projectDir", " projectConn", "modelNum", "Projectnum"], "value": ["port", "name", "ue", "unit", "key", "description", "v", "distance", "number", "values", "point", "property", "profile", "val", "data", "Value", "result", "project", "type", "scale", "feature", "object", "total", "VALUE", "field", "index", "format"]}}
{"id1": "18989018", "id2": "3809087", "code1": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"doSetInput": ["doGetinput", "doSetinput", " doGetinput", "doGetData", " doSetOutput", "doSetOutput", "dosetOutput", "doGetOutput", "doSetData", "doGetInput", "doHandleinput", "dosetinput", "doHandleData", " doSetinput", "doHandleOutput", " doGetInput", "dosetInput", " doGetOutput", " doGetData", "dosetData", " doSetData", "doHandleInput"], "input": ["ix", "p", "info", "content", "submit", "cmd", " Input", "context", "accept", "from", "cont", "conf", "form", "text", "table", "field", "ia", "upload", "version", "act", "def", "xml", "via", "config", "error", "edit", "focus", "request", "att", "control", "raw", "attribute", "active", "up", "ip", "select", "pattern", "present", "this", "support", "what", "arg", "unknown", "argument", "query", "password", "command", "history", "Input", "supp", "doc", "output", "qa", "print", "primary", "al", "ch", "wa", "key", "init", "initial", "image", "it", "add", "entry", "um", "ion", "local", "plugin", "instance", "op", "client", "get", "note"], "monitor": ["im", "timeout", "stat", "mi", "system", "display", "pool", "inner", "process", "message", "dm", "man", "progress", "Monitor", "hist", "mon", "log", "meter", "rain", "manager", " Monitor", "sam", "processor", "wm", "m", "handler", "timer", "report", "mx", "console", "summary", "history", "cm", "watch", "mr", "runner", "program", "window", "state"], "root": ["Root", "util", "room", "oot", "RO", "server", "parent", "p", "system", "scope", "r", "localhost", "target", "mount", "node", "container", "folder", "sys", "h", "resource", " Root", "context", "roots", "host", "manager", "local", "box", "top", "project", "m", "base", "storage", "res", "store", "prefix", "ms", "ro", "pkg", "mr", "null", "tree", "oots", "home", "directory", "window", "owner"], "format": ["attribute", "util", "metadata", "former", "unit", "version", "pattern", "act", "fm", "xml", "process", "MAT", "title", "feed", "config", "filename", "layout", "mod", "parse", "template", "map", "fc", "f", "base", "type", "actor", "struct", "form", "feature", "set", "service", "spec", "class", "api", "at", "supported", "module", "cf", "tif", "policy", "term", "tool", "feat", "transform", "filter", "ct", "fill", "Format"], "source": ["port", "scan", "sequence", "cache", "origin", "is", "src", "buffer", "context", "data", "from", "trace", "store", "spec", "table", "license", "index", "state", "Source", "display", "ource", "sample", "resource", "join", "reason", "report", "body", "details", "ser", "language", "address", "ne", "size", "SOURCE", "style", "raw", "remote", "view", "shell", "find", "this", "dest", "scope", "se", "target", "filename", "template", "base", "site", "object", "out", "relation", "output", "null", "sp", "wrapper", "secret", "handle", "iterator", "parent", "image", "string", "inner", "copy", "session", "i", "local", "console", "service", "proxy", "note"], "in": ["scan", "p", "is", "src", "din", "container", "buffer", "io", "data", "win", "from", "el", "store", "ic", "text", "create", "iter", "as", "index", "ind", "include", "ain", "xml", "resource", "on", "sql", "body", "inside", "IN", "con", "ma", "cin", "rin", "reset", "size", "raw", "thin", "inc", "pin", "ln", "this", "isin", "all", "gin", "id", "In", "sum", "ins", "out", "doc", "null", "can", "inn", "iterator", "init", "image", "mi", "it", "inner", "ini", "add", "copy", "nin", "bin", "i", "internal", "serv", "local", "en", "l", "get", "reader"], "path": ["port", "link", "p", "mount", "pos", "alias", "context", "host", "user", "from", "trace", "set", "pt", "tree", "home", "index", "ith", "name", "PATH", "ath", "full", "physical", "member", "location", "point", "resource", "join", "prefix", "address", "ref", "Path", "where", "pattern", "dest", "pointer", "pro", "prop", "template", "base", "time", "chain", "api", "history", "pr", "pkg", "length", "policy", "th", "print", "parent", "key", "string", "system", " PATH", "entry", "temp", "folder", "log", "local", "po", "near", "item", "loc", "rel", "dir", "route", "transform", "pi", "cp"], "s": ["sm", "stat", "p", "is", "sq", "ts", "socket", "rs", "g", "ps", "stats", "src", "r", "sa", "v", "a", "sb", "b", "sys", "i", "gs", "ssl", "S", "serv", "h", "ss", "sam", "f", "sw", "sv", "c", "storage", "fs", "sts", "space", "abs", "m", "sl", "http", "conf", "simple", "store", "set", "single", "sol", "st", "sf", "t", "us", "https", "l", "js", "ls", "has"], "file": ["ile", "port", "name", "link", "fp", "obj", "le", "key", "File", "p", "image", "tile", "fo", "message", "original", "info", "content", "e", "value", "node", "location", "filename", "i", "resource", "io", "local", "data", "FILE", "library", "files", "media", "id", "f", "il", "type", "from", "fs", "base", "form", "object", "t", "sf", "item", "binary", "class", "supported", "l", "table", " File", "be", "use"], "uri": ["remote", "volume", "link", "msg", "unit", "html", "origin", "ri", "domain", "image", "phi", "char", "ui", "description", "URI", "subject", "copy", "u", "doi", "location", "uid", "filename", "query", "i", "resource", "local", "reference", "template", "id", "result", "http", "du", "form", "prefix", "range", "qi", "chain", "address", "nu", "ref", "phrase", "iri", "term", "dir", "request", "pid", "route", "pi", "note", "ur", "directory", " URI", "uni", "uu"], "url": ["mail", "Url", "link", "name", "string", "char", "r", "u", "mount", "location", "gl", "ssl", "host", "resource", "channel", "f", "dl", "http", "nl", "sl", "rl", "str", "ll", "browser", "address", "ref", "api", "rel", "l", "open", "get", "term", "URL", "ls", "ur", "href", "ul"], "cd": ["vd", "cs", "rd", "ec", "cc", "DC", "dm", "ds", "od", "cmd", "hd", "bd", "de", "sd", "ld", "ctr", "gb", "CD", "md", "xd", "dc", "kb", "d", "cm", "db", "cf", "dt", "cr", "idd", "cod", "dd", "dn", "did", "td", "desc", "ct", "cp", "pd"], "valid": ["al", "active", "required", "full", "used", "multiple", "present", "def", " Valid", "v", "current", "info", "legal", "all", "val", "local", "multi", "related", "defined", "available", "dev", " invalid", "basic", "VAL", "solid", "Valid", "visible", "allowed", "good", "recent", "formed", "form", "check", "normal", "md", "supported", "test", "by", "open", "ma", "bad", "more", "empty", "found"], "stream": ["im", "response", "view", "ous", "image", "is", "clean", "Steam", "pool", "sample", " streaming", "content", "REAM", "buffer", "resource", "read", "channel", "context", "data", "sam", " streamed", "ess", "sw", "Stream", "form", "steam", "store", "instance", "console", " upstream", "out", "sc", " Stream", "row", "ream", "speed", "empty", "transform", "dd", "reader", "raw", "upload"], "document": ["Source", "image", "string", "New", "Internal", "message", "content", "value", "number", "json", "Exception", "resource", "information", "context", "data", "record", "Supported", "FILE", "Store", "ocument", "media", "Open", "Document", "m", "cont", "NULL", "_", "instance", "object", "collection", " documents", "text", "language", "Required", "doc", "Context", "output", "IA", "index"]}}
{"id1": "8515891", "id2": "7087108", "code1": "    protected String readUrl(String svnUrl) throws IOException {\n        URL url = new URL(svnUrl);\n        URLConnection uc = url.openConnection();\n        if (url.getProtocol().equals(\"https\")) {\n            String userPassword = user + \":\" + password;\n            String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n            uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        InputStream is = null;\n        String in = null;\n        try {\n            is = uc.getInputStream();\n            in = read(is);\n        } finally {\n            try {\n                is.close();\n            } catch (Exception e) {\n            }\n        }\n        return in;\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"readUrl": ["READURL", "loadUr", "READurl", "readurl", "readUr", "READUr", "getUr", "geturl", "getURL", "loadurl", "READUrl", "readURL", "loadUrl", "loadURL", "getUrl"], "svnUrl": ["svnServer", "svNUrl", "svneServer", "servicensUr", " svnUr", " svNServer", "servicensurl", "servicenurl", "svnUr", "svcURL", "svneStr", "svnsStr", "servicenUr", "svnURL", "svneUr", "svnStr", "svNUr", "svgURL", "servicenUrl", "svcurl", "svgurl", "svNStr", "svnsUrl", "svgUr", "svnsURL", "servicensURL", "svneUrl", "svgUrl", " svNUr", "svcUrl", "svnsUr", " svnStr", "svnsurl", " svnServer", "servicensUrl", "servicenURL", " svNUrl", "svnurl", "svnsServer", " svNStr", "svNServer", "svcUr"], "url": ["mail", "Url", "link", "hl", "html", "pl", "conn", "raw", "org", "char", "r", "mount", "cl", "lb", "location", "gl", "ssl", "host", "build", "uf", "bel", "call", "ld", "base", "dl", "abs", "uri", "github", "http", "nl", "sl", "uu", "str", "impl", "ll", "google", "browser", "ref", "https", "loc", "l", "lr", "URL", "ml", "acl", "ls", "ur", "ul"], "uc": ["conn", "ac", "bc", "soc", "ec", "uh", "ui", "cc", "ul", "tc", "u", "userc", "anc", "cl", "roc", "nic", "ci", "uf", "fc", "lu", "unic", "c", "usc", "unc", "oc", "ux", "ucc", "nc", "eu", "cur", "uci", "cu", "orc", "us", "lc", "dc", "ub", "loc", "sc", "con", "cus", "cr", "ud", "rc", "co", "UC", "auc", "mc", "uu"], "userPassword": ["browserPassword", " userAuth", "UserData", "browserPass", " userData", " userGrant", "userPass", "userAuth", "browserpassword", " userpassword", "userpassword", " userPass", "Userpassword", "userGrant", "managerPass", "UserAuth", "UserGrant", "userData", "managerGrant", "browserData", "UserPass", "UserPassword", "managerPassword", "managerAuth"], "encoding": ["Encoding", "enoding", "ecaling", "encaling", "ecasing", "Encasing", "cryption", "Encoder", "ecoder", "Encaling", "encoder", "enryption", "enasing", "Encryption", "encryption", "enoder", "encasing", "ecoding", "ecryption", "coder", "caling", "coding"], "is": ["tis", "im", "obs", "ri", "ip", "ois", "mi", "iss", "it", "si", "isin", "isa", "sis", "iso", "Is", "ir", "i", "isf", "ys", "ris", "es", "IS", "imp", "\u00eds", "abs", "fs", "bis", "its", "ic", "ios", "ims", "ms", "isl", "ins", "us", "ists", "ism", "ais", "iris", "vis", "os", "s", "isc", "oss", "mis", "ows", "isi", "as", "lis"], "in": ["inn", "inc", "pin", "kin", "ln", "it", "inner", "isin", "v", "r", "din", "e", "file", "lit", "nin", "bin", "i", "k", "read", "gin", "password", "on", "f", "m", "login", "In", "report", "sum", "str", "ins", "text", "t", "en", "out", "IN", "l", "con", "n", "cin", "input", "rin", "print", "vin", "edIn", "oin"]}}
{"id1": "11475527", "id2": "7945594", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "label": 1, "substitutes": {"addDataFromURL": ["addDatafromurl", "addDataFromUrl", "addDatafromLocation", "addDataToURL", "addTextFormUrl", "addTextFormLocation", "addDataFromLocation", "addDataFormurl", "addTextFormURL", "addTextFromURL", "addDataFormLocation", "addTextFormurl", "addTextFromLocation", "addDataFromurl", "addTextFromurl", "addDataToLocation", "addTextFromUrl", "addDataToUrl", "addDataTourl", "addDatafromUrl", "addDatafromURL", "addDataFormUrl", "addDataFormURL"], "theurl": ["heloader", " theloader", " theUrl", " thefile", "thUrl", "thurl", "Theurl", "heurl", "heUrl", "teURL", "theURL", "thefile", "Theuri", "theuri", "heURL", " theuri", "hefile", "teUrl", "TheURL", "TheUrl", " theURL", "heuri", "teurl", "thfile", "teuri", "thloader", "theUrl", "theloader"], "line": ["name", "link", "sequence", "lane", "online", "liner", "le", "ln", "header", "string", "stroke", "ine", "char", "message", "lined", "sample", "entry", "Line", "node", "source", "point", "email", "LINE", "eline", "record", "comment", "lin", "valid", "page", "cell", "status", "ner", "frame", "day", "code", "text", "chain", "rule", "zone", "l", " inline", "block", "ice", "row", "inline", "print"], "in": ["inn", "al", "inc", "pin", "conn", "include", "init", "ac", "is", "it", "mi", "ain", "inner", "isin", "old", "r", "din", "source", "bin", "i", "read", "serv", "gin", "win", "phys", "id", "f", "from", "again", "In", "or", "ic", "st", "ins", "t", "en", "out", "IN", "o", "lo", "proc", "l", "open", "con", "ai", "ma", "n", "cin", "rin", "input", "mc", "reader", "inf", "oin"], "data": ["iterator", "cache", "writer", "ata", "bus", "def", "this", "stream", "pipe", "a", "info", "content", "dec", "feed", "file", "query", "buffer", "join", "read", "dat", "next", "ad", "io", "user", "result", "body", "da", "text", "out", "d", "client", "DATA", "input", "size", "reader", "window", "raw"], "e": ["ue", "ele", "le", "p", "ec", "E", "x", "ine", "g", "ex", "a", "se", "r", "v", "entry", "oe", "ee", "event", "b", "de", "err", "ve", "i", "h", "me", "es", "error", "f", "m", "c", "te", "y", "or", "ge", "eu", "t", "element", "er", "eeee", "o", "ne", "d", "n", "re", "ae", "ie", "ce", "be", "ed", "ze", "pe"]}}
{"id1": "15129155", "id2": "7908169", "code1": "    public List<String> extractUrlList(String url) throws IOException, XPathExpressionException {\n        LinkedList<String> list = new LinkedList<String>();\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        Tidy tidy = new Tidy();\n        tidy.setErrout(new NullPrintWriter());\n        Document doc = tidy.parseDOM(conn.getInputStream(), null);\n        int len = conn.getContentLength();\n        if (len <= 0) len = 32000;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream(len);\n        PrintStream ps = new PrintStream(bout);\n        tidy.pprint(doc, ps);\n        ps.flush();\n        String content = bout.toString();\n        Pattern p = Pattern.compile(\"(http://[\\\\w\\\\\\\\\\\\./=&?;-]+)\");\n        Matcher m = p.matcher(content);\n        while (m.find()) {\n            list.add(m.group());\n        }\n        return list;\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 0, "substitutes": {"extractUrlList": ["extractURLString", "extractUrList", "extractFileList", "extractedURLlist", "extractURLlist", "extractedUrlFrom", "extractUrFrom", "extractedURLList", "extractedUrlList", "extractFilelist", "extractedUrlString", "extractUrlist", "extractFileFrom", "extractURLFrom", "extractedUrllist", "extractUrlFrom", "extractUrString", "extractedURLFrom", "extractFileString", "extractUrllist", "extractedURLString", "extractURLList", "extractUrlString"], "url": ["mail", "Url", "name", "link", "hub", "html", "path", "string", "ret", "xml", "mount", "file", "location", "b", "log", "ssl", "host", "build", "id", "base", "dl", "uri", "web", "http", "nl", "page", "q", "sl", "str", "ll", "address", "ref", "loc", "rel", "l", "URL", "ls", "ur", "ul", "addr"], "list": ["sequence", "group", "array", "now", "filter", "and", "pool", "add", "menu", "drop", "detail", "temp", "all", "log", "limit", "map", "top", "queue", "batch", "the", "cont", "lists", "left", "conf", "set", "single", "st", "collection", "out", "load", "relation", "csv", "l", "table", "total", "get", "output", "LIST", "tree", "dict", "show", "print", "level", "ist", "pair", "control", "ul", "li"], "conn": ["obj", "ch", "cert", "init", "ws", "resp", "socket", "comm", "org", "cb", "enc", "nt", "ait", "connect", "cmd", "pg", "serv", "close", "j", "conv", "res", "pas", "nc", "cur", "gate", "out", "loc", "jp", "proc", "ctx", "client", "open", "con", "connection", "exec", "co", "Conn", "net", "ct", "cp", "addr"], "tidy": ["ttiddy", "tsyd", "ctweed", "Tiddy", "tridy", "tinker", "htriage", "toy", " tinker", "htidy", "tsoy", "Tyd", "hiddy", "tyd", "htoy", " toy", "hoy", "Tiy", " tyd", "ctidy", "ctoy", "tsweed", " Tiy", "Tidy", "hriage", " tweed", "tiddy", "ttiy", " Tidy", "triage", "trinker", "htiddy", "stiddy", "ttidy", " Tiddy", "ctyd", "tsidy", "tryd", "stidy", "tweed", "hidy", "striage", "stoy", "tiy", "Tinker"], "doc": ["msg", "html", "go", "pp", "mat", "def", "xml", "g", "man", "dec", "json", "file", "div", "b", "h", "dat", "local", "data", "j", "Doc", "base", "oc", "coll", "cam", "body", "in", "str", "md", "t", "out", "d", "db", "word", "dir", "tree", "dict", "js", "document", "dr", "mk"], "len": ["hl", "ell", "elt", "ls", "cap", "ln", "lim", "vol", "cmp", "bytes", "lon", "enc", "nt", "seq", "cl", "syn", "lit", "pos", "gl", "fil", "limit", "L", "val", "conv", "ld", "num", "kl", "lp", "dl", "coll", "nl", "sl", "el", "lf", "mil", "fl", "str", "ll", "en", "t", "lib", "loc", " clen", "l", "length", "wid", "Len", " le", "lan", "vec", "lic", "cod", "size", "Length", "n"], "bout": ["bbOut", "bbout", "nbOut", " bop", "bdOut", "nboss", "nbres", "bdco", "fboss", "bco", "rboss", "fbres", "fbOut", " boss", "bboss", "rbop", "bnet", " bco", "bbco", "boss", "fbout", "rbOut", "bbnet", "bOut", "rbout", " bnet", "bbres", " bOut", "bdout", "nbout", "bop", "bdnet", "bres", "bbop"], "ps": ["fps", "cs", "pl", "pp", "pres", "ips", "pse", "ts", "bs", "rs", "PS", "ats", "Ps", "ups", "aps", "sys", "ys", "gs", "amps", "pps", "pa", "phys", "fs", "pins", "pas", "mp", "its", "ops", "ms", "ins", "out", "pers", "pr", "vs", "jp", "ress", "eps", "pt", "sp", "ks"], "content": ["name", "sequence", "string", "version", "pattern", "xml", "description", "message", "current", "expression", "json", "value", "source", "layout", "context", "reason", "data", "template", "example", "media", "result", "comment", "c", "cont", "Content", "body", "text", "code", "condition", "lc", "cm", "output", "tree", "script", "document", "ontent", "format"], "p": ["fp", "pc", "ip", "pp", "hp", "per", "pattern", "g", "v", "perm", "pro", "b", "par", "h", "np", "ap", "parser", "P", "pa", "lp", "rep", "ping", "q", "op", "t", "pr", "jp", "pb", "pkg", "policy", "pat", "re", "sp", "cp", "pe", "tp"], "m": ["sm", "arm", "M", "nm", "mi", "am", "fm", "mo", "dm", "mm", "um", "man", "perm", "managed", "gm", "i", "h", "mod", "me", "om", "rem", "esm", "mol", "c", "mx", "pm", "rm", "km", "md", "ms", "hm", "mask", "mn", "bm", "d", "cm", "mr", "em", "tm", "vm", "mc", "mt"]}}
{"id1": "21308543", "id2": "6558022", "code1": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 0, "substitutes": {"copyFile": ["clonefile", "cpFiles", "cloneDirectory", "cpfile", "CopyFile", "cpDirectory", "copyDirectory", "CopyFiles", "cpFile", "cloneFiles", "Copyfile", "CopyDirectory", "copyFiles", "cloneFile", "copyfile"], "src": ["ix", "Source", "sec", "obs", "init", "ripp", "inst", "sq", "rs", "subject", "sr", "sb", "rx", "source", "start", "sys", "sit", "ipl", "fx", "usc", "cont", "ctr", "rl", "st", "cur", "sur", "ins", "ser", "loc", "usr", "rel", "pkg", "sc", "req", "rc", "js", "rt", "ur", "iv"], "target": ["delete", "link", "parent", "other", "replace", "dest", "touch", "nt", "bolt", "arg", "mac", "Target", "file", "source", "start", "goal", "eth", "tt", "ARGET", "arget", "next", "that", "template", "match", "gt", "top", "result", "base", "the", "set", "t", "test", "rel", "jp", "output", "term", "to", "patch", "mk", "stop"], "ic": ["ix", "mic", "pc", "iac", "ib", "ip", "ac", "bc", "irc", "it", "arc", "eric", "tic", "anc", "iu", "sic", "cli", "cit", "i", "nic", "ci", "aic", "fc", "icc", "ik", "pic", "ico", "cu", "ican", "icing", "lc", "vc", "IC", "wic", "isc", "rc", "ice", "ics", "cin", "ric", "iq", "ia"], "oc": ["mic", "pc", "ac", "bc", "soc", "ocon", "irc", "ec", "cc", "arc", "ocr", "ox", "toc", "OC", "anc", "od", "roc", "ko", "osc", "gc", "cos", "og", "nic", "ci", "aic", "yo", "oci", "oco", "mot", "c", "unc", "ot", "oct", "voc", "nc", "pic", "ico", "cu", "o", "cus", "ob", "rc", "isc", "oss", "co", "mc"]}}
{"id1": "14773780", "id2": "2807585", "code1": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"testImageInfo": [" testPhotoInfo", " testImagesData", "checkPhotoInfo", " testImagesFile", "checkPhotoList", " testPhotoData", "checkImageInfo", " testImageData", "checkImageFile", "checkPhotoFile", " testImagesList", "checkImageList", "checkImageData", " testImageFile", " testImageList", " testImagesInfo", "checkPhotoData", " testPhotoFile", " testPhotoList"], "IOException": [" IOEx", " IOProblem", "AudioException", "IOEx", "APIException", "AudioProblem", "APIProblem", "AudioEx", "APIEx", "IOProblem"], "start": ["offset", "init", "first", "it", "now", "begin", "before", " started", "birth", "starting", "art", "read", "parse", "id", "step", "base", "from", "time", "send", "wait", "enable", "set", "st", "check", "t", "create", "started", "seed", "wind", " Start", "open", "get", "end", "trans", "reset", "size", "Start", "print", "rest"], "i": ["ix", "name", "im", "bi", "go", "init", "key", "p", "is", "it", "x", "mi", "phi", "gi", "ui", "g", "ex", "si", "major", "info", "u", "b", "gu", "ti", "ci", "me", "multi", "j", "di", "conv", "id", "xi", "f", "m", "batch", "iq", "q", "uu", "y", "ic", "in", "qi", "out", "us", "o", "ai", "I", "s", "to", "n", "my", "pi", "yi", "sim", "index", "ind", "li"], "url": ["mail", "Url", "link", "external", "path", "key", "string", "pattern", "xml", "ul", "r", "u", "mount", "location", "log", "gl", "resource", "host", "id", "dl", "base", "uri", "res", "web", "http", "q", "nl", "el", "str", "ll", "ref", "rel", "l", "null", "lr", "URL", "gif", "ls", "ur"], "istream": ["ositream", "ositiver", "istorage", "istroy", "istable", "ISTstream", "itream", "iptream", "ositrace", "iptorage", "istrace", "iptstream", "itable", "istiver", "intable", "intream", "iststream", "astorage", "astroy", "iptroy", "ISTream", "ISTorage", "aststream", "ISTroy", "astream", "ositable", "itrace", "intiver", "itiver", "intrace"], "ii": ["ni", "nai", "cgi", "ri", "mi", "chi", "gi", "ji", "si", "ini", "hi", "ami", "iu", "irm", "cli", "ista", "iso", "imi", "sci", "cci", "ti", "ci", "zi", "di", "oci", "iov", "xi", "fi", "obi", "iii", "iy", "II", "ei", "qi", "ij", "ki", "iri", "jj", "ai", "vi", "ice", "yi", "pi", "iti", "ati", "ia", "ushi", "li"], "width": ["wy", "len", "path", "wa", "shape", "x", "const", "wn", "dim", "Width", "foo", "w", "dx", "idth", "value", "min", "layout", "data", "fw", "step", "cut", "left", "scale", "body", "draw", "frame", "crop", "text", "widget", "weight", "tall", "write", "length", "wid", "position", "px", "cale", "size", "window", "area", "format"], "height": ["hang", "volume", "radius", "amount", "chip", "gravity", "shape", "stroke", "def", "capacity", "acity", "above", "cue", "grow", "div", "buffer", "rank", "resolution", "h", "padding", "kw", "density", "frame", "depth", "green", "alpha", "history", "angle", "length", "family", "dimension", "rise", "Height", "size", "window", "sky", "style"], "stop": ["delete", "Stop", "obj", "counter", "est", "shape", "jump", "termination", "it", " Stop", "delay", "wake", "peak", "disable", "success", "gc", "quit", "fin", "close", "next", "trip", "hop", "id", "result", "step", "pop", "wait", "enable", "pause", "ops", "set", "st", "no", "loop", "duration", "term", "null", "end", "skip", "period", " STOP", "rest"]}}
{"id1": "949327", "id2": "4599372", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"f": ["fp", "name", "rf", "fab", "tf", "path", "exp", "fed", "p", "it", "def", "ret", "fm", "fax", "fo", "fn", "v", "g", "F", "info", "r", "w", "e", "file", "b", "filename", "h", "fx", "fa", "j", "fw", "fc", "m", "c", "base", "fs", "fi", "fd", "elf", "q", "bf", "lf", "y", "form", "t", "sf", "test", "o", "d", "cf", "l", "ft", "dir", "n", "fac", "fr", "fb", "df"], "in": ["inn", "im", "al", "inc", "up", "init", "ac", "is", "it", "inner", "isin", "ex", "add", "r", "din", "info", "mm", "all", "make", "nin", "bin", "h", "log", "io", "gin", "local", "on", "m", "from", "again", "In", "ic", "ins", "t", "en", "er", "IN", "at", "o", "by", "l", "lo", "get", "iter", "ai", "con", "n", " din", "ma", "cin", "rin", "input", "re", " IN", "pi", "reader", "inf", "oin", "ind", "thin"], "cbuf": ["cfuf", "rbbuf", "bcuff", "rboff", "abbbuf", "rbuf", "cduff", "cbdf", "cbbf", "cduf", "rbfg", "cdbuf", "CBf", "cbf", "cdoff", "sbbuf", "cfuff", "sbuff", "CBbuf", "nbbuf", "nbuff", "cduffy", "cbuff", "cff", "gbf", "sbuf", "rbather", "abbdf", "cfbf", "CBuffy", "CBbf", "gbbf", "nbfg", "rbuff", "CBuff", "sbather", "bcdf", "rbuffy", "gbuf", "bcfg", "cbuffy", "cbfg", "abbfg", "gbuff", "CBuf", "cbbuf", "cbather", "bcather", "rbdf", "cboff", "abbuf", "bcbuf", "nbuf", "bcoff", "bcuf"], "read": ["scan", "link", "is", "stream", "ready", "old", "reads", "pack", "buffer", "io", "data", "ly", "ead", "saw", "set", "range", "text", "miss", "iter", "count", "core", "end", "seek", "skip", "input", "readable", "trust", "index", "pe", "ind", "READ", "clear", "est", "ignore", "bind", "height", "fail", "ret", "current", "r", "start", "error", "sync", "report", "send", "poll", "depth", "mem", "Reader", "slow", "hold", "row", "ink", "raw", "view", "ip", "orig", "burst", "select", "find", "reach", "reading", "se", " Read", "ed", "value", "hello", "query", "rank", "k", "parse", "give", "record", "rate", "dev", "mix", "ank", "wait", "q", "chain", "load", "test", "length", "ke", "ai", "roll", "re", "print", "handle", "key", "it", "x", "add", "shift", "run", "connect", "allow", "feed", "log", "close", "default", "ext", "think", "check", "play", "pre", "write", "ok", "open", "get", "need", "reader", "n", "fill", "Read"], "totRead": ["tottWrit", "totalCheck", "totReader", "ltotRead", "toteAdd", "toteFind", "tcotDisplay", "atotaPrint", "tottNeed", "notaLoad", "trotRead", "totNeed", "trotFind", "retotReader", "ttottAdd", "tiatFill", "tOTFind", "totaBuild", "tokLoad", "notPrint", "totCheck", "tacotCheck", "taotConnect", "tfatWrite", "totPrint", "tobyPrint", "totAdd", "notalLoad", "tottAdd", "totaLoad", "totaFind", "tOTRead", "tiatVal", "notRead", "tiotBreak", "totaNeed", "notalNeed", "totBreak", "tiotVal", "ptotFind", "tottedRead", "trotWrite", "ttottNeed", "taotRead", "taotDisplay", "totalWrite", "totWrit", "totalLoad", "tobyCheck", "ptotWrite", " totRun", " totLength", "tiotFill", "totalFind", "tobyNeed", "ptOTFind", "retotRead", "tobyLoad", "tcotSend", "totaDisplay", "toteWrite", "tootRead", "tootConnect", "tiatSend", "ttotNeed", "retottPrint", "totalNeed", "tcotCheck", " toteRead", "letrotFind", "tootCheck", "atotaFill", "toiotRead", "totalLength", "letotSee", "totHave", " totalRead", "letrotSee", "taotCheck", "notalCheck", "ltotBuild", "tootDisplay", " totFind", "ptOTLoad", "tacotConnect", "tottReader", "tiotRead", " totalBuild", "ttotRead", "tootBreak", "tootVal", "tcotBreak", "tcotConnect", "tottWrite", "notaRead", "totaCheck", "totRun", "tiotHave", "atotHave", "ptOTWrite", "tiatBuild", "letotFind", " toteFind", "totSend", "toteNeed", "trotSee", "tokFind", "ptotLoad", "totalSee", "notCheck", "tcotVal", "totaRead", "toiotSend", "totVal", "totaPrint", "notReader", "totedHave", "tottedReader", "tiotSend", " toteRun", "tacotRead", "totFill", "tacotDisplay", "toteReader", "totaConnect", "totaLength", "tobyWrite", "tiatLoad", "toteLoad", " totBuild", "tiotReader", "tottRead", "atotaHave", "totDisplay", "toteRead", "totaAdd", " totWrite", "ptotRead", "ltotFill", "notalRead", "totaHave", "toticRead", "tokWrite", "tiatRead", "tottRun", "tOTLoad", "totConnect", "totSee", "tOTWrite", "ttotWrite", "toiotBreak", "notLoad", "totedPrint", "toteRun", "letrotRead", "letrotWrite", "tottedWrit", "totalBuild", "notWrite", "atotPrint", "tiotPrint", "totLoad", "toiotVal", "retottWrit", "toteFill", "toteBuild", "ltotaRead", "totLength", "letotRead", "toticWrite", "totalPrint", "totWrite", "atotaRead", "tiotWrit", "notalPrint", "retotPrint", "retottReader", "atotRead", "ltotaLoad", "ltotaFill", "totaReader", "tiatBreak", "tcotRead", " totalWrite", "totaSee", "ltotLoad", "totedRead", "notalWrite", "tootSend", "ltotaBuild", "totalRead", "toticFind", "notNeed", "atotFill", " totalLength", "notaReader", "totaFill", "tokRead", "toteLength", "totBuild", "tOTNeed", "tobyRead", "ptOTRead", "tottFind", "letotWrite", "tottPrint", "ttottRead", "notaWrite", "tfatReader", " toteWrite", "totaWrite", "retotWrit", "ttottWrite", "toticRun", "totedFill", "retottRead", "tfatRead", "totFind", "tfatLoad", "ttotAdd", "tottedPrint"], "out": ["auto", "obj", "up", "ch", "writer", "Out", "g", "ex", "v", "r", "w", "aos", "b", "sys", "log", "io", "conv", "c", "res", "we", "or", "t", "at", "o", "OU", "write", "output", "con", "os", "to", "oss", "end", "co", "s", "outs", "OUT", "net", "n", "ou"], "i": ["ix", "im", "php", "p", "is", "phi", "ui", "v", "hi", "info", "ski", "io", "ci", "multi", "di", "uri", "ei", "set", "ic", "ity", "qi", "ico", "I", "my", "sim", "ia", "index", "ind", "ii", "si", "r", "integer", "e", "iu", "point", "xi", "m", "iii", " I", "ki", "ice", "ip", "ri", "you", "this", "g", "mm", "\u0438", "cli", "me", "zi", "id", "c", "q", "y", "ims", "ij", "chain", "o", "ai", "ie", "print", "bi", "init", "oi", "any", "mi", "it", "x", "gi", "ji", "ini", "ami", "um", "b", "ion", "ti", "j", "iy", "status", "PI", "t", "us", "l", "client", "to", "s", "pi", "iq", "dr", "li"]}}
{"id1": "5977352", "id2": "19739421", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpFiles", "cpfile", " cpfile", "cpFolder", " cpFile", "copyFolder", "cpFile", " copyFolder", " cpFiles", "copyFiles", "copyfile", " copyFiles", " cpFolder", " copyfile"], "src": ["Source", "sec", "orig", "init", "inst", "sq", "rs", "via", "sr", "sb", "source", "start", "sys", "sit", "ipl", "from", "cont", "ctr", "rl", "st", "img", "ins", "cur", "sf", "ser", "loc", "usr", "rel", "pkg", "sc", "req", "rc", "input", "SOURCE", "rest"], "dest": ["port", "name", "origin", "est", "orig", "nom", "del", "comp", "parent", "Dest", "none", "master", "nt", "nw", "target", "copy", "temp", "lit", "source", "de", "opt", "etc", "sit", "comb", "tmp", "dat", "coord", "gt", "result", "txt", "cont", "decl", " dst", "good", "st", "desc", "spec", "them", "loc", "test", "usr", "foreign", "tif", "dir", "null", "end", "dist", "trans", "tom", "self", "th", "sp", "cat", "rest", "mk", "cp"], "bufSize": [" bufLen", "bcLen", "bcNum", "ufNum", "fontNum", "fontSize", "bcSize", " bufferSize", "fontSIZE", " bufSIZE", " bufferNum", "bufSIZE", "bufNum", "bcSIZE", "ufSIZE", "ufSize", "bufLen", "ufLen", " bufNum", " bufferSIZE"], "force": ["remote", "auto", "use", "stall", "apply", "replace", "forge", "safe", "allow", "cmd", "flag", "raise", "forces", "close", " Force", "default", "error", "f", "base", "only", "send", "enable", "command", "forced", "quote", "draw", "frame", "check", "form", "rule", "fast", "always", "write", "Force", "co", "forcing", "require", "reset", "ce", "print", "kill", "fill"], "buffer": ["attribute", "sequence", "cache", "view", "shape", "display", "message", "memory", "sample", "device", "stack", "temp", "number", "variable", "limit", "buf", "Buffer", "template", "library", "queue", "batch", "base", "comment", "command", "quote", "frame", "text", "mem", "buff", "binary", "history", "phrase", "table", "paste", "length", "word", "total", "block", "tree", "row", "print", "document", "window"], "read": ["scan", "im", "READ", "len", "shape", "raw", "find", "height", "bind", "reading", "stream", "before", "add", "r", "reads", " Read", "w", "run", "connect", "allow", "feed", "ind", "through", "hello", "query", "start", "i", "push", "next", "give", "parse", "record", "send", "wait", "valid", "q", "check", "str", "range", "text", "t", "set", "load", "write", "length", "open", "get", "hold", "iter", "req", "count", "request", "end", "word", "row", "input", "readable", "need", "size", "pass", "print", "reader", "index", "fill", "pe", "Read"], "in": ["inn", "im", "al", "inc", "up", "ln", "include", "init", "mi", "it", "is", "ain", "per", "sin", "inner", "isin", "ini", "din", "info", "mm", "irm", "source", "all", "bin", "i", "internal", "gin", "local", "on", "m", "from", "In", "or", "ic", "check", "inside", "ins", "t", "en", "IN", "o", "doc", "l", "get", "con", "iter", "ma", "n", "co", "cin", "rin", "input", "ie", "ar", "inf", "ind", "cn"], "out": ["obj", "cache", "up", "not", "ch", "conn", "ln", "writer", "it", "Out", "inner", "g", "ex", "v", "nt", "mit", "oe", "aos", "outer", "flush", "ent", "ns", "cmd", "file", "b", "all", "sys", "cos", "io", "om", "one", "conv", "gt", "on", "ou", "again", "sum", "ot", "br", "or", "op", "t", "at", "o", "ne", "write", "l", "output", "client", "os", "con", "to", "oss", "end", "co", "list", "outs", "OUT", "net", "can", "n", "cn"]}}
{"id1": "9805906", "id2": "397240", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"dump": [" show", "zip", "link", "println", "stat", "init", " println", " debug", "display", "info", "copy", "flush", "download", "update", "debug", "read", "export", " dumps", "save", "send", "store", "load", " describe", "write", "show", "diff", "print", " dumped"], "source": ["remote", "Source", "sequence", "view", "origin", "parent", "init", "image", "shell", "select", "ource", "scope", "src", "se", "sample", "info", "copy", "file", "config", "start", "sys", "resource", "local", "template", "from", "search", "site", "java", "form", "sql", "store", "service", "check", "text", "spec", "iter", "input", "ie", "script", "ink", "SOURCE", "style"], "target": ["delete", "link", "it", "pattern", "replace", "dest", "current", "bolt", "arg", "copy", "mac", "Target", "file", "goal", "compatible", "host", "arget", "next", "local", "that", "template", "match", "gt", "top", "project", "base", "t", "test", "proxy", "table", "output", "tif", "term", "null", "to", "style"], "is": ["tis", "im", "bits", "are", "ib", "ri", "ois", "ip", "init", "it", "iss", "act", "si", "isin", "mos", "isa", "sis", "iso", "Is", "isf", "i", "ys", "sys", "ris", "ir", "es", "IS", "xs", "abs", "bis", "its", "ic", "in", "ios", "isl", "ims", "ins", "ms", "has", "ists", "ais", "iris", "ai", "s", "isc", "oss", "ics", "isi", "ls", "ist", "ar", "nis", "lis", "ii"], "os": ["bos", "obs", "oes", "cs", "ose", "Os", "ols", "css", "ts", "bs", "uts", "oS", "ps", "ox", "ds", "mos", "aos", "ns", "ants", "ost", "pos", "sys", "cos", "io", "ss", "OS", "es", "fs", "osi", "ot", "or", "ios", "nos", "o", "oses", "los", "dos", "s", "oss", "ros", "js", "outs", "ows", "ls", "oos"], "done": ["loaded", "disabled", "die", "enabled", "created", "continue", "progress", "flag", "given", "de", "Done", "di", "ded", "checked", "later", "filled", "complete", "needed", "only", "shown", "ished", "valid", "du", "led", "set", "seen", "dirty", "started", "d", "des", "finished", "made", " Done", "expected", "pleted", "did", " continued", "gone", "desc", "failed", "found"]}}
{"id1": "15362793", "id2": "15768167", "code1": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"ReadURL": ["readUR", " readUrl", " ReadUrl", "readString", " ReadString", "readUrl", " readURL", " readString", "readURL", "ReadUrl", "ReadString", "ReadUR", " ReadUR", " readUR"], "url": ["Url", "link", "name", "html", "conn", "path", "key", "p", "char", "xml", "job", "mount", "file", "b", "ssl", "build", "bel", "call", "f", "base", "dl", "uri", "nl", "http", "page", "el", "q", "str", "ll", "browser", "address", "rect", "un", "l", "request", "URL", "ls", "ur", "ul"], "textonly": [" textall", " textOnly", "inputfirst", "inputOnly", " textrender", "textfirst", "TextOnly", "readOnly", "Textonly", "textall", "Textall", "readrender", "readonly", "textrender", "inputonly", "readall", "readfirst", "textOnly", " textfirst", "inputrender"], "uconn": ["puConn", "uuiss", "cuconn", "uConn", "pucon", "uiss", " uConn", "uucert", "Ucon", "uuconn", "uphys", "puphys", " ucon", "cucert", "Uconn", "uucon", "ucon", " uphys", "UConn", "Ucert", "ucert", "cucon", "Uiss", "cuiss", "puconn", "Uphys"], "ucont": ["uphonto", "cuont", "uscdet", "bcond", "ucond", "unicannot", "unicong", "uuond", "uphont", "ucdet", "uscond", "uscong", "ancont", "uuong", "uvont", "uudet", "uuont", "ancany", "uphannot", "uccront", "cunt", "usercount", "uccont", "ucany", "ancront", "uvrypt", "uniconto", "uphrypt", "bcnt", "unicdet", "ucnt", "ucict", "usercont", "uccict", "unicrypt", "uccany", "usercnt", "uvonto", "ucong", "uscont", "uconto", "cuount", "bcont", "unicont", "uvannot", "cuond", "ucrypt", "usercond", "bcount", "unicront", "ancict", "unicond", "unicict", "ucount", "unicany", "ucannot", "ucront"]}}
{"id1": "17337238", "id2": "22411381", "code1": "    private Retailer create() throws SQLException, IOException {\n        Connection conn = null;\n        Statement st = null;\n        String query = null;\n        ResultSet rs = null;\n        try {\n            conn = dataSource.getConnection();\n            st = conn.createStatement();\n            query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId() + \")\";\n            st.executeUpdate(query, new String[] { col.id });\n            rs = st.getGeneratedKeys();\n            if (!rs.next()) {\n                throw new SQLException(\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n            }\n            int genId = rs.getInt(1);\n            rs.close();\n            saveDescr(genId);\n            conn.commit();\n            Retailer ret = new Retailer();\n            ret.setId(genId);\n            ret.setTitle(title);\n            ret.setDescr(descr);\n            RetailerViewer.getInstance().somethingUpdated();\n            return ret;\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (Exception e1) {\n            }\n            throw e;\n        } finally {\n            try {\n                rs.close();\n            } catch (Exception e) {\n            }\n            try {\n                st.close();\n            } catch (Exception e) {\n            }\n            try {\n                conn.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 1, "substitutes": {"create": [" write", "copy", "construct", "run", "Create", "creat", "update", " regenerate", "creation", "record", " creator", "save", " monitor", " derive", " created", " creation", "store", " migrate", "insert", " validate", "write", "ctor", "edit", "creator", " restore", " recreate", "CRE"], "IOException": ["ioExit", "IRException", "ioException", "IOExit", " IOExit", "IRExit"], "conn": ["Connection", " con", "obj", "die", "ch", "cert", "ln", "gn", "yn", "resp", "addr", "org", "comm", "cc", "wd", "cb", "enc", "nt", "ds", "ns", "connect", "pen", "cmd", "pg", "config", "gc", "log", "ont", "err", "close", "j", "conv", "iw", "win", "c", "res", "reg", "conf", "ctr", "nc", "cur", "canon", "t", "gate", "bo", "db", "ctx", "cm", "client", "con", "pt", "req", "connection", "rc", "dt", "co", "js", "Conn", "dn", "net", "mc", "rt", "ct", "cp", "cn"], "st": ["sm", "stri", "stat", "est", "ln", "init", "inst", "statement", "ts", "sth", "sh", "put", "src", "bl", "se", "ist", "ut", "sb", "cl", "sy", "ost", "so", "start", "tt", "sta", "ld", "sw", "sts", "std", "sl", "set", "str", "ust", "sty", "t", "ast", "ste", "usr", "sn", "ST", "bt", "ft", "sc", "pt", "cr", "St", "end", "rest", "fr", "et", "irst", "sp", "rt", "mt", "ct", "ind", "stop"], "query": ["then", "util", "execute", "sequence", "path", "string", "statement", "Query", "qu", "select", "sq", "find", "message", "title", "menu", "lock", "ent", "how", "update", "question", "ion", "when", "read", "parse", "ql", "password", "call", "comment", "search", "q", "command", "quote", "sql", "body", "check", "str", "sol", "t", "condition", "test", "work", "table", "con", "row", "qa", "script", "transform", "show", "quest", "print", "ct", "eries", "state"], "rs": ["ls", "ras", "cs", "ri", "rd", "ws", "ts", "bs", "ps", "hr", "ats", "r", "ars", "ds", "rates", "sr", "stats", "src", "rr", "RS", "ys", "vers", "gs", "ris", "xs", "abs", "fs", "sts", "res", "rss", "rows", "rets", "rl", "ims", "ms", "ins", "rys", "vs", "Rs", "usr", "acks", "sels", "mr", "rc", "s", "ros", "js", "qs", "ows", "ks", "ues", "rt"], "genId": ["scanId", "generID", "gnid", "numInt", "generStr", "genInt", " genID", "genStr", "genID", "gnId", " genInt", "generId", "GENID", "GENId", "gnID", " genStr", "genById", "msgID", "msgById", "generById", "scanid", "genid", " genById", "GENInt", "numStr", "scanInt", "gnInt", "msgStr", "GENid", "numId", "msgId", "scanID", "generInt"], "ret": ["obj", "del", "aux", "repl", "info", "hist", "cmd", "success", "uf", "data", "cont", "res", "str", "ert", "iter", "rc", "elt", "news", "back", "def", "r", "title", "detail", "RET", "result", "det", "report", "reg", "rets", "red", "ref", "usr", "pub", "reset", "att", "mt", "fit", "tr", "resp", "g", "nt", "alt", "tmp", "val", "rem", "gt", "lt", "arr", "out", "dt", "re", "print", "desc", "rev", "it", "continue", "sys", "ext", "txt", "dl", "Ret", "t", "jp", "get", "ft", "reply", "rt", "dr"]}}
{"id1": "22441244", "id2": "17773263", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 0, "substitutes": {"send": ["mail", "sent", "execute", "msg", "init", "apply", "Send", "message", "add", "submit", "push", "transfer", "parse", "build", "export", "security", "save", "report", "set", "post", "create", "write", "get", "end", "reply", "print"], "hsession": [" HSession", "hhsession", "HSpace", "hship", "hhettings", "rsession", "hessions", "hsessions", "hhession", "hhessions", "hession", "hettings", "rssession", " HSpace", "hssession", "hhip", "rsess", "HSsession", "HSession", "HSessions", "rspace", " HSess", "HShip", "hhhip", "HSettings", " HSsession", "HSess", "hsettings", "hsess", "hspace"], "session": ["name", "cache", "sid", "view", "ip", "parent", "message", "job", "content", "lock", "event", "context", "manager", "password", "ess", "driver", "instance", "Session", "ession", "set", "store", "object", "client", "connection", "account", "document", "state"], "repositoryName": ["repositionNAME", "reposoryName", "repositablename", "repoositoryPath", "repositoryNAME", "repositoryData", "repoositoryName", "reposositoryName", "repositoryPath", "reposositoryData", "reposositoryPath", "repoitoryPath", "repoositoryname", "repositableData", "repoitoryTitle", "reposoryname", "reposositoryTitle", "repoositoryNAME", "repoitoryname", "repositableNAME", "repoitoryNAME", "repoositoryTitle", "repositorNAME", "repositorPath", "repositionPath", "repositorName", "repoitoryName", "reposositoryNAME", "repositoryTitle", "repositionName", "repositorTitle", "reposoryNAME", "reposoryData", "reposositoryname", "repositableName", "repositionTitle", "repoositoryData", "repoitoryData", "repositoryname"], "ideIdint": ["ideIdentint", "ideInfoINT", "ideIDline", "ideIdentline", " ideIdno", "ideidst", "ideThint", " ideThno", "ideDint", "ideDst", "ideIDind", "ideidint", "IDEidINT", "ideThline", "ideThno", " ideThline", "ideIdind", "ideIDno", "ideThind", "IDEidst", "ideIdline", "IDEIdINT", " ideThint", "IDEidint", "IDEIdint", "IDEIdst", "ideInfoint", "ideIdno", "ideIdINT", "ideIdentno", "ideIdentind", " ideIdind", "ideInfost", " ideThind", "ideIdst", "ideIDint", "ideDINT", "ideidINT", " ideIdline"], "to": ["auto", "ato", "eto", "tr", "about", "toc", "target", "tp", "pro", "pos", "tt", "TO", "tel", "top", "too", "phone", "po", "site", "company", "st", "ta", "range", "To", "t", "address", "contact", "no", "o", "by", "client", "os", "route", "co", "topic", "token", "addr"], "cc": ["cs", "cv", "ac", "CC", "ec", "cmp", "cb", "cloud", "cd", "tc", "toc", "cl", "cmd", "ck", "cci", "cca", "ci", "fc", "company", "ic", "ctrl", "ico", "cy", "dc", "cm", "cf", "sc", "cr", "rc", "ca", "co", "cin", "ce", "mc", "ct", "control", "cp", "cn"], "bcc": ["cbcc", "vcc", "sbcy", "cbck", "vck", "rbcy", "rbcm", "rbCC", "rbce", " bCC", "sbcc", "cbCC", "bcy", "bCC", "bck", " bck", "vce", "sbce", "cbcm", "bcm", " bcm", "sbck", "rbcc", "vcy", "bce", "rbck"], "subject": ["mail", "name", "metadata", "html", "header", "head", "description", "message", "content", "title", "Subject", "face", "source", "filename", "author", "host", "template", "id", "comment", "security", "uri", "form", "prefix", "heading", "text", "topic", "note"], "body": ["mail", "name", "zip", "url", "response", "html", "other", "any", "head", "shell", "news", "part", "back", "inner", "description", "bh", "message", "content", "title", "json", "params", "source", "b", "query", "buffer", "layout", "ody", "h", "data", "template", "padding", "default", "top", "files", "comment", "base", "report", "object", "post", "parts", "text", "code", "summary", "binary", "bill", "no", "output", "line", "null", "ODY", "inline", "background", "hex", "note", "business", "bytes", "handle", "Body"], "attachments": ["achmenttypes", "Attachresses", "attachachment", "achmentachment", "attments", "achmentresses", "achmentments", "attachtypes", "atttypes", "Attachtypes", "Attachments", "attachresses", "Attachachment", "attresses"], "isHtml": ["isChtml", " isWhtml", "isChip", " isHhtml", "ishap", " isWhHTML", "isVtml", "ishttp", "ishhtml", "isHttp", " isHip", "isHHTML", "isWhhtml", "isHap", "isHip", "isChhtml", "isChHTML", "IsHap", "isVHTML", "IsHttp", "isWhHTML", "IsHtml", "isWhip", "isJhtml", "isVip", " isWhip", "ishtml", "isJttp", " isWhhtml", "isVhtml", "isHhtml", "isJap", " isHHTML", "isJtml", "IsHhtml", "isWhtml"], "charset": ["CHippet", "chatsetter", "chippale", "charpetic", "chippET", "chARSets", "CHarsets", "quatsec", "CharsET", "charsale", "clarspace", "chablesec", "charpetter", "chersets", "chacterspace", "ChARSet", "quarsetter", "chARSet", "quatsetter", "chatsale", "chARSpace", "quarset", "charspace", "chippec", "CHarset", "channelsetic", "quatsale", "channelsET", "charsets", "chablesale", "chippets", "charpets", "charpET", "quarsec", "chippet", "charsec", "clarset", "charpet", "chersetter", "CHarsET", "CHippett", "ChARSetic", "Charset", "chARSetic", "CHippET", "clerset", "chacterset", "chARSetter", "Charsetter", "clarsets", "charsetter", "cherspace", "CHarsett", "charsett", "ChARSET", "clersets", "chactersetter", "ChARSetter", "quarsale", "cherset", "chatsec", "chablesetter", "charsET", "Charsetic", "charsetic", "clerspace", "clarsetter", "chactersets", "chippetter", "chARSET", "CHippets", "channelsetter", "channelset", "clersetter", "chableset", "chippett", "quatset", "chatset", "charpett"], "headers": ["metadata", "fields", "header", "head", "lines", "members", "ers", "heads", "users", "params", " heads", "relations", "comments", "keys", "authors", "ters", "files", " trailers", "ilers", "ppers", "details", "types", "ors", "codes", "limits", "names", "dr"], "priority": ["origin", "state", "order", "primary", "description", "title", "pos", "comments", "context", "profile", "password", "id", "phone", "security", "company", "status", "prefix", "serial", "grade", "policy", "position", " urgency", "flags", "due", "level", " severity", "properties"], "email": ["mail", "delete", "link", "url", "ell", "response", "view", "msg", "html", "die", "liner", "domain", "enter", "model", "external", "server", "shell", "initial", "document", "xml", "description", "fax", "gmail", "message", "sample", "entry", "Email", "oe", "database", "e", "detail", "label", "ee", "event", "all", "log", "ssl", "template", "password", "example", "call", "echo", "result", "ome", "comment", "il", "search", "report", "el", "http", "company", "instance", "object", "office", "console", "address", "element", "contact", "er", "test", "ne", "voice", "output", "line", "ilo", "license", "em", "et", "reset", "print", "note"], "user": ["name", "util", "ip", "User", "system", "auth", "owner", "usage", "entity", "users", "admin", "uid", "author", "profile", "me", "manager", "match", "id", "result", "person", "actor", "from", "login", "usa", "browser", "usr", "by", "client", "output", "USER", "creator", "account", "connection", "ident", "student", "used", "username", "use", "human"], "identity": ["entularity", "IDENTularity", "presentularity", "ethnicitate", "IDENTentity", "IDENTality", "identality", "primance", "recognance", "presentitate", "equity", "solidity", "ethnicentity", "IDENTicate", "personicate", "primentity", "personificate", "entity", "IDENTity", "instity", "IDENTance", "IDENTITY", "solidality", "recognentity", "identalty", "identator", "idiciary", "identiciary", "personity", "idality", "instator", "solidentity", "recognicate", "recognity", "idity", "instalty", "identicate", "idententity", "primicate", "ethnicity", "IDENTificate", "identITY", "personITY", "IDENTitate", "instentity", "primificate", "IDENTator", "identance", "identificate", "identifier", "ethnicularity", "IDENTifier", "identularity", "presententity", "ententity", "instularity", "solidularity", "personentity", "presentity", "IDENTalty", "entifier", "primity", "identitate", "equalty", "personiciary", "IDENTiciary", "idularity", "instifier", "idITY", "equentity", "equator"], "_returnPath": [" _returnAddress", "_returnName", "setsavepath", "_retPath", "_requestPoint", " _returnPoint", "_errorPath", " _errorPath", "setreturnpath", "_retpath", "setsaveTo", "setreturnUrl", "setreturnTo", "_errorUrl", "_ReturnAddress", " _errorAddress", "setreturnPath", "_returnCode", "_returnAddress", "_returnLocation", "_returnTo", "_deletePath", "_retPoint", "_retLocation", "_retUrl", "_errorAddress", "_savepath", "_replyPath", "_retTo", "_getTo", " _errorName", "_returnpath", "_replyDir", "_returnDir", "_saveTo", "_errorName", "_requestName", "_requestPath", "_ReturnName", "_requestAddress", "_resultTo", "_deleteTo", "_errorTo", " _returnName", " _errorPoint", "_replyCode", "_getDir", "_resultLocation", "_returnUrl", "_deletepath", "_ReturnPoint", "_errorpath", "_resultPath", "_retCode", "_getCode", "_savePath", "setsaveUrl", "_ReturnPath", "setsavePath", "_resultPoint", "_getPath", "_retDir", "_errorPoint", "_saveUrl", "_errorLocation", "_deletePoint", "_returnPoint"], "_from": ["longto", " _source", "letfrom", "_reset", "_addr", "\tauthor", "remaddr", "\tform", "_author", " _form", "remfrom", "longreset", "longfrom", "letto", "_about", " _actor", "_source", "remowner", "letabout", "\tfrom", "remlocal", "longsource", " _reset", "_local", "_owner", "_actor", " _author", "\tactor", " _about", "_form", "letsource"], "_replyTo": ["_closeTO", "_closeOf", "_ReplyTO", "_commentLine", "_returnTO", "_replyTO", "_replyLine", "_replyFrom", "_respondTo", "_responseFrom", "_commentTO", "_replyOf", "_respondTO", "_returnFrom", "_commentTo", "_ReplyTo", "_responseTo", "_responsePath", "_respondFrom", "_returnOnly", "_returnTo", "_backTo", "_responseLine", "_responseTO", "_backFrom", "_commentOf", "_closeTo", "_respondOnly", "_ReplyPath", "_replyPath", "_backPath", "_closeLine", "_ReplyFrom", "_ReplyOnly", "_replyOnly", "_responseOf", "_backTO"], "_to": ["_ta", "successta", "successtopic", "prisite", "successto", "prita", "pritopic", "prito", "successsite", "_topic", "_site"], "_cc": [" _cca", " _subject", " _cs", "_cs", "_subject", "_cca"], "_bcc": ["_rbcc", "_racc", "_wck", "_rbacc", "_wca", "_wcc", "_bca", "_bacc", "_wacc", "_rbck", "_rcc", "_rca", "_bck", "_rbca", "_rck"]}}
{"id1": "3375718", "id2": "23677147", "code1": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 1, "substitutes": {"importarHistoricoDeCotacoesDoDolar": [" importarHistoricoDeCotacoesDoV", " importarHistoricoDeCotacoesDOS", " importarHistoricoDeCotacoesdoS", " importarHistoricoDeCotacosDeDo", " importarHistoricoDeCotacoesDeDo", " importarHistoricoDeCotacoesDODo", " importarHistoricoDeCotacoesdoD", " importarHistoricoDeCotacoesDoD", " importarHistoricoDeCotacosDoD", " importarHistoricoDeCotacoesDOD", " importarHistoricoDeCotacosDeS", " importarHistoricoDeCotacosDoDo", " importarHistoricoDeCotacosDeV", " importarHistoricoDeCotacoesdoDo", " importarHistoricoDeCotacoesDoDo", " importarHistoricoDeCotacoesdoV", " importarHistoricoDeCotacosDeD", " importarHistoricoDeCotacosDoS", " importarHistoricoDeCotacoesDeD", " importarHistoricoDeCotacoesDeS", " importarHistoricoDeCotacoesDOV", " importarHistoricoDeCotacosDoV", " importarHistoricoDeCotacoesDoS", " importarHistoricoDeCotacoesDeV"], "pAndamento": ["pAndantero", " pAndamente", " pAndementO", "pAndmente", " pAndamentro", "pAndanto", "pOrmentology", "pAndrollao", "pAndmentos", "pOrmentao", " pANDamentO", "pAndmentO", "pAndoddation", "pAndementos", " pAndente", "pAndemente", "pAndrollos", " pAndumentO", "pOramentation", "pAndoddos", "pOramentology", "pOrmentero", "pAndroyO", "pAndoddo", "pAndmentao", " pAndento", " pANDamento", "pOramento", "pOramentero", "pAndumentos", " pANDentro", "pAndrollology", " pAndementro", " pANDamente", " pAndemente", "pAndamentology", " pANDentO", "pAndemento", "pAndmentation", "pAndmento", " pAndemento", " pANDente", "pAndamentos", "pOrmentation", "pAndroyation", "pAndantos", "pOrmente", " pAndumente", "pOramentao", " pANDento", " pAndentro", "pOrmentos", "pOramentos", " pANDamentro", "pAndmentero", "pAndamentero", " pAndumento", "pOrmentO", "pAndante", "pAndroyo", "pAndroyos", "pAndumentology", "pOramentO", "pAndrollo", "pAndumentao", " pAndentO", "pOrmento", "pOramente", "pAndamentO", "pAndamente", "pAndamentao", " pAndumentro", "pAndoddO", "pAndementero", "pAndumento", "pAndmentology", " pAndamentO", "pAndamentation"], "cotacoesPendentesDoDolar": ["cotacoesPendentesDoSangular", "cotacoesPendentesDoDapor", "cotacoesPendentesDonDaur", "cotacoesPendentesDOSapor", "cotacoesPendentesDoDsolver", "cotacoesPendentesDOPolar", "cotacoesPendentesDoDaur", "cotacoesPendentesDePollar", "cotacoesPendentesDePolar", "cotacoesPendentesDoDsolar", "cotacoesPendentesDODollar", "cotacoesPendentesDOPars", "cotacoesPendentesDoPolid", "cotacoesPendentesDeDilar", "cotacoesPendentesDoDoaur", "cotacoesPendentesDoDoars", "cotacoesPendentesDODolars", "cotacoesPendentesDoDollar", "cotacoesPendentesDoEangular", "cotacoesPendentesDonEollar", "cotacoesPendentesDoDilar", "cotacoesPendentesDoBolar", "cotacoesPendentesDeDaur", "cotacoesPendentesDoDsars", "cotacoesPendentesDoPollar", "cotacoesPendentesDonEolar", "cotacoesPendentesDOPollar", "cotacoesPendentesDonDollar", "cotacoesPendentesDoSollar", "cotacoesPendentesDoDiollar", "cotacoesPendentesDoSolars", "cotacoesPendentesDoBapor", "cotacoesPendentesDoSarian", "cotacoesPendentesDoBolars", "cotacoesPendentesDonDolar", "cotacoesPendentesDoDsolder", "cotacoesPendentesDoDoolver", "cotacoesPendentesDODolder", "cotacoesPendentesDoDiolar", "cotacoesPendentesDoDiarian", "cotacoesPendentesDoSilar", "cotacoesPendentesDOSolder", "cotacoesPendentesDOSolars", "cotacoesPendentesDoSolar", "cotacoesPendentesDonDangular", "cotacoesPendentesDoDiaur", "cotacoesPendentesDODolver", "cotacoesPendentesDoPolver", "cotacoesPendentesDePolid", "cotacoesPendentesDoSolid", "cotacoesPendentesDODars", "cotacoesPendentesDeDarian", "cotacoesPendentesDOPolver", "cotacoesPendentesDoDolver", "cotacoesPendentesDoSaur", "cotacoesPendentesDoEolar", "cotacoesPendentesDePilar", "cotacoesPendentesDoDoangular", "cotacoesPendentesDeDolar", "cotacoesPendentesDODapor", "cotacoesPendentesDoDsapor", "cotacoesPendentesDoEollar", "cotacoesPendentesDoDolid", "cotacoesPendentesDeDollar", "cotacoesPendentesDoDars", "cotacoesPendentesDeDolid", "cotacoesPendentesDOSolar", "cotacoesPendentesDoDoollar", "cotacoesPendentesDoDsolars", "cotacoesPendentesDoDolder", "cotacoesPendentesDoSolder", "cotacoesPendentesDoDarian", "cotacoesPendentesDoPars", "cotacoesPendentesDoDsollar", "cotacoesPendentesDoBolder", "cotacoesPendentesDonEaur", "cotacoesPendentesDoDangular", "cotacoesPendentesDoDolars", "cotacoesPendentesDoDoolar", "cotacoesPendentesDoPolar", "cotacoesPendentesDODolar", "cotacoesPendentesDoEaur", "cotacoesPendentesDoSapor", "cotacoesPendentesDonEangular", "cotacoesPendentesDoPilar"], "sql": ["util", "url", "php", "stat", "html", "conn", "server", "fields", "answer", "string", "sq", "statement", "socket", "software", "shell", "xml", "description", "expression", "sb", "database", "temp", "json", "file", "params", "query", "log", "session", "sys", "ssl", "sd", "ss", "orm", "template", "data", "password", "ql", "sv", "dl", "base", "spr", "math", "general", "cfg", "q", "command", "http", "java", "virtual", "sol", "text", "serial", "spec", "condition", "binary", "csv", "seed", "db", "con", "null", "s", "sun", "SQL", "qs", "script", "platform", "net", "sp", "ls", "framework", "format"], "stmtDestino": ["stmmStination", "stmmdestino", "stmtDestINO", "stMTDestination", "stmtStINO", "stmmStino", "stMTdestino", "stmtDescin", "stmtDescino", "stmmdestinos", "stmtDestination", "stmmStin", "stmtStin", "stmtDestined", "stmtdestruction", "stMTdestination", "stmmDestinos", "stmtDestinos", "stmtDestruction", "stMTDestin", "stmtdestino", "stmmdestination", "stmtDeclination", "stmtStinos", "stmmDestin", "stmtDescruction", "stmtdestin", "stMTDestined", "stmtStination", "stMTStination", "stmtDeclined", "stmmdestin", "stmmDestination", "stmtdestination", "stmtdestinos", "stmtDeclino", "stMTStin", "stMTDestino", "stmtDescination", "stMTStruction", "stMTdestin", "stmtdestined", "stmtStruction", "stmtStino", "stmtDeclin", "stmtDestin", "stmmStINO", "stMTdestined", "stmmDestINO", "stmmDestino", "stMTDestruction", "stMTStino", "stmtdestINO"], "quantidadeDeRegistrosASeremImportados": ["quantidadeDeRegistrosASeremImportadas", "quantidadeDeRegistrosASeremPortables", "quantidadeDeRegistrosASeremsImportances", "quantidadeDeRegistrosASeremsPortados", "quantidadeDeRegistrosASeremPortados", "quantidadeDeRegistrosASeremimportadas", "quantidadeDeRegistrosASeremsPortadas", "quantidadeDeRegistrosASeremExportances", "quantidadeDeRegistrosASeremsImportables", "quantidadeDeRegistrosASeremimportances", "quantidadeDeRegistrosASeremPortances", "quantidadeDeRegistrosASeremsImportados", "quantidadeDeRegistrosASeremimportados", "quantidadeDeRegistrosASeremExportables", "quantidadeDeRegistrosASeremImportables", "quantidadeDeRegistrosASeremsImportadas", "quantidadeDeRegistrosASeremExportados", "quantidadeDeRegistrosASeremsPortables", "quantidadeDeRegistrosASeremExportadas", "quantidadeDeRegistrosASeremImportances", "quantidadeDeRegistrosASeremimportables", "quantidadeDeRegistrosASeremsPortances", "quantidadeDeRegistrosASeremPortadas"], "quantidadeDeRegistrosImportados": ["quantidadeDeRegistrosExportados", "quantidadeDeRegistroPortados", "quantidadeDeRegistrosPortados", "quantidadeDeRegistrosRestants", "quantidadeDeRegistroPortants", "quantidadeDeRegistroImportances", "quantidadeDeRegistrosRestadas", "quantidadeDeRegistrosExportadas", "quantidadeDeRegistroPortadas", "quantidadeDeRegistrosImportants", "quantidadeDeRegistroImportants", "quantidadeDeRegistrosExportants", "quantidadeDeRegistroImportadas", "quantidadeDeRegistrosImportadas", "quantidadeDeRegistrosRestados", "quantidadeDeRegistrosPortants", "quantidadeDeRegistrosExportances", "quantidadeDeRegistrosPortances", "quantidadeDeRegistroImportados", "quantidadeDeRegistrosImportances", "quantidadeDeRegistrosRestances", "quantidadeDeRegistrosPortadas", "quantidadeDeRegistroPortances"], "numeroDoRegistro": ["numeroDoRegISTros", "numeroDoRegistra", "numeroDoRegestros", "numeroDoRegistarros", "numeroDoRegisteredistration", "numeroDoRegistarrob", "numeroDoRegISTra", "numeroDoRegisteredistrob", "numeroDoRegestration", "numeroDoRegisteredistro", "numeroDoRegISTrob", "numeroDoREGISTro", "numeroDoRegestro", "numeroDoRegustro", "numeroDoRegistarro", "numeroDoRegisteredistros", "numeroDoRegisteredestros", "numeroDoRegustrob", "numeroDoRegistros", "numeroDoREGistros", "numeroDoRegestrob", "numeroDoRegisteredestration", "numeroDoRegISTro", "numeroDoREGistra", "numeroDoRegistsra", "numeroDoREGistrob", "numeroDoRegustros", "numeroDoRegistsros", "numeroDoREGistro", "numeroDoREGISTra", "numeroDoRegestra", "numeroDoRegistsrob", "numeroDoRegistrob", "numeroDoREGISTros", "numeroDoREGISTrob", "numeroDoRegistsro", "numeroDoRegisteredestro", "numeroDoRegisteredestrob", "numeroDoRegistration", "numeroDoRegistarration", "numeroDoRegustration"], "cotacaoPendenteDoDolar": ["cotacaoPendenteDOSolar", "cotacaoPendenteDoDaur", "cotacaoPendenteDoDolder", "cotacaoPendenteDoPolar", "cotacaoPendenteDoDolver", "cotacaoPendenteDoDoolder", "cotacaoPendenteDoDoaur", "cotacaoPendenteDOSollar", "cotacaoPendenteDoLarius", "cotacaoPendenteDoSolar", "cotacaoPendenteDODolars", "cotacaoPendenteDaDilar", "cotacaoPendenteDoLolar", "cotacaoPendenteDODaur", "cotacaoPendenteDoDars", "cotacaoPendenteDoPolars", "cotacaoPendenteDOPolar", "cotacaoPendentedoDilar", "cotacaoPendenteDoDoilar", "cotacaoPendenteDoDoolar", "cotacaoPendenteDoDiarius", "cotacaoPendenteDoMilar", "cotacaoPendenteDoVolder", "cotacaoPendenteDaDolar", "cotacaoPendenteDoDilar", "cotacaoPendenteDOSars", "cotacaoPendenteDoDoolars", "cotacaoPendenteDoPilar", "cotacaoPendenteDaDiilar", "cotacaoPendenteDoSaur", "cotacaoPendenteDODollar", "cotacaoPendenteDoDiollar", "cotacaoPendenteDoMolar", "cotacaoPendenteDODolar", "cotacaoPendenteDaDiolar", "cotacaoPendentedoPolver", "cotacaoPendenteDoTolar", "cotacaoPendenteDOPolder", "cotacaoPendenteDoDiolar", "cotacaoPendenteDaDiollar", "cotacaoPendenteDoVolar", "cotacaoPendenteDoSarius", "cotacaoPendenteDaDollar", "cotacaoPendenteDODars", "cotacaoPendentedoPilar", "cotacaoPendenteDoMolars", "cotacaoPendenteDoDiolver", "cotacaoPendentedoPolar", "cotacaoPendenteDoSilar", "cotacaoPendenteDoVolars", "cotacaoPendenteDoDarius", "cotacaoPendenteDoTollar", "cotacaoPendenteDoDiilar", "cotacaoPendenteDoVilar", "cotacaoPendentedoDolars", "cotacaoPendenteDoLilar", "cotacaoPendenteDaDiarius", "cotacaoPendenteDoPolder", "cotacaoPendentedoPolars", "cotacaoPendenteDoPolver", "cotacaoPendenteDoTaur", "cotacaoPendenteDaDarius", "cotacaoPendenteDoDollar", "cotacaoPendenteDOPolars", "cotacaoPendenteDoDiolars", "cotacaoPendentedoDolar", "cotacaoPendenteDOPilar", "cotacaoPendenteDoTars", "cotacaoPendentedoDolver", "cotacaoPendenteDOSaur", "cotacaoPendenteDoDolars", "cotacaoPendenteDODolder", "cotacaoPendenteDoSars", "cotacaoPendenteDODilar", "cotacaoPendenteDoLollar", "cotacaoPendenteDoMolder", "cotacaoPendenteDoDoollar", "cotacaoPendenteDoDoars", "cotacaoPendenteDoSollar"], "ano": [" nano", "onna", "nai", "lane", "auto", "ato", "online", "uno", "ata", "ania", "rano", "aito", "amia", "ona", "oda", "iso", "osa", "zon", "una", "nia", "nan", "nee", "onto", "atum", "nce", "oa", "awareness", "an", "nas", "ana", "ione", "apo", "ino", "atan", "\u00f3", "enna", "na", "aro", "anos", "orno", "avan", "ony", "iano", "aco", "sha", "uto"], "mes": ["eters", "mits", "mys", "mor", "pse", "mi", "mares", "tes", "ming", "xes", "mos", "dis", "mails", "sis", "nes", "mers", "mins", "vers", "anas", "me", "es", "ss", "ems", "pps", "ves", "mol", "ses", "mouse", "phys", "mot", "mx", "mate", "ims", "ms", "sels", "made", "jas", "mis", "les", "mens", "ls", "mas"], "dia": ["m\u00eda", "bdiae", "bdian", "Dian", "diae", "mian", " dian", "fd\u00eda", "miana", " diae", "Dia", "Diae", "mia", " diana", "bdia", "fdia", " d\u00eda", "fdiana", "d\u00eda", " diza", "dian", "bdiza", "fdian", "diza", "Diza", "diana"], "calendario": ["calendiarium", "alendarios", "calendairy", "calendirio", "chalendiery", "bookendateur", "calendararios", "alendario", "calenderrio", "calent\u00e9r", "calendary", "calendedario", "calended\u00e9r", "calendateur", "alendarium", "calendiar", "calendarie", "calendarary", "collendrio", "calendrio", "calenderarie", "bookended\u00e9r", "caleniery", "calenderario", "collendario", "calendrera", "calentario", "chalendairy", "calentateur", "calenderarios", "calendedarie", "calend\u00e9r", "alenderario", "calenderary", "calendiarie", "bookend\u00e9r", "calENDrera", "alenderary", "calenairy", "collendirio", "calendarium", "chalendarie", "calENDateur", "collendarie", "bookendedario", "calendarios", "bookendedateur", "calendiario", "calcendiery", "bookendrera", "alendary", "calendiery", "calcendarie", "calenderar", "calendedar", "alenderarium", "calendedrio", "collendiarie", "calendedateur", "calENDario", "collendiario", "calendedrera", "calendararium", "bookendedrera", "chalendario", "collendar", "calendiary", "bookendario", "calenario", "calcendairy", "calcendario", "calendarario", "calenderarium", "calentrera", "collendiar", "calEND\u00e9r", "calendiarios", "calenarie", "alenderarios", "calendar"], "vDATA": [" vdata", "VData", "avdata", "vdata", "mDATA", "jData", "jDATA", "mVO", "mData", "vVO", "VVO", " vData", "avVO", "jINFO", "avDATA", " vINFO", "mdata", "avData", "Vdata", "vINFO", "jdata", "vData", "VINFO", "VDATA"], "vPRECO": [" vPreCON", "vGRECOM", " vPREPO", " vPreCO", "vPreCO", "vCONCON", " vPRECON", "vPreCON", "vPREPO", "vGREPO", "vPrePO", "vPreCOM", "vGRECO", "vPRECON", "vCONCO", " vPRECOM", "vPRECOM", "vGRECON", " vPrePO", "vCONPO", "vCONCOM", " vPreCOM"]}}
{"id1": "3514286", "id2": "23517481", "code1": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"getHashedPassword": ["getHashPassword", "getShashedpassword", "getHackedSecret", "getHashesSecret", "getHackedPassword", "getHashedSecret", "getHashesUser", "getHashedpassword", "getShashedUser", "getHashesPassword", "getHashSecret", "getShashedSecret", "getHashedUser", "getHackedUser", "getShashUser", "getHashUser", "getHashpassword", "getShashPassword", "getShashpassword", "getShashSecret", "getHackedpassword", "getShashedPassword", "getHashespassword"], "password": ["attribute", "name", "key", "REDACTED", "string", "pattern", "wd", "description", "wordpress", "message", "database", "value", "Password", "email", "data", "padding", "default", "user", "login", "sword", "command", "prefix", "hash", "text", "address", "phrase", "word", "shadow", "input", "reset", "pass", "token", "username", "secret", "raw"], "digest": [" Digest", "Digest", "hashester", "dest", " digested", "Digester", " Digse", "hashested", "hashse", "mdest", "hashest", "dests", "digse", "mdester", "digests", " digse", "digested", "Digse", " digester", " digests", " Digester", "digester", "Digests", "dested", "Digested", "mdse", "mdests", "hashests"], "hashedInt": ["hashashingInteger", "hashInt", "hushedInteger", "hcheckedINT", "hashashingINT", "hashashedInt", "hashashedInteger", " hashedInteger", "hashInteger", "hashINT", "hashingINT", "hhedInteger", "hhedInt", "hushedId", "hashashedINT", "hcheckedInteger", " hashedTx", "happedId", "hhedTx", " hushedTx", " hashedId", "hashedINT", "happedInteger", " hushedId", "happedInt", "hhedId", "hashedInteger", " hushedInt", "hashingInt", "hcheckedInt", "hashingInteger", "happedTx", "hashashingInt", "hushedInt", "hashedId", " hushedInteger", "hashedTx", "hushedTx"]}}
{"id1": "7945594", "id2": "8062076", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "label": 0, "substitutes": {"fileDownload": ["FileDownload", "Filedownload", "fileGet", "urlDownload", "urldownload", "FileUpdate", "filedownload", "fileUpdate", " filedownload", "FileGet", " fileUpdate", " fileGet", "urlUpdate", "urlGet"], "fAddress": [" fAdd", "FOrder", "fAdmin", "FPart", " fURL", "fiAlias", "fdAlias", "xfValue", "fDomain", "vaddress", "sfContact", "fiAddress", "fdAddress", "pValue", "fdAdd", "hURI", "fiAdd", "hValue", "fdURL", "fAdd", "FAdd", "feAdd", "eAddress", "faddress", "feAddress", "sfOrder", "FAdmin", "eAdd", "fURL", "fLocation", "fValue", "pAdd", "xfAddress", "FContact", "fmPart", "feOrder", "eOrder", "fmAddress", "xfaddress", "sfPart", "fmContact", "vAddress", "fiaddress", " fAlias", "vDomain", "fContact", "fOrder", "fiDomain", "xfLocation", "pURI", "fPart", "eAdmin", "fAlias", "fmOrder", "fiLocation", "xfAdd", "xfURI", "hAddress", "feAdmin", "fURI", "fiURL", "xfDomain", "hAdd", "vLocation", "FAddress", "sfAddress", "pAddress"], "destinationDir": ["destificationFolder", "destinationFolder", "Destificationdir", "DestinationFolder", "destarationDirector", "destacementDir", "declificationDir", "destacementFolder", "Destinationdir", "destinationsDirectory", "destinationsFolder", "declinationDirectory", "declinationdir", "destineddir", "declinationDir", "destificationDir", "destacementdir", "DestificationFolder", "destinedDirector", "declificationDirectory", "destarationdir", "destinationsDir", "destinationsdir", "DestinationDir", "destarationDir", "declinationFolder", "DestificationDir", "destificationDirector", "DestificationDirector", "destinationDirectory", "DestinationDirector", "destarationFolder", "destinationdir", "destinedFolder", "destificationDirectory", "destinationDirector", "declificationdir", "destificationdir", "declificationFolder", "destacementDirectory", "destinedDir"], "slashIndex": ["fllashindex", "swasherNumber", "slasherIndex", "flashPosition", "slashesIndex", "sllashIndex", "slashedPosition", "slashesindex", "swashNumber", "swasherPosition", "swashCount", "slashesInd", "slashedNumber", "slashPosition", "swasherIndex", "fllashPosition", "slugPosition", "slashNumber", "swashPosition", "fllashIndex", "slashedIndex", "slashindex", "sllashNumber", "sllashInd", "slugInd", "sllashindex", "flashIndex", "swasherCount", "sllashCount", "slashesPosition", "fllashInd", "slashInd", "slugindex", "flashInd", "swashIndex", "sllashPosition", "slasherCount", "flashindex", "slasherNumber", "slashedCount", "slugIndex", "slashCount", "slasherPosition"], "periodIndex": ["periodMax", "tickCounter", "dollarPosition", "pieMax", "piePosition", "pieCounter", "periodCounter", "tickMax", "tickPosition", "pieIndex", "tickIndex", "dollarIndex", "periodPosition", "dollarCounter", "dollarMax"], "fileName": ["fileKey", " fileInfo", " fileKey", "pageKey", "pagename", "filename", "pageName", "FileInfo", "FileName", "FileKey", "Filename", "fileInfo", "pageInfo", " filename"], "url": ["mail", "Url", "util", "link", "hl", "pl", "conn", "cert", "raw", "org", "char", "ret", "xml", "r", "job", "u", "cl", "mount", "gl", "ssl", "build", "bel", "cal", "il", "base", "uri", "github", "web", "http", "nl", "el", "sl", "com", "or", "rl", "impl", "str", "ll", "browser", "address", "https", "loc", "rel", "un", "l", "client", "con", "www", "URL", "re", "ml", "ur", "ul"], "uc": ["bc", "soc", "ec", "cc", "ul", "tc", "userc", "anc", "um", "cl", "ci", "uf", "fc", "c", "usc", "unc", "oc", "ux", "ucc", "nc", "cur", "cu", "us", "lc", "dc", "loc", "ub", "sc", "cus", "con", "cr", "rc", "co", "UC", "auc", "mc", "uu"], "in": ["inn", "inc", "al", "ln", "init", "is", "it", "and", "inner", "isin", "r", "din", "mm", "ze", "bin", "i", "io", "read", "gin", "on", "f", "il", "In", "conf", "body", "ic", "ins", "en", "IN", "l", "ill", "con", "iter", " din", "input", "rin", "cin", "re", "mc", "reader", "inf", "ind"], "file": ["ile", "fp", "name", "zip", "port", "view", "path", "File", "image", "model", "handle", "task", "fo", "message", "log", "filename", "resource", "io", "fil", "local", "data", "FILE", "result", "f", "base", "type", "po", "page", "form", "piece", "spec", "db", "table", "output", "to", "print", "document", "pdf", "format"], "fos": [" fof", "Fo", " foes", " fios", "fOS", "wOS", "tos", "fo", "foes", "fios", "woss", "tOS", "floes", "flos", "flios", "wos", "foss", "Foss", "Fios", "FOS", "flof", "Fos", "Fof", "wo", "Foes", "to", "toss", "fof"], "out": ["writer", "it", "news", "Out", "inv", "inner", "g", "ex", "v", "nt", "w", "outer", "flush", "dis", "all", "cos", "io", "conv", "crit", "sum", "ot", "conf", "st", "set", "at", "o", "OU", "write", "output", "gr", "con", "os", "to", "end", "co", "outs", "OUT", "net", "print", "n", "ou"], "inputLine": ["InputBlock", "configLine", "InputFile", "configline", " inputFile", "textLine", "inCode", "InputLINE", "configRow", "Inputline", "submitLINE", " inputLINE", "configFile", "textRow", "inputRow", "submitLine", "submitRow", " inputBlock", " inputRow", "inputLINE", "inputCode", " inputCode", "submitBlock", "textLINE", "InputRow", "inputline", "inLINE", "textCode", "inputFile", "inLine", "InputLine", "inRow", "inputBlock", " inputline"]}}
{"id1": "11032546", "id2": "17792212", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"testCopyUnknownSize": [" testcopyKnownsize", " testCopyunknownLength", " testCopyKnownShape", " testCopyUnknownLength", " testcopyUnknownsize", " testcopyUnknownShape", " testCopyKnownsize", " testCopyDifferentSize", " testCopyDifferentsize", " testCopyunknownSize", " testCopyUnknownsize", " testCopyKnownSize", " testcopyUnknownLength", " testcopyKnownSize", " testcopyKnownShape", " testcopyUnknownSize", " testCopyKnownLength", " testCopyunknownsize", " testCopyUnknownShape", " testCopyunknownShape", " testCopyDifferentLength", " testcopyKnownLength", " testCopyDifferentShape"], "in": ["inn", "al", "up", "is", "it", "ain", "inv", "sin", "inner", "isin", "r", "din", "copy", "mm", "file", "source", "log", "bin", "i", "gin", "data", "on", "from", "In", "inside", "ins", "en", "IN", "l", "con", "null", "input", "cin", "rin", "inf", "ind"], "out": ["auto", "obj", "up", "it", " Out", "Out", "inv", "ex", "a", "aos", "cmd", "all", "b", "log", "err", "io", "one", "data", "gt", " OUT", "user", "on", "result", "res", "sum", "or", "check", "t", "at", "o", "by", "OU", "output", "client", "gr", "os", "null", "con", "to", "end", "co", "list", "outs", "OUT", "net", "n", "ou"], "cpySize": [" cplyLength", " cplyCount", "CplyCount", "cpeSize", "cpysize", "cplySize", "cpyCount", "cpyLength", "cdysize", "cpeCount", " cplysize", "cpeLength", " cplySize", " cpysize", " cpyLength", "cfiCount", "cfiSize", "cdyCount", "CpyLength", "CpyCount", "CpySize", "cdySize", "cplysize", "CplyLength", "cfisize", "cfiLength", "cplyLength", "CplySize", "cpesize", "cdyLength", "Cpysize", "Cplysize", " cpyCount", "cplyCount"], "outArray": ["inString", "outStream", "outString", "outArea", "outObject", " outArea", "listArray", " outString", "neArray", " outarray", "outImpl", "OUTArray", " outObject", "nearray", " outImpl", "OUTarray", "inArea", "listArea", "listString", "OUTObject", "OUTStream", "listImpl", "inImpl", "neObject", "neStream", " outStream", "outarray", "inArray"]}}
{"id1": "310182", "id2": "21824901", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "conVERT", "consvert", "CONversion", "conversion", "unfer", "converted", "compvert", "compversion", "consversion", "compverts", "Converted", "unversion", "converting", "CONverted", "CONfer", "unvert", "converts", "consVERT", "Conversion", "CONverting", "conprocess", "ConVERT", "CONVERT", "CONvert", "consverting", "Confer", "unverted", "confer", "Conprocess", "unverts", "compprocess", "Convert", "Converts", "unprocess"], "src": ["Source", "scan", "url", "hl", "path", "orig", "attr", "sq", "inst", "addr", "cc", "sin", "rs", "stream", "ource", "href", "sr", "rx", "file", "config", "source", "ebin", "start", "filename", "sys", "SourceFile", "sit", "ipl", "host", "func", "RC", "scene", "iv", "txt", "from", "cont", "uri", "http", "its", "st", "str", "ser", "ins", "cur", "img", "loc", "rel", "usr", "pkg", "buster", "sc", "ur", "req", "rc", "s", "dist", "input", "SOURCE", "rest", "upload"], "dest": ["port", " destinations", "orig", "est", "Dest", "mat", " Destination", "target", "temp", " orig", "source", " destination", "gin", "dat", "result", "txt", " dst", " Dest", "img", "test", "foreign", "write", "table", "tif", "disk", "dir", "dist", "rest"], "in": ["inn", "up", "is", "inner", "stream", "isin", "r", "din", "file", "source", "b", "bin", "i", "io", "serv", "ad", "ar", "m", "from", "res", "In", "el", "sql", "st", "ins", "en", "IN", "d", "l", "input", "cin", "rin", "reader", "as", "inf", "ind"], "p": ["fp", "pc", "php", "pl", "pp", "per", "it", "part", "g", "ps", "r", "pro", "py", "pg", "vp", "b", "ph", "i", "h", "ap", "parser", "P", "parse", "j", "pa", "pd", "f", "m", "lp", "c", "ping", "rep", "pm", "post", "prot", "op", "t", "pre", "er", "pers", "at", "jp", "dp", "d", "pb", "l", "pkg", "wp", "pt", "pi", "sp", "cp", "pe", "tp"], "ds": ["cs", " os", "ports", "drivers", "dh", " ads", "ss", "scripts", "di", "dates", "edes", "sts", " d", "tests", "nas", "dds", "aws", "hd", "obs", "posts", "bs", "rs", "cks", "DS", "ys", "uds", " dd", "eds", "its", "vs", "dp", "d", "os", "terms", "outs", "qs", "dd", "pd", "tp", "ras", "ts", "ods", "Ds", "tes", " DS", "ps", "points", "ils", "gs", "amps", "docs", "xs", "ands", " des", "workers", "lists", "ads", "des", "db", "eps", "dos", "iffs", "dt", "js", "ks", "ls", "mys", "yes", "ws", "gd", "ats", "els", "sets", "ns", "sd", "tags", "loads", "dl", "ags", "s", "hs", "df"], "format": ["name", "unit", "lat", "path", "shape", "version", "it", "settings", "mat", "pattern", "act", "fm", "MAT", "ats", "title", "file", "source", "layout", "parse", "sche", "template", "top", "id", "fc", "f", " Format", "type", "mode", "status", "form", "tag", "feature", "set", "t", "spec", "at", "cf", "table", "output", "module", "l", "policy", "feat", "size", "pretty", "pi", "filter", "mt", "ct", "style", "Format"], "hasPixelData": ["haspixelDATA", "hasFramedata", "HaspixelData", "hasixelData", "hasPixeldata", "hasixelDATA", "hasFrameDATA", "hasFrameData", " hasPixelDATA", "HasPixelDATA", "hasPixelDATA", "HasPixelData", "HaspixelDATA", "haspixeldata", "Haspixeldata", "HasPixeldata", " hasPixeldata", "hasixeldata", "haspixelData"], "inflate": ["Informate", "inFlocate", "informate", "invalidocate", " invalidATE", "inflATE", "inflated", "informated", "inFLated", "infolat", "incelicate", "inFlATE", "informat", "Inflat", "infolated", "invalidicate", "inFLat", "informocate", "incelocate", "Inflocate", "inFlate", "Informocate", "inFLocate", "incelate", "inflocate", "invalidate", "inFLate", " inflocate", "infolate", "inflicate", "invalidATE", "infolocate", "inFlicate", "Informated", " invalidicate", "Inflated", " invalidate", "incelATE", "inflat", " invalidocate", "Inflate", " inflicate", " inflATE", "Informat"], "pxlen": ["packls", "mxdec", "pexlen", "packln", "pxls", "pexfun", "xpden", "mxln", "phpdec", "tmpln", "pxden", "mxlength", "mmlen", "xyln", "mmln", "phpln", "pixellength", "pxdec", "xplen", "pixells", "pexln", "tmplength", "xylength", "cpden", "pxlin", "tmplin", "mmlength", "phplength", "pixelfun", "xylin", "cplength", "mmlin", "packdec", "pxln", "pexlength", "xylen", "tmplen", "xplength", "pxfun", "phplen", "mxlen", "pxlength", "pexls", "pexden", "pixellen", "packlen", "xpln", "packfun", "cplen", "cpln", "packlength"], "out": ["name", "msg", "obj", "group", "up", "conn", "ln", "init", "writer", "gov", "inv", "Out", "ex", "aos", "outer", "temp", "cmd", "log", "err", "sys", "io", "inter", "user", "crit", "res", "cfg", "sum", "store", "prefix", "client", "output", "dir", "gr", "list", "outs", "OUT", "screen", "net", "pretty", "print", "ou"]}}
{"id1": "15799935", "id2": "17792212", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedBody", "saveAttachableFile", "saveAttachedFile", "saveAttachedbody", "saveExtachedPart", "saveAttachmentFile", "saveAttachedPart", "saveExtachmentBody", "saveAttachablePart", "saveExtachedbody", "saveExtachmentFile", "saveExtachmentPart", "saveAttachableBody", "saveAttentionBody", "saveExtachedFile", "saveExtachedBody", "saveExtachmentbody", "saveAttentionPart", "saveAttentionbody", "saveAttachmentPart", "saveAttachablebody", "saveAttentionFile", "saveAttachmentbody"], "context": ["cache", "response", "view", "parent", "version", "system", "tx", "present", "cc", "support", "message", "current", "subject", "content", "stack", "config", "container", "network", "comments", "host", "template", "translation", "media", "application", "search", "command", "java", "instance", "frame", "course", "service", "environment", "chain", "contact", "history", "foundation", "Context", "ctx", "client", "component", "cf", "null", "connection", "request", "ce", "background", "document", "center", "state"], "part": ["name", "PART", "parent", "Part", "p", "tx", "and", "version", "task", "add", "message", "job", "se", "sample", "temp", "partial", "file", "start", "art", "session", "join", "tmp", "host", "data", "top", "base", "type", "report", "pod", "patch", "instance", "body", "post", "parts", "piece", "thread", "zone", "bound", "work", "component", "word", "block", "connection", "trans", "reply", "sp", "pair"], "localAttachment": [" localAttachention", "localAssment", "localAttention", "localAttachachment", "localattention", "localAppention", "localAttached", " localAttail", "localAssail", " localAssachment", "localAssignment", " localAttachignment", "localDetignment", "localAssachment", "localAcail", " localDetail", "localattached", "localAppachment", "localAttignment", " localAttachached", "localAppached", "localATTention", "localAttachached", " localAttignment", "localDetached", " localDetachment", " localAssached", " localDetignment", "localAcached", "localAssached", "localAcignment", "localAttachention", "localattachment", " localAttment", "localDetention", " localAttachachment", "localDetail", "localAssention", "localAttachail", " localDetached", "localATTignment", "localAttail", "localAttachignment", "localAppail", " localAttention", "localATTment", "localAcachment", " localAssention", "localAttment", " localAttached", "localATTachment", " localAssail", "localDetachment"], "accountId": [" accountDb", "AccountById", "accountById", "accountID", "accNum", "accS", "bankAnd", "AccountId", "amountID", " accountID", "objectById", "accDb", "containerId", "accountName", "containerID", "containerNum", " accountName", "objectName", "accAnd", "amountInt", "bankS", "containerInt", "bankID", " accountAnd", "accountNum", "accId", " accountNum", "objectID", "accID", "AccountID", "objectId", "accountAnd", "accInt", "amountId", "amountDb", "bankId", "accountS", "accountInt", " accountById", "AccountName", "accountDb", " accountS", " accountInt"], "attachmentId": ["attacheId", "attacheById", "attociationId", "attionSerial", "AttachmentById", "assignmentID", "attmentById", "attachmentid", "AttociationID", "attachedid", "attacheid", "attociationid", "attociationById", "contachmentId", "attionById", "assignmentById", "AttociationById", "attachedById", "attionId", "Attociationid", "assignmentid", "contachedById", "attignmentId", "contachedSerial", "attmentId", "contachmentById", "attachedSerial", "AttachmentID", "AttachmentId", "assignmentId", "contachmentSerial", "attachmentSerial", "assachmentById", "attionid", "assachmentID", "Attachmentid", "AttociationId", "assachmentid", "contachedid", "attachedId", "attociationID", "attmentid", "attmentID", "attachmentById", "attachedID", "assachmentId", "attacheID", "attignmentID", "attociationSerial", "contachmentid", "contachedId", "attachmentID", "attignmentid", "attignmentById"], "in": ["inn", "al", "inc", "up", "ch", "init", "p", "is", "per", "it", "act", "inner", "isin", "ex", "r", "din", "info", "mm", "file", "ind", "source", "all", "bin", "i", "read", "gin", "on", "id", "m", "from", "In", "sum", "conf", "body", "ins", "inside", "en", "IN", "vin", "l", "con", "iter", "ai", "input", "cin", "rin", "mc", "as", "inf", "raw"], "saveIn": ["sendIN", "aveIn", " savePath", "savAs", " saveIns", "getIn", "sendIn", "getIns", "storeIn", "aveIN", "saveIN", "sendPath", "savIn", "savIns", "secureIn", "secureIN", "saveOut", "aveIns", "saveIns", "sendOut", "getIN", "aveOut", " saveIN", "storeIN", "savIN", "getOut", "secureIns", "savePath", "secureAs", "storeOut", " saveOut", "storePath"], "saveAs": ["aveAn", " saveAS", "aveAS", " saveTo", "aveIn", " saveAn", " saveBy", "submitas", "saveas", "SaveBy", "submitAs", "aveTo", "aveAs", "saveBy", "aveas", "Saveas", "dumpAs", "SaveAS", "saveTo", "submitIn", "saveAn", "saveAS", "submitAS", "dumpAn", "submitBy", "SaveAs", "SaveIn", "dumpTo"], "out": ["name", "auto", "obj", "up", "it", "Out", "inv", "inner", "ex", "v", "copy", "aos", "outer", "ent", "gc", "all", "sys", "log", "i", "cos", "io", "serv", "one", "conv", "res", "sum", "cn", "t", "o", "OU", "output", "con", "null", "os", "to", "oss", "ao", "co", "outs", "OUT", "net", "can", "n", "ou"], "copySize": ["copySIZE", "copyFontSize", "msgLength", "pushLength", "opyLength", "msgSIZE", "msgPercent", "msgSize", "CopySIZE", "likeCount", "pushSize", " copyCount", "CopySize", "copyLength", "opySize", "likeFontSize", "CopyFontSize", " copyLength", "pushCount", "likeLength", "opySIZE", "CopyCount", "opyPercent", "pushFontSize", "copyPercent", " copyFontSize", "likeSize", "CopyPercent", "CopyLength", "copyCount"], "contentUriString": ["contentUniNumber", "contentUnistring", "contentUicString", "contentUnriString", "contentUrisNumber", "contentUnriNumber", "contentUnuriStr", "contentUniStr", "contentUuriStatic", "contentUicstring", "contentUuriStr", "contentUicStatic", "contentUuriNumber", "contentUiStr", "contentUriStr", "contentUnuristring", "contentIriString", "contentUuriString", "contentUiString", "contentIiString", "contentUistring", "contentIriStr", "contentIistring", "contentUicStr", "contentUnriStr", "contentUrisString", "contentUnuriNumber", "contentUriStatic", "contentUrisStr", "contentIiStr", "contentUiStatic", "contentUrisstring", "contentUristring", "contentUuristring", "contentUnristring", "contentUnuriString", "contentIiStatic", "contentIriStatic", "contentUniString", "contentIristring", "contentUriNumber"], "mSize": ["lLength", "lBytes", "nSize", "mPos", "nBytes", "lPos", "mLength", "moBytes", "nLength", "moLength", "mBytes", "moSize", "nPos", "lSize", "moPos"], "mContentUri": ["mResourceIuid", "mContentIRI", "mContentIris", "mResourceIris", "mResourceIri", "mContentPris", "mContentIri", "mContent_RI", "mContentPri", "mResourceURI", "mContent_ris", "mContent_ri", "mResourceUuid", "mResourceUri", "mContentIuid", "mContent_uid", "mResourceIRI", "mContentPRI", "mContentUuid", "mContentUris", "mResourceUris", "mContentURI", "mContentPuid"], "cv": ["cap", "cas", "cmp", "qu", "vol", "act", "cb", "const", "cc", "xc", "v", "CV", "tc", "um", "uv", "gc", "vp", "buf", "vv", "conv", "mult", "ov", "box", "fc", "av", "sv", "c", "cont", "vr", "nv", "nc", "ctrl", "cu", "desc", "lv", "lc", "dc", "qv", "vc", "csv", "pb", "cf", "cm", "vt", "rc", "cod", "vm", "GV", "ev", "ct", "cp", "cn"], "uri": ["link", "url", "ue", "picture", "unit", "origin", "ri", "ip", "handle", "phi", "ui", "URI", "subject", "u", "doi", "query", "uid", "folder", "i", "resource", " Uri", "id", "result", "report", "q", " ni", "du", "prefix", "range", "qi", "address", "component", "iri", "term", "dir", "bid", "ur", "directory", " URI", "uni", "uu"]}}
{"id1": "12236729", "id2": "20232250", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "label": 0, "substitutes": {"copy": [" dup", " append", " merge", " Copy", " combine", " paste", " replicate", "read", "transfer", " move", " cat", " parallel", " download", " duplicate", " operate", " transfer", " cp", " delete", " seek", " clone", " upload", "paste", "Copy", " join", " copying", " restore", " recover", "cp"], "inputFile": ["inFile", "outputPath", "configPath", " inputfile", "inputDir", "argumentPost", "inile", "configFile", "configPost", "argumentPath", "inputPost", " inputPath", "outputile", "inputPath", "inPath", "outputDir", "inputile", "argumentfile", " inputPost", "inputfile", "configfile", "argumentFile", " inputile", " inputDir", "inDir"], "outputFile": ["outFile", "outFilename", "outputPath", "outfile", "targetfile", "targetDir", "outputfile", "outPlace", "inputDir", " outputPlace", "writeFile", " outputDir", "targetPath", "outputFilename", "outDir", "outputPlace", " outputFilename", "inputPath", "writeDir", "outputDir", "writePlace", "writeFilename", "inputfile", "targetFile", "outPath"], "in": ["inn", "al", "inc", "up", "ri", "init", "is", "per", "it", "sin", "inner", "isin", "old", "ini", "din", "info", "min", "all", "ir", "i", "bin", "read", "gin", "on", "from", "In", "ic", "ins", "inside", "en", "IN", "inf", "iter", "ai", "con", " din", "input", "rin", "cin", "reader", "ze", "ind"], "out": ["auto", "cache", "obj", "writer", "it", "Out", "g", "ex", "v", "nt", "aos", "outer", "flush", "dis", "sys", "log", "cos", "io", "one", "user", "on", "res", "ot", "cn", "check", "en", "at", "o", "by", "ne", "write", "output", "client", "os", "null", "con", "to", "end", "co", "outs", "OUT", "net", "print", "can", "n", "ou"], "c": ["character", "pc", "cap", "cache", "cs", "ch", "ac", "bc", "ec", "x", "char", "arc", "cc", "cd", "cb", "v", "r", "current", "u", "cl", "gc", "cos", "i", "k", "f", "uc", "unc", "cont", "conf", "nc", "code", "t", "cu", "chain", "lc", "d", "cm", "cf", "l", "con", "count", "rc", "cr", "z", "cod", "ce", "mc", "C", "n", "cp", "ct"]}}
{"id1": "14794404", "id2": "10391753", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["encryptionPass", "encipherPassword", "encryptedPass", "encryptionpassword", "encryptionPassword", "encipherpassword", "decryptedPassword", "encryptPass", "encryptedSecret", "decryptpassword", "decryptSecret", "encryptpassword", "encryptSecret", "decryptedSecret", "decryptPass", "decryptedPass", "encryptedpassword", "decryptPassword", "decryptedpassword", "encipherSecret", "encipherPass", "encryptionSecret"], "password": ["attribute", "name", "path", "key", "string", "pattern", "description", "wordpress", "message", "entry", "content", "w", "database", "value", "number", "Password", "filename", "email", "data", "padding", "user", "login", "sword", "command", "prefix", "hash", "text", "address", "phrase", "word", "shadow", "past", "input", "reset", "token", "pass", "directory", "username", "secret"], "encryptedPassword": [" encryptedAttribute", "installedPassword", "updatedDatabase", "updatedPassword", " encryptedDatabase", "installedAttribute", "ryptedPassword", "encryptedDirectory", "ryptedpassword", "updatedAttribute", " encryptedStatement", "confirmedpassword", "initializedDatabase", " encryptedpassword", "initializedConnection", "finishedPassword", "initializedStatement", "coloredDatabase", "ryptedDatabase", "coloredConnection", " encryptedConnection", "finishedDatabase", "coloredPassword", "confirmedDirectory", "encryptedStatement", "finishedGuest", "confirmedPassword", " encryptedDirectory", "coloredStatement", "updatedDirectory", "initializedPassword", "installedDirectory", "installedDatabase", "encryptedConnection", "encryptedDatabase", "encryptedpassword", "confirmedDatabase", "finishedpassword", "ryptedDirectory", "updatedpassword", "encryptedAttribute", "updatedGuest", "encryptedGuest", " encryptedGuest"], "md5": ["MD7", "MD512", "sha7", "MD2", " md25", " md2", " mdle", " Md8", "md3", " MD3", " MDle", " Md3", "sha5", "md7", "sha512", "MD25", "md25", " md512", "dig5", "dig25", " Md5", "md512", " md7", "MD5", " MD5", "md2", "dig3", "dig2", "sha2", " MD8", " MD2", "md8", " md3", "MD3", " md8", "mdle", " Mdle"], "digest": ["mdum", "hexEST", "Digest", "mdEST", "hashester", "mdness", "Digness", "hexness", "Digester", "hexested", "hashested", "mdest", "hashest", "digse", "mdester", "digests", "Digum", " digse", "digum", "digested", "hashum", "Digse", "digness", " digests", " digEST", "digEST", "hexest", "hashEST", "DigEST", "digester", "Digests", "Digested", "mdse", "mdests", "mdested"], "i": ["ix", "im", "bi", "ip", "init", "key", "span", "ri", "is", "mi", "x", "it", "phi", "gi", "ui", "ji", "si", "a", "hi", "major", "index", "u", "\u0438", "ind", "b", "ski", "point", "err", "gu", "io", "ci", "ti", "me", "zi", "multi", "j", "di", "conv", "id", "xi", "m", "c", "uri", "sim", "q", "y", "ic", "in", "ei", "qi", "t", "ij", "o", "iter", "ai", "I", "z", "ie", "my", "pi", "yi", "iq", "n", "ii", "li"], "hex": ["zip", "xf", "hl", "html", "comp", "exp", "ch", "cert", "none", "full", "tx", "x", "tex", "def", "form", "sh", "rex", "ex", "temp", "json", "cmd", "lit", "ph", "h", "sex", "dump", " Hex", "sv", "txt", "mix", "unsigned", "solid", "percent", "oct", "kw", "com", "br", "pex", "hash", "check", "str", "alpha", "color", "serial", "ne", "des", "cf", "rh", "term", "iter", "flash", "print", "rendered", "raw", "uint"]}}
{"id1": "20735941", "id2": "18782385", "code1": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["getSourceFile", "newFile", "openSourceFile", "openFile", "readFilename", "readSourceFile", "readfile", "openFilename", "newSourceFile", "getFilename", "newFilename", "readFile", "openfile", "getfile", "newfile"], "home": ["mail", "name", "Root", "auto", "room", "hub", "server", "up", "path", "parent", "html", "shared", "wd", " HOME", "localhost", "Dir", "HOME", "ghost", "h", "host", "join", "profile", "default", "user", "root", "ome", "Home", "project", "book", "base", "http", "housing", "omes", "mem", "history", "share", "dir", "www", "self", "directory", "index", "owner"], "fileName": ["projectNAME", "baseNAME", "baseDefault", "resourcename", "projectname", "filenameName", "resourceName", "FILENames", "filenamename", "tileFilename", "tileNAME", "FileName", "FileNames", "FILEString", " fileNAME", "tileName", "fileFilename", " fileFilename", "projectName", "FILEPath", "filename", "basename", "tileFile", "FILEName", " fileString", "viewName", "baseName", "filePath", "viewFile", "viewNAME", "fileNames", "resourcePath", " fileDefault", " fileNames", "fileNAME", "fileDefault", " filename", " filePath", "FilePath", "resourceFilename", "filenameFilename", "fileString", " fileFile", "fileFile", "viewFilename", "filenamePath", "projectDefault", "FileString"], "file": ["ile", "fp", "name", "port", "al", "link", "view", "le", "path", "File", "image", "full", "model", "handle", "used", "pool", "foo", "current", "info", "run", "node", "buffer", "filename", "log", "resource", "function", "channel", "local", "FILE", "user", "library", "result", "f", "base", "type", "from", "po", "report", "page", "or", "object", "load", "bo", "db", "table", "output", "place", "work", "write", "null", "fe", "to", "tree", "dir", "print", "document", "be", "use", "format"], "url": ["mail", "Url", "util", "link", "name", "html", "path", "cert", "key", "org", "char", "ret", "mb", "r", "gl", "ssl", "host", "resource", "bel", "user", "f", "base", "abs", "dl", "uri", "github", "web", "http", "nl", "sl", "rl", "impl", "str", "ll", "browser", "address", "ref", "loc", "https", "rel", "l", "client", "null", "lr", "URL", "norm", "ls", "ur", "ul"], "in": ["inn", "im", "al", "inc", "up", "init", "is", "it", "and", "inner", "isin", "ini", "r", "din", "source", "bin", "i", "io", "read", "gin", "on", "f", "from", "In", "el", "body", "ic", "ins", "inside", "en", "IN", "o", "l", "con", "iter", "ai", "s", " din", "n", "input", "rin", "cin", "mc", "inf", "ind"], "out": ["msg", "obj", "ln", "writer", "it", "Out", "inner", "v", "nt", "aos", "flush", "outer", "sys", "cos", "ion", "log", "io", "one", "conv", "on", "batch", "ot", "cn", "check", "en", "o", "ne", "OU", "write", "output", "gr", "client", "con", "null", "os", "to", "oss", "co", "outs", "OUT", "net", "can", "n", "ou"]}}
{"id1": "20011285", "id2": "17557289", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"copy": ["remote", "delete", "link", "zip", "php", "p", "opy", "download", "py", "file", "gc", "Cop", "cop", "close", "transfer", "export", "sync", "c", "save", "cut", "clip", "crop", "slice", "create", "move", "clone", "write", "split", "paste", "share", "proxy", "to", "Copy", "co", "cat", "pixel", "cp"], "sourceFile": ["sourceLine", "SourceFile", "ourceDirectory", "sourceFILE", " sourceLocal", "packageFile", "initfile", "sourceUnit", "sourceUser", " sourceDate", "packageDirectory", "sourceWeb", " sourceUnit", "initFILE", "srcFiles", "srcUser", "packageUser", "sourcefile", "srcDirectory", "acePlace", "initHeader", " sourceFILE", " sourcefile", "SourceUnit", "originWeb", "identPlace", "originFile", "aceFile", "identFiles", "SourcePath", "ourcePath", "identFile", "Sourcefile", "originLine", "sourceDir", "ourcefile", "sourcePath", "sourceDirectory", "aceFiles", "initFile", "SourceWeb", "sourceDate", " sourceFiles", "ourceUser", "srcfile", "sampleLocal", "srcUnit", "sourceLocal", " sourcePlace", "SourceDir", "ourceFILE", "srcHeader", "SourceFiles", "srcFILE", "srcFile", "packageFILE", "aceDate", " sourceHeader", " sourceLog", " sourceDir", " sourcePath", "sampleFile", "originDir", "samplefile", "sourceLog", "sourceHeader", "ourceLog", "SourceLog", "srcLocal", "sampleFILE", "identDate", "SourceLine", "sourceFiles", " sourceLine", " sourceWeb", "sourcePlace", "ourceFile"], "destinationFile": ["destationDir", "identinatedMail", "parentinateFile", "destentionMail", "transinationDir", "transinateDir", "destructionFile", "destinatorFILE", "destinateDisk", "destinofile", "identinatedFile", "identinationFILE", "resultinationfile", "parentinationFile", "estinatorDir", "destinationDisk", "destinatorPath", "destificationDir", "destinatorEmail", "parentinateFILE", "resultinateDisk", "transinationDisk", "destinatedMail", "destumentFile", "parentinationFILE", "destationKey", "destinatedDisk", "destinationLine", "destinatorFile", "destinateLocation", "destinatedLocation", "destinatedfile", "destinationMail", "identinationMail", "parentinateEmail", "destationFile", "transinateFILE", "destructionLine", "estinationFile", "destensionFILE", "catinatefile", "catinationKey", "destinationLocation", "destmentationFILE", "destinationEmail", "destinoFile", "destmentationDir", "destationPath", "destinateKey", "destinatorDir", "destinateDir", "destinatedLine", "destructionMail", "destentionLine", "destumentFILE", "estinationDir", "destificationfile", "destentionFILE", "catinationfile", "identinationLine", "resultinationFile", "estinatorPath", "identinatedFILE", "transinateFile", "catinateFile", "estinationfile", "estinatorFile", "destinationfile", "destinatorLocation", "resultinatefile", "destinateEmail", "destinatedFILE", "destmentationFile", "resultinationDisk", "destensionFile", "destinationKey", "destationfile", "destentionFile", "identinatedLine", "estinatorfile", "transinationFile", "destinatefile", "destinationDir", "destensionDir", "destensionDisk", "destinateFile", "transinateDisk", "transinationFILE", "destinateFILE", "destructionFILE", "destmentationDisk", "parentinationEmail", "resultinateFile", "catinationFile", "destinationPath", "resultinateLocation", "destinationFILE", "destumentEmail", "resultinationLocation", "destificationFile", "destinoKey", "destinatedFile", "destinatorDisk", "estinationPath", "destinatorfile", "identinationFile", "destificationPath", "catinateKey"], "tmp": ["msg", "obj", "obs", "mk", "tf", "pres", "p", "cmp", "aux", "cb", "shots", "mb", "src", "nt", "mm", "yy", "nb", "temp", "perm", "managed", "tt", "etc", "np", "buf", "data", "multi", "xs", "apps", "files", "tab", "txt", "m", "abs", "qq", "stuff", "tar", "mp", "img", "ms", "cur", "t", "parts", "buff", "xxx", "pkg", "split", "bt", "dir", "my", "sp", "emp", "aaa"], "f": ["fp", "ff", "xf", "fab", "obj", "tf", "p", "full", "fm", "g", "v", "a", "fo", "F", "w", "u", "e", "file", "b", "h", "k", "func", "fa", "uf", "fw", "fc", "m", "c", "fs", "fi", "fd", "q", "bf", "lf", "flo", "fl", "t", "sf", "o", "d", "cf", "l", "fe", "fr", "fac", "af", "field", "z", "fb", "df"], "i": ["ix", "im", "bi", "ip", "key", "init", "ri", "p", "mi", "it", "x", "is", "phi", "gi", "ui", "ji", "si", "v", "hi", "ini", "major", "ami", "u", "e", "iu", "point", "k", "ti", "ci", "me", "ori", "zi", "multi", "j", "di", "id", "xi", "m", "batch", "iq", "ii", "q", "y", "ic", "in", "ei", "ims", "ms", "qi", "eu", "ij", "us", "ki", "o", "iter", "ai", "I", "ma", "ie", "my", "pi", "sim", "index", "ind", "li"], "source": ["Source", "zip", "scan", "sequence", "iterator", "origin", "parent", "init", "none", "image", "system", "shell", "inner", "stream", "ource", "scope", "src", "se", "sample", "before", "subject", "info", "series", "file", "query", "start", "missing", "session", "resource", "archive", "local", "template", "zero", "result", "comment", "base", "storage", "from", "search", "site", "body", "store", "console", "service", "in", "spec", "seed", "iter", "tree", "input", "ie", "show", "size", "ce", "score", "SOURCE", "style", "index", "use", "owner"], "destination": [" destaration", "destinate", "Destinate", "destaration", "combension", "Destaration", " destension", "combinate", "coordinate", "declinate", "Destation", "destinator", " destinate", "Destinator", "combination", "coordination", "destinated", " destation", "declinated", "combation", "Destension", "destation", " destinator", "destension", " destinated", "declation", "coordinated", "coordation", "declinator", "declaration", "Destination", "declination"]}}
{"id1": "13657527", "id2": "23532405", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "label": 0, "substitutes": {"getDatasetsList": ["getDatasetsStatus", "getDatasetResult", "getDatisetsList", "getDatasuresStatus", "getDatasetList", "getDatisetsStatus", "getDatasuresResult", "getDatisetList", "getDatisetsResult", "getDatisetResult", "getDatasesStatus", "getDatisetStatus", "getDatasetsResult", "getDatasesList", "getDatasesResult", "getDatasuresList", "getDatasetStatus"], "surl": ["sURL", "sUrl", "jslim", "lsmail", "jsUrl", "stsserver", "stsuri", "lsuri", "jsuri", "sslim", " smail", "sysserver", "ssURL", "smail", "lsUrl", " sUrl", "esname", "suri", "ssUrl", "esURL", "sysurl", "lsserver", "syslt", "slim", "esurl", "sname", "slt", "sserver", "ssurl", "sysuri", "stsurl", " sname", " suri", "lslt", "ssuri", "esuri", "esUrl", "lsurl", "jsurl", "stslt"], "datasetsList": ["dataselinesName", "datasetList", "datasetsName", "datisetsName", "datasagesLock", "datasensList", "datasETSGroup", "datarsetsTable", "datarssetsTable", "datarsetslist", "datassetsData", "datisetName", "datarsetsLock", "datisetList", "datasetsData", "datisetsList", "datisetMap", "datasetsMap", "datasourcesLock", "datasourcesTable", "datarsetsMap", "datmassetsMap", "datassetslist", "datarsetList", "datasagesTable", "datasamesSet", "datasuresList", "datasetsSet", "datasagesSet", "datarsetsSet", "datasagesList", "datasetlist", "datasETSList", "datassetsLock", "datmasetsList", "datasetsTable", "datarsetSet", "datasourcesList", "datasuresSet", "datarsetMap", "datassetsSet", "dataselinesMap", "datasetMap", "datasetGroup", "datarsetsList", "datasetName", "datasetData", "datasamesMap", "datasetsGroup", "datasagesMap", "datisetGroup", "datmasetsData", "datasamesList", "datasetsLock", "datisetsMap", "datarssetsSet", "datmassetsLock", "datmasetsLock", "datmassetsList", "datassetsTable", "dataselinesGroup", "datassetsList", "dataselinesList", "datisetsGroup", "datmasetsMap", "datasetLock", "datarssetsList", "datasourcesSet", "datasenslist", "datasureslist", "datasensMap", "datasuresMap", "datasETSMap", "datmassetsData", "datarssetsLock", "datassetsMap", "datasagesData", "datarsetlist", "datasETSName", "datasetslist", "datasetSet", "datasameslist"], "result": ["sequence", "response", "cert", "answer", "first", "Result", "def", "ret", "description", "message", "menu", "detail", "success", "folder", "buffer", "results", "record", "successfully", "there", "default", "successful", "complete", "comment", "search", "res", "report", "valid", "status", "form", "details", "set", "chain", "contact", "test", "relation", "table", "diff", "found", "exist"], "reader": ["iterator", "READ", "liner", "rd", "rer", "writer", "per", "socket", "operator", "older", "reading", "inner", "stream", "via", "loader", "r", "rr", "redo", "layer", "file", "query", "buffer", "author", "resource", "read", "parser", "rar", "roller", "handler", "driver", "timer", "peer", "ner", "body", "rl", "range", "ser", "Reader", "er", "bo", "ro", "test", "client", "upper", "iter", "mr", "row", "runner", "field", "river", "dr", "wrapper", "handle"], "url": ["mail", "Url", "link", "key", "org", "char", "stream", "loader", "r", "mount", "file", "location", "ssl", "resource", "user", "id", "dl", "il", "uri", "web", "http", "sl", "nl", "rl", "str", "ll", "browser", "address", "l", "client", "null", "lr", "row", "URL", "ls", "ur", "ul"], "s": ["cs", "ws", "string", "sq", "ts", "still", "is", "full", "bs", "rs", "tes", "strings", "ps", "v", "ats", "r", "sample", "ds", "ns", "sb", "gets", "series", "source", "b", "i", "gs", "h", "S", "ss", "es", "less", "sw", "sv", "abs", "sts", "ids", "its", "y", "sql", "str", "ms", "ins", "t", "has", "us", "csv", "l", "os", "sym", "js", "qs", "hs", "ls", "as", "n"], "list": ["sequence", "ls", "php", "group", "array", "full", "part", "pool", "def", "add", "stack", "member", "detail", "all", "log", "layout", "join", "L", "local", "top", "listed", "batch", "dl", "cont", "format", "lists", "left", "form", "set", "st", "single", "collection", "ll", "chain", "test", "l", "table", "word", "LIST", "block", "ml", "pretty", "print", "note", "ist", "li"]}}
{"id1": "11616716", "id2": "21642215", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResultsasString", "getCMSResultasStream", "getCMSResultsasSteam", "getCMSResultasView", "getCMSResultAsView", "getCMSResultasString", "getCMSResultsAsStream", "getCMSResultAsSteam", "getCMSResultsasView", "getCMSResultsAsString", "getCMSResultAsString", "getCMSResultsAsSteam", "getCMSResultasSteam", "getCMSResultsasStream", "getCMSResultsAsView"], "rqlQuery": [" rqlString", "rqlStatement", "RQLQuery", "rsqlString", "rqlString", "rviewCommand", "rumbleQuery", "RQLquery", "rumbleString", "Rqlquery", "rqCommand", "rQLquery", "rviewquery", "rqlCommand", "RqlQuery", " rsqlString", " rsqlStatement", " rsqlQuery", "rqStatement", "rqString", "rsqlQuery", "rQLCommand", "rumbleStatement", "RQLCommand", "rqquery", "rQLQuery", "rviewQuery", "rqQuery", "rqlquery", " rqlStatement", "rsqlStatement", "RqlCommand"], "osr": ["iossr", "iosr", "iosh", " osmr", "osssr", "ossrg", "osd", "osmr", "osesrw", "possr", " osq", "oesmr", "posrator", "ooscr", "ossrw", " ossr", "orar", "oosd", "osscr", "ovr", "oesr", "oeser", "osq", "iosd", "ossr", " osvr", " osrar", "iosvr", "oessr", "iosq", " osh", "ioser", "or", "osesr", "posr", "osvr", "osrw", "ossd", "ossh", "ossq", "ooser", " osrg", "iosmr", "ossvr", " oscr", "oesrw", "oseser", "iosrg", "oosr", "osrar", "oscr", "osh", "osesmr", "oesrator", "osrator", "ossrar", "osrg", "ioscr", "osser", "iosrator", "ossmr", "oser"], "url": ["mail", "Url", "link", "hl", "cert", "char", "ret", "mb", "mount", "lb", "gl", "ssl", "host", "build", "bel", "ld", "il", "dl", "abs", "uri", "web", "http", "nl", "sl", "el", "str", "ll", "https", "loc", "rel", "pkg", "l", "client", "open", "URL", "net", "ol", "ls", "ur", "ul"], "conn": ["link", "obj", "ch", "cert", "init", "resp", "socket", "addr", "comm", "cb", "act", "org", "connected", "enc", "nt", "nw", "ns", "connect", "cmd", "pg", "syn", "sys", "close", "j", "conv", "col", "win", "sync", "c", "cont", "res", "pas", "conf", "nc", "cur", "canon", "out", "loc", "jp", "rel", "proc", "l", "ctx", "client", "open", "con", "os", "req", "connection", "n", "exec", "Conn", "ct", "cp", "cn"]}}
{"id1": "11968328", "id2": "4938100", "code1": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"getMD5": [" calculatemd1", " calculateMD2", " calculatemd5", " getMT5", " getmd5", " getMDState", " getHash2", " getMD1", " getMTState", " getMD2", " getHash5", " calculateMD5", " getHashState", " getmdState", " getmd1", " getmd2", " calculateMDState", " calculatemdState", " calculatemd2", " getHash1", " calculateMD1", " getMT2", " getMT1"], "_pwd": ["_wppriv", " _spw", " _pw", "_cwd", "_cfx", "_vppriv", "_pword", "_sppriv", "_wpword", "_vpw", "_passwords", "_vpwd", " _passw", "_pwords", "_passwd", "_ppriv", "_passw", "_passfx", " _pfx", "_wpw", "_cw", " _passwd", "_vpword", " _pword", "_cwords", " _passwords", "_pw", " _sppriv", " _passfx", "_spwd", " _spwd", "_spwords", "_pfx", " _pwords", "_spword", "_spfx", " _spword", "_spw", " _ppriv", "_wpwd"], "md": ["mail", "sm", "msg", "del", "dig", "and", "cd", "mb", "MD", "add", "dm", "dh", "mm", "man", "der", "od", "cmd", "ng", "hd", "ind", "bd", "de", "h", "sd", "tmp", "mod", "ld", "m", "det", " Md", "down", "pm", "bf", "rm", "mp", "mg", "ms", "red", "mn", "d", "db", "nd", "dir", "mand", "dd", "mc", "mt", "mk", "df", "pd"]}}
{"id1": "2022160", "id2": "20924119", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"write": ["port", "execute", "link", "fit", "writer", "find", "apply", "fail", "put", "process", "commit", "copy", "flush", "w", "connect", "writ", "run", "partial", "change", "log", "network", "walk", "rite", "read", "close", "next", "append", "export", "call", "wire", "sync", "batch", "see", "written", "save", "only", "send", "wait", "patch", "scale", "store", "set", "code", "Write", "create", "output", "get", "to", "render", "end", "size", "cycle", "print", "wrote", "writing", "register", "handle", "format"], "byteBuffers": ["byteCountters", "byteNamesers", "bytesPackerers", "byteIndexerers", "ByteBuffers", "byteOffer", "byteOffters", "bytesBuffators", " byteBuffusters", "bitBuffonents", "bytebuffodes", "byteFrags", " byteNamesines", "ByteBuffERS", "bitEnters", "ByteHeadrs", "byteCounters", "byteNamesERS", " bytePackers", "byteBytesERS", "byteBytess", " bytePackusters", "bytesPackators", "bytesHeadters", "bytesHeadered", "bytesHoldters", "bytesbufflers", "byteIndexators", "bytePackators", "bytebuffainers", "bytePacklers", "byteBuffines", "ByteHeadERS", "bytebufflers", "bytebuffERS", " byteBuffels", "byteEntrs", "bytePackters", " bytePacklers", "byteBuffrys", "bytePackrs", "bytePackainers", "byteHoldiers", "byteHeader", "bytesHeaders", "bytebuffines", "byteCombonents", "byteDeflers", "byteFragers", "byteEnters", "byteOrders", "byteBuffERS", " bytebuffters", " byteNameserers", "byteBuffonents", "bytesbuffrys", "byteBytesrys", " byteBufferers", "bitBuffrs", "byteOffered", "bitBuffers", "bytesBuffters", "byteCombers", " byteNamesers", " byteBuffs", "bytesBuffer", "byteBindERS", " byteDefERS", "bytebuffers", "bytesBufflers", "bytebuffiers", "byteBuffrs", "bytesBuffered", "bytebuffusters", "bytePackers", "bytesbuffers", "bytebufferers", "byteBufferines", "byteNamesines", "byteBuffiers", " byteBuffERS", "byteBuffters", "bitBuffters", "byteHolderers", "bytesBuffrys", "byteCountERS", "byteBufferlers", "byteEntters", "byteCorners", "byteCombters", " byteBuffainers", "bytebuffters", "bytesPackers", "bytesHoldERS", "byteHeadERS", "bytePackerers", " bytebuffERS", "byteBufferters", "bytePacker", "bitEntrs", "byteBytesers", " byteDefels", "ByteHeadered", "byteBufferERS", "byteHeadrs", " byteBuffines", " byteBuffters", "bytebuffs", "byteDefels", "bytebuffered", "byteBindodes", "byteHoldERS", "bytesbuffodes", "byteBinders", "byteBufflers", "byteBuffererers", " byteDeflers", "byteCountered", "byteBufferers", "byteHoldered", "byteCornerers", "byteBindlers", " bytebuffers", "bytesbuffs", "byteOffers", "byteCorniers", "byteBufferered", " byteBuffered", "bytesBuffodes", "byteBuffodes", "bitEntonents", "ByteBuffered", " bytebuffiers", "bytebuffrys", "bytesBuffs", "byteHoldters", " bytePacks", "byteHolders", "byteOrdrs", " bytePackainers", "byteWaitERS", "byteHeadters", "bytesHolders", "byteBuffels", " bytebufferers", "bytesBufferers", "byteOrdters", "byteBuffators", "byteIndexers", "bytesHoldered", "byteOrdonents", "byteBuffainers", "bytesPackrs", " byteBufflers", "bytePackered", "byteCombrs", "bytesBuffrs", " bytePackerers", "byteWaitainers", "bytePackrys", " byteDefers", "bitEntters", "bytesBuffers", "byteIndexrs", "byteBuffusters", "byteDefers", "bytePackusters", "byteEntonents", " bytebuffered", "bytesHeader", "ByteHeaders", "byteBufferels", " bytePackERS", "byteHeaders", "byteWaiterers", "bytesBuffERS", "byteFraglers", "bytePackERS", "ByteBuffrs", "byteCornters", "byteDefERS", " byteBuffiers", "byteFragusters", " byteNamesERS", "byteWaiters", "byteBuffer", "bytePacks", "bytesbuffERS", "byteHeadered", "byteBuffs", "byteNameserers", "byteBuffered"], "m_initialOutBuffer": ["m_finalOutputBuff", "m_initialoutCache", "m_InitialOutBuff", "m_initialEndLength", "m_initialInThread", "m_firstoutBuff", "m_initialInbuffer", "m_initialOutputBuffer", "m_initialOutLength", "m_currentInChannel", "m_currentoutCache", "m_initialInQueue", "m_currentOutBuffer", "m_initialByteBuffer", "m_initialNetBuffer", "m_currentoutBuffer", "m_InitialOutLength", "m_initialoutWriter", "m_finalOutputQueue", "m_initialNetThread", "m_InitialoutLength", "m_InitialOutCache", "m_initialNetQueue", "m_finalOutBuff", "m_currentoutBuff", "m_firstoutBuffer", "m_initialCheckBuff", "m_initialoutBuffer", "m_currentInBuff", "m_initialHostBuffer", "m_currentOutQueue", "m_initialOutChannel", "m_initialOutThread", "m_initialHostBuff", "m_finalOutQueue", "m_InitialoutCache", "m_firstOutBuff", "m_initialInLength", "m_currentOutCache", "m_initialCheckBuffer", "m_InitialoutBuff", "m_initialByteBuff", "m_initialInChannel", "m_initialOutputQueue", "m_firstoutWriter", "m_initialOutCache", "m_initialoutQueue", "m_initialCheckChannel", "m_initialCheckQueue", "m_initialByteWriter", "m_initialOutputThread", "m_currentoutQueue", "m_initialoutLength", "m_initialOutWriter", "m_initialOutputBuff", "m_initialOutbuffer", "m_currentInBuffer", "m_initialInBuff", "m_currentOutBuff", "m_initialHostView", "m_initialHostbuffer", "m_initialOutBuff", "m_currentOutChannel", "m_initialEndBuffer", "m_firstOutCache", "m_initialEndBuff", "m_initialInView", "m_finalOutThread", "m_firstoutCache", "m_finalOutputThread", "m_InitialoutBuffer", "m_initialEndCache", "m_firstOutBuffer", "m_firstOutWriter", "m_initialInBuffer", "m_finalOutputBuffer", "m_initialInWriter", "m_initialInCache", "m_initialOutView", "m_initialNetBuff", "m_currentInQueue", "m_finalOutBuffer", "m_initialNetCache", "m_InitialOutBuffer", "m_initialByteCache", "m_initialOutQueue", "m_initialNetChannel", "m_initialoutBuff"], "buffer": ["sequence", "cache", "server", "stream", "container", "holder", "builder", "context", "buf", "channel", "manager", "engine", "store", "bo", "table", "iter", "block", "tree", "list", "background", "document", "directory", "url", "timeout", "pool", "message", "stack", "source", "bridge", "Buffer", "processor", "button", "timer", "thread", "address", "connection", "row", "callback", "flash", "filter", "attribute", "response", "header", "memory", "database", "layer", "profile", "template", "bar", "queue", "batch", "comment", "base", "command", "chain", "loop", "length", "output", "null", "pair", "window", "iterator", "initial", "socket", "temp", "internal", "match", "map", "page", "buff", "binary", "phrase", "empty"], "buffers": ["ufers", "offers", "rendters", "buffings", " buffors", "bufards", "combers", "buffERS", " buffters", "ufERS", "combards", "comblers", "combERS", "ufors", "ufards", "holders", "holdERS", "buffors", "offters", "holdters", "bindERS", "renders", "uflers", "bufflers", "rendERS", "bufters", "rendlers", "bindlers", "ufters", "holdings", "bufings", "bufers", "offERS", "bindters", "binders", " buffings", "offors", "bufERS", " buffERS", "buffards", "buffters", "buflers"], "result": [" resulted", "response", "cache", "group", "other", "answer", "Result", "ver", "created", "true", "continue", "ret", "description", "process", "message", "r", "current", "progress", "json", "event", "success", "make", "product", "resource", "context", "reason", "results", "next", "profile", "data", "that", "match", "user", "error", "successful", "complete", "comment", "done", "see", "search", "res", "report", "role", "valid", "we", "status", "mate", "details", "cur", "ser", "load", "relation", "test", "output", "iter", "null", "request", "re", "runner", "diff", "pair", "wrapper", "uu"], "encrypted": ["sequence", "external", "other", "created", "confirmed", "temp", "ended", "internal", "secure", "channel", "context", "checked", "password", "error", "available", "engine", "chain", "verified", "armor", "finished", "table", "locked", "options", "flash", "extra", "selected", "secret"]}}
{"id1": "6190356", "id2": "8690362", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public static void fileUpload() throws IOException {\n        HttpClient httpclient = new DefaultHttpClient();\n        httpclient.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_1);\n        HttpPost httppost = new HttpPost(postURL);\n        File file = new File(\"d:/hai.html\");\n        System.out.println(ukeycookie);\n        httppost.setHeader(\"Cookie\", ukeycookie + \";\" + skeycookie + \";\" + usercookie);\n        MultipartEntity mpEntity = new MultipartEntity();\n        ContentBody cbFile = new FileBody(file);\n        mpEntity.addPart(\"\", cbFile);\n        httppost.setEntity(mpEntity);\n        System.out.println(\"Now uploading your file into mediafire...........................\");\n        HttpResponse response = httpclient.execute(httppost);\n        HttpEntity resEntity = response.getEntity();\n        System.out.println(response.getStatusLine());\n        if (resEntity != null) {\n            System.out.println(\"Getting upload response key value..........\");\n            uploadresponsekey = EntityUtils.toString(resEntity);\n            getUploadResponseKey();\n            System.out.println(\"upload resoponse key \" + uploadresponsekey);\n        }\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldSHA4", " hashPasswordForOldMBHash", " hashPasswordForOldMB5", " hashPasswordForoldMD4", " hashPasswordForOldMB1", " hashPasswordForoldMDHash", " hashPasswordForoldMD1", " hashPasswordForOldSHAHash", " hashPasswordForOldMDHash", " hashPasswordForOldMD4", " hashPasswordForOldMB4", " hashPasswordForOldSHA5", " hashPasswordForOldSHA1", " hashPasswordForoldMD5", " hashPasswordForOldMD1"], "password": ["attribute", "name", "p", "string", "pattern", "wd", "description", "wordpress", "message", "entry", "database", "value", "Password", "data", "padding", "default", "user", "login", "sword", "command", "prefix", "hash", "text", "address", "phrase", "words", "word", "shadow", "input", "reset", "pass", "token", "username", "secret", "raw"], "md": ["sm", "deep", " MD", "dr", "del", "dig", "cmp", "and", "mt", "cd", "mb", "MD", "add", "dm", "dh", "ds", "mm", "der", "od", "cmd", "grad", "ind", "bd", "de", "sd", "mod", "di", "pd", "ld", "m", "det", " Md", "mode", "down", "pm", "red", "ms", "mn", "d", "dir", "mand", "dd", "mc", "pdf", "ct", "mk", "df", "hd", "sha"], "messageDigest": ["messageDriear", " messagedigested", "messageDigear", " messageDigested", " messageDigist", " messagedigist", "MessageDigse", "messageWithest", "MessageDigEST", "Messagedigest", "messageDigitalEST", "MessageDigear", "messagedigse", "messageDigtest", "messageDriist", "messageDataest", "messagedigested", "messageDataester", "messageDesignest", "Messagedigse", "messageDataEST", "Messagedigear", "messageWithear", "messageDigester", "messageDesignested", "messageDigse", "messagedigear", "messageDigEST", "messageDigitalest", "messagedigist", "messagedigester", " messagedigEST", "messageDesignist", "MessageDigist", "MessageDigest", "MessageDigtest", "Messagedigester", "messagedigest", "messageDigitalist", "messageDesignEST", "MessageDigester", "messageWithist", "messagedigtest", "messageDriest", "messageDatatest", "messageWithse", "messageDigested", "messageDrise", "Messagedigist", "messageDigist", "messagedigEST", " messageDigEST", "messageDigitalested", " messagedigest", "MessagedigEST", "Messagedigtest"], "hexString": [" hexSingle", " HexSet", "phpBuffer", "exSingle", "octArray", "phpChain", "colorBuffer", " hexArray", " HexArray", "hexArray", "hexRest", " hexstring", " hexBuffer", "phpSite", " HexSite", " hexResponse", "hexSite", " HexBuffer", "colorString", "octResponse", "hexstring", "phpStr", " hexSite", " HexResponse", "hexResponse", "exString", " hexChain", "colorStr", "exBuffer", "hexSingle", "colorSet", "octString", "phpString", " HexRest", "hexSet", "phpRest", " HexString", " hexSet", " HexStr", " hexStr", "octstring", " Hexstring", "hexChain", " HexChain", "exStr", "hexStr", "hexBuffer", "phpSingle", " hexRest"], "i": ["ix", "im", "bi", "ip", "init", "key", "is", "it", "x", "mi", "gi", "phi", "ui", "ji", "si", "g", "a", "ini", "hi", "u", "e", "ski", "gu", "ti", "ci", "zi", "j", "multi", "di", "conv", "id", "m", "c", "uri", "ii", "q", "y", "ic", "set", "in", "qi", "t", "chain", "ij", "loop", "o", "ai", "I", "n", "z", "ie", "my", "pi", "yi", "sim", "index", "ind", "li"], "hex": ["zip", "xf", "hl", "php", "html", "imal", "alph", "exp", "none", "comp", "full", "tx", "x", "tex", "it", "def", "sh", "rex", "ex", "hi", "prof", "json", "hello", "lit", "ph", "h", "prop", "sex", "ext", "dump", "EX", " Hex", "sv", "cont", "mix", "solid", "percent", "oct", "com", "form", "br", "pex", "check", "red", "serial", "cf", "row", "flash", "print", "rendered", "raw"]}}
{"id1": "5808579", "id2": "4164833", "code1": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encrollPassword", "encryptLogin", "decryptLogin", "encryptedPass", "decryptedPassword", "encryptPass", "encryptedPassword", "encryptString", "enccryptLogin", "decryptedLogin", "decryptedString", "decryptPass", "enccryptString", "encrollString", "decryptString", "encrollLogin", "decryptedPass", "enccryptPassword", "encryptedLogin", "decryptPassword", "enccryptPass", "encryptedString", "encrollPass"], "loginName": [" loginCode", "blogCode", "usernameName", "cellname", "blogN", "loginname", "usernameCode", "blogTime", "LoginName", "usernameTime", "usernameN", " loginN", "LoginType", "cellName", "loginCode", "cellType", " loginType", "LoginTime", "loginType", "cellTime", "loginN", "blogName", "Loginname", " loginname", " loginTime", "loginTime"], "password": ["attribute", "name", "picture", "response", "path", "p", "string", "PASS", "pattern", "confirmed", "description", "message", "content", "expression", "database", "argument", "value", "last", "hello", "Password", "session", "email", "padding", "default", "user", "result", "comment", "sword", "command", "prefix", "text", "address", "phrase", "another", "paste", "word", "past", "reset", "token", "pass", "username", "secret", "encrypted"], "md5": ["MD7", "sha7", "MD2", "red3", " md6", "red8", " md2", "MD1", " md53", "md3", " MD3", " MD6", " Md3", "sha5", "md7", " Md2", " md1", "red5", " md7", "MD5", "red2", " Md53", " MD5", "md2", "sha1", " MD2", "md53", "sha2", "md8", "md6", "MD8", " md3", "md1", "MD3", " md8", "MD53", "MD6", " Md5"], "ba": ["bi", "CA", "va", "ya", "pha", "ka", "bc", "sa", "a", "ja", "b", "bd", "tta", "cca", "fa", "bre", "bb", "sta", "pa", "bee", "xa", "beta", "Ba", "abc", "bu", "aba", "oa", "bas", "da", "ta", "aa", "BA", "ena", "bo", "ha", "ada", "ga", "ca", "ao", "aka", "aaa"]}}
{"id1": "8132219", "id2": "11341711", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" Copyfile", " copyStream", " CopyFiles", "CopyFile", "copyStream", "CopyStream", "CopyFiles", " CopyFile", " CopyStream", "copyFiles", "Copyfile", " copyFiles", " copyfile", "copyfile"], "inFile": [" inPath", "innEmail", "outFilename", "inEmail", "ninName", "ninFilename", "dinFile", " inRow", "dinRow", "inputTemplate", "inName", "innPath", "inFilename", "inputName", "inTemplate", "inputFilename", "dinPath", "ninTemplate", " inEmail", "inPath", "outName", "outTemplate", "innRow", "inputFile", "inRow", "dinEmail", "innFile", "ninFile"], "outFile": ["ouFILE", " outFILE", "outFilename", "outFormat", "outputFile", "outfile", "outputfile", "inFilename", "outputFilename", "outputFormat", "destFormat", "ouFile", "destfile", "destFILE", " outFormat", "destFile", "ouFilename", "inTable", "outputTable", "outTable", "outFILE", " outfile", "inFILE", "outputFILE", "ouTable"], "in": ["inn", "inc", "up", "init", "is", "it", "ain", "sin", "inner", "isin", "old", "ini", "din", "info", "irm", "source", "ze", "ir", "bin", "i", "gin", "on", "id", "from", "In", "el", "ic", "ins", " input", "en", "IN", "o", "ai", "s", " din", "cin", "rin", "input", "inf", "ind"], "out": ["name", "p", "it", "Out", "g", "ex", "v", "w", "aos", "e", "file", "b", "all", "io", "one", "gt", "c", "res", "ot", "t", "en", "at", "o", "ne", "by", "output", "client", "os", "to", "co", "outs", "OUT", "net", "can", "n", "ou"], "inChannel": ["isinSlot", "innerChannel", "insideHandler", "isinCategory", "newPanel", "outStream", " inConnection", "innerchannel", "cinHandler", "cinComponent", "cinButton", "sinStream", "ginCategory", "innCase", "inBlock", "newCase", "innCategory", "inColumn", "insideComponent", "insideChannel", "vinChannel", "newChannel", "sinBlock", "outBlock", "vinPanel", "ginChannel", "vinCase", "isinCase", "innerChan", "insideButton", "innerConnection", "inSlot", "outchannel", "inStream", "outChan", "inCase", "sinSlot", "isinChannel", "inchannel", "sinCase", " inComponent", "inCategory", "cinChannel", "inConnection", " inHandler", "sinColumn", "innSlot", "outColumn", "sinChannel", "ginPanel", "innChannel", "cinStream", "vinCategory", " inChan", "inComponent", "outConnection", " inButton", "newCategory", "inHandler", "inPanel", "ginCase", "sinCategory", "inChan", "inButton", " inchannel", "cinBlock", "cinColumn"], "outChannel": ["inPassword", " outChan", "outCh", "oClient", "outStream", "oChannel", "OutChan", "OutChannel", "outClient", " outCh", " outClient", " outConnection", "exBlock", "outputChan", "outputCh", "oChan", "outBlock", "nStream", "inClient", "outPassword", "outputChannel", "outchannel", " outchannel", "outChan", "inStream", "OutCh", "inchannel", "outputConnection", "exChan", "outChain", "exChain", "nchannel", "OutConnection", "outConnection", "nChan", "oPassword", "exChannel", " outStream", "inChan", "nChannel", " outChain", " outPassword", " outBlock"]}}
{"id1": "18782385", "id2": "19096138", "code1": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"saveFile": ["storeFiles", " saveFiles", "savePage", "saveFiles", "outputFile", "storefile", "outputFiles", "savefile", "outputPage", "storePage", " savePage", "storeFile", " savefile", "outputfile"], "window": ["port", "remote", "volume", "wall", "view", "where", "server", "flow", "wa", "go", "html", "ws", "now", "height", "env", "system", "wd", "this", "scope", "before", "message", "device", "stack", "w", "lock", "file", "event", "query", " Window", "buffer", "session", "context", "stage", "wx", "manager", "Window", "win", "fw", "button", "box", "hw", "driver", "http", "wait", "page", "we", "form", "frame", "draw", "console", "browser", "widget", "history", "Win", "doc", "client", "focus", "screen", "WIND", "th", "document", "gui"], "stream": [" status", " resp", " con", " form", " session", " dos", "is", " response", " screen", "aos", " error", "REAM", " context", " im", " enc", " steam", " console", "Stream", " fin", " zip", " upstream", " sock", " upload", "os", " din", " is", "ream", " streams"], "outputDoc": ["outputDec", "documentDoc", "OutputDocument", "OutputCode", "outputCode", "exportDoc", " outputCode", "displayDocument", "OutputMat", "putDocument", "putDoc", "outputMat", "outputDocument", "OutputDoc", "OutputDec", " outputDocument", "Outputdoc", "outputdoc", "exportCode", " outputdoc", "putMat", "documentDocument", "toDocument", "toDec", "toDoc", "putDec", "toMat", "displayDoc", "documentdoc", "exportDocument", "displaydoc"], "dtd": ["sdTD", "Dtd", "sdtd", " dpd", "ttm", "DTD", " dtm", "dpd", "dtif", "dhTD", "dtm", " dTD", "sdpd", "dTD", "ttif", " dtif", "dhtd", "dhtif", "ttd", "Dpd", "dhtm", "tTD"], "uiElement": ["uObject", "clielement", "tiObject", "uiEngine", "guiFrame", "guielement", "umiComponent", "uiEvent", "uEvent", "UITag", "uEmail", "UIEntry", "culement", "tiItem", "cliMember", "uiMotion", "uciEvent", "iuToken", "UIlement", "zuSecret", "UISecret", "uiSecret", "iulement", "uMember", "zuLink", "UIEngine", "uciBlock", "guiEntity", "cuSecret", "iuE", "guiEvent", "iuFunction", "uiToken", "uiBlock", "iuMotion", "iuFrame", "tiEngine", "uciFunction", "UIBlock", "iuElement", "umiToken", "iuelement", "cliElement", "uiEmail", "zuEmail", "wuEmail", "wuLink", "cuEntry", "uilement", "cliEmail", "tielement", "iuTag", "zuElement", "uiEntity", "iuEntity", "tilement", "guiTag", "ucilement", "uiEntry", "uiComponent", "umiSecret", "tiElement", "tiEntry", "cuToken", "uItem", "uiFrame", "iuEvent", "umilement", "umiEngine", "UIelement", "uiFunction", "uFrame", "uciElement", "uiObject", "uFunction", "iuItem", "cuComponent", "iiMember", "UIEntity", "ulement", "uE", "UIElement", "guiElement", "UILink", "cuElement", "uiE", "uciE", "iuComponent", "uMotion", "iielement", "iuObject", "UIE", "uiTag", "uelement", "uiItem", "wuSecret", "uiLink", "uciMotion", "UIEvent", "iiEmail", "uiMember", "wuElement", "UIEmail", "guiE", "umiEntry", "umiElement", "uielement", "iuBlock", "iiElement", "uElement"], "currentLFClassName": ["currentLEFClassPath", "currentLEFclassNames", "currentLWStyleConfig", "currentLFClassNames", "currentLEFclassName", "currentLFFullNames", "currentLFSystemNames", "currentLFClassClass", "currentLWClassConfig", "currentLFclassNames", "currentLFFullName", "currentLFClassPath", "currentLFDisplayNames", "currentLFclassSet", "currentLEFclassPath", "currentLFClassSet", "currentLFSystemClass", "currentLEFClassClass", "currentLFStyleConfig", "currentLFFullSet", "currentLFClassConfig", "currentLFclassConfig", "currentLFclassName", "currentLFDisplayPath", "currentLFSystemName", "currentLFSystemPath", "currentLWStyleName", "currentLFStyleNames", "currentLWStyleSet", "currentLFclassClass", "currentLFDisplayClass", "currentLWStyleNames", "currentLEFClassName", "currentLWClassName", "currentLEFClassNames", "currentLEFclassClass", "currentLFStyleName", "currentLWClassSet", "currentLFFullConfig", "currentLFStyleSet", "currentLFDisplayName", "currentLWClassNames", "currentLFclassPath"], "systemLFClassName": ["systemLFFFileNames", "systemLFScreenNames", "systemLEFClassName", "systemLFFClassString", "systemLFFileNames", "systemLFSystemString", "systemLEFClassPath", "systemLFFilename", "systemLFFFilePath", "systemLFClassPath", "systemLFclassname", "systemLFFileName", "systemLEFclassPath", "systemLFSystemNames", "systemLFFFileString", "systemLFScreenname", "systemLFclassName", "systemLFScreenPath", "systemLFClassNames", "systemLFClassString", "systemLFclassString", "systemLEFclassName", "systemLFFFileName", "systemLFFileString", "systemLFclassNames", "systemLFFClassName", "systemLFclassPath", "systemLFSystemName", "systemLFClassname", "systemLFFClassPath", "systemLFSystemPath", "systemLFFClassNames", "systemLEFClassNames", "systemLFScreenName", "systemLFFilePath", "systemLEFclassNames", "systemLEFclassname", "systemLEFClassname"], "mainWindowElement": ["MainWinElement", "mainScreenLE", "mainSessionelement", "MainWindowElement", "mainwindowPort", " mainWindowEntry", " mainWinE", " mainFrameEntry", "mainScreenEntry", " mainWindowLE", "mainWinUser", "mainWinPort", "mainWinelement", "mainWindowPort", "MainWindowPort", "mainFrameMENT", " mainWindowMENT", " mainFrameE", "mainWinEntry", "mainFramelement", "mainSessionE", "mainWindowEntry", " mainWinEntry", "mainWindowlement", "mainWindowLE", "mainWinMENT", "mainWinLE", "MainWindowEntry", "mainSectionE", "mainSessionElement", "mainWinE", "mainwindowE", "mainwindowElement", "mainwindowUser", "MainWindowE", " mainFrameMENT", "mainFrameEntry", "mainScreenE", "MainWinelement", "mainWindowMENT", " mainWinLE", "mainWindowE", "MainWindowelement", "mainWinElement", "mainFramePort", "mainFrameelement", "mainWinlement", " mainFrameElement", "mainSectionElement", "mainWindowelement", "mainSessionEntry", "mainFrameUser", "mainSectionEntry", "MainWindowUser", "mainFrameLE", "mainFrameE", "MainWinEntry", " mainFramelement", " mainWinElement", "mainScreenElement", "MainWinUser", "mainwindowEntry", "mainWindowUser", "MainWinPort", "MainWinE", " mainWindowlement", "mainFrameElement", "mainwindowMENT", " mainWindowE", "mainSectionlement"], "volumeElement": [" volumelement", "audioEntry", "volumeEntry", "voiceEntity", "volumelement", "vineelement", "audioEntity", "volumeEntity", "VolumeElement", " volumeEntry", "vineElement", "VolumeEntity", "uiEmail", "audioE", "musicE", "voicelement", "vineE", " volumeEntity", "voiceMember", " volumeEmail", "audioElement", "vinelement", "voiceEntry", "voiceelement", "musicEntry", "volumeE", "uiEntity", "volumeMember", "musicElement", " volumeMember", "musicMember", "VolumeEmail", "voiceE", "uiE", "volumeEmail", "VolumeE", " volumeelement", "volumeelement", " volumeE", "voiceElement"], "player": ["volume", " Player", "radio", "played", "movie", "pool", "display", "pipe", "loader", "sample", "layer", "pro", "file", "controller", "source", "profile", "video", "taker", "youtube", "user", "Player", "PLAY", "driver", "audio", "program", "worker", "peer", "console", "service", "lay", "playing", "play", "ser", "speaking", "uner", "er", "aster", " playing", "table", "position", "live", "score", "game"]}}
{"id1": "14773780", "id2": "23611215", "code1": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    public String uploadFile(String url, int port, String uname, String upass, InputStream input) {\n        String serverPath = config.getServerPath() + DateUtil.getSysmonth();\n        FTPClient ftp = new FTPClient();\n        try {\n            int replyCode;\n            ftp.connect(url, port);\n            ftp.login(uname, upass);\n            replyCode = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(replyCode)) {\n                ftp.disconnect();\n                return config.getServerPath();\n            }\n            if (!ftp.changeWorkingDirectory(serverPath)) {\n                ftp.makeDirectory(DateUtil.getSysmonth());\n                ftp.changeWorkingDirectory(serverPath);\n            }\n            ftp.storeFile(getFileName(), input);\n            input.close();\n            ftp.logout();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return serverPath;\n    }\n", "label": 0, "substitutes": {"testImageInfo": [" testPhotoInfo", " testImagesData", "checkPhotoInfo", " testImagesFile", "checkPhotoList", " testPhotoData", "checkImageInfo", " testImageData", "checkImageFile", "checkPhotoFile", " testImagesList", "checkImageList", "checkImageData", " testImageFile", " testImageList", " testImagesInfo", "checkPhotoData", " testPhotoFile", " testPhotoList"], "IOException": [" IOEx", " IOProblem", "AudioException", "IOEx", "APIException", "AudioProblem", "APIProblem", "AudioEx", "APIEx", "IOProblem"], "start": ["offset", "init", "first", "it", "now", "begin", "before", " started", "birth", "starting", "art", "read", "parse", "id", "step", "base", "from", "time", "send", "wait", "enable", "set", "st", "check", "t", "create", "started", "seed", "wind", " Start", "open", "get", "end", "trans", "reset", "size", "Start", "print", "rest"], "i": ["ix", "name", "im", "bi", "go", "init", "key", "p", "is", "it", "x", "mi", "phi", "gi", "ui", "g", "ex", "si", "major", "info", "u", "b", "gu", "ti", "ci", "me", "multi", "j", "di", "conv", "id", "xi", "f", "m", "batch", "iq", "q", "uu", "y", "ic", "in", "qi", "out", "us", "o", "ai", "I", "s", "to", "n", "my", "pi", "yi", "sim", "index", "ind", "li"], "url": ["mail", "Url", "link", "external", "path", "key", "string", "pattern", "xml", "ul", "r", "u", "mount", "location", "log", "gl", "resource", "host", "id", "dl", "base", "uri", "res", "web", "http", "q", "nl", "el", "str", "ll", "ref", "rel", "l", "null", "lr", "URL", "gif", "ls", "ur"], "istream": ["ositream", "ositiver", "istorage", "istroy", "istable", "ISTstream", "itream", "iptream", "ositrace", "iptorage", "istrace", "iptstream", "itable", "istiver", "intable", "intream", "iststream", "astorage", "astroy", "iptroy", "ISTream", "ISTorage", "aststream", "ISTroy", "astream", "ositable", "itrace", "intiver", "itiver", "intrace"], "ii": ["ni", "nai", "cgi", "ri", "mi", "chi", "gi", "ji", "si", "ini", "hi", "ami", "iu", "irm", "cli", "ista", "iso", "imi", "sci", "cci", "ti", "ci", "zi", "di", "oci", "iov", "xi", "fi", "obi", "iii", "iy", "II", "ei", "qi", "ij", "ki", "iri", "jj", "ai", "vi", "ice", "yi", "pi", "iti", "ati", "ia", "ushi", "li"], "width": ["wy", "len", "path", "wa", "shape", "x", "const", "wn", "dim", "Width", "foo", "w", "dx", "idth", "value", "min", "layout", "data", "fw", "step", "cut", "left", "scale", "body", "draw", "frame", "crop", "text", "widget", "weight", "tall", "write", "length", "wid", "position", "px", "cale", "size", "window", "area", "format"], "height": ["hang", "volume", "radius", "amount", "chip", "gravity", "shape", "stroke", "def", "capacity", "acity", "above", "cue", "grow", "div", "buffer", "rank", "resolution", "h", "padding", "kw", "density", "frame", "depth", "green", "alpha", "history", "angle", "length", "family", "dimension", "rise", "Height", "size", "window", "sky", "style"], "stop": ["delete", "Stop", "obj", "counter", "est", "shape", "jump", "termination", "it", " Stop", "delay", "wake", "peak", "disable", "success", "gc", "quit", "fin", "close", "next", "trip", "hop", "id", "result", "step", "pop", "wait", "enable", "pause", "ops", "set", "st", "no", "loop", "duration", "term", "null", "end", "skip", "period", " STOP", "rest"]}}
{"id1": "13122204", "id2": "22366505", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"unzipModel": ["unzipmodel", "unlateImage", "unarchiveModule", "Unzipmodel", "uncodeModule", "unarchiveModel", "UnzipImage", "UnzipModel", "UnzipModule", "uncodeModel", "unlatemodel", "uncodeImage", "UnarchiveModel", "UnarchiveModule", "unarchivemodel", "UnarchiveImage", "Unarchivemodel", "unarchiveImage", "unlateModel", "unzipImage", "unzipModule", "unlateModule", "uncodemodel"], "filename": ["fp", "name", "println", "FN", "origin", "path", "ln", "mson", "journal", "ivo", "nm", "jpg", "fn", "original", "ename", "subject", "title", "download", "nil", "file", "location", "source", "SourceFile", "fil", "til", "dra", "FILE", "kl", "txt", "FIL", "stem", "nl", "wl", "sql", "Filename", "fle", "output", "n", "river", "directory", "username"], "tempdir": ["testdir", "Tempdir", "tmppath", "tmpdir", "tmpDIR", "tempfolder", "Tempdirectory", "temdirectory", "temDir", " tempfile", "Tempfile", "tempath", "tmpDir", "TempDir", "testDir", " tempDir", "temppath", "testfolder", "tempfile", "temDIR", " tempdirectory", "tempDIR", " tempDIR", "tempdirectory", "tmpfile", "tempDir", "tmpfolder", "testpath", "temdir", "tmpdirectory", "temfolder"], "dest": ["port", "deep", "obj", "origin", "est", "parent", "nom", "del", "tr", "writer", "Dest", "inv", "display", "pipe", "master", "src", "stream", "nt", "target", "slave", "temp", "source", "pos", "buffer", "bin", "comb", "tmp", "dat", "ptr", "coord", "default", "dev", "result", "generated", "tail", "cont", "send", "sum", "peer", "ctr", "store", "st", "desc", "out", "loc", "foreign", "test", "usr", "des", "dc", "table", "output", "write", "null", "dist", "trans", "document", "rest", "decl"], "fis": ["ifatis", "zos", "li", "zatis", "fatis", "zjs", "flis", "zi", "ifis", "flos", "fljs", "fi", "fjs", "fli", "flatis", "los", "ifos", "ljs", "lis", "ifi"], "BUFFER": ["BAOUNT", "BUFR", "CUFR", "BABER", "BUULT", "BFFER", "BBER", "BLOUNT", "FFERMT", "MAXBuffer", " BUMT", "BUBER", "LOCKFR", "BUOUNT", "LOCKFFER", "BAULT", " BUULT", "BLFFER", "BOUNT", "BLBuffer", "BufferBER", "BLBER", "MAXFFER", "BufferFFER", "CUBER", " BUBER", "BUMT", " BUOUNT", "BAFFER", "BufferBuffer", " BUFR", "FFERBER", "CUBuffer", "FFERBuffer", " BUBuffer", "BUBuffer", "LOCKBuffer", "CUFFER", "MAXOUNT", "LOCKBER", "BULT", "MAXBER", "BufferMT", "FFERFFER"], "zis": ["zip", "xos", " zos", "Zi", "zos", "Ziss", "oziss", " zris", "fiss", "zoneis", "Zis", "zris", " zIS", "ziIS", " zes", "zeits", "zeos", "zIS", "ozi", "zits", "zi", "zes", "zios", "xi", "zeiss", "zeris", " ziss", "zeIS", "fi", "xis", " zi", "zoneris", "fip", "ozis", "zoneits", "ozip", " zip", "ziss", "zees", "zoneiss", "xiss", "Zos", "zeis", " zits", "ziis", "zies"], "entry": ["zip", "name", "link", "existent", "key", "enter", "header", "image", "system", "zo", "part", "char", "def", "se", "nt", "index", "escape", "je", "member", "e", "ent", "file", "jo", "source", "log", "inter", "Entry", "record", "match", "ry", "result", "comment", "way", "cell", "or", "card", "piece", "chain", "element", "item", "jar", "table", "word", "connection", "row", "ie", "ce", "ze", "pe"], "count": ["cache", "counter", "len", "child", "OUNT", "amount", "part", "cc", "cloud", "nt", "current", "add", "index", "max", "acc", "nb", "number", "all", "start", "buffer", "read", "ount", "match", "call", "num", "f", "comment", "c", "base", "batch", "force", "cont", "sum", "page", "cond", "cell", "ctr", "check", "code", "length", "total", "common", "Count", "core", "z", "ce", "size", "found", "ct", "n"], "data": ["cache", "image", "raw", "ata", "mat", "part", "p", "message", "sample", "content", "dec", "value", "all", "buffer", "dat", "results", "next", "zero", "result", "step", "batch", "dl", "done", "accept", "ATA", "valid", "str", "text", " DATA", "out", "rel", "d", "table", "output", "n", "DATA", "size", "window", "bytes", "area", "format"], "fos": [" foes", " fios", "fOS", "voes", "voses", "foes", "fios", "Foses", "lios", "foses", "foss", "Foss", " fOS", "Fios", "lOS", "loss", "FOS", "Fos", " foses", "los", "voss", "Foes", "vos", " foss"]}}
{"id1": "23585985", "id2": "5299276", "code1": "    public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException {\n        StreamSource streamSource = new StreamSource();\n        if (item.getType() == Type.JAVA_OBJECT) {\n            LOG.debug(\"Streaming Java object\");\n            Object obj = ((JavaObjectValue) item).getObject();\n            if (!(obj instanceof File)) {\n                throw new XPathException(\"Passed java object should be a File\");\n            }\n            File inputFile = (File) obj;\n            InputStream is = new FileInputStream(inputFile);\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(inputFile.toURI().toURL().toString());\n        } else if (item.getType() == Type.ANY_URI) {\n            LOG.debug(\"Streaming xs:anyURI\");\n            String url = item.getStringValue();\n            if (url.startsWith(\"/\")) {\n                url = \"xmldb:exist://\" + url;\n            }\n            InputStream is = new URL(url).openStream();\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(url);\n        } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) {\n            LOG.debug(\"Streaming element or document node\");\n            if (item instanceof NodeProxy) {\n                NodeProxy np = (NodeProxy) item;\n                String url = \"xmldb:exist://\" + np.getDocument().getBaseURI();\n                LOG.debug(\"Document detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n            Serializer serializer = context.getBroker().newSerializer();\n            NodeValue node = (NodeValue) item;\n            InputStream is = new NodeInputStream(serializer, node);\n            streamSource.setInputStream(is);\n        } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) {\n            LOG.debug(\"Streaming base64 binary\");\n            BinaryValue binary = (BinaryValue) item;\n            byte[] data = (byte[]) binary.toJavaObject(byte[].class);\n            InputStream is = new ByteArrayInputStream(data);\n            streamSource.setInputStream(is);\n            if (item instanceof Base64BinaryDocument) {\n                Base64BinaryDocument b64doc = (Base64BinaryDocument) item;\n                String url = \"xmldb:exist://\" + b64doc.getUrl();\n                LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n        } else {\n            LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType()));\n            throw new XPathException(\"wrong item type \" + Type.getTypeName(item.getType()));\n        }\n        return streamSource;\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getStreamSource": ["getFormSources", " getStreamIterator", "getStreamIterator", " getFormIterator", "getStreamerSources", "getStreamSources", "getRawSources", "getStreamStream", " getFormSources", "getRawStream", "getFormIterator", " getFormStream", "getFormStream", " getStreamSources", "getFormSource", " getFormSource", "getRawSource", "getStreamerSource", " getStreamStream", "getStreamerIterator", "getRawIterator", "getStreamerStream"], "item": ["link", "p", "info", "device", "content", "container", "jack", "that", "el", "cell", "store", "element", "spec", "iter", "tree", "list", "input", "document", "sim", "name", "msg", "unit", "other", "attr", "claim", "now", "xml", "original", "menu", "article", "detail", "event", "source", "on", "result", "m", "abc", "type", "oc", "com", "mem", "rule", "ref", "edit", "row", "att", "tk", "raw", "addr", "remote", "attribute", "up", "anything", "exp", "this", "hit", "job", "value", "json", "val", "record", "mix", "stuff", "good", "object", "test", "pkg", "module", "term", "re", "area", "handle", "owner", "key", "initial", "image", "it", "add", "entry", "local", "om", "related", "atom", "status", "instance", "check", "op", "Item", "app", "items", "word", "empty"], "context": ["sequence", "metadata", "cache", "view", "parent", "system", "tx", "operator", "cc", "subject", "current", "info", "content", "construct", "event", "config", "location", "network", "resource", "information", "template", "runtime", "application", "c", "search", "command", "instance", "object", "set", "check", "text", "collection", "chain", "environment", "condition", "Context", "ctx", "component", "connection", "kernel", "input", "options", "mc", "document", "wrapper", "index", "state"], "streamSource": [" streamProvider", "streamSpec", "StreamProvider", "designStore", "consoleSourceFile", " streamSources", "StreamSources", "streamStore", "StreamSource", "streamManager", "acceptSite", "runtimeScope", "constSourceFile", "followStore", " streamManager", "designSource", "StreamManager", "signSOURCE", "constSite", "socketSourceFile", "feedStore", "consoleStore", "hostSourceFile", "followSpec", "streamSourceFile", "consoleManager", "hostStore", "StreamSOURCE", "feedSite", "peerSourceFile", " streamSourceFile", "followSOURCE", "streamSite", "feedSource", " streamStore", "feedSourceFile", "socketStore", "signScope", "consoleProvider", "streamProvider", " streamType", "acceptScan", "socketSite", "streamSources", "consoleType", "signSource", " streamScope", "hostType", "streamScope", "acceptSource", " streamSOURCE", "streamType", "peerScan", "socketSource", "followSource", "hostSource", "constScan", "runtimeSource", "designSpec", "feedSOURCE", "streamScan", "feedSources", "designSOURCE", "peerSite", "consoleSource", "constSource", "streamSOURCE", "consoleSources", "peerSource", "acceptSourceFile", " streamSite", "runtimeSOURCE", " streamSpec"], "obj": ["sky", "msg", "obs", "mk", "resp", "attr", "x", "cmp", "org", "cb", "def", "act", "aux", "ex", "bh", "nt", "ox", "mo", "aos", "json", "cmd", "ck", "obo", "tmp", "j", "oj", "txt", "xy", "abs", "pot", "oc", "ot", "stuff", "bj", "y", "object", "t", "ref", "bo", "o", "pkg", "app", "jj", "os", "ob", "co", "js", "cod", "ht", "ct", "tk", "Obj"], "inputFile": ["Inputfile", "importFile", "textfile", "importObject", "InputPath", " InputFile", " InputObject", " inputSet", "InputObject", "inputObject", "sequenceFile", "InputFile", " inputFiles", "mediaObject", "mediaFILE", "InputFILE", " inputfile", "mediaFile", " inputObject", "sequencefile", "importPath", "textObject", "inputFILE", " Inputfile", " inputPath", " InputSet", "mediafile", "sequenceSet", "inputPath", "InputFiles", "textFile", "sequenceObject", "inputfile", "textFILE", "inputSet", "inputFiles", "importFiles"], "is": ["tis", "im", "obs", "cs", "init", "iss", "bs", "isin", "as", "stats", "info", "dis", "isa", "sis", "iso", "Is", "ys", "isf", "i", "ils", "ris", "sys", "es", "IS", "xs", "abs", "fs", "cont", "res", "sim", "bis", "its", "set", "ios", "isl", "ins", "ms", "ims", "ains", "ists", "ais", "iris", "nis", "was", "os", "s", "isc", "atis", "mis", "js", "ics", "ires", "isi", "ls", "has", "lis"], "url": ["mail", "Url", "util", "hl", "link", "external", "html", "path", "len", "cert", "domain", "full", "string", "attr", "addr", "pattern", "char", "org", "handle", "xml", "r", "run", "mount", "label", "log", "gl", "ssl", "host", "email", "user", "id", "f", "dl", "uri", "web", "http", "sl", "nl", "el", "q", "sql", "rl", "console", "prefix", "str", "impl", "ll", "browser", "address", "ref", "loc", "https", "rel", "pkg", "l", "db", "term", "dir", "lr", "URL", "ml", "tm", "norm", "print", "ls", "ur", "href", "ul", "format"], "np": ["fp", "hp", "nit", "gov", "nm", "pn", "nw", "dh", "rn", "nn", "nb", "vp", "nr", "ph", "bp", "rpm", "num", "lp", "nl", "NP", "nv", "nc", "mp", "nu", "mn", "jp", "dp", "pkg", "wp", "dn", "n", "kr", "pd", "tp"], "serializer": ["erialization", " serialisation", "erializer", "initialization", "initialifier", "serialifier", " serialization", "initializer", "serialer", "initialisation", "serialisation", "virtualifier", "initialer", " serialifier", "serialiser", "virtualization", "virtualizer", "erialiser", "erialer", "initialiser", "virtualisation", " serialiser", "serialization", " serialer"], "node": ["remote", "name", "msg", "view", "image", "nm", "mor", "oid", "xml", "src", "nt", "entry", "content", "article", "nn", "nb", "entity", "value", "json", "od", "source", "event", "resource", "root", "num", "Node", "m", "object", "nu", "seed", "doc", "component", "tree", "row", "token", "document", "n"], "binary": ["Source", "New", "xml", "ex", "Ex", "Entry", "Store", "_", "instance", "of", "get", "null", "Raw", "n"]}}
{"id1": "16556717", "id2": "2324868", "code1": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 0, "substitutes": {"getSHADigest": ["getSHAdegests", "getSHADdigse", "getSHAdegse", "getSHADdigest", "getSHADdigests", "getSHADDigse", "getSHAdigest", "getSHADigse", "getSHADDigests", "getSHAdegester", "getSHAdigester", "getSHADegests", "getSHAdigse", "getSHADegest", "getSHAdegest", "getSHADegse", "getSHADDigester", "getSHADegester", "getSHADigester", "getSHAdigests", "getSHADigests", "getSHADDigest", "getSHADdigester"], "password": ["name", "response", "key", "string", "pattern", "auth", "wd", "description", "message", "w", "database", "value", "Password", "session", " Password", "email", "data", "padding", "user", "id", "login", "sword", "command", "prefix", "hash", "text", "address", "phrase", "words", "word", "input", "reset", "pass", "token", "username", "secret"], "digest": ["igEST", " digment", "dEST", "Digest", "hashment", " digist", "mentest", "dest", " digested", "dighash", "decgest", "Digester", "mentester", "Diggest", "hashested", "igest", "diggest", "mentgest", "Dighash", "hashest", "digse", "Digist", "igse", "ighash", "digment", " digse", "digested", "mentEST", "Digse", "Digment", " digEST", "digEST", "decEST", "hashEST", "DigEST", "digester", "dist", "decester", "digist", "dested", "decest", "Digested", " dighash"], "sha": ["access", "auto", "wa", "go", "ya", "ka", "sq", "ssh", "shell", "phi", "addr", "shared", "shi", "ho", "sh", "si", "sa", "a", "hi", "mac", "wal", "ppa", "iso", "SHA", "ssl", "func", "sche", "git", "sam", "pa", "po", "ah", "sum", "tar", "lambda", "da", "alpha", "ta", "md", "hash", "api", "no", "ha", "asha", "ma", "ca", "ao", "na", "qa", "acl", "HA", "pi", "has"], "pwhash": ["pWHhash", " psway", "pthash", "pwhay", "pWHay", "pswashed", "pWHat", "psway", " pswashed", "pWHashed", " pswhash", " pwhat", "pthat", "pswhash", "pwhat", " pwhhash", " pswat", " pwhashed", "pthashed", "pshash", "pshhash", "pthhash", " pswash", "pWHash", "pshashed", "pwhhash", "pwhashed", " pwhay", "pswat", "pswash", "pshay"]}}
{"id1": "10176678", "id2": "13152325", "code1": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"testLoadHttpGzipped": ["testLoadHttpgZips", "testLoadHttpGzipips", "testLoadHttpGgzIP", "testLoadHttpGzIP", "testLoadHttpGZipped", "testLoadHttpgzips", "testLoadHttpGgzips", "testLoadHttpGzips", "testLoadHttpGgzipping", "testLoadHttpGZipping", "testLoadHttpgzipping", "testLoadHttpGzipipped", "testLoadHttpGzipipping", "testLoadHttpgzipped", "testLoadHttpgZIP", "testLoadHttpGZIP", "testLoadHttpGzipIP", "testLoadHttpGZips", "testLoadHttpgzIP", "testLoadHttpgZipping", "testLoadHttpGzipping", "testLoadHttpGgzipped", "testLoadHttpgZipped"], "url": ["mail", "Url", "name", "msg", "link", "html", "pl", "path", "key", "full", "string", "p", "pattern", "fail", "ret", "mount", "config", "location", "b", "err", "ssl", "host", "reason", "build", "id", "result", "dl", "type", "base", "uri", "format", "web", "http", "q", "status", "sql", "str", "ll", "browser", "ref", "loc", "rect", "rel", "test", "l", "policy", "lr", "URL", "options", "acl", "ls", "ur", "state"], "loadingInfo": ["readingNow", " loadingNow", "LoadingInf", "contentInf", "loadingNow", "readingInf", " loadingData", "contentNow", "loadingInf", "readingStatus", "LoadingNow", " loadingInf", "LoadingInfo", "contentInfo", "loadingStatus", "contentData", "LoadingStatus", " loadingStatus", "readingInfo", "LoadingData", "loadingData"], "contentInputStream": ["contentByteSteam", "contentOutputForm", "contentInputPoint", "contentOutputStream", "contentInputThread", "fileInputstream", "contentInfostream", "contentInputSteam", " contentOutputSteam", "contentInputForm", "contentIntSteam", "contentReadSteam", " contentInputSteam", "contentStreamStream", "fileStreamstream", "contentStreamstream", "contentReadPoint", "contentInfoStream", "fileStreamSteam", "contentStreamSteam", "contentOutputPoint", "contentReadForm", "contentIntForm", "fileStreamThread", "contentInfoSteam", " contentInputForm", "contentIntStream", " contentOutputForm", "contentStreamThread", "fileInputThread", "fileStreamStream", "contentByteThread", "contentInfoThread", "contentBytestream", "fileInputStream", "contentOutputSteam", " contentInputPoint", "contentByteStream", "contentReadStream", "fileInputSteam", " contentOutputPoint", " contentOutputStream", "contentInputstream", "contentIntPoint"], "actual": ["currently", "view", "other", "array", "initial", "full", "tested", "now", "required", "approximately", "present", "true", "act", "older", "actually", "false", "old", "original", "current", " Actual", "partial", "all", "ual", "produced", "result", "fake", "truth", "valid", "virtual", "affected", "verified", "test", "received", "reported", "total", "real", "latest", "rendered", "Act", "raw"], "expected": ["nexpected", "pect", "required", "tested", "EXP", "awaited", "erved", "confirmed", "ex", "old", "current", " unexpected", "ired", "umed", "important", "produced", "checked", "announced", "example", "fake", "valid", "anted", "allowed", "or", "pected", "test", "supported", "anticipated", " expect", "planned", "always", "want", "reported", "ert", "received", " expecting", "ed", "pects"]}}
{"id1": "3024970", "id2": "4750967", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamToOutputFile", "testCopy_inputStreamtoInputstream", "testCopy_inputStreamtoInputSteam", "testCopy_inputStreamtoOutputSteam", "testCopy_inputStreamTooutputSteam", "testCopy_inputStreamTooutputFile", "testCopy_inputStreamtoOutputstream", "testCopy_inputStreamToInputstream", "testCopy_inputStreamToInputSteam", "testCopy_inputStreamTooutputstream", "testCopy_inputStreamToOutputSteam", "testCopy_inputStreamtoInputFile", "testCopy_inputStreamToInputStream", "testCopy_inputStreamtoOutputStream", "testCopy_inputStreamTooutputStream", "testCopy_inputStreamtoOutputFile", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamToInputFile", "testCopy_inputStreamtoInputStream"], "in": ["inn", "scan", "im", "al", "up", "init", "p", "is", "it", "ac", "ain", "mi", "inv", "sin", "inner", "xml", "this", "isin", "ini", "r", "din", "copy", "mm", "source", "log", "bin", "i", "h", "nin", "read", "io", "gin", "on", "c", "from", "In", "q", "el", "sql", "ic", "ins", "inside", "en", "IN", "doc", "l", "con", "iter", "ai", "n", " din", "input", "cin", "rin", "mc", "inf", "ind"], "baout": [" bain", "oaOut", "abaOut", "BaOut", "kain", "caOut", " baot", "kaOut", "baOut", "BAOut", "Balog", "BAin", " baOut", "calog", "baend", "boio", "baot", "abaot", "boout", "abaout", "balog", "abain", "kaend", "caio", " baend", "oaio", "kaout", " baouts", "boin", "Baouts", "bain", "BAot", "BAout", "baio", "Baout", "baouts", "oain", "cain", "caouts", "caout", " balog", "boOut", "caend", "oaout"], "out": ["obj", "up", "it", " Out", "Out", "g", "ex", "copy", "aos", "cmd", "all", "b", "sys", "log", "io", "serv", "conv", "gt", "res", "sum", "ot", "set", "check", "t", "at", "o", "OU", "output", "gr", "client", "con", "null", "to", "oss", "list", "co", "outs", "OUT", "net", "n", "ou"], "count": ["counter", "amount", "resp", "nt", "current", "nb", "number", "start", "read", "ount", "id", "num", "c", "sum", "ctr", "code", "length", "total", "Count", "skip", "z", "size", "N", "found", "ct", "index"]}}
{"id1": "13122204", "id2": "19868933", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unzipmodel", "unlateImage", "unarchiveModule", "Unzipmodel", "uncodeModule", "unarchiveModel", "UnzipImage", "UnzipModel", "UnzipModule", "uncodeModel", "unlatemodel", "uncodeImage", "UnarchiveModel", "UnarchiveModule", "unarchivemodel", "UnarchiveImage", "Unarchivemodel", "unarchiveImage", "unlateModel", "unzipImage", "unzipModule", "unlateModule", "uncodemodel"], "filename": ["fp", "name", "println", "FN", "origin", "path", "ln", "mson", "journal", "ivo", "nm", "jpg", "fn", "original", "ename", "subject", "title", "download", "nil", "file", "location", "source", "SourceFile", "fil", "til", "dra", "FILE", "kl", "txt", "FIL", "stem", "nl", "wl", "sql", "Filename", "fle", "output", "n", "river", "directory", "username"], "tempdir": ["testdir", "Tempdir", "tmppath", "tmpdir", "tmpDIR", "tempfolder", "Tempdirectory", "temdirectory", "temDir", " tempfile", "Tempfile", "tempath", "tmpDir", "TempDir", "testDir", " tempDir", "temppath", "testfolder", "tempfile", "temDIR", " tempdirectory", "tempDIR", " tempDIR", "tempdirectory", "tmpfile", "tempDir", "tmpfolder", "testpath", "temdir", "tmpdirectory", "temfolder"], "dest": ["port", "deep", "obj", "origin", "est", "parent", "nom", "del", "tr", "writer", "Dest", "inv", "display", "pipe", "master", "src", "stream", "nt", "target", "slave", "temp", "source", "pos", "buffer", "bin", "comb", "tmp", "dat", "ptr", "coord", "default", "dev", "result", "generated", "tail", "cont", "send", "sum", "peer", "ctr", "store", "st", "desc", "out", "loc", "foreign", "test", "usr", "des", "dc", "table", "output", "write", "null", "dist", "trans", "document", "rest", "decl"], "fis": ["ifatis", "zos", "li", "zatis", "fatis", "zjs", "flis", "zi", "ifis", "flos", "fljs", "fi", "fjs", "fli", "flatis", "los", "ifos", "ljs", "lis", "ifi"], "BUFFER": ["BAOUNT", "BUFR", "CUFR", "BABER", "BUULT", "BFFER", "BBER", "BLOUNT", "FFERMT", "MAXBuffer", " BUMT", "BUBER", "LOCKFR", "BUOUNT", "LOCKFFER", "BAULT", " BUULT", "BLFFER", "BOUNT", "BLBuffer", "BufferBER", "BLBER", "MAXFFER", "BufferFFER", "CUBER", " BUBER", "BUMT", " BUOUNT", "BAFFER", "BufferBuffer", " BUFR", "FFERBER", "CUBuffer", "FFERBuffer", " BUBuffer", "BUBuffer", "LOCKBuffer", "CUFFER", "MAXOUNT", "LOCKBER", "BULT", "MAXBER", "BufferMT", "FFERFFER"], "zis": ["zip", "xos", " zos", "Zi", "zos", "Ziss", "oziss", " zris", "fiss", "zoneis", "Zis", "zris", " zIS", "ziIS", " zes", "zeits", "zeos", "zIS", "ozi", "zits", "zi", "zes", "zios", "xi", "zeiss", "zeris", " ziss", "zeIS", "fi", "xis", " zi", "zoneris", "fip", "ozis", "zoneits", "ozip", " zip", "ziss", "zees", "zoneiss", "xiss", "Zos", "zeis", " zits", "ziis", "zies"], "entry": ["zip", "name", "link", "existent", "key", "enter", "header", "image", "system", "zo", "part", "char", "def", "se", "nt", "index", "escape", "je", "member", "e", "ent", "file", "jo", "source", "log", "inter", "Entry", "record", "match", "ry", "result", "comment", "way", "cell", "or", "card", "piece", "chain", "element", "item", "jar", "table", "word", "connection", "row", "ie", "ce", "ze", "pe"], "count": ["cache", "counter", "len", "child", "OUNT", "amount", "part", "cc", "cloud", "nt", "current", "add", "index", "max", "acc", "nb", "number", "all", "start", "buffer", "read", "ount", "match", "call", "num", "f", "comment", "c", "base", "batch", "force", "cont", "sum", "page", "cond", "cell", "ctr", "check", "code", "length", "total", "common", "Count", "core", "z", "ce", "size", "found", "ct", "n"], "data": ["cache", "image", "raw", "ata", "mat", "part", "p", "message", "sample", "content", "dec", "value", "all", "buffer", "dat", "results", "next", "zero", "result", "step", "batch", "dl", "done", "accept", "ATA", "valid", "str", "text", " DATA", "out", "rel", "d", "table", "output", "n", "DATA", "size", "window", "bytes", "area", "format"], "fos": [" foes", " fios", "fOS", "voes", "voses", "foes", "fios", "Foses", "lios", "foses", "foss", "Foss", " fOS", "Fios", "lOS", "loss", "FOS", "Fos", " foses", "los", "voss", "Foes", "vos", " foss"]}}
{"id1": "13439950", "id2": "8216539", "code1": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 0, "substitutes": {"readRemoteFile": ["downloadStaticFrom", "downloadRemoteFilename", "readLocalRemote", "readRemoteFrom", "readStaticFrom", "downloadRemoteRemote", "downloadStaticFile", "downloadStaticRemote", "readStaticFilename", "readLocalFile", "readLocalFrom", "downloadRemoteFrom", "readStaticRemote", "readStaticFile", "readremoteRemote", "readremoteFilename", "downloadRemoteFile", "downloadStaticFilename", "readremoteFrom", "readRemoteFilename", "readremoteFile", "readLocalFilename", "readRemoteRemote"], "response": ["sequence", "cache", "view", "server", "answer", "version", "resp", "string", "image", "settings", "continue", "description", "message", "sample", "value", "json", "source", "network", "resolution", "next", "data", "respons", "example", "result", "application", "res", "report", "send", "vector", "command", "status", "onse", "body", "Response", "service", "str", "summary", "address", "relation", "output", "line", "block", "request", "connection", "reset", "reply", "print", "secret", "format"], "url": ["mail", "Url", "link", "hl", "name", "pl", "char", "ret", "r", "mount", "cmd", "lb", "b", "gl", "ssl", "resource", "build", "bel", "base", "dl", "abs", "uri", "web", "http", "nl", "sl", "el", "rl", "fl", "str", "ll", "browser", "ref", "https", "loc", "rel", "l", "lr", "URL", "ur", "ul"], "is": ["ri", "ip", "does", "it", "iss", "bs", "rs", "as", "isa", "sis", "iso", "Is", "ir", "i", "sys", "isf", "ris", "serv", "es", "IS", "\u00eds", "fs", "bis", "its", "ic", "in", "ios", "isl", "ins", "ms", "ists", "ais", "iris", "sels", "os", " Is", "isc", "ates", "isi", "nis", "lis"], "br": ["bi", "bn", "dr", "tr", "bc", "BR", "ver", "bs", "adr", "bh", "hr", "r", "bl", "repl", "Br", "b", "bd", "bridge", "wr", "nr", "buf", "ber", "bp", "res", "vr", "bf", "rob", "str", "browser", "pr", "bm", "rel", "jp", "ro", "gr", "bt", "bro", "shr", "mr", "cr", "lr", "rb", "fr", "sp", "be"], "s": ["p", "string", "ts", "sq", "bs", "still", "a", "rs", "strings", "g", "ps", "v", "ats", "r", "se", "stats", "sample", "ns", "w", "gets", "sb", "e", "series", "value", "b", "i", "S", "gs", "h", "sports", "ss", "es", "j", "less", "ves", " gets", " samples", "m", "ies", "sv", "sts", "txt", "res", "its", "y", "sql", "single", "str", " ts", "ms", "ins", "t", "o", "csv", "l", "sn", "tes", "os", "sym", " inputs", "js", "z", "qs", "ls", "n"], "eof": ["eeos", "eot", "Eef", "ef", " eomp", " eif", " ef", "eOF", " eef", "eeot", "seot", "eeol", "Eol", "eeomp", " eov", "eOf", "seef", "geif", "eomp", "eow", "eos", "Eomp", "Eof", "eeOF", "eeow", " eow", "eif", "eeif", "sef", "geOF", "Eos", " eOf", "eeof", "geof", "eeef", "geow", "Eov", "eol", " eot", " eos", "eeov", "eef", "eeOf", "seof", " eOF", "EOf", "eov", " eol"]}}
{"id1": "6558022", "id2": "5989666", "code1": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"CheckUrl": ["Checkurl", "checkURL", " checkURL", "checkUrl", "checkStr", " validateUrl", " validateurl", "checkurl", " validateURL", " validateStr", " checkUrl", "CheckURL", " checkurl", " checkStr", "CheckStr"], "urlvalue": ["stringstring", "urlval", "stringname", "urlformat", "Urlvalue", "urlname", " urlformat", "Urlval", "nullvalue", "stringValue", "nullname", "URLval", "URLstring", "stringvalue", "URLformat", "nullValue", "urlstring", "Urlstring", " urlval", "urlValue", "Urlformat", " urlstring", "UrlValue", "Urlname", "nullstring", "URLvalue"], "inputLine": [" inputValue", "serviceLine", "outputChain", "serviceString", "inputValue", " inputChain", "outputLine", " inputLINE", "feedChain", "inputChain", "outputRow", "inputRow", "inputString", " inputRow", "inputLINE", "selectline", "feedLINE", "feedLine", "inputline", "serviceRow", "feedString", "selectLINE", "selectLine", " inputString", "outputLINE", "outputline", "outputValue", "outputString", "selectValue", "serviceLINE", " inputline"], "url": ["Url", "name", "hl", "link", "pl", "org", "char", "ul", "atl", "r", "job", "mount", "file", "b", "log", "ssl", "build", "bel", "f", "dl", "base", "web", "http", "nl", "sl", "q", "el", "rl", "str", "impl", "ll", "ref", "https", "rel", "l", "open", "get", "null", "arl", "www", "URL", "ls", "ur"], "urlConnection": ["fileConnect", "webConn", "httpConnection", "fileconnection", " urlConnect", "webconnection", "urlLink", "URLConnection", "urlConnect", "webConnection", "webConnect", "httpconnection", "httpConnect", "fileConnection", " urlDescription", "urlDescription", "URLLink", "urlConn", "httpLink", "URLConnect", "URLDescription", "httpConn", "httpDescription", "fileConn", "urlconnection", " urlLink"], "in": ["inn", "inc", "is", "inner", "xml", "r", "din", "file", "source", "b", "all", "log", "bin", "read", "gin", "on", "f", "txt", "m", "from", "In", "sum", "conf", "body", "ins", "out", "mn", "IN", "by", "doc", "l", "get", " din", "cin", "rin", "input", "reader", "n", "thin"]}}
{"id1": "3430784", "id2": "11952735", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"decodeBody": ["decprocessContent", " DecodeContent", " DecodeForm", " DecodeHeader", " DecodesHeader", "decprocessForm", "decodesContent", "decodesHeader", " DecodeBody", "decodeForm", " DecodesForm", "decodedContent", "decodedHeader", "decprocessHeader", "decodeContent", "decodeHeader", " DecodesBody", "decodedBody", "decodesForm", " DecodesContent", "decodedForm", "decodesBody", "decprocessBody"], "in": ["conn", "ac", "is", "v", "ex", "din", "info", "content", "asin", "data", "from", "cont", "form", "iter", "req", "input", "oin", "ind", "ain", "act", "xml", "r", "source", "h", "on", "m", "sql", "body", "inside", "IN", "con", "ma", "cin", "rin", "inf", "pc", "inc", "up", "isin", "mm", "all", "k", "gin", "c", "In", "q", "or", "ins", "load", "doc", "ai", "vin", "inn", "al", "init", "it", "mat", "inner", "add", "file", "b", "nin", "bin", "i", "serv", "check", "en", "l", "get", "to", "pi", "reader", "n"], "contentTransferEncoding": ["contentTransferFormType", "contentTransferEnacing", "contentRequestEnoding", "contentTypeEncoded", "contentInfoencling", "contentTransferEnapping", "contentTransferAuthType", "contentTypeEncoding", "contentTransferChode", "contentTransferChapping", "contentTransferEvication", "contentTransferEnoding", "contentTransferCollasting", "contentInfoEncling", "contentTypeEnode", "contentTransferencoder", "contentRequestencoded", "contentRequestEncType", "contentTypeEncapping", "contentInfoEncoding", "contentTransferSeapping", "contentTransferAuthoding", "contentTransferEncType", "contentTransferEncoder", "contentTransferEnation", "contentTypeEnoded", "contentTransferEncode", "contentTransferEncation", "contentInfoencacing", "contentRequestencoding", "contentRequestEncoder", "contentRequestEnation", "contentTransferencoded", "contentRequestEncication", "contentTransferEvoder", "contentTransferEncling", "contentRequestEnoder", "contentInfoencoding", "contentTransferEncication", "contentTransferEnication", "contentTypeEnoding", "contentTransferEvoded", "contentRequestEncation", "contentTransferColloding", "contentRequestEnoded", "contentInfoencoder", "contentTransferCollation", "contentTransferChoded", "contentTransferEvoding", "contentInfoEncoder", "contentTransferencoding", "contentTransferChoding", "contentTransferEnling", "contentRequestEncoded", "contentRequestencoder", "contentTransferEncasting", "contentTransferEnoder", "contentRequestEncasting", "contentTransferencication", "contentRequestencication", "contentTransferEnType", "contentTransferEnoded", "contentTransferSeode", "contentTransferSeoding", "contentTransferencling", "contentTransferFormoding", "contentTransferEncacing", "contentRequestEnasting", "contentRequestEncoding", "contentTransferAuthoded", "contentRequestEnType", "contentTransferFormling", "contentTransferEnode", "contentInfoEncacing", "contentTransferSeoded", "contentTransferAuthoder", "contentTypeEnapping", "contentTransferEnasting", "contentTransferEncapping", "contentTransferencType", "contentTransferFormoder", "contentTransferencacing", "contentTypeEncode", "contentTransferEncoded", "contentTransferColloder"], "tempBody": [" temporaryFoot", "tmpBody", "TempFile", "temBox", " temporaryBox", "TempHead", "TempBody", " tempBox", "tempReturn", "tempFoot", "tmpbody", "tabBox", "Tempbody", " tempbody", "tmpBox", "tempHead", " tempHead", "temFoot", "tembody", "temHead", "tabFoot", "tmpHead", "temReturn", "tempFile", "temFile", "temBody", "tabBody", " tempFile", "tabReturn", " temporaryBody", " temporaryReturn", "tempBox", "tempbody"], "out": ["auto", "obj", "up", "writer", "is", "it", "Out", "inv", "inner", "v", "ex", "aos", "outer", "ent", "gc", "all", "sys", "cos", "log", "io", "one", "conv", "user", "m", "ou", "res", "sum", "t", "o", "OU", "l", "output", "client", "os", "con", "null", "to", "oss", "co", "cin", "outs", "OUT", "net", "n", "cn"]}}
{"id1": "6840241", "id2": "23510383", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"copy": ["delete", "link", "system", "opy", "replace", "gc", "cop", "read", "close", "transfer", "map", "cover", "call", "sync", "save", "clip", "slice", "create", "move", "load", "clone", "write", "share", "Copy", "size", "cat", "print", "cp"], "source": ["Source", "cache", "origin", "parent", "image", "shell", "select", "pse", "inner", "stream", "ource", "src", "master", "subject", "sample", "se", "si", "scope", "sr", "wrapper", "info", "start", "session", "resource", "context", "local", "template", "base", "from", "site", "status", "sql", "body", "store", "inside", "ins", "spec", "table", "iter", "input", "ie", "ce", "size", "sp", "SOURCE", "reader", "style", "state"], "sink": ["Source", "asink", "slource", "asinker", "sinker", "sue", "ssender", "sender", "slue", "ssinker", "Sender", "ssink", "asender", " sinker", "ssource", "slender", "asource", "Sink", " sue", " sender", "Sue", "slink", "Sinker"]}}
{"id1": "8747840", "id2": "10690321", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["delete", "link", " mirror", " Copy", "add", "download", "gc", " replicate", "read", "transfer", "map", "sync", "save", "clip", "slice", "create", " cp", "move", "load", "csv", "clone", "write", "paste", "Copy", " copying", "cat", "cp", "upload"], "src": ["Source", "sec", "obs", "init", "inst", "sq", "bs", "sin", "rs", "via", "sr", "sb", "rx", "syn", "source", "start", "sys", "sit", "ipl", "txt", "from", "cont", "ctr", "st", "img", "cur", "sur", "sf", "ser", "urg", "ins", "usr", "rel", "pkg", "sc", "req", "rc", "input", "iv"], "dest": ["origin", "est", "orig", "nom", "del", "Dest", "master", "nt", "nw", "target", "mm", "temp", "deg", "source", "opt", "sit", "tmp", "gt", "cont", "way", "pas", "good", "st", "spec", "https", "loc", "test", "usr", "d", "des", "null", "req", "pub", "dist", "end", "trans", "th", "self", "rest", "mk", "decl"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "it", "ain", "inner", "isin", "old", "din", "info", "mm", "ze", "source", "bin", "i", "gin", "on", "id", "from", "In", "ic", "impl", "ins", "inside", "en", "IN", "con", "iter", "ai", "rc", "cin", "rin", "input", "ar", "inf", "ind"], "out": ["auto", "obj", "not", "ch", "conn", "writer", "p", "it", "Out", "inner", "g", "ex", "nt", "aos", "outer", "dis", "sys", "bin", "err", "io", "conv", "gt", "on", "res", "sum", "ot", "t", "en", "at", "o", "ne", "by", "write", "output", "client", "con", "os", "to", "oss", "end", "co", "over", "outs", "OUT", "net", "can", "n", "ou"], "buf": ["cap", "msg", "cv", "bus", "bs", "cb", "mb", "bh", "bl", "seq", "temp", "cmd", "b", "bed", "buffer", "log", "prop", "uf", "Buffer", "data", "conv", "bar", "col", "box", "gen", "tab", "queue", "batch", "arr", "cam", "mu", "good", "br", "fg", "str", "bag", "Buff", "buff", "ref", "pkg", "vec", "db", "block", "rb", "fb", "cat", "used", "aka", "bytes", "stab"], "c": ["cache", "cs", "ch", "ac", "bc", "ec", "cb", "cc", "cd", "a", "dec", "gc", "b", "jc", "cos", "i", "k", "ci", "call", "fc", "uc", "m", "unc", "cont", " C", "conf", "nc", "cu", "t", "code", "lc", "dc", "d", "cm", "l", "cf", "count", "cr", "rc", "co", "z", "ca", "cod", "ce", "mc", "C", "n", "cp", "ct"]}}
{"id1": "12678045", "id2": "3756429", "code1": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"addQDInformation": ["addQuestiondinformation", "addQuestiondInformation", "addQuestionDinformation", "addQDMInfo", "addQDMinformation", "addQdinformation", "addQuestionDInfo", "addQuestionDinfo", "addQDinfo", "addQSinformation", "addQuestiondInfo", "addQuestiondinfo", "addQSinfo", "addQDMinfo", "addQDInfo", "addQDMInformation", "addQdinfo", "addQdInfo", "addQSInfo", "addQDinformation", "addQSInformation", "addQuestionDInformation", "addQdInformation"], "qdDate": ["requduDat", " qddate", "qdodate", "qldDat", "qdmFile", "qdxDo", "qdTime", "qedDo", "requduDisplay", "qdxDate", "qdxNow", "requdDat", "qdDat", "qlDat", "qdDisplay", "questdDate", "qdxdate", "qedNow", "qdtNow", " qdDat", "qadNow", " qdodate", "qlDate", "qadDate", "requdDate", "qdsDate", " qdoNow", "questdNow", "requduDate", "qdxFile", " qdDo", "qdoNow", " qdoDat", "questedDat", "qadDo", "qdsDisplay", "requduTime", "questedDate", "requdDisplay", "qdmDo", "qddate", "questdDo", "qadDat", "qdtdate", " qdoDate", "qdxDat", "qdmTime", "qdxTime", "qduTime", "qduDisplay", "qldDate", "qdtDate", "qdNow", "questedDo", "qduDat", " qdNow", "qdtDat", "qlNow", " qdTime", "qldDisplay", "qdsDat", "qedDate", "qduDate", "qdDo", "requdTime", "questdDat", "qdsTime", "qlDo", "qedDat", "qldTime", "questedNow", "qdoDate", "qdoDat", "qdmDate"], "qdFile": ["qsdFile", "qdmByte", "qdmFile", "qdsfile", " qdfile", "querydByte", "qdsFile", "qdTable", "querydFile", "qdTime", "qdoSourceFile", "qdrfile", "iqdFile", "qdSourceFile", "qdsTime", "qdsTable", "qrdByte", "querysdSourceFile", "qmdSourceFile", "querydTime", "qmdfile", "iqdoFile", "iqdoByte", "qdrFile", "qdrFilename", "querysdByte", "qrdfile", "qdmTime", "qdFilename", "qrdSourceFile", "qdsFilename", "qdsByte", "iqdfile", "qdrTable", "querydSourceFile", "iqdofile", "qrdFile", " qdFilename", "qsdSourceFile", "qdsSourceFile", "qmdFile", " qdTable", "qdoFile", "qdmSourceFile", "qmdByte", "iqdoSourceFile", "iqdSourceFile", "qsdByte", "qsdTime", "querysdFile", "iqdByte", "qdoByte", "qdofile", "querysdTime", "qdfile", "qdByte"], "_qdFileDate": ["_qdfileMap", "_qdDirMap", "_qdsFileMap", "_qpFileDate", "_qdfileNumber", "_qdDirNumber", "_qdDirFormat", "_qdDirDo", "_qdUnitFormat", "_qdFileNumber", "_qdsFileDate", "_qdsfileNumber", "_qdsfileMap", "_qdSetMap", "_qpTotalFormat", "_qpFileYear", "_qdTotalDate", "_qpFileFormat", "_qdsfileDate", "_qdTotalWrite", "_qdTotalFormat", "_qdsFileNumber", "_qdDirYear", "_qdsFileDo", "_qdFileDo", "_qdsfileDo", "_qdDirDate", "_qdSetDate", "_qdDirWrite", "_qdFileFormat", "_qpTotalWrite", "_qpTotalDate", "_qdSetNumber", "_qdFileYear", "_qdFileWrite", "_qdfileDate", "_qdfileDo", "_qdFileMap", "_qdUnitDate", "_qpTotalYear", "_qdSetDo", "_qdUnitYear", "_qpFileWrite", "_qdUnitWrite", "_qdTotalYear"], "ii": ["ni", "ix", "ku", "iona", "cgi", "ani", "oi", "mi", "chi", "gi", "inch", "si", "Si", "ini", "hi", "ami", "ishi", " iii", "ind", "ski", "iso", "i", "ti", "ci", "ori", "zi", "di", "oci", "xi", "aii", "qq", "ou", "fi", "umi", "sim", "iii", " ni", "iy", "II", "ei", "ati", "ims", "ico", "qi", "cu", "ta", "aa", "ij", "iri", "jj", "ai", "ice", "iat", "co", "ie", "pi", "yi", "iq", "ia", "li"], "info": ["name", "ip", "key", "init", "none", "is", "about", "notice", "def", "inner", "fo", "Info", "entry", "what", "tip", "unknown", "success", "query", "iso", "alias", "i", "information", "io", "join", "ti", "data", "translation", "error", "id", "f", "type", "time", "http", "conf", "status", "instance", "details", "object", "INFO", "check", "summary", "item", "history", "inf", "pi", "note", "used", "index"], "_qdValue": ["_qdInfo", "_qdvalue", "_dqDValue", "_qdResult", "_qDResult", "_qldValue", "_qdoInfo", "_dqdResult", "_dqDInfo", "_qDInfo", "_dqdvalue", "_dqdValue", "_dqDvalue", "_qldvalue", "_dqDResult", "_qldResult", "_qldInfo", "_qdoResult", "_qdovalue", "_qdoValue", "_qDvalue", "_dqdInfo", "_qDValue"], "reader": ["then", "iterator", "READ", "writer", "reading", "inner", "loader", "r", "rr", "rx", "redo", "feed", "buffer", "holder", "builder", "read", "parser", "resource", "rar", "data", "library", "handler", "driver", "worker", "ner", "body", "rl", "random", "Reader", "er", "relation", "ro", "iter", "upper", "lr", "row", "runner", "pull", "dd", "rot", "dr", "wrapper", "handle"], "urlName": ["URLNames", "URLKey", "lName", " urlPath", "UrlKey", "urlNames", "strName", "UrlNames", "UrlDefault", "rowName", "urlDefault", "urlKey", "urlname", "urlPath", "strname", " urlString", "lN", "rowN", "URLname", "strKey", "rowname", " urlNames", "UrlPath", " urlDefault", "urlString", "URLDefault", "UrlN", "rowNames", "UrlString", "URLString", "lNames", "UrlName", "strNames", "URLName", "urlN", "lname", " urlKey", "URLPath", " urlname", "Urlname"], "url": ["mail", "Url", "link", "hl", "name", "string", "char", "mb", "r", "mount", "b", "location", "gl", "ssl", "resource", "host", "bel", "user", "f", "uri", "http", "nl", "sl", "rl", "console", "str", "ll", "browser", "address", "ref", "loc", "rel", "l", "open", "lr", "URL", "re", "ur"], "stream": ["iterator", "system", "socket", "clean", "present", "inner", "message", "sample", "stack", "REAM", "feed", "buffer", "network", "resource", "channel", "stage", "data", "sw", "cont", "Stream", "sl", "pod", "form", "poll", "body", "instance", "console", "in", "str", "iter", "row", "ream", "input", "platform", "screen", "window"], "file": ["ile", "fp", "port", "File", "header", "writer", "loader", "message", "r", "run", "buffer", "filename", "io", "data", "FILE", "files", "f", "handler", "fs", "fd", "report", "page", "body", "in", "range", "rule", "fast", "db", "table", "open", "dir", "tree", "input", "fr", "document", "handle", "format"], "line": ["port", "link", "sequence", "online", "cmd", "buffer", "channel", "LINE", "one", "user", "trace", "cell", "store", "frame", "range", "normal", "piece", "no", "iter", "block", "field", "le", "ine", "part", "message", "sample", "detail", "e", "point", "error", "lin", "sql", "body", "rule", "lo", "position", "ice", "row", "inline", "dd", "level", "raw", "ln", "ip", "header", "se", "job", "node", "query", "record", "eline", "queue", "comment", "chain", "out", "section", "print", "column", "handle", "liner", "string", "char", "continue", "lines", "entry", "side", "Line", "log", "next", "page", "code", "phrase", "l", "word", "note"], "_qdDate": ["_qdxGeneral", "_qudtPort", "_kdFile", "_qdFile", "_iqtTime", "_qdoDate", "_qlTime", "_qdTotal", "_iqtDat", "_qdoTotal", "_qdxTotal", "_iqtValue", "_qdsTime", "_qdmGeneral", "_qdxFile", "_kdGeneral", "_qdtTime", "_qdoFile", "_qdTime", "_iqdDate", "_qlDate", "_qdtDat", "_qtDat", "_qudDat", "_qdoPort", "_kdxGeneral", "_qdoGeneral", "_qudTime", "_qtTime", "_kdDate", "_iqdDat", "_iqdValue", "_qdDat", "_iqtDate", "_qudtDat", "_kdxTotal", "_kdxFile", "_qudDate", "_kdTotal", "_qdsDat", "_qdmDate", "_qdmTotal", "_qdPort", "_qdoDat", "_qudPort", "_kdxDate", "_qdsValue", "_qdmFile", "_qdsPort", "_qtDate", "_qdsDate", "_iqdTime", "_qlDat", "_qdoTime", "_qlValue", "_qudtDate", "_qtValue", "_qdGeneral", "_qdtPort", "_qudtTime", "_qdtDate", "_qdxDate"], "pos": ["port", "pc", "yes", "len", "offset", "exp", "pres", "p", "axis", "part", "present", "def", "ps", "add", "max", "neg", "pro", "Pos", "min", "start", "cos", "point", "i", "snap", "slot", "pad", "win", "zero", "top", "num", "po", "conf", "cond", "or", "prefix", "prot", "nos", "loc", "no", "o", "proc", "pose", "pr", "length", "os", "position", "pt", "n", "pid", "apo", "pat", "px", "size", "sp", "POS", "index", "ind"], "projectNum": [" projectDir", "componentDir", "projectnum", "componentNum", "modelDir", " projectNo", "componentnum", "componentNo", "componentNumber", " projectNumber", "modelNo", "componentConn", "ProjectNum", "projectNumber", "projectNo", "ProjectConn", "modelnum", "projectConn", "ProjectNumber", " projectnum", "projectDir", " projectConn", "modelNum", "Projectnum"], "value": ["port", "name", "ue", "unit", "key", "description", "v", "distance", "number", "values", "point", "property", "profile", "val", "data", "Value", "result", "project", "type", "scale", "feature", "object", "total", "VALUE", "field", "index", "format"]}}
{"id1": "16511008", "id2": "11962480", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMsgSchembol", "createNewProfilingMsgSchentax", "createNewProfilingMessagesymbol", "createNewProfilingMsgSyntax", "createNewProfilingMsgSymbol", "createNewProfilingMessageSyntax", "createNewProfilingMessageCyntax", "createNewProfilingMessageCymbol", "createNewProfilingMessageSchembol", "createNewProfilingMessageSchentax", "createNewProfilingMessagesyntax"], "configID": ["configURL", " configId", " configURL", " configURI", "caseid", " configOR", "confID", "configOR", "componentId", "cfgID", "componentOR", " configIDs", "configIDs", "componentPK", "configPK", "configid", "cfgId", "caseML", "configId", " configid", "Configid", "confOR", "confId", "ConfigID", "ConfigML", "confPK", "confURI", "ConfigURL", "caseID", "configML", "caseURL", "cfgURI", "cfgIDs", "componentID", "configURI", " configML", "confIDs", " configPK"], "programMessageSymbolID": ["programMessageSyrorIDs", "programMessageSymbID", "programMessageSymbN", "programMessageSymbolIDs", "programMessageSymbIDs", "programMessageSymbolValue", "programMessageSymbId", "programMessageSyptionName", "programMessageSyrorID", "programMessageSyptionID", "programMessageSymbolName", "programMessageSyTypeName", "programMessageSySyName", "programMessageSymmbolName", "programMessageSymmbolValue", "programMessageSyElementId", "programMessageSymmbolid", "programMessageSymbolN", "programMessageSymmbolIDs", "programMessageSyrorN", "programMessageSySyID", "programMessageSymbolid", "programMessageSyptionId", "programMessageSymmbolN", "programMessageSyElementName", "programMessageSyptionid", "programMessageSyTypeValue", "programMessageSymbolId", "programMessageSyrorId", "programMessageSyTypeId", "programMessageSySyId", "programMessageSySyid", "programMessageSymmbolId", "programMessageSymmbolID", "programMessageSyTypeID", "programMessageSyElementID", "programMessageSyElementValue"], "profilingMessageSymbol": ["profilingMsgSymbol", "profilingMessagesymbol", "profilingMessageSymavior", "profilingMessageSymols", "profilingMessageSYmbol", "profilingMessageSymse", "profilingMessageSymb", "profilingMessageSyntax", "profilingMessageSyavior", "profilingMessageCymbol", "profilingMessageCyntax", "profilingMessageSYmb", "profilingMessageCyavior", "profilingMessagesymb", "profilingMessagesyols", "profilingMessageSysmbol", "profilingMsgSymntax", "profilingMsgSymavior", "profilingMessageSymmb", "profilingMessageSyse", "profilingMessageSymmbol", "profilingMessagePyntax", "profilingMsgSyntax", "profilingMessageSymntax", "profilingMessagesyse", "profilingMsgSymmbol", "profilingMessageSYse", "profilingMessageSyols", "profilingMsgSyavior", "profilingMessagePyavior", "profilingMessageSysmb", "profilingMessagePymbol", "profilingMessageSysols"], "connection": ["established", "Connection", "link", "volume", "sequence", "response", "character", "server", "conn", "initial", "writer", "system", "settings", "created", "socket", "connected", "usage", "current", "subject", "entry", "device", "connect", "database", "associated", "config", "network", "session", "cone", "ion", "resource", "context", "city", "close", "information", "function", "reference", "channel", "library", "application", "note", "handler", "communication", "engine", "command", "we", "generation", "collection", "condition", "bo", "relation", "db", "table", "client", "open", "module", "con", "position", "line", "ce", "operation", "document", "directory"], "statement": ["volume", "execute", "sequence", "Statement", "response", "stat", "journal", "stan", "linger", "shell", "activity", "bind", "description", "message", "usage", "memory", "se", "subject", "expression", "database", "management", "network", "session", "resource", "function", "parse", "reference", "template", "processor", "library", "ment", "application", "note", "comment", "storage", "report", "command", "instance", "sql", "set", " Statement", "language", "t", "chain", "rule", "condition", "relation", "phrase", "policy", "position", "list", "EMENT", "print", "document", "sp", "mt", "directory", "state"], "resultSet": [" resultset", "recordset", "traceSet", "ResultList", "ResultHandle", "traceset", "eventset", " resultPath", "resultHandle", "eventSet", "ResultSource", " resultS", "rowList", "eventPath", "ResultScan", "ResultS", "eventList", "resultRow", "rowset", "ResultPath", " resultScan", "traceSource", "rowRow", "resultset", "recordSet", "Resultset", "rowS", "rowSet", "resultSource", "recordHandle", "ResultRow", "traceList", "resultScan", "recordList", " resultRow", "resultS", "resultList", "resultPath", "rowScan", "rowHandle", " resultList", " resultSource", "ResultSet"], "query": ["QU", "volume", "scan", "execute", "sequence", "where", "key", "init", "string", "Query", "select", "sq", "qu", "find", "scope", "message", "commit", "content", "menu", "title", "expression", "lock", "how", "question", "update", "ion", "join", "read", "parse", "ql", "password", "call", "note", "comment", "search", "send", "q", "sum", "command", "quote", "sql", "check", "code", "gate", "create", "condition", "spec", "test", "ERY", "table", "get", "request", "script", "transform", "show", "quest", "print", "eries"], "msg": ["mail", "sm", "warn", "name", "bg", "html", "rup", "nom", "nm", "cmp", "notice", "comm", "Msg", "char", "mb", "g", "ex", "message", "title", "gem", "man", "e", "cmd", "mun", "gm", "log", "err", "ung", "og", "gs", "meg", "reason", "sg", "error", "gen", "ext", "m", "txt", "med", "cfg", "sum", "mu", "mag", "sql", "kg", "mess", "mg", "str", "md", "text", "mem", "mn", "ged", "pkg", "doc", "gr", "term", "req", "em", "note", "mt"]}}
{"id1": "3024987", "id2": "20310134", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStream_Decending", "testCopy_readerToOutputStreamWithEncending", "testCopy_readerToOutputStream_Encending", "testCopy_readerToOutputStream_Chending", "testCopy_readerToOutputStream_Decoded", "testCopy_readerToOutputStreamWithDecoder", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStreamWithEncoded", "testCopy_readerToOutputStream_Choder", "testCopy_readerToOutputStream_Decoder", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStreamWithDecending", "testCopy_readerToOutputStream_Decoding", "testCopy_readerToOutputStream_Choding", "testCopy_readerToOutputStream_encending", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStreamWithDecoding", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Choded", "testCopy_readerToOutputStreamWithEncoder", "testCopy_readerToOutputStreamWithEncoding", "testCopy_readerToOutputStreamWithDecoded"], "in": ["inn", "inc", "up", "init", "p", "is", "it", "ac", "mi", "act", "sin", "inner", "isin", "ini", "r", "din", "copy", "info", "mm", "source", "bin", "i", "read", "gin", "local", "data", "m", "from", "cont", "In", "ins", "inside", "IN", "Input", "l", "iter", "con", "n", "input", "rin", "cin", " IN", "mc", "as", "inf", "ind"], "reader": ["Larry", "iterator", "writer", "per", "reading", "inner", "ocker", "loader", "r", "rr", "oe", "rx", "file", "query", "buffer", "read", "io", "parser", "rar", "data", "handler", "driver", "ner", "rl", "red", "Reader", "er", "ro", "phrase", "iter", "mr", "req", "rise", "row", "input", "rot", "dr"], "baout": [" bain", "oaOut", " bares", "haouts", "beanOut", "caOut", " baot", "BAres", "baOut", "BAin", "haOut", "oaos", "yares", "baot", "haout", "boos", "caos", "yaout", "bares", "beanout", "boout", "beanin", "boin", "bain", "baos", "BAot", "BAout", "hain", "baouts", "oain", "cain", "caouts", "yaot", "beanouts", "caout", "boOut", "oaout", "yain"], "out": [" outs", "auto", " os", " bout", " Out", "Out", "ex", "copy", "outer", "cmd", "b", "all", "sys", "update", "cos", "io", "conv", "gt", " OUT", " output", "batch", "res", "cn", "t", "bo", "o", "ne", "OU", "output", "client", "os", "null", "con", "to", "oss", "stable", "ao", "outs", "OUT", "net", "n", "ou"], "bytes": ["resources", "bits", "groups", "ips", "raw", "unks", "frames", "bs", "strings", "tes", "lines", "pages", "classes", "reads", "gets", "users", "values", "reports", "blocks", "letters", "comments", "gs", "results", "es", "ones", "data", "files", "ites", "seconds", "faces", "ies", "issues", "pieces", "cells", "services", "its", "objects", "parts", "ings", "videos", "binary", "vals", "des", "Bytes", "words", "latest", "terms", "versions", "outs", "les", "bps", "names", "pdf", "units"]}}
{"id1": "12537270", "id2": "16851955", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "label": 0, "substitutes": {"parse": ["delete", "php", "p", "arse", "replace", "process", "se", "layer", "update", "Parser", "resource", "read", "close", "parser", "build", "match", "error", "ping", "slice", "check", "load", "loop", "split", "print", "pair", "handle", "format"], "link": ["name", "html", "path", "ln", "le", "ip", "image", "string", "action", "pattern", "char", "se", "add", "entry", "linked", "lock", "e", "label", "source", "start", "log", "links", "join", "local", "match", "template", "id", "let", "type", "uri", "ping", "page", "tag", "frame", "address", "load", "element", "loc", "rel", "l", "line", "word", "block", "route", "script", "ink", "sp", "style", "index", "Link"], "conn": ["nav", "obj", "gn", "cs", "ch", "ln", "ws", "yn", "resp", "socket", "comm", "cb", "org", "act", "enc", "nt", "ait", "ns", "connect", "cmd", "err", "conv", "txt", "c", "cont", "res", "pas", "ctr", "nc", "ner", "cn", "ctrl", "loc", "rel", "ctx", "client", "open", "con", "cr", "connection", "ann", "oss", "nec", "Conn", "cat", "ls", "ct", "cp", "addr"], "rd": ["ri", "rer", "rs", "hr", "r", "din", "rr", "rand", "rn", "sr", "rid", "rx", "wr", "ird", "rad", "rar", "rog", "ld", "raf", "vr", "rl", "rob", "red", "ro", "rw", "d", "rh", "usr", "nd", "ra", "mr", "erd", "rc", "rb", "lr", "fr", "dd", "rt", "dr", "reader"], "kit": ["Kit", "util", "html", "ch", "init", "qt", "bh", "tc", "iz", "pack", "sys", "sit", "k", "io", "h", "ang", "kt", "iw", "box", "tk", "kat", "c", "base", "pot", "maker", "webkit", "cam", "ic", "set", "cu", "t", "lib", "pkg", "jit", "ctx", "ok", "sc", "iter", "boot", "js", "shop", "et", "ect", "net", "rot", "cat", "rt", "bot", "mk", "sky"], "doc": ["msg", "html", "p", "head", "tx", "def", "xml", "g", "nt", "ds", "content", "w", "window", "man", "dec", "json", "file", "config", "div", "log", "og", "dat", "ad", "data", "di", "Doc", "pdf", "page", "mu", "body", "in", "md", "t", "out", "dc", "d", "db", "dir", "tree", "js", "sp", "document", "dr", "mk", "n"], "url": ["mail", "Url", "util", "hub", "html", "pl", "cert", "path", "ln", "domain", "server", "org", "mb", "xml", "r", "mount", "log", "gl", "ssl", "host", "resource", "git", "bel", "user", "deb", "dl", "base", "uri", "web", "http", "nl", "sl", "peer", "el", "rl", "impl", "ll", "t", "address", "ref", "https", "loc", "api", "l", "open", "lr", "blog", "URL", "ls", "ur", "ul", "addr"], "it": ["im", "ip", "init", "you", "It", "rit", "nt", "ite", "iz", "IT", "lit", "sit", "io", "ci", "iw", "wait", "ot", "pit", "he", "its", "ic", "in", "t", "out", "at", "l", "ert", "iter", "et", "ct", "ind", "li"], "elem": [" peom", "elt", "tem", "eelt", "belement", "lem", " pelect", "llem", " element", "seem", "telt", "tlect", "tlement", " pelem", "selem", "seelt", " eom", "bem", "sem", " pelement", "eem", "llement", "eleelt", " elect", "elelem", "eleem", "telement", "element", "elect", "belem", "elelement", "eom", "tlem", "em", "tom", "lelt", "selement", "belt", "telem", "selt"], "s": ["sm", "cs", "is", "sq", "ts", "als", "rs", "si", "sa", "ps", "se", "stats", "ats", "ds", "ns", "sb", "sys", "ys", "S", "gs", "sd", "ss", "es", "xs", "sam", "sg", "less", "ess", "sv", "fs", "sts", "space", "sl", "simple", "set", "st", "ins", "ms", "spec", "os", "sym", "js", "sp", "ls"], "lnk": ["olnn", "linko", "lankt", "olnk", "lenk", "nelko", "olnj", "lenak", "nlko", "klk", "lnak", "olnak", "dlak", "dln", "lank", "olnck", "lenck", "dnko", "olnik", "lnek", "nelk", "linik", "dnck", "nlk", "lntk", "dlck", "lnkt", "olnko", "lnck", "nln", "lnj", "nlak", "lnke", "linke", "linck", "klek", "lnn", "dlik", "dnk", "klko", "nelke", "klke", "nltk", "olnkt", "lnik", "linn", "nlck", "dnn", "lenj", "nlkt", "lann", "nelek", "dltk", "linj", "linak", "linek", "dlk", "lanak", "lintk", "lnko"], "j": ["obj", "off", "jump", "uj", "jl", "ji", "g", "v", "ja", "je", "max", "ng", "div", "jc", "pos", "Ja", "h", "k", "oj", "kj", "prime", "q", "J", "bj", "br", "y", "ij", "aj", "t", "dj", "bo", "jp", "o", "adj", "jj", "js", "z", "n", "ind", "li"], "urlLink": ["emailSource", "emaillink", "httpLinks", "emailLink", "objUrl", " urllink", "strLink", "sslLoad", "objLink", "sslLinks", "urlLinks", "UrlLock", "Urllink", "UrlLink", "urlMatch", " urlRel", "urlStart", "httpLoad", " urlUrl", " urlMatch", "strStart", "UrlSource", " urlLinks", "objRel", "urlSource", "urllink", " urlSource", "strRel", "sslLink", "urlLock", "urlRel", "strUrl", "httpLink", "urlUrl", " urlLock", "httpMatch", "sslMatch", "objStart", "urlLoad", "emailLock", " urlLoad", " urlStart"], "str": ["msg", "elt", "stri", "html", "exp", "tr", "p", "string", "vol", "inst", "comm", "char", "part", "inner", "g", "ocr", "r", "w", "temp", "STR", "wr", "div", "f", "txt", "m", "res", "coll", "arr", "ctr", "br", "prefix", "st", "text", "t", "ll", "out", "spec", "chain", "usr", "pkg", "Str", "tree", "stable", "list", "fr", "js", "print", "hex", "dr", "n", "raw"], "i": ["ix", "bi", "im", "ip", "init", "oi", "p", "mi", "x", "gi", "phi", "ui", "si", "ex", "a", "ini", "hi", "info", "ami", "\u0438", "cli", "iu", "start", "io", "ci", "me", "ti", "zi", "multi", "di", "ori", "xi", "batch", "m", "iy", "PI", "y", "ic", "ei", "in", "ims", "ms", "qi", "ity", "chain", "us", "ki", "o", "length", "iter", "ai", "I", "ie", "pi", "sim", "index", "area", "ii", "li"], "skip": ["warn", " skipped", "deep", "ip", "ips", "jump", "cmp", "replace", " bypass", "sk", "process", "add", "copy", "strip", " skipping", "complete", "clip", "ops", "op", "fast", "loop", "Skip", "write", "iter", "pass", "note", "kill", "stop"]}}
{"id1": "9647576", "id2": "13981689", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"Reserve": ["Reserved", "Servation", "Conserved", "Resolve", "reservation", "Consolve", "reserved", "reserve", "Conserve", "Reservation", "Serve", "Served", "Conservation", "resolve", "Solve"], "stbookings": ["Stbookies", "stbindies", "stbinding", "stbooksers", "stbindings", "stbooksings", "Stbookers", "stbooking", "stBooking", "stbookers", "stBookers", "stBookies", "Stbooking", "stBookings", "stbinders", "stbookies", "stbooksing", "stbooksies", "Stbooksies", "Stbooksings", "Stbookings", "Stbooksing", "Stbooksers"], "stchartwl": ["stpagewal", "stplotwal", "STchartwal", "STChartbook", "STchartbook", "STchartml", "stpageml", "stChartwal", "stpagewl", "stChartml", "stchartwal", "stchartbook", "stChartbook", "stplotbook", "stplotml", "stchartml", "STChartwal", "STchartwl", "STChartml", "stChartwl", "STChartwl", "stplotwl", "stpagebook"], "sp": ["sm", "pp", "p", "vol", "sk", "si", "scope", "sh", "se", "ps", "sb", "sy", "esp", "so", "ap", "sil", "bsp", " SP", "ss", "isp", "pol", "sw", "sv", "lp", "asp", "space", "spr", "osp", "st", "service", "SP", "sf", "spe", "jp", "pb", "policy", "sc", "Sp", "pt", "yp", " esp", "cp", "pe", "tp"], "userbooksql": ["userbysquer", "userbooksels", " userbindquer", "userscriptsqs", "userbooksSQL", "userscriptsels", "agentbooksQL", "userbookql", "agentpagesQL", "userbooksQL", "usertypessql", "userreadsels", "agentbookssql", "clientreadsqs", "clientbooksels", "userscriptselly", "userpagesql", "clientreadselly", "userpagesQL", "userreadsql", "userbysql", "userpagesqs", "userbindSQL", " userbindsql", "userbysSQL", "agentbooksqs", " userbindSQL", "userbindquer", "agentpagesql", "clientbookselly", "userbindql", "userBooksquer", "userpagessql", "agentpagesqs", "clientbooksqs", "clientreadsql", "userbookselly", "userscriptsql", "clientreadsels", "userreadsqs", "userbindsql", " userbooksquer", "userooksql", "userbookqs", "userBooksSQL", "agentpagessql", "userreadselly", "userbooksqs", "usertypesqs", "userbookssql", "userooksels", " userbindql", "userBookssql", " userbooksSQL", "userbookQL", "userookselly", "usertypesql", "clientbooksql", "userBooksql", " userbookssql", "usertypesQL", "userbooksquer", "userbyssql", "userooksqs"], "agentbooksql": ["agentbookql", "agentletsql", "agentbooksQL", "agentpagesQL", "ownerbeansili", " agentBooksquer", "agentbookssql", " agentbookssql", "agentBooksql", " agentBooksqu", "agentbeansquer", "ownerbeansquer", "agentpagesql", " agentbookQL", "ownerbeansQL", " agentbooksQL", "ownerbooksili", "agentbeansQL", "agentbookili", " agentbookql", "agentiquesquer", "ownerbeansql", " agentbooksquer", "agentBooksili", "agentpagessql", "agentiquesQL", "agentBooksqu", "agentbooksili", "agentBooksQL", " agentBooksql", "agentbookQL", "agentbeansili", "agentletsqu", "agentiquesqu", " agentbooksili", "agentbooksqu", "agentiquessql", "agentpagesili", "agentiquesili", "ownerbooksquer", "ownerbooksQL", "agentBookssql", "agentiquesql", "ownerbooksql", " agentbooksqu", "agentletssql", " agentBookssql", " agentbookili", "agentbooksquer", "agentBooksquer", "agentbeansql", "agentbookquer", "agentletsquer"], "bookingid": ["bookillingid", "bookingsid", "bookingingids", "bookingingID", "bookingID", "Bookingsid", "BookingsID", "bookingids", "bookingingid", "bookillingids", "Bookingids", "Bookingid", "BookingID", "bookillingID", "bookingsID", "Bookingsids", "bookingsids"], "currentcoach": [" currentcoarch", "currentlycat", "currentCOac", "currentcoACH", "currentCOasp", "currentfoch", "currentcoachable", "currentCoACH", " currentfoACH", "currentfoech", "currentcoarch", "currentfoACH", "currentcalech", "currentCoch", "currentCoarch", "currentlyCoech", "currentconac", "currentlycoch", "currentlyCoachable", "currentconasp", "currentcach", "currentcoasp", "currentlyCoch", "currentcoearch", "currentfoach", " currentfoach", "currentconach", "currentCOat", "currentlycach", "currentfoarch", " currentfoch", "currentcoech", "currentlycoech", "currentCoachable", "currentlycac", "currentlycoasp", " currentfoarch", "currentcalch", "currentconat", "currentcasp", "currentcac", " currentcoch", "currentcoch", "currentlycoach", "currentlycoat", "currentcoeACH", "currentCoech", "currentlycoachable", "currentcoeach", "currentcoac", "currentcat", "currentCOach", "currentlycasp", "currentcalach", "currentfoachable", "currentcalachable", " currentcoACH", "currentcoat", "currentCoach", "currentlyCoach", "currentlycoac"], "currentseat": ["currentslot", " currentsel", "reportedport", "Currentseat", "currentlysen", " currentroute", "curseat", "currentlysel", "currentsen", "reportedsel", "currentroute", "currentsel", "reportedseat", "Currentsen", "reportedroute", "Currentsel", "cursel", " currentport", "curroute", " currentsen", "curport", "currentlyseat", "currentport", "Currentslot", " currentslot", "currentlyslot"], "tickpos": ["snapposition", "quotepos", "snapPos", "stickposition", "ickpo", "popPos", "testposition", "stickPos", "ickpos", "snappos", "rickPos", "stickpo", "ickPos", "quoteno", "ickposition", "rickpo", "checkposition", "rickprop", " tickno", "tickposition", "checkpos", "testpos", "quotePos", "snappo", "checkPos", "stickpos", "poppos", "tickprop", " tickposition", "testpo", "stickno", "tickPos", "poppo", " tickpo", "stickprop", "testPos", "rickpos", "tickno", "tickpo", " tickPos", " tickprop", "quoteposition", "popposition", "checkpo"], "chartavailupdsql": ["chartavailupsdatesQL", "chartavailupdsQL", "chartavailupyssql", "chartavailupdql", "chartavailupsdsql", "chartavailupdsq", "chartavailupdatesql", "chartavailupsdsq", "chartavailupsdssql", "chartavailupysq", "chartavailupsdsQL", "chartavailupdatessql", "chartavailupysql", "chartavailupdq", "chartavailupdatesq", "chartavailupdatesQL", "chartavailupsdatesql", "chartavailupdssql", "chartavailupsdatesq", "chartavailupsdatessql", "chartavailupysQL", "chartavailupdQL"]}}
{"id1": "2642914", "id2": "6036012", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public byte[] getClassBytes(String className, ClassLoader classLoader) {\n        URLClassLoader cl = new URLClassLoader(urls, classLoader);\n        String resource = className.replace('.', '/') + \".class\";\n        InputStream is = null;\n        try {\n            URL url = cl.getResource(resource);\n            if (url == null) {\n                throw new RuntimeException(\"Class Resource not found for \" + resource);\n            }\n            is = url.openStream();\n            byte[] classBytes = InputStreamTransform.readBytes(is);\n            return classBytes;\n        } catch (IOException e) {\n            throw new RuntimeException(\"IOException reading bytes for \" + className, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(\"Error closing InputStream for \" + className, e);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"addFileToTarGz": ["addFileToTarGep", "addFileToTarGszip", "addFileToTarRw", "addFileToTarBx", "addFileToTarJx", "addFileToTarJzip", "addFileToTarJz", "addFileToTarGx", "addFileToTarGzip", "addFileToTarBw", "addFileToTarGp", "addFileToTarBz", "addFileToTarRzip", "addFileToTarGst", "addFileToTarBzip", "addFileToTarGet", "addFileToTarGsp", "addFileToTarGw", "addFileToTarGezip", "addFileToTarRz", "addFileToTarBt", "addFileToTarJw", "addFileToTarRx", "addFileToTarGt", "addFileToTarBp", "addFileToTarGsz", "addFileToTarGez"], "taro": [" tara", "thamo", "staco", "stoa", "Taco", "warro", "Tamo", "qtaro", "tempamo", "marro", "staro", "stargo", "stamo", "troa", "maro", "trary", "starro", "ttara", " tolan", "retaro", "tory", "trro", "ktara", "Taro", " tory", "thosa", "ktarro", "tamo", "stary", "qtro", "margo", "tro", "ktaro", "ttaro", "thara", "tolan", "Tolan", "waro", "ktrar", "taco", " tarro", "tara", " tary", "tary", "retaco", "tarro", "tosa", "trar", "tharo", "Tarro", "retara", "targo", "traro", "temparo", " targo", "retamo", "qtolan", "Targo", "tharro", "tempargo", "toa", "Tro", "ttosa", "Tory", "wro", "qtory", "tempro", " taco", " tosa", " tamo", " toa", "Tara", " trar", "stro", "thrar", "wargo", "mro", "ttamo", " tro"], "path": ["name", "url", "PATH", "ath", "key", "p", "full", "string", "pattern", "clean", "ex", "entry", "w", "mount", "file", "h", "local", "root", "project", "m", "c", "parts", "text", "chain", "ref", "history", "kind", "doc", "dir", "Path", "core", "binding", "th", "transform", "pi", "print"], "base": ["name", "server", "parent", "full", "part", "file", "b", "start", "buffer", "alias", "pad", "build", "padding", "template", "default", "root", "based", "basic", "Base", "bf", "bas", "prefix", "check", "normal", "relative", "create", "db", "common", "family", "ase", "shadow", "binding", "bad", "reset", "extra", "bare", "absolute"], "f": ["fp", "xf", "rf", "fab", "tf", "fed", "df", "p", "fm", "g", "v", "fo", "r", "F", "w", "e", "life", "perm", "file", "b", "i", "h", "fx", "fa", "uf", "fc", "c", "fs", "fi", "fd", "elf", "bf", "lf", "y", "fg", "form", "fl", "t", "sf", "o", "d", "cf", "l", "ft", "fe", "far", "fac", "fr", "af", "alf", "fb", "inf"], "entryName": ["ryname", " entryKey", "EntryPath", "entryType", "ryName", "rowType", "elementPath", "cueKey", "elementname", "rowName", " entryLetter", "entryPath", " entryPath", "EntryKey", "cueName", "elementKey", "rowname", "entryKey", " entryType", "rowLetter", "cuename", "cueType", " entryname", "ryLetter", "ryType", "entryLetter", "entryname", "Entryname", "elementName", "EntryName", "EntryType"], "goIn": [" goIN", "moInput", "gein", "poIN", "geIn", " goOut", "GoIn", "moIN", "goIns", "Goin", "GoIns", "poin", "goOut", "GoIN", "goin", "moin", "moIns", "moIn", "goIN", "geInput", "poOut", " goInput", "poIn", "geIns", "goInput", " goIns", " goin", "GoOut"], "tarEntry": ["rarentry", "warItem", "rarComponent", "rarCategory", "tarentry", " tarEnt", "warComponent", "warEnt", " tarItem", "tarCategory", "tarItem", "rarEntry", "warEntry", " tarCategory", "rarItem", "tarEnt", "carCategory", "carEnt", "tarComponent", "rarEnt", "carentry", " tarComponent", "carEntry", " tarentry"], "children": ["resources", "cache", "groups", "cs", "parent", "each", "ports", "cloud", "stories", "wn", "gall", "ps", "pages", "kids", "members", "many", "names", "aos", "parents", "json", "users", "all", "reports", "blocks", "ren", "keys", "roots", "they", "these", "files", "batch", "fs", "packages", "modules", "jobs", "objects", "ll", "balls", "los", "hawks", "items", "ml", "Children", "follow", "ls", "ul"], "child": ["zip", "name", "cache", "ch", "parent", "key", "Child", "shell", "char", "job", "entry", "label", "last", "file", "ph", "close", "id", "comment", "c", "batch", "fd", "q", "cell", "page", "lf", "uncle", "ll", "friend", "cow", "l", "client", "count", "block", "brother", "row", "fr", "background", "follow", "pixel", "col", "handle"]}}
{"id1": "1122585", "id2": "13783549", "code1": "    private String copyImageFile(String urlString, String filePath) {\n        FileOutputStream destination = null;\n        File destination_file = null;\n        String inLine;\n        String dest_name = \"\";\n        byte[] buffer;\n        int bytes_read;\n        int last_offset = 0;\n        int offset = 0;\n        InputStream imageFile = null;\n        try {\n            URL url = new URL(urlString);\n            imageFile = url.openStream();\n            dest_name = url.getFile();\n            offset = 0;\n            last_offset = 0;\n            offset = dest_name.indexOf('/', offset + 1);\n            while (offset > -1) {\n                last_offset = offset + 1;\n                offset = dest_name.indexOf('/', offset + 1);\n            }\n            dest_name = filePath + File.separator + dest_name.substring(last_offset);\n            destination_file = new File(dest_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    if (!destination_file.canWrite()) {\n                        System.out.println(\"FileCopy: destination \" + \"file is unwriteable: \" + dest_name);\n                    }\n                    System.out.println(\"File \" + dest_name + \" already exists. File will be overwritten.\");\n                } else {\n                    System.out.println(\"FileCopy: destination \" + \"is not a file: \" + dest_name);\n                }\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                }\n                if (!parentdir.canWrite()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                }\n            }\n            destination = new FileOutputStream(dest_name);\n            buffer = new byte[1024];\n            while (true) {\n                bytes_read = imageFile.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(\"Bad URL \" + urlString);\n        } catch (IOException ex) {\n            System.out.println(\" IO error: \" + ex.getMessage());\n        } finally {\n            if (imageFile != null) {\n                try {\n                    imageFile.close();\n                } catch (IOException e) {\n                }\n            }\n            if (destination != null) {\n                try {\n                    destination.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return (dest_name);\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"copyImageFile": ["cpimagePhoto", "cpImageHeader", "cpimageFile", "copyItemImageHeader", "copyImagesfile", "copyImagePhoto", "copyimageHeader", "copyImagesPhoto", "copyimagefile", "cpimagefile", "cpimageHeader", "cpImagePhoto", "copyImagesHeader", "copyImageHeader", "copyItemImagefile", "copyimagePhoto", "cpImageFile", "copyItemImagePhoto", "cpImagefile", "copyimageFile", "copyImagefile", "copyImagesFile", "copyItemImageFile"], "urlString": [" urlRest", "urlStr", "UrlService", "uriStr", "linkRest", "uriService", "uriChain", "uristring", "uriString", "imageStr", "urlService", "UrlRest", "linkString", "linkStr", "UrlChain", " urlService", "imageString", "urlChain", "imageRest", "UrlString", "imagestring", " urlChain", "urlstring", "uriRest", "linkstring", "urlRest"], "filePath": ["outputPath", "resourcePATH", "givenPath", "FileName", " Filepath", "resourcepath", " filePATH", " FilePATH", "givenPATH", "givenpath", "FilePATH", " FileName", " FilePath", "resourcePath", "givenStream", "filePATH", "outputPATH", "FilePath", "resourceStream", "Filepath", "filepath", "outputpath", " filepath", "fileName", " fileName", "fileStream", "outputStream"], "destination": ["destaration", "identinator", "identinated", "terminaration", "delinator", "terminination", "terminignment", "portinated", "commentacement", "combation", "delribution", "destation", " destinator", "destension", "continator", "delination", " destachment", "Destinate", "methodachment", "combinity", "terminachment", "Destation", "contension", "srcinate", "destinator", "Destinator", "srcignment", " destository", "Destension", "destachment", " destinated", "destository", "identension", "portension", "methodinator", "destignment", "Destination", "identination", "continate", "targetinated", "destinity", "portinity", "destribution", "destificate", "combination", "commentinate", "destinated", "methodination", "targetinator", "srcinator", " destignment", "srcaration", "commentination", " destaration", "destinate", "termininator", " destribution", "methodository", " destension", "identinate", "contination", "combinator", "terminository", "targetination", "targetribution", "srcificate", "destacement", "Destinity", " destacement", " destinate", "delinated", " destificate", "portation", "commentificate", "portination", "srcacement", "portinator", "srcination"], "destination_file": ["destination____entity", "destociation_dir", "destinator_FILE", "destation_File", "destination_port", "destinator___name", "destination_entity", "destination_name", "destination_dir", "destination____file", "destination____no", "destination__name", "destinator_full", "destinator_ile", "destination___ile", "destation_file", "destination_File", "destination_no", "destination___full", "destociation_file", "destation_name", "destinator___full", "destination___file", "destociation_ile", "destATION_name", "destation_ile", "destination_full", "destociation_library", "destinator_name", "destATION_entity", "destination_FILE", "destination____name", "destinator_file", "destATION____name", "destinator___ile", "destinator_port", "destination__file", "destATION_no", "destATION____no", "destination_table", "destination___name", "destinator_File", "destination_library", "destinator_table", "destination__full", "destATION____file", "destination_ile", "destATION____entity", "destATION_file", "destinator___file", "destinator_dir", "destination__ile"], "inLine": ["Inline", "inString", "inliner", " inline", "binString", "InString", "InLine", "Inliner", "binLine", "inline", "binline", " inString", "binliner", " inliner"], "dest_name": ["dest__filename", "img_name", " dest__NAME", "dest_filename", "ident_name", "destinalname", " dest_ame", "src_file", "destopsan", "dest_NAME", " dest_NAME", "destationName", "destinationName", "dest_file", "src_name", "destDdescription", "destopdescription", "dest_data", "img_data", "Dest_Name", "destJsize", " dest_path", " dest_size", "desttkey", " dest_filename", "dest__name", "destDname", " dest__filename", "src_Name", "destnname", "dest__Name", "decl_name", "dest_call", "desttname", "dest_ma", "dest_path", "destJterm", "destinationname", "destJname", " dest_term", "decl_file", "destationnames", "dest_system", " dest_lock", "Dest_system", "desttName", "decl_ma", "dest_lock", "dest_key", "dest_ame", "destinationfile", " dest_call", "dest__NAME", "img_Name", " dest_names", "destinalfile", "Dest_key", "dest__ame", "destinalword", " dest__name", "destationcall", "dest_san", "destDsan", " dest_file", "Dest_description", "Dest_san", "destndescription", "Dest_file", "destationname", " dest_Name", "destinalma", "desttsystem", "dest_description", "dest_size", "dest_entry", "dest_word", "dest_Name", "destJNAME", "img_file", "src_filename", "destnfile", "destinationfilename", " dest__Name", "ident_entry", "ident_word", "Dest_name", "decl_word", "dest_term", "destopname", "dest_names"], "buffer": ["sequence", "cache", "shape", "char", "stream", "message", "memory", "sample", "device", "stack", "database", "feed", "value", "b", "source", "update", "variable", "read", "buf", "function", "Buffer", "append", "data", "parse", "bar", "channel", "password", "result", "queue", "batch", "base", "comment", "FFER", "page", "command", "frame", "text", "buff", "binary", "address", "phrase", "length", "table", "paste", "iter", "block", "row", "document", "window", "raw"], "bytes_read": ["bytes2length", "bytes_reading", "bytes67read", "bytes2readable", "bytes_write", " bytes_readable", "Bytes_mix", "bytes_mix", " bytes_Read", " bytes2read", " bytes_reading", "Bytes_read", "bytes67write", "bytes_Read", " bytes_length", "Bytes_send", "bytes67mix", " bytes_write", " bytes_count", "bytes_length", "bytes2reading", "bytes67send", "bytes2Read", "bytes_readable", " bytes2readable", "bytes2read", "Bytes_write", " bytes2reading", "bytes_send", " bytes2Read", "bytes_count"], "last_offset": ["last_start", "last___offset", "last__offset", "Last_position", "last___Offset", "last__Offset", " last_start", "Last_flag", "Last_pointer", "last_name", " last_name", "last_index", " last_Offset", "last_page", "Last_Offset", "last_position", "last___pointer", "last_pointer", "last_Offset", "Last_offset", "last__name", "last_flag", " last_index", "last__index", "Last_page", "last___position"], "offset": ["offs", "origin", "offer", "pos", "alias", "pad", "store", "frame", "set", "element", "no", "bound", "table", "seek", "end", "skip", "field", "index", "name", "auto", "timeout", "ace", "onet", "amount", "other", "part", "original", "article", "associated", "Offset", "location", "start", "point", "padding", "error", "type", "prefix", "mask", "address", "component", "position", "et", "inline", "size", "reset", "addr", "attribute", "volume", "option", "tile", "pointer", "outer", "alt", "append", "step", "batch", "unsigned", "left", "OFF", "length", "output", "section", "operation", "window", "iterator", "key", "inner", "after", "order", "entry", "shift", "slot", "next", "scroll", "always", "empty", "off"], "imageFile": ["photofile", "messagefile", "messageReader", "photoReader", "ImageStream", "imageStream", "mediaFile", "Imagefile", "pictureFile", "picturefile", " imageSourceFile", "imageSourceFile", "messageStream", " imagefile", "mediafile", "picturePlace", "ImageSourceFile", "mediaStream", "imagefile", "imagePlace", " imageReader", "pictureStream", "messageFile", "imageReader", "photoFile", "ImagePlace", " imageStream", "photoStream", "ImageFile", " imagePlace", "mediaSourceFile"], "url": ["mail", "Url", "link", "hl", "up", "html", "image", "char", "r", "mount", "b", "gl", "ssl", "resource", "build", "bel", "f", "base", "dl", "abs", "uri", "github", "web", "http", "nl", "sl", "q", "rl", "str", "impl", "ll", "google", "browser", "api", "address", "rel", "l", "open", "get", "URL", "re", "ml", "gif", "ur", "ul"], "parentdir": [" parentDir", "parentDir", "parentdiv", "tmpdir", "parentfolder", " parentlib", "parendiv", "childfolder", " parentdict", "rootfolder", " parentdirectory", "Parentdict", "tmpDir", "childdiv", "childlib", "childdirectory", "parendir", "ParentDir", "parenfolder", "rootir", "tmpdict", "Parentdir", "parentlib", "childDir", "rootdiv", "parentdict", "Parentlib", "childdir", "parenir", "Parentdirectory", "rootdir", "parentdirectory", "tmpdirectory", "parentir", "childir"]}}
{"id1": "11032546", "id2": "88047", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testCopyUnknownSize": [" testcopyKnownsize", " testCopyunknownLength", " testCopyKnownShape", " testCopyUnknownLength", " testcopyUnknownsize", " testcopyUnknownShape", " testCopyKnownsize", " testCopyDifferentSize", " testCopyDifferentsize", " testCopyunknownSize", " testCopyUnknownsize", " testCopyKnownSize", " testcopyUnknownLength", " testcopyKnownSize", " testcopyKnownShape", " testcopyUnknownSize", " testCopyKnownLength", " testCopyunknownsize", " testCopyUnknownShape", " testCopyunknownShape", " testCopyDifferentLength", " testcopyKnownLength", " testCopyDifferentShape"], "in": ["inn", "al", "up", "is", "it", "ain", "inv", "sin", "inner", "isin", "r", "din", "copy", "mm", "file", "source", "log", "bin", "i", "gin", "data", "on", "from", "In", "inside", "ins", "en", "IN", "l", "con", "null", "input", "cin", "rin", "inf", "ind"], "out": ["auto", "obj", "up", "it", " Out", "Out", "inv", "ex", "a", "aos", "cmd", "all", "b", "log", "err", "io", "one", "data", "gt", " OUT", "user", "on", "result", "res", "sum", "or", "check", "t", "at", "o", "by", "OU", "output", "client", "gr", "os", "null", "con", "to", "end", "co", "list", "outs", "OUT", "net", "n", "ou"], "cpySize": [" cplyLength", " cplyCount", "CplyCount", "cpeSize", "cpysize", "cplySize", "cpyCount", "cpyLength", "cdysize", "cpeCount", " cplysize", "cpeLength", " cplySize", " cpysize", " cpyLength", "cfiCount", "cfiSize", "cdyCount", "CpyLength", "CpyCount", "CpySize", "cdySize", "cplysize", "CplyLength", "cfisize", "cfiLength", "cplyLength", "CplySize", "cpesize", "cdyLength", "Cpysize", "Cplysize", " cpyCount", "cplyCount"], "outArray": ["inString", "outStream", "outString", "outArea", "outObject", " outArea", "listArray", " outString", "neArray", " outarray", "outImpl", "OUTArray", " outObject", "nearray", " outImpl", "OUTarray", "inArea", "listArea", "listString", "OUTObject", "OUTStream", "listImpl", "inImpl", "neObject", "neStream", " outStream", "outarray", "inArray"]}}
{"id1": "20181656", "id2": "2199604", "code1": "    private int[] sortRows(int[] rows) {\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows.length - 1; j++) {\n                if (rows[j] > rows[j + 1]) {\n                    int temp = rows[j];\n                    rows[j] = rows[j + 1];\n                    rows[j + 1] = temp;\n                }\n            }\n        }\n        return rows;\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 0, "substitutes": {"sortRows": [" sortLords", "sortRues", "sortRords", "sortLords", "sortDords", " sortRues", "sortDues", "sortRecows", "sortLrows", "sortRecues", "sortRecrows", " sortRords", " sortLues", " sortLows", "sortDows", " sortLrows", "sortRrows", "sortLues", " sortRrows", "sortRecords", "sortDrows", "sortLows"], "rows": ["views", "ges", "ports", "months", "errors", "values", "relations", "links", "keys", "orts", "data", "dates", "cells", "res", "tests", "ries", "events", "ros", "list", "ues", "names", "resources", "fields", "posts", "rules", "bs", "rs", "forms", "stats", "series", "users", "ints", "rown", "uds", "changes", "ards", "vs", "types", "terms", "row", "outs", "images", "cases", "raw", "groups", "frames", "ods", "pages", "runs", "blocks", "ris", "docs", "roots", "xs", "rooms", "issues", "workers", "arr", "packages", "ins", "ms", "history", "maps", "sheets", "tracks", "checks", "ls", "lines", "members", "rates", "heads", "reports", "results", "projects", "files", "rices", "abs", "ids", "modules", "models", "items", "orders", "ows", "headers"], "i": ["ix", "bi", "ri", "init", "ip", "p", "mi", "is", "it", "gi", "ji", "ui", "phi", "si", "v", "g", "ini", "hi", "u", "e", "iu", "io", "ci", "ori", "ti", "zi", "di", "id", "xi", "m", "q", "ei", "ic", "in", "us", "out", "ki", "ai", "ie", "pi", "ia", "ar", "ii", "li"], "j": ["ix", "im", "obj", "other", "jump", "uj", "jl", "it", "ji", "x", "ret", "g", "v", "si", "ja", "job", "son", "je", "u", "e", "json", "last", "jo", "b", "jc", "err", "kid", "og", "k", "next", "rem", "di", "user", "oj", "m", "kj", "q", "jac", "J", "jet", "bj", "y", "br", "ij", "aj", "dj", "out", "er", "pr", "jp", "o", "by", "adj", "l", "jit", "rel", "jj", "req", "s", "js", "z", "fr", "my", "note", "sim", "bot", "uni", "state"], "temp": ["cum", "tem", "orig", "EMP", "tr", "clean", "const", "tc", "current", "perm", "alt", "buffer", "variable", "tt", "tmp", "Temp", "dat", "mod", "local", "template", "result", "txt", "base", "fake", "tim", "status", "kw", "cell", "mp", "porary", "mem", "pre", "t", "test", "vt", "term", "null", " tmp", "fac", "level", "emp", "mint"]}}
{"id1": "8000624", "id2": "755203", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyFrom", " copiesTo", " copiesInt", "CopyFrom", " copiesFrom", " CopyInt", " CopyFrom", " copyTo", " copyInt", "CopyInt"], "dest": ["name", "origin", "path", "orig", "nom", "est", "p", "image", "Dest", "it", "pipe", "v", "src", "fn", "target", "copy", "w", "temp", "source", "filename", "opt", "tmp", "result", "txt", "cont", "st", "img", "mem", "them", "loc", "usr", "d", "output", "dir", "null", "th", "sp", "cat", "rest"], "in": ["inn", "ire", "al", "inc", "up", "init", "image", "is", "per", "ac", "ain", "it", "mi", "sin", "inner", "isin", "ini", "r", "din", "file", "min", "source", "nin", "bin", "i", "ir", "internal", "read", "gin", "local", "one", "ar", "win", "on", "m", "from", "login", "In", "ins", "inside", " input", "en", "t", "IN", "o", "by", "l", "client", "iter", "con", "ai", " din", "cin", "rin", "input", "re", "net", "reader", "inf", "ind", "thin"], "out": ["obj", "up", "not", "other", "ln", "writer", "full", "it", "Out", "inner", "v", "ex", "nt", "fn", "oe", "w", "outer", "flush", "e", "dis", "aos", "ns", "b", "all", "cos", "io", "one", "conv", "gt", "user", "batch", "res", "ot", "cn", "loss", "op", "t", "en", "at", "o", "ne", "by", "write", "output", "client", "os", "null", "boot", "to", "oss", "end", "co", "con", "outs", "OUT", "na", "list", "net", "note", "can", "n", "ou"], "c": ["character", "cap", "cs", "ch", "ac", "bc", "ec", "char", "cb", "cc", "cd", "arc", "g", "v", "current", "u", "e", "cl", "gc", "i", "k", "f", "uc", "unc", "cont", "cut", "conf", "nc", "code", "t", "lc", "d", "cm", "cf", "l", "sc", "con", "count", "rc", "cr", "ca", "z", "cod", "ce", "cat", "C", "n", "cp", "ct"]}}
{"id1": "3375724", "id2": "20685385", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "label": 1, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" insertarEmissoresDosTitulOsFe", " insertarEmissoresDosTituloC", " insertarEmissoresDosTitULosFe", " insertarEmissoresDosTitULoC", " insertarEmissoresDosTitULoFe", " insertarEmissoresDosTitULoT", " insertarEmissoresDosTitULosT", " insertarEmissoresDosTituloT", " insertarEmissoresDosTitulosC", " insertarEmissoresDosTitulasC", " insertarEmissoresDosTitulOsC", " insertarEmissoresDosTituloF", " insertarEmissoresDosTitULosC", " insertarEmissoresDosTitulasT", " insertarEmissoresDosTitulosT", " insertarEmissoresDosTitulosF", " insertarEmissoresDosTitulasFe", " insertarEmissoresDosTitULosF", " insertarEmissoresDosTitulOsF", " insertarEmissoresDosTitulasF", " insertarEmissoresDosTitulosFe", " insertarEmissoresDosTituloFe", " insertarEmissoresDosTitulOsT", " insertarEmissoresDosTitULoF"], "pArquivoTXT": ["pArquivoTOX", "pArquivoFxt", "pArquivoRXT", "pArquivoRxt", "pArquivotOX", "pArquivTOX", "pArquivTEX", "pArquivoXTXT", "pArquivoFRL", "pArquiveTxt", "pArquivoTxt", "pArquivTIN", "pArquivoNxt", "pArquivoFEX", "pArquiveNBT", "pArquivTxt", "pArquivoDRL", "pArquivoXTOX", "pArquivNXT", "pArquivoNBT", "pArquivotIN", "pArquivRIN", "pArquivoROX", "pArquivoXTIN", "pArquiveNxt", "pArquivotxt", "pArquivRxt", "pArquivoFXT", "pArquivoBxt", "pArquivoXTxt", "pArquivoBEX", "pArquivoTRL", "pArquivoDXT", "pArquivoNRL", "pArquivNxt", "pArquivotXT", "pArquivTRL", "pArquivoTEX", "pArquivROX", "pArquiveNXT", "pArquivNRL", "pArquivoFBT", "pArquiveNEX", "pArquivoTIN", "pArquivoRIN", "pArquivTXT", "pArquivRXT", "pArquivoNEX", "pArquivoDEX", "pArquivoNXT", "pArquivNEX", "pArquiveTEX", "pArquiveTBT", "pArquiveTXT", "pArquivoBXT", "pArquivoTBT", "pArquivoBBT", "pArquivoDxt"], "pAndamento": ["pandmentO", "pAndumentO", "pAndumentoS", "pAndamentos", "pandamentO", "pandamentos", "pAndamentO", "pAndumentos", "pAndmentoS", "pandamentoS", "pandmentoS", "pAndmentos", "pandmento", "pandmentos", "pAndmentO", "pAndamentoS", "pAndementO", "pAndementos", "pAndementoS", "pAndemento", "pAndumento", "pandamento", "pAndmento"], "numeroDoRegistro": ["numeroDoRegitulo", "numeroDoregistulo", "numeroDoregestro", "numeroDoRegestulo", "numeroDoRegistulo", "numeroDoRegestros", "numeroDoregistr", "numeroDoregestulo", "numeroDoRegitro", "numeroDoRegestro", "numeroDoRegestr", "numeroDoRegistros", "numeroDoRegitr", "numeroDoregestr", "numeroDoRegistr", "numeroDoregistro", "numeroDoRegendro", "numeroDoRegitros", "numeroDoRegendr", "numeroDoRegendulo", "numeroDoregestros", "numeroDoregistros", "numeroDoRegendros"], "in": ["inn", "scan", "inc", "pin", "kin", "ln", "sin", "inner", "isin", "din", " ins", "min", " out", "nin", "bin", "tin", "inning", "gin", " inn", "f", "m", "from", "In", "ner", "ins", " nin", "out", "IN", "inf", "con", "n", " din", "cin", "rin", "input", " sin", "reader", "vin", "edIn", "thin"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialDecaine", "stmtLimpezaIniciaEstinos", "stmtLimpezaIniciaEstINO", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialEstino", "stmtLimpezaInicialDestaine", "stmtLimpezaInicialStinos", "stmtLimpezaInicialStaine", "stmtLimpezaInicioDestINO", "stmtLimpezaIniciaDestINO", "stmtLimpezaInicioDestino", "stmtLimpezaInicialStino", "stmtLimpezaInicioDestinos", "stmtLimpezaInicioEstINO", "stmtLimpezaInicialDestINO", "stmtLimpezaIniciaEstino", "stmtLimpezaInicialdestination", "stmtLimpezaInicioEstaine", "stmtLimpezaInicioEstino", "stmtLimpezaInicialStination", "stmtLimpezaInicialDestinos", "stmtLimpezaInicialEstinos", "stmtLimpezaInicioEstinos", "stmtLimpezaInicioDestaine", "stmtLimpezaInicialdestino", "stmtLimpezaInicialdestinos", "stmtLimpezaIniciaEstination", "stmtLimpezaInicialEstaine", "stmtLimpezaInicialStINO", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialEstination", "stmtLimpezaInicialDecino", "stmtLimpezaInicialDestination", "stmtLimpezaInicialEstINO", "stmtLimpezaIniciaDestinos", "stmtLimpezaInicialDecINO", "stmtLimpezaInicialDecinos"], "sql": ["name", "url", "msg", "html", "ln", "pp", "string", "statement", "sq", "select", "socket", "inv", "xml", "description", "fn", "scl", "expression", "cmd", "json", "wal", "params", "query", "log", "session", "ssl", "join", "sd", "serv", "xs", "template", "ql", "pel", "sv", "dl", "spr", "nl", "q", "command", "lex", "details", "sol", "str", "spec", "csv", "seed", "rel", "sn", "eps", "s", "js", "SQL", "qs", "script", "sp", "ls", "raw", "format"], "stmtDestino": ["stmtdestorno", "stmmInstorno", "stmtDecino", "stmtDecinos", "stmtDestINO", "stmtStINO", "stMTDecino", "stmtDestination", "stmtStin", "stmtInstino", "stmmInstination", "stMTDestinos", "stmtStorno", "stmmDestinos", "stmmDestorno", "stMTDestin", "stmmInstinos", "stmtInstination", "stmtDecin", "stmtdestino", "stMTDecinos", "stMTDecINO", "stmtStinos", "stmtdestin", "stmtInstinos", "stmtStination", "stmmInstino", "stmmDestination", "stmtdestinos", "stmtdestination", "stmtDecINO", "stMTDestino", "stMTDestINO", "stMTDecin", "stmtStino", "stmtDestin", "stmtDestorno", "stmmDestino", "stmtDestinos", "stmtInstorno", "stmtdestINO"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABUCALH", "TAMANHO_DO_CABUCALLHI", "TAMANHO_DO_CABECILHI", "TAMANHO_DO_CABECARHA", "TAMANHO_DO_CABUCALLHA", "TAMANHO_DO_CABECALHA", "TAMANHO_DO_CABUCALLH", "TAMANHO_DO_CABECULH", "TAMANHO_DO_CABECALLHA", "TAMANHO_DO_CABECILHO", "TAMANHO_DO_CABECARHI", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECALH", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECARH", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABUCALHA", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECILHA", "TAMANHO_DO_CABUCALHI", "TAMANHO_DO_CABUCALHO", "TAMANHO_DO_CABECALLH", "TAMANHO_DO_CABECILH", "TAMANHO_DO_CABUCALLHO"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAP_FILE", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPEJFILE", "TAMANHO_DO_RODAPE2do", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPE2DO", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPE2Do", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPE_FILE", "TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAP_Do"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADABOSON", "TAMANHO_DOS_METADADSON", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADABO_", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADOON", "TAMANHO_DOS_METADADS_", "TAMANHO_DOS_METADADDSON", "TAMANHO_DOS_METADABOON", "TAMANHO_DOS_METADABOS_", "TAMANHO_DOS_METADADOSON", "TAMANHO_DOS_METADABos_", "TAMANHO_DOS_METADADDS_"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_REMES", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_POR_RegIN", "TAMANHO_MEDIO_POR_REGIN", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_POR_RECES", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_POR_REMESS", "TAMANHO_MEDIO_POR_REGis", "TAMANHO_MEDIO_POR_Regis", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_REMIN", "TAMANHO_MEDIO_POR_RegESS", "TAMANHO_MEDIO_POR_REMIS", "TAMANHO_MEDIO_POR_REGESS", "TAMANHO_MEDIO_POR_RECis"], "tamanhoDosArquivos": ["tamanhoDosArquesivaos", "tamanhoDosArquivalores", "tamanhoDosArquesivlos", "tamanhoDosArquivalo", "tamanhoDosArqivos", "tamanhoDosArquivelos", "tamanhoDosArquiveores", "tamanhoDosArquIVores", "tamanhoDosArquivao", "tamanhoDosArquivalos", "tamanhoDosArquesivalos", "tamanhoDosArqivores", "tamanhoDosArquesivo", "tamanhoDosArquivals", "tamanhoDosArquivaoes", "tamanhoDosArquIVoes", "tamanhoDosArquIVlos", "tamanhoDosArquiveoes", "tamanhoDosArqIVs", "tamanhoDosArqivs", "tamanhoDosArquiveo", "tamanhoDosArquivores", "tamanhoDosArquivoes", "tamanhoDosArquiveos", "tamanhoDosArquesivao", "tamanhoDosArquesivos", "tamanhoDosArquivlos", "tamanhoDosArquivs", "tamanhoDosArquIVos", "tamanhoDosArqIVos", "tamanhoDosArquives", "tamanhoDosArquIVo", "tamanhoDosArquivo", "tamanhoDosArquesivaoes", "tamanhoDosArquIVs", "tamanhoDosArquivaos", "tamanhoDosArqivo", "tamanhoDosArqIVores", "tamanhoDosArqIVo", "tamanhoDosArquesivoes"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstamados", "quantidadeDeRegistrosEstipados", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstimados", "quantidadeDeRegistrosEstamada", "quantidadeDeRegistrosEstamadas", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstimmados", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstamado", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstimmadas"], "registro": ["regestr", "regdistro", "regitro", "registr", "regestrob", "Regestr", "Registro", "regestros", "registros", "Regestrob", "regitrob", "regdistros", "Registros", "Regestro", "regdistr", "regitros", "regestro", "Registr", "Registrob", "regitr", "Regestros", "regdistrob", "registrob"], "campos": ["campo", "jamOS", "taro", " campo", "tarOS", "campOs", "tarOs", " campOS", "jamo", "campOS", " campOs", "taros", "jamos", "jamOs"]}}
{"id1": "8329093", "id2": "7166270", "code1": "    public void parse(ParserEvent event) {\n        logger.debug(\"parse() called for link \" + event.getLink().getURI());\n        if (event.getLink().getURI().matches(itemFilter)) {\n            logger.debug(\"Content \" + event.getLink().getURI() + \" matched\");\n            Statement stmt = null;\n            ResultSet rs = null;\n            long checksum1 = 0;\n            try {\n                URL url = new URL(event.getLink().getURI());\n                checksum1 = url.openConnection().getLastModified();\n            } catch (MalformedURLException mfe) {\n                logger.error(\"Malformed url \" + event.getLink().getURI() + \" - \" + mfe.getMessage());\n                return;\n            } catch (IOException ioe) {\n                logger.error(\"Couldn't read \" + event.getLink().getURI() + \" - \" + ioe.getMessage());\n                return;\n            }\n            if ((checksum1 == 0) || (checksum1 == 1)) {\n                Adler32 adler32 = new Adler32();\n                NodeList nodes = (NodeList) event.getPageData().getData();\n                adler32.update(nodes.toHtml().getBytes());\n                checksum1 = adler32.getValue();\n            }\n            try {\n                stmt = conn.createStatement();\n                rs = stmt.executeQuery(\"SELECT * FROM documents WHERE url='\" + event.getLink().getURI() + \"'\");\n                if (rs.first()) {\n                    long checksum2 = rs.getLong(\"checksum\");\n                    if (checksum1 == checksum2) {\n                        stmt.executeUpdate(\"UPDATE documents SET checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    } else {\n                        stmt.executeUpdate(\"UPDATE documents SET checksum=\" + checksum1 + \", checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    }\n                } else {\n                    stmt.executeUpdate(\"INSERT INTO documents VALUES \" + \"(DEFAULT, '\" + event.getLink().getURI() + \"', \" + checksum1 + \", '\" + providerId + \"', \" + String.valueOf(System.currentTimeMillis()) + \")\");\n                }\n            } catch (SQLException e) {\n                logger.error(\"Could't perform database query or update - \" + e.getMessage());\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    rs = null;\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    stmt = null;\n                }\n            }\n        }\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 0, "substitutes": {"parse": ["scan", "execute", "link", "init", "apply", "arse", "process", "se", "update", "start", "read", "parser", "build", "match", "fire", "handler", "send", "page", "load", "rule", "get", "render", "print", "document", "patch", "handle", "format"], "event": ["external", "enc", "ex", "info", "device", "content", "cmd", "when", "context", "from", "el", "form", "age", "element", "ctx", "events", "document", "state", "msg", "now", "claim", "ec", "message", "ow", "e", "config", "author", "archive", "error", "on", "result", "address", "rule", "request", "connection", "att", "attribute", "response", "view", "flow", "exp", "this", "arg", "ent", "argument", "information", "dev", "comment", "handler", "command", "object", "load", "ay", "window", "Event", "owner", "initial", "image", "it", "action", "vent", "after", "log", "network", "ext", "atom", "complete", "let", "page", "instance", "er", "app", "exc", "except", "empty", "ev"], "stmt": [" stmp", "ostmb", "Stm", "stpt", "Stms", " Stmp", "stMT", " stpt", "ostmt", "spm", "strmm", "stms", "stmm", "STm", "stmb", "ostmm", "strMT", " Stmt", "STMT", "Stmm", " stm", " Stms", "stmp", "STpt", "spMT", "Stgt", "Stmp", "spgt", "STmt", "strmb", " stms", " stmm", "ostMT", "strmt", " stMT", "Stmt", "StMT", "STmm", " stgt", "stgt", "Stpt", "spmt", "stm", " Stm", " stmb"], "rs": ["ras", "rt", "cs", "rd", "ws", "icks", "ges", "ts", "bs", "ps", "hr", "ats", "ars", "els", "ds", "rates", "sr", "RS", "ys", "vers", "gs", "caps", "ris", "amps", "results", "xs", "ems", "pps", "fs", "sts", "res", "arts", "ags", "rows", "rets", "rings", "its", "ares", "rl", "ims", "ins", "ms", "rys", "vs", "Rs", "usr", "vals", "otes", "acks", "sels", "times", "mr", "rc", "ros", "js", "ires", "qs", "ows", "hs", "ks", "arms", "ues", "ls"], "checksum1": ["cksums3", "checksuum15", "checksumm51", "checksum4", " checksumer4", "checksumone", "checkssum2", "checkssum01", "checksuum81", "cssum2", "checksam1", "cksums1", "checksums1", "csum0", "cksumOne", "checksave81", "checksumm0", "ckssumone", "cksum15", " checksum01", "cssum51", "checkssum3", "checksnum4", "checksumOne", "checksamone", " checksumer01", "checkssum51", "checksnum0", "checksum81", "csum2", "csum51", "checksnum3", "checksnum1", " checksumer1", "checkssum0", "cksum1", "checksumm1", "checkssum15", "cksums0", "cksum3", "ckssum1", "cssumOne", "checksum01", "cksums2", "checksumm2", "ckssumOne", "ckssum4", "cksum0", "checksave1", "checksumer4", "ckssum2", "cksum2", "checksnumone", "checkssumone", "checkssum4", "ckssum81", "checksnum2", "checksatum1", "checksump4", "checksuum2", "checksums3", "checksumer1", "cksum81", "checksums0", "checksnumOne", "checksums01", "csumOne", "checksam2", "csum1", "checksatum51", "checksums4", "checksamOne", "checksatum0", "checksum3", "cssum0", "cksum4", "checksummOne", "checkssum1", "checksave15", " checksumer2", "checksumer01", "checkssum81", "checksuum1", "checkssumOne", "checksum51", "checksumpone", "checksump1", "checksumsOne", "checksave2", "checksatumOne", " checksum4", "checksums2", "checksumer2", "cssum1", "checksum0", "ckssum15", "cksumone", "checksump2", "checksum15"], "url": ["mail", "Url", "link", "name", "msg", "html", "conn", "path", "cert", "image", "string", "char", "document", "r", "job", "content", "u", "value", "UR", "file", "b", "location", "log", "buffer", "ssl", "resource", "build", "data", "bel", "error", "cal", "id", "result", "f", "dl", "base", "abs", "uri", "web", "nl", "http", "sl", "page", "rl", "str", "ll", "browser", "item", "ref", "load", "loc", "rel", "l", "open", "get", "null", "lr", "connection", "URL", "input", " URL", "ol", "ls", "ur", "ul"], "adler32": ["adle16", " adle32", " adler34", "adger34", "adsler64", "adsll33", "adler64", "adger16", "adder32", "adling40", "adll64", "adger33", "adlder31", "adll31", "adlder64", "adder30", "adsler33", "adlder40", "adlder34", " adlder30", "adle64", " adle16", "adling30", " adler16", "adlder32", "adger31", "adsler31", "adler33", " adle64", " adler30", " adler40", "adler40", "adle31", "adlder30", "adder31", " adlder31", "adling31", "adlder16", "adler31", " adler31", "adsll31", "adle32", " adler64", " adlder32", "adsll32", "adler16", "adler30", "adll32", " adle34", "adling32", "adger32", "adder40", "adll33", "adle34", "adsll64", "adler34", "adger64", " adlder40", "adle33", "adsler32"], "nodes": [" nets", "renods", "renodes", "mnets", "mnodes", "noms", " nods", "node", "Nodes", "nets", "nods", "Node", " node", "mnoms", "Noms", "Nods", "renode", "mnode", "nos", " nos", "Nos", "Nets", "renos", " noms"], "checksum2": ["checksnum21", "checksnum3", " checksum21", "checksnum1", "checksnum2", "checksume02", "checksums3", " checksnum21", " checksnum1", "checksums02", "checkssum2", " checksum3", " checksnum2", "checksume21", "checksums1", "checksum02", "checksums2", " checksnum3", "checksume2", "checkssum21", "checksnum02", "checksume1", "checksum21", "checkssum3", " checksnum02", "checksum3", "checkssum02", "checkssum1", " checksum02"]}}
{"id1": "5125848", "id2": "13595251", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"combineJs": ["combinateLink", "Combinejs", "CombineJs", "combosejs", "ComboseLink", "ComboseJS", "combinatejs", "ComboseJs", "comboseJS", "CombineLink", "combINELink", "Combosejs", "combineLink", "combinejs", "combineJS", "combINEJs", "combinateJS", "combINEjs", "combinateJs", "comboseJs", "combINEJS", "comboseLink", "CombineJS"], "base": ["server", "origin", "domain", " bases", "file", "b", "start", "buffer", "source", "host", "bottom", "local", "data", " Base", "based", "template", "root", "id", "from", "uri", "Base", "site", "page", "bas", "prefix", "relative", "address", "api", "db", "bound", " based", "ase", "re", "bid", "reset", " basis", "absolute"], "linkJs": ["inkJs", "linkScript", "LinkJs", "linkedScript", "linkjs", "linkJS", "LinkJS", " linkJS", "inkScript", " linkLinks", " linkTags", "linkedJs", "inkJS", "inkjs", "Linkjs", "linkLinks", "inkTags", "inkLinks", "linkedLinks", "linkedJS", "LinkTags", " linkjs", " linkScript", "linkTags"], "newFiles": ["newDocuments", "linkfiles", "linkDocuments", " newLinks", "nextfiles", "linkFiles", "nextFiles", " newfiles", "newLinks", "nextLinks", " newDocuments", "newfiles", "linkLinks", "nextDocuments"], "dir": ["zip", "auto", "vol", "created", "wd", "def", "cd", "dm", "lock", "Dir", "temp", "file", "div", "folder", "sys", "ir", "tmp", "mod", "local", "DB", "manager", "di", "root", "DIR", "id", "dl", "done", "fs", " directory", "fd", " d", " Dir", "dep", "tar", "good", "md", "desc", "lib", "out", "ref", "loc", "rel", "d", "pkg", "db", "doc", "module", "disk", "dd", "diff", "dr", "directory", "mk", "area", "addr"], "name": [" parser", " err", " self", " foo", " os", " res", " names", " vm", " str", " msg", " scanner", " prefix", " karma", " rebuild", " report", " start", " loader", " db", " bar", " cleaner", " browser", " dummy", " b", " log", " filename", " logger", " tmp", " manager", " info"], "minDir": ["minRel", "thinDir", "skindir", "mainDir", "thinJar", "sortDir", "sortPref", "miniJar", "thinTrans", "MinFile", "skinLoc", "miniTrans", " minPref", "sortRel", "smallNet", "minutePref", "maindir", "miniDir", "minuteDar", "smallDb", "minuteRel", " minDar", "smallDir", "MinDir", " minFile", "minPref", "minJar", " minJar", "minTier", "skinDb", " minNet", "minDar", "thinTier", " minRel", "smallFile", "miniTier", "skinDir", "minDb", "smalldir", " minTier", "MinNet", " minTrans", "minFile", "minuteDir", "minLoc", "smallLoc", "minNet", "mindir", "mainLoc", "mainDb", "minTrans", "sortDar"], "combineFile": ["combinerfile", "combINESet", "combinateFile", "combineSet", "combINEWriter", "combinSet", "combinerEmail", "combinfile", "comboiceFile", "comboseFile", "combinateEmail", "comboicefile", "coordINEFile", "coordINESet", "combinWriter", "comboiceMessage", "coordINEWriter", "combinefile", "comboseWriter", "comineEmail", "cominateFile", "combinatefile", "coordineSet", "combineEmail", "comboiceEmail", "cominateEmail", "combinFile", "combINEFile", "combinerFile", "comineFile", "combinerMessage", "comineMessage", "cominefile", "comboseSet", "coordineFile", "combINEfile", "cominatefile", "cominateMessage", "combosefile", "coordineWriter", "combinateMessage", "combineMessage", "coordINEfile", "coordinefile"], "concatFile": ["comcFile", "concatFiles", "covertFiles", "comcDir", "comcFilename", "convertFiles", "convertFilename", "comcatFilename", "cocatFile", "conCatDir", "cocatTable", "concapTable", "covertfile", "concatFilename", "conatfile", "convertFile", "concapfile", "cocatfile", "conCatFile", "concapFiles", "conatTable", "conCatFilename", "concatTable", "concapFile", "cocatFiles", "convertfile", "covertTable", "concDir", "convertDir", "concFile", "concFilename", "comcatDir", "convertTable", "comcatFile", "conatFiles", "covertFile", "conatFile", "concatDir", "concatfile"], "combineWriter": ["comboseWrite", "declinateWriter", "combinateFile", "combieWrite", "comboseReader", "ComboseCounter", "CombineWriter", "comboseFile", "combenWrite", "combinateCounter", "ComboseWrite", "combosewriter", "Combinewriter", "combenCounter", "combinateWrite", "declineFile", "combinewriter", "combieFile", "CombineCounter", "combieReader", "comboseWriter", "combinateWriter", "combineReader", "declinateWrite", "combieWriter", "declinateReader", "declineWriter", "combineCounter", "declinateFile", "declineReader", "combenWriter", "combineWrite", "CombineWrite", "comboseCounter", "combenwriter", "Combosewriter", "declineWrite", "combinatewriter", "combinateReader", "ComboseWriter"], "concatWriter": ["comvertWriter", "comcatWriter", "comvertFile", "comcatWrite", "coatReader", "concatsReader", "cocatFile", "comcatReader", "coatFile", "concatsWriter", "comvertWrite", "concatWrite", "comvertReader", "convertFile", "convertWrite", "conatWriter", "cocatReader", "convertWriter", "concatsFile", "concatReader", "conatWrite", "coatWriter", "coatWrite", "cocatWriter", "cocatWrite", "concatsWrite", "conatReader", "comcatFile", "convertReader", "conatFile"], "fails": ["ifailing", "ifailed", "Failing", "failing", " failing", "malls", "mocks", "lailing", "frils", "mails", "lailed", "Fils", "facails", "lails", "mailed", "Fails", "facocks", "mailing", "ifocks", " focks", "ifails", " failed", "fils", "frails", "focks", "facailed", " falls", "lalls", "facailing", "frailed", "Failed", "frailing", "lils", "failed", "falls"], "link": ["remote", "child", "ln", "task", "display", "add", "linked", "node", "source", "log", "links", "push", "close", "embed", "match", "map", "c", "mark", "check", "set", "code", "address", "load", "loc", "relation", "l", "share", "open", "line", "skip", "script", "self", "ink", "inline", "follow", "Link", "li"], "path": ["PATH", "ath", "key", "image", "string", "p", "full", "pattern", "src", "entry", "file", "source", "location", "alias", "prop", "resource", "join", "data", "template", "match", "root", "id", "uri", "prefix", "str", "text", "relative", "ref", "loc", "kind", "Path", "route", "input", "hex", "href", "style", "format"], "url": ["mail", "Url", "hl", "html", "li", "string", "char", "this", "r", "mount", "location", "source", "gl", "ssl", "resource", "host", "build", "id", "il", "abs", "uri", "web", "http", "nl", "sl", "str", "ll", "browser", "address", "ref", "loc", "rel", "l", "get", "null", "request", "lr", "URL", "ls", "ur", "href", "ul", "addr"], "inputStream": ["Inputstream", "InputSteam", " inputSet", " inputSteam", "inTime", "InputTime", " inputstream", "outputStyle", "InputStyle", "InputStream", "instream", "inStream", " inputTime", "inputTime", "inSet", "inputSteam", "outputstream", "inputstream", "InputSet", "inputSet", "outputSteam", "inputStyle", " inputStyle"], "jsFile": ["javascriptTable", "jsName", "jsFilename", "jsPath", "cssTable", "JsFilename", "javascriptfile", " jsfile", "cssPath", " jsFilename", "JsPath", "jFilename", "jName", "javascriptPath", "javascriptFilename", " jsPath", "cssFilename", "javascriptName", "jsfile", "Jsfile", "jPath", " jsName", "cssfile", "jsTable", "cssFile", "JsFile", "jFile", " jsTable", "javascriptFile"], "fileName": [" filePath", "filePath", "FilePath", " fileHash", "fileHash", "FileHash", "filename", "getName", "getHash", "FileName", "getname", "getPath", "Filename", " filename"], "outputStream": [" outputStyle", " outputstream", "Outputstream", "OutputForm", " outputSteam", "outputStyle", "outputForm", "writeStream", "OutputStyle", "writeSteam", "OutputStream", "outputSet", "inputForm", "OutputSteam", "inputSteam", "writeSet", "inputstream", "outputstream", "OutputSet", " outputSet", "writestream", "outputSteam", " outputForm", "inputStyle"], "first": ["then", "initial", "each", "now", "quick", "true", "same", "continue", "unique", "master", "false", "current", "index", "fourth", "stack", "last", "second", "success", "all", "ind", "First", "start", "sort", "important", "next", "must", "default", "top", "seconds", "only", "send", "valid", "st", "front", "fast", "third", "open", "real", "latest", "self", "prev", "primary", "natural"], "reader": ["iterator", "rer", "writer", "this", "inner", "stream", "ocr", "loader", "r", "rr", "layer", "file", "buffer", "builder", "read", "parser", "resource", "rar", "io", "data", "context", "handler", "driver", "http", "ner", "rl", "Reader", "er", "ro", "mr", "rc", "core", "row", "runner", "input", "wrapper", "rator"], "jsCompressor": ["jscomposer", "cssRepression", "cssComposer", "jsRepressor", "jsRepression", "jsBuffression", "jsBuffoser", "jscompiler", "cssRepressor", "jsRepiler", "jsBuffiler", "cssCompressor", "cssReposer", "jsComposer", "cssRepiler", "cssCompiler", "jsCompiler", "jsCompression", "cssCompression", "jscompression", "jsBuffressor", "jscompressor", "jsReposer"], "s": ["cs", "full", "is", "ts", "lines", "tes", "ps", "ats", "ds", "ers", "ns", "S", "gs", "tags", "es", "ss", "xs", "less", "ies", "fs", "ids", "eds", "y", "details", "parts", "ms", "ings", "t", "pers", "l", "words", "os", "ens", "qs", "hs", "ls"], "s1": ["s9", "ps1", " s0", "es2", "idFirst", "ls1", "ls0", " s3", "esFirst", "s81", "sFirst", "s0", "pers0", "pers1", "ys3", "ps0", "id1", "id2", "ys1", "id9", "ys0", "ys81", "es1", "es9", "ls81", "ls3", " s81", "s3"], "i": ["im", "bi", "ch", "ip", "ri", "oi", "p", "mi", "it", "is", "ui", "v", "um", "iu", "ion", "io", "ci", "ori", "j", "di", "ifier", "ig", "id", "y", "ic", "ity", "us", "o", "ai", "I", "iat", "ie", "pi", "iti", "ati", "ia", "ii", "li"], "s2": ["esTwo", "S02", "S2", "gs2", "es2", "ssTwo", "ss2", "s22", "ms2", "zSecond", "ms22", "msTwo", "gsSecond", "tes2", "ztwo", "tes02", "SSecond", "s02", "stwo", "z2", "Stwo", "tes1", "gstwo", "z02", "ms02", "es1", "es02", "sTwo", "tesTwo", "sSecond", "ss02", "ss22", "gs02"], "i1": ["e1", "oOne", "it1", "iOne", "p2", "i0", "e4", "pOne", "o0", "a2", "p4", "i4", "p0", "a1", "itOne", "it0", "i01", "o4", "a01", "p01", "p1", "aOne", "o1", "it4", "e2", "i2", "eOne", "it01", "it2"]}}
{"id1": "14191679", "id2": "20735941", "code1": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"EncodeReturn": ["EnforceReturn", "EnodeData", "EnforceData", "EnforceText", "EnccodeText", "EnccodeData", "EnodeText", "EnccodeReturn", "EncodeText", "EncodeData", "EnodeReturn"], "IOException": ["ioEvent", "AudioException", "ioFailure", "IOEvent", "AudioEvent", "AudioFailure", "ioException", " IOFailure", "IOFailure", " IOEvent"], "c": ["cs", "ch", "p", "cmp", "ec", "ac", "cc", "arc", "xc", "enc", "v", "tc", "r", "w", "u", "e", "b", "cos", "h", "ci", "fc", "f", "m", "icc", "crypt", "ic", "cu", "t", "coin", "lc", "dc", "o", "cm", "l", "cr", "ca", "co", "cin", "mc", "C", "n", "cp"], "tmpf": ["tmpv", "tmpfe", "mpfe", " tmpfe", "mkf", "mpd", "mintf", "tempv", "mkd", " tmpv", "mkfile", " tmpd", "mintw", "mintfe", " tmpw", "tempfile", "mpv", "tmpd", "mpf", "mkw", "mpfile", "tempd", "tempf", "tmpfile", "mintfile", "mpw", " tmpfile", "tmpw"], "cw": ["cwd", "csw", " cwindow", "cuwriter", "ccsw", "Cw", "ccwd", "cpw", "cwindow", "Csw", "ccw", "dcwd", "cpweb", " csw", "dcwe", "cws", " cwriter", "ccwe", "cew", "cwriter", "Cwd", "fw", "fwindow", "fws", "cusw", "cewd", " cws", "cuwd", "cwe", "cpws", "fweb", " cwd", "Cwe", "dcw", "cewriter", "cuw", "cweb", " cweb", "cesw", "dcsw", "cpwindow"], "encdata": ["decData", "Encdata", "decdat", "Enctext", "EncData", "excdata", "ENCtext", "excData", " encresult", "encdat", "decdata", "excdat", "Encresult", "exttext", "ENCData", "Encdat", " encData", "ENCdat", "ENCdata", "excresult", "extData", " encdat", "extdat", "encresult", "enctext", "encData", "extdata"], "pigdata": ["pibdat", "pickData", "Pigdata", "pigdes", "Pigata", " pIGdat", "pagdata", "prigdata", " pIGata", "pIGData", " pigdat", "PIGdata", "PIGata", "pircData", "pixData", "Pigdat", "pagData", "prigData", " pIGData", "pigdat", " pigData", "PigData", "pickdata", "PIGdes", "PIGdat", "pagdes", "pibata", "pibdata", "pIGata", "pigData", "PIGData", "Pigfile", "prigdes", "pIGdes", "pixfile", "pigfile", "pIGfile", "pagata", "pibData", "pircata", "pircdat", "pIGdata", "pickdat", "PIGfile", "pircdata", " pigata", "pigata", "pickfile", "pixdat", "pIGdat", " pIGdata", "Pigdes", "prigata", "pixdata"], "pigroute": ["piderouter", "pibrroute", "pyrouter", "pircange", "pigrouter", "prigoute", "piderouse", "pyranne", "pircoute", "prigote", "pibrata", "piscanne", " pigote", " pigrouter", " pyroute", "piscange", "pigranne", "pircanne", "pibroute", "pigoute", " pigrroute", " pigrata", " pibrouse", " pigranne", "pyrouse", " pigrouse", "pyroute", " pibrouter", "pigrange", "piscoute", "pigrata", "pircouter", "piscouter", "pibrouter", " pyranne", " pigrange", "piderroute", "pigrroute", "pigrouse", "prigroute", "pibrote", "pyrange", " pigoute", "pyrroute", "pigrote", " pigata", "pigata", "pideroute", "pigote", " pigrote", "pibrouse", " pyrange", " pibroute", " pibrroute", "prigata", " pyrouter"], "fos": ["fOS", " fios", "fbbos", "fbos", "wOS", "foops", "Fops", "fios", "woss", "fboss", "Foses", "fooses", "fbOS", "foses", "wos", "foss", " fOS", "foios", "Fios", "wbos", "Fos", "foos", " fops", " foses", "fops", " fbos", " foss"], "foc": ["fboc", " fog", "hog", "fbos", " foco", "fiocal", "fosc", " fosc", "rfoc", "rfoca", "Fic", "fioco", "hos", "focal", "hoc", "rfosc", " foca", "fbosc", "fog", " focal", "foca", "fiic", "rfos", "hic", "Foc", "bfic", "fboca", "Fos", "bfoco", "bfocal", "Fog", "bfoc", "foco", "fioc"], "fis": ["feedisc", "fics", "vics", "feedic", "fisc", " fisc", " fics", "sfis", "sfics", "feedisa", "sfisa", "feedis", "sfic", "sfisc", " fisa", "sfos", "vis", "fisa", "vos", "vic"], "fic": ["Fric", "fics", "Fis", "ifics", " ficon", "flicon", "Fic", "hoc", " fics", " fric", "Fico", "his", "flics", "flric", "sfis", "fico", "ifis", "sfoc", "hico", "flic", "ific", "hic", " fico", "Foc", "sfic", "sfico", "fric", "Fics", "hics", "ifico", "ficon", "Ficon"]}}
{"id1": "17724879", "id2": "7296597", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getDigest": [" getMDEST", " getDigEST", "getHashest", "getdigse", " getDigested", "getdigEST", "getDigEST", "getMDest", "getMDse", " getDigse", "getHashse", " getMDest", " getMDse", "getDigse", "getDigested", "getHashEST", "getHashested", "getdigest", " getMDested", "getMDested", "getMDEST", "getdigested"], "attribute": ["name", "character", "al", "metadata", "option", "attr", "each", "and", "operator", "description", "a", "message", "subject", "add", "entry", "member", "expression", "management", "associated", "article", "argument", "value", "event", "variable", "missing", "ribute", "property", "information", "Attribute", "data", "reference", "password", "pair", "application", "type", "qualified", "space", "report", "communication", "command", "object", "item", "address", "element", "at", "relation", "definition", "policy", "word", "position", "request", "input", "operation", "att", "document", "ident", "directory"], "digestAlgorithm": ["digestPalgorithm", "digestSchego", "digestAlgorith", "digestAlgebra", "digestalgorithm", "digestsAlgo", "digesteralgo", "digesterAlgebra", "digestsalgo", "digestSchegorithm", "digesterAlgorithm", "digestPalgo", "digestalgo", "digestALgorithm", "digestsAlgebra", "digesteralgebra", "digesterAlgorith", "digestALgorith", "digesteralgorithm", "digestalgebra", "digestsalgebra", "digestsAlgorithm", "digestAlgo", "digestalgorith", "digesteralgorith", "digestPalgebra", "digestALgo", "digesterAlgo", "digestALgebra", "digestsalgorithm", "digestSchegebra", "digestPalgorith"], "digest": ["designist", "Digest", "diagnested", "mditude", "digend", "digtest", " digist", "hashend", " digested", "digitude", "equested", "equEST", "designEST", "hashested", "mdest", "hashest", "diagnitude", "digse", "digests", "Digist", " digitude", " digse", "digested", "Digse", "Digtest", "Digend", " digtest", " digests", " digEST", "digEST", "hashEST", "designests", "DigEST", "Digests", "equend", "digist", "designest", "Digested", "equest", "mdse", "diagnest", "diagnse", "mdtest", "mdested"], "md": ["sm", "metadata", "amd", "mt", "wd", "cd", "mb", "MD", "nt", "dm", "dh", "ds", "mm", "der", "mac", "cmd", "managed", "hd", "ind", "grad", "bd", "sd", "mod", "esm", "di", "ld", "rpm", "m", "mind", "det", "pdf", "fd", "pm", "good", "rm", "cond", "mg", "ms", "red", "mn", "d", "nd", "met", "pt", "ma", "ud", "strong", "js", "dd", "mc", "dr", "ct", "mk", "df", "pd"]}}
{"id1": "10176678", "id2": "530882", "code1": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"testLoadHttpGzipped": ["testLoadHttpgZips", "testLoadHttpGzipips", "testLoadHttpGgzIP", "testLoadHttpGzIP", "testLoadHttpGZipped", "testLoadHttpgzips", "testLoadHttpGgzips", "testLoadHttpGzips", "testLoadHttpGgzipping", "testLoadHttpGZipping", "testLoadHttpgzipping", "testLoadHttpGzipipped", "testLoadHttpGzipipping", "testLoadHttpgzipped", "testLoadHttpgZIP", "testLoadHttpGZIP", "testLoadHttpGzipIP", "testLoadHttpGZips", "testLoadHttpgzIP", "testLoadHttpgZipping", "testLoadHttpGzipping", "testLoadHttpGgzipped", "testLoadHttpgZipped"], "url": ["mail", "Url", "name", "msg", "link", "html", "pl", "path", "key", "full", "string", "p", "pattern", "fail", "ret", "mount", "config", "location", "b", "err", "ssl", "host", "reason", "build", "id", "result", "dl", "type", "base", "uri", "format", "web", "http", "q", "status", "sql", "str", "ll", "browser", "ref", "loc", "rect", "rel", "test", "l", "policy", "lr", "URL", "options", "acl", "ls", "ur", "state"], "loadingInfo": ["readingNow", " loadingNow", "LoadingInf", "contentInf", "loadingNow", "readingInf", " loadingData", "contentNow", "loadingInf", "readingStatus", "LoadingNow", " loadingInf", "LoadingInfo", "contentInfo", "loadingStatus", "contentData", "LoadingStatus", " loadingStatus", "readingInfo", "LoadingData", "loadingData"], "contentInputStream": ["contentByteSteam", "contentOutputForm", "contentInputPoint", "contentOutputStream", "contentInputThread", "fileInputstream", "contentInfostream", "contentInputSteam", " contentOutputSteam", "contentInputForm", "contentIntSteam", "contentReadSteam", " contentInputSteam", "contentStreamStream", "fileStreamstream", "contentStreamstream", "contentReadPoint", "contentInfoStream", "fileStreamSteam", "contentStreamSteam", "contentOutputPoint", "contentReadForm", "contentIntForm", "fileStreamThread", "contentInfoSteam", " contentInputForm", "contentIntStream", " contentOutputForm", "contentStreamThread", "fileInputThread", "fileStreamStream", "contentByteThread", "contentInfoThread", "contentBytestream", "fileInputStream", "contentOutputSteam", " contentInputPoint", "contentByteStream", "contentReadStream", "fileInputSteam", " contentOutputPoint", " contentOutputStream", "contentInputstream", "contentIntPoint"], "actual": ["currently", "view", "other", "array", "initial", "full", "tested", "now", "required", "approximately", "present", "true", "act", "older", "actually", "false", "old", "original", "current", " Actual", "partial", "all", "ual", "produced", "result", "fake", "truth", "valid", "virtual", "affected", "verified", "test", "received", "reported", "total", "real", "latest", "rendered", "Act", "raw"], "expected": ["nexpected", "pect", "required", "tested", "EXP", "awaited", "erved", "confirmed", "ex", "old", "current", " unexpected", "ired", "umed", "important", "produced", "checked", "announced", "example", "fake", "valid", "anted", "allowed", "or", "pected", "test", "supported", "anticipated", " expect", "planned", "always", "want", "reported", "ert", "received", " expecting", "ed", "pects"]}}
{"id1": "19739421", "id2": "13657103", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": ["UnknownOptionHandler", "UnknownCommandException", " UnknownCommandException", "UnknownParameterClass", "UnknownParameterHandler", " UnknownCommandError", "UnknownFormatException", "UnknownOptionError", " UnknownCommandHandler", "UnknownCommandClass", "UnknownFormatHandler", " UnknownOptionHandler", "UnknownParameterError", "UnknownParameterException", "UnknownCommandError", "UnknownOptionClass", " UnknownCommandClass", " UnknownOptionClass", "UnknownCommandHandler", "UnknownFormatClass", "UnknownFormatError", " UnknownOptionError"], "cmdLineParser": ["mdLineBuilder", "cmdlineOptions", "mdLineHandler", "commandlineReader", "commandLineBuilder", "cmdPageReader", "cmdlinePers", "cmdFrameParser", "mdLineReader", "CmdLineReader", "cmdNetParser", "cmdlineHandler", "mdlinearser", "commandLineRunner", "cmdLHandler", "CmdLineParser", "mdLineParser", "cmdLineRunner", "cmdListParser", "commandLineReader", "cmdLinePers", "mdLineparser", "commandlineBuilder", "commandlineRunner", "cmdLineReader", "cmdLBuilder", " cmdPageBuilder", " cmdPageParser", "cmdLineHandler", "cmdlineReader", "CmdlineProvider", "mdlineParser", "mdlineBuilder", "CmdLineProvider", "cmdPageParser", "cmdFrameRunner", "cmdSetparser", "mdlineHandler", "cmdlineStreamer", "cmdPageBuilder", "cmdChainReader", "cmdSetBuilder", "mdlineLoader", "cmdListReader", "cmdFrameReader", "cmdChainParser", "cmdChainarser", "cmdBlockOptions", "commandLineProvider", "cmdLineStreamer", "cmdLineBuilder", "cmdBlockProvider", "commandlineProvider", "cmdLineOptions", "commandLinePers", "mdLineLoader", "mdlineReader", "cmdLOptions", "cmdSetParser", "mdlineOptions", "CmdLineBuilder", "commandLineParser", "cmdLinearser", "cmdListparser", "mdLinearser", "cmdBlockBuilder", "cmdLParser", " cmdLineReader", "commandlinePers", "CmdlineReader", "mdLineOptions", "mdlineStreamer", " cmdLineBuilder", "cmdlineParser", " cmdPageReader", "cmdLineLoader", "cmdlineLoader", "mdLineStreamer", "cmdPageProvider", "cmdlineBuilder", "CmdlineParser", "cmdBlockHandler", "cmdBlockReader", "cmdlineparser", "cmdNetStreamer", "cmdBlockParser", "cmdLineProvider", "cmdlinearser", "cmdLineparser", "cmdFramePers", "cmdChainLoader", "cmdNetReader", "cmdListBuilder", "commandlineParser", "CmdlineBuilder", "cmdNetHandler", "mdlineparser", "cmdlineProvider", "cmdSetReader", "cmdlineRunner"], "formatOption": ["transformOption", "filterEntry", " formatEntry", " formatOperation", "formatOptions", "formatOperation", "transformOperation", "FormatOptions", " formatOptions", "formatEntry", "FormatOption", "transformEntry", "transformOptions", "filterOption", "FormatOperation"], "outputEncodingOption": ["outputencodingOption", "outputEncodingoption", "outputencodingOptions", "outputEncamingOptions", "outputEncamingoption", "outputEncappingOptions", "outputencachingOptional", "outputEncodingOptions", "outputEncachingOption", "outputencodingoption", "outputEncachingOptional", "outputencachingOptions", "outputEncappingOptional", "outputEncodingOptional", "outputencappingOptional", "outputEncamingOption", "outputencachingOption", "outputEncachingOptions", "outputencappingoption", "outputEncappingOption", "outputEncgingoption", "outputEncamingOptional", "outputencodingOptional", "outputencappingOption", "outputEncgingOption", "outputEncappingoption", "outputEncgingOptional"], "inputEncodingOption": ["inputEncappingOptions", "inputEncodingAttribute", "inputencodingoption", "inputEncappingoption", "inputenclingOptions", "inputEncordingOption", "inputencodingAttribute", "inputenclingAttribute", "inputEnclingoption", "inputCodingOption", "inputEncordingOptions", "inputEncodingoption", "inputEncappingAttribute", "inputenclingoption", "inputEncappingOptional", "inputEncordingoption", "inputenclingOption", "inputEncordingAttribute", "inputEncachingOptions", "inputCachingOptions", "inputEncendingOption", "inputEnclingAttribute", "inputEncappingOption", "inputEncachingOptional", "inputEncodingOptional", "inputEncendingOptions", "inputencodingOptions", "inputencodingOption", "inputCachingOption", "inputEncendingOptional", "inputEncodingOptions", "inputCodingOptional", "inputCachingOptional", "inputEnclingOptions", "inputEncachingOption", "inputCodingOptions", "inputEnclingOption"], "format": ["option", "name", "printf", "unit", "version", "string", "it", "pattern", "display", "fix", "what", "title", "file", "config", "source", "filename", "layout", "sort", "join", "parse", "template", "export", "method", "error", "f", "accept", "type", "force", "scale", "command", "form", "status", "prefix", "set", "language", "with", "api", "at", "module", "table", "output", "get", "term", "tif", "policy", "license", "transform", "pretty", "print", "note", "filter", "pi", "style", "use", "Format"], "outputEncoding": ["outputencaging", "currentEnling", "outputEngoder", "currentEnaching", "outputencoding", " outputDecoding", "outputEncaging", "currentEncaching", " outputEncacing", "outputEnording", " outputEncaming", "outputEnling", "outputEnaching", " outputEngoder", "outputEnging", " outputEngoding", "outputencging", "outputMessining", "outputEncalling", "currentEncling", "outputEncging", "publicEncoding", " outputEngacing", "currentEncoding", "outputEncaling", "currentEnoding", "outputEncoder", " outputEncoder", "outputEnaging", "outputEncacing", "outputDecling", "outputMessaming", "publicEncaging", "outputMessoding", "outputEngging", "outputEngacing", "outputEncryption", "responseEncoding", "outputEncling", "outputDecalling", "outputEnoding", "outputDecaming", "publicEncling", " outputEncining", "outputEngaling", "outputDecining", " outputEngaling", "outputEnacing", "outputCompining", "outputEnaling", "outputencling", "outputEncaming", " outputEncaling", "outputEncording", "outputCompryption", "outputCompoding", "responseEncling", "currentEncging", "outputencaching", "outputEncaching", "publicEncording", "outputDecoding", "outputMessryption", " outputDecryption", " outputEncryption", "currentEnging", "outputCompaming", "outputEnalling", "outputEngling", "outputEngaching", "outputEngoding", "outputDecryption", " outputDecining", "responseEncryption", "outputEncining", "outputencording", "outputEnoder", "responseEncalling", "outputEnryption", " outputDecaming"], "inputEncoding": ["inputEngale", "inputEnacing", "contextEnoder", "inputEncale", "inputEncing", "inputEnoding", "sourceEnling", "inputPackging", "inputEngoding", "inputencoding", "contextEncacing", "inputEnging", "sourceEncling", "inputEning", "inputChale", "inputChacing", "outputEncging", "outputEnoding", "contextEnoding", "inputEngoder", "contextEncoding", "inputencacing", "inputChoder", "inputPackoder", "inputencoder", "inputChoding", "outputEncale", "sourceEncoding", "inputEnoder", "contextEnacing", "sourceEncing", "outputEncoder", "outputEnale", "contextEnale", "inputEncoder", "contextEncale", "inputCodacing", "inputEncacing", "inputencing", "inputCodling", "contextEncoder", "inputPackale", "inputencale", "inputPackoding", "inputencling", "inputEnale", "inputEncling", "sourceEning", "outputEnging", "inputEngging", "inputEnling", "sourceEncacing", "outputEnoder", "sourceEnoding", "sourceEnacing", "inputCoding", "inputCododing", "inputEncging"], "remainingArgs": ["resainingGS", "mainedGS", "resainedLinks", "remistingLinks", "remainingItems", "remainsArgs", "remainargs", "remainGS", "mainingParts", "resainingItems", "remainsBlocks", "remainedItems", "resainedItems", "remainLinks", "remainsGS", "resainedargs", "remainedargs", "trainFrames", "trainingFrames", "remainBlocks", "resainingBlocks", "mainedParts", "remainingParts", "remainItems", "remainJs", "remainFrames", "trainingGS", "resainedGS", "remistingBlocks", "removalGS", "remendingGS", "remendingArgs", "trainGS", "remainParts", "remainedLinks", "remgoingParts", "resainingLinks", "remistingArgs", "trainingItems", "resainingParameters", "mainingGS", "remistingGS", "mainingArgs", "resainingArgs", "trainItems", "resainedParameters", "removalBlocks", "trainArgs", "mainedJs", "resainingargs", "trainingArgs", "remainingJs", "remainingParameters", "removalParameters", "removalArgs", "remgoingJs", "remainingLinks", "remainArgs", "remainsParameters", "remainedParts", "remgoingArgs", "resainedArgs", "remainedJs", "remgoingItems", "remgoingGS", "remainedBlocks", "remainedGS", "remainedFrames", "remendingItems", "mainingJs", "remendingFrames", "resainedBlocks", "remainingGS", "remainedArgs", "remgoingargs", "remainedParameters", "mainedArgs", "remainingBlocks", "remainingFrames", "remainingargs"], "inputFile": ["Inputfile", "InputPath", "hiddenFile", "acceptfile", "outputPath", "InputFile", "InputFILE", " inputfile", "outputfile", " inputLine", "inputPlace", " inputPlace", "requestPath", "hiddenPath", "acceptFile", "inputFILE", " inputLike", " inputFILE", "acceptLine", "hiddenfile", "inputLine", " inputPath", "inputPath", "acceptPlace", "requestfile", "inputLike", "InputPlace", "requestFile", "inputfile", "InputLine", "outputLike", "hiddenLike", "requestFILE"], "outputFile": ["coinDo", "outputDo", "clientFiles", "OutputFiles", "outputfile", "OutputFile", "OutputFilename", "inputDir", "writeFile", "clientDo", " outputDir", "cacheFilename", "clientFile", "outputFolder", " outputfile", "writeDo", "OutputDir", "outputFilename", "writeFolder", "inputFilename", "cacheDir", " outputFiles", "coinFile", "Outputfile", "outputDir", "coinFolder", "inputfile", "clientDir", "OutputDo", " outputDo", "cachefile", "writefile", " outputFolder", "cacheFile", "outputFiles", "coinfile"], "out": ["msg", "obj", "up", "conn", "ln", "init", "writer", "inv", "Out", "inner", "ex", "aos", "outer", "temp", "all", "log", "session", "err", "sys", "io", "inter", "manager", "user", "gen", "on", "error", "res", "report", "cfg", "in", "ins", "ser", "inf", "output", "gr", "dir", "con", "null", "list", "outs", "screen", "OUT", "net", "print", "pretty", "n", "ou"]}}
{"id1": "20275821", "id2": "5632808", "code1": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "label": 0, "substitutes": {"getAttribute": [" getAtt", "getDirectory", "Getattribute", "readattribute", "readAttributes", " getDirectory", "fileAttribute", "getattribute", "GetAttribute", "getAttributes", "readAttribute", "readAtt", " getattribute", "GetDirectory", "fileAtt", " getAttributes", "getAtt", "fileAttributes", "readDirectory", "fileattribute", "GetAtt"], "url": ["Url", "link", "name", "server", "pl", "path", "conn", "string", "char", "r", "job", "u", "cl", "file", "b", "log", "gl", "ssl", "host", "resource", "conv", "user", "call", "dl", "abs", "base", "uri", "il", "web", "http", "el", "sl", "nl", "page", "q", "sql", "rl", "str", "ll", "address", "ref", "https", "loc", "l", "null", "connection", "URL", "document", "ls", "ur", "ul"], "con": ["free", "pc", "cons", "conn", "ln", "go", "bc", "soc", "ver", "ain", "comm", "const", "cc", "bean", "clean", "don", "bon", "pen", "connect", "pos", "cone", "fin", "close", "ran", "col", "conv", "on", "cal", "fc", "num", "c", "cont", "po", "conf", "com", "nc", "ctrl", "CON", "cur", "fl", "canon", "en", "un", "proc", "cm", "cf", "open", "client", "Con", "connection", "dial", "co", "re", "Conn", "trans", "mc", "ct", "can", "cp", "cn"], "response": ["sequence", "yes", "server", "amount", "none", "version", "resp", "def", "description", "usage", "message", "entry", "se", "e", "json", "number", "success", "esp", "pos", "network", "when", "next", "es", "respons", "zero", "error", "result", "application", "res", "http", "trace", "status", "body", "onse", "Response", "code", "relative", "country", "esi", "des", "total", "compliance", "client", "os", "position", "connection", "request", "reset", "roads", "net", "index", "state"], "redirect": [" Redind", "Reditional", " redir", "predir", "predirection", "redrict", "redir", "redirection", "rewirect", " redind", "rewind", "reditional", " redirection", "predirect", "Redirect", " Redirect", "redind", " redrict", " Redirection", "preditional", "rewrict", "Redir", " reditional", " Redrict", "Redirection", "rewirection"], "location": ["remote", "link", "where", "origin", "path", "Location", "system", "usage", "sample", "pointer", "ocation", "filename", "layout", "holder", "slot", "resource", "local", "reference", "template", "behavior", "translation", "comment", "uri", "command", "region", "details", "LOC", "language", "relative", "direction", "address", "zone", "history", "loc", "relation", "phrase", "hold", "position", "operation", "document", "directory", "area"]}}
{"id1": "4118412", "id2": "2199604", "code1": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"compress": ["encact", "suppact", "complate", "suppressed", "ompression", "ompressed", "Compact", "ompact", "ompose", " compression", "encress", "omprypt", "Compression", " complate", "Comprypt", "suppression", "compressed", "encract", "encrypt", "Compress", "suppress", "compact", "ompract", "Compract", "compose", "ompress", "Complate", "comprypt", "Compressed", " compose", "omplate", "compression", "compract", "Compose"], "outputFile": ["sourceFile", "outFile", "outFilename", "outputPath", "outStream", "connectionFile", " outputFILE", "outFormat", " outputPage", "outputPage", "putStream", "outfile", "putFormat", "sourceStream", "OutputFiles", "OutputPath", "outputfile", "connectionFILE", "connectionPath", "putPath", "publicPath", "inputDir", "OutputFile", "OutputFilename", "outputFILE", "putfile", " outputDir", "putPage", " outputfile", "OutputDir", "outputFilename", "inputStream", "inputFilename", "outDir", "outputFormat", "OutputString", "inputString", "publicFILE", " outputStream", " outputFiles", " outputFilename", "outFiles", "Outputfile", "inputPath", "sourceFormat", "outputDir", "inputFormat", " outputPath", "putFile", "inputfile", " outputString", "publicFile", "inputFile", "outputString", "outPath", "inputPage", "sourcefile", "outputFiles", " outputFormat", "outputStream"], "inputFiles": [" inputfiles", "outputfiles", " incomingFiles", "InputFile", " inputFile", "inputItems", " inputResources", "currentfiles", "outputResources", "outputItems", "inputfiles", "currentFiles", "inputResources", " inputItems", " incomingFile", "currentResources", "InputFiles", "currentItems", " inputTopics", "inputTopics", "inputFile", " incomingfiles", "InputTopics", " incomingTopics", "outputFiles", "Inputfiles"], "log": ["mail", "zip", "printf", "url", "msg", "LOG", "path", "pl", "le", "exp", "writer", "shell", "and", "Log", "display", "def", "order", "xml", "ex", "message", "job", "entry", "w", "lock", "progress", "json", "cmd", "err", "debug", "og", "bar", "error", "cal", "low", "pel", "crit", "report", "el", "conf", "trace", "cell", "lex", "sql", "store", "console", "set", "ll", "en", "pers", "mem", "loop", "lo", "lv", "l", "db", "output", "write", "line", "ob", "blog", "row", "skip", "net", "print"], "absPath": ["abisChain", "acsPath", "absoluteUrl", "abP", "ascUrl", "httpsP", "acsPoint", "abisPal", "AbsPort", "Abspath", "absoluteRoot", "abisPath", "absPod", "abDir", "AbsP", "absP", "AbsPatch", "AbsDir", "absolutePod", "httpsDir", "abChain", "absPoint", "AbsPod", " absP", "abRoot", "httpsPoint", "abPoint", "AbsUrl", "httpsPatch", "absolutePath", "absDir", "abPath", "abcPath", "abcChain", "absRoot", "abUrl", "abPatch", "abPal", "absPort", "absUrl", "absoluteP", "absoluteLog", "expath", "exPort", "httpsUrl", "abcLog", "AbsPath", "abspath", "abisLog", "exP", "AbsLog", "absPatch", "absPh", "AbsRoot", "absLog", "httpsPh", "ascPath", "exPath", "acsPh", "httpsPath", "absChain", " abspath", "acsP", "ascLog", "absPal", "abLog", " absPort", "ascPod", "abcPal", "abPh"], "out": ["auto", "cache", "obj", "up", "writer", "it", "Out", "ex", "copy", "outer", "gc", "all", "sys", "cos", "io", "one", "sum", "we", "com", "console", "op", "t", "en", "at", "o", "by", "OU", "write", "output", "gr", "client", "os", "con", "null", "to", "oss", "end", "co", "list", "outs", "OUT", "net", "can", "n", "ou"], "buffer": ["sequence", "cache", "shape", "header", "initial", "char", "message", "memory", "sample", "stack", "value", "source", "variable", "limit", "read", "buf", "Buffer", "append", "parse", "column", "template", "bar", "channel", "library", "password", "batch", "base", "command", "frame", "buff", "binary", "history", "phrase", "length", "table", "output", "paste", "iter", "word", "block", "row", "input", "document", "window", "index"], "readBytes": ["readValues", "readContents", "writeValues", "countBytes", "findByte", "readableContents", "findBytes", " readTokens", "ReadValues", "readableValues", "writeContents", "ReadByte", "readableTokens", "writeBytes", "Readbytes", " readContents", "ReadBytes", "readbytes", "countbytes", " readValues", "readTokens", "countValues", "readableBytes", " readByte", "writeTokens", "countByte", "findValues", "readByte", " readbytes", "findbytes"], "file": ["ile", "name", "link", "url", "path", "key", "le", "File", "image", "string", "model", "tile", "part", "message", "sample", "info", "entry", "run", "entity", "e", "source", "filename", "channel", "local", "data", "FILE", "files", "id", "f", "base", "type", "from", "http", "page", "language", "rule", "relation", "table", "line", "block", "request", "input", "field", "print", "document", "format"], "in": ["inn", "al", "inc", "up", "init", "is", "per", "it", "and", "sin", "inner", "rec", "isin", "din", "info", "mm", "source", "bin", "i", "io", "read", "gin", "local", "on", "from", "In", "el", "ic", "ins", "inside", "en", "IN", "get", "con", "iter", "ai", "input", "rin", "cin", "mc", "reader", "inf", "oin", "ind"], "normalSize": ["minNumber", " normalTime", "exampleFontSize", "exampleSize", " normalName", "NormalSize", "commonFontSize", "NormalLength", "standardFontSize", "commonSize", "exampleAge", "examplesize", "normalName", "standardsize", "NormalName", "normLength", "normalAge", "minName", "NormalNumber", "minTime", "normalFontSize", "normName", " normalLength", "NormalTime", "commonAge", "normTime", "standardSize", "normSize", "normalLength", "normalTime", "commonsize", "normNumber", "normalNumber", "normalsize", "standardAge"], "builder": ["hub", "alph", "building", "writer", "full", "bean", "operator", "order", "loader", "message", "job", "der", "b", "bridge", "make", "uild", "parser", "build", "manager", "keeper", "bar", "library", "result", "builders", "Builder", "handler", "base", "driver", "web", "worker", "command", "or", "browser", "bo", "by", "client", "built", "block", "creator", "runner", "Build", "ler", "control", "framework", "BU"], "process": ["execute", "and", "task", "this", "job", "run", "connect", "cmd", "node", "success", "make", "session", "function", "parse", "processor", "call", "result", " program", "Process", "command", "pm", "frame", "object", "check", "service", "thread", "code", "class", "condition", "proc", " Process", "component", "term", "position", "count", "exec", "pid", " processes", "script", "processing", "cess", "program"], "minSize": ["MinSize", "minBytes", "minScreen", "MinBytes", "maxBytes", " minBytes", "minStatus", "MINLength", "MINSize", "MinLength", "MINStatus", "MINBytes", " minLength", "minLength", "maxSize", " minScreen", "MinStatus", " minStatus", "maxLength", "maxScreen", "MinScreen"], "diff": ["delete", "comp", "del", "erence", "cmp", "equal", "different", "resp", "same", "def", "delay", "fail", "add", "distance", "dx", "dis", "Diff", "change", "div", "update", "eff", "sd", "dust", "deb", "dev", "iff", "dl", "mix", "Delta", " difference", "draw", "range", "between", "rel", "d", "length", "split", "exc", "dist", "size", " Diff", "missing", "desc", "changed"], "percentage": [" percentAGE", "voltager", " percentade", "percentability", "repages", "taxager", " percentages", "taxure", "voltade", "repage", "repAGE", "Percentability", "PercentAGE", "repability", " percenture", "Percentage", "taxade", "volture", "percentager", " percentability", " percentager", "taxage", "percentages", "Percentages", "percentAGE", "percentade", "percenture", "voltage"], "diffSize": ["Diffsize", "DiffFontSize", "diffSIZE", " diffLength", "diffPrice", "rangeSIZE", "diffLength", "dustPrice", "rangeLength", "diffsize", "resultsize", "resultSize", "rangeSize", "DiffSize", " diffsize", "resultLength", "DiffLength", "diffFontSize", " diffPrice", "dustSize", "resultFontSize", "dustSIZE", "rangePrice", "dustLength", " diffFontSize", " diffSIZE"]}}
{"id1": "11840277", "id2": "2324868", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 0, "substitutes": {"clearTables": ["clearDells", "cleanTables", "cleartashes", "clearContiles", "cleanLiles", "clearTableables", "clearTates", "clearTells", "clearLiles", "clearDiles", "clearDables", "resetTableables", "clearTableTable", "resetTashes", "cleanLables", "clearLells", "cleanLells", "clearContells", "cleartables", "cleartTable", "cleanTiles", "clearTiles", "clearSables", "resetTableTable", "resetTates", "clearContables", "clearSashes", "cleanTates", "clearSates", "resetTableashes", "clearLates", "clearTTable", "resetTables", "clearTashes", "clearLables", "cleanLates", "cleartates", "cleanTells", "clearContates", "resetTTable", "clearSTable", "resetTableates", "clearTableashes", "clearTableates", "clearDates"], "conn": ["link", "obj", "die", "enc", "cmd", "user", "conf", "cur", "bo", "cf", "ctx", "pt", "req", "ca", "dn", "Connection", "yn", "org", "cb", "cc", "act", "pool", "forge", "gc", "h", "iw", "on", "oc", "coll", "cfg", "com", "con", "connection", "oss", "exec", "ce", "mt", "col", "addr", "tp", "cn", "cons", "cert", "resp", "comm", "nt", "ds", "ont", "ang", "conv", "gen", "c", "pas", "nc", "gate", "out", "db", "co", "mc", "ct", "yes", "gn", "ch", "ws", "wd", "ns", "connect", "pg", "sys", "priv", "close", "lang", "canon", "en", "rel", "open", "client", "Conn", "note", "rt", "n", "cp"], "stmt": ["stlt", " stmg", "sttry", "stymr", "astmr", " stpt", "ustmg", "stmsg", "restgr", " superstmt", "strpt", "ostmm", "klmt", "estmg", "restMT", "STMT", " stm", "startmt", "contmt", "ustm", "Stmsg", "styMT", "stmg", " superstpt", "ostMT", "statmt", "stymm", "StMT", "statm", "estmm", "ustmsg", "restmt", "ustmt", "stMT", "statgt", "stdlamm", "startmr", "startgr", "Stmr", "Stgr", "usemt", " sttry", "strmt", "klMT", "stgt", "astMT", "estmt", "STmp", "astm", "statMT", "usemm", "estMT", "putmt", "ostmt", "stgr", "Stlt", "usetry", "estmsg", "stymt", "stmr", "contlt", " stlamm", "Stmt", "kllamm", "stlamm", "stm", "stdpt", " stmp", "Stm", "stpt", "strm", " stgr", "STlt", "strmm", "stmm", "STm", " stmsg", "restmr", "startmg", "esttry", "astmt", "Stmg", "klgr", "putMT", "Stmm", "useMT", "STpt", "stmp", "restlamm", "putmg", "Stgt", "Stmp", "STmt", "contMT", " stmm", " superstlamm", "stdmt", " stMT", "putmsg", "restmm", " stgt", "STmm", " stmr", "ostmr"]}}
{"id1": "2017833", "id2": "11005804", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"hash": ["string", "replace", "message", "hello", "update", " fingerprint", "read", "parse", "dump", "Hash", " hashing", "sum", "tag", "check", "str", "code", "test", "write", "to", "render", "transform", "print", "sign", "hex", "sha", " digest", "format"], "text": ["name", "url", "msg", "TEXT", "path", "string", "select", "now", "tx", "act", "pattern", "v", "message", "nt", "content", "title", "value", "event", "config", "source", "buffer", "log", "read", "data", "translation", "password", "ext", "txt", "comment", "cont", "q", "command", "aut", "form", "body", "prefix", "str", "t", "code", "out", "test", "output", "word", "pt", "input", "print", "document", "ct", "Text", "format"], "UnsupportedEncodingException": ["UnsupportedEncryptionError", "UnsupportedDecoderError", "UnsupportedDecoderFailure", "UnsupportedEncensionFailure", "UnsupportedEncoderFailure", "UnsupportedEncensionError", "UnsupportedEncryptionFailure", "UnsupportedDecodingError", "UnsupportedDecodingFailure", "UnsupportedEncryptionException", "UnsupportedEncensionException", "UnsupportedDecoderException", "UnsupportedEncoderException", "UnsupportedEncoderError", "UnsupportedEncodingError", "UnsupportedEncodingFailure", "UnsupportedDecodingException"], "md": ["sm", "amd", "and", "mt", "cd", "mb", "MD", "add", "dm", "dh", "mm", "der", "od", "cmd", "grad", "hd", "ind", "bd", "h", "sd", "mod", "ad", "di", "ld", "m", "det", "pdf", " Md", "pm", "rm", "mg", "red", "ms", "mn", "d", "dir", "mand", "dd", "mc", "dr", "ct", "mk", "df", "pd", "sha"], "sha1hash": ["sha5hex", "sha512h", "sha512dig", "haoneHash", "ha1sum", "sha512hash", "sha2hex", "sha2key", "sha2Hash", "shaonehex", "sha1h", "sha2sum", "sha1dig", "shaonehash", "sha1sum", "ha3sum", "sha2hash", "sha3Hash", "sha11hash", "shaonesum", "ha2Hash", "ha1h", "sha5hash", "ha1hex", "ha1dig", "ha3Hash", "sha11dig", "ha1key", "sha5sum", "haonesum", "ha3key", "shaoneHash", "ha2h", "sha512Hash", "sha1hex", "sha1Hash", "sha2h", "haonehash", "sha2dig", "sha1key", "sha5key", "sha3sum", "ha2dig", "sha3hash", "ha1Hash", "sha11Hash", "sha3key", "ha3hash", "ha2hash", "sha11h", "ha1hash", "haonehex", "sha5Hash"]}}
{"id1": "13946197", "id2": "4852691", "code1": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"transformByMD5": [" encryptBymd4", " encryptbyMD7", " encryptBymd5", " encryptbyMDTime", " encryptByMCTime", " encryptByMD7", " encryptBymd7", " encryptbymdTime", " encryptByMC7", " encryptByMD4", " encryptBymdTime", " encryptByMD5", " encryptBySM7", " encryptbyMD5", " encryptByMC5", " encryptbymd4", " encryptBySM4", " encryptBySM5", " encryptbymd7", " encryptBySMTime", " encryptbymd5", " encryptByMDTime", " encryptbyMD4", " encryptByMC4"], "password": ["name", "path", "key", "PASS", "pattern", "auth", "wd", "description", "message", "entry", "w", "database", "value", "hello", "Password", "filename", " Password", "email", "data", "padding", "user", "security", "login", "sword", "command", "prefix", " passwords", "hash", "text", "address", "phrase", "word", "account", "pass", "token", "username", "secret"], "md5": ["MD7", " mdnt", "mdnt", "MD2", " md2", " mdle", "mand10", " MDle", "md3", "mand3", "mand5", " MD3", "md7", "mag2", "dig5", "MDnt", " mdhed", " MD7", " md7", "MD5", " MDnt", "mag5", " MD5", "md10", "mag3", "MDhed", "md2", "dig3", "dig2", " MD2", "maghed", "mand2", " md3", "MD3", " md10", "MDle", "mdle", "mdhed", "MD10"], "output": ["remote", "response", "view", "four", "answer", "PUT", "display", " Output", "put", "message", "current", "outer", "Output", "STDOUT", "file", "source", "all", "buffer", "log", " outputs", "results", "respond", "data", "export", "echo", "result", "exit", "successful", "batch", "accept", "web", "console", "collection", "text", "out", "csv", "OU", "write", "line", "block", "list", "input", "print", "document", "hidden", "column", "ou"], "bufferPass": ["batchPass", "batchPassword", "bufpass", "BufferCat", "bufferEn", "screenPass", "bufferPASS", "BufferPASS", " bufferSe", "sequenceAdd", "memoryPass", "BufferPass", " bufferPASS", "bufSe", "bufferPassword", "bufPass", " bufferpass", " bufferCat", " bufferDe", "bufPASS", "bufferCat", " bufferPassword", "bufferSe", "bufDe", "sequencePass", "screenAdd", "bufferAss", "BufferPassword", "screenPassword", "sequencePassword", "memoryEn", "memorySe", "Bufferpass", " bufferAdd", "bufCat", "sequenceAss", " bufferEn", "screenAss", " bufferAss", "batchpass", "bufferAdd", "bufferDe", "bufEn", "memoryDe", "bufferpass"], "b": ["bi", "bg", "ib", "p", "bc", "bs", "cb", "mb", "g", "v", "a", "B", "r", "w", "sb", "nb", "u", "e", "buffer", "i", "h", "k", "bb", "j", "bar", "bp", "bit", "m", "c", "batch", "base", "emb", "bis", "gb", "bool", "blue", "y", "wb", "o", "d", "db", "l", "bound", "bt", "ob", "block", "rb", "z", "fb", "be", "n"]}}
{"id1": "17791385", "id2": "20011285", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["clonefile", " cpfile", "copyResource", " cpFile", " copyResource", "cloneResource", " cpFiles", "copyFiles", "copyfile", " copyFiles", " cpResource", " copyfile", "cloneFiles", "cloneFile"], "src": ["Source", "sec", "obs", "init", "inst", "sq", "bs", "sin", "rs", "via", "sr", "sb", "rx", "ck", "sel", "source", "start", "sys", "ys", "sit", "ipl", "txt", "usc", "from", "cont", "ctr", "ux", "rl", "st", "sur", "cur", "ins", "sf", "ser", "usr", "rel", "sc", "req", "rc", "input", "iv"], "dst": [" dnd", "Ddest", "ddest", "ddst", "Dth", "dnt", "dth", "dnd", " dth", "sst", "wdest", "dddest", "Dnt", "wst", "Dnd", "snd", "wth", "ddnt", " ddest", "sdest", "snt", "ddnd", "wnd", "Dst"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "is", "it", "ain", "act", "sin", "inner", "rec", "isin", "din", "info", "mm", "ze", "min", "source", "i", "bin", "gin", "on", "from", "In", "ic", "st", "inside", "ins", "en", "IN", "iter", "con", "ai", "input", "cin", "rin", "ar", "inf", "oin", "ind"], "out": ["auto", "obj", "up", "writer", "it", "and", "Out", "inner", "g", "ex", "nt", "oe", "outer", "aos", "dis", "sys", "bin", "io", "conv", "gt", "on", "ou", "res", "po", "sum", "ot", "st", "t", "at", "o", "ne", "by", "write", "output", "client", "os", "con", "to", "oss", "co", "outs", "OUT", "net", "can", "n", "cn"], "buf": ["msg", "cap", "pl", "cv", "tx", "bus", "cb", "bytes", "bh", "seq", "cmd", "ck", "b", "bed", "buffer", "log", "prop", "uf", "Buffer", "conv", "bar", "box", "gen", "tab", "batch", "arr", "cam", "mu", "good", "br", "cur", "bag", "Buff", "buff", "pkg", "vec", "db", "cf", "stab", "block", "norm", "cat", "fb", "aka", "var", "cp"], "len": ["cap", "elt", "ln", "le", "exp", "lim", "vol", "cmp", "lon", "v", "nt", "seq", "e", "pos", "all", "ren", "h", "fin", "L", "val", "fun", "ld", "num", "il", "dl", "coll", "el", "lf", "str", "fl", "t", "ll", "en", "lib", "no", "loc", "rel", "l", "length", "lan", "Len", "wid", "count", "lic", "end", "z", "compl", "size", "ls", "n"]}}
{"id1": "10690321", "id2": "21999120", "code1": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 0, "substitutes": {"readData": ["processData", "readInfo", "processInfo", "ReadResults", "ReadArray", "ReadData", "processArray", "readResults", "processResults", "loadArray", "loadData", "loadInfo", "ReadInfo", "readArray", "loadResults"], "sTok": ["gsOtt", "sysNik", "sEar", "stsOct", " sLex", "usIter", "tesSocket", "sqlEar", "newEar", "seIter", "stsPick", "sqlTok", "sysTok", "sysSax", "dsVo", "gsTok", "gsOct", "fsOp", "atsLex", "sVal", "tsEp", "rsTok", "atsEp", "sesSocket", "stsIter", "fsNob", "tSax", "sToy", "dsInst", "sLex", "nsAsk", "atsIter", "stsTyp", "gsEp", "sysVal", "qsIter", "gsTyp", "rsOtt", "sSax", "gsCorp", "persTok", "usPet", "seTok", "tOtt", " sIv", "STok", " sOK", "jsSax", "atsTok", "tsIter", "sEp", "gsAsk", "newNik", "qsToy", "jsOtt", " sNik", "sRap", "sqlTyp", "sysAsk", "tesObj", "SOp", "persIter", "sesTok", "gsPick", "sqlNob", "sPut", "tsNik", "stsTok", "nsIter", "sInst", "tsRex", "nsEar", "sNob", "fsObj", "simpleIter", " sVal", " sPick", "itsArch", "sIter", "sPick", "itsTok", "usOtt", "dsIter", "sysIv", "fsEar", "nsInst", " sToy", " sSax", "fsOtt", "nsSax", "sOct", " sNob", "sesObj", "stsEp", "fsCorp", "sPet", "simpleRap", "tsSax", "gsNik", "atsPet", "sIv", " sArch", " sEar", "gsSax", "simpleTok", "newTok", "sObj", "sCorp", "gsRex", "persOtt", "sTyp", " sPet", "sAsk", "jsArch", "SEp", " sOtt", "SInst", "tsTok", "fsEp", "nsOtt", "sysIter", "simpleOK", "seOK", "rsIter", "tsOtt", " sOct", " sApp", "persOct", "sqlIter", "dsTok", "sOtt", "atsOtt", " sObj", "seRap", "stsOtt", "fsRex", "rsEp", " sSocket", "tTok", "tesTok", "atsOct", "jsTok", " sEp", "nsVo", "jsEp", "sqlOtt", " sTyp", "sVo", "newEp", " sOp", "sArch", "sRex", "nsTok", "sSocket", "sysVo", "usTok", "itsSax", "atsAsk", "tesIv", "tesAsk", "tsCorp", " sVo", "qsApp", "sOK", "qsTok", "tsEar", " sPut", "itsEp", " sAsk", "sOp", "tesPut", "gsApp", "gsIter", "sqlEp", " sRap", "tIter", "gsEar", "sysOK", "fsTok", "jsIter", " sInst", "sNik", " sIter", "sesPut", "sApp", "nsEp", "gsToy", "atsTyp", "tesVal", "stsSax"], "topSet": ["rightMap", "bottomSize", " topScan", "topLog", "topScan", "topsMap", "hopMap", "bottomLog", "topsScan", "bottomMap", " topLog", "topsSet", " topSize", "rightLog", "topSize", " topMap", "hopSet", "rightSize", "bottomSet", "topMap", "hopScan"], "leftSet": ["LeftSum", "leftset", "LeftMap", "Leftset", "oldSet", "oldset", " leftNet", "oldNet", " leftMap", "oldMap", "leftMap", "LeftSet", "leftSum", "leftNet", "rightGroup", "LeftNet", " leftGroup", " leftset", "LeftGroup", " leftSum", "leftGroup", "rightSum"], "rightSet": ["rowHat", "rightHat", "rowPos", " rightEx", " rightGen", "blockHat", "blockPos", "rowEx", "rightGen", "leftGen", "blockSet", " rightPos", "rightPos", "rowSet", " rightHat", " rightSET", "rightSET", "blockSET", "rowGen", "rowSET", "rightEx", "leftEx"], "farRightSet": ["farrightset", "farRoleset", "farRForce", "farRset", "farRUse", "farRoleForce", "farRightUse", " farLeftUse", " farrightSet", " farRightForce", "farrightSet", " farLeftset", "farRightForce", "farrightForce", " farrightForce", "farRightset", " farrightset", "farrightUse", " farLeftSet", "farRoleSet", "farLeftUse", "farLeftSet", "farLeftset", " farRightset", " farRightUse", "farRSet"], "vowelSet": ["vowleBase", "vowellBase", "vowleUse", "vowelMap", "vowellList", "vowelsUse", "vowelList", "vowellMap", "vowelBase", "voxellSet", "vowelsBase", "voxelUse", "vowselList", "vowleSet", "vowelsMap", "vowselSet", "vowselMap", "voxelBase", "voxelSet", "vowilSet", "vowilList", "vowsellMap", "vowilMap", "vowelsList", "voxellBase", "vowellSet", "vowsellSet", "vowellUse", "vowsellList", "voxellUse", "vowelsSet", "vowelUse"], "ntk": ["ptp", "ptykar", " syntk", "nextkar", "ntak", "osskw", " etok", "rettk", "ossok", "ontz", "otke", "rtks", "retk", "ontkr", "rentok", "rtkar", "nnik", "nttk", "gtcp", "otK", "cmdk", "entik", "ntik", "detok", "gtke", "dettek", " syntkw", "mdok", "ntok", "ptk", "etmk", "mdik", "rentkj", "rtik", "nnkar", "ontkar", "cmdcp", "otq", "gtk", "ntks", "nnks", "ntmk", "ftk", "ontp", "ntkn", "cmdak", "montq", "ntq", "oddkid", "retz", "ftkw", "otkn", "ontak", "mdk", "ntz", "ntK", " syntok", " etkw", "oddk", "ptyok", "enttek", "gtik", "ntr", "ptyak", "gtkn", "rentk", "cmdik", "detkar", "ontr", "ntcp", "ontch", "ptyK", "etok", " etik", "onty", "ontkj", "ossik", "detK", "entok", "entch", "ntkar", "nty", "otk", "ossk", "ontik", "rentK", "ontK", "montke", "ntkid", "ntp", "retch", "entK", "ftmk", "nextkr", "entz", "ftok", "ntkw", "retik", "gtq", "otcp", "gtK", "renttek", " etk", "ntch", "montk", "entk", "detr", "etkw", "detk", "oddkar", "nextkn", "oddr", "mdkw", "nttek", "rentks", "retok", "ntkj", "ptkj", "ontok", "rentkar", "pty", "onttk", "detkid", " syntmk", "ptykr", "ontkid", "rtok", "ontkn", "rtk", "cmdok", "nextk", "ontk", "ptyk", "retkar", "otik", "renty", "rentik", "ntke", "etk", "rttk", "montkn", "nnk", "ntkr", "cmdK", "ptykn", "rentp"], "maxEwtsVowelLength": ["maxEwtsVowelsLen", "maxEwtsVowellLength", "maxEwtsVowalDuration", "maxEwtsVoxalLength", "maxEwtsVovellLen", "maxEwtsVowelsWidth", "maxEwtsVovelDuration", "maxEwtsVowylDuration", "maxEwtsVoxelWidth", "maxEwtsVowylLength", "maxEwtsVowalLen", "maxEwtsVowylWidth", "maxEwtsVoxallength", "maxEwtsVowelLen", "maxEwtsVowelsLength", "maxEwtsVowelllength", "maxEwtsVowallength", "maxEwtsVoxelLength", "maxEwtsVowelWidth", "maxEwtsVowalLength", "maxEwtsVoxalLen", "maxEwtsVowellDuration", "maxEwtsVowelslength", "maxEwtsVovellDuration", "maxEwtsVoxelLen", "maxEwtsVowelDuration", "maxEwtsVovelLength", "maxEwtsVowellLen", "maxEwtsVoxalWidth", "maxEwtsVovellLength", "maxEwtsVowalWidth", "maxEwtsVovelWidth", "maxEwtsVoxellength", "maxEwtsVowellWidth", "maxEwtsVovelLen", "maxEwtsVovellWidth", "maxEwtsVowylLen", "maxEwtsVowellength"], "puncSet": ["cpuncSet", "pfuncSet", "puncset", "pocoset", "pacGroup", " pfuncSet", "pocoSet", "punctset", "cpuncset", " pfuncBase", "pocoSetting", "ptcset", "cpunctSet", "pacSet", "punctSet", "ptcSetting", "pfuncGroup", "punctSetting", "paucSet", "puncSetting", "cpunctSetting", " puncBase", "cpunctset", "ptcSet", " puncGroup", "puncGroup", "pacBase", "cpuncSetting", "pfuncBase", " pfuncGroup", "puncBase", "paucGroup", "paucBase"], "charSet": ["Charset", "byteSet", "CharacterSet", "charset", "CharSet", "charLog", "characterBase", "byteset", " charset", " charBase", "charList", " charList", "CharList", "characterLog", "characterSet", "CharacterLog", " charLog", "charBase", "byteList", "CharacterBase"], "tibSet": ["nibEn", "nibSet", " tibChain", " tibiSet", "nibiEn", "tibEn", "tiberSum", "nibiSet", "torgSet", "tobSet", "tilibChain", "tibiChain", " tibiChain", "tilibSum", "tilibSet", "tiberSet", "torgEn", "tibiSet", "tibiSum", "tibiEn", "tobEn", "tibSum", "tibChain", "tiberChain", " tibiSum", " tibSum"], "sanskritStackSet": ["sanskritStepBase", "sanskraStateBase", "sanskritStackHash", "sanskritStateHash", "sanskriticBase", "sanskriticHash", "sanskriticSet", "sanskritStateSet", "sanskraStackBase", "sanskraStackHash", "sanskraStackSet", "sanskraStateHash", "sanskritStackBase", "sanskritStepSet", "sanskraStateSet", "sanskritStepHash", "sanskritStateBase"]}}
{"id1": "19849797", "id2": "6403868", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "transferFile", "transferFiles", "copyStream", " cpfile", " cpFile", "transferStream", " cpStream", " cpFiles", "copyFiles", "copyfile", " copyFiles", " copyfile", "transferfile"], "sourceFile": ["sourceLine", "srcfile", " sourceField", " sourcefile", "srcField", "srcTable", "ourceLine", " sourcePage", "srcPage", "srcFile", "ourcePath", "sourceTable", "sourceField", "srcLine", "srcPath", "ourceField", " sourceLine", "ourceFile", "ourcePage", " sourceTable", "ourcefile", "sourcePath", " sourcePath", "sourcefile", "sourcePage", "ourceTable"], "destFile": ["srcDir", " destPath", " destDir", "srcEntity", "optFolder", "restFile", "DestDir", "optEntity", "declFile", "restPlace", "DestPath", "datFilename", " destFiles", " destPlace", "destFolder", "restFiles", "optPath", "destPath", "datFiles", "declEntity", "DestFile", "srcFile", "optDir", "optFilename", "destFilename", "srcPath", "destFiles", " destFilename", "DestFilename", "datPlace", "optFile", "declDir", "destEntity", "srcFolder", "srcFiles", "restFilename", "destDir", "DestFiles", "declFolder", "destPlace", "datFile"], "source": ["Source", "iterator", "attribute", "sequence", "cause", "origin", "parent", "init", "none", "image", "shell", "back", "char", "owner", "OURCE", "inner", "ource", "scope", "src", "se", "sample", "subject", "target", "slave", "copy", "before", "series", "query", "start", "missing", "update", "resource", "channel", "parse", "score", "local", "match", "stream", "result", "note", "comment", "from", "search", "force", "send", "scale", "body", "store", "in", "service", "console", "check", "create", "load", "spec", "pose", "proxy", "component", "table", "iter", "input", "ie", "ce", "show", "SOURCE", "reader", "style", "index", "use", "standard"], "destination": ["destinate", "Destinate", " destment", "veration", "terminined", "descination", "decined", "separination", "restinated", "terminination", "noninate", "decinated", "separation", "decinate", "descinator", "verificate", "destificate", "destined", "Destation", "restinator", "verinated", "destinator", " destinate", "Destinator", " destificate", "destinated", " destation", "Destinated", "noninator", "descation", "decination", "destation", " destinator", "termininated", "verination", " destinated", "noninated", "separment", "restinate", "descinate", "nonination", "destment", "termininate", "Destment", "restination", "separinated", " destined", "Destination", "Destificate"]}}
{"id1": "11477906", "id2": "16572931", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadFAULTSetting", "readdefaultSettings", "readDefaultsettings", "loadFAULTsettings", "loaddefaultsettings", "loaddefaultValues", "loaddefaultSettings", "loadDefaultValues", "readDefaultValues", "readDefaultSettings", "loadDefaultsettings", "loadFAULTSettings", "loaddefaultSetting", "readdefaultValues", "loadFAULTValues", "readDefaultSetting", "loadDefaultSetting", "readdefaultsettings", "readdefaultSetting"], "configFileName": ["configStreamname", "confFilenamename", "configFilenameLocation", "configFilePath", "configFILEname", "configFILEPath", "configPagename", "configFileLocation", "confFilenamePath", "configfilePath", "conffileName", "configFilenamePath", "confFileName", "conffileNames", "conffilePath", "configFilenameNames", "configFILELocation", "configFilenamename", "configStreamPath", "configStreamName", "confFilePath", "configPageName", "confFilenameLocation", "confFilenameName", "configStreamLocation", "configPageNames", "configFilenameName", "conffilename", "confFilename", "confFileLocation", "configFILEName", "configfileName", "confFileNames", "configFileNames", "configFilename", "configfileNames", "configPagePath", "configfilename"], "in": ["inn", "im", "al", "up", "init", "is", "it", "mi", "ain", "inner", "isin", "ini", "din", "info", "run", "e", "source", "ze", "bin", "i", "gin", "ad", "user", "on", "id", "m", "from", "In", "or", "check", "ins", "t", "en", "IN", "ro", "o", "doc", "l", "con", "ai", "ma", "n", " din", "cin", "rin", "input", "re", "mc", "ls", "ar", "inf", "ind"], "out": ["port", "cache", "obj", "not", "server", "are", "Out", "ex", "v", "io", "user", "res", "ot", "store", "ind", "auto", "writer", "gc", "read", "m", "ge", "at", "ne", "os", "con", "oss", "outs", "OUT", "net", "ing", "raw", "cn", "up", "nt", "w", "ent", "une", "all", "de", "conv", "gt", "or", "ins", "o", "OU", "des", "output", "null", "co", "can", "handle", "ou", "init", "it", "copy", "aos", "file", "update", "sys", "ion", "log", "po", "check", "t", "en", "client", "to", "over", "n", "off"]}}
{"id1": "2511579", "id2": "1188100", "code1": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"extractZipFile": ["extractLogfile", "extractPackageFile", "extractPackageDir", "extactLogfile", "extractPackageFilename", "extractJarDir", "extactLogFilename", "extactLogDir", "extractPackagefile", "extractZipFilename", "extactLogFile", "extactZipFilename", "extractLogFilename", "extactZipfile", "extractLogDir", "extactZipDir", "extractLogFile", "extractJarFilename", "extractJarfile", "extractZipfile", "extractZipDir", "extractJarFile", "extactZipFile"], "filename": ["fp", "name", "url", "origin", "path", "ln", "nm", "description", "fn", "src", "original", "ename", "subject", "message", "title", "file", "location", "source", "folder", "SourceFile", "fil", "FILE", "root", "kl", "f", "txt", "base", "uri", "sql", "prefix", "Filename", "output", "latest", "directory", "username"], "progressText": [" progressMath", "progressCode", "progressLog", "progressTEXT", "formtext", "progressPrint", "progressMath", "memoryLabel", "debugtext", " progressInfo", "debugText", " progresstext", "memoryMsg", "progressMsg", "priorityFont", "priorityMath", "progressInd", "progressInfo", " progressInd", " progressRect", "progressCheck", "gradeText", " progressLabel", "memoryInd", " progressPrint", "memoryText", " progressiveLog", " progressiveRect", " progressCode", " ProgressRect", "gradeLog", " progressCheck", "gradeMath", "priorityLabel", "ProgressCode", "ProgressText", " progressiveInfo", "priorityMsg", "progressLabel", "progresstext", "gradeCode", "progressRect", "ProgressCheck", " progressTEXT", "formPrint", "gradeFont", " ProgressInfo", "gradeCheck", " progressMsg", " progressiveText", "priorityInd", "debugPrint", " progressLog", "formTEXT", "progressFont", " progressFont", "priorityLog", "ProgressLog", " ProgressLog", " ProgressText", "debugTEXT", "formText", "priorityText"], "destinationname": ["destinationfrom", "destorationno", "destinedfrom", " destinationnames", "destinationadmin", "destmentationadmin", "destensionroot", " destificationnames", "destorationnam", " destificationroot", "destinationroot", "Destinationfrom", "destinednam", "destinationno", "destositoryName", "Destinationnm", "destmentationno", "destinedadmin", "restinationnam", "destinationnm", "destinationnam", "destensionnames", "destinednm", "destorationname", "restorationnam", "destositorysecret", " destificationname", "Destinationname", "destificationname", "restinationno", "destmentationnam", "destinationnames", "restinationadmin", "destorationadmin", "destmentationname", "destificationroot", "destificationnames", "destinationName", "destinedno", "restinationname", "destinedname", " destificationsecret", " destinationroot", "destositoryfrom", "restorationname", "destositorynames", "destificationsecret", " destinationsecret", "destositorynm", "DestinationName", "destinedName", "restorationno", "destinationsecret", "destositoryroot", "destensionsecret", "restorationadmin", "destensionname", "destositoryname"], "buf": ["fp", "bn", "msg", "cap", "alph", "cv", "tr", "cb", "seq", "pack", "cmd", "b", "buffer", "comb", "prop", "Buffer", "uf", "data", "conv", "hz", "queue", "batch", "cont", "arr", "mu", "boxes", "br", "img", "bag", "text", "Buff", "mem", "buff", "str", "wb", "cur", "pkg", "vec", "db", "paste", "bt", "block", "rb", "fr", "norm", "fb", "bytes", "raw"], "zipinputstream": ["zipinputservice", "zipinitstream", "Zipinputiterator", "zipinputform", "ZipInputsteam", "zipfeedStream", "zoutputStream", "zipsearchiterator", "zipinputsteam", "zipsearchsteam", "zipfeedstream", "zipInputscope", "zipactiveline", " zipinitStream", "ZipInputservice", "zoutputform", "zipoutputiterator", " zipopenStream", "zipupStream", "zipjoiniterator", "zipupiterator", "zipopenstream", "zipupstream", "zipoutputline", "zoutputline", "ziparchivemount", " zipinputview", "zipsearchStream", "zipinitialStream", "Zipinputsteam", "zipoutputStream", "zipactiveform", "zipInputline", "zipactiveservice", "zipupcontext", "zipinputmount", "zipinputiterator", "zipInputview", "zipinputStream", "zipinitialscope", "zipopeniterator", "ZipInputscope", "zipfeediterator", "ZipInputstream", "zipinputview", "zipoutputsteam", "ziparchiveview", "zipInputstream", " zipfeedstream", "zipoutputform", "ZipinputStream", " zipinputiterator", " zipinputcontext", "zipinputline", " zipinitview", " zipopeniterator", "zipactivestream", "ziparchivestream", "ZipInputiterator", " zipfeediterator", "zipInputiterator", "zipinitialstream", "zipopenStream", "Zipinputscope", "zoutputstream", "zipoutputstream", "zipinitStream", "zipactivescope", "zipinitialservice", " zipfeedStream", " zipopencontext", "Zipinputstream", "zipInputsteam", "zipinputscope", "zipinitmount", " zipinitmount", " zipinputmount", "Zipinputservice", "zipInputStream", "zipInputform", "zipInputcontext", "zinputStream", "zipInputmount", "zipinputcontext", "zipinitview", "zinputstream", "zipjoinStream", " zipinputStream", "ziparchiveStream", "zinputform", "zipsearchstream", " zipinitstream", "zipactiveStream", " zipopenstream", "zipjoinstream", "ZipInputStream", "zipopencontext", "zinputline", "zipInputservice"], "zipentry": ["testEntry", "Zipenter", "zcard", "packagecell", "Zipfield", " zipEntry", " zipfile", "zipcell", "packageentry", "testentry", "testenter", "zipfield", "zenter", "Zipjob", "archivecard", "zoneEntry", " zipinfo", "zoneentry", "zinfo", "ZipEntry", "Zipentry", "zEntry", "Zipinfo", "zcell", "archivecell", " zipfield", "packagecard", "packageconnection", "zipEntry", "archiveconnection", "zipfile", "zconnection", "zipinfo", "zipconnection", "zipcard", "archiveentry", "testjob", "zfield", "zonefile", "zipjob", "Zipfile", "zentry", "zjob", "zipenter"], "entryName": [" entryKey", " entryCase", "elementNot", "seaNot", "EntryPath", "entryType", "cellKey", " entryNot", "seaKey", "cellNAME", "cellname", "attributeSpec", " entryNAME", "cellPath", "sectionKey", "seaTitle", " entryTitle", "entryPath", " entryPath", "sectionSpec", "EntryKey", "sectionName", "existentname", "elementKey", "entryTitle", "entryCase", "entryKey", "cellName", "attributeName", " entryType", "cellType", "existentType", "entrySpec", "entryNAME", "attributeKey", "elementTitle", " entrySpec", "existentName", "seaName", " entryname", "elementName", "Entryname", "entryname", "attributeCase", "entryNot", "EntryName", "sectionCase", "existentNAME"], "n": [" l", "name", "len", "gn", "ln", "yn", "nm", "p", "x", "g", " m", "fn", "nt", "r", "v", "ns", "w", "nn", "ng", "number", "b", "ren", "i", "k", "nan", "j", "nor", "num", "m", "c", "nl", "nc", "y", "t", "ll", "en", "nu", "no", "d", "ne", "sn", "l", "nd", " N", "count", "s", " len", "na", "z", "N", "cn"], "fileoutputstream": ["fileOutputStream", "fileputview", "filecurrentstream", "fileoutputwindow", "binarycurrentlink", " fileoutputStream", "fileinputform", "fileoutview", " fileputsteam", "fileoutstream", "fileputsteam", "filewriteStream", "filecurrentview", " fileoutputwindow", " fileputconsole", "fileinputstream", " fileputStream", "fileoutputStream", "fileputconsole", "fileresponsepipe", "binaryoutputstream", "filesystemStream", "FileOutputstream", "fileOutputwindow", "fileoutlink", " fileputstream", "binarycurrentfield", "filecolumnform", "fileoutputconsole", "fileoutputview", "fileOutputstream", "fileOutputconsole", "FileOutputstyle", "binaryoutputlink", "fileoutfield", "fileresponsestream", "filewritestream", "fileoutputsteam", "binarycurrentview", "filecurrentfield", "fileOutputpipe", " fileoutputpipe", " filewritepipe", "fileinputStream", "fileOutputsteam", "binaryoutputfield", "filesystemconsole", "FileOutputStream", "fileinputstyle", "filecurrentlink", "FileOutputform", "FileoutputStream", "filecolumnstyle", "Fileoutputstyle", "filewritewindow", " fileoutputsteam", "fileputStream", "filesystemsteam", "fileresponsewindow", "fileresponseStream", "fileoutputlink", "filecolumnStream", " fileoutputconsole", " filewriteStream", "Fileoutputform", "filecolumnstream", "fileOutputform", "fileputfield", "fileputstream", "binarycurrentstream", "fileputlink", "Fileoutputstream", " filewritestream", "fileoutputfield", "binaryoutputview", " filewritewindow", "fileoutputpipe", "fileoutputform", "filewritepipe", "fileOutputstyle", "fileoutputstyle", "filesystemstream"]}}
{"id1": "6171406", "id2": "7425022", "code1": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"createTar": ["Createtar", "CreateDir", "setupHar", "setupTar", " createDir", "createtar", "setupDir", " createtar", "setuptar", "createHar", "CreateHar", "CreateTar", "createDir", " createHar"], "directoryToPack": [" directoryToPackage", "DirectoryToPack", "directoryTopack", "directoryTOLoad", "directoryToPlan", "DirectoryToPush", "directorytoPak", " directoryOfPak", "directionToPackage", "directorytoLoad", "DirectoryToPackage", "directionTOPlan", "directoryToPush", " directoryOfpack", " directorytopack", " directoryToPak", "directory2Pak", "directionToPack", "DirectorytoPak", "directoryAsPackage", "directoryToPak", "directorytopack", " directorytoPak", "DirectorytoPackage", "directionToPlan", "directoryToApply", "directory2pack", "directoryFromLoad", "directionTOPak", "directory2Plan", " directoryTopack", "documentToPackage", " directory2pack", "directory2Package", " directoryOfPack", "DirectoryToPak", "directionTOApply", "directionTOPack", "DirectorytoPush", "directoryTOPack", "directorytoApply", "directionToLoad", "directionTOLoad", "directoryFromApply", "directoryTOApply", "directorytoPackage", "directoryOfPak", "documentToPack", "directoryTOPak", "directionTOPackage", "directoryFrompack", "directoryFromPack", "directionToApply", "directoryAsPack", "directorytoPush", "directoryToLoad", " directory2Pack", "directoryOfPack", "directoryToPackage", "directorytoPack", "directoryTOPackage", " directorytoPack", "directoryOfpack", "directoryFromPak", "directoryOfPackage", "directoryFromPlan", "directory2Pack", " directorytoPackage", "directoryTOPush", "directoryFromPackage", " directory2Package", "DirectorytoPack", "directoryTOPlan", "directionToPak"], "targetTarFile": [" targetEarFilename", "targetEarFormat", "targetTarFormat", "targetARPath", "targetEarFile", "targetEarFilename", "targetARFile", "targetJarFile", "targetTarString", "argetTarFilename", " targetEarLine", "TargetAREntry", "targetArchPath", "argetEarfile", "targetEarString", "targetARLine", "targetTarResource", "targettarfile", "targetWarField", "targetWarEntry", " targetEarFile", "targetArchFilename", "targetJarfile", "targettarFilename", "argetTarfile", "targetCarFile", " targetEarFiles", "targetTarLine", "targetTarFilename", "targetJarResource", "targetEarEntry", "targetTarFiles", "targettarFile", "TargetTarEntry", " targetTarFilename", "targetAREntry", "TargetTarfile", "targetJarFilename", "TargetTarFile", "targetTarField", "argetTarString", "targetJarFiles", "targetWarFile", "TargetARfile", "targetARField", "TargetARFile", "targetARFiles", "TargetARField", "TargetTarField", "targetTarEntry", "targetJarFormat", "targetCarLine", "targetJarPath", "argetEarFile", " targetTarLine", " targetTarFormat", "targettarString", " targetTarFiles", "targetCarFilename", " targetEarfile", "argetTarFile", "argetEarFilename", "argetTarResource", "targetEarfile", "targetArchFile", "targetCarResource", "targetARfile", "targetARFilename", "targetArchFiles", "targetARFormat", "targetWarfile", " targetTarfile", " targetTarPath", "targetEarLine", " targetEarFormat", "targetCarfile", "targetEarField", "targetTarfile", "argetEarString", "targetTarPath", "targetEarFiles"], "buffer": ["attribute", "cache", "header", "string", "char", "stream", "message", "memory", "pointer", "entry", "flag", "variable", "limit", "buf", "Buffer", "map", "comment", "batch", "type", "object", "buff", "binary", "length", "table", "block", "print"], "targetOutput": [" targetInput", "sourceOutput", "TargetPUT", "gtPUT", "TargetOutput", "targetoutput", "argetInput", "gtoutput", "argetoutput", "argetTarget", "gtOutput", " targetoutput", "targetTarget", "gtInput", "sourceTarget", "sourceoutput", "targetPUT", "TargetInput", "Targetoutput", "TargetTarget", " targetPUT", "argetOutput", "sourceInput", "targetInput"], "targetOutputTar": ["targetCreatedTar", "argetCreatedtar", " targetTargettar", "argetOutputHar", "targetTargetTar", "argetOutputJar", " targetOutputtar", "argetCreatedJar", " targetTargetTar", " targetTargetJar", "targetInputtar", "targetCreatedHar", "targetCreatedtar", "targetConnectiontar", " targetOutputJar", "targetTargetJar", "targetTargettar", "targetInputJar", "targetOutputHar", "targetCreatedJar", "targetConnectionJar", "targetConnectionTar", "argetCreatedHar", "targetOutputJar", "targetInputHar", "argetCreatedTar", "argetOutputTar", "targetInputTar", "argetOutputtar", "targetOutputtar"], "fileList": ["FileLIST", "fileLIST", " fileSet", "FileStream", "fieldStream", "byteSet", "filelist", "FileList", "fieldSet", "fieldList", "Filelist", "bytelist", " filelist", " fileStream", "fileSet", "byteLIST", "fieldlist", "byteList", " fileLIST", "fileStream", "FileSet"], "iter": ["iterator", "ter", "former", "ip", "other", "init", "tr", "writer", "it", "ver", "itter", "inner", "loader", "ator", "ait", "outer", "train", "ipper", "walker", "i", "ir", "ger", "iner", "inter", "cer", "gener", "iv", "actor", "coll", "valid", "ner", "ser", "chain", "fer", "er", "loc", "loop", "vis", "liter", "Iter", "exec", "list", "oper", "reader", "ind", "li"], "file": ["port", "link", "File", "model", "p", "stream", "old", "info", "number", "channel", "data", "user", "library", "f", "valid", "store", "hash", "element", "table", "running", "core", "tree", "field", "document", "directory", "name", "url", "unit", "path", "le", "version", "full", "icle", "message", "current", "issue", "title", "entity", "e", "legal", "event", "location", "source", "h", "resource", "archive", "fil", "error", "il", "type", "http", "single", "fl", "language", "rule", "use", "ile", "attribute", "remote", "header", "job", "value", "node", "filename", "record", "template", "comment", "base", "time", "object", "chain", "fer", "module", "db", "output", "fe", "null", "ple", "ory", "print", "handle", "group", "key", "image", "string", "true", "entry", "run", "folder", "log", "date", "local", "FILE", "files", "application", "page", "feature", "check", "item", "class", "fold", "dir", "line", "word", "to", "format"], "filePathInTar": ["filePathinEar", "filePathINTar", "filePathINTr", "filepathINTar", "filePathedInHar", "filePathInHar", "filepathinTar", "filePathINtar", "filePathFromTar", "filepathInHar", "filePathedInTar", "filepathInWar", "filePathOutTar", "filepathInTar", "filePathInWar", "filepathINWar", "fileLocationINTar", "filePathInTr", "filePathINHar", "filePathInsideTar", "fileLocationIntar", "fileLocationInTr", "filepathIntar", "filePathInsideWar", "filePathInEar", "filePathinTar", "fileLocationInEar", "filePathintar", "filePathFromEar", "fileLocationINTr", "filePathinTr", "filepathinWar", "filePathFromtar", "filePathINEar", "filePathinWar", "filePathINWar", "fileLocationINEar", "filePathOuttar", "filePathedIntar", "filePathOutWar", "filePathInsideHar", "filePathIntar", "fileLocationInTar", "filePathFromTr", "fileLocationINtar", "filepathintar", "filepathINHar", "filePathedInWar"], "tarAdd": ["TarEntry", " tarEntry", " tarNew", "starAdd", "canCreate", "cotInstall", "cotAdd", "canadd", "rarCreate", "canNew", "tarInstall", "carNew", "rarAdd", "trEntry", "staradd", "carCreate", "trCreate", " taradd", " tarCreate", "cotCreate", "TarMake", "starCreate", "tarMake", "tarEntry", "TarCreate", "TarAdd", "taradd", "cotNew", "tarNew", "carAdd", "starNew", " tarMake", "canAdd", "carInstall", "rarNew", "rarInstall", "trMake", "tarCreate", "trAdd"], "in": ["name", "is", "it", "this", "inner", "sin", "a", "add", "current", "source", "start", "nin", "join", "local", "gen", "on", "within", "id", "from", "under", "In", "into", "an", "inside", "ins", "with", "en", "out", "t", "IN", "at", "un", "by", "get", "sub", "ign", "to", "input", "ing", "ed", "n"]}}
{"id1": "18974466", "id2": "13063241", "code1": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["downloadFile", "copyDirectory", "downloadFiles", " copyObject", "downloadDirectory", " cpFile", "downloadObject", " copyDirectory", "copyObject", " cpFiles", " copyFiles", "copyFiles", " cpObject", " cpDirectory"], "sourceFile": ["samplefile", "fromPage", "srcfile", "fromfile", " sourcefile", " sourcePlace", " sourcePage", "srcPage", "srcFile", "fromFile", "fromPlace", "ourceFile", "ourcePage", "ourcefile", "sourcePlace", "ourcePlace", "samplePage", "sourcefile", "sourcePage", "sampleFile"], "destinationFile": ["destdestResource", "destventionResource", "ddestFilename", "destdestfile", " destensionResource", " destensionFile", "destinationfile", " destensionfile", "destinationFilename", "destventionFile", "dinationResource", "destdestFilename", "destinatorDirectory", "dinationFile", " destensionDirectory", "destensionResource", "destinatorFilename", "destinatedDirectory", "destensionFile", "ddestFile", " destinationResource", "destventionFilename", "destinatedFile", "destinatorFile", "destinatedResource", "ddestfile", "destinatorfile", "destinationDirectory", " destinationfile", "destensionfile", "destinatedfile", "destinatorResource", "dinationFilename", "dinationfile", "destinationResource", "destensionDirectory", "destdestFile", " destinationDirectory", "ddestResource", "destventionfile"], "srcChannel": [" srcClient", " srcMember", "srcConnection", "sslController", "srcchannel", "sslChannel", "sourceChannel", "srcProxy", "rcClient", "ourceChannel", "sourcechannel", " srcChan", "srcController", "ourceProxy", "robController", "sourceClient", "sourceConnection", "curchannel", "rcChannel", "robChannel", "srcMember", "sslMember", "srcButton", "ourceChan", " srcConnection", "curChannel", "curButton", "robChan", "srcClient", "sslChan", " srcController", "sourceChan", "sourceButton", "rcProxy", "sourceProxy", " srcButton", "srcChan", "curChan", "rcChan", "robMember", "rcConnection", "ourceConnection", " srcchannel"], "dstChannel": [" dstChain", "destChan", " dotchannel", "dgtchannel", "dndConnection", "dstConnection", "ddestchannel", "destStore", "dndStream", " dndChannel", "dndChain", "dstChan", " dstStore", "destchannel", "dotConnection", "dstStream", " dstchannel", "dstStore", "dotchannel", "dndchannel", "dstchannel", "ddestChan", "ddestChain", " dstStream", "dotChan", " dotConnection", " dndStream", "ddestStore", "dndChannel", "dgtStream", " dotChain", " dndchannel", "ddestStream", " dotChannel", "dotStore", " dndChan", "destChannel", "dotChannel", "dgtChan", "ddestConnection", " dotChan", "dndChan", " dotStore", "dstChain", "ddestChannel", " dstConnection", " dstChan", "dotChain", "dgtChannel"]}}
{"id1": "14324112", "id2": "16820041", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 1, "substitutes": {"innerProcess": ["inlineRender", "originalSelect", "originalprocess", " innerRender", "inlineProcess", "innerprocess", " innerprocess", "inlineSelect", "innerSelect", " innerSelect", "originalProcess", "innerRender", "originalRender", "inlineprocess"], "curi": [" cudi", "wri", " cdu", "coumi", "Cri", "liri", " ciri", "cphi", "lcvoid", "rcri", "wdu", "crudi", "cdui", "caturi", "catuni", " citi", "acuri", "uncri", "cori", " couri", "couri", "cri", "lcuri", "ctumi", "ciri", "crdu", "luri", "cophi", "dumi", "covoid", " cumi", "acumi", " cui", "cui", "lcui", "lcphi", "mcurl", "cury", "rcuri", "Couri", "acri", "uncuri", "Caddress", "mcumi", "Curi", "chtml", "lcdu", "ctdu", "mcuri", "rcui", "curl", "cruri", " cri", "cdurl", "lcury", "ctiri", "mciri", "acuni", "lciti", "uncdu", "cturi", "diri", "ctiti", "catphi", "rcouri", "durl", "catury", "coury", "caddress", "lui", "couni", "crui", "catvoid", "lcri", "cdumi", "cathtml", "cdri", "ctri", "lcudi", " caddress", "uncaddress", "duri", "cumi", "cuni", "catumi", "lri", "cdu", "Curl", "Cdu", "cvoid", "cudi", "achtml", " curl", "Cumi", "wiri", "ctui", "Cui", "citi", "Ciri", "mchtml", "cduri", "mcuni", "Cuni", "wuri"], "maxsize": [" maxlen", " MAXlength", " maxlength", "Maxize", " MAXnumber", "minspace", "axize", "minSize", " maxSIZE", "maxize", " maxnumber", "MaxSIZE", " maxspace", "maxlength", "mxsize", "Maxsize", "maxlen", "MaxSize", " maxbytes", "axsize", "MAXsize", "maxSIZE", "minsize", "axlen", "mxSIZE", "mxspace", " maxize", "Maxlen", "axbytes", "maxspace", " MAXsize", "MAXlength", "minSIZE", " maxSize", "maxSize", "maxnumber", "Maxbytes", "MAXSize", "maxbytes", "axSize", "MAXnumber", " MAXSize", "mxSize", "axSIZE"], "regexpr": ["resexprop", "fregdpr", "bregexps", "reqexpr", "relyexpr", "fregexpr", "reexpr", "replexpro", "reqpr", "replexexpr", "frepexpro", "consexrepl", "replexPR", "recreer", "reexer", "regexps", "repatternpt", "brecreps", "reqps", "repatternpr", "fregdper", "reexvr", "reewrepl", "repexpr", "fregexexpr", "bregexer", "reexper", "fregexper", "brecreexpr", "regexer", "bregexpr", "reqer", "frepexexpr", "resexpr", "fregexpt", "repatternper", "reewpr", "frepexPR", "regdpr", "repexpro", "relyprop", "resexrepl", "congexprop", "regexPR", "consexpr", "regexexpr", "fregexpro", "repexexpr", "reexexpr", "congexrepl", "reewprop", "rexpro", "relyrepl", "relypr", "reewexpr", "regexper", "fregexvr", "resexexpr", "reexpt", "rexpr", "congexpr", "rexexpr", "regexpt", "congexexpr", "repexPR", "regexprop", "regexrepl", "fregexPR", "consexprop", "brecreer", "consexexpr", "regdpt", "fregdpt", "fregdvr", "bregexexpr", "recreps", "recrepr", "rexPR", "reexps", "replexpr", "brecrepr", "repatternvr", "regexpro", "regexvr", "regdper", "regdvr", "recreexpr", "frepexpr"], "cs": ["ces", "cas", "ws", "icks", "css", "ts", "bs", "cms", "cc", "rs", "cks", "ps", "ats", "ars", "CS", "ds", "ns", "Cs", "gc", "caps", "gs", "acts", "ss", "es", "c", "fs", "sts", "ctr", "nc", "its", "wcs", "unes", "acs", "ims", "ms", "ours", "csv", "cf", "ctx", "sels", "sc", "cus", "mr", "ics", "js", "qs", "ks", "ls", "cp", "cn"], "digest": ["ddester", "ddest", "Digest", "dester", "shaum", "dder", "hashester", "diger", "dest", "Digester", "signest", "shase", "der", " diger", "hashse", "signum", "hashest", "digse", "signse", "Digist", "shaested", "Digum", " digse", "shaest", "digum", "digested", "Digse", " digester", "ddist", "Diger", "digester", "dist", "digist", "hasher", "Digested", "signested"], "s": ["ws", "p", "sq", "is", "x", "ts", "string", "strings", "v", "a", "ats", "r", "ps", "ds", "stats", "ns", "w", "gets", "sb", "b", "i", "S", "h", "gs", "ss", "es", "j", "less", "conv", "f", "c", "sts", "fs", "simple", "y", "ims", "ms", "text", "t", "str", "o", "des", "l", "os", "js", "qs", "ls", "n"], "m": ["sm", "arm", "span", "model", "M", "p", "mi", "nm", "mat", "fm", "g", "v", "message", "r", "dm", "mo", "ym", "w", "mm", "b", "gm", "i", "h", "mod", "match", "mol", "f", "c", "rm", "md", "ms", "t", "d", "l", "cm", "mr", "em", "tm", "vm", "mt", "n"]}}
{"id1": "13757855", "id2": "300397", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"process": ["execute", "apply", "replace", "task", "display", "add", "run", "parse", "build", "processor", "call", "step", "project", "save", "Process", "create", "load", "loop", "proc", "write", "render", "transform", "processing", "filter", "handle", "format"], "tpl": ["ttopl", "terld", "topl", "timplug", "ttpl", "tpg", "turtle", " tplates", "ptpl", "timpl", "Tph", " turtle", "tspr", "atuple", "Tpl", "stplate", "otpl", "stbl", "tmpp", "tyPL", "templ", "stpg", "tPL", "ptbl", " tpp", "tembl", "tpp", "stopl", "itbl", "itPL", "tsurtle", "tyurtle", "otld", "typl", "ttplug", "itpl", "Tplate", "atld", " tplate", "terplate", "tplate", "tsbl", "stplug", "Tplates", "stpl", "ttpg", "Tspl", "ttph", "tplug", "timspl", "tph", "tpr", "ptld", "Tpp", "timpg", "atplate", " tbl", "stspl", "tmbl", "tspl", "Tld", "timbl", "timopl", "tmpl", "ptplates", "tsPL", "temPL", "tempr", "otplate", "tuple", "Tbl", "ttPL", "tld", "tplates", "itplate", " tld", "tmplate", "terpl", "tmplates", "tmPL", "atpl", " tuple", "TPL", "tbl", "timplate", "Tpr", "ttbl", " tPL", "teruple", " tph", "otbl"], "model": ["html", "parent", "M", "content", "node", "file", "product", "log", "Model", " Model", "data", "record", "project", "m", "base", "Document", "el", "models", "object", "md", " models", "module", "tree", "ml", "document"], "packageName": ["PackageClass", "pkgNames", "PackageRoot", " packageRoot", "viewname", "groupVersion", "groupFamily", "viewRoot", "viewClass", "packageNames", "groupNames", "packagename", "viewName", "packageFamily", " packageNames", "packageVersion", "pkgVersion", " packageClass", "PackageName", " packageFamily", "groupName", "pkgName", "packageClass", "packageRoot", "pkgFamily", "Packagename", " packagename", " packageVersion"], "outFileName": ["outFilename", "infileType", "outFNames", "outFileType", "outFilenameSize", " outFilenamename", "outStreamTime", "outFilenameTime", "outTableName", " outTableName", "outDirSize", "outFileSize", " outFilenamePath", "outTableChain", "outfileNames", "outFilenameName", "outImagePath", "outFilenamename", " outfileNames", "outStreamPath", "outfileTime", "outDirName", " outFileTime", "outDirTime", " outFilenameName", "outfileName", "outFilenamePath", "infileName", "outTableType", "outStreamType", "outfileType", "inFileTime", "outFileChain", " outFileType", "outTableTime", "infileNames", "outFileNames", " outFilePath", "infilePath", " outfileName", "outFPath", " outFilenameType", "outfileChain", "inFileName", "outFilenameChain", "outfilename", " outFileNames", " outFilenameChain", " outfilename", " outFileChain", "outFname", "outFilenameType", "outFileTime", "inFilePath", "outImagename", "outFName", " outfilePath", " outTableTime", " outFilenameSize", " outTablePath", "infileTime", " outTableSize", "outTablePath", " outFilename", "outDirPath", "outFilenameNames", "inFileType", "inFileNames", "outStreamNames", "outImageName", "outfilePath", "outImageSize", " outFileSize", "outFilePath", "outStreamName", "outTableSize", "outTablename"], "xsltParam": ["xsltParameter", "xsslParam", "xltParameter", "xsqlParam", "xltConf", "xsslConf", "xsslParameter", "xsmlParam", "xmlParam", "xsltConf", "xltParam", "xsqlParameter", "xmlConf", "xsmlParameter", "xsqlConf", "xsmlConf", "xmlParameter"], "artifact": ["artifacts", "artificial", "anificate", "ardificate", "ardificial", "artificate", " artificial", " artifacts", " artificate", "Artifacts", "ardifact", "anifacts", "partifact", "anificial", "arifact", "partifacts", "anifact", "Artifact", "arifacts", "ardifacts"], "destinationPath": ["destationDir", "estinationName", "destinerDir", "desturationpath", "desturationPath", " destinationTarget", " destociationDisk", "estinationKey", "desticationDir", "descositoryHost", "destATIONPort", "destociationHost", "destATIONPath", "destinationAt", "estinationPoint", "identinateKey", "destacementTime", "identinatePath", "destinatedTarget", "destificationLocation", "DestinationLocation", "estationPath", "estionPATH", "estationDir", "destinatePart", "destinationPoints", "destinationDisk", "destinatorPoint", "DestensionPath", "generinationAt", "destinationTime", "destinatorPath", "origininatedNow", "destregationpath", " destociationpath", "DestensionHost", "destificationDir", "destinationTemp", "DestensionTemp", "DestensionPod", "generinatePath", "destinoName", "destionPATH", "destinationName", "DestinationTemp", "destinateForm", "destinationJar", "chaininatedDisk", "desturationJar", "destociationPoint", "destinatedDisk", "destinatorParent", "destinantPod", "origininationForm", "generinateJar", "destinateLocation", "destinatedDriver", "destinateInfo", "destinerPart", "destesticSystem", "estinationHost", "destinatorpath", "estinationPATH", "destinateChain", "chaininationHome", "generinationSystem", "destinateUrl", "destinationForm", "destinatePath", "destinoTime", "estionPath", "destionpath", "destinantPath", "destositoryParent", "DestinationHost", "destinateNow", "delinationLog", "delinatePoints", "destociationHome", "destinateAt", "estinoPath", "destitutionPATH", "destitutionPoint", "destinerJar", "delinateForm", "destociationDisk", "destinationParent", "origininatedPath", "termininerTarget", " destinationpath", "generinationPath", "descinationParent", "destationPart", "identinateChain", "destinatedKey", "desticationPath", "destinateSystem", "destigationPath", "destinerSystem", "destacementKey", "DestinationPoint", "destesticJar", "destinationLocation", "destinationPATH", "chaininationDisk", "termininationJar", "delinationPoints", "destositoryPort", "destesticAt", "destinationpath", "destinatorPort", "destinationPart", "estinoKey", "estinoTime", "destationPath", "destinateKey", "destinateDir", "DestensionDir", "destensionTemp", "descinationPort", "destacementPath", "destinatorChain", "destregationDisk", "estinationDir", "delinationPath", "destinoHost", "destociationTarget", "chaininatedDriver", "estinationpath", "destinerAt", "destensionPath", "destociationLog", "destATIONParent", "DestinationPath", "destinationUrl", "termininationPath", "chaininatedPath", "destinatedPath", "destinationPort", "termininationTarget", "destositoryHost", "identinationChain", "generinateAt", "destationUrl", "destinerTarget", "termininationpath", "destinerpath", "destinationHost", " destociationPath", "destregationTarget", "origininationChain", "destinationLog", " destinationDisk", "destrancePoints", "descinationPath", "destensionHost", "destinateName", "destationHost", "estionpath", "destranceForm", "descinationHost", "generinateSystem", "DestificationPath", "destionPoint", "destinatorPATH", "destinatePoints", "destinationTarget", "destinoDir", "destigationNow", "destensionPod", "destinerHost", "destinationKey", "estinationPart", "destinoPath", "destinatedInfo", "destinatorHost", "estinationTime", "destacementName", "destitutionPath", "DestensionPoint", "destinationPod", "destinantTemp", "DestinationDir", "destensionPoint", "DestificationDir", "DestinationUrl", "delinatePath", "origininationPath", "origininationNow", "chaininationPath", "DestinationPod", "destventionDriver", "descositoryParent", "destinatedHome", "desticationPod", "destinationDir", "destranceLog", "descositoryPath", "destensionDir", "identinationKey", "destinateLog", "destinationInfo", "destventionPath", "destventionDisk", "estionPoint", "termininerPath", "generinationJar", "identinationPath", "desticationTemp", "delinateLog", "chaininationDriver", "destificationUrl", "destrancePath", "destinatepath", "destociationDriver", "destociationPath", "destinateJar", "destinationPoint", "chaininatedHome", "destventionHome", "destinationChain", "identinateInfo", "delinationForm", "destationLocation", "destATIONHost", "destinateTarget", "identinationInfo", "destinantDir", "destinateHost", "desturationTarget", "termininerpath", "destociationDir", "destitutionpath", "destociationPoints", "destinatedForm", "destociationForm", "destinationNow", "destigationForm", "destinatedNow", "termininerJar", "destinatedpath", "destinationDriver", "descositoryPort", "destinationSystem", "estationHost", "destociationpath", "destinatedChain", "origininatedChain", "destinoKey", "destositoryPath", "estinationPath", "destinateTime", "destionPath", "destinoPoint", "estinoName", "destigationChain", "destinatorKey", "destinationHome", "destregationPath", "estationPart", "DestificationLocation", "destinerPath", "destesticPath", "origininatedForm", "destificationPath", " destociationTarget", "DestificationUrl", "destinatorInfo"], "in": ["inner", "r", "din", "info", "w", "file", "bin", "i", "io", "id", "f", "m", "c", "In", "ins", "t", "IN", "o", "d", "doc", "l", "input", " IN", "reader", "n"], "out": ["msg", "obj", "println", "up", "cache", "ln", "conn", "go", "ch", "writer", "p", "it", "Out", "inv", "inner", "ex", "v", "nt", "w", "outer", "aos", "dis", "oe", "e", "cmd", "u", "file", "nr", "all", "log", "err", "sys", "ger", "b", "io", "gen", "f", "c", "res", "report", "cfg", "conf", "cn", "or", "ins", "t", "o", "l", "write", "output", "gr", "client", "con", "null", "os", "s", "to", "list", "co", "screen", "OUT", "outs", "net", "print", "can", "n", "raw", "ou"], "root": ["name", "Root", "println", "group", "child", "parent", "initial", "p", "New", "def", "Template", "scope", "se", "r", "parents", "node", "json", "config", "start", "de", "context", "roots", "data", "id", "dump", "m", "_", "impl", "chain", "create", "ok", "table", "dir", "tree", "graph", " roots"]}}
{"id1": "6871529", "id2": "2807585", "code1": "    private boolean readUrlFile(String fullUrl, PrintWriter out) {\n        try {\n            URL url = new URL(fullUrl);\n            String encoding = \"gbk\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding));\n            return fileEditor.pushStream(out, in, fullUrl, false);\n        } catch (Exception e) {\n        }\n        return false;\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"readUrlFile": ["readUrlPage", "readURLStream", " readURLfile", " readUrlStream", "readUrlfile", " readURLFile", " readUrlPage", "readurlStream", "readURLPage", " readURLPage", "readPathPage", "readPathfile", "readurlfile", "readPathFile", "readurlPage", " readURLStream", "readURLfile", " readUrlfile", "readurlFile", "readUrlStream", "readPathStream", "readURLFile"], "fullUrl": ["partialURL", "fullName", " fullurl", "fullURL", " fullPath", "FullUrl", " fullUr", "pathURL", "fullurl", "fulRoute", "partialPath", "partialUrl", "partialRoute", " fullURL", "FullUr", "completeURL", "fulURL", "fullRoute", "partialurl", "pathName", "fullUr", "fulUrl", "fulurl", "pathUrl", "completePath", "FullURL", "Fullurl", "FullRoute", "fullPath", " fullName", "completeurl", "pathUr", "completeUrl", "FullName"], "out": ["msg", "ch", "writer", "p", "ws", "it", "Out", "nt", "w", "flush", "aos", "json", "file", "b", "log", "io", "txt", "c", "res", "report", "t", "us", "o", "write", "table", "output", "client", "os", "to", "s", "outs", "OUT", "screen", "pretty", "print", "net", "n", "ou"], "url": ["mail", "Url", "link", "oul", "path", "conn", "char", "r", "job", "sb", "mount", "file", "config", "b", "ssl", "resource", "build", "git", "bel", "f", "dl", "base", "uri", "web", "http", "nl", "sl", "service", "str", "ll", "google", "browser", "ref", "rel", "l", "client", "open", "URL", "ls", "ur", "ul"], "encoding": ["rcaching", "Encoding", "Encoded", "coded", "encapping", "capping", "ENCapping", "cryption", "Encoder", "ENCoded", "encaching", "rcoding", "encoded", "ENCoder", "encoder", "Encryption", "encryption", "ENCoding", "caching", "Encaching", "Encapping", "rcryption", "rcoded", "coder", "coding"], "in": ["inn", "and", "inner", "stream", "r", "din", "info", "file", "source", "bin", "i", "io", "gin", "data", "user", "id", "f", "m", "from", "In", "el", "sum", "conf", "sql", "body", "inside", "ins", "er", "IN", "l", " din", "cin", "rin", "input", "reader", "inf", "ind"]}}
{"id1": "23035537", "id2": "21308543", "code1": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 0, "substitutes": {"getContent": ["updateContents", "updateContent", " getContents", "getMedia", "getContents", " getcontent", "checkContents", "checkMedia", "checkContent", "getcontent", "checkcontent", " getMedia", "updatecontent", "updateMedia"], "userId": ["authorById", " userID", "jobById", "humanById", "humanName", "USERName", "humanId", "userName", " userName", "UserID", "USERId", "authorID", "userById", "authorName", "authorId", "USERById", "USERID", "jobName", " userById", "humanID", "jobId", "userID", "UserById", "UserId", "UserName", "jobID"], "latestMsgId": ["latestMessageById", "lastmsgID", "lastMsgID", "LatestMsgID", "lastmsgid", "lastMsgid", "latestmsgid", "latestMessageId", "latestmsgById", "latestStrIn", "latestmsgIn", "latestMessageIn", "LatestMessageIn", "LatestMsgId", "lastmsgId", "lastmsgById", "LatestMsgIn", "latestmsgId", "LatestMessageById", "latestMsgid", "LatestMessageID", "latestMsgById", "latestStrId", "lastMsgById", "latestMessageid", "LatestMsgById", "latestStrById", "latestmsgID", "lastMsgId", "LatestMessageId", "latestMsgID", "latestMsgIn", "latestStrID", "latestMessageID"], "targetUrl": ["TargetURL", "templateURL", "templateUrl", " targetURL", " targetName", "TargetStr", "argetURL", "templateDest", "targetURL", "baseUr", "argetName", "baseUrl", "TargetUr", "baseStr", "sourceURL", "sourceUr", "targetDest", "sourceUrl", "targetName", "targetUr", "argetUrl", "baseURL", "targetStr", "argetDest", " targetDest", "sourceStr", "TargetUrl", "templateName"], "url": ["Url", "link", "name", "pl", "key", "p", "char", "xml", "r", "u", "mount", "file", "location", "b", "err", "gl", "ssl", "resource", "bel", "call", "id", "dl", "base", "uri", "web", "http", "nl", "sl", "el", "str", "t", "browser", "ll", "ref", "rel", "l", "open", "null", "URL", "ol", "ls", "ur", "ul"], "in": ["inn", "al", "p", "is", "it", "inner", "xml", "stream", "isin", "din", "file", "source", "all", "bin", "i", "io", "serv", "gin", "data", "from", "In", "el", "sql", "body", "or", "st", "str", "ins", "inside", "t", "en", "out", "er", "IN", "o", "l", "con", "null", "n", "s", "input", "cin", "rin", "mc", "inf"], "list": ["sequence", "ls", "lat", "group", "array", "p", "filter", "pool", "v", "add", "info", "detail", "all", "log", "layout", "alist", "data", "record", "top", "listed", "result", "lt", "queue", "batch", "base", "dl", "lp", "format", "lists", "status", "set", "st", "single", "collection", "t", "chain", "out", "load", "item", "summary", "l", "table", "LIST", "null", "count", "block", "tree", "dict", "ml", "ist", "ul", "li"], "parser": ["name", "php", "magic", "system", "per", "now", "pool", "xml", "loader", "ars", "layer", "Parser", "walker", "parse", "music", "bank", "processor", "password", "penter", "arser", "basic", "lp", "handler", "driver", "maker", "worker", "peer", "asser", "service", "language", "er", "proc", "policy", "mr", "document", "student", "reader", "format"], "dao": ["datowa", "ddta", "dai", "dowa", "dnowa", "oosa", " dpo", "datao", "datpo", " dosa", "dnpo", "dataos", "dta", "ddosa", "ota", "dpo", "daos", "oao", "ddao", "ddai", " dta", "dosa", " dai", "dnao", "oai", " daos", "dnaos", " dowa"]}}
{"id1": "2221297", "id2": "14191679", "code1": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 0, "substitutes": {"getURLContent": ["getURLContents", "getURIValue", "getHTMLContent", "getHTMLContents", "getURIContents", "getUrlValue", " getURLData", "getUrlContents", "getUrlData", "getURLValue", "getHTMLValue", "getUrlContent", " getURLValue", "getURLData", " getUrlData", "getHTMLData", " getURLContents", "getURIContent", "getURIData", " getUrlContents", " getUrlValue", " getUrlContent"], "urlToSearchString": ["urlToFindString", "urlToFindContent", "urlForSearchSite", "urlTosearchContent", "urlTosearchURL", "urlTosearchString", "urlToLookContent", "urlToLookString", "urlForFindURL", "urlToSearchURL", "urlToFindURL", "urlForSearchURL", "urlToSearchContent", "urlForSearchString", "urlToSearchSite", "urlToFindStr", "urlTosearchStr", "urlForFindSite", "urlForFindString", "urlForFindStr", "urlForSearchStr", "urlToFindSite", "urlToSearchStr", "urlToTestString", "urlTosearchSite", "urlToLookStr", "urlForFindContent", "urlToTestSite", "urlForSearchContent", "urlToTestURL", "urlToTestStr"], "url": ["Url", "link", "hl", "cert", "org", "ret", "r", "job", "mount", "cmd", "lb", "gl", "ssl", "host", "build", "bel", "ld", "f", "dl", "uri", "web", "nl", "http", "sl", "el", "str", "ll", "google", "out", "https", "loc", "rel", "l", "open", "client", "con", "URL", "ol", "ls", "ur", "ul"], "conn": ["Connection", "obj", "gn", "ch", "cert", "resp", "socket", "addr", "comm", "cb", "inv", "enc", "nt", "ns", "connect", "cmd", "sys", "serv", "conv", "iw", "lang", "res", "pas", "nc", "cur", "gate", "loc", "jp", "db", "ctx", "client", "open", "con", "os", "connection", "oss", "Conn", "ct", "cp", "cn"], "encoding": ["incoded", "encending", "Encoding", "enoding", "coded", "increoder", "incication", "ecmentation", "decoder", "engmentation", "Encending", "encmentation", "encaming", "decending", "cryption", "increication", "Encoder", "ecoder", "encoded", "increoding", "enending", "ecaming", "encoder", "enaming", "enryption", "incoding", "enmentation", "caming", "enoder", "encryption", "cication", "encication", "engoder", "Encryption", "ecoding", "decoding", "engryption", "ecryption", "coder", "decryption", "increoded", "engoding", "incoder", "coding"], "br": ["bn", "bi", "bg", "tr", "bc", "BR", "bs", "cb", "bl", "hr", "r", "bh", "sr", "Br", "nb", "b", "bd", "bridge", "buf", "ber", "bb", "bp", "vr", "bf", "gb", "ctr", "rob", "browser", "pr", "jp", "bt", "bro", "mr", "cr", "lr", "rb", "ob", "fr", "fb", "dr"], "sb": ["bn", "erb", "bg", "ib", "shell", "sq", "bs", "cb", "sth", "sh", "mb", "sa", "bh", "nb", "lb", "b", "gc", "bd", "ssl", "bsp", "sd", "bb", "orb", "sam", "sg", "bp", "eb", "lp", "sync", "sv", "bis", "gb", "bj", "bf", "rob", "gob", "sf", "ub", "kb", "obb", "pb", "db", "bt", "rb", "SB", "zb", "sp", "xb"], "line": ["link", "sequence", "lane", "online", "len", "liner", "ln", "ip", "header", "string", "stroke", "ine", "message", "sample", "entry", "entity", "e", "Line", "number", "file", "source", "point", "log", "LINE", "record", "eline", "comment", "lin", "valid", "page", "cell", "body", "frame", "range", "check", "text", "code", "chain", "rule", "phrase", "l", "word", "iter", "block", "ice", "row", "inline", "print"]}}
{"id1": "20073619", "id2": "17947246", "code1": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "code2": "    public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception {\n        URL url = null;\n        HttpURLConnection conn = null;\n        InputStream istream = null;\n        try {\n            url = new URL(urlLocation);\n            conn = (HttpURLConnection) url.openConnection();\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        loadCookies(urlLocation, conn, c);\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i++) {\n                String header = (String) headers.get(i);\n                String key = header.substring(0, header.indexOf(\":\"));\n                String value = header.substring(header.indexOf(\":\") + 2);\n                Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                conn.setRequestProperty(key, value);\n            }\n        }\n        Debug.debug(\"Set to use GET, URL=\" + urlLocation);\n        try {\n            istream = conn.getInputStream();\n        } catch (Exception e) {\n            Debug.debug(\"Unable to capture input stream: \" + e.getMessage());\n            throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        Debug.debug(\"'GET' - Got input stream.\");\n        if (conn.getContentLength() == -1) {\n            Debug.debug(\"Content length = unknown\");\n        } else {\n            Debug.debug(\"Content length = \" + conn.getContentLength());\n        }\n        byte data[] = null;\n        int curPos = 0, contentLength = conn.getContentLength();\n        if (conn.getContentLength() == -1) {\n            String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\");\n            if (byteSize == null) {\n                contentLength = 4096;\n            } else {\n                contentLength = Integer.parseInt(byteSize);\n            }\n            Debug.debug(\"Content length unknown.  Allowing fuzz of \" + contentLength + \" bytes.\");\n        }\n        data = new byte[contentLength];\n        try {\n            int dataRead = 0;\n            while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) {\n                if (dataRead == 0) {\n                    break;\n                }\n                curPos += dataRead;\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage());\n        }\n        try {\n            istream.close();\n            conn.disconnect();\n        } catch (MalformedURLException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' is invalid: \" + e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed to connect.\");\n        }\n        String dataOut = new String(data);\n        int counter = 0;\n        data = null;\n        istream = null;\n        conn = null;\n        url = null;\n        return dataOut.trim();\n    }\n", "label": 0, "substitutes": {"getPagina": ["getPackaginate", "getPagarinate", "getPagininate", "getPagarine", "getPaginina", "getPagino", "getPackagina", "getPaginine", "getPageinate", "getPagarina", "getPageino", "getPaginino", "getPackagarino", "getPageine", "getPagarino", "getPackagarina", "getPaginate", "getPackagine", "getPageina", "getPagine", "getPackagarine", "getPackagarinate", "getPackagino"], "strurl": ["sprURL", "arrrel", "strssl", "STRstr", " strUrl", "arrURL", " strURL", "sprUrl", "STRssl", "STRUrl", "urlssl", "strURL", "urlurl", "strstr", " strssl", "urlstr", "strrel", "strUrl", "sprrel", "arrUrl", "arrurl", "urlUrl", " strstr", "STRurl", " strrel", "sprurl"], "resp": ["obj", "html", "conn", "lim", " respons", " msg", "repl", "cmd", "pos", "par", " disp", " enc", "respons", "Resp", "res", "rm", "Response", "help", " outp", " ret", "req", " err", "msg", "elt", "rend", "comp", "cmp", "soc", "inv", "ret", "disc", "respond", "body", "summary", " req", "changes", "https", "gz", " rep", "response", "exp", " res", "comm", " response", "ja", "cli", "perm", "neg", "err", "conv", "rep", "pas", "arr", "good", "sol", "pkg", "output", "re", "fr", " Resp", "rest", "rev", "gov", "rex", "acc", "esp", "serv", "dem", "txt", "dl", "buff", "jp", "rel", "csv", "pretty"], "url": ["Url", "link", "pl", "cert", "char", "r", "mount", "file", "b", "gl", "ssl", "resource", "host", "build", "id", "f", "dl", "base", "uri", "web", "http", "nl", "sl", "service", "ll", "t", "address", "browser", "loc", "l", "open", "get", "client", "null", "URL", "ls", "ur", "ul"], "in": ["inn", "inc", "al", "is", "it", "and", "inner", "isin", "r", "din", "file", "source", "all", "bin", "i", "io", "serv", "gin", "read", "on", "from", "again", "In", "el", "sum", "body", "ic", "ins", "inside", "out", "er", "mn", "IN", "by", "ill", "n", " din", "cin", "rin", "input", "mc", "reader", "inf", "oin", "ind"], "str": ["name", "msg", "obj", "ch", "le", "exp", "tr", "p", "string", "bc", "del", "comm", "part", "expr", "char", "inner", "r", "entry", "ns", "e", "ent", "STR", "syn", "div", "err", "i", "j", "txt", "m", "comment", "sts", "cont", "coll", "arr", "br", "st", "sol", "text", "t", "chain", "l", "line", "pt", "Str", "cr", "s", "dict", "block", "fr", "list", "req", "sp", "print", "hex", "ls", "dr", "n"]}}
{"id1": "23532405", "id2": "755203", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"persist": ["remist", "remister", "remiste", "Persiste", "Persain", "insiste", "remain", "insist", "Persist", "Persister", "persain", "persiste", "insister", "persister", "insain"], "ffConfigurable": ["ffconfigURA", "ffPorturable", "ffConfigurated", "ffRequestuer", "ffconfigurate", "ffConfigurationurated", "ffconfigural", "ffConfurated", "ffPortutable", "ffLogurated", "ffConfigURA", "ffConfurable", "efConfiguring", "efConfigurate", "ffConfigured", "ffCerturable", "effCerturable", "ffConfigurationured", "uffconfiguer", "ffConfigurationURA", "effPortutable", "ffConfigural", "ffSpecural", "ffPorturer", "ffConfuer", "ffCerturing", "effCertured", "effCerturated", "ffPorturated", "effConfigutable", "efConfigural", "effPorturer", "effConfigURA", "ffCerturate", "uffConfiguer", "ffCertured", "ffConfurer", "ffconfigured", "uffConfigorable", "ffConfiguer", "uffConfiguring", "effConfigurated", "ffconfigorable", "ffSpecuring", "ffconfiguring", "ffConforable", "ffconfigurated", "efconfigurate", "ffCertURA", "uffconfiguring", "ffConfigurer", "ffCertural", "ffConfigutable", "ffConfiguring", "effConfigurable", "ffConfuring", "ffCerturated", "ffLogurable", "efconfiguring", "efconfigural", "ffConfigorable", "ffconfiguer", "uffConfigurable", "ffLogurer", "ffLogutable", "efConfigurable", "effPorturable", "ffSpecurate", "ffSpecurable", "effConfigured", "effPorturated", "ffRequestorable", "effConfigurer", "effCertURA", "ffconfigurable", "uffconfigurable", "ffRequesturable", "ffConfigurate", "ffRequesturing", "uffconfigorable", "efconfigurable", "ffConfigurationurable", "ffConfutable"], "relativePath": ["qualifiedFile", " relativeRoot", "absoluteUrl", " relativeUrl", "absoluteRoot", "absoluteFile", "absoluteDir", " relativeDir", "relativeRoot", "qualifiedDir", "absolutePath", "relativeName", " relativeName", "relDir", "relUrl", "relativeDir", "qualifiedPath", "relativeUrl", "relativeFile", "qualifiedName", "absoluteName", "relPath", " relativeFile", "relRoot"], "file": ["fp", "ile", "name", "port", "al", "auto", "link", "url", "view", "path", "le", "File", "image", "header", "full", "string", "pool", "stream", " File", "message", "memory", "issue", "entry", "lock", "e", "folder", "filename", "buffer", "log", "resource", "fil", "local", "template", "FILE", "user", "f", "project", "queue", "base", "force", "page", "command", "store", "frame", "set", "play", "class", "rule", "spec", "out", "create", "db", "table", "output", "work", "word", "dir", "to", "list", "document", "use", "handle", "format"], "is": ["bits", "im", "are", "ip", "ib", "iss", "bs", "isin", "isa", "sis", "iso", "Is", "ir", "i", "ris", "es", "IS", "xs", "fs", "bis", "its", "ic", "in", "ios", "isl", "ms", "ins", "us", "ists", "ais", "iris", " Is", "s", "isc", "js", "ires", "isi", "ls", "ist", "nis", "lis"], "os": ["bos", "obs", "ose", "Os", "ols", "bs", "ui", "si", "oS", "ox", "ds", "oz", "pos", "iso", "sys", "cos", "i", "ys", "io", "es", "OS", "mot", "osi", "fs", "ot", "oa", "ops", "ios", "ms", "us", "o", "des", "oses", "los", "oss", " Os", "ls", "oos"]}}
{"id1": "9824814", "id2": "18693224", "code1": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"run": ["execute", "unit", "go", "begin", "sample", "job", "runs", "start", "Run", "build", "launch", "call", "play", "loop", "test", "un", "work", "open", "get", "running", "block", "exec", "render", "runner", "show"], "file": ["fp", "ile", "name", "port", "picture", "path", "le", "File", "image", "string", "header", "p", "handle", "pool", "stream", " File", "message", "content", "entity", "lock", "e", "download", "face", "fine", "session", "filename", "log", "resource", "io", "channel", "local", "data", "record", "FILE", "user", "error", "files", "result", "f", "handler", "base", "type", "web", "http", "page", "instance", "body", "object", "text", " FILE", "out", "binary", "angle", "upload", "rule", "class", "fast", "db", "table", "output", "get", "fe", "tree", "document", "reader", "pe", "format"], "inputStream": [" inputView", "InputPath", "inputFile", " InputFile", " InputView", "inputPath", "InputFile", "InputView", " inputFile", " InputPath", " InputStream", "InputStream", "inputView", " inputPath"], "url": ["mail", "Url", "link", "name", "server", "path", "domain", "cert", "string", "socket", "xml", "loader", "r", "u", "mount", "location", "b", "log", "ssl", "resource", "builder", "host", "email", "build", "channel", "library", "method", "id", "dl", "base", "il", "uri", "github", "web", "http", "nl", "sl", "page", "sql", "rl", "service", "str", "ll", "browser", "address", "https", "loc", "l", "open", "get", "client", "www", "URL", "document", "ls", "ur", "ul"], "beatportAccessor": ["beatportaccessOR", "beatcraftAdapter", "beatportProcessutor", "beatcraftAdaptOR", "beatphoneaccessOR", "beatcraftAdaptor", "beatphoneAccessor", "beatportProcessor", "beatcraftAccessor", "beatportProcessOR", "beatportSelecter", "beatportAccessutor", "beatportSelectior", "beatcraftAccessior", "beatportAdaptOR", "beatcraftAdaptior", "beatportaccessor", "beatcraftAccesser", "beatportSelector", "beatcraftAccessOR", "beatportAdaptor", "beatphoneAccesser", "beatportProcesser", "beatportaccessior", "beatportAccesser", "beatphoneaccessor", "beatphoneAccessutor", "beatportAdaptior", "beatportAccessOR", "beatportAccessior", "beatphoneAccessOR", "beatportCreater", "beatportAdapter", "beatphoneaccessutor", "beatportCreatOR", "beatportSelectOR", "beatportaccesser", "beatportaccessutor", "beatportCreator", "beatportCreatutor", "beatphoneaccesser"], "sessionCookies": ["sessionCookries", "sessionPrefles", "sessioncookms", "sessionCies", "essionCookms", "sessioncookels", "Sessioncookrys", "sessionCs", "sessionCles", " sessionCookles", "sessionCookles", " sessionCookries", "sessionStries", " sessionBuffies", "sessionBuffs", "SessionCookies", "sessioncookries", " sessionBuffs", "sessioncookles", "sessionStrys", "sessionCms", " sessionBuffries", "sessioncookys", "sessionCys", "SessionCooks", "essionCookies", "sessionPrefies", "sessionCessions", "SessionCookrys", "sessionCries", "essionCopessions", "sessionCookrys", " sessioncookys", " sessionCooks", "sessionPrefrys", "sessionCels", "sessioncookies", "sessioncooks", "Sessioncookles", "essionCoples", "sessionCrys", "SessionCookles", " sessionCookys", "sessionCookels", "essionCopms", " sessioncookels", "sessionCopies", "sessionCookms", "sessionCookessions", "sessioncookessions", "essionCookles", "Sessioncookies", "sessionCooks", " sessionCookels", "essionCookessions", "Sessioncooks", "sessionCookys", "sessionCopessions", "sessionStrles", "sessioncookrys", "sessionPrefs", "sessionBuffies", "sessionStrels", "essionCopies", "sessionBuffries", " sessioncookles", "sessionCopms", " sessioncookies", "sessionCoples"], "connection": ["character", "Connection", "link", "established", "response", "cone", "conn", "version", "termination", "statement", "settings", "still", "created", "socket", "connected", "description", "message", "pointer", "entry", "internet", "connect", "database", "json", "number", "controller", "location", "network", "session", "ion", "log", "resource", "context", "channel", "close", "creation", "function", "data", "information", "reference", "translation", "record", "method", "computer", "application", "result", "c", "handler", "uri", "communication", "engine", "command", "language", "collection", "condition", "reason", "relation", "client", "con", "position", "to", "operation", "token", "document", "directory"], "contentLength": ["ontentSize", "ontentDuration", "ContentFrame", "ontentLength", "contentType", " contentFrame", "contentLen", "contentDuration", "ContentLen", "ContentLength", "ContentENGTH", "documentSize", "ontentFrame", "codeENGTH", "ContentDuration", "sizeType", " contentlength", " contentDuration", "ContentSize", " contentSize", " contentLen", "contentFrame", "Contentlength", "contentENGTH", "documentLength", "sizeSize", "documentLen", "codeLength", "codelength", " contentToken", " contentENGTH", "ontentLen", "sizeLen", "ContentType", "documentToken", "ontentToken", "sizeLength", "contentlength", "contentSize", " contentType", "ontentlength", "contentToken", "codeLen"], "size": ["name", "sent", "timeout", "cache", "amount", "news", "height", "notice", "capacity", "sample", "index", "content", "max", "number", "grow", "sized", "limit", "city", "data", "scroll", "SIZE", "zero", "done", "storage", "type", "small", "send", "sum", "scale", "body", "set", "huge", "summary", "ize", "address", "serial", "length", "total", "fee", "position", "count", "Size", "speed", "empty", "bytes", "area", "state"], "downloaded": ["New", "this", "info", "connect", "Exception", "call", "_", "https"], "status": ["name", "active", "stat", "server", "version", "process", "progress", "flag", "source", "start", "Status", "error", "id", "result", "complete", "type", "login", "mode", "wait", "scale", "service", "code", "summary", "s", "state"], "success": [" shutdown", "fail", "cc", "continue", " successes", " successful", " succeeds", "progress", " succeed", " succ", "Success", "results", "ccess", "successfully", "top", "result", "successful", " successfully", "accept", " suc", "summary", " Success", " failure", " proceed", "exist", " completion", "failed"]}}
{"id1": "15241397", "id2": "8788371", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", "DoGet", "doGET", "doPut", " doPut", "DoPut", "handlePut", "handleget", "doget", " doGET", "handleGET", "DoGET", " doget", "Doget"], "request": ["attribute", "QUEST", "server", "initial", "first", "each", "message", "current", "Request", "hello", "query", "question", "start", "context", "reference", "user", "setup", "application", "complete", "the", "report", "http", "command", "frame", "in", "address", "create", "forward", "client", "get", "position", "req", "connection", "input", "re", "reset", "transform", "quest", "document"], "response": ["sequence", "view", "server", "answer", "image", "resp", "version", "xml", "description", "message", "content", "json", "success", "network", "session", "ve", "resource", "context", "next", "respond", "application", "result", "fire", "exit", "res", "report", "send", "http", "site", "page", "status", "form", "onse", "frame", "Response", "body", "service", "object", "console", "write", "output", "position", "block", "connection", "reset", "ce", "reply", "print", "document"], "rewrittenQueryString": ["rewartedQueryString", "rewrittenQustring", "rewrittenURLStr", "rewrittenRequestString", "rewrittenCurrentStr", "rewrittenHeaderstring", "rewartedHeaderString", "rewwrittenqueryStr", "rewrittenURLString", "rewartedQueryStream", "rewrittenQuestionStr", "rewwrittenQueryStr", "rewrittenURLStream", "rewartedHeaderStream", "rewrittenHeaderStream", "rewrittenQuerystring", "rewartedQuerystring", "rewrittenqueryStream", "rewliedQueryStream", "rewrittenURLstring", "rewwrittenQueryString", "rewrittenQueryStream", "rewrittenquerystring", "rewrittenCurrentString", "rewliedqueryStr", "rewwrittenqueryString", "rewartedHeaderStr", "rewrittenRequestStr", "rewrittenQueryQuery", "rewrittenQuStr", "rewrittenQuestionString", "rewrittenQuString", "rewartedQueryStr", "rewrittenqueryQuery", "rewartedHeaderstring", "rewliedqueryString", "rewrittenQueryStr", "rewliedQueryStr", "rewwrittenqueryQuery", "rewrittenqueryString", "rewrittenqueryStr", "rewwrittenquerystring", "rewrittenQuestionStream", "rewrittenRequeststring", "rewliedqueryStream", "rewwrittenQuerystring", "rewrittenRequestQuery", "rewrittenHeaderString", "rewliedQueryString", "rewrittenCurrentQuery", "rewwrittenQueryQuery", "rewrittenCurrentstring", "rewrittenQuStream", "rewrittenHeaderStr"], "rewrittenUrl": ["rewrapedUrl", "rewrotePosition", "rewwrittenLink", "rewrapedURL", "rewrittenPosition", "rewwrittenPort", "RewrittenLink", "rewriddenURL", "rewittenurl", "rewittenURL", "rewadjustedURL", "RewwrittenUrl", "rewriterUrl", "rewwrittenUrl", "rewroteurl", "rewriddenUrl", "rewwrittenUr", "rewwrittenPosition", "rewriterUr", "rewedString", "rewrapedUr", "RewrittenURL", "rewriddenPosition", "rewrittenString", "rewriddenUr", "rewrittenLink", "rewrittenURL", "rewrownPosition", "rewroteLink", "rewedUr", "rewadjustedPort", "rewriteurl", "rewrapedPort", "rewedUrl", "rewrownUrl", "RewrittenPosition", "rewriteURL", "rewrownURL", "rewriterURL", "rewwrittenURL", "rewedURL", "rewadjustedUr", "RewrittenString", "RewwrittenString", "rewartedURL", "rewartedPosition", "rewadjustedUrl", "RewrittenPort", "RewrittenUr", "rewriteUr", "rewwrittenString", "rewriterString", "rewartedurl", "rewittenLink", "Rewwrittenurl", "RewrittenUrl", "rewriteUrl", "rewartedUr", "rewittenUrl", "RewwrittenPosition", "rewroteURL", "RewwrittenPort", "Rewrittenurl", "rewartedUrl", "rewrittenurl", "RewwrittenLink", "rewrittenUr", "rewrittenPort", "rewwrittenurl", "RewwrittenURL", "rewrownUr", "rewroteUrl", "rewroteUr", "RewwrittenUr"], "httpURLConnection": ["httpFileApplication", " httpUrlConnection", "HttpHTTPConfiguration", "httpFileConnection", "httpFileConn", " httpURLConnect", "httpHTTPConn", "ttpURLControl", "httpUrlConnect", "ttpUrlControl", "HttpHTTPApplication", "httpHTTPControl", "httpUrlconnection", "ttpUrlApplication", " httpUrlConnect", "ttpURLconnection", "httpUrlControl", "HttpHTTPConnect", "httpHTTPconnection", "httpFileConnect", "httpSRconnection", "httpRLApplication", "ttpURLConn", "HttpUrlConnect", "httpMLConnect", "httpURLconnection", "httpRLconnection", "HttpHTTPconnection", "ttpURLConnection", "httpRLConnection", " httpURLApplication", " httpUrlconnection", "httpURLApplication", "httpUrlConnection", "httpUrlConn", " httpUrlApplication", "ttpUrlConnect", "httpMLConnection", "httpSRConnect", "ttpUrlConn", "ttpURLConnect", "HttpURLConfiguration", "httpURLConfiguration", "ttpUrlconnection", "HttpURLConnection", "httpHTTPConnect", "HttpURLConnect", "HttpUrlConnection", " httpURLconnection", "httpURLConnect", "httpHTTPApplication", "httpHTTPConnection", "httpURLControl", "httpMLApplication", "httpHTTPConfiguration", "httpSRApplication", "ttpUrlConnection", "HttpURLApplication", "HttpUrlconnection", "httpSRControl", "httpUrlApplication", "httpSRConfiguration", "httpMLconnection", "httpRLConnect", "httpUrlConfiguration", "HttpURLconnection", "HttpHTTPConnection", "httpURLConn", "httpSRConnection", "ttpURLApplication"], "header": ["port", "attribute", "option", "metadata", "ter", "init", "head", "version", "state", "part", "operator", "info", "device", "shift", "title", "detail", "layer", "argument", "event", "query", "Header", "variable", "holder", "buffer", "h", "padding", "user", "comment", "handler", "meta", "page", "status", "peer", "tag", "feature", "prefix", "heading", "hash", "check", "rule", "er", "zone", "address", "relation", "component", "client", "section", "line", "term", "policy", "block", "core", "field", "headers", "token", "filter", "dr", "hidden", "wrapper", "column", "handle", "format"], "value": ["attribute", "name", "sequence", "unit", "server", "ue", "key", "version", "string", "description", "v", "message", "sample", "current", "entry", "content", "job", "expression", "json", "label", "values", "hello", "property", "val", "email", "data", "record", "default", "password", "example", "Value", "sv", "comment", "see", "save", "vector", "instance", "python", "hash", "language", "text", "element", "zone", "create", "address", "test", "des", "VALUE", "field", "pair", "format"], "inputStream": ["InputThread", " inputSteam", "InputView", "outputLoop", " inputLoop", " inputstream", "outputWindow", "inputWindow", "InputStream", "inputView", "outputView", "errorstream", "inputSteam", "inputstream", "outputstream", "errorSteam", " inputView", "inputThread", "errorStream", "outputThread", "errorWindow", "outputSteam", " inputThread", "inputLoop", "InputLoop", " inputWindow"], "outputStream": ["displaySteam", " outputLength", "outputLength", " outputstream", "OutputForm", "responseSteam", " outputSteam", "outputForm", "responseLength", "OutputStream", "OutputLength", "inputView", "responseForm", "outputView", "displayView", "OutputSteam", "inputSteam", "displayStream", "inputstream", "outputstream", "displaystream", " outputView", "outputSteam", " outputForm", "responseStream"]}}
{"id1": "22560224", "id2": "22411381", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"hashStringMD5": [" hashBytesMT0", " hashStringMD1", " hashBytesMT1", " hashBytesMD5", " hashStringSHA1", " hashStringMD0", " hashStringMT0", " hashBytesMT5", " hashStringSM5", " hashStringSHA5", " hashBytesMD1", " hashStringMDHash", " hashStringMT5", " hashStringSHA0", " hashBytesMDHash", " hashBytesMD0", " hashStringSMHash", " hashStringSHAHash", " hashBytesMTHash", " hashStringSM0", " hashStringMT1", " hashStringSM1", " hashStringMTHash"], "string": ["name", "sequence", "array", "char", "strings", "v", "message", "content", "value", "number", "file", "source", "buffer", "filename", "host", "function", "data", "password", "result", "comment", "space", "setting", "site", "sql", "prefix", "object", "service", "str", "text", "ring", "spec", "address", "test", "word", "null", "s", "list", "input", "ident", "print", "format"], "md": ["sm", "amd", " MD", "dr", "and", "mt", "cd", "mb", "MD", "add", "nt", "dm", "dh", "mm", "der", "od", "cmd", "grad", "hd", "ind", "bd", "de", "alg", "sd", "mod", "ad", "di", "ld", "m", "det", " Md", "mode", "down", "Cmd", "cond", "red", "ms", "desc", "mn", "d", "nd", "dir", "mand", "dist", "dd", "mc", "pdf", "mk", "df", "pd"], "byteData": ["ByteBytes", "componentData", "byteParts", "byteForm", " ByteBuffer", "ByteDat", "ByteBuffer", "ByteParts", "byteLens", " ByteLens", " byteParts", "wordData", "bytedata", "displayDo", "nodeLens", " byteCount", "ByteDo", "byteCount", "phraseBytes", " bytedata", "componentBytes", "phraseDo", "viewData", "chardata", " byteBuffer", "phraseDat", "displayData", "viewDo", "seeLens", "seeData", " ByteData", "charData", "ByteData", "displaydata", "phraseData", "seeForm", "componentBuffer", "helloData", "charDATA", "byteDATA", "seeBuffer", "componentParts", " ByteForm", "helloBytes", "byteDat", " byteDATA", "viewdata", "helloDat", " byteDo", "nodeForm", "worddata", "nodeBuffer", " byteBytes", "helloDo", "wordDATA", "byteBytes", "byteBuffer", "viewCount", "displayCount", "byteDo", "nodeData"], "sb": ["erb", "bg", "alph", "ib", "ws", "sq", "soc", "shell", "bs", "cb", "sth", "sh", "mb", "sa", "bh", "src", "nb", "lb", "b", "ssl", "bsp", "bb", "sg", "sam", "sw", "sv", "eb", "sync", "bash", "web", "gb", "bf", "bj", "sf", "kb", "pb", "bt", "sc", "rb", "SB", "zb", "sp", "xb"], "i": ["ix", "im", "cgi", "phi", "ui", "ex", "v", "hi", "info", "ski", "gu", "io", "ci", "multi", "di", "uri", "kj", "ic", "set", "ity", "in", "ei", "qi", "I", "list", "my", "ii", "name", "si", "series", "iu", "point", "xi", "m", "ki", "remote", "ip", "ri", "span", "this", "g", "cli", "json", "\u0438", "err", "me", "zi", "conv", "id", "batch", "base", "c", "q", "y", "ij", "chain", "history", "o", "ai", "z", "ie", "yi", "print", "bi", "init", "oi", "any", "mi", "it", "gi", "ji", "ini", "ti", "j", "iy", "us", "er", "client", "pi", "iq", "li"], "hexString": ["pexString", " hexScreen", "alphaStr", "hexNumber", " hexBuffer", "serialStr", "hexSite", " hexNumber", "serialString", "sexList", "alphaScreen", "expNumber", "expSet", "expBuffer", "sexStatement", "sexString", "viewSet", "exSocket", "hexList", "pexList", " hexSite", "httpSite", "viewBuffer", "hexScreen", "hexSocket", "exText", "exString", "alphaString", "expString", "pexSocket", "exBuffer", "viewString", "httpString", "exStatement", "exList", "serialBuffer", "pexStatement", "hexBuffer", "hexText", "serialText", "httpScreen", "viewNumber", "hexSet", " hexText", "httpStr", " hexSet", " hexStr", "sexSocket", "exStr", "hexStr", "alphaSite", "hexStatement"], "hex": ["zh", "xf", "hl", "html", "comp", "hp", "ip", "none", " ex", "exp", "full", "tx", "x", "tex", "aux", "char", "def", "handle", "cmp", "sh", "rex", "ex", "hi", "json", "hello", "lit", "ph", "h", "prop", "sex", "hz", "ext", "dump", "hw", " Hex", "sv", "cont", "oct", "he", "com", "form", "pex", "hash", "buff", "des", "rh", "term", " sex", "cat", "print", "raw"]}}
{"id1": "16623181", "id2": "20851065", "code1": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"srcDir": ["srcRel", " srcdir", "sourceRel", "sitDirectory", "sbDir", "sitdir", " srcDirectory", "sbRel", "sbDirectory", "rcdir", "srcPath", "srcdir", " srcRel", "rcPath", "sourceDir", "sbPath", "rcDirectory", "rcDir", "sourceDirectory", " srcPath", "sourcePath", "sitDir", "sitPath", "srcDirectory"], "dstDir": [" dndDir", "destDirectory", "ddsir", "ddsDir", " dotdir", "ddsdir", " dnddir", "ddestdir", " dotDir", "dotDir", " dndFile", "dstir", "ddsFile", "dndDirectory", " dstdir", " dstDirectory", "ddestDirectory", "dstdir", "ddestFile", "dndir", " dotFile", "dstDirectory", "destFile", " dstir", "dnddir", "ddestDir", "dstFile", "dotFile", "dndFile", "dndDir", "destDir", "dotir", "dotdir", " dstFile", " dotir", "destdir", " dndDirectory"], "srcFiles": ["sourceFile", "sourceResources", "rcResources", "rcFiles", "rcFile", "srcResources", " srcResources", "srcFile", "sourcefiles", " srcfiles", "rcfiles", " srcFile", "srcfiles", "sourceFiles"], "f": ["fp", "name", "xf", "rf", "tf", "exp", "p", "full", "part", "fm", "g", "v", "a", "fo", "r", "F", "w", "e", "perm", "file", "b", "i", "h", "k", "fx", "j", "fc", "m", "c", "fs", "fi", "fd", "elf", "good", "bf", "y", "lf", "fl", "sf", "t", "ref", "o", "d", "cf", "l", "dir", "fe", "s", "fr", "fac", "alf", "z", "fb", "n", "col"], "srcChannel": [" srcClient", "rxchannel", "srcConnection", "rxButton", "rcchannel", "sourcePanel", " srcPanel", "srcchannel", "sslChannel", "rxChannel", "rcCommand", "srConnection", "sourceChannel", "srcBuffer", "rcClient", " srcCommand", "srcCh", "sourcechannel", " srcChan", " srcBuffer", "sourceClient", "sslBuffer", "srcCommand", "rcCh", "rcChannel", "srcButton", "srcPanel", " srcConnection", "rcBuffer", " srcCh", "sourceBuffer", "srcClient", "rxPanel", "srCommand", "sslChan", "sourceChan", "sourceButton", " srcButton", "sslCh", "srClient", "srcChan", "rcChan", "srChannel", "rcConnection", " srcchannel"], "dstChannel": ["Destchannel", "destChan", "dustComponent", "dblCategory", "dblConnection", "dstConnection", "ddestchannel", "dotCategory", "dblChannel", "DotChan", " dstConnector", "dstChan", "dstConnector", " destChannel", "DstChan", "destComponent", "destchannel", "dotConnection", "dustChan", "dstCategory", "DestConnection", "dstComponent", "ddestConnector", "dotchannel", "DestChan", "ddestCategory", "DotCategory", "DstChannel", "dstchannel", " destConnector", "ddestChan", "DotChannel", "dustChannel", "ddestComponent", "dblChan", "DstCategory", "dotChan", "DotConnection", " dstComponent", "DstConnection", "dustConnector", " destChan", "destConnection", " destComponent", "destChannel", "dotChannel", "ddestConnection", "DestChannel", "ddestChannel", "destConnector", " dstChan", "Dstchannel"], "buffer": ["attribute", "sequence", "timeout", "cache", "shape", "header", "char", "document", "message", "memory", "sample", "stack", "database", "temp", "number", "event", "grow", "source", "variable", "resource", "context", "channel", "buf", "Buffer", "function", "data", "template", "scroll", "reference", "library", "button", "result", "queue", "batch", "comment", "note", "base", "command", "frame", "pause", "summary", "chain", "buff", "binary", "history", "address", "phrase", "rule", "length", "table", "output", "total", "iter", "ob", "block", "position", "hold", "null", "re", "screen", "reset", "print", "filter", "window"], "nr": ["ni", "radius", "obs", "ln", "tr", "nm", "our", "uj", "attr", "adr", "ocr", "hr", "nw", " NR", "eno", "r", "rand", "rr", "sr", "nb", "nn", "ns", "number", "ng", "wr", "arr", "sys", "byter", "tn", "np", "next", "inter", "ptr", "nor", "num", "Ni", "nl", " ni", "ctr", "nc", "nv", "bj", "br", "NR", "nut", "nie", "vr", "nir", "nz", "out", "no", "rw", "usr", "gr", "iter", "mr", "rb", "norm", "sim", "n", "kr", "addr"]}}
{"id1": "2936678", "id2": "14733078", "code1": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 1, "substitutes": {"getUniqueKey": ["getRandomkey", "getNewString", "getuniqueKey", " getUniquekey", "getNewKey", "getuniqueId", " getUniqueId", "getuniquekey", "getUniqueString", "getUniqueId", "getNewkey", "getRandomId", "getRandomString", "getuniqueString", "getNewId", " getRandomKey", "getUniquekey", " getRandomId", " getRandomString", "getRandomKey", " getRandomkey", " getUniqueString"], "digest": [" Digest", "integse", "Digest", "integest", "contest", "feedest", " digity", " Diggest", "contested", " digested", "contity", "Digester", " Digse", "contests", "digity", "validest", " DigEST", "Diggest", "displayested", "diggest", "validests", "digse", "Digist", "digests", "feedEST", "displayEST", "displayest", "validested", "displayester", "integEST", "digested", "Digse", " digester", "feedist", " digests", " digEST", "digEST", "validity", "DigEST", "digester", "digist", "integgest", "displayist", "feedested", "Digested"], "md": ["sm", "magic", "dig", "mt", "wd", "cd", "mb", "MD", "add", "dm", "dh", "ds", "mm", "der", "od", "cmd", "grad", "hd", "ind", "bd", "de", "sd", "mod", "ad", "di", "ld", "m", "det", "mark", "pdf", "fd", "cond", "mp", "rm", "bf", "pm", "mg", "red", "ms", "mn", "d", "nd", "ma", "pt", "mand", "dd", "dn", "mc", "td", "dr", "mk", "df", "pd"], "timeVal": [" timeValue", "timeval", "imePref", "TimeValue", "TimeDef", " timePref", "timePref", "TimeVal", "imeValue", "timeValue", "timeDef", " timeDef", "TimePref", " timeval", "imeval", "imeDef", "imeVal", "Timeval"], "localHost": ["realHost", "localPort", "localAddress", "locAddress", "localhost", "locHost", "realGuest", "localValue", "LocalValue", "realAddress", "Localhost", " localGuest", "locValue", "LocalPort", "locPort", " localAddress", "LocalAddress", "lochost", " localValue", " localPort", "localGuest", "LocalHost", "realPort", "locGuest", " localhost"], "randVal": ["randInt", "randomInt", "randomValue", "RandVal", "ndVal", "RandValue", "ndValue", "randomval", " randval", " randStr", "ndInt", "randomVal", "ndval", "randStr", " randValue", "Randval", " randInt", "randval", "randValue", "RandStr", "randomStr"], "val": ["al", "msg", "obj", "aud", "p", "vol", "tx", "it", "aval", "def", "ret", "v", "oval", "value", "grad", "sel", "values", "div", "Val", "buf", "mod", "data", "cal", "result", "Value", "res", "VAL", "reg", "sl", "valid", "ival", "rol", "alpha", "item", "test", "vals", "vt", "ctx", "pt", " Val", "eval", "ind"]}}
{"id1": "6906419", "id2": "7044685", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["encryptionPass", "encryptedPass", "encryptionpassword", "encryptionPassword", "decryptedPassword", "encryptPass", "decryptpassword", "encryptpassword", "encryptedPassword", "encryptString", "enccryptpassword", "decryptedString", "decryptPass", "enccryptString", "decryptString", "encryptionString", "decryptedPass", "encryptedpassword", "enccryptPassword", "decryptPassword", "decryptedpassword", "enccryptPass", "encryptedString"], "password": ["attribute", "name", "key", "string", "pattern", "auth", "wd", "description", "wordpress", "message", "database", "value", "hello", "Password", "email", "data", "padding", "default", "user", "login", "sword", "command", "prefix", "text", "address", "phrase", "word", "shadow", "input", "reset", "pass", "token", "print", "username", "secret"], "digest": ["Digest", "minester", "dester", "decse", "persist", "persest", "hashester", "minested", "dest", " digested", "Digester", "persester", "hashse", "minest", "hashest", "digse", "Digist", " digse", "decested", "dse", "digested", "Digse", " digester", "persested", " digEST", "digEST", "hashEST", "DigEST", "digester", "decester", "digist", "dested", "decest", "minist", "Digested"], "hash": ["attribute", "cache", "where", "html", "array", "dig", "height", "have", "sh", "memory", "shift", "mac", "square", "hist", "all", "query", "alt", "h", "her", "here", "stock", "host", "score", "hz", "ash", "match", "map", "esh", "hed", "search", "Hash", "ah", "report", "sum", "ashes", "check", "mask", "address", "history", "test", "rh", "table", "total", "share", "block", "hex", "print", "filter", "has", "oh", "handle", "sha"], "buf": ["printf", "msg", "cap", "bg", "alph", "cv", "bc", "cb", "forge", "pool", "mb", "bh", "foo", "fam", "nb", "cmd", "b", "buffer", "agg", "etc", "np", "func", "Buffer", "uf", "tmp", "conv", "bar", "box", "queue", "txt", "batch", "bu", "hung", "mu", "br", "font", "img", "bag", "Buff", "buff", "bo", "usr", "pb", "vec", "pkg", "db", "cf", "ob", "block", "rb", "fb", "window", "var", "off"], "i": ["ix", "bi", "im", "ip", "init", "key", "go", "ri", "is", "it", "x", "mi", "gi", "phi", "ui", "ji", "si", "v", "a", "ini", "ex", "g", "info", "hi", "major", "u", "e", "iu", "\u0438", "json", "ind", "cli", "b", "ski", "point", "exp", "ti", "ci", "io", "me", "zi", "multi", "j", "di", "conv", "id", "xi", "f", "m", "c", "uri", "sim", "q", "y", "ei", "in", "ic", "slice", "qi", "t", "oi", "get", "ai", "I", "n", "to", "ie", "my", "pi", "print", "iq", "index", "ii", "li"], "halfbyte": ["leftbuffer", "phybytes", "quarterchar", "leftnode", " halfnode", " halfpiece", "halfword", "Halfword", "Halfchar", "Halfnode", "Halfbuffer", "phypiece", "quarterword", "quarterpixel", "halfpair", "halfchannel", "quarterpair", "leftbyte", " halfword", "Halfchannel", "halflen", " halfpair", "Halfbytes", "quarterbyte", "quarterchannel", " halfchar", "quarterletter", "phypixel", "halfpage", "phybyte", " halfcoin", "phylen", " halfletter", "leftchar", "Halfpage", "halfbuffer", " halfbuffer", "quarterlen", "halfcoin", "halfpixel", "Halfbyte", " halfbytes", " halfpage", "Halfletter", "Halfpiece", "quartercoin", "phypair", "Halfpixel", "halfpiece", " halfpixel", "halfletter", " halfchannel", "quarterpage", "halfchar", " halflen", "phychar", "halfbytes", "Halfcoin", "halfnode"], "two_halfs": ["two_enthalisters", "two_ledss", "two_halfss", "two_shakess", "two_turns", "two_turni", "two_enthalsets", "two_halfisters", "two_shakes", "two_roundls", "two_ledsets", "two_parens", "two_pareni", "two_turnups", "two_halfups", "two_leds", "two_enthalss", "two_parenups", "two_enthals", "two_turnls", "two_roundi", "two_ledisters", "two_rounds", "two_shakeisters", "two_parenls", "two_roundups", "two_halfls", "two_halfi", "two_shakesets", "two_halfsets"]}}
{"id1": "13012591", "id2": "9846843", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 0, "substitutes": {"getPasswordHash": [" getPassSum", "getUserHash", "getPassHash", " getPasswordSum", "getPasswordhash", "getpasswordMac", "getUserMac", "getPasswordMac", "getPasswordSum", " getPassHash", "getUserSum", "getPasshash", "getpasswordHash", "getpasswordhash", " getPasswordMac", " getPassMac", "getUserhash", "getpasswordSum", " getPasswordhash", " getPasshash", "getPassSum", "getPassMac"], "password": ["attribute", "name", "key", "string", "pattern", "wd", "description", "message", "entry", "content", "w", "database", "value", "hello", "Password", " Password", "email", "data", "padding", "user", "login", "sword", "command", "prefix", "text", "address", "phrase", "word", "shadow", "input", "reset", "pass", "token", "username", "secret", "raw"], "md": ["sm", "metadata", "df", "and", " mm", "cd", "MD", "add", "dm", "dh", "mo", "mm", "e", "der", "cmd", "od", "ind", "ent", " sd", "bd", "grad", "mac", "sd", "mod", " mo", "di", "pd", "ld", "m", "det", "med", " Md", " dd", " mc", "mp", "rm", "ms", "mg", " ms", "mem", "red", "mn", "d", "gr", "nd", "dir", "mand", "dd", "mc", "mt", "mk", " ma", "hd"], "hash": ["style", "ashed", "where", "cache", "html", "array", "oh", "dig", "used", "char", "sh", "bh", "sample", "shift", "stack", "mac", "square", "number", "all", "h", "here", "host", "match", "ash", "hz", "map", "box", "esh", "search", "Hash", "report", "sum", "color", "ashes", "mask", "check", "address", "test", "table", "total", "block", "hex", "score", "filter", "print", "has", "index", "handle", "sha"], "buf": ["printf", "bn", "msg", "cap", "bg", "alph", "cv", "bc", "aux", "bs", "cb", "forge", "bytes", "bh", "bl", "foo", "fam", "nb", "cmd", "b", "bed", "buffer", "agg", "Buffer", "uf", "next", "tmp", "bar", "ov", "box", "bp", "av", "txt", "abs", "bu", "hung", "mu", "br", "cur", "bag", "img", "Buff", "buff", "bo", "proc", "pb", "db", "pkg", "cf", "ob", "block", "rb", "cat", "var"], "i": ["ix", "im", "bi", "ip", "key", "ri", "is", "mi", "x", "it", "phi", "gi", "ui", "ji", "si", "v", "a", "ini", "hi", "ex", "u", "e", "cli", "\u0438", "iu", "json", "ski", "gu", "ti", "ci", "j", "multi", "di", "xi", "m", "c", "iq", "uri", "ii", "q", "y", "ei", "ic", "in", "ims", "ms", "qi", "ogi", "chain", "us", "ki", "o", "ai", "I", "n", "z", "my", "pi", "yi", "sim", "index", "ind", "li"]}}
{"id1": "2668853", "id2": "8452134", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFile2Files", "decodeFileAsFile", "decodeFileTOString", "decodeFileToString", "decodeFileTOFile", "decodeFileAsFiles", "decodeFileToFiles", "decodeFileToPage", "decodeFilesToFiles", "decodeFilesToFile", "decodeFileTOPage", "decodeFiles2Files", "decodeFiles2Page", "decodeFilesToPage", "decodeFileAsString", "decodeFileTOFiles", "decodeFile2File", "decodeFileAsPage", "decodeFiles2File", "decodeFile2Page", "decodeFilesToString", "decodeFiles2String", "decodeFile2String"], "infile": ["inFile", "inputwhere", "outFile", "InFile", " inwhere", "innfile", "inputfilename", "inwhere", "inbase", " inbase", "Inbase", "innwhere", "infilename", "inpath", "innbase", "Inpath", "outbase", "innfilename", "Infile", "outpath", "inputfile", "inputpath", "inputFile", "inputbase", " infilename"], "outfile": ["inFile", "Outfilename", "outFile", "listfile", "infp", " outFile", "tofp", "listfilename", "listFile", "Outfile", "infilename", "toFile", "inpath", "tofilename", " outpath", "Outpath", "outfp", "outfilename", "outpath", "listfp", " outfilename", "OutFile", "tofile"], "in": ["inn", "im", "al", "inc", "pin", "conn", "init", "image", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "io", "gin", "user", "on", "from", "In", "form", "amin", "ins", "inside", "en", "IN", "ro", "o", "by", "get", "iter", "con", "ai", "n", " din", "cin", "rin", "input", "re", "inf", "oin", "ind"], "out": ["ln", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "w", "aos", "outer", "flush", "ent", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "sequence", "cache", "view", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "bone", "variable", "pad", "black", "buf", "Buffer", "append", "template", "bar", "padding", "zero", "available", "password", "note", "batch", "base", "comment", "queue", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "length", "block", "tree", "row", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "shift", "run", "connect", "through", "query", "start", "i", "push", "close", "give", "data", "send", "wait", "q", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "iter", "count", "seek", "end", "skip", "need", "readable", "input", "size", "print", "reader", "index", "pe", "Read"], "success": [" convergence", "response", "town", " okay", "first", "same", "continue", "master", "support", " successes", "commit", " successful", "growth", "photo", " succeeds", "safe", " succeed", "submit", " succ", "second", "snap", "Success", "city", "close", "ccess", "successfully", "error", "warning", "ceed", "result", "successful", "complete", " successfully", "security", "accept", "crit", "sufficient", "done", "cont", "release", "democracy", "valid", "status", "good", "surv", "danger", "green", "summary", " Success", "please", "ok", " failure", "setup", "unity", "ratulations", " succeeded", "top", "cess", "primary", "exist"]}}
{"id1": "3958807", "id2": "13499897", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadBixedStream", "loadBinaryInput", "loadBignedStream", "loadEmbinaryStream", "loadEmbbinaryFile", "loadBbinaryInput", "loadEmbbinaryInput", "loadEmbinaryFile", "loadBignedFile", "loadBixedInput", "loadEmbbinaryStreamer", "loadBixedStreamer", "loadBbinaryFile", "loadBixedFile", "loadBignedStreamer", "loadEmbinaryStreamer", "loadEmbbinaryStream", "loadEmbinaryInput", "loadBinaryStreamer", "loadBbinaryStream", "loadBbinaryStreamer", "loadBignedInput", "loadBinaryFile"], "streamName": ["streamPath", "resourceName", "recordname", " streamHandle", " streamType", "streamname", "stringName", "stringType", "longPath", "filePath", "stringNAME", "StreamNAME", "streamType", "fileNAME", " streamname", "resourceType", "recordName", "recordHandle", "streamHandle", "StreamName", "resourceNAME", "longName", "Streamname", " streamPath", " streamNAME", "streamNAME", "fileName", "recordNAME", "StreamHandle", "longNAME"], "streamToLoad": ["stringWillAdd", " stream2Read", " stream2Use", "streamtoAdd", " streamToload", "streamTOLoad", " streamToUse", "streamTOUse", "stringToLoad", "streamToUse", "streamToload", "streamWillload", "streamWillLoad", "streamTORead", "streamTOAdd", "streamToRead", "streamtoLoad", "stream2Load", "streamToAdd", " stream2Load", "streamtoload", "stringWillLoad", "stream2Read", "stream2load", " streamWillload", "stringToAdd", "streamWillAdd", "streamTOload", " streamWillLoad", " stream2load", "stringWillload", "stream2Use", "stringToload", " streamToRead"], "sz": ["insiz", "siz", "Sch", "insz", "rsz", "Sz", "Sld", " sch", " sld", " sze", "insze", "rsiz", "insch", "rsld", "sld", " siz", "sze", "rsze", "sch", "Sze", "Siz"], "req": ["comp", "sq", "quick", "attr", "qt", "comm", "inv", "org", "seq", "rx", "cmd", "Request", "query", "wx", "qq", "res", "pas", "q", "http", "wcs", "Requ", "cur", "urg", "jp", "usr", "proc", "pkg", "ctx", "client", "gr", "request", "dq", "requ", "fr", "qs", "require", "quest"], "resp": ["msg", "response", "obj", "rend", "html", "conn", "exp", "RES", "p", "soc", "cmp", "vol", "comm", "inv", "ret", "rec", "nt", "r", "content", "dis", "cl", "esp", "cmd", "wr", "pos", "sys", "serv", "wx", "Res", "respond", "Resp", "respons", "conv", "result", "fs", "res", "rep", "report", "pas", "http", "status", "body", "Response", "sol", "https", "jp", "rel", "proc", "output", "gr", "client", "os", "request", "re", "fr", "compl", "sp", " Resp"], "out": [" outs", "utt", "obj", "ws", "vol", "ts", "bs", "Out", "ex", "nt", "w", "aos", "sys", "cos", "log", "gs", "io", "conv", "gt", "yout", "sw", "ou", "res", "ot", "in", "ins", "t", "us", "o", "output", "client", "os", "null", "to", "oss", "co", "outs", "OUT", "net", "n", "cn"], "bos": ["bi", "bits", "obs", "ws", "ols", "ts", "bs", "ods", "banks", "tes", "uts", "bh", "boards", "mos", "aos", "bat", "oops", "sys", "bin", "ys", "fits", "base", "oids", "bis", "bas", "ios", "ubis", "bones", "buff", "nos", "bo", "bes", "des", "los", "dos", "os", "eros", "jas", "oss", "js", "bles", "BS", "bot", "bytes", "oos"]}}
{"id1": "23291583", "id2": "19147281", "code1": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"fetchUrl": ["fetchurl", "fectURL", "FetchString", "faultUrl", "fetchString", "Fetchurl", "FetchURL", "faultString", "fectUrl", "fectString", "faultURL", "faulturl", "FetchUrl", "fetchURL", "fecturl"], "urlString": [" urlRest", "urlStr", "lName", "sslSeries", "lSeries", " urlStr", "lString", "uristring", "uriString", "UrlRest", "urlName", "lStr", " urlSeries", "sslString", "sslStr", "UrlString", "urlstring", "Urlstring", "urlSeries", "sslName", "uriRest", " urlstring", "urlRest", " urlName"], "outException": ["outExample", "outTransaction", "outEvent", "OUTExample", "OutException", "cnException", "OUTEvent", "OUTTransaction", " outExample", " outEvent", " OUTTransaction", "cnExample", "inAddress", "inExample", " outCondition", "OutCondition", "cnError", " outTransaction", "OutEvent", "OutAddress", "inError", "outCondition", " OUTExample", " OUTEvent", "inException", "outAddress", "cnEvent", " OUTException", "OUTError", "inEvent", "outError", "OUTException", " outAddress", "inCondition"], "url": ["mail", "Url", "link", "hl", "hub", "pl", "cert", "org", "char", "xml", "bl", "r", "job", "u", "download", "mount", "dll", "b", "log", "gl", "ssl", "host", "channel", "build", "email", "bel", "lt", "dl", "il", "base", "uri", "github", "web", "http", "sl", "nl", "el", "rl", "impl", "str", "ll", "address", "https", "rel", "pkg", "l", "get", "www", "URL", "ml", "ls", "ur", "ul"], "is": ["tis", "im", "ls", "bits", "ri", "ip", "init", "ib", "ois", "inst", "iss", "still", "bs", "isin", "mos", "isa", "dis", "sis", "iso", "sys", "ir", "i", "isf", "Is", "ris", "serv", "ils", "es", "IS", "ys", "xs", "abs", "fs", "res", "bis", "its", "in", "ios", "ims", "ms", "isl", "ists", "ais", "ism", "eps", "vis", "was", "os", "s", "isc", "oss", "js", "ires", "isi", "sim", "has", "lis"], "inc": ["inn", "ch", "exp", "init", "include", "incre", "pp", "ln", "ec", "ac", "occ", "const", "cc", "rec", "enc", "add", "integ", "acc", "dec", "min", "err", "pad", "ipl", "zero", "num", "step", "c", "Inc", "ctr", "in", "ins", "INC", "asc", "dc", "inf", "exc", "frac", "sc", "iter", "rc", "count", "width", "isc", "index", "ind"], "curr": ["curl", " curR", "Curn", " currc", "Currs", " curmr", "Curl", "currs", "grrs", " currid", "urr", "constrs", "Curr", " curp", "corrd", "contr", "curn", "rcr", "Curp", "contl", "currid", " currs", "rcl", "chp", "Currb", "currd", "contrd", "grr", "corr", "grp", "rcmr", " curl", " currd", "grrc", "catrid", " curn", "corrb", "urrc", "constrid", "Currc", "currb", " currb", "contrc", "contp", "catr", "Curmr", "chn", "chr", "CurR", "constr", "chR", "curmr", "curR", "corn", "curp", "catrs", "currc", "corp", "Currid", "rcrs", "contn", "corl"], "result": ["sequence", "response", "cache", "answer", "Result", "true", "ret", "this", "description", "false", "master", "message", "memory", "r", "current", "repl", "rue", "value", "success", "currency", "all", "buffer", "buf", "results", "RESULTS", "next", "data", "record", "match", "tmp", "successful", "complete", "batch", "search", "res", "report", "valid", "command", "status", "page", "prefix", "cur", "text", "summary", "pre", "collection", "test", "phrase", "proc", "csv", "table", "output", "total", "term", "length", "null", "block", "list", "row", "rendered"], "n": ["name", "len", "gn", "ln", "le", "yn", "nm", "p", "g", "v", "fn", "nt", "r", "ns", "nn", "e", "ng", "number", "nr", "ren", "i", "np", "nan", "j", "nor", "num", "f", "m", "c", "el", "nl", "nc", "y", "an", "ll", "t", "en", "nu", "no", "o", "ne", "d", "un", "sn", "l", "s", "na", "z", "N", "cn"], "temp": ["tem", "orig", "tr", "EMP", "created", "tty", "v", "tc", "current", "copy", "mm", "partial", "perm", "make", "alt", "unt", "ph", "tt", "variable", "buffer", "tmp", "dat", "Temp", "mod", " Temp", "template", "tv", "ptr", " temporary", "local", "tab", "txt", "fake", "mp", "porary", "t", "create", "pre", "mem", "buff", "test", "term", "met", "pt", " tmp", "em", "tm", "emp"]}}
{"id1": "21125261", "id2": "21308543", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"test": [" evaluate", "execute", "fit", "unit", "server", "sample", "run", "train", "hello", "testing", "debug", "volt", "read", "launch", "example", " sample", "Test", "evaluate", " testing", "tests", "feature", " tests", "t", "load", "T", "show"], "is": ["tis", "are", "ri", "does", "ws", "bs", "rs", "xml", "stream", "ps", "isa", "sis", "iso", "sys", "Is", "i", "sit", "ris", "serv", "es", "IS", "xs", "fs", "its", "in", "ios", "ms", "has", "out", "us", "ais", "os", "ai", "s", "isc", "mis", "input", "isi", "ls", "as", "lis"], "byteArrayOutputStream": ["byteStringInputView", "byteArrayByteStream", "byteStreamOutputSteam", "byteStreamInputSteam", "byteStringInputSteam", "byteArrayOutputSteam", "byteArrayOutputStyle", "byteStringInputString", "byteStreamOutputStream", "byteArrayInputStyle", "byteArrayByteStyle", "byteStreamOutputStyle", "byteStreamInputForm", "byteStringOutputForm", "byteArrayApplicationForm", "byteArrayInputString", "byteArrayInputView", "byteArray4View", "byteArrayoutputString", "byteArrayInputSteam", "byteArrayByteString", "byteArrayOutputForm", "byteStreamInputStyle", "byteArrayoutputStream", "byteStringOutputView", "byteArrayOutputView", "byteArrayInputStream", "byteArrayoutputSteam", "byteArrayByteView", "byteArrayApplicationStyle", "byteStringoutputStream", "byteStringOutputSteam", "byteStringOutputString", "byteArray4Stream", "byteArrayApplicationStream", "byteStringOutputStream", "byteArrayApplicationSteam", "byteArrayByteForm", "byteArray4Steam", "byteStringInputStream", "byteArrayOutputString", "byteArray4String", "byteArrayByteSteam", "byteArrayoutputForm", "byteStreamInputStream", "byteStringoutputForm", "byteStringoutputSteam", "byteArrayInputForm", "byteStreamOutputForm", "byteStringoutputString"], "def": ["ef", "del", "cd", "DE", "ds", "dec", "pro", "json", "de", "Def", "sd", "sche", "dem", "defined", "default", "ded", "dev", "dl", "det", "crit", "dal", "conf", "Definition", "da", "md", "desc", "DEF", "d", "definition", "des", "db", "dict", "define", "decl", "df", "hd"], "se": ["sea", "ense", "sec", "SE", "le", "su", "est", "pse", "ine", "sa", "ide", "e", "ee", "sel", "so", "de", "ve", "ade", "sd", "me", "sche", "parse", "es", "be", "sed", "ses", "sem", "see", "engine", "sl", "we", "he", "te", "ge", "set", "ser", "spe", "ste", "ne", "Se", "ke", "ase", "ene", "ae", "ie", "ce", "sp", "ane", "ode", "ese", "ze", "she", "pe"], "linkId": ["linkedId", "chainIdent", " linkID", "linkedIdent", "connectionIdent", "LinkID", "chainId", "LinkId", "linkIdent", "chainID", "lineID", "linkName", "Linkid", "linkid", "lineId", "linkedID", " linkName", " linkid", "connectionId", "linkID", "LinkName", "lineName", "connectionID", "lineid"], "segmentId": ["begroupID", "segmentRef", "semissionName", "begroupName", "semissionRef", "segementID", "sementId", "sementID", "segroupById", "idegementid", "idegmentId", "idegementId", "idegementName", "semissionid", "sementid", "segroupID", "begmentById", "begmentID", "semissionId", "sementById", "idegmentRef", "segmentById", "sementName", "segementById", "segementId", "begmentId", "sementRef", "segmentName", "segmentID", "idegmentName", "segroupId", "segementRef", "segroupName", "begmentName", "begroupById", "segementid", "begroupId", "idegementRef", "segementName", "idegmentid", "segmentid"], "linkSegments": [" linkThreadgments", "linkGment", " linkBuildets", "linkGroups", "linkSegment", " linkBuildments", "linkConnectments", " linkSegables", "linkSements", " linkThreadlements", "linkConnectables", "linkFragment", "linkSegables", " linkSegets", "linkThreadroups", "linkParlements", "linkThreadments", "linkConnectlements", "linkFragroups", " linkSegment", "linkPargments", " linkSeggments", " linkBuildgments", " linkThreadroups", "linkConnectgments", " linkGgments", "linkBuildgments", "linkSeglements", " linkGroups", "linkBuildroups", " linkGment", " linkBuildables", "linkParments", "linkSeggments", "linkThreadlements", "linkSegets", "linkBuildment", " linkSeglements", "linkBuildments", " linkThreadments", "linkConnectets", " linkGments", "linkParroups", "linkGments", "linkConnectroups", "linkSegroups", "linkSeets", "linkFraggments", "linkThreadgments", " linkSegroups", "linkFragments", "linkBuildets", "linkSeables", "linkBuildables", "linkGgments"], "segments": ["velements", " sevals", "begments", "parselements", " sements", "beges", " Sements", "sevals", "sements", " Segments", "usements", "usegs", " seges", "parsements", "parsegments", "sectors", "bevals", " Sevals", "vegments", "usegins", "seges", "usegments", "segs", " segs", "megments", "megins", "segins", " segins", "vectors", "parsectors", " sectors", "bements", "megs", " selements", " Seges", "vements", "mements", "selements"], "frameProperties": ["frameParptions", "frameComrics", "framePrperties", "frameProptions", "frameProfps", "frameProrics", "frameProps", "frameProfptions", " frameProptions", " framePrps", "framePropptions", "frameComperties", " frameProrics", "frameByperties", "framePrptions", " frameProps", " frameByps", "frameParrics", "framePropps", " frameByilities", "frameComptions", "frameProfperties", "frameByps", "framePropilities", "framePrrics", " framePrperties", "frameByptions", "framePropperties", "frameProfilities", "frameByilities", " framePrptions", "frameParps", "framePrps", " frameByptions", " frameByperties", "frameComps", " frameProilities", "frameProilities", " framePrrics", "frameParperties"], "time": ["ime", "timeout", "sequence", "counter", "version", "now", "system", "x", "each", "tx", "ts", "delay", "task", "before", "message", "estamp", "distance", "TIME", "clock", "value", "second", "event", "start", "point", "date", "tt", "context", "rate", "money", "step", "year", "timer", "tim", "trace", "think", "set", "depth", "frequency", "check", "t", "slow", "Time", "duration", "etime", "times", "length", "trust", "total", "count", "speed", "size", "transform", "runtime", "window"], "vehicle": ["heroICLE", "vehogram", "vehic", "heroicle", "vehicles", " vehocity", "vericle", "survocity", "vehocity", "yardocity", "yardogram", "survendor", "venticle", "yardicle", "yardendor", "ventic", " vehICLE", "heroocity", "verocity", "ventocity", "Vehic", "Vehicles", "venticles", " vehicles", "survogram", "heroicles", "verendor", "vehendor", "verticles", "VehICLE", "survicle", "verticle", "verogram", "Vehicle", "vehICLE", "Vehocity", "vertic", "vertocity"]}}
{"id1": "3330775", "id2": "421042", "code1": "    public static JSONObject getJSONData(String url) throws JSONException {\n        JSONObject jObject = null;\n        InputStream data = null;\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        URI uri;\n        try {\n            uri = new URI(url);\n            HttpGet httpGet = new HttpGet(uri);\n            HttpResponse response = httpClient.execute(httpGet);\n            data = response.getEntity().getContent();\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader;\n            reader = new BufferedReader(new InputStreamReader(data), 8192);\n            while ((line = reader.readLine()) != null) builder.append(line);\n            reader.close();\n            jObject = (JSONObject) new JSONTokener(builder.toString()).nextValue();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return jObject;\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getJSONData": ["getJSONResponse", "loadjsonContent", "getjsonData", "loadJSONContent", "loadjsonData", "getJSONObject", "getBasicContent", "getJData", "getjsonContent", "getJResponse", "getJSONContent", "getBasicResponse", "getJContent", "loadjsonResponse", "loadJSONResponse", "getJObject", "loadJSONData", "getjsonObject", "loadjsonObject", "loadJSONObject", "getBasicData", "getjsonResponse", "getBasicObject"], "url": ["remote", "Url", "name", "util", "link", "pl", "path", "lim", "string", "pattern", "ret", "json", "file", "location", "b", "log", "i", "ssl", "host", "id", "result", "dl", "base", "web", "http", "nl", "sl", "str", "ll", "item", "address", "loc", "rel", "l", "URL", "ls", "ur", "href", "ul", "addr"], "jObject": ["jobject", "jDocument", "jpNull", " jObj", "jpObject", "jsonNull", "jData", " jAnonymous", "jsonDocument", "jsonobject", "reportDocument", "reportObject", " jobject", "jsonObject", "objDocument", "jObj", " jNull", "objData", "jpAnonymous", " jData", "jAnonymous", "jsonAnonymous", "jpobject", "jsonData", " jDocument", "jNull", "reportObj", "jsonObj", "reportData", "objObject", "objObj"], "data": ["name", "sequence", "cache", "html", "image", "string", "ata", "stream", "message", "sample", "content", "feed", "json", "value", "source", "buffer", "session", "resource", "dat", "results", "ad", "aw", "error", "media", "dev", "result", "done", "mu", "body", "details", "or", "text", "api", "no", "ne", "output", "block", "DATA", "input", "trans", "size", "window", "bytes", "area", "raw"], "httpClient": ["httpsBuilder", "ttpGet", "httpControl", "Httpclient", "httpBuilder", "httpsControl", "httpsGet", " httpBuilder", "ttpClient", "HttpClient", "httpsclient", "HttpControl", "HttpContext", "httpsContext", "httpsClient", "ttpContext", "HttpBuilder", "HttpGet", "ttpclient", "httpclient", " httpControl", "httpContext", " httpclient"], "uri": ["remote", "cp", "Url", "link", " ur", "util", "hub", "server", "origin", "ri", "domain", "path", "ip", "qu", "phi", "char", "ui", "via", "URI", "subject", "hi", "u", "source", "location", "point", "i", "resource", "archive", "host", "manager", "lu", "base", "hu", "http", "du", "range", "qi", "address", "nu", "api", "ref", "client", "iri", "term", "ilo", "connection", "URL", "pi", "ur", "directory", " URI", "uni", "uu"], "httpGet": ["htmlGet", "hGate", "htmlQuery", "httpGET", "HTTPGET", "hGet", "hGET", "httpQuery", "httpPut", "HTTPQuery", " httpQuery", "httpGate", "htmlGate", " httpPut", "HTTPPut", "hQuery", "HTTPGet", " httpGate", " httpGET", "htmlPut", "htmlGET"], "response": ["remote", "yes", "server", "answer", "image", "resp", "version", "socket", "still", "description", "message", "json", "success", "hello", "pos", "opening", "resolution", "resource", "context", "next", "respond", "result", "application", "successful", "report", "http", "page", "status", "body", "frame", "Response", "service", "object", "onse", "output", "client", "block", "connection", "request", "reply", "document"], "line": ["name", "link", "sequence", "online", "len", "ln", "key", "liner", "header", "stroke", "ine", "part", "message", "sample", "entry", "entity", "e", "label", "Line", "file", "number", "point", "log", "next", "LINE", "eline", "user", "error", "comment", "lin", "nl", "page", "status", "cell", "frame", "text", "code", "chain", "phrase", " Line", "l", "word", "block", "ice", "row", "inline", "field", "print", "column"], "builder": ["name", "ward", "alph", "building", "writer", "full", "bean", "operator", "order", "inner", "loader", "message", " builders", "board", "utils", "sb", "oster", "der", "number", "b", "ener", "buffer", "lower", "black", "parser", "build", "uf", "join", "ender", "bar", "library", "builders", "lu", "Builder", "base", "web", "trace", "language", "sf", "er", "by", "length", "atter", "built", "upper", "row", "fb", "eng", "control", "BU"], "reader": ["iterator", " readers", "util", "where", "ri", "writer", "per", "older", "reading", "inner", "stream", "loader", "message", "r", "ator", "entry", "oder", " writer", "e", "buffer", "ger", "read", "parser", "rar", "dra", "record", " read", "roller", "handler", "driver", "worker", "peer", "ner", "rl", "range", "Reader", "er", "bo", "ro", "iter", "mr", "row", "runner", "readable", "dd", "field", "river", "dr", "wrapper"]}}
{"id1": "2022160", "id2": "15645004", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"write": ["port", "execute", "link", "fit", "writer", "find", "apply", "fail", "put", "process", "commit", "copy", "flush", "w", "connect", "writ", "run", "partial", "change", "log", "network", "walk", "rite", "read", "close", "next", "append", "export", "call", "wire", "sync", "batch", "see", "written", "save", "only", "send", "wait", "patch", "scale", "store", "set", "code", "Write", "create", "output", "get", "to", "render", "end", "size", "cycle", "print", "wrote", "writing", "register", "handle", "format"], "byteBuffers": ["byteCountters", "byteNamesers", "bytesPackerers", "byteIndexerers", "ByteBuffers", "byteOffer", "byteOffters", "bytesBuffators", " byteBuffusters", "bitBuffonents", "bytebuffodes", "byteFrags", " byteNamesines", "ByteBuffERS", "bitEnters", "ByteHeadrs", "byteCounters", "byteNamesERS", " bytePackers", "byteBytesERS", "byteBytess", " bytePackusters", "bytesPackators", "bytesHeadters", "bytesHeadered", "bytesHoldters", "bytesbufflers", "byteIndexators", "bytePackators", "bytebuffainers", "bytePacklers", "byteBuffines", "ByteHeadERS", "bytebufflers", "bytebuffERS", " byteBuffels", "byteEntrs", "bytePackters", " bytePacklers", "byteBuffrys", "bytePackrs", "bytePackainers", "byteHoldiers", "byteHeader", "bytesHeaders", "bytebuffines", "byteCombonents", "byteDeflers", "byteFragers", "byteEnters", "byteOrders", "byteBuffERS", " bytebuffters", " byteNameserers", "byteBuffonents", "bytesbuffrys", "byteBytesrys", " byteBufferers", "bitBuffrs", "byteOffered", "bitBuffers", "bytesBuffters", "byteCombers", " byteNamesers", " byteBuffs", "bytesBuffer", "byteBindERS", " byteDefERS", "bytebuffers", "bytesBufflers", "bytebuffiers", "byteBuffrs", "bytesBuffered", "bytebuffusters", "bytePackers", "bytesbuffers", "bytebufferers", "byteBufferines", "byteNamesines", "byteBuffiers", " byteBuffERS", "byteBuffters", "bitBuffters", "byteHolderers", "bytesBuffrys", "byteCountERS", "byteBufferlers", "byteEntters", "byteCorners", "byteCombters", " byteBuffainers", "bytebuffters", "bytesPackers", "bytesHoldERS", "byteHeadERS", "bytePackerers", " bytebuffERS", "byteBufferters", "bytePacker", "bitEntrs", "byteBytesers", " byteDefels", "ByteHeadered", "byteBufferERS", "byteHeadrs", " byteBuffines", " byteBuffters", "bytebuffs", "byteDefels", "bytebuffered", "byteBindodes", "byteHoldERS", "bytesbuffodes", "byteBinders", "byteBufflers", "byteBuffererers", " byteDeflers", "byteCountered", "byteBufferers", "byteHoldered", "byteCornerers", "byteBindlers", " bytebuffers", "bytesbuffs", "byteOffers", "byteCorniers", "byteBufferered", " byteBuffered", "bytesBuffodes", "byteBuffodes", "bitEntonents", "ByteBuffered", " bytebuffiers", "bytebuffrys", "bytesBuffs", "byteHoldters", " bytePacks", "byteHolders", "byteOrdrs", " bytePackainers", "byteWaitERS", "byteHeadters", "bytesHolders", "byteBuffels", " bytebufferers", "bytesBufferers", "byteOrdters", "byteBuffators", "byteIndexers", "bytesHoldered", "byteOrdonents", "byteBuffainers", "bytesPackrs", " byteBufflers", "bytePackered", "byteCombrs", "bytesBuffrs", " bytePackerers", "byteWaitainers", "bytePackrys", " byteDefers", "bitEntters", "bytesBuffers", "byteIndexrs", "byteBuffusters", "byteDefers", "bytePackusters", "byteEntonents", " bytebuffered", "bytesHeader", "ByteHeaders", "byteBufferels", " bytePackERS", "byteHeaders", "byteWaiterers", "bytesBuffERS", "byteFraglers", "bytePackERS", "ByteBuffrs", "byteCornters", "byteDefERS", " byteBuffiers", "byteFragusters", " byteNamesERS", "byteWaiters", "byteBuffer", "bytePacks", "bytesbuffERS", "byteHeadered", "byteBuffs", "byteNameserers", "byteBuffered"], "m_initialOutBuffer": ["m_finalOutputBuff", "m_initialoutCache", "m_InitialOutBuff", "m_initialEndLength", "m_initialInThread", "m_firstoutBuff", "m_initialInbuffer", "m_initialOutputBuffer", "m_initialOutLength", "m_currentInChannel", "m_currentoutCache", "m_initialInQueue", "m_currentOutBuffer", "m_initialByteBuffer", "m_initialNetBuffer", "m_currentoutBuffer", "m_InitialOutLength", "m_initialoutWriter", "m_finalOutputQueue", "m_initialNetThread", "m_InitialoutLength", "m_InitialOutCache", "m_initialNetQueue", "m_finalOutBuff", "m_currentoutBuff", "m_firstoutBuffer", "m_initialCheckBuff", "m_initialoutBuffer", "m_currentInBuff", "m_initialHostBuffer", "m_currentOutQueue", "m_initialOutChannel", "m_initialOutThread", "m_initialHostBuff", "m_finalOutQueue", "m_InitialoutCache", "m_firstOutBuff", "m_initialInLength", "m_currentOutCache", "m_initialCheckBuffer", "m_InitialoutBuff", "m_initialByteBuff", "m_initialInChannel", "m_initialOutputQueue", "m_firstoutWriter", "m_initialOutCache", "m_initialoutQueue", "m_initialCheckChannel", "m_initialCheckQueue", "m_initialByteWriter", "m_initialOutputThread", "m_currentoutQueue", "m_initialoutLength", "m_initialOutWriter", "m_initialOutputBuff", "m_initialOutbuffer", "m_currentInBuffer", "m_initialInBuff", "m_currentOutBuff", "m_initialHostView", "m_initialHostbuffer", "m_initialOutBuff", "m_currentOutChannel", "m_initialEndBuffer", "m_firstOutCache", "m_initialEndBuff", "m_initialInView", "m_finalOutThread", "m_firstoutCache", "m_finalOutputThread", "m_InitialoutBuffer", "m_initialEndCache", "m_firstOutBuffer", "m_firstOutWriter", "m_initialInBuffer", "m_finalOutputBuffer", "m_initialInWriter", "m_initialInCache", "m_initialOutView", "m_initialNetBuff", "m_currentInQueue", "m_finalOutBuffer", "m_initialNetCache", "m_InitialOutBuffer", "m_initialByteCache", "m_initialOutQueue", "m_initialNetChannel", "m_initialoutBuff"], "buffer": ["sequence", "cache", "server", "stream", "container", "holder", "builder", "context", "buf", "channel", "manager", "engine", "store", "bo", "table", "iter", "block", "tree", "list", "background", "document", "directory", "url", "timeout", "pool", "message", "stack", "source", "bridge", "Buffer", "processor", "button", "timer", "thread", "address", "connection", "row", "callback", "flash", "filter", "attribute", "response", "header", "memory", "database", "layer", "profile", "template", "bar", "queue", "batch", "comment", "base", "command", "chain", "loop", "length", "output", "null", "pair", "window", "iterator", "initial", "socket", "temp", "internal", "match", "map", "page", "buff", "binary", "phrase", "empty"], "buffers": ["ufers", "offers", "rendters", "buffings", " buffors", "bufards", "combers", "buffERS", " buffters", "ufERS", "combards", "comblers", "combERS", "ufors", "ufards", "holders", "holdERS", "buffors", "offters", "holdters", "bindERS", "renders", "uflers", "bufflers", "rendERS", "bufters", "rendlers", "bindlers", "ufters", "holdings", "bufings", "bufers", "offERS", "bindters", "binders", " buffings", "offors", "bufERS", " buffERS", "buffards", "buffters", "buflers"], "result": [" resulted", "response", "cache", "group", "other", "answer", "Result", "ver", "created", "true", "continue", "ret", "description", "process", "message", "r", "current", "progress", "json", "event", "success", "make", "product", "resource", "context", "reason", "results", "next", "profile", "data", "that", "match", "user", "error", "successful", "complete", "comment", "done", "see", "search", "res", "report", "role", "valid", "we", "status", "mate", "details", "cur", "ser", "load", "relation", "test", "output", "iter", "null", "request", "re", "runner", "diff", "pair", "wrapper", "uu"], "encrypted": ["sequence", "external", "other", "created", "confirmed", "temp", "ended", "internal", "secure", "channel", "context", "checked", "password", "error", "available", "engine", "chain", "verified", "armor", "finished", "table", "locked", "options", "flash", "extra", "selected", "secret"]}}
{"id1": "13720140", "id2": "16549995", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"modifyProperty": ["modateProperty", "modifyProp", "ModifiesProp", "modateAttribute", "ModifyAttribute", "ModifiesAttribute", "modureValue", "ModifyProperty", "modifiesAttribute", "modureAttribute", "modateProp", "ModifiesProperty", "modureProperty", "ModifyValue", "ModifiesValue", "modateValue", "modureProp", "modifiesProp", "modifiesProperty", "ModifyProp", "modifyValue", "modifiesValue", "modifyAttribute"], "valueID": ["versionIDs", "versionId", "versionid", "propertyid", " valueid", " valueMD", "valueIDs", "valueid", " valueId", "versionUID", "VALUEId", " valueUID", "valueId", "VALUEMD", "propertyId", "valueUID", "propertyIDs", "VALUEID", "VALUEUID", "versionID", "valueMD", "propertyID", "versionMD", " valueIDs"], "value": ["attribute", "name", "key", "version", "string", "description", "v", "message", "current", "memory", "entry", "content", "expression", "label", "hello", "values", "update", "buffer", "variable", "function", "val", "data", "padding", "default", "password", "example", "Value", "application", "comment", "type", "save", "format", "vector", "instance", "text", "code", "address", "output", "get", "VALUE", "input", "field", "state"], "userID": ["UserURL", "usernameID", "UserType", "usernameName", "ownerName", "userName", "ownerID", "userId", " userName", "UserID", " userId", " userURL", "userURL", "usernameId", " userType", "usernameURL", "userType", "UserId", "ownerType", "UserName", "ownerId"], "property": ["attribute", "name", "option", "metadata", "key", "state", "claim", "p", "operator", "display", "this", "ty", "description", "message", "title", "expression", "associated", "label", "config", "second", "alias", "prop", "resource", "profile", "function", "data", "translation", "method", "media", "setup", "project", "type", "prototype", "command", "feature", "object", "Property", "prefix", "language", "item", "address", "relation", "module", "table", "policy", "term", "section", "position", "to", "license", "field", "print", "pair", "style", "pe", "properties"], "newValue": ["NEWValue", " newValues", "oldMessage", "Newvalue", "newMessage", "newValues", "newVersion", "newString", " newResult", "newName", " newVersion", "oldName", "oldResult", "uniqueValue", "oldVersion", "uniqueName", "newvalue", "NewString", "oldValue", " newName", " newvalue", "uniqueMessage", "NEWString", "oldValues", "oldvalue", "oldString", "NEWResult", "newResult", "NewValue", "NewValues", " newString", " newMessage", "NEWvalue", "uniqueVersion"], "crypt": ["bec", "sm", "roy", "cs", "ch", "go", "init", "cert", "magic", "cmp", "comm", "auth", "cc", "cot", "enc", "ocr", "nt", "mac", "dec", "cmd", "gc", "cos", "sys", "ssl", "cry", "col", "conv", "rem", "password", "Crypt", "arch", "sync", "cont", "coll", "ctr", "CR", "cook", "check", "hash", "prot", "coin", "mem", "code", "cy", "cur", "rh", "cm", "pt", "cr", "core", "dict", "reset", "rot", "hex", "trust", "ct", "cp", "rypt"], "digest": ["hexEST", " Digest", "mdested", "dEST", "Digest", "digestamp", "dester", "mdEST", "mdge", "dest", " digested", "Digester", " digestamp", " DigEST", "Digge", "digert", "Diggest", "diggest", "mdest", "hashest", "mdester", "digge", "digests", "mdgest", "Digestamp", "Digert", "digested", "hashge", " Digert", "hexest", "digEST", " Digester", " digEST", "hashgest", "DigEST", "digester", "hexert", "Digests", "mdestamp", "dested", "Digested", "hexester", "mdests", "hashests"], "hexString": ["hexBytes", "shortStr", "hashstring", " hexArray", "hexArray", " hexstring", " hexBuffer", "exArray", "exBytes", "formBytes", " hexBytes", "hashStr", "hexstring", "exString", "hashArray", "formBuffer", "exBuffer", "formStr", "shortstring", "formString", "hashString", "exstring", "shortString", "shortBuffer", " hexStr", "exStr", "hexStr", "hexBuffer"], "i": ["ix", "bi", "im", "ip", "init", "span", "is", "it", "x", "mi", "phi", "gi", "ui", "ji", "si", "v", "a", "ex", "ini", "info", "hi", "major", "u", "e", "cli", "\u0438", "number", "point", "gu", "io", "ci", "ti", "j", "multi", "di", "id", "m", "uri", "ii", "q", "y", "ic", "ei", "slice", "ms", "qi", "chain", "us", "ki", "o", "ai", "I", "ie", "pi", "sim", "index", "ind", "li"]}}
{"id1": "16388708", "id2": "17296916", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2file", "decodeFileAsfile", "decodeFile2Files", "decodeStringToFiles", "decodeStringTofile", "decodeFileAsFile", "decodeFileTofile", "decodeFileToString", "decodeFileFilefile", "decodeFileAsFiles", "decodeFileToFiles", "decodeFile2file", "decodeFileFileFiles", "decodeString2String", "decodeFileFileString", "decodeString2File", "decodeString2Files", "decodeStringToFile", "decodeFileAsString", "decodeFile2File", "decodeStringToString", "decodeFile2String", "decodeFileFileFile"], "infile": ["inFile", "infolder", "outFile", "InFile", "fromfile", "isinname", "Inbase", "inbase", "frombase", "infilename", "isinfolder", "outname", "isinfile", "outbase", "fromFile", "inputname", "inputfolder", "Infile", "inname", "outfilename", "fromfilename", "Infilename", "outfolder", "inputfile", "inputFile", "isinFile"], "outfile": ["otfile", "inFile", " outname", "Outfilename", " outFILE", "outFile", " outFile", "todir", "Outfile", "outdir", "otFILE", "infilename", "toFile", "tofilename", "indir", "otname", "outname", "inname", "outfilename", "Outdir", "otFile", "outFILE", "OutFile", "tofile", "inFILE"], "in": ["inn", "im", "al", "inc", "up", "pin", "conn", "init", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "gin", "on", "id", "from", "In", "form", "or", "amin", "ins", "inside", "t", "en", "IN", "by", "get", "iter", "con", " din", "cin", "rin", "input", "re", "ar", "inf", "oin", "ind"], "out": ["auto", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "aos", "outer", "flush", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "null", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "character", "sequence", "cache", "view", "shape", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "variable", "bone", "pad", "buf", "black", "Buffer", "append", "template", "bar", "padding", "library", "available", "password", "button", "note", "batch", "base", "comment", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "block", "row", "print", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "shift", "run", "connect", "allow", "through", "query", "start", "i", "push", "close", "give", "send", "wait", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "req", "count", "iter", "seek", "end", "skip", "input", "readable", "need", "n", "size", "print", "reader", "index", "ind", "Read"], "success": ["response", "town", " okay", "first", "same", "fail", "continue", "primary", "scope", " successes", "support", " successful", "commit", "positive", "growth", "photo", " succeeds", "safe", " succeed", "submit", "value", " succ", "second", "snap", "Success", "city", "ccess", "successfully", "error", "ceed", "result", "successful", "complete", "setup", "done", "accept", "crit", "sufficient", "release", "democracy", "valid", "status", "good", "surv", "danger", "summary", "condition", "please", "ok", " failure", "unity", "ratulations", "cess", "exist"]}}
{"id1": "16851955", "id2": "11377441", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainingbackProp", "testTestingBackprop", "testTrainingbackprop", "testTestingbackProp", "testTestingbackprop", "testTrainingBprop", "testTestingBackProp", "testTrainingbackend", "testTestingbackward", "testTrainingBend", "testTestingbackend", "testTrainingBackend", "testTrainingBProp", "testTrainingBackProp", "testTrainingbackward", "testTestingBackend", "testTrainingBward", "testTestingBackward", "testTrainingBackward"], "temp": ["zip", "tem", "cache", "orig", "por", "EMP", "full", "p", "created", "this", "dest", "v", "tc", "copy", "w", "partial", "file", "make", "unt", "tmp", "Temp", "dat", "mod", " Temp", "template", "local", " temporary", "tab", "complete", "txt", "fake", "stem", "tar", "mp", "prefix", "emp", "porary", "t", "relative", "out", "create", "loc", "test", "output", "Tem", "pt", "null", " tmp", "tm", "remove", "empty", "mt", "mk", "cp"], "layers": [" lowers", "llients", "lienges", "lanes", "listayers", " Lensions", "lsayers", "llacks", "liacks", "lumers", "lienses", "vlayers", "liights", "lipackages", "lients", " Layers", " languages", "listenses", " lenses", "llayers", "lsasks", "lowers", "leights", " lpackages", "slensions", "listanes", "liients", "leenges", "liowers", " lights", " Lights", "lpackages", "slenses", "lenses", " lenges", "slights", "vlpackages", "llanguages", "lays", "llenses", "flenses", "lensions", "liayers", "flayers", "lacks", "liumers", " lacks", "languages", "lsenses", "lasks", " lanes", " lasks", "vlenses", "slayers", "slays", "flanguages", "lenges", "leayers", " lients", "lights", "lsanes", "lepackages", " Languages", "flays", "vlumers", " lensions", "llays", "llowers", "listasks", " lumers", "slanguages"], "fann": [" fannot", "Fann", "cann", "flannis", "flana", " farn", "flann", "ffarn", " fain", "fana", "fain", "Fana", "ffain", "farn", "fANN", "carn", "fmanANN", "FANN", "cannot", "ffann", "fmanann", "fmanannis", "ffannot", "flANN", "cain", "fannot", "Fannis", "fannis", "fmanana"], "trainer": ["rrain", " tracer", "brainer", "trayer", " trayer", "triner", "stracer", "Tracy", "bracer", "racy", "rainer", "Truner", "Trainer", "bracy", "striner", "Triner", "formayer", "strrain", "formainer", "strainer", "formacer", "tracer", "Trrain", "riner", "trrain", "bruner", "runer", "racer", "Trayer", "tracy", "Tracer", "truner"], "desiredError": ["demireError", "demuredEr", "desuredError", "desiredValue", "desiredEr", "demireEvent", "deseedException", "deseedValue", "desireEvent", "demiredEvent", "demireEr", "desIREDERROR", "desuredERROR", "desiringError", "desuredEr", "DesuredValue", "desuredValue", "demuredEvent", "desireEr", "demiredError", "desiredException", "desiringEr", "desuredEvent", "desIREDError", "desiringEvent", "DesiredValue", "deseedError", "desireError", "deseedERROR", "DesiredError", "demuredError", "demiredEr", "desiredEvent", "desuredException", "DesiredException", "DesuredError", "DesuredException", "DesuredERROR", "DesiredERROR", "desIREDValue", "desiredERROR", "desIREDException"], "mse": [" mSE", "Mse", "dte", "mmese", "cmpe", "mso", "mpe", "mrpe", "moe", "MSE", " mpe", "mmSE", "cmse", "mrso", "cmese", "Mso", "mrse", " msem", "mmpe", "msem", "mSE", "Mte", "dSE", "Msem", "dse", "mte", " moe", " mte", "dsem", "Mpe", "cmSE", "Moe", "mmse", " mso", "mroe", "mese", " mese"]}}
{"id1": "2668853", "id2": "9257487", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFile2Files", "decodeFileAsFile", "decodeFileTOString", "decodeFileToString", "decodeFileTOFile", "decodeFileAsFiles", "decodeFileToFiles", "decodeFileToPage", "decodeFilesToFiles", "decodeFilesToFile", "decodeFileTOPage", "decodeFiles2Files", "decodeFiles2Page", "decodeFilesToPage", "decodeFileAsString", "decodeFileTOFiles", "decodeFile2File", "decodeFileAsPage", "decodeFiles2File", "decodeFile2Page", "decodeFilesToString", "decodeFiles2String", "decodeFile2String"], "infile": ["inFile", "inputwhere", "outFile", "InFile", " inwhere", "innfile", "inputfilename", "inwhere", "inbase", " inbase", "Inbase", "innwhere", "infilename", "inpath", "innbase", "Inpath", "outbase", "innfilename", "Infile", "outpath", "inputfile", "inputpath", "inputFile", "inputbase", " infilename"], "outfile": ["inFile", "Outfilename", "outFile", "listfile", "infp", " outFile", "tofp", "listfilename", "listFile", "Outfile", "infilename", "toFile", "inpath", "tofilename", " outpath", "Outpath", "outfp", "outfilename", "outpath", "listfp", " outfilename", "OutFile", "tofile"], "in": ["inn", "im", "al", "inc", "pin", "conn", "init", "image", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "io", "gin", "user", "on", "from", "In", "form", "amin", "ins", "inside", "en", "IN", "ro", "o", "by", "get", "iter", "con", "ai", "n", " din", "cin", "rin", "input", "re", "inf", "oin", "ind"], "out": ["ln", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "w", "aos", "outer", "flush", "ent", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "sequence", "cache", "view", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "bone", "variable", "pad", "black", "buf", "Buffer", "append", "template", "bar", "padding", "zero", "available", "password", "note", "batch", "base", "comment", "queue", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "length", "block", "tree", "row", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "shift", "run", "connect", "through", "query", "start", "i", "push", "close", "give", "data", "send", "wait", "q", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "iter", "count", "seek", "end", "skip", "need", "readable", "input", "size", "print", "reader", "index", "pe", "Read"], "success": [" convergence", "response", "town", " okay", "first", "same", "continue", "master", "support", " successes", "commit", " successful", "growth", "photo", " succeeds", "safe", " succeed", "submit", " succ", "second", "snap", "Success", "city", "close", "ccess", "successfully", "error", "warning", "ceed", "result", "successful", "complete", " successfully", "security", "accept", "crit", "sufficient", "done", "cont", "release", "democracy", "valid", "status", "good", "surv", "danger", "green", "summary", " Success", "please", "ok", " failure", "setup", "unity", "ratulations", " succeeded", "top", "cess", "primary", "exist"]}}
{"id1": "255765", "id2": "17792212", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"f": ["fp", "name", "rf", "fab", "tf", "path", "exp", "fed", "p", "it", "def", "ret", "fm", "fax", "fo", "fn", "v", "g", "F", "info", "r", "w", "e", "file", "b", "filename", "h", "fx", "fa", "j", "fw", "fc", "m", "c", "base", "fs", "fi", "fd", "elf", "q", "bf", "lf", "y", "form", "t", "sf", "test", "o", "d", "cf", "l", "ft", "dir", "n", "fac", "fr", "fb", "df"], "in": ["inn", "im", "al", "inc", "up", "init", "ac", "is", "it", "inner", "isin", "ex", "add", "r", "din", "info", "mm", "all", "make", "nin", "bin", "h", "log", "io", "gin", "local", "on", "m", "from", "again", "In", "ic", "ins", "t", "en", "er", "IN", "at", "o", "by", "l", "lo", "get", "iter", "ai", "con", "n", " din", "ma", "cin", "rin", "input", "re", " IN", "pi", "reader", "inf", "oin", "ind", "thin"], "cbuf": ["cfuf", "rbbuf", "bcuff", "rboff", "abbbuf", "rbuf", "cduff", "cbdf", "cbbf", "cduf", "rbfg", "cdbuf", "CBf", "cbf", "cdoff", "sbbuf", "cfuff", "sbuff", "CBbuf", "nbbuf", "nbuff", "cduffy", "cbuff", "cff", "gbf", "sbuf", "rbather", "abbdf", "cfbf", "CBuffy", "CBbf", "gbbf", "nbfg", "rbuff", "CBuff", "sbather", "bcdf", "rbuffy", "gbuf", "bcfg", "cbuffy", "cbfg", "abbfg", "gbuff", "CBuf", "cbbuf", "cbather", "bcather", "rbdf", "cboff", "abbuf", "bcbuf", "nbuf", "bcoff", "bcuf"], "read": ["scan", "link", "is", "stream", "ready", "old", "reads", "pack", "buffer", "io", "data", "ly", "ead", "saw", "set", "range", "text", "miss", "iter", "count", "core", "end", "seek", "skip", "input", "readable", "trust", "index", "pe", "ind", "READ", "clear", "est", "ignore", "bind", "height", "fail", "ret", "current", "r", "start", "error", "sync", "report", "send", "poll", "depth", "mem", "Reader", "slow", "hold", "row", "ink", "raw", "view", "ip", "orig", "burst", "select", "find", "reach", "reading", "se", " Read", "ed", "value", "hello", "query", "rank", "k", "parse", "give", "record", "rate", "dev", "mix", "ank", "wait", "q", "chain", "load", "test", "length", "ke", "ai", "roll", "re", "print", "handle", "key", "it", "x", "add", "shift", "run", "connect", "allow", "feed", "log", "close", "default", "ext", "think", "check", "play", "pre", "write", "ok", "open", "get", "need", "reader", "n", "fill", "Read"], "totRead": ["tottWrit", "totalCheck", "totReader", "ltotRead", "toteAdd", "toteFind", "tcotDisplay", "atotaPrint", "tottNeed", "notaLoad", "trotRead", "totNeed", "trotFind", "retotReader", "ttottAdd", "tiatFill", "tOTFind", "totaBuild", "tokLoad", "notPrint", "totCheck", "tacotCheck", "taotConnect", "tfatWrite", "totPrint", "tobyPrint", "totAdd", "notalLoad", "tottAdd", "totaLoad", "totaFind", "tOTRead", "tiatVal", "notRead", "tiotBreak", "totaNeed", "notalNeed", "totBreak", "tiotVal", "ptotFind", "tottedRead", "trotWrite", "ttottNeed", "taotRead", "taotDisplay", "totalWrite", "totWrit", "totalLoad", "tobyCheck", "ptotWrite", " totRun", " totLength", "tiotFill", "totalFind", "tobyNeed", "ptOTFind", "retotRead", "tobyLoad", "tcotSend", "totaDisplay", "toteWrite", "tootRead", "tootConnect", "tiatSend", "ttotNeed", "retottPrint", "totalNeed", "tcotCheck", " toteRead", "letrotFind", "tootCheck", "atotaFill", "toiotRead", "totalLength", "letotSee", "totHave", " totalRead", "letrotSee", "taotCheck", "notalCheck", "ltotBuild", "tootDisplay", " totFind", "ptOTLoad", "tacotConnect", "tottReader", "tiotRead", " totalBuild", "ttotRead", "tootBreak", "tootVal", "tcotBreak", "tcotConnect", "tottWrite", "notaRead", "totaCheck", "totRun", "tiotHave", "atotHave", "ptOTWrite", "tiatBuild", "letotFind", " toteFind", "totSend", "toteNeed", "trotSee", "tokFind", "ptotLoad", "totalSee", "notCheck", "tcotVal", "totaRead", "toiotSend", "totVal", "totaPrint", "notReader", "totedHave", "tottedReader", "tiotSend", " toteRun", "tacotRead", "totFill", "tacotDisplay", "toteReader", "totaConnect", "totaLength", "tobyWrite", "tiatLoad", "toteLoad", " totBuild", "tiotReader", "tottRead", "atotaHave", "totDisplay", "toteRead", "totaAdd", " totWrite", "ptotRead", "ltotFill", "notalRead", "totaHave", "toticRead", "tokWrite", "tiatRead", "tottRun", "tOTLoad", "totConnect", "totSee", "tOTWrite", "ttotWrite", "toiotBreak", "notLoad", "totedPrint", "toteRun", "letrotRead", "letrotWrite", "tottedWrit", "totalBuild", "notWrite", "atotPrint", "tiotPrint", "totLoad", "toiotVal", "retottWrit", "toteFill", "toteBuild", "ltotaRead", "totLength", "letotRead", "toticWrite", "totalPrint", "totWrite", "atotaRead", "tiotWrit", "notalPrint", "retotPrint", "retottReader", "atotRead", "ltotaLoad", "ltotaFill", "totaReader", "tiatBreak", "tcotRead", " totalWrite", "totaSee", "ltotLoad", "totedRead", "notalWrite", "tootSend", "ltotaBuild", "totalRead", "toticFind", "notNeed", "atotFill", " totalLength", "notaReader", "totaFill", "tokRead", "toteLength", "totBuild", "tOTNeed", "tobyRead", "ptOTRead", "tottFind", "letotWrite", "tottPrint", "ttottRead", "notaWrite", "tfatReader", " toteWrite", "totaWrite", "retotWrit", "ttottWrite", "toticRun", "totedFill", "retottRead", "tfatRead", "totFind", "tfatLoad", "ttotAdd", "tottedPrint"], "out": ["auto", "obj", "up", "ch", "writer", "Out", "g", "ex", "v", "r", "w", "aos", "b", "sys", "log", "io", "conv", "c", "res", "we", "or", "t", "at", "o", "OU", "write", "output", "con", "os", "to", "oss", "end", "co", "s", "outs", "OUT", "net", "n", "ou"], "i": ["ix", "im", "php", "p", "is", "phi", "ui", "v", "hi", "info", "ski", "io", "ci", "multi", "di", "uri", "ei", "set", "ic", "ity", "qi", "ico", "I", "my", "sim", "ia", "index", "ind", "ii", "si", "r", "integer", "e", "iu", "point", "xi", "m", "iii", " I", "ki", "ice", "ip", "ri", "you", "this", "g", "mm", "\u0438", "cli", "me", "zi", "id", "c", "q", "y", "ims", "ij", "chain", "o", "ai", "ie", "print", "bi", "init", "oi", "any", "mi", "it", "x", "gi", "ji", "ini", "ami", "um", "b", "ion", "ti", "j", "iy", "status", "PI", "t", "us", "l", "client", "to", "s", "pi", "iq", "dr", "li"]}}
{"id1": "9647576", "id2": "22411381", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 1, "substitutes": {"Reserve": ["Reserved", "Servation", "Conserved", "Resolve", "reservation", "Consolve", "reserved", "reserve", "Conserve", "Reservation", "Serve", "Served", "Conservation", "resolve", "Solve"], "stbookings": ["Stbookies", "stbindies", "stbinding", "stbooksers", "stbindings", "stbooksings", "Stbookers", "stbooking", "stBooking", "stbookers", "stBookers", "stBookies", "Stbooking", "stBookings", "stbinders", "stbookies", "stbooksing", "stbooksies", "Stbooksies", "Stbooksings", "Stbookings", "Stbooksing", "Stbooksers"], "stchartwl": ["stpagewal", "stplotwal", "STchartwal", "STChartbook", "STchartbook", "STchartml", "stpageml", "stChartwal", "stpagewl", "stChartml", "stchartwal", "stchartbook", "stChartbook", "stplotbook", "stplotml", "stchartml", "STChartwal", "STchartwl", "STChartml", "stChartwl", "STChartwl", "stplotwl", "stpagebook"], "sp": ["sm", "pp", "p", "vol", "sk", "si", "scope", "sh", "se", "ps", "sb", "sy", "esp", "so", "ap", "sil", "bsp", " SP", "ss", "isp", "pol", "sw", "sv", "lp", "asp", "space", "spr", "osp", "st", "service", "SP", "sf", "spe", "jp", "pb", "policy", "sc", "Sp", "pt", "yp", " esp", "cp", "pe", "tp"], "userbooksql": ["userbysquer", "userbooksels", " userbindquer", "userscriptsqs", "userbooksSQL", "userscriptsels", "agentbooksQL", "userbookql", "agentpagesQL", "userbooksQL", "usertypessql", "userreadsels", "agentbookssql", "clientreadsqs", "clientbooksels", "userscriptselly", "userpagesql", "clientreadselly", "userpagesQL", "userreadsql", "userbysql", "userpagesqs", "userbindSQL", " userbindsql", "userbysSQL", "agentbooksqs", " userbindSQL", "userbindquer", "agentpagesql", "clientbookselly", "userbindql", "userBooksquer", "userpagessql", "agentpagesqs", "clientbooksqs", "clientreadsql", "userbookselly", "userscriptsql", "clientreadsels", "userreadsqs", "userbindsql", " userbooksquer", "userooksql", "userbookqs", "userBooksSQL", "agentpagessql", "userreadselly", "userbooksqs", "usertypesqs", "userbookssql", "userooksels", " userbindql", "userBookssql", " userbooksSQL", "userbookQL", "userookselly", "usertypesql", "clientbooksql", "userBooksql", " userbookssql", "usertypesQL", "userbooksquer", "userbyssql", "userooksqs"], "agentbooksql": ["agentbookql", "agentletsql", "agentbooksQL", "agentpagesQL", "ownerbeansili", " agentBooksquer", "agentbookssql", " agentbookssql", "agentBooksql", " agentBooksqu", "agentbeansquer", "ownerbeansquer", "agentpagesql", " agentbookQL", "ownerbeansQL", " agentbooksQL", "ownerbooksili", "agentbeansQL", "agentbookili", " agentbookql", "agentiquesquer", "ownerbeansql", " agentbooksquer", "agentBooksili", "agentpagessql", "agentiquesQL", "agentBooksqu", "agentbooksili", "agentBooksQL", " agentBooksql", "agentbookQL", "agentbeansili", "agentletsqu", "agentiquesqu", " agentbooksili", "agentbooksqu", "agentiquessql", "agentpagesili", "agentiquesili", "ownerbooksquer", "ownerbooksQL", "agentBookssql", "agentiquesql", "ownerbooksql", " agentbooksqu", "agentletssql", " agentBookssql", " agentbookili", "agentbooksquer", "agentBooksquer", "agentbeansql", "agentbookquer", "agentletsquer"], "bookingid": ["bookillingid", "bookingsid", "bookingingids", "bookingingID", "bookingID", "Bookingsid", "BookingsID", "bookingids", "bookingingid", "bookillingids", "Bookingids", "Bookingid", "BookingID", "bookillingID", "bookingsID", "Bookingsids", "bookingsids"], "currentcoach": [" currentcoarch", "currentlycat", "currentCOac", "currentcoACH", "currentCOasp", "currentfoch", "currentcoachable", "currentCoACH", " currentfoACH", "currentfoech", "currentcoarch", "currentfoACH", "currentcalech", "currentCoch", "currentCoarch", "currentlyCoech", "currentconac", "currentlycoch", "currentlyCoachable", "currentconasp", "currentcach", "currentcoasp", "currentlyCoch", "currentcoearch", "currentfoach", " currentfoach", "currentconach", "currentCOat", "currentlycach", "currentfoarch", " currentfoch", "currentcoech", "currentlycoech", "currentCoachable", "currentlycac", "currentlycoasp", " currentfoarch", "currentcalch", "currentconat", "currentcasp", "currentcac", " currentcoch", "currentcoch", "currentlycoach", "currentlycoat", "currentcoeACH", "currentCoech", "currentlycoachable", "currentcoeach", "currentcoac", "currentcat", "currentCOach", "currentlycasp", "currentcalach", "currentfoachable", "currentcalachable", " currentcoACH", "currentcoat", "currentCoach", "currentlyCoach", "currentlycoac"], "currentseat": ["currentslot", " currentsel", "reportedport", "Currentseat", "currentlysen", " currentroute", "curseat", "currentlysel", "currentsen", "reportedsel", "currentroute", "currentsel", "reportedseat", "Currentsen", "reportedroute", "Currentsel", "cursel", " currentport", "curroute", " currentsen", "curport", "currentlyseat", "currentport", "Currentslot", " currentslot", "currentlyslot"], "tickpos": ["snapposition", "quotepos", "snapPos", "stickposition", "ickpo", "popPos", "testposition", "stickPos", "ickpos", "snappos", "rickPos", "stickpo", "ickPos", "quoteno", "ickposition", "rickpo", "checkposition", "rickprop", " tickno", "tickposition", "checkpos", "testpos", "quotePos", "snappo", "checkPos", "stickpos", "poppos", "tickprop", " tickposition", "testpo", "stickno", "tickPos", "poppo", " tickpo", "stickprop", "testPos", "rickpos", "tickno", "tickpo", " tickPos", " tickprop", "quoteposition", "popposition", "checkpo"], "chartavailupdsql": ["chartavailupsdatesQL", "chartavailupdsQL", "chartavailupyssql", "chartavailupdql", "chartavailupsdsql", "chartavailupdsq", "chartavailupdatesql", "chartavailupsdsq", "chartavailupsdssql", "chartavailupysq", "chartavailupsdsQL", "chartavailupdatessql", "chartavailupysql", "chartavailupdq", "chartavailupdatesq", "chartavailupdatesQL", "chartavailupsdatesql", "chartavailupdssql", "chartavailupsdatesq", "chartavailupsdatessql", "chartavailupysQL", "chartavailupdQL"]}}
{"id1": "807346", "id2": "11334468", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"runScript": ["executeCode", "runCode", " runCode", "executeProgram", " runscript", "callProgram", "callCode", "callScript", " runProgram", "executeScript", "runProgram", "executescript", "callscript", "runscript"], "scriptName": [" scriptBody", " scriptPath", "criptFile", " scriptFile", "criptPath", "scriptBody", "criptBody", " scriptKey", "fileKey", "filename", " scriptname", "scriptKey", "templateFile", "filePath", "templateBody", "templatePath", "scriptPath", "scriptname", "ScriptKey", "criptName", "ScriptPath", "ScriptName", "Scriptname", "fileName", "templateName", "scriptFile"], "data": ["name", "sequence", "response", "cache", "html", "image", "raw", "ata", "action", "p", "string", "some", "this", "description", "a", "message", "info", "what", "content", "title", "partial", "value", "json", "source", "div", "buffer", "all", "debug", "log", "comments", "reason", "dat", "next", "results", "video", "default", "padding", "error", "result", "step", "alert", "comment", "type", "res", "report", "command", "str", "text", "t", "chain", "out", "rew", "rel", "table", "output", "to", "DATA", "row", "input", "list", "empty", "extra", "missing", "window", "n", "format"], "url": ["mail", "Url", "link", "hl", "pl", "char", "r", "job", "mount", "lb", "b", "log", "gl", "ssl", "resource", "build", "bel", "user", "f", "base", "dl", "abs", "uri", "web", "http", "sl", "nl", "str", "ll", "browser", "address", "out", "https", "loc", "rel", "l", "open", "get", "URL", "ur", "ul"], "in": ["inn", "inc", "al", "is", "it", "mat", "act", "inner", "stream", "isin", "r", "din", "info", "mm", "source", "all", "bin", "i", "io", "serv", "gin", "val", "on", "In", "body", "check", "ins", "en", "out", "IN", "l", "ma", " din", "input", "cin", "rin", "pi", "mc", "inf", "ind"], "buffIn": ["BuffIn", " buffedIn", " BuffIn", "bufOut", " BuffCon", "buffOut", " buffOut", " BuffOut", "bufIn", "BuffOut", "bufferIn", "bufferCon", "buffedIn", "buffIns", "bufferOut", "BuffedIn", "BuffCon", "buffCon", " BuffIns", "BuffIns", "bufferIns", "bufedIn"], "temp": ["character", "sequence", "cap", "tem", "cert", "cel", "tc", "current", "index", "acc", "deg", "perm", "perature", "wr", "buffer", "variable", "i", "read", "tmp", "Temp", "dat", "mod", "j", "template", "ptr", "there", "result", "txt", "fake", "stem", "tim", "cell", "Temperature", "cur", "porary", "t", "relative", "thread", "test", "length", "output", "term", "pt", "input", "emp", "mint"]}}
{"id1": "88047", "id2": "411595", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewrites", "readAndrewWrite", "readAndReprites", "readAndResWrite", "readAndResend", "readAndReprite", "readAndResrites", "readAndrewrites", "readAndRepWrite", "readAndrewend", "readAndRewWrite", "readAndResrite", "readAndRepend", "readAndRewend", "readAndrewrite"], "inFile": [" inFilename", "outFilename", "InFile", "outfile", "inTime", "INTime", "inputPlace", "inFace", "INFILE", "initPlace", " infile", "docFILE", "initFilename", "inFilename", "inputFilename", "iTime", "INFile", "initFace", "INFace", "InFilename", "iFILE", "Infile", "infile", "INPlace", "docFilename", "docFile", "inputFile", "INFilename", "inPlace", "iFile", "docTime", "iFilename", "initFile", "inFILE", "inputFace"], "outFile": [" outFILE", "outFilename", "reportFile", "outfile", "reportFILE", "nameFile", "nameFilename", "checkfile", "toFile", "inFilename", " outFilename", "reportfile", "checkFile", "nameFILE", "checkFILE", "checkFilename", "reportFilename", "infile", "toFilename", "outFILE", "toFILE", "namefile", "tofile", " outfile", "inFILE"], "iis": ["diIs", " iisc", " iIS", "IIs", "Ii", "eis", "liIs", "diiss", " ii", "iisc", "dii", "liisc", " iIs", " iiss", "Iis", "iIs", "iiss", "liis", "aiis", "iiris", "aiIS", "Iiss", "iiIs", "aiIs", "iris", "iiisc", "liris", " iris", "eIS", "iiis", "eIs", "diis", "iIS", "ii"], "dcmParser": ["dpmStatement", " dcmLoader", "dmmparser", "DpmParser", "DpmReader", "dpmPar", "dmmmParser", "decmarser", "Dpmparser", "dfmLoader", "dmmReader", " dpmarser", "decmReader", "DcmReader", "dcommParser", "dpmParser", "dpmPrivate", " dcmAssistant", " dpmparser", "deromReader", "dmReader", "dcfStatement", "deromParser", " dpmAssistant", "DcmBuilder", "DcmAdapter", "dcomBuilder", "deromarser", " dpmParser", " dpmPrivate", " dcmStatement", "dmarser", "dcrparser", "dcomLoader", "dromReader", "dmmarser", "dmmParser", "dmmmparser", "dcomParser", "dcfReader", "dpmBuilder", "dgrPar", "dpmReader", "dromparser", "dcmStatement", "dcmPrivate", " dpmListener", " dpmStatement", "dmparser", "dpmLoader", "dfmReader", "drumPar", "dpmListener", " dcmarser", "dfmParser", "Dcmparser", "dgrReader", "dcmAdapter", "dmoduleAssistant", "dmmAdapter", "DcmPar", "dcmLoader", "dromListener", "dpcParser", "dpcReader", "dcrBuilder", " dcmReader", "dromarser", "dfmBuilder", "DpmBuilder", " dcmparser", "dpcAssistant", "dcmPar", "dcommListener", " dcmPrivate", " dcmBuilder", "decmParser", "dgrStatement", "decmparser", "dcmAssistant", "drumBuilder", "dcmListener", "dcommReader", "DcmParser", " dpmPar", "drumReader", " dpmLoader", "dmParser", "dcmReader", " dcmListener", "dcommAssistant", "dmodulePrivate", " dcmPar", "DpmAdapter", "dcomReader", "dcmarser", "dgrParser", "dpmparser", "dmmmReader", "dromParser", "DpmPar", "dpmAssistant", "dcfParser", "dcrParser", "dpmAdapter", "dromAssistant", "drumParser", " dpmBuilder", " dpmReader", "dpmarser", "dcfPar", "deromparser", "dpcPrivate", "dmoduleReader", "dmoduleParser", "dmmmAdapter", "dcmparser", "dcmBuilder", "dcrReader"], "ds": ["obs", "cs", "ws", "gd", "bs", "ods", "Ds", "rs", "tes", " DS", "ps", "drivers", "sets", "dh", "ns", "aos", "dx", "der", "DS", "hd", "bd", "sys", "ys", "ils", "gs", "sd", "dat", "ss", "es", "data", "uds", "xs", " des", "sv", "dl", "fs", "services", "ads", "eds", "its", "details", "in", "da", "ims", "ins", "dds", "pers", "vs", "d", "des", "db", "eps", "dos", "os", "dt", "s", "dq", "js", "outs", "qs", "dd", "hs", "ks", "ls", "as", "df", "pd"], "pdReader": ["vdWriter", "pedRunner", "xdHelper", "ddHelper", "tdParser", "pdParser", "dpLoader", "pdCar", "ddParser", "ddRunner", "vdReader", "pedReader", "pdRunner", "pdHelper", "ddLoader", "pedLoader", "pdLoader", "ddRead", "ddWriter", "hdReader", "dpReader", "ddReader", "vdHelper", "pedCar", "pdRead", "tdRead", "hdWriter", "xdReader", "xdLoader", "xdWriter", "dpRunner", "vdLoader", "ddCar", "dpCar", "hdRead", "hdParser", "tdWriter", "tdReader"], "out": ["obj", "cache", "conn", "p", "Out", "ex", "v", "cmd", "pos", "io", "one", "data", "res", "in", "str", "end", "list", "name", "auto", "msg", " err", "full", "writer", "cb", "inv", "pool", "opt", "on", "sw", "cfg", "we", "at", "gr", "os", "con", "oss", "outs", "screen", "OUT", "net", "raw", "cn", "up", "nt", "w", "outer", "ent", "all", "nr", "err", "tmp", "conv", "gt", "gen", "id", "c", "sum", "ins", "o", "output", "null", "co", "js", "desc", "ou", "go", "ch", "it", "inner", "aos", "flush", "sys", "log", "serv", "inter", "txt", "status", "t", "en", "client", "s", "to", "over", "n"], "dcmEncParam": ["dcmencMsg", "dmmencMsg", "dmmEncPar", "dmmEnNum", "dmmencNum", "dmmEncParam", "dcmEncVal", "dmmEnParam", "dcmEscNum", "dmmEncMsg", "dmmEnPar", "dcmDecCmd", "dcmEnParam", "dcmencParam", "dcmencPar", "dcmDecMsg", "dcmEnPar", "dcmDecParam", "dcmEscVal", "dcmEnNum", "dcmEncPar", "dmmencCmd", "dcmencCmd", "dmmEncVal", "dcmEnVal", "dcmencNum", "dcmDecNum", "dcmEncNum", "dcmEncMsg", "dmmEncNum", "dmmEncCmd", "dcmEscParam", "dcmEncCmd", "dcmEscPar", "dmmencParam"], "pdWriter": ["PDEditor", "pcWriter", "tdWriter", "dpEditor", "PDReader", "PDWrite", "pdWrite", "pidWriting", "PDWriter", "pdwriter", "dpReader", "dpWriter", "tdEditor", "pdEditor", "pidWriter", "pcWrite", "pcWriting", "pcwriter", "dpWrite", "pidwriter", "tdWriting", "tdwriter", "pidWrite", "pdWriting", "tdWrite", "tdReader"]}}
{"id1": "8047989", "id2": "14691829", "code1": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"getHashedID": ["getShashingString", "getShashedId", "getShashedHash", "getHashingId", "getShashingId", "getHackedId", "getHASHHash", "getHackedHash", "getShashedString", "getHackedID", "getHASHId", "getHashedHash", "getHackedString", "getShashingHash", "getShashedID", "getHashedId", "getHashingString", "getHASHString", "getHashingID", "getHashingHash", "getHashedString", "getShashingID", "getHASHID"], "ID": ["name", "IDENT", "ACK", "TYPE", "NAME", "TAG", "MD", " PID", "URI", "INT", "ASH", "STR", "DS", "SHA", "IDs", "UID", "P", "DB", "PK", "KEY", "FILE", "EL", "id", "Key", "AND", "NULL", "NOTE", "IDA", " NAME", "Name", "DER", "MAC", "AD", "REF", "DATA", "URL", " fid", "END", "Id", " id", "BY", "JS"], "md5": ["MD7", "MD512", "sha7", "MD2", " md6", " md2", "md75", "hash8", "md3", " MD3", " md75", "md4", " MD6", "md7", " MD75", "hash75", "sha5", " md512", "dig5", " MD7", "md512", " md7", "MD5", " md4", " MD5", "md2", "dig3", "dig2", "dig512", "sha2", " MD8", "md8", "md6", " MD4", " md3", "MD4", "MD3", " md8", "hash5", "sha6", "MD6", "hash7"], "digest": [" digment", "Digest", " digist", "mdEST", " digast", " digested", "Digast", "Digate", "mdest", "digast", "Digist", "digests", "digate", "digment", "digested", " digate", "mdast", "Digment", " digests", "mdist", " digEST", "digEST", "mdment", "DigEST", "Digests", "digist", "mdate", "Digested", "mdests", "mdested"], "bytes": ["bits", "groups", "fields", "ips", "raw", "frames", "bs", "banks", "this", "lines", "tes", "strings", "some", "pages", "errors", "classes", "ds", "values", "gc", "blocks", "gs", "keys", "buf", "results", "es", "tags", "data", "xs", "nets", "tmp", "files", "seconds", "faces", "pieces", "services", "steps", "cells", "rows", "bis", "gb", "boxes", "jobs", "details", "ios", "parts", "binary", "https", "bes", "types", "Bytes", "times", "items", "terms", "s", "flags", "fixes", "windows", "options", "images", "bps", "ces", "units"], "i": ["ix", "bi", "im", "ip", "init", "key", "span", "ri", "is", "mi", "x", "it", "phi", "gi", "ui", "ji", "inner", "si", "v", "a", "ini", "index", "u", "cli", "ind", "b", "ski", "gu", "io", "ci", "ti", "zi", "multi", "j", "di", "xi", "fire", "m", "batch", "uri", "q", "uu", "y", "ic", "ei", "set", "ms", "qi", "t", "ij", "us", "ki", "o", "client", "ai", "I", "ie", "pi", "sim", "n", "ii", "li"]}}
{"id1": "20232250", "id2": "18358467", "code1": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "code2": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"sendRequest": [" sendCommand", "executeRequest", "sendrequest", "processMessage", "processRequest", " sendrequest", "sendCommand", "executerequest", "processCommand", "executeCommand", "processrequest", "executeMessage", " sendMessage", "sendMessage"], "seq": ["sequence", "msg", "sec", "comp", "cas", "sq", "pse", "eq", "enc", "ence", "cl", "cmd", "cli", "sel", "config", "pos", "session", "err", "serv", "next", "buf", "Sequ", "rez", "gen", "id", "tab", "queue", "batch", "sequ", "struct", "res", "sim", "q", "cell", "frame", "prefix", "str", "item", "ref", "test", "ctx", "client", "exc", "iter", "req", "block", "sub", "que", "clus", "iq", "desc", "protein", "state"], "IOException": [" IOStatus", "ReadingException", "ioFailure", "ReadingFailure", "ReadingStatus", "IOStatus", "ioException", " IOFailure", "IOFailure", "ioStatus"], "putBuf": ["putBeuf", "outputbuf", "PUTBbuff", "putburg", "putBld", "putLagg", "putMuf", "putDebuff", "putBuff", "putBeagg", "putEBpkg", "putbbuff", " putLagg", "putPbuff", "putEBagg", "PUTGuf", "outputBuf", " putBpkg", "putBimg", "PUTMuf", "putCld", "outputGuff", "putLpkg", "putOutbuf", "putbuf", "putGuff", "putGurg", "putOutuf", " putBagg", "outputburg", " putLpkg", "putLbuff", "putBurg", "putLurg", "PUTBurg", "putBUF", "putCuf", "putPbuf", "putLuf", "PUTBbuf", "putBub", "putGUF", "putOutub", "putLbuf", "putDebuf", "putBbuf", "posBeUF", "putCimg", "putBbuff", "posBuf", "putLub", "PUTBld", " putBbuf", "putEBbuf", "PUTBuf", "PUTBimg", "putBagg", "putGagg", "putMuff", "PUTBuff", "PUTGbuf", "putPurg", "putGuf", "putLuff", " putLbuf", "outputbbuf", "posBebuf", "putBpkg", "posBeagg", "PUTMimg", "putOutuff", "outputGbuf", "outputBuff", "posBUF", "outputBurg", "putbagg", "outputGuf", "putbpkg", "putBeUF", "posBeuf", "PUTGbuff", "putMld", "putDebld", "putCuff", "outputbbuff", "PUTMld", "PUTMuff", "putEBuf", "putbbuf", "posBagg", "putDebimg", "putGub", "outputBub", "putMimg", "outputBbuf", "putGbuf", " putLuf", "outputBbuff", "outputGub", "putPuf", "putGbuff", "posBbuf", "putBebuf", "PUTGurg"], "url": ["Url", "link", "hl", "oul", "cert", "p", "ret", "xml", "atl", "r", "sb", "cmd", "lb", "log", "ssl", "build", "bel", "dl", "abs", "uri", "sl", "nl", "http", "rl", "ctrl", "str", "ll", "browser", "https", "loc", "rel", "pkg", "l", "open", "client", "get", "URL", "net", "att", "ls", "ur", "addr"], "conn": ["obj", "ln", "ch", "cert", "ws", "resp", "soc", "socket", "addr", "comm", "cb", "inv", "enc", "nt", "nw", "ns", "connect", "cl", "cmd", "syn", "tn", "fin", "secure", "close", "conv", "iw", "win", "sw", "dl", "cont", "res", "pas", "ctr", "nc", "ctrl", "cur", "loc", "jp", "db", "ctx", "open", "write", "client", "con", "connection", "n", "exec", "nec", "ann", "Conn", "net", "ct", "cp", "cn"], "wr": ["wy", "wk", "writers", "Writer", "ln", "wa", "wrote", "writer", "ws", "Wr", "wn", "fn", "nw", "w", "writ", "wx", "iw", "vet", "hw", "wm", "kl", "sw", "fw", "spr", "vr", "we", "mg", "wb", "mn", "pr", "rew", "rw", "write", "wid", "wo", "mr", "WR", "tw", "fr", "dr", "wer", "mk", "wt", "kr"]}}
{"id1": "20717531", "id2": "10715601", "code1": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"encrypt": ["Encipher", "encipher", "decipher", "uncipher", "decrypted", "uncryption", "decryption", "Encryption", "encryption", "uncrypted", "uncrypt", "decrypt", "Encrypt", "Encrypted", "encrypted"], "plainText": ["hardWord", "cleanTEXT", "hardText", "tableUrl", "ainWord", " plainTextColor", "plainDelete", "floatTEXT", "ainTextColor", "ainUrl", "plainWord", "plainPath", " plainData", "hardTEXT", "longTextColor", "ainTEXT", "publicText", "ainOutput", "formText", "ainPassword", "tableConfig", "leadTEXT", "leadText", "longTEXT", "ainPath", "realtext", " plainTEXT", " plainUrl", "broadText", "ainConfig", "cleanName", "ainName", "plainName", "broadPassword", " plainSource", "leadtext", "plainConfig", " plainName", "floatPassword", "publicOutput", "longText", "longString", "floatDelete", "realTEXT", "ainDelete", "plainUrl", "publicData", "longtext", "tableTEXT", "broadTEXT", "floatText", "plainPassword", "broadDelete", "ainString", "cleantext", " plaintext", "plainData", " plainString", "hardtext", "plainString", "formTEXT", "ainData", "plainOutput", "longSource", "formtext", " plainPath", " plainConfig", "ainText", "cleanText", "formWord", "realSource", "leadPath", "plainSource", "tableText", "plainTextColor", "aintext", "plaintext", "realText", "plainTEXT", " plainOutput", "publictext"], "text": ["view", "TEXT", "path", "image", "writer", "tx", "quick", "select", "act", "process", "nt", "message", "content", "title", "ut", "event", "source", "all", "start", "log", "buffer", "tt", "read", "template", "translation", "ext", "txt", "comment", "cont", "math", "struct", "left", "sum", "quote", "aut", "prefix", "t", "binary", "write", "output", "word", "end", "input", "net", "print", "cat", "ct", "Text", "ind", "format"], "i": ["ix", "ni", "im", "cgi", "p", "is", "phi", "ui", "v", "hi", "ski", "gu", "io", "ci", "multi", "di", "f", "uri", "ic", "ei", "ity", "eu", "in", "qi", "iter", "I", "asi", "my", "sim", "index", "ii", "si", "iu", "point", "ori", "xi", "m", "ki", "uni", "ip", "ri", "g", "u", "cli", "\u0438", "zi", "id", "q", "y", "ims", "ms", "chain", "o", "ai", "z", "yi", "print", "bi", "init", "oi", "mi", "it", "x", "gi", "ji", "ini", "ami", "ti", "j", "iy", "t", "us", "pi", "n", "li"], "mDigest": ["Mdigse", "mDse", "mdiggest", "mDiggest", "mMacested", "MDiger", "mExecest", "mMDer", "mFindgest", " mDse", "mFindest", "mExecested", "mdigger", "mDigger", "mMDest", "mExecum", "mExecger", " mHashger", "Mdiger", "mDiger", " mDigested", "mFinder", "mHashum", "mMacse", "mDester", " mDested", "MDigse", "mDoher", "mDoested", "mDoest", " mHashested", "mMacester", "mDigester", "mHashest", "mDose", "mDested", "mDigher", "mDigse", "mDest", " mHashum", "mdigse", "mDher", " mHashest", " mDigger", "mHashger", "mHashested", "Mdigest", " mDigester", "mDigested", "mDigum", " mDigum", "mMacest", "mdigher", "MDigest", "mMDgest", " mDigse", "Mdiggest", "mdigest", " mDester", "mFindse", " mDigher", " mDher", "mdigester", "mdiger", "mdigum", " mDest", "mdigested", "mMDse", "MDiggest"], "d": ["p", " D", "x", "cd", "g", "v", "D", "a", "r", "ds", "dh", "w", "dx", "u", "e", "dec", "b", "bd", "de", "h", "sd", "dat", "j", "di", "ld", "f", "m", "done", "c", "fd", "y", "da", "md", "t", "with", "dot", "dc", "db", "l", "nd", "n", "s", "dict", "dd", "diff", "ed", "df", "pd"], "hash": ["radius", "cache", "html", "key", "array", "header", "tr", "our", "ssh", "sh", "message", "dh", "shift", "square", "all", "div", "buffer", "h", "her", "hz", "ash", "checked", "password", "id", "save", "Hash", "ah", "report", "search", "sum", "tag", "random", "check", "code", "summary", "test", "rh", "always", "table", "total", "block", "shadow", "dict", "flash", "hex", "print", "filter", "href", "style", "oh", "handle", "sha"]}}
{"id1": "5125848", "id2": "21013026", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private InputStream getPageStream(String query) throws MalformedURLException, IOException {\n        URL url = new URL(baseUrl + query + \"&rhtml=no\");\n        URLConnection connection = url.openConnection();\n        connection.connect();\n        InputStream in = connection.getInputStream();\n        BufferedInputStream bis = new BufferedInputStream(in);\n        return bis;\n    }\n", "label": 0, "substitutes": {"combineJs": ["combinateLink", "Combinejs", "CombineJs", "combosejs", "ComboseLink", "ComboseJS", "combinatejs", "ComboseJs", "comboseJS", "CombineLink", "combINELink", "Combosejs", "combineLink", "combinejs", "combineJS", "combINEJs", "combinateJS", "combINEjs", "combinateJs", "comboseJs", "combINEJS", "comboseLink", "CombineJS"], "base": ["server", "origin", "domain", " bases", "file", "b", "start", "buffer", "source", "host", "bottom", "local", "data", " Base", "based", "template", "root", "id", "from", "uri", "Base", "site", "page", "bas", "prefix", "relative", "address", "api", "db", "bound", " based", "ase", "re", "bid", "reset", " basis", "absolute"], "linkJs": ["inkJs", "linkScript", "LinkJs", "linkedScript", "linkjs", "linkJS", "LinkJS", " linkJS", "inkScript", " linkLinks", " linkTags", "linkedJs", "inkJS", "inkjs", "Linkjs", "linkLinks", "inkTags", "inkLinks", "linkedLinks", "linkedJS", "LinkTags", " linkjs", " linkScript", "linkTags"], "newFiles": ["newDocuments", "linkfiles", "linkDocuments", " newLinks", "nextfiles", "linkFiles", "nextFiles", " newfiles", "newLinks", "nextLinks", " newDocuments", "newfiles", "linkLinks", "nextDocuments"], "dir": ["zip", "auto", "vol", "created", "wd", "def", "cd", "dm", "lock", "Dir", "temp", "file", "div", "folder", "sys", "ir", "tmp", "mod", "local", "DB", "manager", "di", "root", "DIR", "id", "dl", "done", "fs", " directory", "fd", " d", " Dir", "dep", "tar", "good", "md", "desc", "lib", "out", "ref", "loc", "rel", "d", "pkg", "db", "doc", "module", "disk", "dd", "diff", "dr", "directory", "mk", "area", "addr"], "name": [" parser", " err", " self", " foo", " os", " res", " names", " vm", " str", " msg", " scanner", " prefix", " karma", " rebuild", " report", " start", " loader", " db", " bar", " cleaner", " browser", " dummy", " b", " log", " filename", " logger", " tmp", " manager", " info"], "minDir": ["minRel", "thinDir", "skindir", "mainDir", "thinJar", "sortDir", "sortPref", "miniJar", "thinTrans", "MinFile", "skinLoc", "miniTrans", " minPref", "sortRel", "smallNet", "minutePref", "maindir", "miniDir", "minuteDar", "smallDb", "minuteRel", " minDar", "smallDir", "MinDir", " minFile", "minPref", "minJar", " minJar", "minTier", "skinDb", " minNet", "minDar", "thinTier", " minRel", "smallFile", "miniTier", "skinDir", "minDb", "smalldir", " minTier", "MinNet", " minTrans", "minFile", "minuteDir", "minLoc", "smallLoc", "minNet", "mindir", "mainLoc", "mainDb", "minTrans", "sortDar"], "combineFile": ["combinerfile", "combINESet", "combinateFile", "combineSet", "combINEWriter", "combinSet", "combinerEmail", "combinfile", "comboiceFile", "comboseFile", "combinateEmail", "comboicefile", "coordINEFile", "coordINESet", "combinWriter", "comboiceMessage", "coordINEWriter", "combinefile", "comboseWriter", "comineEmail", "cominateFile", "combinatefile", "coordineSet", "combineEmail", "comboiceEmail", "cominateEmail", "combinFile", "combINEFile", "combinerFile", "comineFile", "combinerMessage", "comineMessage", "cominefile", "comboseSet", "coordineFile", "combINEfile", "cominatefile", "cominateMessage", "combosefile", "coordineWriter", "combinateMessage", "combineMessage", "coordINEfile", "coordinefile"], "concatFile": ["comcFile", "concatFiles", "covertFiles", "comcDir", "comcFilename", "convertFiles", "convertFilename", "comcatFilename", "cocatFile", "conCatDir", "cocatTable", "concapTable", "covertfile", "concatFilename", "conatfile", "convertFile", "concapfile", "cocatfile", "conCatFile", "concapFiles", "conatTable", "conCatFilename", "concatTable", "concapFile", "cocatFiles", "convertfile", "covertTable", "concDir", "convertDir", "concFile", "concFilename", "comcatDir", "convertTable", "comcatFile", "conatFiles", "covertFile", "conatFile", "concatDir", "concatfile"], "combineWriter": ["comboseWrite", "declinateWriter", "combinateFile", "combieWrite", "comboseReader", "ComboseCounter", "CombineWriter", "comboseFile", "combenWrite", "combinateCounter", "ComboseWrite", "combosewriter", "Combinewriter", "combenCounter", "combinateWrite", "declineFile", "combinewriter", "combieFile", "CombineCounter", "combieReader", "comboseWriter", "combinateWriter", "combineReader", "declinateWrite", "combieWriter", "declinateReader", "declineWriter", "combineCounter", "declinateFile", "declineReader", "combenWriter", "combineWrite", "CombineWrite", "comboseCounter", "combenwriter", "Combosewriter", "declineWrite", "combinatewriter", "combinateReader", "ComboseWriter"], "concatWriter": ["comvertWriter", "comcatWriter", "comvertFile", "comcatWrite", "coatReader", "concatsReader", "cocatFile", "comcatReader", "coatFile", "concatsWriter", "comvertWrite", "concatWrite", "comvertReader", "convertFile", "convertWrite", "conatWriter", "cocatReader", "convertWriter", "concatsFile", "concatReader", "conatWrite", "coatWriter", "coatWrite", "cocatWriter", "cocatWrite", "concatsWrite", "conatReader", "comcatFile", "convertReader", "conatFile"], "fails": ["ifailing", "ifailed", "Failing", "failing", " failing", "malls", "mocks", "lailing", "frils", "mails", "lailed", "Fils", "facails", "lails", "mailed", "Fails", "facocks", "mailing", "ifocks", " focks", "ifails", " failed", "fils", "frails", "focks", "facailed", " falls", "lalls", "facailing", "frailed", "Failed", "frailing", "lils", "failed", "falls"], "link": ["remote", "child", "ln", "task", "display", "add", "linked", "node", "source", "log", "links", "push", "close", "embed", "match", "map", "c", "mark", "check", "set", "code", "address", "load", "loc", "relation", "l", "share", "open", "line", "skip", "script", "self", "ink", "inline", "follow", "Link", "li"], "path": ["PATH", "ath", "key", "image", "string", "p", "full", "pattern", "src", "entry", "file", "source", "location", "alias", "prop", "resource", "join", "data", "template", "match", "root", "id", "uri", "prefix", "str", "text", "relative", "ref", "loc", "kind", "Path", "route", "input", "hex", "href", "style", "format"], "url": ["mail", "Url", "hl", "html", "li", "string", "char", "this", "r", "mount", "location", "source", "gl", "ssl", "resource", "host", "build", "id", "il", "abs", "uri", "web", "http", "nl", "sl", "str", "ll", "browser", "address", "ref", "loc", "rel", "l", "get", "null", "request", "lr", "URL", "ls", "ur", "href", "ul", "addr"], "inputStream": ["Inputstream", "InputSteam", " inputSet", " inputSteam", "inTime", "InputTime", " inputstream", "outputStyle", "InputStyle", "InputStream", "instream", "inStream", " inputTime", "inputTime", "inSet", "inputSteam", "outputstream", "inputstream", "InputSet", "inputSet", "outputSteam", "inputStyle", " inputStyle"], "jsFile": ["javascriptTable", "jsName", "jsFilename", "jsPath", "cssTable", "JsFilename", "javascriptfile", " jsfile", "cssPath", " jsFilename", "JsPath", "jFilename", "jName", "javascriptPath", "javascriptFilename", " jsPath", "cssFilename", "javascriptName", "jsfile", "Jsfile", "jPath", " jsName", "cssfile", "jsTable", "cssFile", "JsFile", "jFile", " jsTable", "javascriptFile"], "fileName": [" filePath", "filePath", "FilePath", " fileHash", "fileHash", "FileHash", "filename", "getName", "getHash", "FileName", "getname", "getPath", "Filename", " filename"], "outputStream": [" outputStyle", " outputstream", "Outputstream", "OutputForm", " outputSteam", "outputStyle", "outputForm", "writeStream", "OutputStyle", "writeSteam", "OutputStream", "outputSet", "inputForm", "OutputSteam", "inputSteam", "writeSet", "inputstream", "outputstream", "OutputSet", " outputSet", "writestream", "outputSteam", " outputForm", "inputStyle"], "first": ["then", "initial", "each", "now", "quick", "true", "same", "continue", "unique", "master", "false", "current", "index", "fourth", "stack", "last", "second", "success", "all", "ind", "First", "start", "sort", "important", "next", "must", "default", "top", "seconds", "only", "send", "valid", "st", "front", "fast", "third", "open", "real", "latest", "self", "prev", "primary", "natural"], "reader": ["iterator", "rer", "writer", "this", "inner", "stream", "ocr", "loader", "r", "rr", "layer", "file", "buffer", "builder", "read", "parser", "resource", "rar", "io", "data", "context", "handler", "driver", "http", "ner", "rl", "Reader", "er", "ro", "mr", "rc", "core", "row", "runner", "input", "wrapper", "rator"], "jsCompressor": ["jscomposer", "cssRepression", "cssComposer", "jsRepressor", "jsRepression", "jsBuffression", "jsBuffoser", "jscompiler", "cssRepressor", "jsRepiler", "jsBuffiler", "cssCompressor", "cssReposer", "jsComposer", "cssRepiler", "cssCompiler", "jsCompiler", "jsCompression", "cssCompression", "jscompression", "jsBuffressor", "jscompressor", "jsReposer"], "s": ["cs", "full", "is", "ts", "lines", "tes", "ps", "ats", "ds", "ers", "ns", "S", "gs", "tags", "es", "ss", "xs", "less", "ies", "fs", "ids", "eds", "y", "details", "parts", "ms", "ings", "t", "pers", "l", "words", "os", "ens", "qs", "hs", "ls"], "s1": ["s9", "ps1", " s0", "es2", "idFirst", "ls1", "ls0", " s3", "esFirst", "s81", "sFirst", "s0", "pers0", "pers1", "ys3", "ps0", "id1", "id2", "ys1", "id9", "ys0", "ys81", "es1", "es9", "ls81", "ls3", " s81", "s3"], "i": ["im", "bi", "ch", "ip", "ri", "oi", "p", "mi", "it", "is", "ui", "v", "um", "iu", "ion", "io", "ci", "ori", "j", "di", "ifier", "ig", "id", "y", "ic", "ity", "us", "o", "ai", "I", "iat", "ie", "pi", "iti", "ati", "ia", "ii", "li"], "s2": ["esTwo", "S02", "S2", "gs2", "es2", "ssTwo", "ss2", "s22", "ms2", "zSecond", "ms22", "msTwo", "gsSecond", "tes2", "ztwo", "tes02", "SSecond", "s02", "stwo", "z2", "Stwo", "tes1", "gstwo", "z02", "ms02", "es1", "es02", "sTwo", "tesTwo", "sSecond", "ss02", "ss22", "gs02"], "i1": ["e1", "oOne", "it1", "iOne", "p2", "i0", "e4", "pOne", "o0", "a2", "p4", "i4", "p0", "a1", "itOne", "it0", "i01", "o4", "a01", "p01", "p1", "aOne", "o1", "it4", "e2", "i2", "eOne", "it01", "it2"]}}
{"id1": "12766377", "id2": "932225", "code1": "    public Document index() throws CrawlingException {\n        log.debug(\"BEGINIG indexing page [code=\" + getCode() + \"] ...\");\n        URL url = null;\n        InputStream in = null;\n        String contentType = null;\n        try {\n            url = new URL(getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath());\n            HttpURLConnection pageContent = (HttpURLConnection) url.openConnection();\n            if (pageContent.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                log.debug(\"page pk[\" + getCode() + \",\" + url.toExternalForm() + \"] is invalid\");\n                return null;\n            }\n            String redireccion = pageContent.getHeaderField(\"location\");\n            if (redireccion != null) {\n                log.debug(\"Page \" + url.toExternalForm() + \" redirected to \" + redireccion);\n                recordLink(redireccion);\n                return null;\n            }\n            contentType = pageContent.getContentType();\n            in = new BufferedInputStream(pageContent.getInputStream(), 32768);\n        } catch (MalformedURLException e) {\n            log.error(\"Invalid page address\", e);\n        } catch (ConnectException e) {\n            if (getServer() != null) {\n                log.error(\"Unable to connect to page: \" + getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath(), e);\n            }\n        } catch (UnknownHostException uhe) {\n            log.warn(\"Unknow host indexing page \" + getURL(), uhe);\n        } catch (IOException e) {\n            log.warn(\"Unable to index page \" + getURL(), e);\n        }\n        Document doc = generateDocument(contentType, in);\n        log.debug(\"END indexing page [code=\" + getCode() + \"]\");\n        return doc;\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 0, "substitutes": {"index": ["access", "scan", "link", "execute", "view", "html", "version", "image", "find", "suggest", "display", "process", "se", "xx", "connect", "download", "node", "query", "update", "author", "read", "archive", "build", "parse", " Index", " ingest", "search", "evaluate", "service", "create", "address", " analyse", "insert", "review", "write", "open", "tree", "blog", "list", "show", "Index", "print", "document", "ind", " indexed"], "url": ["mail", "Url", "link", "hl", "util", "server", "pl", "path", "cert", "html", "p", "org", "char", "xml", "loader", "r", "mount", "cl", "lb", "b", "location", "log", "gl", "ssl", "resource", "build", "bel", "user", "kl", "dl", "il", "base", "uri", "github", "web", "http", "nl", "sl", "el", "rl", "str", "impl", "fl", "t", "browser", "address", "ll", "https", "loc", "au", "rel", "un", "ref", "l", "get", "lr", "www", "URL", "ml", "ls", "ur", "ul", "addr"], "in": ["inn", "pc", "inc", "up", "is", "it", "ain", "inv", "inner", "xml", "isin", "ini", "r", "din", "file", "min", "bin", "asin", "i", "io", "gin", "on", "m", "from", "po", "In", "conf", "sum", "ins", "t", "en", "out", "er", "IN", "o", "l", "con", "s", "cin", "input", "rin", "mc", "ar", "as", "inf", "ind"], "contentType": ["conditionTyp", "conditionType", " contentStyle", "ontentLength", "contentCode", "contentTypes", " contentTyp", "ContentLength", "contentFormat", "ontenttype", " contentLength", "documentCode", "commentTyp", "Contenttype", "ontentType", "commentType", "contenttype", "documentLength", " contentCode", "ContentTypes", "contentLength", "commentFormat", "contentStyle", "conditionFormat", "contentTyp", "ContentType", "ontentTypes", " contenttype", "documentType", " contentFormat", "ContentCode", " contentTypes", "conditionStyle", "commentStyle", "documentTypes"], "pageContent": ["wikiCa", "articleComment", "contentContents", "serverComment", "pageComment", "pageOne", "pixelOne", " pageComment", "contentSync", " pagecontent", "articleSync", "pixelCa", "profileContents", "articlecontent", " pageOne", "profileComment", " pageAuth", "serverContext", " pageConn", "pixelContent", "PageContents", " pageContents", "contentComment", "PageAuth", "profileContext", "articleContent", "articleAuth", "pagesContent", "contentContent", "resultContent", "resultConn", "pagesCode", " pageCode", "resultCode", "resultContents", "pageConn", "wikiContent", "PageContent", "serverContent", "pageAuth", "pageCa", "pagesConn", " pageSync", "pagesContents", "profileContent", "serverContents", "articleContents", "wikiOne", " pageCa", "pageContext", "pageCode", "wikicontent", " pageContext", "Pagecontent", "pageSync", "pageContents", "pagecontent", "pixelcontent"], "redireccion": ["redirencension", "redoreccions", "redileccison", "redirecedison", "redorecION", "redIREncion", "redirequestison", "redireccao", "redilencension", "redilencion", "redirecsison", "redorecion", "redirecsension", "redoreccION", "redIREcciton", "redoreccison", "redirecions", "redileccion", "redirepcison", "redireccions", "redirecciton", "redorecison", "redIREnciton", "redirecedion", "redirequestion", "redirecsion", "redIREccION", "redireccION", "redirencion", "redIREccion", "redorecions", "redirecION", "redirencison", "redirebcao", "redirecison", "redirencION", "redilecciton", "redirecsION", "redireccension", "redirecion", "redirenciton", "redirecedension", "redileccension", "redirepcION", "redirebcison", "redirebciton", "redIREncison", "redireccison", "redirecsiton", "redIREccison", "redirequestiton", "redilencison", "redirencao", "redileccao", "redirecsao", "redirebcion", "redilencao", "redirepcions", "redIREncION", "redilenciton", "redirequestION", "redirecediton", "redirepcion", "redoreccion", "redirecsions"], "doc": ["msg", "html", "exp", "tx", "it", "mat", "def", "xml", "nt", "content", "article", "dec", "ent", "file", "de", "log", "DOC", "Doc", "m", "Document", "po", "pdf", "oc", "coll", "cam", "page", "good", "pic", "st", "md", "t", "out", "dc", "d", "db", "word", "tree", "document", "dr", "mk", "df"]}}
{"id1": "4686922", "id2": "17202158", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResources2Stream", "extractResourceFromfile", "extractResource2Stream", "extractResource2file", "extractResourceTofile", "extractResourcesTofile", "extractResourceToStream", "extractResources2File", "extractResourceFromFiles", "extractResourceAsFile", "extractResourceToFiles", "extractResource2Files", "extractResourceAsStream", "extractResourcesToFiles", "extractResourceAsFiles", "extractResourceFromStream", "extractResourceAsfile", "extractResourcesToStream", "extractResource2File", "extractResourcesToFile", "extractResources2file", "extractResources2Files", "extractResourceFromFile"], "resourcePath": ["attributeUrl", "resourceName", " resourceIn", "ResourceIn", "resourceLocation", " resourceName", "uriUrl", "resourcepath", "attributePath", "templatepath", "ResourceName", "templateIn", "Resourcepath", "uriLocation", "ResourcePath", "templatePath", "attributeName", " resourcepath", "attributeLocation", "uriPath", "resourceUrl", "ResourceLocation", "ResourceUrl", "resourceIn", "templateName", "uriName"], "dest": ["origin", "orig", "parent", "nom", "gov", "Dest", "this", "src", "target", "home", "w", "temp", "source", "lit", "opt", "etc", "comb", "prop", "tmp", "dat", "coord", "result", "cont", "good", "img", "desc", "mem", "loc", "des", "output", "dir", "null", "to", "end", "dist", "trans", "self", "sp", "cat", "rest", "decl"], "in": ["inn", "al", "inc", "up", "ln", "init", "none", "raw", "is", "it", "mi", "sin", "inner", "isin", "ini", "r", "din", "file", "source", "all", "bin", "i", "resource", "gin", "local", "on", "id", "f", "m", "from", "In", "conf", "or", "ins", "inside", "no", "IN", "ne", "l", "con", "iter", " din", "cin", "rin", "input", "re", "mc", "inf", "ind"], "out": ["cache", "obj", "ch", "writer", "it", " Out", "Out", "pool", "inner", "v", "nt", "w", "aos", "outer", "b", "sys", "cos", "i", "io", "tmp", "conv", "on", "f", "exit", "again", "res", "ot", "cn", "t", "en", "no", "at", "o", "ne", "write", "output", "client", "os", "null", "con", "to", "oss", "stable", "co", "na", "outs", "OUT", "net", "print", "note", "can", "n", "col", "ou"]}}
{"id1": "18504192", "id2": "1769771", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" Copyfile", " transferfile", " CopyFiles", "CopyFile", "copyStream", "CopyStream", "CopyFiles", " CopyFile", " transferFile", " CopyStream", " transferStream", " transferFiles", "Copyfile", "copyFiles", "copyfile"], "in": ["inn", "inc", "up", "is", "it", "isin", "old", "din", "mm", "b", "i", "gin", "edIn", "on", "id", "from", "In", "el", "or", "ic", "ins", "en", "IN", "o", "vin", "l", "n", "input", "cin", "rin", "as", "inf", "ind"], "out": ["it", "Out", "g", "v", "ex", "nt", "w", "b", "log", "err", "i", "k", "io", "serv", "gt", "po", "ot", "help", "t", "at", "o", "ne", "l", "output", "os", "to", "s", "oss", "outs", "OUT", "net", "n", "ou"], "source": ["Source", "scan", "volume", "sequence", "iterator", "access", "use", "origin", "init", "system", "shell", "pse", "back", "sin", "inner", "ource", "scope", "src", "before", "sample", "se", "subject", "copy", "info", "file", "query", "start", "resource", "me", "parse", "local", "match", "template", "comment", "space", "search", "from", "force", "instance", "store", "service", "inside", "ources", "create", "spec", "seed", "open", "position", "input", "ie", "SOURCE", "reader", "style", "secret"], "destination": ["coordification", "seeinator", "coordregation", " destension", "restinated", "destregation", "comato", "comination", " destification", "seeension", " destato", "Destation", "restinator", "comregation", "coordato", "destinator", "Destinator", "destato", " destregation", "coordination", "destification", "destinated", " destation", "restation", "Destinated", "Destension", "destation", " destinator", " destinated", "destension", "seeination", "comification", "restination", "Destination", "seeinated"]}}
{"id1": "13362846", "id2": "3767903", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setCont\u00ednux", "setCont\u00ednu", "setcontenu", "setContensenue", "setContennU", "setContenue", "setContenux", "setcontenue", "setContennu", "setcontensenux", "setcontenU", "setcontensenue", "setContensenu", "setContennue", "setContennux", "setCont\u00ednue", "setcontensenu", "setCont\u00ednU", "setcontenux", "setContenU", "setContensenU", "setContensenux", "setcontensenU"], "contenuFichier": ["contenuFicheer", "contenuFolfier", "contenuFithier", "contenuFochier", "contenuVichyr", "contenuFiverier", "contenuFolfieri", "contenuFiveraire", "contenuMicheiere", "contenuVichie", "contenuFechiere", "contenuFignaire", "contenuFechieri", "contenuMicheer", "contenuFsichire", "contenuMicheaire", "contenuFithyr", "contenuFuffier", "contenuFihier", "contenuFsrenchire", "contenuFchie", "contenuFichaire", "contenuFicheier", "contenuFechiest", "contenuFamilyachie", "contenuFuffer", "contenuFchiere", "contenuFithiere", "contenuFileochie", "contenuVichier", "contenuVichiere", "contenuFsicher", "contenuFicheiere", "contenuFileichiers", "contenuVchIER", "contenuFamilyichiere", "contenuFihyr", "contenuFochiers", "contenuVechiere", "contenuFileochier", "contenuFigniere", "contenuMichier", "contenuVechyr", "contenuFsecher", "contenuFuffieri", "contenuFrenchieri", "contenuFichie", "contenuFsechire", "contenuFichtie", "contenuFechire", "contenuFileochiers", "contenuFCher", "contenuMichaire", "contenuFichIER", "contenuFochIER", "contenuFichieri", "contenuFamilyachiere", "contenuFachier", "contenuFicheieri", "contenuFachiere", "contenuFrenchaire", "contenuFchier", "contenuFChaire", "contenuFigner", "contenuFchIER", "contenuFileochiere", "contenuFChiere", "contenuFignier", "contenuFicheiers", "contenuFithiest", "contenuFamilyichie", "contenuVechiest", "contenuFicheire", "contenuFochie", "contenuMicheier", "contenuFichtier", "contenuFrenchier", "contenuFichyr", "contenuFsichieri", "contenuVchiere", "contenuFachorie", "contenuFsichier", "contenuFiverieri", "contenuVichIER", "contenuFileichier", "contenuFileichie", "contenuVechier", "contenuFamilyichier", "contenuFihiere", "contenuVchie", "contenuFechier", "contenuFamilyachorie", "contenuFithie", "contenuFamilyachier", "contenuFicher", "contenuVichiest", "contenuFithorie", "contenuFachiers", "contenuFechyr", "contenuVchier", "contenuFicheie", "contenuFochiere", "contenuFichiere", "contenuFichtIER", "contenuFicheaire", "contenuFsrenchier", "contenuFicheorie", "contenuFecher", "contenuFsrenchieri", "contenuFsechieri", "contenuFichtiere", "contenuFsichaire", "contenuFsrenchaire", "contenuFrenchire", "contenuFachie", "contenuFichire", "contenuFamilyichorie", "contenuMicher", "contenuFichiers", "contenuFuffire", "contenuFolfer", "contenuFileichiere", "contenuFichorie", "contenuFolfire", "contenuFChier", "contenuFichiest", "contenuFsechier", "contenuMichiere", "contenuFihiest", "contenuFiverire"], "fichierElectronique": ["fichierelectreniques", "fichierElectchronoch", "fichierElectchronicity", "fichierCentronique", "fichierElectroneiq", "fichierSelectroneoch", "fichierelectrenique", "fichierElectrenic", "fichierelectronic", "fichierSelectronoch", "fichierAdministronique", "fichierElectrenaire", "fichierAdministroniques", "fichierElectchronique", "fichierelectrenic", "fichierAdministroneiq", "fichierElectroneie", "fichierElectronaire", "fichierElectricie", "fichierElectronier", "fichierElectronsiques", "fichierCentronicy", "fichierCentronius", "fichierElectronsiq", "fichierTransferronic", "fichierElectromius", "fichierElectronsique", "fichierElectroneic", "fichierElectrenius", "fichierElectroneipolar", "fichierSelectronicity", "fichierElectreniques", "fichierAdministroneie", "fichierElectchronaire", "fichierSelectroneique", "fichierElectronic", "fichierElectradorique", "fichierCentRONius", "fichierElectradoric", "fichierElectrenique", "fichierElectroneiques", "fichierCentRONique", "fichierCentronaire", "fichierElectronoch", "fichierElectronsie", "fichierElectronsicity", "fichierElectroneius", "fichierElectroneaire", "fichierElectchronius", "fichierSelectroneicity", "fichierTransferronius", "fichierelectrenier", "fichierelectroniques", "fichierAdministroneique", "fichierElectchroniques", "fichierSelectronique", "fichierElectromic", "fichierElectrontique", "fichierElectromaire", "fichierElectronie", "fichierElectoniques", "fichierTransferradorique", "fichierCentRONaire", "fichierElectronticity", "fichierelectronier", "fichierElectromique", "fichierElectriciques", "fichierelectronique", "fichierTransferradorie", "fichierElectromipolar", "fichierTransferradorius", "fichierElectradorius", "fichierTransferronie", "fichierElectroneicity", "fichierElectradorie", "fichierTransferronique", "fichierElectroniq", "fichierAdministroneiques", "fichierTransferradoric", "fichierElectonic", "fichierElectRONaire", "fichierElectRONique", "fichierElectroniques", "fichierElectrenier", "fichierElectronicity", "fichierElectronicy", "fichierElectriciq", "fichierElectchronicy", "fichierSelectroniques", "fichierElectromie", "fichierElectronipolar", "fichierAdministronie", "fichierElectronsier", "fichierElectrenicy", "fichierElectricique", "fichierElectronius", "fichierElectrontipolar", "fichierCentRONicy", "fichierElectonier", "fichierElectronsic", "fichierElectRONicy", "fichierElectronsoch", "fichierAdministroniq", "fichierSelectroneiques", "fichierElectonique", "fichierElectromicity", "fichierElectrontaire", "fichierElectroneoch", "fichierElectroneique", "fichierElectRONius"], "utilisateurCourant": ["utilisateurRepresentant", "utilisateurParticipant", "utilisateursGovernant", "utilisateursCourants", "utilisateurCourante", "utilisateurGovernants", "utilisateurParticipants", "utilisateurGovernante", "utilisateursGoverniant", "utilisateurParticipiant", "utilisateursCouriant", "utilisateurCourants", "utilisateurRepresentante", "utilisateursCourant", "utilisateurGoverniant", "utilisateursCourante", "utilisateurRepresentants", "utilisateurRepresentiant", "utilisateurGovernant", "utilisateurCouriant", "utilisateurParticipante", "utilisateursGovernante", "utilisateursGovernants"], "support": ["port", "access", "cap", "system", "replace", "evidence", "document", "allow", "success", "context", "profile", "library", "cover", "media", "accept", "storage", "prototype", "force", "see", "install", "feature", "service", "help", "pport", "collection", "Support", " Support", "language", "SUP", "proof", "supported", "please", "supp", "know", "history", "share", "null", "trust", "control", "use", "format"], "ficheDocument": ["ficiDocument", "fruitDocument", "facheTree", "ficiTransaction", "foyerDocument", "hicheDocument", "fcheDatabase", "fliciMatrix", "fiqueDatabase", "fifaDocuments", "hachedocument", "bicheTree", " frenchDatabase", "ficheDocuments", "fiqueDocument", "FicheDatabase", "facheDoc", "ficheMatrix", "hichedocument", "ficheDoc", "facheDocument", "frenchDoc", "fiqueDescription", "ficidocument", "fitimeTransaction", "flicheDatabase", " ficheDatabase", "fcheDocument", "flicheMatrix", "ficheTree", "ficiJournal", "flicheTransaction", "bicheDoc", "facheTransaction", "foyerDoc", "fayeDatabase", "ficheDatabase", "hicheJournal", " frenchDocument", "FicheDocuments", "fifaDocument", "frenchDocument", " ficheDescription", "fcheTree", "fayeDocuments", "fliciTransaction", "frenchMatrix", "fruitJournal", "fifaDoc", "frenchTransaction", "ficheJournal", "hacheJournal", "frenchDatabase", "frenchDescription", "fitimeDocument", "foyerDatabase", "bacheDocument", "flicheDocument", "facheJournal", "hacheTransaction", "fachedocument", "bicheDatabase", "fruitTransaction", "fliciDocument", "fichedocument", "ficheTransaction", "ficiMatrix", "FayeDatabase", "fruitdocument", "fayeDocument", "FicheDoc", "FayeDocuments", "fitimeDescription", "bacheTree", "fcheDoc", "bacheDatabase", "frenchDocuments", "fitimeDatabase", "fifaDatabase", "bicheDocument", "ficheDescription", "hacheDocument", "facheDatabase", " frenchDescription", "fitimeMatrix", "FayeDocument", "FayeDoc", "fliciDatabase", "hicheTransaction", "FicheDocument", "ficiDatabase", "bacheDoc", "foyerTree", "fayeDoc"], "nomFichier": ["nomPFoililler", "nomPichire", "nomPichomer", "nomFiverIER", "nomFichoanger", "nomFicheer", "nomFicire", "nomFilicjer", "nomFicher", "nomFicER", "nomFachancer", "nomFichanger", "nomFericanger", "nomFolfiere", "nomFicerer", "nomPFoilER", "nomNolfire", "nomFachomer", "nomFchire", "nomFchiner", "nomNichie", "nomFericancer", "nomPFichier", "nomFicheiner", "nomUFichier", "nomFihire", "nomFiciller", "nomFilicER", "nomFoilier", "nomPachier", "nomFichjer", "nomFichire", "nomFicheier", "nomPacherer", "nomFcherer", "nomFicheire", "nomUFachire", "nomFicjer", "nomNolfiere", "nomPFichjer", "nomFachanger", "nomFericIER", "nomUFachery", "nomFiverire", "nomFihery", "nomFihier", "nomPichier", "nomFoiljer", "nomFiliciller", "nomFachire", "nomFichoIER", "nomFachIER", "nomFachiere", "nomFchomer", "nomFiverier", "nomPFichER", "nomFoililler", "nomFichoancer", "nomFachery", "nomFichoier", "nomFicheiere", "nomFachie", "nomFichiller", "nomPachomer", "nomPicherer", "nomNolfier", "nomFichiner", "nomNolfie", "nomUFichire", "nomFichomer", "nomFilicier", "nomUFichery", "nomFchier", "nomFichIER", "nomFericier", "nomFiverery", "nomPachire", "nomFicier", "nomFolfie", "nomFicomer", "nomFicheie", "nomFoilER", "nomNichire", "nomFicherer", "nomPFichiller", "nomUFachier", "nomFachier", "nomNichiere", "nomFihIER", "nomNichier", "nomFacher", "nomFolfire", "nomFichiere", "nomFichery", "nomPFoilier", "nomFacherer", "nomPFoiljer", "nomFchiere", "nomFcher", "nomUFichIER", "nomFichancer", "nomUFachIER", "nomFolfier", "nomFichie", "nomFachiner", "nomFichER"], "extension": ["expension", "xtending", "strension", "Extending", "extensions", "protitude", "Extensions", "strensions", "extending", "expention", "extractor", "xtension", "protention", "contension", "expractor", "protension", "extitude", "contractor", "contention", "expitude", "protractor", "xtensions", "strending", "Extension", "contitude", "extention"], "fichierElectroniqueExistant": ["fichierElectroniqueLocalistance", "fichierElectroniqueInvant", "fichierElectroniqueInclusive", "fichierElectroniqueAssistant", "fichierElectroniqueEXert", "fichierElectroniqueExclusive", "fichierElectronogramLocalistent", "fichierElectronicityInistant", "fichierElectroniquePlusistent", "fichierElectronicityExistant", "fichierElectroniqueInistant", "fichierElectronoguePersistent", "fichierElectroniqueEXistant", "fichierElectroniquePersistant", "fichierElectronogramExclusive", "fichierElectronicityInistance", "fichierElectroniquePresentiker", "fichierElectronogramLocalistance", "fichierElectronogueExiker", "fichierElectronogueExistant", "fichierElectronoguePersiker", "fichierElectroniqueExiker", "fichierElectroniquePlusister", "fichierElectroniqueExert", "fichierElectronicityExert", "fichierElectronogramExistant", "fichierElectronogueExister", "fichierElectroniqueExplert", "fichierElectronogramLocalistant", "fichierElectroniquePresentister", "fichierElectronogramExistance", "fichierElectroniqueEXistance", "fichierElectroniqueExister", "fichierElectroniqueExistance", "fichierElectronicityInvant", "fichierElectroniqueLocalclusive", "fichierElectroniquePresentistant", "fichierElectronicityInert", "fichierElectronogueExistent", "fichierElectronogramExistent", "fichierElectroniqueInistance", "fichierElectroniquePersiker", "fichierElectroniqueExplistant", "fichierElectroniqueExplistance", "fichierElectroniqueLocalistent", "fichierElectroniqueAssclusive", "fichierElectroniqueInert", "fichierElectroniquePlusistant", "fichierElectroniqueExplvant", "fichierElectronicityExvant", "fichierElectroniqueExistent", "fichierElectroniqueLocalistant", "fichierElectroniquePresentistent", "fichierElectroniqueExvant", "fichierElectroniqueEXvant", "fichierElectroniquePersister", "fichierElectroniquePlusiker", "fichierElectronicityExistance", "fichierElectronoguePersister", "fichierElectroniqueAssistent", "fichierElectroniquePersistent", "fichierElectronoguePersistant", "fichierElectroniqueAssistance", "fichierElectronogramLocalclusive", "fichierElectroniqueInistent"], "idIgid": ["idAmgis", "idIgoid", "idIegkey", "idIIgzid", "idIkgid", "idIgzida", "idIigmaddress", "idIgdid", "idAglimit", "idIgcida", "idIIgido", "idIegids", "idIgcido", "idIvgdata", "idImgis", "idIgaddress", "idAgaddress", "idIgdido", "idAmglimit", "idIkglimit", "idIIgzida", "idAgis", "idAmgaddress", "idIkgaddress", "idIIgoid", "idIgzid", "idImglimit", "idIigmis", "idIgids", "idIgido", "idIgcoid", "idIigmlimit", "idImgaddress", "idIIgzoid", "idImgdata", "idImgkey", "idIegid", "idImgids", "idImgid", "idIvgids", "idIgis", "idIgdoid", "idIgzoid", "idIIgid", "idIgdata", "idIIgzido", "idIglimit", "idIvgid", "idIvgkey", "idIgkey", "idIigmid", "idIgida", "idIgcid", "idAgid", "idIgdida", "idIegdata", "idIkgis", "idAmgid", "idIIgida", "idIgzido"], "inputStream": ["InputThread", "Inputstream", "InputSteam", "helloSteam", " inputSteam", "imageStream", " inputLoop", "InputTime", " inputstream", "helloStreamer", " inputStreamer", "imageTime", "helloStream", "helloChannel", "InputStream", "inputStreamer", "imageLoop", "outputChannel", "inputChannel", " inputTime", "inputTime", "inputSteam", "inputstream", "outputstream", " inputChannel", "inputThread", "outputThread", "imageSteam", "outputSteam", " inputThread", "inputLoop", "InputLoop", "outputStreamer"], "outputStream": ["webView", "sequenceStreamer", " outputStyle", "sequenceStyle", "OutputForm", " outputSteam", "outputStyle", "outputForm", "writeStream", "OutputStyle", "OutputView", "writeSteam", "OutputStream", "OutputStreamer", "webSteam", "inputForm", "inputView", "sequenceSteam", "outputView", "writeView", "OutputSteam", "inputSteam", "webStreamer", "sequenceStream", " outputView", "outputSteam", "webStream", " outputStreamer", "writeForm", "outputStreamer"], "typeMime": ["typeRIME", "typeRme", "TypeMime", "Typemime", "typeSmme", "typeSmime", "TypeMme", "typemme", "typemime", "typeMim", "typeRim", "TypemIME", "typeSmim", "typemim", "typeMme", "typeRime", "Typemme", "typeSmIME", "TypeMim", "typemIME", "Typemim", "typeMIME", "TypeMIME"], "tailleFichier": [" tailleficheier", " tailleFuzziers", " tailleficheiers", " tailleFixie", " tailleFichie", " tailleFicheier", " tailleFichiers", " tailleFuzzie", " taillefichies", " tailleFuzzier", " tailleFuzzies", " tailleFicheie", " tailleficheie", " tailleficheies", " taillefichiers", " tailleFixiers", " taillefichier", " taillefichie", " tailleFixies", " tailleFicheies", " tailleFixier", " tailleFichies", " tailleFicheiers"]}}
{"id1": "804637", "id2": "6171406", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewrites", "readAndrewWrite", "readAndReprites", "readAndResWrite", "readAndResend", "readAndReprite", "readAndResrites", "readAndrewrites", "readAndRepWrite", "readAndrewend", "readAndRewWrite", "readAndResrite", "readAndRepend", "readAndRewend", "readAndrewrite"], "inFile": [" inFilename", "outFilename", "InFile", "outfile", "inTime", "INTime", "inputPlace", "inFace", "INFILE", "initPlace", " infile", "docFILE", "initFilename", "inFilename", "inputFilename", "iTime", "INFile", "initFace", "INFace", "InFilename", "iFILE", "Infile", "infile", "INPlace", "docFilename", "docFile", "inputFile", "INFilename", "inPlace", "iFile", "docTime", "iFilename", "initFile", "inFILE", "inputFace"], "outFile": [" outFILE", "outFilename", "reportFile", "outfile", "reportFILE", "nameFile", "nameFilename", "checkfile", "toFile", "inFilename", " outFilename", "reportfile", "checkFile", "nameFILE", "checkFILE", "checkFilename", "reportFilename", "infile", "toFilename", "outFILE", "toFILE", "namefile", "tofile", " outfile", "inFILE"], "iis": ["diIs", " iisc", " iIS", "IIs", "Ii", "eis", "liIs", "diiss", " ii", "iisc", "dii", "liisc", " iIs", " iiss", "Iis", "iIs", "iiss", "liis", "aiis", "iiris", "aiIS", "Iiss", "iiIs", "aiIs", "iris", "iiisc", "liris", " iris", "eIS", "iiis", "eIs", "diis", "iIS", "ii"], "dcmParser": ["dpmStatement", " dcmLoader", "dmmparser", "DpmParser", "DpmReader", "dpmPar", "dmmmParser", "decmarser", "Dpmparser", "dfmLoader", "dmmReader", " dpmarser", "decmReader", "DcmReader", "dcommParser", "dpmParser", "dpmPrivate", " dcmAssistant", " dpmparser", "deromReader", "dmReader", "dcfStatement", "deromParser", " dpmAssistant", "DcmBuilder", "DcmAdapter", "dcomBuilder", "deromarser", " dpmParser", " dpmPrivate", " dcmStatement", "dmarser", "dcrparser", "dcomLoader", "dromReader", "dmmarser", "dmmParser", "dmmmparser", "dcomParser", "dcfReader", "dpmBuilder", "dgrPar", "dpmReader", "dromparser", "dcmStatement", "dcmPrivate", " dpmListener", " dpmStatement", "dmparser", "dpmLoader", "dfmReader", "drumPar", "dpmListener", " dcmarser", "dfmParser", "Dcmparser", "dgrReader", "dcmAdapter", "dmoduleAssistant", "dmmAdapter", "DcmPar", "dcmLoader", "dromListener", "dpcParser", "dpcReader", "dcrBuilder", " dcmReader", "dromarser", "dfmBuilder", "DpmBuilder", " dcmparser", "dpcAssistant", "dcmPar", "dcommListener", " dcmPrivate", " dcmBuilder", "decmParser", "dgrStatement", "decmparser", "dcmAssistant", "drumBuilder", "dcmListener", "dcommReader", "DcmParser", " dpmPar", "drumReader", " dpmLoader", "dmParser", "dcmReader", " dcmListener", "dcommAssistant", "dmodulePrivate", " dcmPar", "DpmAdapter", "dcomReader", "dcmarser", "dgrParser", "dpmparser", "dmmmReader", "dromParser", "DpmPar", "dpmAssistant", "dcfParser", "dcrParser", "dpmAdapter", "dromAssistant", "drumParser", " dpmBuilder", " dpmReader", "dpmarser", "dcfPar", "deromparser", "dpcPrivate", "dmoduleReader", "dmoduleParser", "dmmmAdapter", "dcmparser", "dcmBuilder", "dcrReader"], "ds": ["obs", "cs", "ws", "gd", "bs", "ods", "Ds", "rs", "tes", " DS", "ps", "drivers", "sets", "dh", "ns", "aos", "dx", "der", "DS", "hd", "bd", "sys", "ys", "ils", "gs", "sd", "dat", "ss", "es", "data", "uds", "xs", " des", "sv", "dl", "fs", "services", "ads", "eds", "its", "details", "in", "da", "ims", "ins", "dds", "pers", "vs", "d", "des", "db", "eps", "dos", "os", "dt", "s", "dq", "js", "outs", "qs", "dd", "hs", "ks", "ls", "as", "df", "pd"], "pdReader": ["vdWriter", "pedRunner", "xdHelper", "ddHelper", "tdParser", "pdParser", "dpLoader", "pdCar", "ddParser", "ddRunner", "vdReader", "pedReader", "pdRunner", "pdHelper", "ddLoader", "pedLoader", "pdLoader", "ddRead", "ddWriter", "hdReader", "dpReader", "ddReader", "vdHelper", "pedCar", "pdRead", "tdRead", "hdWriter", "xdReader", "xdLoader", "xdWriter", "dpRunner", "vdLoader", "ddCar", "dpCar", "hdRead", "hdParser", "tdWriter", "tdReader"], "out": ["obj", "cache", "conn", "p", "Out", "ex", "v", "cmd", "pos", "io", "one", "data", "res", "in", "str", "end", "list", "name", "auto", "msg", " err", "full", "writer", "cb", "inv", "pool", "opt", "on", "sw", "cfg", "we", "at", "gr", "os", "con", "oss", "outs", "screen", "OUT", "net", "raw", "cn", "up", "nt", "w", "outer", "ent", "all", "nr", "err", "tmp", "conv", "gt", "gen", "id", "c", "sum", "ins", "o", "output", "null", "co", "js", "desc", "ou", "go", "ch", "it", "inner", "aos", "flush", "sys", "log", "serv", "inter", "txt", "status", "t", "en", "client", "s", "to", "over", "n"], "dcmEncParam": ["dcmencMsg", "dmmencMsg", "dmmEncPar", "dmmEnNum", "dmmencNum", "dmmEncParam", "dcmEncVal", "dmmEnParam", "dcmEscNum", "dmmEncMsg", "dmmEnPar", "dcmDecCmd", "dcmEnParam", "dcmencParam", "dcmencPar", "dcmDecMsg", "dcmEnPar", "dcmDecParam", "dcmEscVal", "dcmEnNum", "dcmEncPar", "dmmencCmd", "dcmencCmd", "dmmEncVal", "dcmEnVal", "dcmencNum", "dcmDecNum", "dcmEncNum", "dcmEncMsg", "dmmEncNum", "dmmEncCmd", "dcmEscParam", "dcmEncCmd", "dcmEscPar", "dmmencParam"], "pdWriter": ["PDEditor", "pcWriter", "tdWriter", "dpEditor", "PDReader", "PDWrite", "pdWrite", "pidWriting", "PDWriter", "pdwriter", "dpReader", "dpWriter", "tdEditor", "pdEditor", "pidWriter", "pcWrite", "pcWriting", "pcwriter", "dpWrite", "pidwriter", "tdWriting", "tdwriter", "pidWrite", "pdWriting", "tdWrite", "tdReader"]}}
{"id1": "21754659", "id2": "20588811", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public void run() {\n        long time = System.currentTimeMillis();\n        logger.info(\"Version: \" + version);\n        String hostname = properties.getProperty(\"mercuriushost\");\n        String protocol = properties.getProperty(\"mercuriusprotocol\");\n        String port = properties.getProperty(\"mercuriusport\");\n        String path = properties.getProperty(\"mercuriuspath\");\n        String action = properties.getProperty(\"mercuriusaction\");\n        logger.info(\"Getting Timex Data --- \" + getTimeDifferent(time));\n        String xml = timexfrmk.getUnsynchedSessionsXMLFormat();\n        logger.info(\"Done getting Timex Data --- \" + getTimeDifferent(time));\n        if (timexfrmk.getSessionCount() > 0) {\n            try {\n                logger.info(\"Sending Timex Data to Mercurius --- \" + getTimeDifferent(time));\n                String data = URLEncoder.encode(\"action\", \"UTF-8\") + \"=\" + URLEncoder.encode(action, \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"data\", \"UTF-8\") + \"=\" + URLEncoder.encode(xml, \"UTF-8\");\n                if (isAdminFeedKeySet()) {\n                    data += \"&\" + URLEncoder.encode(\"adminfeedkey\", \"UTF-8\") + \"=\" + URLEncoder.encode(adminfeedkey, \"UTF-8\");\n                    logger.debug(\"Using adminfeedkey to authenticate\");\n                } else {\n                    Authenticator.setDefault(new CustomAuthenticator(user, password));\n                    logger.debug(\"Using user/pwd to authenticate\");\n                }\n                String u = protocol + \"://\" + hostname + \":\" + port + path;\n                logger.debug(\"Posting xml data to: \" + u);\n                URL url = new URL(u);\n                URLConnection conn = url.openConnection();\n                conn.setRequestProperty(\"User-Agent\", \"TimexMercurius/\" + version);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                StringBuffer s = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    s.append(line);\n                }\n                if (s.length() > 0) {\n                    logger.debug(s.toString());\n                    if (s.toString().indexOf(\"Result:\") != -1) {\n                        logger.info(s.toString().substring(s.toString().indexOf(\"Result:\")));\n                        if (s.toString().indexOf(\"Result: Successful\") != -1) {\n                            timexfrmk.updateSessionsStatus();\n                        }\n                    } else {\n                        logger.error(s.toString());\n                    }\n                } else {\n                    logger.info(\"No data returned\");\n                }\n                wr.close();\n                rd.close();\n            } catch (MalformedURLException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (IOException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (Exception e) {\n                logger.error(e);\n                logger.trace(e, e);\n            }\n        } else {\n            logger.info(\"There is nothing to send.  Everything has already been synchronized\");\n        }\n        timexfrmk.close();\n        logger.info(\"Done!!! Total Time: \" + getTimeDifferent(time));\n    }\n", "label": 0, "substitutes": {"getButtonSonido": ["getButtonDonido", "getbuttonSonilo", "getButtonSonida", "getButtonDonilo", "getButtonSonico", "getbuttonSonico", "getButtonLeonida", "getbuttonSonida", "getButtonSonilo", "getButtonLeonido", "getButtonLeonilo", "getbuttonSonido", "getButtonDonida", "getButtonLeonico", "getButtonDonico"], "buttonSonido": ["fieldsonido", "secondSonidable", "secondSonicho", "buttonsoningo", "labelSonido", "buttonNorthido", "buttonSonata", "positionSonilo", "buttonSunito", "keySonardo", "buttonJonao", "buttonBonardo", "buttonsonilo", "keyson\u00ed", "ButtonSonata", "buttonDenito", "buttonJonicho", "ButtonSonido", "ButtonSunido", "buttonSynito", "buttonJonidable", "buttonSonao", "ButtonSunico", "buttonsonano", "labelSONido", "buttonBonano", "fieldsoningo", "buttonSunata", "keySon\u00ed", "labelSONphp", "buttonSONido", "buttonSunilo", "fieldSonida", "buttonBoningo", "fieldSonido", "buttonSONida", "buttonNorthingo", "positionSonido", "buttonJonila", "buttonBon\u00ed", "buttonJonphp", "secondSynido", "buttonSONilo", "buttonSONphp", "ButtonSunata", "buttonSynido", "buttonSunido", "positionSonico", "positionJonico", "positionJonido", "buttonSonila", "fieldSoningo", "labelSonphp", "buttonSunico", "buttonDenido", "secondSonito", "buttonJonido", "buttonSONila", "ButtonSunao", "ButtonSonico", "fieldsonano", "fieldsonida", "buttonBonida", "labelSONida", "buttonSonidable", "buttonSonicho", "buttonSynphp", "secondSynicho", "buttonDenidable", "positionJonilo", "buttonson\u00ed", "buttonSynila", "buttonJonilo", "ButtonSonao", "buttonSynida", "keySonido", "buttonSonano", "buttonSONico", "buttonBonilo", "buttonHonardo", "buttonBonata", "buttonJonito", "buttonNorthano", "secondSynidable", "buttonNorthida", "keysonardo", "keysonilo", "buttonSon\u00ed", "positionSonito", "buttonHonilo", "buttonHonido", "buttonHon\u00ed", "buttonJonico", "buttonJonida", "buttonSonphp", "buttonSONito", "buttonBonido", "buttonSunao", "labelSONila", "fieldSonano", "buttonSonilo", "buttonsonido", "buttonDenicho", "buttonBonao", "labelSonila", "buttonSoningo", "secondSonido", "buttonSonico", "buttonsonardo", "buttonBonico", "labelSonida", "buttonSonardo", "buttonSynicho", "buttonJonata", "secondSynito", "keysonido", "keySonilo", "positionJonito", "buttonSonito", "buttonSonida", "buttonsonida", "buttonSynidable"], "e": ["AE", "E", "act", "ese", " who", "a", " ge", " fe", " ve", "ED", "ee", "event", "me", "es", " pe", "te", "ing", " ate", "t", " sent", "er", " ie", "ae", "ie", "ev", "ed", " ke", "pe"], "fc": ["fp", "pc", "fab", "inc", "tf", "cv", "bc", "soc", "ec", "irc", "FC", "cc", "fm", "fn", "tc", "anc", "mac", "gc", "etc", "fa", "conv", "f", "uc", "abc", "c", "icc", "fs", "fi", "fd", "coll", "bf", "nc", "lf", "rl", "ctrl", "ic", "fl", "ifa", "lc", "dc", "vc", "cf", "con", "rc", "isc", "WC", "fb", "mc", "RFC"], "returnVal": [" returnValue", "resultval", "retval", "ReturnValue", "ReturnVal", "Returnval", "resultVAL", "returnValue", "returnval", "resultVal", "retVal", "resultValue", "retVAL", "returnVAL", "retValue", "ReturnVAL", " returnval", " returnVAL"], "file": ["ile", "fp", "name", "link", "url", "stat", "path", "parent", "File", "image", "full", "this", "message", "info", "source", "buffer", "resource", "io", "channel", "local", "data", "template", "FILE", "user", "files", "f", "base", "type", "uri", "time", "http", "valid", "page", "form", "single", "create", "spec", "table", "output", "disk", "dir", "get", "fe", "null", "to", "word", "tree", "block", "input", "show", "document", "handle", "format"], "rutaGlobal": ["rutenLocal", "rutiglobal", "redutanDefault", "rutenGlobal", "RutaRemote", "RutoFile", "rutanDefault", "RutaStatic", "rutaFile", "rutiStatic", "rutoLocal", "rutenRemote", "rontoLocal", "rutaglobal", "rontoGlobal", "RutoLocal", "rutiRemote", "rutiLocal", "RutaGlobal", "rutoGlobal", "RutoRemote", "rutiGeneral", "redutaLocal", "rutoRemote", "rutiDefault", "redutanLocal", "rutoStatic", "rutaGeneral", "rutenFile", "rutanGlobal", "rutoglobal", "redutanGeneral", "rutaStatic", "rutanGeneral", "RutoGlobal", "rutoFile", "RutoStatic", "rutenglobal", "rontoDefault", "rutiGlobal", "rutanLocal", "rutaDefault", "Rutoglobal", "rutaLocal", "redutaDefault", "redutanGlobal", "rutaRemote", "rutenStatic", "redutaGeneral", "rontoGeneral", "RutaLocal", "redutaGlobal", "Rutaglobal", "RutaFile", "rutiFile"], "rutaRelativa": ["rutaRELATivas", "rutaRELitivas", "rutaRelantivas", "rutaRelantiva", "rutaRelitivo", "rutaRelATiv", "rutaRELitivo", "rutaRELATiva", "rutaRelativo", "rutaRelATivas", "rutaRelatiivas", "rutaRELativ", "rutaRelatiiv", "rutaRELATiv", "rutaRelantivo", "rutaRelatiivo", "rutaRelitiv", "rutaRELativa", "rutaRelantiv", "rutaRelativ", "rutaRELitiva", "rutaRelatiiva", "rutaRelitiva", "rutaRelATivo", "rutaRELativas", "rutaRelitivas", "rutaRELativo", "rutaRELATivo", "rutaRelativas", "rutaRelATiva", "rutaRELitiv"], "fis": ["lf\u00eds", "flisc", "viss", "lfisa", "dfis", "risc", "fiss", " fys", "vois", "lfiss", "fisc", " fisc", "lfis", "fys", "dfiss", "flis", "ris", " f\u00eds", "dfois", "flos", " fois", "df\u00eds", "f\u00eds", "rys", " fisa", "vis", " fiss", "fisa", "flys", "ros", "fois", "dfisa", "vais", " fais", "dfais", "fais"], "fos": [" foes", "mows", "voes", "moes", "fdoss", "ioses", "woses", "mos", "vops", "waos", "foes", "woss", "fdaos", "fios", "hos", "fdoes", " fows", "faos", "iios", "hios", "foses", "wos", "ioss", "hoss", "foss", "vows", "fdos", "woes", " faos", "fows", "ios", "mops", " fops", "wios", "fops", "hoses", "vos", " foss"], "canalFuente": ["canalFacer", "canelFaelia", "canalFaente", "canalFient", "canallfuestro", "canalFiente", "canelFaent", "canelFaante", "canelFaente", "canalfuante", "canalFUelia", "canalFucer", "canalFUente", "canalfucer", "canallFucer", "canallfuente", "canalFuent", "canalfumelon", "canalFaante", "canalFUent", "canallfumelon", "canalfuente", "canalFaent", "canalFiestro", "canallfuent", "canallfucer", "canalfuper", "canalFuestro", "canalFraencia", "canallFuper", "canalPotente", "canalPotper", "canalPotmelon", "canalfuent", "canalFramelon", "canelFuelia", "canalFumelon", "canalFaestro", "canalFUante", "canalFraente", "canalFicer", "canalFuante", "canalFuelia", "canallFuente", "canallFumelon", "canalFraper", "canalfuestro", "canallFuestro", "canallFuent", "canalFuper", "canalfuencia", "canallFuencia", "canalfuelia", "canelFuante", "canallfuencia", "canalFaelia", "canelFuent", "canallfuper", "canelFuente", "canalFuencia", "canalPotencia"], "canalDestino": ["canalOrigina", "canalsDestination", "canaldDestine", "canalNegino", "canalDescination", "canalsdestinian", "canalDestinian", "canalNegination", "canalDestina", "canalNeginian", "canalOrigino", "canalNegina", "canaldOrigina", "canaldOrigination", "canalsDestino", "canaldestinian", "canaldestination", "canaldestino", "canalsdestination", "canalsDestina", "canalsdestino", "canalsdestina", "canalDestine", "canalDescina", "canaldestina", "canalDestination", "canalOrigine", "canalDescine", "canaldOrigine", "canaldDestino", "canaldDestina", "canaldOrigino", "canalOrigination", "canaldDestination", "canalDescino", "canalsDestinian"]}}
{"id1": "12078471", "id2": "160705", "code1": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "code2": "    public static boolean downloadFile(String url, String destination) throws Exception {\n        BufferedInputStream bi = null;\n        BufferedOutputStream bo = null;\n        File destfile;\n        byte BUFFER[] = new byte[100];\n        java.net.URL fileurl;\n        URLConnection conn;\n        fileurl = new java.net.URL(url);\n        conn = fileurl.openConnection();\n        long fullsize = conn.getContentLength();\n        long onepercent = fullsize / 100;\n        MessageFrame.setTotalDownloadSize(fullsize);\n        bi = new BufferedInputStream(conn.getInputStream());\n        destfile = new File(destination);\n        if (!destfile.createNewFile()) {\n            destfile.delete();\n            destfile.createNewFile();\n        }\n        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n        int read = 0;\n        int sum = 0;\n        long i = 0;\n        while ((read = bi.read(BUFFER)) != -1) {\n            bo.write(BUFFER, 0, read);\n            sum += read;\n            i += read;\n            if (i > onepercent) {\n                i = 0;\n                MessageFrame.setDownloadProgress(sum);\n            }\n        }\n        bi.close();\n        bo.close();\n        MessageFrame.setDownloadProgress(fullsize);\n        return true;\n    }\n", "label": 0, "substitutes": {"tryLoadURL": ["tryLoadUR", "tryReadUrl", " tryLoadString", "tryReadURL", "tryOpenURL", "tryOpenUR", "tryOpenUrl", "tryLoadString", "tryloadURL", " tryloadUrl", " tryloadUR", " tryloadURL", "tryReadString", "tryLoadUrl", "tryReadUR", "tryOpenString", " tryLoadUrl", " tryloadString", "tryloadUrl", "tryloadString", " tryLoadUR", "tryloadUR"], "url": ["Url", "link", "html", "pl", "path", "key", "string", "pattern", "r", "job", "file", "location", "log", "ssl", "host", "k", "build", "dl", "abs", "uri", "web", "http", "nl", "q", "sl", "sql", "ll", "address", "ref", "out", "loc", "https", "un", "l", "URL", "print", "ls", "ur", "ul"], "format": ["printf", "unit", "html", "version", "settings", "pattern", "act", "mat", "and", "MAT", "ats", "file", "config", "sort", "layout", "join", "function", "parse", "template", "fc", "f", "type", "accept", "mode", "struct", "status", "form", "set", "with", "spec", "at", "output", "term", "edit", "feat", "list", "transform", "cat", "print", "att", "filter", "mt", "style", "index", "use", "Format"], "c": ["cs", "ch", "ac", "p", "ec", "cb", "cc", "xc", "enc", "g", "v", "a", "r", "u", "anc", "cl", "b", "i", "etc", "conv", "call", "fc", "f", "m", "cont", "nc", "com", "ctrl", "cur", "cu", "lc", "dc", "l", "cm", "cf", "sc", "con", "cr", "rc", "ca", "co", "cin", "ce", "mc", "C", "cp", "ct"], "data": ["name", "sequence", "response", "cache", "html", "key", "image", "string", "ata", "description", "message", "sample", "info", "content", "value", "json", "feed", "source", "buffer", "dat", "dump", "batch", "base", "accept", "space", "body", "text", "serial", "no", "d", "output", "DATA", "row", "input", "hex", "window", "bytes", "area", "raw"], "model": ["sm", "im", "obj", "view", "response", "server", "xml", "mb", "message", "sample", "dm", "job", "mm", "value", "controller", "de", "log", "Model", "mod", "me", "manager", "template", "map", "result", "m", "batch", "save", "report", "el", "command", "form", "rm", "models", "object", "set", "instance", "impl", "frame", "ll", "bm", "relation", "db", "module", "proxy", "table", "human", "tree", "re", "transform", "sim", "gp"]}}
{"id1": "596993", "id2": "23620712", "code1": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"makeLoginRequest": ["makeLoginMessage", " makeFacebookRequest", " makeFacebookPost", " makeFacebookResponse", "makeFacebookRequest", "makeFacebookPost", " makeLoginPost", "makeSubmitResponse", "makeFacebookMessage", " makeLoginMessage", "makeloginRequest", "makeLoginResponse", "makeSubmitRequest", " makeLoginResponse", "makeloginPost", "makeSubmitMessage", "makeloginMessage", " makeFacebookMessage", "makeloginResponse", "makeFacebookResponse", "makeSubmitPost", "makeLoginPost"], "url": ["Url", "name", "path", "string", "char", "ul", "r", "job", "cl", "file", "location", "b", "ssl", "k", "build", "bel", "call", "dl", "base", "abs", "uri", "web", "http", "sl", "nl", "el", "str", "ll", "browser", "address", "ref", "https", "un", "l", "open", "URL", "re", "ls", "ur"], "urlConnection": ["mountConnection", " urlConn", "xmlConnection", "browserConn", "UrlSession", " urlConnect", " urlConnector", "UrlLink", "handleConnect", "mountConn", "loadConnection", "loadConn", "browserconnection", "urlConnector", "browserConnection", "httpStream", "browserConnect", "urlconnection", "UrlConnect", "mountClient", "nlLink", "UrlConn", "nlConnect", "urlConnect", " urlInstance", "sslPort", "sslSession", "loadInstance", "consoleConnect", "sslStream", "nlconnection", "httpLink", "browserInstance", "consoleConnection", "consoleConn", "xmlConnector", " urlClient", "fileConnect", "httpConnection", "fileconnection", "mountConnect", "logConnection", "handleStream", "urlTree", "urlLink", "loadConnect", "UrlInstance", "logConnect", "httpConnect", "fileConnection", "sslConnector", "urlSession", "sslTree", "urlConn", "browserClient", "fileSession", "handleConn", "httpSession", "urlClient", "httpConn", "mountSession", " urlTree", "Urlconnection", " urlPort", "sslConnect", "nlConnection", "urlStream", "xmlPort", " urlconnection", "consoleSession", "httpconnection", "sslconnection", "sslConnection", "urlPort", "mountconnection", "urlInstance", "xmlTree", " urlSession", "logConn", "UrlConnection", "logLink", "handleConnection", "sslConn"], "content": ["sequence", "metadata", "cache", "lead", "conn", "any", "version", "image", "action", "settings", "activity", "pattern", "const", "continue", "filter", "handle", "xml", "description", "message", "current", "subject", "title", "expression", "json", "value", "config", "values", "cmd", "label", "network", "layout", "comments", "node", "context", "reason", "function", "data", "template", "example", "media", "comment", "cont", "search", "Content", "format", "report", "command", "form", "body", "object", "mask", "text", "summary", "language", "address", "create", "code", "contact", "cm", "output", "trust", "core", "license", "script", "size", "document", "names", "ontent", "control", "raw", "properties"], "outputStream": ["outputBlock", " outputStyle", "networkSteam", " outputstream", "OutputForm", "Outputstream", " outputSteam", "outputForm", "outputStyle", "networkStreamer", "OutputView", "OutputStyle", "OutputStream", "OutputStreamer", "OutputBlock", "inputForm", "inputView", " outputBlock", "outputView", "OutputSteam", "inputSteam", "networkStream", "outputstream", " outputView", "outputSteam", " outputForm", "inputBlock", "networkstream", "inputStyle", " outputStreamer", "outputStreamer"], "responseCode": ["ResponseCount", "usageCount", "responseCount", "usageCategory", "statusType", " responseCategory", "sequenceCode", "usageCode", "sequenceCount", "responseType", "ResponseType", "sequenceType", "statusCode", "ResponseCategory", " responseChoice", "sequenceStatus", "responseCategory", "usageChoice", "ResponseChoice", "ResponseStatus", "ResponseCode", "responseStatus", "responseChoice", " responseCount", "statusStatus", "statusCount"], "inputStream": ["thisSteam", "fileStream", "InputSteam", "viewThread", "fileStreamer", " inputSteam", "InputView", "thisStream", "errorView", "errorForm", " inputStreamer", "outputStyle", "outputForm", "thisStreamer", "viewSteam", "inputStreamer", "InputStream", "inputView", "viewStream", "inputForm", "outputView", "actStyle", "inputSteam", "errorSteam", "actStream", " inputView", "inputThread", "fileSteam", "outputThread", "errorStream", " inputQueue", "actView", "outputSteam", "actSteam", " inputThread", "fileQueue", "viewView", "inputStyle", " inputStyle", "thisQueue", "inputQueue", "InputForm"]}}
{"id1": "13644374", "id2": "13362846", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getBytesFormPath", "getBytesfromPath", "getBytesForPath", "getByteFromPage", "getBytesFromPath", "getBytesfromURL", "getBytesForURL", "getBytesForUrl", "getBytesFromPage", "getByteFromPath", "getBytesFormPage", "getBytesFromURL", "getBytesfromPage", "getByteFormUrl", "getByteFromURL", "getByteFromUrl", "getByteFormURL", "getByteFormPath", "getBytesFormURL", "getByteFormPage", "getBytesfromUrl", "getBytesFormUrl", "getBytesForPage"], "url": ["Url", "name", "link", "html", "pl", "path", "domain", "full", "string", "pattern", "xml", "location", "host", "build", "parse", "default", "id", "base", "dl", "uri", "res", "web", "http", "nl", "sl", "el", "page", "str", "ll", "address", "ref", "https", "loc", "rect", "l", "URL", "ls", "ur", "ul"], "get": ["full", "select", "find", "this", "put", "g", "gets", "download", "query", "like", "read", "build", "give", "parse", "call", "GET", "let", "search", "send", "http", "we", "body", "set", "service", "post", "check", "play", "ge", "pre", "load", "create", "got", "request", "exec", "pull", "Get", "show"], "response": ["yes", "answer", "image", "resp", "version", "still", "soc", "message", "entry", "content", "json", "success", "pos", "given", "resource", "next", "respond", "respons", "that", "result", "application", "successful", "res", "http", "page", "status", "body", "onse", "Response", "service", "object", "post", "output", "client", "open", "block", "request", "connection", "tree", "reply", "document"], "entity": ["obj", "unit", "group", "le", "icon", "model", "image", "any", "activity", "and", "unique", "put", "se", "Entity", "info", "entry", "content", "member", "ent", "json", "ee", "event", "iso", "resource", "me", "email", "one", "data", "record", "user", "result", "note", "comment", "security", "type", "base", "eme", "person", "el", "peer", "instance", "form", "body", "object", "ity", "load", "component", "total", "client", "line", "em", "encrypted", "ce", "document", "pe"]}}
{"id1": "9796161", "id2": "7149578", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 0, "substitutes": {"getMD5": ["toMD7", "toSHA4", "getMD2", "toMD5", "getSHA5", "toSHA7", "getMD7", "getSHA2", "getSHA7", "toSHA5", "getmd7", "getMD4", "getSHA4", "toSHA2", "toMD2", "getmd5", "getmd2", "getmd4", "toMD4"], "s": ["p", "is", "sq", "ts", "ws", "bs", "string", "bytes", "rs", "strings", "v", "ps", "ats", "src", "g", "ns", "sb", "gets", "b", "source", "i", "S", "h", "gs", "ss", "es", "xs", "data", "ends", " gets", "ses", "f", "sv", "ies", "c", "sts", "space", "fs", "abs", "its", "y", "sql", "str", "ms", "text", "t", "ins", "l", "aws", "os", "js", "ls", "n"], "m": ["sm", "M", "nm", "am", "mi", "fm", "g", "v", "dm", "mo", "mm", "man", "e", "mac", "managed", "perm", "gm", "h", "mod", "me", "om", "manager", "rem", "mut", "mu", "pm", "rm", "y", "md", "ms", "hm", "mask", "bm", "cm", "l", "made", "mr", "em", "tm", "vm", "mc", "mt", "mk"]}}
{"id1": "8490710", "id2": "23273706", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 0, "substitutes": {"actualizar": ["ualizaiar", "ualizaar", " actualisAR", " actualizer", " actualiziar", " actualisar", "ualiziar", "ualizaer", "ualizar", " actualizeAR", " actualizeer", "ualizaAR", "ualizAR", " actualizaiar", " actualizaAR", " actualizeiar", "ualizer", " actualizear", " actualisiar", " actualiser", " actualizAR", " actualizaar", " actualizaer"], "ClassNotFoundException": ["ClassNotfoundException", "ClassNotPresentException", "ClassNotfoundError", "ClassNotPresentError", "ClassNotFoundError"], "Exception": ["None", "Connection", "Option", "Class", "ION", "File", "Error", "Result", "E", "Message", "Warning", "Example", "Exc", "Application", " exception", "Status", "Ex", "Null", "Transaction", "Operation", "End", "EX", "Instance", "Interface", "Response", "Handler", "Time", "Configuration", "Context", "T", "Throw", "I", "Un", "Type", "ception", "Index", "Exit", "Event"], "conn": ["Connection", " con", "obj", "yes", "die", "ch", "ln", "cert", "init", "yn", "ws", "ec", "socket", "comm", "act", "cc", "org", "rs", "pool", "enc", "cb", "nt", "Connect", "ns", "connect", "pen", "cmd", "pg", "config", "sys", "session", "ont", "close", "c", "pas", "conf", "nc", "sql", "ctrl", "gate", "en", "jp", "db", "ctx", "open", "client", "Con", "con", "sc", "rc", "connection", "n", "ann", "exec", "js", "Conn", "ens", "oss", "ks", "mc", "mt", "ct", "cp", "cn"], "ms": ["sm", "mic", "mys", "cs", "ws", "is", "mi", "ts", "cms", "posts", "bs", "inv", "rs", "uts", "ps", "ocks", "Ms", "ats", "mos", "mm", "ns", "ants", "sys", "ys", "mod", "ents", "xs", "ems", "m", "ies", "fs", "res", "mx", "pm", "mp", "eds", "mill", "ims", "md", "ins", "pers", "mn", "mes", "vs", "eps", "uns", "MS", "cus", "ma", "terms", "s", "os", "js", "ml", "qs", "arms", "windows", "ks", "mc", "mt", "ces"], "fechaSystem": ["fechoaSystem", "fechisystem", "fochaSTEM", "feshaSystem", "fetisystem", "fochtaServer", "fechtaServer", "fechaSTEM", "feshaServer", "fetaSys", "fetiSys", "feshoSystem", "feshasystem", "fetaesystem", "fechoaServer", "feshosystem", "fechaServer", "fechtaSTEM", "fechoSys", "fochtaSTEM", "fechasystem", "fechaeSystem", "fechlaSystem", "fechoSTEM", "fochaSystem", "feshoServer", "fechaeSTEM", "fechosystem", "fechlaSys", "fechtaSystem", "fetiSystem", "fochaServer", "fechaesystem", "fetaeSystem", "fetaSystem", "fetasystem", "fechoaSys", "fechoasystem", "fechiSys", "fechaSys", "fetaeSys", "fechoServer", "fechiSystem", "fechoSystem", "fochtaSystem", "fechaeServer", "fechaeSys", "fechlasystem"], "aaaammdd": ["aaaaammm", "aaaaammmm", "aaaaummd", "aaaaamd", "aaaaamdd", "aaaammd", "aaaaumd", "aaaaumdd", "aammds", "aaaaammd", "aaammd", "aaaamld", "aaaamdd", "aammdd", "aaaammm", "aaammds", "aammd", "aammmd", "aaaaumds", "aaaammmm", "aaaamlmm", "aaaammmd", "aaaamldd", "aaammdd", "aaammmm", "aaammmd", "aaaaammdd", "aaaamds", "aaaammds", "aaaamd"], "fzafsis": ["fzafses", "fzeafses", "fzajsi", "fzamses", "fzamsi", "fzamsis", "fzeajses", "fzeajesi", "fzahses", "fzafesi", "fzajses", "fzafsi", "fzamesi", "fzahsi", "fzahesi", "fzeafsi", "fzeajsis", "fzajsis", "fzeafsis", "fzajesi", "fzeafesi", "fzeajsi"], "hhmmss": ["hhmmse", "hhmmess", "hhmmmse", "HHMMss", "hhmps", "hmmmess", "hmmbess", "HHmms", "hhmbs", "hhmss", "hhMMse", "hhmmmps", "hhmbss", "hhmmps", "HHmmms", "HHMMs", "hmmmse", "hhmbess", "hmmmss", "hhMMps", "hhMMess", "hhmmmess", "hmmms", "HHmmss", "HHMMms", "hhMMms", "hhmms", "hmmbss", "hhMMs", "hhMMss", "hhmmmss", "hhmmms", "hmmbse", "hhmbse", "HHmmps", "HHMMps", "hhms", "hmmbs", "hhmmmms"], "sss": ["issl", "esss", "esses", "essl", "issss", "essss", "ssjs", "ossn", "ssl", "rssl", "rsses", "isses", " ssn", "essn", "ossjs", "ssss", "ssn", "isss", "essjs", "osss", "ossss", "sses", "rssss", " ssss", "rsss", " ssjs"], "ss": ["cs", "ass", "su", "ius", "pres", "ws", "string", "sq", "css", "ts", "bs", "tx", "iss", "pse", "rs", "sh", "si", "ps", "stats", "se", "\u00df", "ds", "ns", "hess", "sb", "xx", "SS", "sys", "ys", "tt", "ssl", "sd", "less", "pps", "ses", "ess", "txt", "sv", "rss", "sl", "tz", "good", "sql", "str", "sf", "https", "ress", "styles", "s", "oss", "js", "hs", "pass", "lower"], "fzahsis": ["fzaforus", "fzafses", "fzaqorus", "fzaborus", "fizafsis", "fizaforus", "fizahses", "fzabsi", "fzaqses", "fzaqsi", "fizahsis", "fzahses", "fizafses", "fzafsi", "fizafsi", "fizahorus", "fzahsi", "fzaqsis", "fzahorus", "fzabsis", "fizahsi", "fzabses"], "afectados": ["afettators", "afettados", "afittulas", "afitectado", "afitectarians", "affectarians", "afECTado", "affettados", "afittados", "affectado", "afettulas", "affECTado", "afelectulas", "afectionurated", "affecturated", "affectados", "afelectados", "affectadas", "affettators", "afittadas", "afettadas", "affectators", "afelectadas", "afittators", "afECTarians", "affECTurated", "affECTados", "afECTurated", "affectulas", "afectado", "affettadas", "afectulas", "affECTarians", "afectadas", "afectators", "afectarians", "afECTados", "afectionados", "afitecturated", "affettulas", "afecturated", "afitectados", "afectionado", "afelectators", "afectionarians"]}}
{"id1": "13122204", "id2": "21125261", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unzipmodel", "unlateImage", "unarchiveModule", "Unzipmodel", "uncodeModule", "unarchiveModel", "UnzipImage", "UnzipModel", "UnzipModule", "uncodeModel", "unlatemodel", "uncodeImage", "UnarchiveModel", "UnarchiveModule", "unarchivemodel", "UnarchiveImage", "Unarchivemodel", "unarchiveImage", "unlateModel", "unzipImage", "unzipModule", "unlateModule", "uncodemodel"], "filename": ["fp", "name", "println", "FN", "origin", "path", "ln", "mson", "journal", "ivo", "nm", "jpg", "fn", "original", "ename", "subject", "title", "download", "nil", "file", "location", "source", "SourceFile", "fil", "til", "dra", "FILE", "kl", "txt", "FIL", "stem", "nl", "wl", "sql", "Filename", "fle", "output", "n", "river", "directory", "username"], "tempdir": ["testdir", "Tempdir", "tmppath", "tmpdir", "tmpDIR", "tempfolder", "Tempdirectory", "temdirectory", "temDir", " tempfile", "Tempfile", "tempath", "tmpDir", "TempDir", "testDir", " tempDir", "temppath", "testfolder", "tempfile", "temDIR", " tempdirectory", "tempDIR", " tempDIR", "tempdirectory", "tmpfile", "tempDir", "tmpfolder", "testpath", "temdir", "tmpdirectory", "temfolder"], "dest": ["port", "deep", "obj", "origin", "est", "parent", "nom", "del", "tr", "writer", "Dest", "inv", "display", "pipe", "master", "src", "stream", "nt", "target", "slave", "temp", "source", "pos", "buffer", "bin", "comb", "tmp", "dat", "ptr", "coord", "default", "dev", "result", "generated", "tail", "cont", "send", "sum", "peer", "ctr", "store", "st", "desc", "out", "loc", "foreign", "test", "usr", "des", "dc", "table", "output", "write", "null", "dist", "trans", "document", "rest", "decl"], "fis": ["ifatis", "zos", "li", "zatis", "fatis", "zjs", "flis", "zi", "ifis", "flos", "fljs", "fi", "fjs", "fli", "flatis", "los", "ifos", "ljs", "lis", "ifi"], "BUFFER": ["BAOUNT", "BUFR", "CUFR", "BABER", "BUULT", "BFFER", "BBER", "BLOUNT", "FFERMT", "MAXBuffer", " BUMT", "BUBER", "LOCKFR", "BUOUNT", "LOCKFFER", "BAULT", " BUULT", "BLFFER", "BOUNT", "BLBuffer", "BufferBER", "BLBER", "MAXFFER", "BufferFFER", "CUBER", " BUBER", "BUMT", " BUOUNT", "BAFFER", "BufferBuffer", " BUFR", "FFERBER", "CUBuffer", "FFERBuffer", " BUBuffer", "BUBuffer", "LOCKBuffer", "CUFFER", "MAXOUNT", "LOCKBER", "BULT", "MAXBER", "BufferMT", "FFERFFER"], "zis": ["zip", "xos", " zos", "Zi", "zos", "Ziss", "oziss", " zris", "fiss", "zoneis", "Zis", "zris", " zIS", "ziIS", " zes", "zeits", "zeos", "zIS", "ozi", "zits", "zi", "zes", "zios", "xi", "zeiss", "zeris", " ziss", "zeIS", "fi", "xis", " zi", "zoneris", "fip", "ozis", "zoneits", "ozip", " zip", "ziss", "zees", "zoneiss", "xiss", "Zos", "zeis", " zits", "ziis", "zies"], "entry": ["zip", "name", "link", "existent", "key", "enter", "header", "image", "system", "zo", "part", "char", "def", "se", "nt", "index", "escape", "je", "member", "e", "ent", "file", "jo", "source", "log", "inter", "Entry", "record", "match", "ry", "result", "comment", "way", "cell", "or", "card", "piece", "chain", "element", "item", "jar", "table", "word", "connection", "row", "ie", "ce", "ze", "pe"], "count": ["cache", "counter", "len", "child", "OUNT", "amount", "part", "cc", "cloud", "nt", "current", "add", "index", "max", "acc", "nb", "number", "all", "start", "buffer", "read", "ount", "match", "call", "num", "f", "comment", "c", "base", "batch", "force", "cont", "sum", "page", "cond", "cell", "ctr", "check", "code", "length", "total", "common", "Count", "core", "z", "ce", "size", "found", "ct", "n"], "data": ["cache", "image", "raw", "ata", "mat", "part", "p", "message", "sample", "content", "dec", "value", "all", "buffer", "dat", "results", "next", "zero", "result", "step", "batch", "dl", "done", "accept", "ATA", "valid", "str", "text", " DATA", "out", "rel", "d", "table", "output", "n", "DATA", "size", "window", "bytes", "area", "format"], "fos": [" foes", " fios", "fOS", "voes", "voses", "foes", "fios", "Foses", "lios", "foses", "foss", "Foss", " fOS", "Fios", "lOS", "loss", "FOS", "Fos", " foses", "los", "voss", "Foes", "vos", " foss"]}}
{"id1": "15472181", "id2": "9718328", "code1": "    private InputStream getInputStream(String item) {\n        InputStream is = null;\n        URLConnection urlc = null;\n        try {\n            URL url = new URL(item);\n            urlc = url.openConnection();\n            is = urlc.getInputStream();\n            current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() + url.getFile();\n        } catch (Exception ee) {\n            System.err.println(ee);\n        }\n        int i = 0;\n        udp_port = -1;\n        udp_baddress = null;\n        while (urlc != null) {\n            String s = urlc.getHeaderField(i);\n            String t = urlc.getHeaderFieldKey(i);\n            if (s == null) {\n                break;\n            }\n            i++;\n            if (\"udp-port\".equals(t)) {\n                try {\n                    udp_port = Integer.parseInt(s);\n                } catch (Exception e) {\n                }\n            } else if (\"udp-broadcast-address\".equals(t)) {\n                udp_baddress = s;\n            }\n        }\n        return is;\n    }\n", "code2": "    public void actionPerformed(ActionEvent e) {\n        if (\"register\".equals(e.getActionCommand())) {\n            buttonClicked = \"register\";\n            try {\n                String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\");\n                URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\");\n                URLConnection conn = url.openConnection();\n                conn.setDoInput(true);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = rd.readLine()) != null) {\n                }\n                rd.close();\n                wr.close();\n            } catch (Exception ex) {\n            }\n            setVisible(false);\n        } else if (\"cancel\".equals(e.getActionCommand())) {\n            buttonClicked = \"cancel\";\n            setVisible(false);\n        } else if (\"never\".equals(e.getActionCommand())) {\n            buttonClicked = \"never\";\n            setVisible(false);\n        }\n    }\n", "label": 0, "substitutes": {"getInputStream": ["getContentChannel", "getStreamFile", "createOutputSource", "getContentSteam", "createOutputStream", "createInputSource", "createOutputFile", " getInputSteam", "getItemSource", "getInputstream", "getItemFile", "createInputStream", "getStreamStream", "getItemstream", "getStreamSource", "createInputstream", "getInputChannel", "getInputSteam", "getItemStream", "getOutputStream", " getInputView", " getOutputSteam", "getInputSource", " getOutputChannel", "createInputFile", "getInputFile", " getInputChannel", "getErrorSteam", "getInputView", "getOutputFile", "getErrorStream", "getErrorView", " getOutputStream", "getErrorChannel", "getContentStream", "createOutputstream", "getOutputstream", "getOutputChannel", " getOutputView", "getOutputView", "getOutputSteam", "getContentView", "getStreamstream", "getOutputSource"], "item": ["remote", "name", "link", "server", "ip", "key", "path", "p", "claim", "it", "string", "pattern", "this", "what", "info", "title", "value", "event", "source", "question", "val", "local", "match", "template", "id", "m", "el", "stuff", "status", "store", "prefix", "object", "spec", "test", "Item", "items", "iter", "row", "token"], "is": ["tis", "im", "bits", "ip", "isu", "iss", "bs", "si", "isin", "isa", "sis", "source", "iso", "Is", "ris", "serv", "es", "IS", "fs", "bis", "its", "ic", "in", "ios", "ims", "ms", "isl", "ins", "us", "ists", "ais", "iris", "ism", "os", "ai", "isc", "mis", " cis", "isi", "ist", "as", "lis"], "urlc": ["rlc", "Urlc", "llC", "urlC", "httpc", "sslcu", "zipcu", "Urla", "Urlcon", "httpac", "urltc", "httpC", "urla", "Urltc", "httpcon", "Urlbc", "urlac", "Urll", "httpci", "nlci", "lll", "urlcon", "rlC", "urlbc", "urlcu", " urll", "sslC", "zipcor", "nlc", " urlbc", " urlC", "httpcache", " urla", "sslcache", "rlcor", "nlcs", "nlC", " urlac", " urlcache", "sslcon", "lla", "zipC", "Urlac", "rlcu", "UrlC", "sslcs", "httpbc", " urltc", "urlcache", "sslc", "httptc", "urlcor", "urlcs", "llc", "urlci", "sslci", "zipc", "sslcor", "urll", "httpcs", "Urlcache"], "url": ["Url", "link", "hl", "util", "html", "raw", "full", "handle", "comm", "char", "xml", "r", "download", "mount", "cl", "cmd", "b", "gl", "ssl", "host", "builder", "build", "git", "bel", "call", "f", "lt", "il", "dl", "uri", "github", "web", "http", "sl", "nl", "rl", "str", "impl", "ll", "google", "ref", "history", "loc", "browser", "rel", "l", "client", "get", "tool", "null", "www", "URL", "re", "ls", "ur", "ul", "li"], "current_source": ["current__site", "local_format", "current_format", "current_name", "local_source", "current__source", "current_site", "local_name", "current__format", "current__name", "local_site"], "i": ["ix", "bi", "ip", "init", "p", "mi", "x", "it", "phi", "gi", "ui", "si", "ini", "hi", "menu", " j", "e", "iu", "cli", " ii", "ind", "b", "gu", "ti", "ci", "zi", "j", "multi", "di", "conv", "xi", "c", "y", "ei", "ic", "slice", "set", "chain", "ai", "I", "n", "z", "pi", "yi", "index", "ii", "li"], "udp_port": ["udp_ports", "udcp_port", "udpTheport", "udpThedevice", "udp_device", "udp_p", "udP_p", "udcp_address", "udp_address", "udpThePORT", "udp_ort", "udcp_PORT", "udP_ports", "udp_PORT", "udP_ort", "udcp_device", "udpTheaddress", "udP_port"], "udp_baddress": ["udp_rbattribute", "udp_bAddress", "udp_dAddress", "udp_nbconnection", "udp_daddress", "udp_nbAddress", "udp_pbconnection", "udp_bconnection", "udp_bcontroller", "udp_rbaddress", "udp_Battribute", "udp_pbcontroller", "udp_dattribute", "udp_dcontroller", "udp_pbAddress", "udp_Baddress", "udp_BAddress", "udp_dconnection", "udp_nbaddress", "udp_nbcontroller", "udp_battribute", "udp_pbaddress", "udp_rbAddress"], "s": ["cs", "ws", "p", "ts", "sq", "bs", "string", "full", "rs", "socket", "g", "ps", "a", "se", "ats", "ds", "ns", "sb", "e", "ys", "gs", "S", "h", "ss", "es", "less", "sam", "f", "sv", "abs", "fs", "search", "sts", "its", "sql", "set", "str", "ms", "ins", "spec", "des", "l", "was", "os", "sym", "js", "qs", "hs", "ls", "n"], "t": ["not", "tf", "tr", "p", "it", "ts", "ant", "ty", "g", "tc", "typ", "title", "e", "ent", "tt", "j", "template", "kt", "txt", "c", "type", "ot", "te", "y", "tag", "st", "ta", "text", "at", "test", "o", "vt", "T", "l", "term", "word", "pt", "tm", "et", "token", "td", "att", "rt", "mt", "ct", "wt"]}}
{"id1": "2642914", "id2": "8932510", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarGep", "addFileToTarGszip", "addFileToTarRw", "addFileToTarBx", "addFileToTarJx", "addFileToTarJzip", "addFileToTarJz", "addFileToTarGx", "addFileToTarGzip", "addFileToTarBw", "addFileToTarGp", "addFileToTarBz", "addFileToTarRzip", "addFileToTarGst", "addFileToTarBzip", "addFileToTarGet", "addFileToTarGsp", "addFileToTarGw", "addFileToTarGezip", "addFileToTarRz", "addFileToTarBt", "addFileToTarJw", "addFileToTarRx", "addFileToTarGt", "addFileToTarBp", "addFileToTarGsz", "addFileToTarGez"], "taro": [" tara", "thamo", "staco", "stoa", "Taco", "warro", "Tamo", "qtaro", "tempamo", "marro", "staro", "stargo", "stamo", "troa", "maro", "trary", "starro", "ttara", " tolan", "retaro", "tory", "trro", "ktara", "Taro", " tory", "thosa", "ktarro", "tamo", "stary", "qtro", "margo", "tro", "ktaro", "ttaro", "thara", "tolan", "Tolan", "waro", "ktrar", "taco", " tarro", "tara", " tary", "tary", "retaco", "tarro", "tosa", "trar", "tharo", "Tarro", "retara", "targo", "traro", "temparo", " targo", "retamo", "qtolan", "Targo", "tharro", "tempargo", "toa", "Tro", "ttosa", "Tory", "wro", "qtory", "tempro", " taco", " tosa", " tamo", " toa", "Tara", " trar", "stro", "thrar", "wargo", "mro", "ttamo", " tro"], "path": ["name", "url", "PATH", "ath", "key", "p", "full", "string", "pattern", "clean", "ex", "entry", "w", "mount", "file", "h", "local", "root", "project", "m", "c", "parts", "text", "chain", "ref", "history", "kind", "doc", "dir", "Path", "core", "binding", "th", "transform", "pi", "print"], "base": ["name", "server", "parent", "full", "part", "file", "b", "start", "buffer", "alias", "pad", "build", "padding", "template", "default", "root", "based", "basic", "Base", "bf", "bas", "prefix", "check", "normal", "relative", "create", "db", "common", "family", "ase", "shadow", "binding", "bad", "reset", "extra", "bare", "absolute"], "f": ["fp", "xf", "rf", "fab", "tf", "fed", "df", "p", "fm", "g", "v", "fo", "r", "F", "w", "e", "life", "perm", "file", "b", "i", "h", "fx", "fa", "uf", "fc", "c", "fs", "fi", "fd", "elf", "bf", "lf", "y", "fg", "form", "fl", "t", "sf", "o", "d", "cf", "l", "ft", "fe", "far", "fac", "fr", "af", "alf", "fb", "inf"], "entryName": ["ryname", " entryKey", "EntryPath", "entryType", "ryName", "rowType", "elementPath", "cueKey", "elementname", "rowName", " entryLetter", "entryPath", " entryPath", "EntryKey", "cueName", "elementKey", "rowname", "entryKey", " entryType", "rowLetter", "cuename", "cueType", " entryname", "ryLetter", "ryType", "entryLetter", "entryname", "Entryname", "elementName", "EntryName", "EntryType"], "goIn": [" goIN", "moInput", "gein", "poIN", "geIn", " goOut", "GoIn", "moIN", "goIns", "Goin", "GoIns", "poin", "goOut", "GoIN", "goin", "moin", "moIns", "moIn", "goIN", "geInput", "poOut", " goInput", "poIn", "geIns", "goInput", " goIns", " goin", "GoOut"], "tarEntry": ["rarentry", "warItem", "rarComponent", "rarCategory", "tarentry", " tarEnt", "warComponent", "warEnt", " tarItem", "tarCategory", "tarItem", "rarEntry", "warEntry", " tarCategory", "rarItem", "tarEnt", "carCategory", "carEnt", "tarComponent", "rarEnt", "carentry", " tarComponent", "carEntry", " tarentry"], "children": ["resources", "cache", "groups", "cs", "parent", "each", "ports", "cloud", "stories", "wn", "gall", "ps", "pages", "kids", "members", "many", "names", "aos", "parents", "json", "users", "all", "reports", "blocks", "ren", "keys", "roots", "they", "these", "files", "batch", "fs", "packages", "modules", "jobs", "objects", "ll", "balls", "los", "hawks", "items", "ml", "Children", "follow", "ls", "ul"], "child": ["zip", "name", "cache", "ch", "parent", "key", "Child", "shell", "char", "job", "entry", "label", "last", "file", "ph", "close", "id", "comment", "c", "batch", "fd", "q", "cell", "page", "lf", "uncle", "ll", "friend", "cow", "l", "client", "count", "block", "brother", "row", "fr", "background", "follow", "pixel", "col", "handle"]}}
{"id1": "7809093", "id2": "160705", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    public static boolean downloadFile(String url, String destination) throws Exception {\n        BufferedInputStream bi = null;\n        BufferedOutputStream bo = null;\n        File destfile;\n        byte BUFFER[] = new byte[100];\n        java.net.URL fileurl;\n        URLConnection conn;\n        fileurl = new java.net.URL(url);\n        conn = fileurl.openConnection();\n        long fullsize = conn.getContentLength();\n        long onepercent = fullsize / 100;\n        MessageFrame.setTotalDownloadSize(fullsize);\n        bi = new BufferedInputStream(conn.getInputStream());\n        destfile = new File(destination);\n        if (!destfile.createNewFile()) {\n            destfile.delete();\n            destfile.createNewFile();\n        }\n        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n        int read = 0;\n        int sum = 0;\n        long i = 0;\n        while ((read = bi.read(BUFFER)) != -1) {\n            bo.write(BUFFER, 0, read);\n            sum += read;\n            i += read;\n            if (i > onepercent) {\n                i = 0;\n                MessageFrame.setDownloadProgress(sum);\n            }\n        }\n        bi.close();\n        bo.close();\n        MessageFrame.setDownloadProgress(fullsize);\n        return true;\n    }\n", "label": 0, "substitutes": {"getContent": ["readContents", "getStream", "getData", "getEntity", "GetContents", "readData", "GetData", "readContent", "GetContent", "readEntity", " getContents", " getData", " getStream", "GetEntity", "getContents", "GetStream", "readStream", " getEntity"], "request": ["attribute", "QUEST", "execute", "url", "claim", "task", "this", "xml", "message", "job", "Request", "event", "hello", "query", "question", "start", "resource", "email", "template", "call", "application", "project", "search", "http", "q", "command", "instance", "object", "post", "item", "address", "create", "get", "open", "req", "input", "self", "transform", "quest", "document"], "sb": ["sm", "bn", "erb", "bg", "ib", "sq", "bs", "cb", "sth", "mb", "sa", "bh", "nb", "lb", "b", "gc", "bd", "buffer", "ssl", "bsp", "buf", "bb", "sg", "bp", "sv", "eb", "lp", "gb", "bf", "rm", "rob", "sf", "wb", "ub", "kb", "pb", "obb", "bt", "rb", "SB", "zb", "sp", "bps", "fb", "xb"], "client": ["remote", "cache", "server", "conn", "ch", "init", "key", "ip", "tc", "grid", "Client", "connect", "cli", "cl", "cmd", "config", "resource", "context", "city", "ci", "io", "secure", "call", "c", "force", "web", "http", "cell", "console", "service", "google", "chain", "create", "https", "api", "cm", "con", "connection", "core", "co", "ce", "net", "wrapper", "control", "cp", "cn"], "httpParams": ["httpPerms", " httpParims", "httpPARims", " httpPims", "httpPrparams", "httpPars", "httpPARms", " httpPams", "httpPrms", " httpParans", " httpParars", "httpPims", "httpPARams", "httpPARars", " httpParam", "apiParms", "apiparparams", "apiParams", "httpParims", "httpparparams", "httpParAMS", "apiParAMS", "httpparms", " httpPars", "httpPeram", "httpParars", "httpPrams", "apiparams", "httpParparams", "httpPams", "httpParam", " httpPms", "httpPerams", "apiparms", "httpPms", "httpParans", " httpParms", "apiparAMS", "apiParparams", "httpPans", "httpPrAMS", "httpparAMS", "httpPerans", "httpParms", "httpPam", "httpparams"], "response": ["sequence", "answer", "image", "resp", "still", "version", "description", "message", "entry", "json", "success", "pos", "given", "resource", "next", "data", "respond", "that", "result", "application", "successful", "report", "http", "page", "status", "body", "object", "Response", "service", "onse", "out", "output", "block", "connection", "tree", "reply", "document"], "entity": ["attribute", "metadata", "obj", "group", "existent", "image", "activity", "unique", "xml", "enc", "Entity", "info", "entry", "ent", "e", "json", "event", "ee", "resource", "me", "email", "one", "data", "translation", "user", "error", "result", "application", "note", "comment", "person", "el", "valid", "peer", "quote", "form", "status", "body", "object", "details", "ity", "code", "phrase", "component", "encrypted", "ce", "net", "token", "document", "pe"], "reader": ["iterator", "linger", "rer", "writer", "per", "older", "reading", "inner", "stream", "loader", "r", "entry", "rr", "file", "buffer", "resource", "read", "parser", "builder", "rar", "data", "user", "roller", "comment", "handler", "worker", "ner", "rl", "range", "Reader", "er", "ro", "iter", "row", "runner", "readable", "input", "dd", "dr", "owner"], "line": ["link", "sequence", "msg", "lane", "where", "liner", "ln", "le", "header", "string", "stroke", "ine", "continue", "lines", "message", "sample", "lined", "entry", "edge", "e", "detail", "label", "Line", "number", "file", "source", "point", "email", "LINE", "eline", "user", "comment", "lin", "nl", "el", "page", "cell", "body", "frame", "day", "text", "chain", "rule", "zone", "phrase", "l", "block", "license", "ice", "row", "inline", "print"]}}
{"id1": "7044153", "id2": "23532405", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendExceptionToHost", "sendExceptionTOHost", "sendErrorToClient", "sendErrorToHost", "sendExceptionTOServer", "sendExceptiontoHost", "sendExceptiontoClient", "sendErrorToServer", "sendErrortoHost", "sendExceptionToClient", "sendErrortoClient", "sendErrortoServer", "sendExceptionTOClient", "sendExceptiontoServer"], "server": ["port", "remote", "version", "string", "ver", "env", "erver", "v", "description", "localhost", "value", "Server", "host", "serv", "channel", "email", "password", "base", "site", "store", "service", "ser", "code", "address", "test", "client", "null"], "ex": ["ix", "obj", "eas", "exp", "none", "any", "tx", "x", "aux", "it", "fail", "exe", "xc", "rex", "ox", "Exc", "rx", "e", "Exception", "event", "Ex", "err", "wx", "one", "error", "example", "ext", "ry", "exit", "EX", "el", "lex", "com", "expl", "or", "pex", "ic", "an", "test", "exclusive", "exc", "except", "re", "ception", "hex", "nex"], "config": ["cache", "cert", "env", "settings", "Config", "auth", "content", "params", "log", "param", "debug", "context", "channel", "password", "fig", "c", "cfg", "conf", "form", "service", "text", "Configuration", "rc", "input", "figure", "ct", "control"], "prob": ["probes", " prbe", "prbj", "probe", " prbes", "prbes", " prb", "Probj", " prbj", "prb", "prbe", "Prob", "probj", "Probes", "Probe"], "dataSB": ["dataWB", "partialSL", " dataSM", "partialSB", "DATASW", "windowSN", "listBB", "dataGB", "mapBS", "ataNB", "cacheSM", "contentSF", "imageBP", "DATABS", "jsonsb", "partialGB", "relationMB", "mapSB", "valueBS", "imageSF", "keyBS", "ataSF", "relationSB", " dataBB", "ataBP", " dataSN", " dataMB", "windowSB", "cacheBB", "dataBP", "DATASF", "divBS", " dataSW", "imageSB", " dataHB", "relBS", "ataSR", "DATASB", "ataSB", "relationQB", "joinWB", " datasb", "imagesb", "relBB", "mapSL", "listEB", "dataBu", "dataSW", "windowBB", "listMB", "divSN", "nextQB", "datMB", "dataRB", "joinsb", "relationSN", "ataBu", "atasb", "cacheBS", "listSF", "dataMB", "imageSw", "cacheBW", "ataBB", "relationRB", "listsb", "nextBS", " dataSA", "resourcesb", "divSF", "resourceSF", "windowBS", "dataSA", "debugBB", "relationBu", "dataEB", " dataSF", "listSI", "listSB", "divSquare", "mapBB", "cacheSA", "defGB", "mapGB", "divBW", "ataQB", "datWB", "keySL", "dateBu", "windowSL", "joinSL", "nextSB", "divBB", "relationSquare", "relationBS", "nextGB", "contentBS", "relSW", "relationSF", "resourceSI", "defQB", "valueSW", "cacheSF", "imageSN", " dataSI", "dateQB", "dataBS", "divSB", "reasonBS", "debugSF", "reasonSF", "imageQB", "dataBW", "reasonSW", "imageHB", "imageSL", "cacheSB", "relSB", "nextBB", "datasb", "contentSN", "keySB", " dataNB", "jsonSB", "dateSB", "jsonSw", "dataSw", "dataHB", "dataSI", "ataMB", "dataQB", "nextSF", "ataSA", "imageNB", " dataBS", " dataEB", "dataSquare", "defBB", "ataSN", "keyBB", " dataGB", "resourceSB", "mapHB", "imageSM", "reasonSB", "windowSF", " dataQB", "partialBB", "defSB", "mapSF", "divNB", "datSL", " dataBP", " dataSquare", " dataSw", "mapSN", "joinSB", "relationBB", "contentNB", "relationSL", "contentSR", "imageBB", "relationNB", "ataSW", "jsonSF", "dataSF", "dataSL", "dataSM", "dataSN", "datSB", "ataBS", "contentSB", "debugRB", "dataBB", "ataSL", "dateBS", "cachesb", "joinSF", "dataSR", "ataEB", "ataWB", " dataSL", "imageBS", "valueBB", "imageSR", "joinMB", " dataBW", "valueSB", "debugSB", " dataRB", "dataNB"], "trace": ["sequence", "ace", "race", "span", "tr", "tile", "true", "stream", "tty", "message", "sample", "track", "se", "stack", "detail", "temp", "buffer", "network", "debug", "log", "profile", "data", "be", "dump", "batch", "comment", "fake", "time", "role", "report", "te", "feature", "frame", "body", "range", "store", "thread", "chain", "address", "create", "history", " Trace", "test", "table", "stable", "list", "tm", "th", "transform", "mt", "style"]}}
{"id1": "22366505", "id2": "21824901", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 0, "substitutes": {"incluir": ["incluiar", "incluar", "inCLuir", "incluator", "inclouar", "inclUir", "inclouir", "inCLuator", "inclUier", "inclouier", "incluier", "incluiator", "inclUator", "incluiir", "incluiier", "inCLuar", "inCLuier", "inCLUir", "inCLUator", "inCLUar", "inclouator", "inclUar", "inCLUier"], "igreja": ["igarreji", "igopenva", "igopenj", " igrejas", "igarreva", " iggrejas", "iggreja", "igvreja", "iggreva", " igcreJa", "iggreji", "igcreJa", " igrej", " iggreja", "igreJa", "igopenja", "igcreja", "igcreji", " iggreva", "igarreJa", "igreji", "igvrej", "iggrej", "iggrejas", "igreje", " igcreja", "igrej", " iggrej", "igarrej", "igvrejas", " igreji", " igreJa", " iggreje", "igrejas", "iggreje", "iggreJa", "igarreje", "igcrej", " igcreji", "igarrejas", "igreva", "igarreja", " igcrej", "igopenji", " igreva", " igreje", "igvreje", " iggreji"], "connection": ["established", "Connection", "link", "response", "server", "conn", "system", "created", "settings", "socket", "statement", "pool", "connected", "description", "message", "current", "which", "database", "connect", "management", "config", "container", "query", " Connection", "session", "network", "ion", "resource", "context", "city", "close", "function", "computer", "reference", "manager", "user", "library", "setup", "application", "c", "communication", "engine", "command", "instance", "generation", "language", "collection", "gate", "condition", "relation", "db", "component", "open", "client", "section", "con", "position", "to", "creator", "operation", "document", "directory", "n"], "sql": ["zip", "url", "pl", "ln", "string", "sq", "select", "statement", "shell", "inv", "sk", "xml", "scl", "description", "title", "expression", "lock", "series", "cmd", "query", "sys", "log", "sd", "plan", "template", "ql", "pel", "sv", "dl", "san", "spr", "login", "q", "nl", "command", "install", "form", "normal", "sol", "sf", "serial", "spec", "csv", "seed", "table", "SQL"], "sql2": ["SQL1", "sql3", "sd2", " sql3", "sql02", "sd4", "ql3", "SQL02", "sd3", "sql4", " sql02", "SQL2", "ql02", " sql1", "sql1", "SQL3", "ql1", "ql2", " sql4", "sd02", "SQL4"], "stmt": ["Stm", "statmn", "restmt", "strm", "reststat", "statMT", "estMT", "stMT", "statm", " stmn", "stmm", "STm", "stmb", "tMT", "tmb", "STmb", "strMT", "estmb", "STMT", "Stmm", " stm", " ststat", "estm", "ststat", "tmt", "Stmn", "STmt", " stmm", "Ststat", "tmm", "strmt", " stMT", "statmt", "Stmt", "StMT", "restm", "stmn", "restmm", "STmn", "STmm", "Stmb", "stm", "strmb", " stmb", "estmt"], "stmt2": ["Stmt1", "stmr4", "stmTwo", "stm2", "sttm2", "stMT3", "sttx2", "stMT2", " stmp4", "stmt02", "stmp3", "stmp1", "Stmem1", "stmt1", "StmtTwo", "stm02", " stmt1", "sttm4", "stmp4", " stmt4", "stMT1", "sttm3", " stmp3", "stmptwo", "stmpTwo", " stmtTwo", "stmrtwo", " stMT02", "stmr1", " stmttwo", "Stmem3", "stm1", "stmemTwo", " stmpTwo", " stmptwo", "sttx02", "StmemTwo", "Stmt2", " stMT3", "Stmt3", " stmp1", "stmem3", " stmt3", "stm3", "Stmem2", "stmr2", "stmt3", "sttx1", " stMT2", " stMT1", "sttx3", "stmttwo", "stmem2", " stmt02", " stmp2", "sttmTwo", "stMTTwo", "stMT4", "stmt4", "stMTtwo", "stMT02", "stmtTwo", "stmem1", "stmp2"], "rs": ["ras", "rt", "cs", "rd", "ws", "ts", "bs", "ps", "ats", "r", "ars", "ds", "rates", "ns", "sr", "RS", "ys", "vers", "gs", "ris", "results", "ss", "xs", "fs", "sts", "res", "rss", "rows", "its", "ims", "ms", "ins", "rys", "pers", "vs", "Rs", "usr", "eps", "mr", "rc", "s", "ros", "js", "qs", "ows", "hs", "ks", "ls"], "retorno": [" retorn", "retorne", "retorn", "retogo", "altorno", "gotorne", "gotora", "altogo", "montorno", "eltorno", "eltano", "altano", "gotorno", "eltorn", " retano", "eltogo", "altorn", "montrero", " retrero", "montora", "retano", "retrero", "montorne", " retogo", " retora", " retorne", "retora", "gotrero"]}}
{"id1": "6470716", "id2": "22879400", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"st": ["sm", "stri", "est", "inst", "sth", "sh", "stream", "se", "ost", "start", "tt", "sta", "ld", "step", "sw", "stra", "sts", "std", "store", "service", "set", "str", "ast", "t", "sty", "ust", "ste", "d", "sn", "ST", "ft", "nd", "St", "stable", "www", "th", "sp", "rt", "ist", "rest"], "url": ["mail", "Url", "link", "hl", "html", "pl", "ch", "cert", "domain", "shell", "string", "addr", "char", "ret", "r", "cl", "mount", "file", "location", "gl", "ssl", "host", "build", "bel", "f", "dl", "base", "abs", "uri", "github", "il", "web", "http", "nl", "sl", "el", "fl", "impl", "str", "ll", "browser", "address", "ref", "loc", "rect", "rel", "l", "client", "null", "www", "URL", "ls", "ur", "rest", "ul", "li"], "fis": ["tiss", "tis", "efis", "uf\u00eds", "xfis", "Fis", "ufiss", " fisl", "tos", "efi", "fiss", "tais", "ufis", "efiss", "xfier", "xfi", "flisl", "ef\u00eds", "fliss", "flis", "fisl", "fei", " f\u00eds", "xfois", "Fiss", " fi", "feis", "fi", "fli", "Fais", "fier", "f\u00eds", "Fier", "Fos", " fiss", "feier", "fois", "Fi", "ufisl", "feois", "ufi", " fais", "fais", "Fois"], "zis": [" zos", "zhisin", "zos", "zenis", "czisa", " zris", "fiss", "zenisi", "zipos", "zris", "zisin", "zhIs", "ozisin", "zits", "ozes", "zipIs", "zIs", "zes", "zisi", "zipisin", " zIs", "zipits", "fits", " ziss", "ozits", "zhes", " zisa", "zhis", "ozis", "zisa", "ozIs", "czits", "ziss", "fris", "zipes", "czis", "zeniss", "ozisa", " zisi", "fisi", "zenris", " zits", "zipis", "czIs"], "entry": ["zip", "name", "attribute", "link", "obj", "existent", "key", "enter", "system", "zo", "pattern", "char", "def", "nt", "se", "info", "member", "entity", "e", "ent", "event", "jo", "source", "de", "log", "tmp", "inter", "Entry", "record", "match", "ry", "result", "comment", "way", "valid", "cell", "form", "or", "office", "card", "chain", "out", "item", "element", "jar", "line", "word", "null", "row", "list", "fr", "ie", "ce", "field", "sp", "be", "index"], "count": ["name", "counter", "len", "ch", "amount", "child", "char", "cc", "nt", "add", "current", "index", "max", "acc", "nb", "last", "number", "start", "buffer", "err", "read", "ount", "match", "call", "num", "batch", "base", "comment", "c", "force", "cont", "sum", "page", "ctr", "cell", "check", "depth", "code", "t", "length", "total", "iter", "Count", "core", "end", "size", "found", "ct", "n", "ind"], "data": ["name", "cache", "image", "string", "ata", "part", "def", "message", "sample", "value", "number", "json", "all", "source", "buffer", "bin", "reason", "dat", "next", "buf", "zero", "result", "step", "batch", "done", "mu", "good", "text", " DATA", "mem", "out", "chain", "d", "table", "output", "length", "block", "n", "DATA", "size", "bytes", "area", "raw", "format"], "fos": ["fool", "Fol", "fOS", "fioss", "wOS", "foops", "hOS", "Fops", "fios", "hos", "woss", "fooss", "his", "wis", "fol", "wos", "hoss", "foss", "fiol", "Foss", " fOS", "Fos", "foos", "fops", "fiops", " foss"], "dest": ["origin", "comp", "est", "nom", "parent", "exp", "writer", "Dest", "master", "src", "pipe", "nt", "target", "member", "temp", "gest", "source", "bin", "comb", "dat", "transfer", "ptr", "coord", "result", "done", "det", "crit", "cont", "way", "pas", "std", "send", "sum", "desc", "mem", "gate", "out", "them", "dc", "loc", "foreign", "test", "des", "usr", "output", "nd", "dist", "trans", "cat", "rest", "decl"]}}
{"id1": "13757855", "id2": "810342", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"process": ["execute", "apply", "replace", "task", "display", "add", "run", "parse", "build", "processor", "call", "step", "project", "save", "Process", "create", "load", "loop", "proc", "write", "render", "transform", "processing", "filter", "handle", "format"], "tpl": ["ttopl", "terld", "topl", "timplug", "ttpl", "tpg", "turtle", " tplates", "ptpl", "timpl", "Tph", " turtle", "tspr", "atuple", "Tpl", "stplate", "otpl", "stbl", "tmpp", "tyPL", "templ", "stpg", "tPL", "ptbl", " tpp", "tembl", "tpp", "stopl", "itbl", "itPL", "tsurtle", "tyurtle", "otld", "typl", "ttplug", "itpl", "Tplate", "atld", " tplate", "terplate", "tplate", "tsbl", "stplug", "Tplates", "stpl", "ttpg", "Tspl", "ttph", "tplug", "timspl", "tph", "tpr", "ptld", "Tpp", "timpg", "atplate", " tbl", "stspl", "tmbl", "tspl", "Tld", "timbl", "timopl", "tmpl", "ptplates", "tsPL", "temPL", "tempr", "otplate", "tuple", "Tbl", "ttPL", "tld", "tplates", "itplate", " tld", "tmplate", "terpl", "tmplates", "tmPL", "atpl", " tuple", "TPL", "tbl", "timplate", "Tpr", "ttbl", " tPL", "teruple", " tph", "otbl"], "model": ["html", "parent", "M", "content", "node", "file", "product", "log", "Model", " Model", "data", "record", "project", "m", "base", "Document", "el", "models", "object", "md", " models", "module", "tree", "ml", "document"], "packageName": ["PackageClass", "pkgNames", "PackageRoot", " packageRoot", "viewname", "groupVersion", "groupFamily", "viewRoot", "viewClass", "packageNames", "groupNames", "packagename", "viewName", "packageFamily", " packageNames", "packageVersion", "pkgVersion", " packageClass", "PackageName", " packageFamily", "groupName", "pkgName", "packageClass", "packageRoot", "pkgFamily", "Packagename", " packagename", " packageVersion"], "outFileName": ["outFilename", "infileType", "outFNames", "outFileType", "outFilenameSize", " outFilenamename", "outStreamTime", "outFilenameTime", "outTableName", " outTableName", "outDirSize", "outFileSize", " outFilenamePath", "outTableChain", "outfileNames", "outFilenameName", "outImagePath", "outFilenamename", " outfileNames", "outStreamPath", "outfileTime", "outDirName", " outFileTime", "outDirTime", " outFilenameName", "outfileName", "outFilenamePath", "infileName", "outTableType", "outStreamType", "outfileType", "inFileTime", "outFileChain", " outFileType", "outTableTime", "infileNames", "outFileNames", " outFilePath", "infilePath", " outfileName", "outFPath", " outFilenameType", "outfileChain", "inFileName", "outFilenameChain", "outfilename", " outFileNames", " outFilenameChain", " outfilename", " outFileChain", "outFname", "outFilenameType", "outFileTime", "inFilePath", "outImagename", "outFName", " outfilePath", " outTableTime", " outFilenameSize", " outTablePath", "infileTime", " outTableSize", "outTablePath", " outFilename", "outDirPath", "outFilenameNames", "inFileType", "inFileNames", "outStreamNames", "outImageName", "outfilePath", "outImageSize", " outFileSize", "outFilePath", "outStreamName", "outTableSize", "outTablename"], "xsltParam": ["xsltParameter", "xsslParam", "xltParameter", "xsqlParam", "xltConf", "xsslConf", "xsslParameter", "xsmlParam", "xmlParam", "xsltConf", "xltParam", "xsqlParameter", "xmlConf", "xsmlParameter", "xsqlConf", "xsmlConf", "xmlParameter"], "artifact": ["artifacts", "artificial", "anificate", "ardificate", "ardificial", "artificate", " artificial", " artifacts", " artificate", "Artifacts", "ardifact", "anifacts", "partifact", "anificial", "arifact", "partifacts", "anifact", "Artifact", "arifacts", "ardifacts"], "destinationPath": ["destationDir", "estinationName", "destinerDir", "desturationpath", "desturationPath", " destinationTarget", " destociationDisk", "estinationKey", "desticationDir", "descositoryHost", "destATIONPort", "destociationHost", "destATIONPath", "destinationAt", "estinationPoint", "identinateKey", "destacementTime", "identinatePath", "destinatedTarget", "destificationLocation", "DestinationLocation", "estationPath", "estionPATH", "estationDir", "destinatePart", "destinationPoints", "destinationDisk", "destinatorPoint", "DestensionPath", "generinationAt", "destinationTime", "destinatorPath", "origininatedNow", "destregationpath", " destociationpath", "DestensionHost", "destificationDir", "destinationTemp", "DestensionTemp", "DestensionPod", "generinatePath", "destinoName", "destionPATH", "destinationName", "DestinationTemp", "destinateForm", "destinationJar", "chaininatedDisk", "desturationJar", "destociationPoint", "destinatedDisk", "destinatorParent", "destinantPod", "origininationForm", "generinateJar", "destinateLocation", "destinatedDriver", "destinateInfo", "destinerPart", "destesticSystem", "estinationHost", "destinatorpath", "estinationPATH", "destinateChain", "chaininationHome", "generinationSystem", "destinateUrl", "destinationForm", "destinatePath", "destinoTime", "estionPath", "destionpath", "destinantPath", "destositoryParent", "DestinationHost", "destinateNow", "delinationLog", "delinatePoints", "destociationHome", "destinateAt", "estinoPath", "destitutionPATH", "destitutionPoint", "destinerJar", "delinateForm", "destociationDisk", "destinationParent", "origininatedPath", "termininerTarget", " destinationpath", "generinationPath", "descinationParent", "destationPart", "identinateChain", "destinatedKey", "desticationPath", "destinateSystem", "destigationPath", "destinerSystem", "destacementKey", "DestinationPoint", "destesticJar", "destinationLocation", "destinationPATH", "chaininationDisk", "termininationJar", "delinationPoints", "destositoryPort", "destesticAt", "destinationpath", "destinatorPort", "destinationPart", "estinoKey", "estinoTime", "destationPath", "destinateKey", "destinateDir", "DestensionDir", "destensionTemp", "descinationPort", "destacementPath", "destinatorChain", "destregationDisk", "estinationDir", "delinationPath", "destinoHost", "destociationTarget", "chaininatedDriver", "estinationpath", "destinerAt", "destensionPath", "destociationLog", "destATIONParent", "DestinationPath", "destinationUrl", "termininationPath", "chaininatedPath", "destinatedPath", "destinationPort", "termininationTarget", "destositoryHost", "identinationChain", "generinateAt", "destationUrl", "destinerTarget", "termininationpath", "destinerpath", "destinationHost", " destociationPath", "destregationTarget", "origininationChain", "destinationLog", " destinationDisk", "destrancePoints", "descinationPath", "destensionHost", "destinateName", "destationHost", "estionpath", "destranceForm", "descinationHost", "generinateSystem", "DestificationPath", "destionPoint", "destinatorPATH", "destinatePoints", "destinationTarget", "destinoDir", "destigationNow", "destensionPod", "destinerHost", "destinationKey", "estinationPart", "destinoPath", "destinatedInfo", "destinatorHost", "estinationTime", "destacementName", "destitutionPath", "DestensionPoint", "destinationPod", "destinantTemp", "DestinationDir", "destensionPoint", "DestificationDir", "DestinationUrl", "delinatePath", "origininationPath", "origininationNow", "chaininationPath", "DestinationPod", "destventionDriver", "descositoryParent", "destinatedHome", "desticationPod", "destinationDir", "destranceLog", "descositoryPath", "destensionDir", "identinationKey", "destinateLog", "destinationInfo", "destventionPath", "destventionDisk", "estionPoint", "termininerPath", "generinationJar", "identinationPath", "desticationTemp", "delinateLog", "chaininationDriver", "destificationUrl", "destrancePath", "destinatepath", "destociationDriver", "destociationPath", "destinateJar", "destinationPoint", "chaininatedHome", "destventionHome", "destinationChain", "identinateInfo", "delinationForm", "destationLocation", "destATIONHost", "destinateTarget", "identinationInfo", "destinantDir", "destinateHost", "desturationTarget", "termininerpath", "destociationDir", "destitutionpath", "destociationPoints", "destinatedForm", "destociationForm", "destinationNow", "destigationForm", "destinatedNow", "termininerJar", "destinatedpath", "destinationDriver", "descositoryPort", "destinationSystem", "estationHost", "destociationpath", "destinatedChain", "origininatedChain", "destinoKey", "destositoryPath", "estinationPath", "destinateTime", "destionPath", "destinoPoint", "estinoName", "destigationChain", "destinatorKey", "destinationHome", "destregationPath", "estationPart", "DestificationLocation", "destinerPath", "destesticPath", "origininatedForm", "destificationPath", " destociationTarget", "DestificationUrl", "destinatorInfo"], "in": ["inner", "r", "din", "info", "w", "file", "bin", "i", "io", "id", "f", "m", "c", "In", "ins", "t", "IN", "o", "d", "doc", "l", "input", " IN", "reader", "n"], "out": ["msg", "obj", "println", "up", "cache", "ln", "conn", "go", "ch", "writer", "p", "it", "Out", "inv", "inner", "ex", "v", "nt", "w", "outer", "aos", "dis", "oe", "e", "cmd", "u", "file", "nr", "all", "log", "err", "sys", "ger", "b", "io", "gen", "f", "c", "res", "report", "cfg", "conf", "cn", "or", "ins", "t", "o", "l", "write", "output", "gr", "client", "con", "null", "os", "s", "to", "list", "co", "screen", "OUT", "outs", "net", "print", "can", "n", "raw", "ou"], "root": ["name", "Root", "println", "group", "child", "parent", "initial", "p", "New", "def", "Template", "scope", "se", "r", "parents", "node", "json", "config", "start", "de", "context", "roots", "data", "id", "dump", "m", "_", "impl", "chain", "create", "ok", "table", "dir", "tree", "graph", " roots"]}}
{"id1": "18005010", "id2": "5135688", "code1": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "code2": "    private boolean saveNodeMeta(NodeInfo info, int properties) {\n        boolean rCode = false;\n        String query = mServer + \"save.php\" + (\"?id=\" + info.getId());\n        try {\n            URL url = new URL(query);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            byte[] body = Helpers.EncodeString(Helpers.ASCII, createURLEncodedPropertyString(info, properties));\n            conn.setAllowUserInteraction(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            setCredentials(conn);\n            conn.setDoOutput(true);\n            conn.getOutputStream().write(body);\n            rCode = saveNode(info, conn);\n        } catch (Exception ex) {\n            System.out.println(\"Exception: \" + ex.toString());\n        }\n        return rCode;\n    }\n", "label": 0, "substitutes": {"setProfile": ["storeProfile", "storeProperty", "setDefault", "SETProperty", "SETProf", "setProf", "storeProf", "SETProfile", "setProperty", " setDefault", "SETDefault", " setProf", " setProperty", "storeDefault"], "loginName": ["loginname", "fileKey", "fileNames", " loginKey", "filename", "displayname", " loginNames", "loginKey", "fileName", "displayKey", "displayNames", "displayName", " loginname", "loginNames"], "profile": ["port", "option", "picture", "header", "p", "pse", "settings", "pool", "usage", "sample", "memory", "panel", "title", "photo", "face", "prof", "json", "config", "update", "buffer", "log", "context", "property", "data", "template", "FILE", "user", "plot", "password", "result", "project", "note", "phone", "base", "report", "role", "pty", "feature", "details", "frame", "hash", "summary", "mem", "history", "relation", "Profile", "output", "client", "line", "table", "policy", "position", "account", "document", "style", "username", "properties"], "outStream": ["aosPoint", "servStream", "outFile", "aosWriter", " outFile", "outputFile", " outSteam", "aosStream", "Outstream", "exSteam", "outView", "OutSteam", " outView", "offSteam", " outWriter", " outPoint", "offStream", "outPoint", "offstream", "outputView", "exWriter", "OutWriter", "outstream", "servstream", "OutStream", "outputstream", "outWriter", "exPoint", "servView", "exStream", "outputSteam", "offWriter", "aosSteam", "OutFile", "servSteam", " outstream", "OutView", "outSteam", "outputStream"], "url": ["mail", "Url", "link", "html", "pl", "path", "cert", "string", "org", "char", "xml", "r", "mount", "location", "ssl", "resource", "host", "build", "email", "parse", "bel", "f", "base", "dl", "abs", "uri", "web", "http", "nl", "q", "service", "impl", "str", "ll", "browser", "address", "https", "loc", "rel", "l", "open", "get", "client", "URL", "re", "ls", "ur", "li"], "file": ["ile", "fp", "name", "link", "port", "path", "le", "File", "image", "pool", "document", "info", "entry", "download", "filename", "resource", "local", "email", "template", "FILE", "library", "result", "f", "base", "report", "web", "page", "lf", "body", "out", "binary", "db", "table", "output", "null", "tree", "print", " File", "format"], "connection": ["established", "Connection", "character", "link", "response", "online", "conn", "system", "still", "socket", "statement", "created", "connected", "pointer", "connect", "database", "number", "network", "session", "ion", "cone", "resource", "computer", "city", "channel", "close", "application", "c", "communication", "web", "command", "nc", "generation", "sql", "console", "condition", "no", "bo", "relation", "client", "open", "con", "position", "to", "dial", "net", "directory", "closure"], "writer": ["writers", "iterator", "println", "counter", "Writer", "external", "liner", "wa", "journal", "wrote", "ws", "operator", "owner", "inner", "fn", "loader", "wright", "commit", "entry", "w", "wrapper", "outer", "writ", "flush", "node", "event", "buffer", "walker", "network", "variable", "builder", "function", "processor", "comment", "handler", "storage", "written", "driver", "maker", "format", "worker", "caster", "ner", "draw", "usher", "widget", "er", "riter", "editor", "rw", "write", "client", "word", "creator", "WR", "runner", "document", "reader", "window", "wt", "writing"], "myEnum": [" myAnom", "someENum", " myENom", "someEnums", "myENum", " myEnet", "myEnUM", "myAcum", "myENet", " myENumb", "myenum", " myAnet", " myEnums", "myAnUM", "myEncums", "myAnumb", "myEncum", "myEnet", "someEnumb", "myEncumb", "myAnet", "someEnum", "myAnum", "myENumb", " myENum", "myAcom", " myEnom", "someEnUM", "someENUM", "myenom", " myAnums", "myENom", "myAcums", "myEncUM", "myEnums", "myEnom", " myAnum", "someENumb", "myAnums", "myAcet", "myENUM", "someENums", "myAnom", "myEnumb", "myenumb", " myEnumb", "myEncom", "myENums"], "key": ["attribute", "name", "ace", "child", "parent", "string", "it", "part", "char", "a", "ex", "v", "info", "entry", "index", "title", "member", "mac", "label", "value", "node", "variable", "i", "k", "keys", "host", "air", "val", "one", "column", "KEY", "id", "step", "Key", "m", "base", "type", "cell", "cond", "prefix", "hash", "str", "text", "item", "chain", "element", "no", "bo", "test", "word", "n", "ice", "ek", "row", "field", "token", "note", "primary", "pair", "var", "col", "pe", "owner"]}}
{"id1": "149935", "id2": "2982747", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public FileParse(String fileStr, String type) throws MalformedURLException, IOException {\n        this.inFile = fileStr;\n        this.type = type;\n        System.out.println(\"File str \" + fileStr);\n        if (fileStr.indexOf(\"http://\") == 0) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"File\")) {\n            File inFile = new File(fileStr);\n            size = inFile.length();\n            inStream = new FileInputStream(inFile);\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URL\")) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URLZip\")) {\n            URL url = new URL(fileStr);\n            inStream = new GZIPInputStream(url.openStream(), 16384);\n            InputStreamReader zis = new InputStreamReader(inStream);\n            bufReader = new BufferedReader(zis, 16384);\n        } else {\n            System.out.println(\"Unknown FileParse inType \" + type);\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["Converting", "conVERT", "consvert", "CONversion", "conversion", "unfer", "converted", "compvert", "compversion", "consversion", "compverts", "Converted", "unversion", "converting", "CONverted", "CONfer", "unvert", "converts", "consVERT", "Conversion", "CONverting", "conprocess", "ConVERT", "CONVERT", "CONvert", "consverting", "Confer", "unverted", "confer", "Conprocess", "unverts", "compprocess", "Convert", "Converts", "unprocess"], "src": ["Source", "scan", "url", "hl", "path", "orig", "attr", "sq", "inst", "addr", "cc", "sin", "rs", "stream", "ource", "href", "sr", "rx", "file", "config", "source", "ebin", "start", "filename", "sys", "SourceFile", "sit", "ipl", "host", "func", "RC", "scene", "iv", "txt", "from", "cont", "uri", "http", "its", "st", "str", "ser", "ins", "cur", "img", "loc", "rel", "usr", "pkg", "buster", "sc", "ur", "req", "rc", "s", "dist", "input", "SOURCE", "rest", "upload"], "dest": ["port", " destinations", "orig", "est", "Dest", "mat", " Destination", "target", "temp", " orig", "source", " destination", "gin", "dat", "result", "txt", " dst", " Dest", "img", "test", "foreign", "write", "table", "tif", "disk", "dir", "dist", "rest"], "in": ["inn", "up", "is", "inner", "stream", "isin", "r", "din", "file", "source", "b", "bin", "i", "io", "serv", "ad", "ar", "m", "from", "res", "In", "el", "sql", "st", "ins", "en", "IN", "d", "l", "input", "cin", "rin", "reader", "as", "inf", "ind"], "p": ["fp", "pc", "php", "pl", "pp", "per", "it", "part", "g", "ps", "r", "pro", "py", "pg", "vp", "b", "ph", "i", "h", "ap", "parser", "P", "parse", "j", "pa", "pd", "f", "m", "lp", "c", "ping", "rep", "pm", "post", "prot", "op", "t", "pre", "er", "pers", "at", "jp", "dp", "d", "pb", "l", "pkg", "wp", "pt", "pi", "sp", "cp", "pe", "tp"], "ds": ["cs", " os", "ports", "drivers", "dh", " ads", "ss", "scripts", "di", "dates", "edes", "sts", " d", "tests", "nas", "dds", "aws", "hd", "obs", "posts", "bs", "rs", "cks", "DS", "ys", "uds", " dd", "eds", "its", "vs", "dp", "d", "os", "terms", "outs", "qs", "dd", "pd", "tp", "ras", "ts", "ods", "Ds", "tes", " DS", "ps", "points", "ils", "gs", "amps", "docs", "xs", "ands", " des", "workers", "lists", "ads", "des", "db", "eps", "dos", "iffs", "dt", "js", "ks", "ls", "mys", "yes", "ws", "gd", "ats", "els", "sets", "ns", "sd", "tags", "loads", "dl", "ags", "s", "hs", "df"], "format": ["name", "unit", "lat", "path", "shape", "version", "it", "settings", "mat", "pattern", "act", "fm", "MAT", "ats", "title", "file", "source", "layout", "parse", "sche", "template", "top", "id", "fc", "f", " Format", "type", "mode", "status", "form", "tag", "feature", "set", "t", "spec", "at", "cf", "table", "output", "module", "l", "policy", "feat", "size", "pretty", "pi", "filter", "mt", "ct", "style", "Format"], "hasPixelData": ["haspixelDATA", "hasFramedata", "HaspixelData", "hasixelData", "hasPixeldata", "hasixelDATA", "hasFrameDATA", "hasFrameData", " hasPixelDATA", "HasPixelDATA", "hasPixelDATA", "HasPixelData", "HaspixelDATA", "haspixeldata", "Haspixeldata", "HasPixeldata", " hasPixeldata", "hasixeldata", "haspixelData"], "inflate": ["Informate", "inFlocate", "informate", "invalidocate", " invalidATE", "inflATE", "inflated", "informated", "inFLated", "infolat", "incelicate", "inFlATE", "informat", "Inflat", "infolated", "invalidicate", "inFLat", "informocate", "incelocate", "Inflocate", "inFlate", "Informocate", "inFLocate", "incelate", "inflocate", "invalidate", "inFLate", " inflocate", "infolate", "inflicate", "invalidATE", "infolocate", "inFlicate", "Informated", " invalidicate", "Inflated", " invalidate", "incelATE", "inflat", " invalidocate", "Inflate", " inflicate", " inflATE", "Informat"], "pxlen": ["packls", "mxdec", "pexlen", "packln", "pxls", "pexfun", "xpden", "mxln", "phpdec", "tmpln", "pxden", "mxlength", "mmlen", "xyln", "mmln", "phpln", "pixellength", "pxdec", "xplen", "pixells", "pexln", "tmplength", "xylength", "cpden", "pxlin", "tmplin", "mmlength", "phplength", "pixelfun", "xylin", "cplength", "mmlin", "packdec", "pxln", "pexlength", "xylen", "tmplen", "xplength", "pxfun", "phplen", "mxlen", "pxlength", "pexls", "pexden", "pixellen", "packlen", "xpln", "packfun", "cplen", "cpln", "packlength"], "out": ["name", "msg", "obj", "group", "up", "conn", "ln", "init", "writer", "gov", "inv", "Out", "ex", "aos", "outer", "temp", "cmd", "log", "err", "sys", "io", "inter", "user", "crit", "res", "cfg", "sum", "store", "prefix", "client", "output", "dir", "gr", "list", "outs", "OUT", "screen", "net", "pretty", "print", "ou"]}}
{"id1": "9272325", "id2": "5977352", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"sendPost": ["doPOST", "executeRequest", "httpGet", "doGet", "httpPOST", "doRequest", "doPost", "sendGet", "executePost", "executePOST", "executeGet", "httpPost", "sendPOST", "httpRequest", "sendRequest"], "reqUrl": ["requestUrl", "resStr", "requName", "reqPath", "requestPath", "requUrl", " reqPath", " reqStr", "resUrl", "requLink", "reqLink", "seqURL", "reqName", "reqStr", "seqUrl", "seqName", " reqURL", "seqLink", " reqName", "resURL", "requestURL", "resPath", " reqLink", "requURL", "reqURL", "requestStr"], "parameters": ["parmes", "promams", "publiceter", "promuments", "promations", "paruments", "equeters", "arameters", "equams", "aramuments", "paramuments", "equations", "paramams", "arammes", "publicams", "prometers", "parameter", "arameter", "parammes", "prometer", "pareter", "prommes", "publications", "publiceters", "pareters", "paramations", "equeter"], "urlConn": ["relConnection", "mountConnector", "utilConnection", "urlCo", "mountCtrl", " urlConnect", " urlConnector", "rowCo", "objCo", "retConn", "webConnect", "resourceLink", "objConn", "relCo", "resourceConn", "mountConn", "belConn", "retConnect", "urlConnector", "mountCo", "fileconn", "relConn", "urlCon", "fileConn", "urlConnection", " urlCon", "implDesc", " urlCtrl", "mountconn", "URLconn", "utilConnector", "nlConnect", "sslCond", "sslDesc", "urlConnect", "belDesc", "leftConn", "implCond", "sslCon", "mountWr", "sslCo", "nlConnector", "URLConnect", "implConn", "leftConnect", "objCtrl", "URLConn", "webConn", "httpConnection", "nlConn", "belCond", "URLCon", "urlLink", "httpConnect", "rowConn", "fileConnection", "sslConnector", "utilConn", "urlDesc", "httpConn", "urlCtrl", "rowConnection", " urlCo", "relconn", "sslConnect", "nlConnection", "leftconn", "implConnection", "fileCon", "utilConnect", "leftCon", "belConnection", "resourceWr", "resourceconn", "retconn", " urlWr", "relConnector", "sslConnection", "sslconn", "urlWr", "mountLink", "urlconn", "rowconn", "httpConnector", " urlConnection", " urlconn", "urlCond", "objconn", "sslConn", "webconn", " urlLink"], "params": ["units", "p", "string", "posts", "rs", "ps", "v", "json", "Parameters", "values", "config", "AMS", "points", "param", "keys", "tags", "results", "data", "padding", "pps", "password", "files", "phys", "m", "base", "services", "pins", "conf", "prefix", "changes", "types", "terms", "s", "ams", "options", "names", "bytes", "properties"], "url": ["Url", "name", "hl", "loader", "r", "sb", "mount", "lb", "location", "log", "ssl", "build", "bel", "f", "dl", "il", "abs", "uri", "base", "web", "http", "nl", "sl", "el", "uu", "rl", "str", "ll", "t", "out", "au", "https", "loc", "pkg", "l", "get", "URL", "self", "ls", "ur", "ul"], "b": ["bits", "obj", "p", "bc", "it", "bs", "cb", "mb", "v", "a", "B", "r", "w", "sb", "nb", "u", "buffer", "bin", "i", "buf", "bb", "orb", "bp", "bit", "f", "eb", "base", "m", "batch", "bis", "bf", "gb", "br", "buff", "binary", "d", "db", "l", "ob", "block", "n", "rb", "s", "z", "fb", "be", "bytes"]}}
{"id1": "3401153", "id2": "7891509", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"getHTML": ["getJS", "processURL", "printHTML", "processPDF", "printURL", "getURL", " getPDF", "getPDF", "printJS", " getJS", " getURL", "processHTML", "processJS", "printPDF"], "pageURL": ["baseURI", " pageurl", "Pageurl", "cacheUrl", "baseUrl", " pageURI", "PageURI", "PageUR", "cacheURI", "PageUrl", "pageUrl", " pageUrl", "baseURL", "baseUR", "cacheurl", "pageurl", "PageURL", "pageURI", "pageUR", " pageUR", "cacheURL"], "encoding": ["Encoding", "ecoded", "Encoded", "enoding", "uncaching", "decuation", "ecaching", "decoder", "uncoding", "Encoder", "decaching", "Encuation", "enuation", "ecoder", "encaching", "encoded", "enaching", "encoder", "enoder", "Encaching", "ecoding", "decoding", "uncoded", "uncoder", "encuation"], "dirPath": ["dirDir", "dirName", "directoryName", "folderRoot", "viewDir", "dirRoot", " dirDirectory", "dirDirectory", "pathDir", "pathFile", "directoryPATH", "pathRoot", "directoryDir", "pkgDirectory", "viewPath", "folderFile", "folderPath", "viewName", "dirFile", "directoryPath", "pkgDir", " dirRoot", " dirFile", "pathPath", "dirPATH", "pkgName", "pkgPath", "folderDir", " dirName", " dirPATH", "viewPATH", "directoryDirectory", " dirDir"], "pageHTML": ["PageHT", " pageJS", "pagePUT", "entryAPI", "entryHTML", " pageJSON", "viewJSON", "PageHTML", "searchURL", "pageHT", "pageAPI", "pointHTTP", " pageAPI", " pageHT", "pointJS", "ageMD", "ageHTML", "agePUT", " pageMD", "displayHTTP", "componentHT", " pageSQL", "componentSQL", "pointAPI", "displayJS", "entryJS", "PageHTTP", "displayURL", "pageJS", " pagePUT", "componentHTML", "searchJS", "pageSQL", "pageWP", "pageHTTP", "searchHTML", "pointHTML", "ageHT", "PageURL", "componentWP", "viewHTML", "PageJS", "searchHT", "viewPUT", "ageSQL", " pageWP", "entryHTTP", " pageHTTP", "displayHTML", "viewMD", "ageJSON", "pageJSON", "ageWP", "pageMD"], "connection": ["remote", "character", "Connection", "link", "established", "response", "server", "conn", "writer", "still", "statement", "socket", "connected", "government", "description", "message", "current", "internet", "entry", "connect", "database", "number", "network", "session", "ion", "resource", "creation", "channel", "close", "io", "reference", "processor", "library", "user", "application", "c", "uri", "communication", "web", "http", "engine", "command", "nc", "generation", "console", "browser", "condition", "bo", "relation", "client", "open", "con", "position", "to", "creator", "operation", "document", "directory"], "url": ["Url", "link", "name", "conn", "path", "p", "loader", "atl", "r", "b", "location", "gl", "ssl", "resource", "bel", "f", "dl", "base", "uri", "web", "http", "nl", "sl", "rl", "str", "ll", "google", "address", "api", "https", "rel", "l", "open", "get", "client", "URL", "net", "ls", "ur", "ul"], "br": ["ch", "tr", "bc", "BR", "bs", "bl", "hr", "r", "bh", "sr", "Br", "wr", "b", "bd", "bridge", "buf", "ber", "bb", "be", "bp", "vr", "bf", "gb", "str", "er", "pr", "shr", "bt", "bro", "mr", "cr", "lr", "rb", "fr", "sp", "dr", "kr"], "line": ["link", "sequence", "online", "ln", "liner", "stay", "le", "stroke", "string", "ine", "continue", "sample", "entry", "entity", "detail", "label", "Line", "number", "source", "point", "log", "email", "LINE", "eline", "user", "comment", "lin", "nl", "page", "cell", "quote", "frame", "range", "text", "code", "chain", "phrase", "l", "section", "word", "block", "row", "inline", "field", "print", "style"], "e": ["xe", "ue", "le", "p", "E", "x", "ine", "ex", "se", "ite", "oe", "je", "ent", "ee", "event", "de", "err", "ve", "es", "error", "f", "eb", "see", "he", "te", "ge", "en", "er", "eeee", "ne", "ke", "fe", "esome", "re", "ae", "ie", "ce", "ode", "be", "ed", "ze", "pe"], "file": ["ile", "port", "fp", "mail", "name", "link", "le", "path", "parent", "File", "tile", "image", "task", "lock", "buffer", "log", "h", "resource", "io", "email", "data", "FILE", "f", "base", "report", "web", "el", "page", "out", "db", "work", "table", "output", "dir", "ca", "et", "print", " File", "directory", "handle"], "bufferedWriter": ["buffaredwriter", "bufferredwriter", " bufferedWrite", "buffaredMember", " bufferredHelper", "buffaredStreamer", " bufferredwriter", "bufferingReader", "buffererWriter", "bufferredHelper", "bufferedReader", "buffaredReader", "buffererMember", "builteredWriter", "bufferedMember", "bufferedStreamer", "bufferingStreamer", "buffenedClient", " bufferredWriter", " bufferredClient", "builteringWriter", " bufferredWrite", "bufferredWrite", "buffenedWrite", "bufferingMember", "buffenedHelper", "builteringReader", " bufferedStreamer", "bufferedClient", " bufferedClient", " bufferredStreamer", "bufferingWriter", "bufferedwriter", "bufferedWrite", "bufferredStreamer", "builteredReader", " bufferedwriter", "bufferedHelper", "buffererReader", "bufferingClient", "bufferredClient", "buffaredWrite", "bufferingwriter", "builteringMember", "buffenedWriter", "bufferingHelper", "builteredMember", "bufferredWriter", "bufferingWrite", " bufferedHelper", "buffaredWriter"]}}
{"id1": "9802073", "id2": "1357662", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 0, "substitutes": {"testAutoCommit": ["testAutoDebits", "testAutoCompute", "testAutoCommmit", "testAutoCompmit", "testAutoCommute", "testAutoComit", "testAutoCompit", "testAutoDebit", "testAutoCompits", "testAutoComits", "testAutoCommits", "testAutoDebmit", "testAutoComute", "testAutoDebute"], "con": ["cons", "obj", "conn", "go", "ln", "ac", "bc", "ver", "ain", "clean", "const", "cc", "comm", "act", "xc", "don", "rec", "enc", "tc", "connect", "pen", "gc", "cos", "local", "ran", "col", "conv", "win", "gen", "cal", "call", "fc", "c", "res", "coll", "conf", "nc", "com", "ctrl", "CON", "cur", "fl", "canon", "en", "out", "bo", "cm", "cf", "client", "ctx", "Con", "rc", "connection", "dial", "ca", "co", "re", "Conn", "fac", "cat", "mc", "ct", "can", " conn", "cp", "cn"], "stmt": [" stmp", "STmp", "Stm", "statmm", "statmb", "stpt", "stct", "strm", "Starm", " stgr", "strmp", " starm", "stMT", " stpt", "stgr", "strmm", " superstmb", " superstmt", "stmm", "STm", "stmb", "statgr", "STmb", "STMT", "Stmm", " stm", "strgr", " superstm", "STpt", "stmp", " superstarm", "Stmp", "Stct", "STmt", " stmb", " stmm", "strmt", " stMT", "starm", "statmt", "Stmt", " stct", "StMT", "Stpt", "statct", "stm", "strmb", "Stmb", "statm"], "rs": ["ras", "obs", "rt", "cs", "rd", "ws", "icks", "ges", "bs", "cks", "stats", "ats", "ars", "ds", "rates", "ers", "sr", "irms", "ubs", "RS", "sys", "ys", "vers", "gs", "ris", "results", "ss", "xs", "ems", "sts", "fs", "res", "ags", "rows", "its", "ares", "acs", "ims", "ms", "ins", "rys", "dds", "vs", "Rs", "usr", "acks", "times", "ra", "mr", "rc", "ros", "ires", "js", "qs", "ows", "hs", "ks", "arms", "ues", "ls"]}}
{"id1": "9033641", "id2": "8754809", "code1": "    public void testHttpsConnection_Not_Found_Response() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            try {\n                doInteraction(connection, ss, NOT_FOUND_CODE);\n                fail(\"Expected exception was not thrown.\");\n            } catch (FileNotFoundException e) {\n                if (DO_LOG) {\n                    System.out.println(\"Expected exception was thrown: \" + e.getMessage());\n                }\n            }\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 0, "substitutes": {"testHttpsConnection_Not_Found_Response": ["testHttpsConnection_Not_Present_Exception", "testHttpsConnection_Not_FoundErrorResponse", "testHttpsConnection_Not_PresentErrorResponse", "testHttpsConnection_Not_FoundExceptionResponse", "testHttpsConnection_Not_FoundExceptionHandler", "testHttpsConnection_Not_FoundExceptionException", "testHttpsConnection_Not_Found_response", "testHttpsConnection_Not_FoundStatusresponse", "testHttpsConnection_Not_FoundStatusHandler", "testHttpsConnection_Not_Found_Exception", "testHttpsConnection_Not_FoundStatusResponse", "testHttpsConnection_Not_FoundErrorresponse", "testHttpsConnection_Not_Present_Handler", "testHttpsConnection_Not_PresentErrorHandler", "testHttpsConnection_Not_FoundExceptionresponse", "testHttpsConnection_Not_Present_Response", "testHttpsConnection_Not_FoundErrorException", "testHttpsConnection_Not_PresentErrorresponse", "testHttpsConnection_Not_FoundErrorHandler", "testHttpsConnection_Not_Found_Handler", "testHttpsConnection_Not_PresentErrorException", "testHttpsConnection_Not_FoundStatusException", "testHttpsConnection_Not_Present_response"], "ctx": ["obj", "conn", "init", "ws", "bc", "tx", "sq", "socket", "qu", "cmp", "cc", "pool", "tc", "cl", "pg", "config", "sys", "ssl", " cx", "context", "tmp", "np", "setup", "hw", "txt", "tz", "nc", "ctrl", "https", "jp", "proc", "pkg", "cm", "cf", "Context", "sc", "co", "hs", "mc", "rt", "ct", "cp"], "ss": ["cs", "ws", "sq", "css", "socket", "ssh", "soc", "tx", "iss", "rs", "sk", "si", "bs", "ps", "ds", "sb", "hess", "SS", "so", "sys", "network", "sit", "ssl", "serv", "ses", "ess", "sw", "fs", "rss", "sol", "sf", "https", "sc", "aws", "oss", "sch", "hs", "sp", "ks", "ls", " SS"], "hnv": ["dnvc", "hdvd", "dnver", "hnvd", "dnv", "bnver", " \u00b5v", " \u00b5vd", "hdj", " knV", " \u00b5V", "dnj", "hnver", "hdvc", "hnj", "bnv", " knvd", "hdw", "hdver", "hnV", "hnw", "hnvc", " knv", " \u00b5w", "hdV", "bnvc", "hdv", " knw", "bnj"], "url": ["Url", "name", "util", "oul", "pl", "char", "atl", "r", "sb", "mount", "file", "dll", "location", "log", "ssl", "parse", "build", "kl", "f", "dl", "il", "abs", "uri", "http", "sl", "nl", "el", "rl", "str", "ll", "t", "api", "address", "https", "l", "client", "arl", "URL", "ml", "ol", "ls", "ur", "ul"], "connection": ["established", "Connection", "link", "sequence", "response", "server", "conn", "system", "statement", "socket", "connected", "message", "entry", "connect", "database", "management", " Connection", "session", "network", "ion", "resource", "context", "channel", "ssl", "log", "close", "application", "c", "handler", "communication", "command", "instance", "object", "service", "condition", "relation", "client", "open", "wrapper", "cp"]}}
{"id1": "3558512", "id2": "21824901", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["serialate", "serialized", "Serializer", "erialate", "erializer", "finalized", "initialization", "serializer", "erialized", "finalization", "finalize", "erialize", "Serialze", "finalze", "Serialate", "serialze", " serialate", "serialization", "Serialization", "initialize", " serialized", "initialze", "initialized", "Serialized", " serializer", "Serialize"], "out": ["up", "ch", "p", "it", "Out", "pool", "stream", "v", "a", "w", "aos", "file", "b", "log", "err", "i", "io", "serv", " OUT", "result", "f", "sw", "c", "res", "report", "sum", "t", "o", "d", "OU", "output", "os", "to", "outs", "OUT", "n", "ou"], "parser": ["aser", "util", "rer", "magic", "writer", "p", "per", "now", "part", "inner", "xml", "loader", "job", "tp", "layer", "file", "ker", "Parser", "ger", "walker", "builder", "jack", "parse", "manager", "bank", "plan", "processor", "password", "arser", "base", "handler", "lp", "worker", "peer", "command", "instance", "tar", "asser", "language", "er", "proc", "pkg", "policy", "tree", "ler", "token", "reader", "style", "format"], "on_disk": ["on_link", "On2disk", "on_Disk", "on2Disk", " on_disc", "on_download", "On2link", "On_file", "On_Disk", " on_Disk", "on_volume", "On_cloud", "on_file", "On_link", "On2Disk", " on_volume", "on2link", " on_download", "on_dis", "On_disk", "on_disc", "on2file", " on_file", "on_cloud", "On2file", "on2disk", " on_dis"], "in": ["inn", "inc", "mi", "is", "it", "ain", "and", "sin", "inner", "isin", "r", "din", "min", "bin", "i", "io", "gin", "ad", "on", "id", "from", "In", "body", "ins", "inside", "en", "IN", " din", "input", "cin", "rin", " IN", "vin", "inf", "ind"]}}
{"id1": "14188043", "id2": "7166270", "code1": "    public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException {\n        AQUtility.debug(\"net\", urlPath);\n        URL url = new URL(urlPath);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setConnectTimeout(NET_TIMEOUT);\n        int code = connection.getResponseCode();\n        if (code == 307 && retry) {\n            String redirect = connection.getHeaderField(\"Location\");\n            return openHttpResult(redirect, false);\n        }\n        if (code == -1 && retry) {\n            return openHttpResult(urlPath, false);\n        }\n        AQUtility.debug(\"response\", code);\n        if (code == -1 || code < 200 || code >= 300) {\n            throw new IOException();\n        }\n        byte[] result = AQUtility.toBytes(connection.getInputStream());\n        return result;\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 0, "substitutes": {"openHttpResult": ["OpenHTTPResponse", "openhttpResult", "OpenHTTPResult", "openUrlResults", "openHttpRes", "getHttpResult", "getHttpRes", "openUrlMessage", "openHttpResponse", "openQueryRes", "openHTTPResponse", "openHttpResults", "OpenHTTPMessage", "openHTTPMessage", "OpenHTTPResults", "getHTTPResult", "openhttpRes", "openQueryResults", "getHttpResults", "OpenHttpMessage", "openhttpResponse", "openQueryResult", "openHTTPResults", "openQueryResponse", "OpenHTTPRes", "getHTTPResponse", "openUrlResponse", "getHTTPResults", "openHTTPResult", "OpenHttpResult", "getHttpResponse", "openUrlRes", "OpenHttpResponse", "openUrlResult", "getHTTPRes", "OpenHttpRes", "openhttpMessage", "openhttpResults", "OpenHttpResults", "openHTTPRes", "openHttpMessage"], "urlPath": ["urlStr", "nlPath", "nlFile", " urlCh", "pathpath", "nlP", "urlCh", "xmlpath", "UrlFile", "urlP", "dlStr", "pathFile", "urlDir", "urlId", "xmlStr", "UrlId", "urlpath", "dlPath", "xmlFile", "xmlPath", " urlP", " urlpath", " urlString", "URLId", "dlFile", "UrlP", "urlName", "UrlPath", "URLDir", " urlId", " urlDir", "pathPath", "urlString", "UrlCh", "Urlpath", "UrlString", "URLString", "urlFile", "pathStr", "UrlName", "nlpath", "URLName", "URLCh", "URLPath", "dlpath", "UrlDir", " urlFile", " urlName"], "retry": ["twrite", "Retrying", "reri", "redrier", "terry", "rerying", "redwrite", "pretry", "attried", " retri", "pretrain", "pretric", "terrying", "attrying", " retrying", "trier", "retrying", "attry", "rery", "tric", "terrain", "Retry", "attrain", "pretried", "retri", "terried", "Rettry", "rettry", "retried", "retwrite", "retrain", "pretrying", "redry", "retrier", "retric", "pretrier", "Retri", "redric", "pretwrite", " rettry"], "url": ["Url", "link", "conn", "pl", "org", "char", "loader", "r", "job", "mount", "file", "location", "log", "ssl", "user", "dl", "il", "base", "uri", "web", "nl", "http", "sl", "rl", "service", "str", "ll", "https", "loc", "l", "open", "get", "www", "URL", "ls", "ur", "ul", "li"], "connection": ["established", "Connection", "link", "character", "response", "online", "server", "conn", "writer", "statement", "created", "socket", "connected", "description", "usage", "pointer", "message", "entry", "subject", "connect", "database", "number", "controller", "network", "session", "ion", "cone", "resource", "io", "channel", "city", "context", "creation", "close", "builder", "computer", "translation", "application", "c", "uri", "communication", "http", "command", "nc", "generation", "set", "create", "condition", "relation", "l", "client", "open", "con", "position", "creator", "to", "using", "operation", "directory"], "code": ["zip", "name", "sequence", "sec", "cause", "ch", "go", "ord", "coded", "now", "x", "cc", "cd", "a", "message", "se", "entry", "xx", "dec", "e", "currency", "number", "success", "Code", "change", "controller", "close", "one", "zero", "error", "rate", "id", "num", "call", "c", "type", "cont", "force", "time", "mode", "page", "status", "nc", "check", "cast", "desc", "create", "zone", "test", "xxx", "ne", "component", "length", "count", "rc", "co", "cod", "ce", "size", "cycle", "level", "ode", "codes", "ie", "ct", "coe", "state"], "redirect": ["regirection", "redistant", " redir", "predir", "Redistant", "predirection", "promirection", "redir", "Reduction", "regir", "redirection", "promir", "regirect", "predistant", " redirection", "promistant", "reduction", "predirect", "Redirect", " reduction", "Redir", "Redirection", "promirect", "reguction"], "result": ["sequence", "other", "cert", "answer", "Result", "true", "cup", "ret", "description", "process", "message", "memory", "r", "currency", "value", "success", "params", "buffer", "date", "meg", "reason", "profile", "results", "match", "data", "password", "root", "complete", "comment", "res", "report", "vector", "command", "feature", "mask", "out", "test", "proc", "table", "total", "output", "length", "request", "transform"]}}
{"id1": "6840241", "id2": "18693224", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["delete", "link", "system", "opy", "replace", "gc", "cop", "read", "close", "transfer", "map", "cover", "call", "sync", "save", "clip", "slice", "create", "move", "load", "clone", "write", "share", "Copy", "size", "cat", "print", "cp"], "source": ["Source", "cache", "origin", "parent", "image", "shell", "select", "pse", "inner", "stream", "ource", "src", "master", "subject", "sample", "se", "si", "scope", "sr", "wrapper", "info", "start", "session", "resource", "context", "local", "template", "base", "from", "site", "status", "sql", "body", "store", "inside", "ins", "spec", "table", "iter", "input", "ie", "ce", "size", "sp", "SOURCE", "reader", "style", "state"], "sink": ["Source", "asink", "slource", "asinker", "sinker", "sue", "ssender", "sender", "slue", "ssinker", "Sender", "ssink", "asender", " sinker", "ssource", "slender", "asource", "Sink", " sue", " sender", "Sue", "slink", "Sinker"]}}
{"id1": "8062076", "id2": "742465", "code1": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"updateUser": ["updatePerson", " updatePerson", "UPDATEUser", " updateAccount", "UpdateAccount", "UpdatePerson", "UPDATEUsers", "UpdateUsers", "UPDATEAccount", "UpdateUser", "updateAccount", "updateUsers", " updateUsers", "UPDATEPerson"], "portalUserBean": ["portalClientBeann", "portaluserPean", "portalUserRoans", "portalUserSoun", "portalUserDean", "portalFileBebean", "portalUserBeale", "portalClientBan", "portalClientBeAN", "portalUserRoan", "portalUserBeen", "portalUserBein", "portalUserBeane", "portalClientRoAN", "portalClientRoon", "portalUserBoAN", "portalUserBroann", "portaluserBeAN", "portaluserBean", "portalPersonProann", "portalPersonBeen", "portalUserBEans", "portalUserObjectan", "portalUserPeoon", "portalPersonBeAN", "portalOwnerBelann", "portalFileBelane", "portalUserBeAN", "portalPersonPeale", "portalUserPeale", "portalPersonBeann", "portalUserProann", "portalUserBEAN", "portalUserRoann", "portalUserbebean", "portaluserBebean", "portalUserBeoon", "portalUserRoAN", "portalUserProbean", "portalUserBann", "portalClientBbean", "portalFileBean", "portalUserBelane", "portalUserBoen", "portalUserRoane", "portalPersonProen", "portalPersonPeann", "portalUserbean", "portalOwnerBean", "portalPersonPean", "portalPersonPeoon", "portalPersonBein", "portalUserBEin", "portalUserBun", "portalClientBeans", "portalClientBean", "portalPersonPeAN", "portalUserBelbean", "portalPersonBeoon", "portalUserDeAN", "portalUserbeane", "portalUserObjectale", "portalUserProen", "portalUserbeann", "portalOwnerBeun", "portalPersonBean", "portalUserBan", "portalUserRoon", "portalUserObjectAN", "portalUserBeun", "portalPersonBeale", "portalFileBelann", "portalUserBAN", "portalClientBeon", "portalUserBEann", "portalUserBeon", "portalUserBroan", "portalUserProAN", "portalUserBelun", "portalUserProan", "portalUserBEon", "portalUserBEoon", "portalClientBann", "portalUserProale", "portalUserBoann", "portaluserPeAN", "portalUserBebean", "portalUserBelan", "portalUserBEan", "portalClientBebean", "portalUserBroin", "portalPersonPein", "portalUserPeen", "portalOwnerBelan", "portalClientRoans", "portalUserRobean", "portalFileBelbean", "portalUserPebean", "portalUserBon", "portalFileBelan", "portalUserPein", "portalOwnerBeann", "portalUserBbean", "portalUserBrooon", "portalClientBAN", "portalFileBeane", "portalClientRoan", "portalPersonProan", "portalUserBans", "portalUserSoan", "portalFileBeann", "portalUserBeann", "portalUserPeAN", "portaluserPebean", "portalOwnerBelun", "portalUserDebean", "portalUserBelann", "portalPersonProAN", "portalUserPean", "portalUserSoann", "portalUserPeann", "portalUserDeann", "portalUserBeans", "portalUserBoan"], "authSession": ["uthsession", "authorClient", "selectSite", "aptClient", "AuthUser", "aptSite", "authState", "aptSession", "authorSite", "authorState", "authorSession", " authsession", "authSite", "authUser", "uthSession", "authClient", "selectState", "authsession", "Authsession", "AuthSession", "uthUser", "selectClient", "aptState", " authUser", "selectSession"], "dbDyn": ["dbDoys", "dbCyp", "dbSYN", "dbCont", "dbDuYN", "dbGyp", "datCys", "dbFYN", "dbdyn", "dbDsynam", "dbDyd", "dlCreateily", "dbSsyn", "dbSyn", "webDsynam", "webDyn", " dbDync", "DbDyn", " dbDsyn", "datDyn", "dbDbyp", "dbCreateily", "dbdy", "DbDoyd", "dbDsys", "dbDily", "dbFyn", "dbSys", "dbDYN", "dbSyd", "dlCreateynam", "dbDesyn", "datDyp", "dbDoynam", "dbDoyp", "datCyn", "dbdys", "dbGYN", "datCYN", "dbCys", "webDsyl", "dbDeyn", "dbDsyl", "dbDoy", "dbDoont", "dbDynam", "DbDYN", "dbDy", "dbNy", " dbDont", " dbDyp", "dbBindily", "dbDuys", "dbDyl", "dbBindyn", "dbDoyn", " dbDoont", "dlCreateyn", " dbDYN", "dbDsyn", "webDsys", "webDynam", "dbGys", "dlDyn", "dbBindynam", " dbDy", " dbDoys", "dbDbYN", "dbCYN", "datDys", "webDsyn", "dbDuont", "DbDoYN", "dbDoyl", " dbDoYN", "dbDoYN", "DbDoy", "dbDync", "dbDuyn", "dbDbyn", "dbFy", "dbDoily", "dbNyn", "DbDoyn", "dbCreateynam", "dbdync", "webDyl", "dbFys", "dbDont", "datCyp", "dbCyn", "dbSynam", "dbDyp", " dbDoyn", "dbFyp", "dlDily", "DbDyd", "dbSy", "webDys", "dbDeYN", "dbGyn", "dbCreateyn", "dbNys", "datDYN", "dbFyd", "dlDynam", "DbDy", "dbDoyd", "dbNync", " dbDys", "dbSyl", "dbDbys", "dbDys"], "ps": ["fp", "fps", "itions", "cs", "pl", "ip", "pp", "ips", "p", "ws", "pse", "pres", "css", "als", "ports", "posts", "ts", "bs", "rs", "PS", "ats", "stats", "ds", "Ps", "ups", "pos", "aps", "points", "ils", "ys", "params", "gs", "amps", "pps", "pa", "ptr", "ies", "fs", "sts", "res", "mp", "its", "ops", "pes", "sol", "ims", "op", "pers", "pr", "jp", "ress", "vs", "eps", "wp", "pt", "s", "js", "qs", "ples", "sp", "ks", "gres", "pe", "pd", "tp"], "sql": ["url", "sal", "ln", "ws", "string", "sq", "shell", "socket", "statement", "inv", "xml", "scl", "stats", "repl", "fn", "expression", "sb", "series", "wal", "query", "log", "sys", "ssl", "join", "ss", "plan", "template", "ql", "pel", "sv", "dl", "spr", "nl", "sl", "status", "details", "prefix", "sol", "ll", "serial", "spec", "pr", "seed", "csv", "rel", "sn", "eps", "s", "js", "SQL", "qs", "sp", "print", "ls"], "idList": ["IdLIST", "IdList", " idLIST", "infoList", "idLIST", "idL", " idlist", "idsL", "idsList", "idslist", "Idlist", "infoL", "uidlist", "infolist", "uidList", "idlist", "idsLIST", "uidLIST", " idL", "infoLIST"], "num": ["tu", "unit", "alph", "orig", "nom", "nm", "NUM", "mat", "ret", "begin", "dim", "hom", "Num", "um", "nb", "dec", "nn", "number", "node", "mon", "hum", "snap", "np", "nam", "dat", "multi", "mult", "conv", "coord", "zero", "cal", "prim", "umber", "done", "non", "tim", "sum", "draw", "cu", "mem", "nu", "mn", "no", "eng", "un", "den", "proc", "con", "fac", "note", "desc", "gre", "index"], "i1": ["li2", "i61", "I0", "I61", "li0", "i0", "I2", "li1", "pi61", "pi1", "I1", " i61", "pi2", " i0", "i2", " i2", "pi0", "li61"]}}
{"id1": "13333160", "id2": "9347451", "code1": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"run": ["scan", "execute", "view", "unit", "flow", "go", "apply", "action", "process", "wal", "query", "start", "Run", "read", "ran", "test", "proc", "work", "app", "running", "exec", "render", "runner", "pass", "eval"], "xmlIn": ["xmlIns", "jsonIns", "jsonOut", "jsonInput", "htmlIn", "domIn", "xIn", "xmlOut", "domInput", "domOut", "htmlIns", "fileIn", "domIns", " xmlin", "xmlInput", "jsonIn", "xOut", "xmlin", "xInput", "fileIns", "xIns", "filein", "htmlin", " xmlIns"], "out": ["off", "obj", "up", "raw", "p", "ws", "Out", "pool", "stream", "v", "ex", "nt", "w", "aos", "file", "log", "err", "i", "io", "one", "sw", "res", "report", "set", "in", "t", "o", "d", "OU", "output", "client", "os", "null", "to", "end", "s", "outs", "OUT", "ou"], "dom": ["html", "domain", "model", "p", "mat", "comm", "cd", "xml", "process", "dm", "utils", "node", "div", "parser", "host", "om", "dem", "j", "DOM", "data", "atom", "result", "m", "yang", "dl", "Dom", "web", "el", "page", "iam", "frame", "md", "img", "mom", "browser", "d", "doc", "db", "os", "tree", "fr", "dn", "document", "dr", "window", "df"], "f": ["ff", "fy", "xf", "fab", "rf", "tf", "full", "it", "forge", "fm", "g", "fo", "v", "F", "w", "fx", "uf", "conv", "fc", "c", "fs", "fi", "fd", "conf", "bf", "lf", "fg", "fl", "sf", "of", "foreign", "d", "cf", "l", "inf", "ft", "Factory", "fr", "fac", "af", "fb", "fort", "df"], "b": ["bi", "bg", "p", "bc", "bs", "mb", "g", "v", "B", "a", "bh", "r", "ab", "sb", "nb", "e", "bd", "builder", "bb", "j", "Builder", "m", "c", "eb", "base", "gb", "bf", "d", "pb", "db", "l", "bt", "rb", "fb", "be"], "root": ["Root", "html", "p", "head", "mount", "container", "host", "data", "res", "valid", "browser", "element", "create", " rooted", "table", "mr", "tree", "document", "used", "ul", "nav", "wrap", "roid", "ain", "xml", "r", "ow", "div", "start", "h", "author", "rown", "DOM", "box", "cover", "top", "right", "result", "available", "m", "type", "rap", "ax", "gr", "os", "row", "raw", "ram", "oot", "scope", "node", "rank", "roots", "av", "base", "object", "ree", "chain", "ro", "module", "doc", "null", "primary", "bot", "area", "owner", "group", "parent", "first", " Root", "bank", "instance", "feature", "loc", "ok", "get", "rt"], "att": ["attribute", " matt", "tr", "ac", "attr", "ts", "mat", "ATT", "aux", "def", "apt", "attach", " ut", "nt", "pet", "info", "Att", "acc", "ach", "nat", "alt", "rib", "tt", "prop", "ap", "tmp", "dat", "data", "ar", " attribute", "av", "txt", "set", "aria", "aff", "t", "aj", "at", "adj", "atts", "pt", "feat", "rt", "ct", " dat", "addr"], "menu": ["option", "nav", "sequence", "cache", "theme", "up", "parent", "li", "header", "consumer", "movie", "settings", "ui", "wiki", "usage", "title", "um", "node", "config", "admin", " menus", "pie", "next", "manager", "library", "button", "mouse", "queue", "m", "Menu", "site", "command", "mu", "category", " Menu", "page", "ctrl", "summary", "item", "us", "chain", "men", "module", "cm", "omo", "family", "block", "tree", "row", "list", "options", "window", "ul"], "id": ["name", "link", "url", "icon", "key", "init", "version", "description", "scope", "mid", "target", "title", "value", "file", "source", "uid", "ID", "data", "method", "type", "uri", "ids", "status", "tag", "class", "ref", "pid", "Id"], "zout": ["Zin", "zipot", "zipor", "zOUT", "ZOut", " zaos", "zipOUT", "ozoss", "zoss", " zouts", "gzin", "ziposs", "izOut", "izout", " zin", "enzOut", "zouter", "zipouter", "Zout", "zipclient", "gzout", " zpoint", " zor", "czOut", "ozouts", "zipin", "ezout", "zOut", "ozot", "czout", "ezpoint", "zerouter", "zipup", "Zaos", "zipaos", "ozOUT", "ozup", "zipnet", "zot", "zippoint", "zor", "zaos", "zerot", "zclient", "izserv", "zpoint", "zserv", "czup", "enzpoint", "zerout", "ezouts", "ozouter", "czclient", "zouts", " zOut", "zerup", "izaos", "ozOut", "zin", " znet", "gzor", "ozpoint", "zipout", "zipOut", "zerOut", "gznet", " zup", "zerOUT", "zup", " zserv", "ozout", " zclient", "zipserv", "zeross", "znet", "enzout"], "content": ["sequence", "metadata", "cache", "html", "cmd", "context", "host", "data", "accept", "cont", "Content", "cur", "text", "create", "block", "core", "tree", "document", "ontent", "htm", "path", "full", "now", "pool", "xml", "message", "current", "title", "article", "config", "source", "layout", "read", "reason", "padding", "result", "body", "lay", "address", "condition", "position", "request", "ce", "size", "raw", "header", "expression", "value", "json", "query", "template", "comment", "c", "search", "time", "command", "good", "object", "load", "output", "section", "script", "wrapper", "image", "string", "x", "inner", "description", "file", "default", "media", "ext", "txt", "page", "code", "format"], "signal": ["sealing", "scature", " signale", "SIGNature", "Signaling", "SIGNal", " signAL", "SIGNale", "severaling", "signil", "seal", "several", "severature", "signaling", "signature", " signature", " signil", "seale", "scale", "severale", "severil", "seil", " signaling", "signAL", "seAL", "seature", "signale", "severAL", "scaling", "Signature", "SIGNaling", "Signal", "scal"], "n": ["ni", "len", "ln", "p", "nm", "g", "nt", "nw", "index", "ns", "nb", "nn", "ng", "number", "node", "nr", "pos", "tn", "i", "h", "np", "nan", "j", "nor", "zero", "on", "num", "m", "c", "natural", "nl", "unn", "nv", "nc", "an", "t", "en", "nu", "no", "mn", "o", "d", "ne", "sn", "un", "l", "count", "z", "dn", "norm", "N", "cn"], "entry": ["zip", "link", "ace", "enter", "RY", "system", "quick", "nt", "se", "add", "cue", "member", "escape", "ent", "e", "query", "log", "slot", "join", "tmp", "next", "Entry", "record", "data", "ry", "result", "comment", "cell", "page", "instance", "office", "element", "sheet", "insert", "table", "line", "connection", "row", "ie", "pixel"], "pout": ["phpot", "pto", "ppot", "zot", " pnew", "zou", "phpOut", "pin", "zouter", "POut", " pto", " pouter", "ppinner", "pOut", "pinner", "wpond", "phpsys", "ptout", "pond", "pnew", "jpou", " pent", "Pin", " pin", "ppto", "ppout", "phpnew", "pent", "zconn", "jpout", " pou", "pouter", "phpout", "ptouter", " psys", "ptOut", "pot", "ppouter", " pinner", "wpent", "jpconn", " pOut", "ppond", " pconn", "psys", " pond", "Pout", "jpinner", "ppent", "phpinner", "ptnew", "zinner", "wpto", "phpin", "phpouter", "Psys", "pou", "wpout", "pconn"]}}
{"id1": "11477906", "id2": "7911686", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadFAULTSetting", "readdefaultSettings", "readDefaultsettings", "loadFAULTsettings", "loaddefaultsettings", "loaddefaultValues", "loaddefaultSettings", "loadDefaultValues", "readDefaultValues", "readDefaultSettings", "loadDefaultsettings", "loadFAULTSettings", "loaddefaultSetting", "readdefaultValues", "loadFAULTValues", "readDefaultSetting", "loadDefaultSetting", "readdefaultsettings", "readdefaultSetting"], "configFileName": ["configStreamname", "confFilenamename", "configFilenameLocation", "configFilePath", "configFILEname", "configFILEPath", "configPagename", "configFileLocation", "confFilenamePath", "configfilePath", "conffileName", "configFilenamePath", "confFileName", "conffileNames", "conffilePath", "configFilenameNames", "configFILELocation", "configFilenamename", "configStreamPath", "configStreamName", "confFilePath", "configPageName", "confFilenameLocation", "confFilenameName", "configStreamLocation", "configPageNames", "configFilenameName", "conffilename", "confFilename", "confFileLocation", "configFILEName", "configfileName", "confFileNames", "configFileNames", "configFilename", "configfileNames", "configPagePath", "configfilename"], "in": ["inn", "im", "al", "up", "init", "is", "it", "mi", "ain", "inner", "isin", "ini", "din", "info", "run", "e", "source", "ze", "bin", "i", "gin", "ad", "user", "on", "id", "m", "from", "In", "or", "check", "ins", "t", "en", "IN", "ro", "o", "doc", "l", "con", "ai", "ma", "n", " din", "cin", "rin", "input", "re", "mc", "ls", "ar", "inf", "ind"], "out": ["port", "cache", "obj", "not", "server", "are", "Out", "ex", "v", "io", "user", "res", "ot", "store", "ind", "auto", "writer", "gc", "read", "m", "ge", "at", "ne", "os", "con", "oss", "outs", "OUT", "net", "ing", "raw", "cn", "up", "nt", "w", "ent", "une", "all", "de", "conv", "gt", "or", "ins", "o", "OU", "des", "output", "null", "co", "can", "handle", "ou", "init", "it", "copy", "aos", "file", "update", "sys", "ion", "log", "po", "check", "t", "en", "client", "to", "over", "n", "off"]}}
{"id1": "21425787", "id2": "22977189", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFile", "transferFiles", " copyByte", "CopyFile", "CopyFiles", "Copyfile", " copyFiles", "transferByte", "CopyByte", "copyFiles", "copyfile", "copyByte", " copyfile", "transferfile"], "in": ["inn", "inc", "up", "is", "it", "isin", "old", "din", "source", "b", "i", "gin", "on", "from", "In", "el", "ic", "ins", "en", "IN", "o", "l", "n", "input", "cin", "rin", "ie", "ar", "vin", "inf", "ind"], "out": ["p", "it", "Out", "g", "v", "ex", "nt", "w", "ent", "b", "source", "err", "i", "io", "gt", "c", "po", "ot", "help", "str", "t", "at", "o", "ne", "l", "output", "os", "null", "to", "s", "oss", "outs", "OUT", "net", "n", "ou"], "sourceChannel": ["sourceClass", "srcConnection", " sourceCh", "sourcePanel", "ourceManager", "systemCategory", "startChannel", "sourceMachine", "sourceCommand", "seedCategory", "srcCh", "ourceChannel", " sourceClass", "sourceConnection", "srcCommand", "systemMachine", " sourceManager", " sourceChan", "inputChan", "ourceChan", "inputChannel", "inputCh", "sourceCh", " sourceCommand", "startCategory", "seedMachine", "sourceCategory", "srcChannel", "startPanel", "inputConnection", "sourceManager", "sourceChan", "seedPanel", " sourceConnection", "systemPanel", "srcManager", "ourceCommand", "startMachine", "seedChannel", "srcChan", "srcClass", "systemChannel", "ourceConnection", "ourceClass"], "destinationChannel": ["destationHandler", "restinationchannel", "destationChannel", "DestinationHandler", "restinationChan", "destensionConnection", "DestensionChan", "restinationChannel", "Destensionchannel", "destinoChan", "destinatedChan", "DestationHandler", "destinationsChannel", "destinatedchannel", "destinationHandler", "DestationChan", "destinatorChan", "restinochannel", "destationChan", "DestensionConnection", "restinationContext", "destationContext", "destinoChannel", "destinoContext", "destinatedChannel", "DestensionChannel", "Destationchannel", "destensionChannel", "destensionchannel", "destinationchannel", "destinationsChan", "destinationContext", "destinatorHandler", "DestationChannel", "Destinationchannel", "destinatedContext", "destinatorChannel", "destinationsConnection", "destinatorchannel", "destinochannel", "destationchannel", "restinoChan", "restinoContext", "destensionChan", "DestinationChannel", "destationConnection", "destinationChan", "DestinationChan", "restinoChannel", "destinationschannel", "destinationConnection", "DestinationConnection"]}}
{"id1": "1769771", "id2": "8490297", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyLine", "CopyLine", "CopyFile", " CopyFiles", "CopyStream", " copyLine", "copyStream", "CopyFiles", " CopyFile", " CopyStream", " copyFiles", "copyFiles", " CopyLine"], "in": ["inn", "inc", "up", "init", "is", "inner", "isin", "old", "ini", "r", "din", "mm", "b", "source", "bin", "i", "io", "gin", "on", "from", "In", "el", "ic", "ins", " input", "en", "IN", "l", "input", "cin", "rin", "inf", "ind"], "out": ["msg", "up", "p", "it", "Out", "v", "ex", "nt", "w", "file", "b", "update", "log", "err", "io", "serv", "gt", "c", "po", "res", "ot", "help", "op", "t", "at", "o", "l", "output", "os", "to", "s", "outs", "OUT", "net", "n", "ou"], "inChannel": ["dinConnection", " inCase", "Inchannel", "inScope", " inConnection", "cinRoom", "innCase", "insideClient", "inCommand", "dinChannel", "insideChannel", "InChannel", "innButton", " inCategory", "intChannel", "dinChan", "inClient", "sinClient", "outchannel", " inRoom", " inCommand", "cinCommand", "outChan", "ainClient", "insideCategory", "inCase", "ainScope", "sinCase", "inchannel", "cinChannel", "inCategory", "inConnection", "ainChannel", " inClient", "insideScope", "ainCategory", "sinChannel", "innClient", "innChannel", " inScope", " inChan", "inRoom", "sinButton", "intchannel", "outConnection", " inButton", "intCommand", "InCommand", "InChan", "sinRoom", "sinCommand", "dinchannel", "inButton", "inChan", " inchannel", "intChan"], "outChannel": ["inMember", " outMany", " outChan", "blockChannel", "outCh", "neChan", "aosSection", "neMember", "outManager", "outMember", "parentMany", "blockChan", "outputchannel", " outCh", "outMany", "inSection", "outSection", " outGate", "outputChan", "outputCh", "cnChannel", "outGate", "outchannel", "parentChannel", "outputChannel", " outchannel", "outChan", "aosChannel", "aosChan", "inchannel", "blockGate", "blockMany", "cnChan", " outManager", "neChannel", "inCh", "parentChan", "aosMember", "outputManager", "parentGate", "inChan", "cnManager", "neSection"]}}
{"id1": "22993368", "id2": "10451698", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2file", "decodeFileAsfile", "decodeFile2Files", "decodeStringToFiles", "decodeStringTofile", "decodeFileAsFile", "decodeFileTofile", "decodeFileToString", "decodeFileFilefile", "decodeFileAsFiles", "decodeFileToFiles", "decodeFile2file", "decodeFileFileFiles", "decodeString2String", "decodeFileFileString", "decodeString2File", "decodeString2Files", "decodeStringToFile", "decodeFileAsString", "decodeFile2File", "decodeStringToString", "decodeFile2String", "decodeFileFileFile"], "infile": ["inFile", "infolder", "outFile", "InFile", "fromfile", "isinname", "Inbase", "inbase", "frombase", "infilename", "isinfolder", "outname", "isinfile", "outbase", "fromFile", "inputname", "inputfolder", "Infile", "inname", "outfilename", "fromfilename", "Infilename", "outfolder", "inputfile", "inputFile", "isinFile"], "outfile": ["otfile", "inFile", " outname", "Outfilename", " outFILE", "outFile", " outFile", "todir", "Outfile", "outdir", "otFILE", "infilename", "toFile", "tofilename", "indir", "otname", "outname", "inname", "outfilename", "Outdir", "otFile", "outFILE", "OutFile", "tofile", "inFILE"], "in": ["inn", "im", "al", "inc", "up", "pin", "conn", "init", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "gin", "on", "id", "from", "In", "form", "or", "amin", "ins", "inside", "t", "en", "IN", "by", "get", "iter", "con", " din", "cin", "rin", "input", "re", "ar", "inf", "oin", "ind"], "out": ["auto", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "aos", "outer", "flush", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "null", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "character", "sequence", "cache", "view", "shape", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "variable", "bone", "pad", "buf", "black", "Buffer", "append", "template", "bar", "padding", "library", "available", "password", "button", "note", "batch", "base", "comment", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "block", "row", "print", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "shift", "run", "connect", "allow", "through", "query", "start", "i", "push", "close", "give", "send", "wait", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "req", "count", "iter", "seek", "end", "skip", "input", "readable", "need", "n", "size", "print", "reader", "index", "ind", "Read"], "success": ["response", "town", " okay", "first", "same", "fail", "continue", "primary", "scope", " successes", "support", " successful", "commit", "positive", "growth", "photo", " succeeds", "safe", " succeed", "submit", "value", " succ", "second", "snap", "Success", "city", "ccess", "successfully", "error", "ceed", "result", "successful", "complete", "setup", "done", "accept", "crit", "sufficient", "release", "democracy", "valid", "status", "good", "surv", "danger", "summary", "condition", "please", "ok", " failure", "unity", "ratulations", "cess", "exist"]}}
{"id1": "6558022", "id2": "3197876", "code1": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"CheckUrl": ["Checkurl", "checkURL", " checkURL", "checkUrl", "checkStr", " validateUrl", " validateurl", "checkurl", " validateURL", " validateStr", " checkUrl", "CheckURL", " checkurl", " checkStr", "CheckStr"], "urlvalue": ["stringstring", "urlval", "stringname", "urlformat", "Urlvalue", "urlname", " urlformat", "Urlval", "nullvalue", "stringValue", "nullname", "URLval", "URLstring", "stringvalue", "URLformat", "nullValue", "urlstring", "Urlstring", " urlval", "urlValue", "Urlformat", " urlstring", "UrlValue", "Urlname", "nullstring", "URLvalue"], "inputLine": [" inputValue", "serviceLine", "outputChain", "serviceString", "inputValue", " inputChain", "outputLine", " inputLINE", "feedChain", "inputChain", "outputRow", "inputRow", "inputString", " inputRow", "inputLINE", "selectline", "feedLINE", "feedLine", "inputline", "serviceRow", "feedString", "selectLINE", "selectLine", " inputString", "outputLINE", "outputline", "outputValue", "outputString", "selectValue", "serviceLINE", " inputline"], "url": ["Url", "name", "hl", "link", "pl", "org", "char", "ul", "atl", "r", "job", "mount", "file", "b", "log", "ssl", "build", "bel", "f", "dl", "base", "web", "http", "nl", "sl", "q", "el", "rl", "str", "impl", "ll", "ref", "https", "rel", "l", "open", "get", "null", "arl", "www", "URL", "ls", "ur"], "urlConnection": ["fileConnect", "webConn", "httpConnection", "fileconnection", " urlConnect", "webconnection", "urlLink", "URLConnection", "urlConnect", "webConnection", "webConnect", "httpconnection", "httpConnect", "fileConnection", " urlDescription", "urlDescription", "URLLink", "urlConn", "httpLink", "URLConnect", "URLDescription", "httpConn", "httpDescription", "fileConn", "urlconnection", " urlLink"], "in": ["inn", "inc", "is", "inner", "xml", "r", "din", "file", "source", "b", "all", "log", "bin", "read", "gin", "on", "f", "txt", "m", "from", "In", "sum", "conf", "body", "ins", "out", "mn", "IN", "by", "doc", "l", "get", " din", "cin", "rin", "input", "reader", "n", "thin"]}}
{"id1": "7006052", "id2": "16623181", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyFilesTo", "copyfileFrom", " copyFilesFrom", " copyFilesThrough", "copyToFrom", " copyFilesTo", "copyFileThrough", "copyfileOver", " copyFileThrough", "copyFilesThrough", "copyFilesFrom", "copyFilesOver", "copyToTo", "copyToOver", "copyFileOver", " copyFilesOver", "copyfileThrough", " copyFileOver", "copyToThrough", "copyFileFrom", " copyFileFrom", "copyfileTo"], "src": ["Source", "url", "sec", "obs", "init", "inst", "sq", "bs", "sin", "rs", "sr", "sb", "rx", "config", "source", "start", "sys", "cos", "sit", "ipl", "txt", "cont", "http", "ctr", "rl", "st", "cur", "ins", "ser", "sf", "usr", "rel", "pkg", "sc", "req", "rc", "input", "rt", "iv"], "dest": ["port", "origin", "orig", "exp", "est", "del", "pl", "Dest", "nt", "target", "source", "de", "tmp", "dat", "result", "done", "cont", "way", " dst", "good", "st", "desc", "mem", "them", "loc", "test", "usr", "d", "des", "dir", "req", "end", "dist", "www", "pub", "trans", "home", "rest", "decl"], "destFile": ["srcDir", "sourceFile", "srcfile", "destPage", "DestDir", "Destfile", " destPage", "distPage", "DestFile", "distfile", "srcFile", " destfile", "newDo", "destfile", "destFiles", " destDo", "sourceFiles", "newfile", "sourceDir", "newFile", "srcFiles", "distDo", "destDo", "newPage", "destDir", "DestFiles", "distFile", "sourcefile"], "in": ["inn", "im", "al", "inc", "up", "init", "is", "it", "per", "ain", "act", "sin", "inner", "isin", "ini", "din", "info", "mm", "ze", "bin", "i", "io", "read", "gin", "on", "from", "In", "el", "ic", "ins", "inside", "en", "IN", "iter", "con", "ai", "rc", "cin", "rin", "input", "inf", "ind"], "out": ["auto", "obj", "writer", "p", "it", "and", "Out", "inner", "g", "v", "ex", "nt", "aos", "outer", "b", "sys", "cos", "io", "gt", "on", "res", "po", "we", "ot", "cn", "t", "en", "at", "o", "by", "ne", "write", "output", "client", "os", "null", "con", "to", "oss", "co", "outs", "OUT", "net", "can", "n", "ou"], "buf": ["cap", "obj", "msg", "alph", "cv", "bc", "tx", "bus", "cb", "bh", "seq", "cmd", "b", "buffer", "var", "log", "bin", "pad", "prop", "Buffer", "uf", "data", "conv", "bar", "box", "gen", "tab", "queue", "batch", "arr", "cam", "mu", "good", "br", "str", "bag", "cur", "Buff", "img", "buff", "abet", "pkg", "vec", "db", "cf", "block", "rb", "cat", "aka", "bytes", "cp"], "len": ["cap", "elt", "pl", "ln", "le", "exp", "del", "cmp", "lon", "v", "nt", "mid", "seq", "e", "mun", "pos", "fin", "val", "ld", "il", "dl", "coll", "el", "lf", "str", "ll", "en", "t", "no", "rel", "la", "l", "length", "vec", "Len", "lan", "wid", "count", "lic", "end", "z", "compl", "lif", "size", "ls", "n"]}}
{"id1": "2168610", "id2": "345515", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"update": ["touch", "info", "user", "dates", "call", "set", "create", "count", "remove", "diff", "index", "ul", "UPDATE", "state", "msg", "now", "put", "current", "resource", "result", "num", " Update", "report", "send", "http", "insert", "component", "edit", "row", "size", "use", "where", "up", "offset", "select", "find", " UPDATE", "database", "u", "value", "id", "batch", "Update", "save", "draw", "load", "out", "print", "handle", "delete", "init", "action", "equal", "continue", "commit", "add", "run", "change", "date", "exit", "login", "status", "check", "op", "write", "updated", "get", "grade", "latest", "fill"], "o": ["obj", "ooo", "onet", "p", "oid", "fo", "a", "mo", "oo", "e", "iso", "i", "h", "k", "om", "O", "oco", "m", "c", "cont", "po", "q", "oa", "object", "t", "out", "bo", "lo", "l", "os", "ilo", "ob", "to", "ao", "co", "aco", "n", "oin"], "contact": ["mail", "port", "character", "lead", "charge", "group", "pp", "conduct", "action", "claim", "addr", "act", "char", "cc", "comm", "display", "consider", "fax", "message", "add", "info", "entry", "content", "panel", "ACT", "title", "detail", "controller", "config", "hello", "international", "acts", "close", "transfer", "match", "Contact", "translation", "phone", "cont", "force", "report", "CONT", "impact", "communication", "company", "cell", "form", "responsible", "details", "check", "service", "country", "address", "l", "work", "client", "compliance", "component", "module", "connection", "trans", "att", "print", "aco", "ct", "control", "cp", "format"], "pst": ["pster", "apstan", "Ppt", "prse", "lST", "dpster", " pset", "psth", "pSt", " pmt", "vpset", "drest", "Pct", "pest", "ipSt", "ply", "dst", " pstan", "jply", " pster", "dpt", "pth", "pmt", " pstra", "epstal", "tpstal", "vpct", "dpct", "ipmt", "pingst", "PST", "prST", "jpSt", "jpst", " pstal", "dct", "pingsta", "lct", "presth", "prest", "pset", "pingSt", "psta", "prst", "epnt", "pingct", "pect", "bpost", "pingth", " ply", "Pse", "pingstal", "pstal", "lse", "preSt", "phpstal", " post", "jpct", "ppt", "perest", "ipsta", "apost", "post", "phpnt", "jpST", "apSt", "phpct", "preth", "pST", "epct", "ipST", "Prest", " pct", "jpsy", "epst", "presta", "tpst", " psy", "pept", "pse", "prect", "bpstan", "jpster", "tpstra", "dpst", "ipsth", "bpst", "jpmt", "pnt", "pstan", "ipct", " pSt", "lst", "Pst", "phpst", "ipst", "tpct", "pingstra", "jpset", " pnt", "bpSt", "prct", "pct", "pstra", "ipth", "dpsy", " pST", "psy", "vpst", "apst", "vply", " psth"]}}
{"id1": "8087001", "id2": "9826240", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"generateStackHashKey": ["generateStackhashPage", "generateStackNodeKey", "generateStackHashPage", "generateStackNodeKeys", "generateTrackHashPage", "generateStackStatePage", "generateTrackhashKey", "generateTrackhashKeys", "generateTrackHashKeys", "generateStackNodeIndex", "generateTrackHashIndex", "generateStackhashKey", "generateStackNodePage", "generateStackStateKeys", "generateStackhashIndex", "generateStackStateKey", "generateTrackHashKey", "generateStackhashKeys", "generateStackHashIndex", "generateTrackhashIndex", "generateStackHashKeys", "generateStackStateIndex", "generateTrackhashPage"], "e": ["xe", " err", "ue", "exp", "ef", "eer", "p", "ec", "x", "E", "ex", "a", "se", "r", "oe", " error", "u", "ep", "ee", "event", "err", "i", "h", "me", "es", "email", " pe", "error", "f", " ce", "eb", "m", " exc", "eg", "el", "te", "ge", "eu", "t", "en", "element", "er", "eeee", "o", "ne", "d", "exc", " me", "ae", "ie", " te", "ed", "n", "pe"], "digest": ["mdested", "Digest", " diggest", "decse", "mdEST", "diger", " digested", "Digester", "compested", "Diggest", " diger", "diggest", "mdest", "digse", "mdester", "digests", "descgest", " digse", "decested", "digested", "Digse", " digester", "compEST", " digests", "descest", " digEST", "digEST", "Diger", "DigEST", "digester", "Digests", "decester", "descer", "compest", "decest", "Digested", "mdse", "compests", "descse"], "hash": ["style", "ashed", "cache", "html", "key", "dig", "sh", "bh", "message", "sample", "mac", "all", "log", "h", "her", "build", "ash", "map", "search", "Hash", "report", "sum", "valid", "tag", "check", "chain", "test", "rh", "total", "block", "shadow", "hex", "score", "filter", "has", "sha"], "rtn": ["ertn", "rotnu", "mtcn", "tton", "rtcn", "rtr", "rotns", "aptr", "RTnu", "rtnm", "rotnor", "rton", "rotcn", "vrnm", "rtmn", "rotn", "mtnu", "rtN", "rtyn", "mtnm", "otn", "vrn", "ntN", "RTb", "rotyn", "latnm", "vrN", "rxmn", "otmn", "otne", "ttn", "rotnm", "ntb", "artns", "RTn", "aptn", "rxnm", "apton", "mtn", "artn", "rtnor", "latne", "RTN", "latmn", "ttr", "artyn", "latn", "vrb", "ytnor", "rtne", "ntn", "artnor", "rxne", "ertr", "ntnm", "aptnu", "RTcn", "ytyn", "RTnm", "rtb", "ytns", "rtnu", "rtns", "otnm", "ttnu", "rxn", "erton", "ertnu", "ytn"]}}
{"id1": "7809093", "id2": "12783713", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["readContents", "getStream", "getData", "getEntity", "GetContents", "readData", "GetData", "readContent", "GetContent", "readEntity", " getContents", " getData", " getStream", "GetEntity", "getContents", "GetStream", "readStream", " getEntity"], "request": ["attribute", "QUEST", "execute", "url", "claim", "task", "this", "xml", "message", "job", "Request", "event", "hello", "query", "question", "start", "resource", "email", "template", "call", "application", "project", "search", "http", "q", "command", "instance", "object", "post", "item", "address", "create", "get", "open", "req", "input", "self", "transform", "quest", "document"], "sb": ["sm", "bn", "erb", "bg", "ib", "sq", "bs", "cb", "sth", "mb", "sa", "bh", "nb", "lb", "b", "gc", "bd", "buffer", "ssl", "bsp", "buf", "bb", "sg", "bp", "sv", "eb", "lp", "gb", "bf", "rm", "rob", "sf", "wb", "ub", "kb", "pb", "obb", "bt", "rb", "SB", "zb", "sp", "bps", "fb", "xb"], "client": ["remote", "cache", "server", "conn", "ch", "init", "key", "ip", "tc", "grid", "Client", "connect", "cli", "cl", "cmd", "config", "resource", "context", "city", "ci", "io", "secure", "call", "c", "force", "web", "http", "cell", "console", "service", "google", "chain", "create", "https", "api", "cm", "con", "connection", "core", "co", "ce", "net", "wrapper", "control", "cp", "cn"], "httpParams": ["httpPerms", " httpParims", "httpPARims", " httpPims", "httpPrparams", "httpPars", "httpPARms", " httpPams", "httpPrms", " httpParans", " httpParars", "httpPims", "httpPARams", "httpPARars", " httpParam", "apiParms", "apiparparams", "apiParams", "httpParims", "httpparparams", "httpParAMS", "apiParAMS", "httpparms", " httpPars", "httpPeram", "httpParars", "httpPrams", "apiparams", "httpParparams", "httpPams", "httpParam", " httpPms", "httpPerams", "apiparms", "httpPms", "httpParans", " httpParms", "apiparAMS", "apiParparams", "httpPans", "httpPrAMS", "httpparAMS", "httpPerans", "httpParms", "httpPam", "httpparams"], "response": ["sequence", "answer", "image", "resp", "still", "version", "description", "message", "entry", "json", "success", "pos", "given", "resource", "next", "data", "respond", "that", "result", "application", "successful", "report", "http", "page", "status", "body", "object", "Response", "service", "onse", "out", "output", "block", "connection", "tree", "reply", "document"], "entity": ["attribute", "metadata", "obj", "group", "existent", "image", "activity", "unique", "xml", "enc", "Entity", "info", "entry", "ent", "e", "json", "event", "ee", "resource", "me", "email", "one", "data", "translation", "user", "error", "result", "application", "note", "comment", "person", "el", "valid", "peer", "quote", "form", "status", "body", "object", "details", "ity", "code", "phrase", "component", "encrypted", "ce", "net", "token", "document", "pe"], "reader": ["iterator", "linger", "rer", "writer", "per", "older", "reading", "inner", "stream", "loader", "r", "entry", "rr", "file", "buffer", "resource", "read", "parser", "builder", "rar", "data", "user", "roller", "comment", "handler", "worker", "ner", "rl", "range", "Reader", "er", "ro", "iter", "row", "runner", "readable", "input", "dd", "dr", "owner"], "line": ["link", "sequence", "msg", "lane", "where", "liner", "ln", "le", "header", "string", "stroke", "ine", "continue", "lines", "message", "sample", "lined", "entry", "edge", "e", "detail", "label", "Line", "number", "file", "source", "point", "email", "LINE", "eline", "user", "comment", "lin", "nl", "el", "page", "cell", "body", "frame", "day", "text", "chain", "rule", "zone", "phrase", "l", "block", "license", "ice", "row", "inline", "print"]}}
{"id1": "16621499", "id2": "1357662", "code1": "    public static byte[] loadURLToBuffer(URL url) throws IOException {\n        byte[] buf = new byte[4096];\n        byte[] data = null;\n        byte[] temp = null;\n        int iCount = 0;\n        int iTotal = 0;\n        BufferedInputStream in = new BufferedInputStream(url.openStream(), 20480);\n        while ((iCount = in.read(buf, 0, buf.length)) != -1) {\n            if (iTotal == 0) {\n                data = new byte[iCount];\n                System.arraycopy(buf, 0, data, 0, iCount);\n                iTotal = iCount;\n            } else {\n                temp = new byte[iCount + iTotal];\n                System.arraycopy(data, 0, temp, 0, iTotal);\n                System.arraycopy(buf, 0, temp, iTotal, iCount);\n                data = temp;\n                iTotal = iTotal + iCount;\n            }\n        }\n        in.close();\n        return data;\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 0, "substitutes": {"loadURLToBuffer": ["loadURLToBytes", "loadUrl2Buff", "loadUrlToBuffer", "loadURLtoBuff", "loadURLToBuff", "loadUrlToBuff", "loadURL2Buff", "loadURLtoBuffer", "loadUrlToBytes", "loadUrl2Bytes", "loadURLtoBytes", "loadUrl2Buffer", "loadURL2Buffer", "loadURL2Bytes"], "url": ["mail", "Url", "link", "name", "html", "pl", "cert", "char", "xml", "loader", "r", "job", "file", "location", "b", "log", "gl", "ssl", "bel", "base", "dl", "uri", "web", "http", "nl", "page", "sl", "el", "str", "ll", "browser", "address", "l", "open", "URL", "ls", "ur", "ul"], "buf": ["bn", "msg", "cap", "cv", "tr", "bc", "tx", "bs", "cb", "bh", "bl", "nt", "seq", "nb", "cmd", "b", "div", "buffer", "log", "uf", "dat", "Buffer", "tmp", "capt", "conv", "box", "bar", "bp", "queue", "batch", "txt", "axe", "bu", "arr", "mu", "br", "font", "str", "bag", "img", "Buff", "buff", "bo", "pkg", "vec", "db", "ctx", "bt", "rb", "cat", "fb", "desc", "mus", "bytes", "BU"], "data": ["cache", "obj", "p", "info", "content", "partial", "buffer", "dat", "di", "res", "set", "str", "text", "no", "bo", "table", "count", "list", "name", "msg", "ata", "part", "def", "ret", "message", "div", "result", "done", "type", "size", "raw", "this", "a", "nt", "value", "json", "all", "tmp", "zero", "step", "batch", "arr", "good", " DATA", "out", "length", "output", "total", "null", "missing", "bytes", "initial", "image", "it", "action", "bus", "dec", "bin", "results", "next", "default", "map", "txt", "only", "mu", "br", "item", "buff", "rel", "to", "DATA", "format"], "temp": ["util", "tem", "cache", "unit", "nom", "tr", "EMP", "vol", "ret", "dest", "v", "tc", "current", "copy", "mm", "deg", "partial", "pos", "div", "alt", "buffer", "unt", "tt", "variable", "tmp", "dat", "Temp", "mod", "template", "ptr", " Temp", "rem", "result", "txt", "fake", "tim", "tar", "mp", "font", "ta", "porary", "t", "buff", "mem", "pre", "test", "term", "met", "pt", "null", "em", "tm", "mont", "emp"], "iCount": ["piTotal", "diCounter", "jcount", "intNow", "iniMark", "iCounter", "aiCounter", "giTotal", "phiMark", "iiNow", "ciTotal", "piCount", "ciCP", "diCount", "iNow", "biCode", "giCheck", "iMark", "jLength", "giCount", "iniCount", "intProcess", "iiTotal", "biCount", "iuCount", " icount", "phiCount", "uiCounter", " iCode", "giCounter", "aicount", "iiCounter", "iCheck", "liTotal", "dicount", "piCP", "jTotal", "iProcess", "iCall", "piCounter", "liCount", " iCheck", "iiProcess", "iriCount", "liCounter", " iLength", "piLength", "iiCategory", "iniNumber", "iuCP", "icount", "iCategory", "uiCount", "uiTotal", "iriNow", "iuTotal", "phiLength", "iiCall", "aiLength", "iuCounter", "iCode", "iniLength", "iCP", "iLength", "iNumber", "aiCount", "biTotal", "biCheck", "jCount", "aiTotal", " iMark", "giCode", "liCall", "phiNumber", "iriCategory", " iCounter", "diTotal", "uiCall", "intCategory", "giLength", "ciCounter", "ciCount", "iiCount", "intCount", "iriProcess", " iNumber"], "iTotal": ["jtotal", "piTotal", "uiFull", "miCurrent", " iNow", " iLast", "iiZero", "miToken", "ditotal", "mitotal", "ciTotal", "piCount", "iLast", "iitotal", "ciAll", "diCount", "iNow", "liParent", " iZero", "iuNew", "piDone", "phiTotal", "phiNew", "liLast", "aiToken", "miAll", "aiComplete", "iTemp", " itotal", " iTarget", "iiTotal", "diNow", "imTotal", "iDone", "miLast", "liTotal", "jTotal", "liCount", "piFull", "miTarget", " iTemp", " iFull", "miComplete", "iuLast", "iAll", "iToken", "miTotal", "ciToken", "miZero", "itotal", "uiTotal", "ciComplete", "iuTotal", "jCurrent", " iDone", "iParent", "imCount", "iZero", "phiLast", "iComplete", "piParent", "jZero", "iuTarget", "liNew", "jCount", "aiTotal", "jNow", " iCurrent", "uiDone", "diTotal", "iNew", "aiAll", " iNew", "liTemp", "iCurrent", "iiCount", " iParent", "phiTemp", "iTarget", "imZero", "imtotal", "iFull", "miNew"], "in": ["inn", "al", "inc", "up", "is", "it", "per", "and", "inner", "isin", "v", "add", "r", "din", "info", "mm", "b", "bin", "i", "h", "io", "serv", "on", "from", "In", "conf", "sum", "or", "ic", "check", "ins", "en", "out", "mn", "IN", "by", "l", "get", "con", "ma", " din", "cin", "input", "re", "mc", "reader", "inf", "ind"]}}
{"id1": "8625346", "id2": "21824901", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringAsDisk", "encodeStringAsStream", "encodeFileAsStream", "encodeFiletoDisk", "encodeStringAsFile", "encodeStringToStream", "encodeFileToFiles", "encodeStringToFiles", "encodeStringToDisk", "encodeStringAsFiles", "encodeFileAsFile", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileAsDisk", "encodeFiletoStream", "encodeFileFromFiles", "encodeFileAsFiles", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk", "encodeFileFromDisk", "encodeFileFromFile", "encodeFileToStream"], "infile": ["inFile", "outFile", "InFile", "inputfilename", "inbase", "Inbase", " inbase", " inFile", "infilename", "inpath", "Inpath", " inpath", "outbase", "Infile", "outfilename", "outpath", "inputfile", "inputpath", "inputFile", " infilename"], "outfile": ["inFile", " outname", "outFile", "infp", " outFile", "fromfile", "tofp", "newfilename", "todir", "outdir", "infilename", "toFile", "fromfp", "indir", "outname", "fromFile", "inname", "outfp", "outfilename", " outfilename", "newfile", "newFile", "fromdir", "newname", "tofile"], "in": ["inn", "im", "al", "inc", "up", "pin", "conn", "init", "image", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "gin", "on", "id", "from", "In", "form", "or", "amin", "ins", "inside", "t", "en", "IN", "ro", "by", "get", "iter", "con", " din", "cin", "rin", "input", "re", "ar", "inf", "oin", "ind"], "out": ["up", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "aos", "outer", "flush", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "null", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "character", "sequence", "cache", "view", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "bone", "variable", "pad", "buf", "black", "append", "Buffer", "template", "bar", "padding", "library", "available", "password", "button", "note", "batch", "base", "comment", "queue", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "length", "block", "row", "print", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "run", "connect", "allow", "through", "query", "start", "i", "push", "close", "give", "send", "wait", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "req", "count", "iter", "seek", "end", "skip", "input", "readable", "need", "n", "size", "print", "reader", "index", "ind", "Read"], "success": ["response", "town", " okay", "first", "same", "fail", "continue", "primary", "support", " successes", "commit", " successful", "positive", "growth", "photo", "safe", "value", "submit", " succ", "second", "snap", "Success", "city", "ccess", "successfully", "error", "warning", "ceed", "result", "successful", "complete", "setup", "done", "accept", "crit", "sufficient", "release", "democracy", "valid", "status", "good", "surv", "danger", "summary", " Success", "condition", "please", "ok", " failure", "unity", "ratulations", "cess", "ith"]}}
{"id1": "18891988", "id2": "20619879", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["getString", "GetFilename", "createString", "selectFile", "createFilename", "createFile", "createfile", "selectfile", "getFilename", "GetFile", "selectFilename", "getfile", "GetString", "selectString", "Getfile"], "serviceName": ["ServiceName", "serverType", " serviceCode", "serverCode", "libraryType", "serviceType", " serviceFamily", "ServiceCode", "ServiceType", "serviceCode", " serviceType", "ServiceFamily", "libraryFamily", "ServiceNames", "libraryName", "serverName", "libraryNames", "serviceNames", "serviceFamily", " serviceNames"], "wsdlLocation": ["wssdLoc", "wssdURL", "wlLocation", "wsdlFolder", "wlLoc", "wsdlPath", "wsDLLocation", "wsDLURL", "wlPath", "wsdlocation", "wsolLocation", "wsdURL", "wslLoc", "wsolLoc", "wsdlLoc", "wsdLocation", "wsDLLoc", "awsdURL", "wdlLocation", "wsdLoc", "awsdLocation", "wssdPath", "wssdlocation", "wssdLocation", "wsDLFolder", "wlFolder", "awsdLoc", "wslLocation", "awsolURL", "awsdlocation", "awsdlLocation", "wsDLPath", "awsdlURL", "awsollocation", "wsolURL", "wsollocation", "wdlLoc", "awsolLoc", "wdlPath", "awsolLocation", "wdlFolder", "wsdllocation", "wsDLlocation", "awsdlLoc", "wssdFolder", "awsdllocation", "wslFolder", "wsdlURL", "wslPath"], "endpoint": ["Endword", "beginpoints", "Endport", "startline", "endword", "beginpoint", "idpoint", "endport", "startpoint", "bindpoints", " endpoints", " endline", " endport", "endPoint", "bindport", "idPoint", "endline", "beginPoint", "endpoints", "startPoint", "startpoints", "bindpoint", "Endpoints", "beginword", "EndPoint", "idpoints", "bindPoint", "idline", "Endpoint", " endPoint", "startword"], "fileLocation": ["documentPosition", "fileLoc", "documentLoc", "filePosition", "filelocation", " filePosition", "documentlocation", "FileLoc", "FilePosition", "documentLocation", " filelocation", "Filelocation", "FileLocation", " fileLoc"], "tempDir": ["tempUrl", "Tempdir", "tmpdir", "tmpPath", "TempPath", "tmpDirectory", " tempDirectory", "tmpUrl", " tempdir", "tmpDir", "TempDir", "tempPath", " tempPath", "tempDirectory", "TempDirectory", "TempUrl", "TempFolder", "tmpFolder", "tempFolder", " tempFolder", " tempUrl", "tempdir"], "url": ["mail", "Url", "link", "up", "pl", "conn", "cert", "socket", "char", "ret", "r", "job", "mount", "location", "gl", "ssl", "build", "bel", "f", "m", "il", "base", "dl", "uri", "github", "web", "http", "nl", "sl", "service", "str", "ctrl", "sur", "ll", "browser", "https", "loc", "rel", "un", "l", "open", "cr", "URL", "re", "ls", "ur", "window", "cp", "ul", "li"], "WSDLFile": ["WSDLLFILE", "WSDLString", "WSDLType", "WHDDLFile", "WHDDLfile", "WSDLFilename", "WSDLSFile", "WIDLFile", "WSDDLfile", "WNDDLFILE", "WIDDLfile", "WSDELFile", "WSDLSType", "WIDDLString", "WIDDLType", "WSDLFILE", "WIDLString", "WSDQLFile", "WSDQLfile", "WNDDLfile", "WSDLLfile", "WSDMLFILE", "WIDLType", "WSDQLFILE", "WHDLFILE", "WSDDLType", "WSDDLString", "WNDLfile", "WNDLFilename", "WSDDLFILE", "WSDELFILE", "WNDLFILE", "WNDDLFilename", "WHDLFile", "WIDLfile", "WSDLLType", "WSDLSString", "WSDDLFilename", "WHDDLFILE", "WSDELfile", "WIDDLFile", "WNDDLFile", "WSDLLFile", "WSDDLFile", "WSDLLFilename", "WSDELFilename", "WSDMLFile", "WSDMLfile", "WNDLFile", "WHDLfile", "WSDLLString", "WSDLSfile", "WSDLfile"], "tmpWSDLFile": ["tmpWSDLLfile", "tmpWIDDLFILE", "tmpWSDLDFilename", "tmpWSDLDFile", "tmpWIDDLfile", "tmpWNDLFiles", "tmpWIDDLFilename", "tmpWIDLFILE", "tmpWSDLFILE", "tmpWNDLfile", "tmpWSDLLFile", "tmpWSDlfile", "tmpWNDDLfile", "tmpWSDlFile", "tmpWSDLLFiles", "tmpWSDDLFILE", "tmpWSDLFiles", "tmpWSDDLFilename", "tmpWSDLFilename", "tmpWSDDLFile", "tmpWNDDLFiles", "tmpWSDDLfile", "tmpWNDLFilename", "tmpWSDLDFILE", "tmpWNDDLFilename", "tmpWNDLFile", "tmpWIDDLFile", "tmpWSDLfile", "tmpWSDlFilename", "tmpWIDLFilename", "tmpWSDDLFiles", "tmpWSDLLFilename", "tmpWSDLLFILE", "tmpWNDDLFile", "tmpWSDlFiles", "tmpWSDLDfile", "tmpWIDLfile", "tmpWIDLFile"], "inputFile": ["Inputfile", "inFile", "indexFILE", "interfaceFile", "tmpFILE", "InputPath", "InputDo", "InputFile", " inputFiles", "intFile", "outputFile", "InputFILE", "clientFiles", "intFILE", " inputfile", "indexfile", " inputSourceFile", "outputfile", "clientPath", "inputPlace", " inputPlace", "indexFile", "errorFile", "tmpSourceFile", "outputStream", "clientFILE", "inputFILE", "errorfile", "clientFile", " inputFILE", "errorFILE", "inputStream", "InputStream", "tmpStream", "indexStream", " inputPath", "tmpPlace", "inPath", "inputPath", "intfile", "InputFiles", " inputDo", "infile", "inputfile", "errorStream", "interfaceSourceFile", "tmpfile", "intFiles", "inDo", "inputSourceFile", "interfacePlace", "inputFiles", "inputDo", "outputFILE", "interfacefile"], "tmpFile": ["mpFile", "empfile", "empFILE", "tmpFiles", "tmpFILE", "empFile", " tmpFiles", "tmpFilename", "tempFiles", "tmpPath", "inputFILE", " tmpPath", "tempPath", "mpFiles", "inputFilename", "tempfile", "tempFILE", "tempFilename", "empFilename", "mpPath", "mpfile", "inputfile", "tempFile", "tmpfile", " tmpfile"], "in": ["inn", "inc", "conn", "ln", "ri", "ch", "init", "is", "it", "mi", "ain", "inv", "sin", "inner", "stream", "isin", "ini", "r", "din", "file", "source", "bin", "io", "id", "c", "from", "cont", "In", "ic", "ins", "t", "en", "IN", "o", "client", "ai", "n", "input", "cin", "rin", "ar", "inf", "ind"], "out": ["auto", "cache", "obj", "group", "conn", "ch", "writer", "Out", "inv", "pool", "this", "ex", "w", "outer", "aos", "lock", "file", "all", "log", "buffer", "sys", "io", "tmp", "conv", "on", "c", "conf", "we", "t", "en", "at", "o", "ne", "OU", "by", "write", "output", "client", "cm", "os", "null", "to", "oss", "ao", "co", "connection", "outs", "OUT", "net", "can", "n", "ou"], "con": ["acon", "cons", "sec", "conn", "ln", "ch", "ws", "soc", "ain", "const", "fn", "tc", "connect", "cos", "cone", "func", "ran", "conv", "win", "cal", "fc", "num", "c", "login", "conf", "nc", "com", "CON", "cur", "un", "cm", "cf", "exc", "Con", "connection", "co", "cin", "Conn", "re", "mc", "can", "cp", "cn"], "fileLength": ["objectDuration", "fileSize", " fileLen", "fileLen", " fileDuration", " fileSize", "objectLength", "channelDuration", " fileFontSize", "FILESize", "fileFontSize", "ileLength", "FILELength", "ileDuration", "channelFontSize", "ileLen", "channelLength", "FILEDuration", "channelSize", "ileSize", "FILELen", "objectFontSize", "fileDuration", "objectSize"], "channelIn": ["ChannelIn", " channelIN", "channelIN", "ChanneledIn", "chanOut", "chanIN", "consoleedIn", "Channelin", "consoleOut", "ChannelOut", "ChannelIN", "channelSet", "consoleIN", "clientIN", "ChannelSet", "consoleIn", "clientin", " channelin", "channelin", "clientIn", "chanSet", "clientOut", "chanIn", "clientSet", "channeledIn", " channeledIn"], "channelOut": ["ChannelIn", "consoleOUT", "chanConn", "chanOut", "consoleOut", "ChannelOut", "ChannelConn", "chanout", "courseIn", "channelConn", "channelout", "consoleout", "consoleIn", "courseOUT", "Channelout", " channelConn", "courseout", "ChannelOUT", "courseOut", "chanIn", " channelout", "channelOUT", " channelOUT"], "tmpDocument": ["tmdocument", "tempDocument", "npDocuments", "tmpdocument", "cpdocument", " tmpDoc", "mkdocument", "mkDocument", " tmpdocument", "tempdocument", "tmpMedia", " tmpDocuments", "tmpDoc", "tpDocument", "tpMedia", "tmDoc", "mpDocument", "mkDoc", "tmDocument", "tpFile", "npFile", "mpDoc", "cpDoc", " tmpMedia", "npMedia", "tpDocuments", "tempDoc", "tmpDocuments", "mpdocument", "npDocument", "cpDocument"], "nl1": ["nel6", "nl0", "lnOne", "rnOne", "sol1", "NL1", "nrOne", "rn3", "nl3", "rn6", "pel1", "nlOne", "nel1", "NL9", "pel01", "sol2", "rn1", "nl6", "ln1", "nr1", "ln9", "nl9", "ln6", "ln2", "pelOne", "NL2", "sol9", "nr01", "nelOne", "nl2", "sol0", "ln0", "nl01", "ln3", "NL0", "nel3", "ln01"], "i": ["ix", "bi", "ip", "key", "init", "span", "ri", "mi", "is", "x", "it", "gi", "ji", "ui", "si", "v", "a", "ini", "hi", "info", "ami", "index", "u", "cli", "\u0438", "k", "io", "ci", "me", "ti", "ori", "multi", "j", "di", "id", "xi", "m", "mu", "y", "ic", "ims", "ms", "qi", "ij", "us", "o", "ai", "I", "ie", "pi", "sim", "n", "ii", "li"], "node1": ["Node001", "layer1", "n0", "n1", "component0", "node2", "nodeOne", " nodeOne", "component1", "layerOne", "ode0", " node0", "node91", "node001", "Node2", "node0", "ode001", " node2", "nOne", "Node0", "Node1", "n91", "component2", "componentOne", " node001", "ode1", "ode2", "layer0", " node91", "layer91", "NodeOne"], "tmpOut": ["tmpIn", "TempOUT", "mpOut", "mpout", "TempOut", "cmpIn", " tmpIs", "npOut", "empout", "tmpout", " tmpObj", "cmpout", "cmpOut", "TempObj", "tempOut", "tmpObj", "mpIn", "npout", "tempObj", "npIn", "npObj", "tempout", "tmpIs", "tempIs", "tempOUT", " tmpout", "tmpOUT", " tmpIn", "mpObj", "empIs", "TempIn", "empOut", "tempIn", " tmpOUT"], "retVal": ["RetVal", "RetTrue", "returnValue", "returnval", "retValue", " retValue", " retval", "retval", "returnTrue", " retTrue", "Retval", "retTrue", "RetValue", "returnVal"]}}
{"id1": "5760649", "id2": "3024970", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "label": 1, "substitutes": {"createFile": [" createFiles", " createfile", " createStream", "saveFile", "uploadFile", "saveFiles", "saveStream", "createfile", "createFiles", "uploadFiles", "uploadStream", "savefile", "uploadfile", "createStream"], "src": ["fp", "url", "sec", "obj", "comp", "inst", "sq", "is", "rs", "stream", "dest", "sr", "sb", "rx", "config", "source", "start", "sys", "SourceFile", "sit", "resource", "ipl", "fc", "txt", "abs", "from", "uri", "res", "pour", "ctr", "st", "str", "ser", "cur", "loc", "rect", "sc", "rc", "input", "SOURCE"], "filename": ["fp", "name", "println", "FN", "path", "ln", "string", "nm", "png", "jpg", "fn", "v", "subject", "ename", "title", "nil", "file", "location", "ren", "SourceFile", "fil", "FILE", "kl", "txt", "stem", "nl", "bf", "prefix", "Filename", "xxx", "output", "family", "n", "username"], "fis": ["bfios", " fios", "sfiss", "Fis", "sfios", "ffos", "bfiss", " fIS", "fiss", "afiss", "fios", "afais", "Fiss", "sfis", "afis", "sfais", " fisi", "Fios", "FIS", "ffIS", "bfis", "afios", "Fos", "bfos", "fIS", " fiss", "Fisi", "ffisi", "fisi", "ffis", " fais", "fais"], "fos": ["wor", "tis", "bos", " foes", "fOS", "Fis", "voses", "wOS", "tos", "woses", "tios", "foes", "fios", "woss", "vOS", "flis", "foses", "wis", "flos", "flios", "wos", "foss", "boss", "Foss", " fOS", "bis", "Fos", " foses", "wios", "Foes", "toss", "floss", "vos", "vor", " foss", "boes"]}}
{"id1": "23310397", "id2": "3945236", "code1": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"onCreate": ["onsCreate", "onsCreated", "onCreated", "onNew", "onsNew", "onCreat", "whenCre", " onCre", " onCreated", "OnCreate", "onCre", "whenCreate", "OnCreated", "onsCreat", "onsCre", "whenCreat", " onNew", "whenCreated", "OnNew", " onCreat"], "savedInstanceState": ["savingInstanceInfo", "savedanceInfo", "savedInstantIn", "saveInstanceIn", "savedInstIn", "savedinstancestate", "saveinstanceState", "savedInstState", "savingInstanceEx", "savedInstantState", "saveinstanceIn", "saveInstancestate", "saveinstancestate", "savedinstanceEx", "savedInstant_", "savedanceState", "savedInstanceIn", "savedInstanceEx", "savedinstanceState", "saveInstance_", "savedInstancestate", "savedInstance_", "savedInstInfo", "savedInststate", "savedInstanceInfo", "savingInstanceState", "savedinstance_", "savedinstanceIn", "savedInstEx", "savingInstInfo", "savingInstState", "saveInstanceState", "savingInstEx", "savedanceEx", "savedinstanceInfo", "savedInst_", "saveinstance_", "savedInstantstate"], "mButton1": ["mLabel11", "mSwitch1", "mLabelA", "mDialogOne", " mActionA", " mButtonOne", "mDialog0", "MLabel2", " mAction1", "MButton2", " mAction0", "mActionOne", "mButtonA", "MLabel11", "mDialog1", "mLabelOne", " mButtonA", "mButton11", "mButton0", "mActionA", " mButton0", "mAction1", "MLabel1", "mAction2", "MLabelOne", "mLabel0", "mSwitchOne", "MButtonOne", "mAction11", "mDialogA", "mButtonOne", "mSwitch2", "mLabel1", "mAction0", "MButton11", " mActionOne", "MButton1", "mSwitch11", "mLabel2"], "mButton2": ["mLabelTwo", "mBut3", "pButTwo", "mConnector2", " mButton6", "mAction3", "mButTwo", "mQueue6", "mButton3", "pButton2", "mLabel3", "mButton0", "mButtonTwo", " mAction2", "mConnectorTwo", "pBut0", "pButtonTwo", "mAction2", "mConnector0", "mConnector3", "mLabel0", "pButton3", "mConnector6", "mQueue2", "mButton6", " mAction6", "mBut0", " mButton3", "pButton0", "pBut3", "mAction6", "pBut2", "mBut2", " mAction3", "mLabel2", "mQueue3"], "mTextView1": ["mTextview2", "mTEXTview2", "mTEXTviewOne", "mTextModel8", "mTextV1", "mTextStream1", "mTEXTView8", "mTEXTview1", "mTextBox1", "mTEXTViewName", "mTEXTStreamOne", "mTEXTview8", "mTextView4", "mTextViewOnce", "mTEXTviewTab", "mTextModel1", "mTextStreamOne", "mTextview0", "mTEXTView1", "mTEXTview0", "mTEXTView0", "mTextModelOnce", "mTextVName", "mTextV3", "mTextview4", "mTEXTStream2", "mTEXTView2", "mTEXTView4", "mTextview8", "mTextview3", "mTextView8", "mTEXTViewOne", "mTEXTViewTab", "mTextRow0", "mTextview1", "mTEXTModel3", "mTextView0", "mTEXTModelOne", "mTextModel4", "mTEXTModelName", "mTextStream4", "mTextViewTab", "mTEXTModel1", "mTextBoxOne", "mTextBox8", "mTextviewName", "mTextView3", "mTextviewTab", "mTEXTModelOnce", "mTEXTViewOnce", "mTextView2", "mTextModelOne", "mTextviewOne", "mTextRow1", "mTextModelTab", "mTextBox2", "mTextModel0", "mTextViewName", "mTextModel2", "mTextStream2", "mTextModel3", "mTextRow2", "mTEXTStream4", "mTextviewOnce", "mTEXTStream1", "mTextV2", "mTextModelName", "mTextBoxTab", "mTEXTView3", "mTextViewOne", "mTextRowOne", "mTEXTModel2"], "v": ["view", "p", "x", "g", "a", "w", "u", "e", "uv", "b", "vp", "i", "h", "j", "ov", "id", "f", "m", "sv", "c", "V", "q", "y", "t", "lv", "o", "d", "l", "z", "vm", "n"], "uriAPI": ["folderURI", "databaseCI", "pictureCI", "directionII", "uiID", "surfacePLE", "parallePI", "uiII", "databaseNP", "surfaceNP", "directionID", "URIAPI", "uriURI", "surfacePI", "originURI", "doiPI", "directionAPI", "directoryII", "folderapi", "directoryURI", "uriNP", "originapi", "uiURI", "URIURI", "directionURI", "doiAPI", "directoryapi", "uriCI", "databasePI", "originII", "parallePLE", "databaseVM", "originAPI", "databasePLE", "URIID", "folderAPI", "uriapi", "directoryAPI", "pictureVM", "databaseAPI", "uriVM", "picturePI", "pictureAPI", "uriII", "folderII", "paralleAPI", "uriPI", "uriID", "uiAPI", "surfaceAPI", "URIII", "paralleNP", "uriPLE", "doiCI", "doiVM"], "httpRequest": ["httResponse", " httpQUEST", " httpCommand", "httpsCommand", " httpUpon", "ttpRequest", "Httprequest", "httQUEST", "ttpQuery", "ttpCommand", "httpQUEST", "httpsRequest", "ttpResponse", "facebookResponse", "ttpQUEST", "HttpCommand", "httRequest", "HttpQuery", "httpUpon", "HttpUpon", "httpCommand", "httpQuery", " httpQuery", "httpsResponse", "httprequest", "httpsQuery", "HttpRequest", "HttpResponse", "facebookRequest", "facebookrequest", " httprequest", "facebookUpon"], "params": ["groups", "fields", "pres", "p", "posts", "settings", "rs", "lines", "forms", "ps", "marks", "members", "json", "AMS", "pos", "Parameters", "values", "param", "gs", "np", "caps", "keys", "tags", "requires", "multi", "padding", "pps", "data", "phys", "actions", "pas", "pins", "conf", "photos", "packages", "sql", "details", "objects", "parts", "api", "changes", "vals", "times", "terms", "request", "ams", "options", "pi", "pass", "names", "mas", "properties"], "httpResponse": [" httpResp", "HTTPResponse", "httpRes", "httpresponse", "ttpRequest", "htmlResponse", "HTTPResult", "httpsResp", "httpsRequest", "HttpRes", "httpsReturn", "ttpResponse", " httpResults", " httpresponse", "httpsresponse", "httpsResult", "htmlresponse", "ttpResult", "HTTPRequest", "htmlResults", "httpsResults", "ttpresponse", "httpsResponse", " httpReturn", "httpResults", "httpReturn", " httpRes", "HttpResult", "Httpresponse", "HTTPresponse", "httpResp", " httpResult", "httpsRes", "HttpRequest", "httpResult", "HttpResponse", "htmlResult", "HttpReturn", "htmlRequest", "ttpResp"], "strResult": ["stringRes", "STRResponse", "StrResults", "STRresult", "stringResponse", "STRResult", "strResponse", "strresult", " strRes", "stringResult", "stringResults", "StrRes", " strResults", "StrResponse", "stringresult", "StrResult", "strResults", "strRes", "Strresult", " strresult", "STRResults"]}}
{"id1": "23532405", "id2": "19134229", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"persist": ["remist", "remister", "remiste", "Persiste", "Persain", "insiste", "remain", "insist", "Persist", "Persister", "persain", "persiste", "insister", "persister", "insain"], "ffConfigurable": ["ffconfigURA", "ffPorturable", "ffConfigurated", "ffRequestuer", "ffconfigurate", "ffConfigurationurated", "ffconfigural", "ffConfurated", "ffPortutable", "ffLogurated", "ffConfigURA", "ffConfurable", "efConfiguring", "efConfigurate", "ffConfigured", "ffCerturable", "effCerturable", "ffConfigurationured", "uffconfiguer", "ffConfigurationURA", "effPortutable", "ffConfigural", "ffSpecural", "ffPorturer", "ffConfuer", "ffCerturing", "effCertured", "effCerturated", "ffPorturated", "effConfigutable", "efConfigural", "effPorturer", "effConfigURA", "ffCerturate", "uffConfiguer", "ffCertured", "ffConfurer", "ffconfigured", "uffConfigorable", "ffConfiguer", "uffConfiguring", "effConfigurated", "ffconfigorable", "ffSpecuring", "ffconfiguring", "ffConforable", "ffconfigurated", "efconfigurate", "ffCertURA", "uffconfiguring", "ffConfigurer", "ffCertural", "ffConfigutable", "ffConfiguring", "effConfigurable", "ffConfuring", "ffCerturated", "ffLogurable", "efconfiguring", "efconfigural", "ffConfigorable", "ffconfiguer", "uffConfigurable", "ffLogurer", "ffLogutable", "efConfigurable", "effPorturable", "ffSpecurate", "ffSpecurable", "effConfigured", "effPorturated", "ffRequestorable", "effConfigurer", "effCertURA", "ffconfigurable", "uffconfigurable", "ffRequesturable", "ffConfigurate", "ffRequesturing", "uffconfigorable", "efconfigurable", "ffConfigurationurable", "ffConfutable"], "relativePath": ["qualifiedFile", " relativeRoot", "absoluteUrl", " relativeUrl", "absoluteRoot", "absoluteFile", "absoluteDir", " relativeDir", "relativeRoot", "qualifiedDir", "absolutePath", "relativeName", " relativeName", "relDir", "relUrl", "relativeDir", "qualifiedPath", "relativeUrl", "relativeFile", "qualifiedName", "absoluteName", "relPath", " relativeFile", "relRoot"], "file": ["fp", "ile", "name", "port", "al", "auto", "link", "url", "view", "path", "le", "File", "image", "header", "full", "string", "pool", "stream", " File", "message", "memory", "issue", "entry", "lock", "e", "folder", "filename", "buffer", "log", "resource", "fil", "local", "template", "FILE", "user", "f", "project", "queue", "base", "force", "page", "command", "store", "frame", "set", "play", "class", "rule", "spec", "out", "create", "db", "table", "output", "work", "word", "dir", "to", "list", "document", "use", "handle", "format"], "is": ["bits", "im", "are", "ip", "ib", "iss", "bs", "isin", "isa", "sis", "iso", "Is", "ir", "i", "ris", "es", "IS", "xs", "fs", "bis", "its", "ic", "in", "ios", "isl", "ms", "ins", "us", "ists", "ais", "iris", " Is", "s", "isc", "js", "ires", "isi", "ls", "ist", "nis", "lis"], "os": ["bos", "obs", "ose", "Os", "ols", "bs", "ui", "si", "oS", "ox", "ds", "oz", "pos", "iso", "sys", "cos", "i", "ys", "io", "es", "OS", "mot", "osi", "fs", "ot", "oa", "ops", "ios", "ms", "us", "o", "des", "oses", "los", "oss", " Os", "ls", "oos"]}}
{"id1": "11716816", "id2": "13891080", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"updateFile": ["downloadSourceFile", "updateContent", "archiveContent", "downloadFile", "UpdatePage", "downloadContent", "UpdateSourceFile", "archivePage", "downloadPage", "archiveSourceFile", "updatePage", "updateSourceFile", "UpdateContent", "UpdateFile", "archiveFile"], "file": ["ile", "fp", "name", "link", "url", "attribute", "port", "path", "le", "File", "image", "full", "p", "message", "info", "entry", "content", "issue", "title", "e", "source", "filename", "log", "h", "resource", "io", "channel", "local", "data", "FILE", "f", "base", "type", "report", "page", "t", "rule", "db", "table", "output", "get", "line", "null", "input", "document", "use", "handle", "format"], "IOException": [" IOProblem", "SecurityProblem", "SecurityException", "IOError", "OperationError", " IOError", "OperationException", "OperationProblem", "SecurityError", "IOProblem"], "destFile": ["Destile", " destPath", "sourceFile", " destDir", "destPage", "optFolder", "DestDir", "declFile", "destile", "targetDir", "Destfile", "DestPath", " destPage", "destPlace", " destPlace", " DestEmail", "destFolder", " destinationEmail", "destEmail", "destPath", "targetPath", "destSourceFile", "DestFile", "tempPath", " destFolder", "DestFolder", " destfile", "tempfile", "destfile", "declSourceFile", "DestSourceFile", " DestDo", " destinationDo", " destDo", " destinationDir", " destile", "optFile", "tempFile", "sourceDir", " DestDir", "targetFile", "destDo", "tempDir", "destDir", " destSourceFile", "DestPlace", "optPlace", "declFolder", "sourcePath", "declile", "sourceFolder", "DestPage", " DestFile", "optPage", " destEmail", " destinationFile", "targetFolder"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "raw", "is", "it", "mi", "ain", "act", "sin", "inner", "isin", "ini", "r", "din", "info", "mm", "all", "bin", "i", "io", "read", "gin", "local", "edIn", "on", "f", "m", "from", "In", "ic", "ins", "inside", "en", "IN", "ne", "l", "con", "ai", "iter", "s", " din", "n", "cin", "rin", "input", "ie", "re", " IN", "net", "pass", "inf", "oin", "ind"], "out": ["obj", "msg", "up", "cache", "ch", "conn", "it", "Out", "g", "v", "ex", "nt", "fn", "oe", "aos", "outer", "flush", "cmd", "b", "cos", "ion", "sys", "log", "io", "channel", "one", "conv", "gt", " OUT", "result", "ou", "again", "ot", "or", "t", "en", "chain", "no", "at", "jp", "o", "ne", "OU", "write", "output", "client", "os", "null", "con", "s", "oss", "to", "co", "outs", "OUT", "net", "note", "can", "n", "cn"]}}
{"id1": "22057083", "id2": "6840241", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 0, "substitutes": {"Connect": ["Connection", "Check", "Error", "New", "Bind", "Log", "Ping", "Init", " Init", "Client", "connect", "Create", "Auth", " Connection", "Dial", "Close", "Interface", "Construct", " Close", "Sync", " Open", "Login", "Setup", "Conn", "Connector", "Start", "Open", " Dial"], "client": ["port", "cgi", "cache", "obj", "server", "conn", "cmd", "buffer", "builder", "secure", "channel", "context", "one", "manager", "user", "call", "phone", "cell", "form", "store", "collection", "browser", "create", "bo", "table", "core", "list", "name", "url", "writer", "version", "Client", "man", "controller", "config", "product", "resource", "type", "force", "http", "google", "pb", "component", "con", "connection", "row", "net", "control", "mail", "remote", "util", "pc", "response", "pattern", "cli", "cl", "node", "ssl", "batch", "c", "handler", "command", "chain", "api", "module", "null", "co", "patch", "wrapper", "window", "handle", "ch", "key", "entry", "connect", "log", "session", "close", "local", "plugin", "service", "lib", "proxy", "open", "to", "reader", "cp"], "reply": ["link", "response", "answer", "resp", "mi", "shell", "notice", "ret", "repl", "message", "job", "entry", "nb", "flag", "py", "success", "vote", "query", "close", "next", "match", "translation", "user", "error", "echo", "result", "comment", "type", "report", "command", "status", "prefix", "code", "address", "bill", "no", "ply", "write", "line", "rc", "Reply", "print", "state"]}}
{"id1": "9449064", "id2": "17792212", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"readExp": ["readexp", "readLoc", "readExpress", "ReadEXP", "readerLoc", "passExp", "readerEx", "readExpl", "Readexp", " readExpl", "ReadEx", "passexp", "checkExpl", "readProp", "passExpress", "readerExp", " readLoc", "checkExp", "passExpl", "readerexp", "checkexp", " readProp", " readexp", " readExpress", "ReadProp", "readerEXP", "readEx", "checkExpress", "readerProp", " readEXP", "ReadExp", "ReadLoc", "readEXP", " readEx"], "writeExp": ["writeEv", "writeExt", " writeexp", " writeXP", "riteConf", "writeexp", "riteEXP", "riteReg", " writeEv", "updateExp", "applyEx", "writeXP", "writEXP", "writEx", "applyEXP", " writeExt", "writexp", "writExp", "applyXP", " writeReg", "updateEv", "riteExt", "writeEx", "writeReg", "updateReg", "riteExp", "writeConf", " writeConf", "writeEXP", "updateExt", "riteEv", " writeEXP", "writXP", " writeEx", "writConf", "applyExp", "riteexp"], "expFile": [" expFILE", "Expfile", "exFile", "docPlace", "mxFile", "repPath", " expPlace", "docField", "expDir", "repFILE", "exprName", "exfile", "exprDir", "docFILE", "exprFile", "exFILE", "expName", "ExpDir", "exFilename", "expPath", "ExpFile", "xpFiles", "expPlace", "exprFilename", "xpPath", "xpFILE", "mxName", "xpfile", " expfile", "exPlace", "expFILE", "xpFile", "xpField", "expFilename", "mxFILE", "mxFilename", "xpFilename", "xpName", "exFiles", "docFile", "docFilename", "exprfile", " expDir", " expFilename", " expFiles", "repFile", "exprFILE", "expfile", "expField", "expFiles", "repField", "docPath"], "exp": [" np", " resp", "obj", " est", " expansion", "comp", " ep", "ef", "pp", "resp", "EXP", " dj", " expanded", "comm", "lim", "def", "expr", " xp", " ne", "eq", "ps", "ox", " inst", "expression", "acc", "ent", " imp", "esp", " op", "plus", "bed", "opt", " disp", "push", "inst", "dem", "wx", " sc", "imp", "Exp", "zero", "isp", "ext", "ez", "f", " exc", "rep", "raw", " extr", "expl", " vec", " doc", "nz", "ev", "pr", "jp", "prov", "xp", "eps", " expand", "sc", " exponent", " lim", " expr", " ev", "pl", "inf", " rap"], "fi": ["ni", "xf", "ri", "mi", "ffe", "zo", "fif", "phi", "gi", "wi", "eric", "si", "ini", "uti", "FI", "ista", "fty", "i", "cci", "ti", "ci", "fa", "zi", "osi", "obi", "aci", "lf", "flo", "ei", "uci", "qi", "ico", "ki", "iri", "fe", "Fi", "pi", "isi", "ati", "abi", "ii", "li"], "oi": ["ni", "bi", "odi", "uo", "ri", "ivo", "mi", "eric", "ini", "ami", "uti", "oni", "avi", "igi", "iso", "obo", "i", "ovi", "ti", "ci", "ori", "io", "multi", "rio", "eni", "osi", "obi", "bis", "oa", "flo", "ei", "ta", "ico", "uci", "ki", "iri", "ita", "vi", "asi", "ink", "isi", "uta", "ati", "oin", "ii"], "jf": [" jF", "djfd", " jif", "jsxf", " jsf", "jjc", "jcsf", "jcfm", " jbf", "Jfd", "jssf", "jcxf", "jb", "jjv", " jb", "bjfm", "jjfm", " jv", " jfp", "jbf", "jxf", "jfd", "jackxf", "jackfd", "Jsf", "Jfx", "jcf", "jjF", "gc", "djbf", "jc", "jjfp", "jjif", "Jb", "jfp", "jF", "jjfc", "Jbf", "jif", "jackbf", "jsbf", "jfm", "jackf", " jfm", "JF", "gfm", "gf", "Jxf", "jjf", "bjv", "djf", "Jfm", "jfx", "Jf", "djxf", "gfc", "bjfp", " jfc", "jv", "bjf", "jcfx", " jfx", " jc", "jfc", "jsf", "jcb", " jxf", "Jif"], "sp": ["sm", "pl", "pp", "span", "p", "sk", "si", "sh", "ps", "se", "sb", "ep", "esp", "vp", "so", "par", "ap", "bsp", "sg", "sam", "bp", "isp", "sw", "sv", "lp", "asp", "spr", "space", "rep", "osp", "st", "SP", "op", "sf", "spe", "jp", "pb", "sc", "Sp", "pt", "spl", " esp", "cp", "tp"], "e": ["name", "p", "it", "E", "x", "v", "a", "w", "ee", "event", "i", "f", "m", " ev", "el", "t", "er", "d", "fe", "s", "re", "ie", "ev", "ed", "n", "pe"], "fo": ["tto", "xf", "uo", "ooo", "ato", "folio", "tf", "opa", "zo", "fif", "wi", "mo", "eno", "oe", "FO", "so", "obo", "io", "ti", "hea", "uf", "fa", "olf", "po", "flo", "ico", "ki", "bo", "ro", "lo", "o", "cf", "tif", "wo", "co", "aco", "wt", "oos"], "oo": ["uo", "ooo", "ato", "oes", "folio", "opa", "elo", "zo", "oid", "ola", "ox", "foo", "mo", "oe", "cro", "ko", "oooooooo", "so", "oto", "obo", "ora", "ollo", "oooo", "yo", "oco", "olo", "po", "oa", "flo", "aco", "ano", "ta", "ico", "bo", "ro", "lo", "o", "wo", "ilo", "goo", "aha", "ao", "co", "ero", "OO", "oos"], "ex": ["ix", "xe", "external", "six", "none", "su", "ac", "tx", "x", "act", "exe", "aux", "tex", "iox", "def", "rex", "ox", "Exc", "event", "cre", "de", "log", "Ex", "err", "sex", "es", "wx", "example", "ry", "ext", "EX", " exc", "el", "lex", "com", "ax", "or", "pex", "ic", "te", "status", "spe", "pers", "des", "ctx", "exc", "re", "except", "ception", "px", "hex", "nex"]}}
{"id1": "9954926", "id2": "18238468", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "label": 1, "substitutes": {"simulate": ["modulation", " simure", "modure", "smulate", "smulation", "simulates", "simulation", " simulation", "smure", "modulates", " simulates", "smulates", "simure", "modulate"], "out": ["cache", "obj", "conn", "p", "Out", "ex", "v", "content", "cmd", "last", "buffer", "ger", "io", "manager", "f", "res", "conf", "store", "in", "set", "help", "tree", "list", "state", "name", "writer", "inv", "pool", "put", "e", "gc", "error", "on", "report", "cfg", "at", "gr", "con", "os", "outs", "OUT", "screen", "net", "raw", "cn", "up", "exp", "hit", "nt", "w", "outer", "ent", "all", "nr", "err", "conv", "gen", "batch", "c", "base", "sum", "ins", "o", "OU", "output", "null", "co", "print", "can", "handle", "ou", "group", "go", "init", "gov", "it", "inner", "copy", "flush", "aos", "b", "log", "sys", "t", "write", "client", "to", "pretty", "n"], "file": ["port", "ile", "name", "fp", "path", "le", "File", "model", "handle", "pool", "message", "lock", "e", "b", "source", "buffer", "log", "filename", "resource", "io", "channel", "data", "template", "FILE", "library", "result", "f", "base", "type", "report", "console", "set", "play", "t", "db", "l", "output", "table", "connection", "input", "document", "format"], "obtainUserReputationRequest": ["obtainUserReputationrequest", "obtainUserReputationsResponse", "obtainUserRepresentationResponse", "obtainUserRelutationQuery", "obtainUserRepationrequest", "obtainUserReputationError", "obtainUserReputionTask", "obtainUserReputionTarget", "obtainUserReputionResponse", "obtainUserReputationTask", "obtainUserReputationsTarget", "obtainUserRelutationsTask", "obtainUserRelutationsRequest", "obtainUserRepositoryTask", "obtainUserRepresentationRequest", "obtainUserReputationsrequest", "obtainUserReplutationTarget", "obtainUserRepositoryRequest", "obtainUserReputationQuery", "obtainUserReporationError", "obtainUserRelutationRequest", "obtainUserRepetitionResponse", "obtainUserReputionrequest", "obtainUserReputionQuery", "obtainUserReporationResponse", "obtainUserRepationResponse", "obtainUserRelutationTask", "obtainUserRepationTarget", "obtainUserRepationError", "obtainUserRepresentationQuery", "obtainUserReputationsError", "obtainUserRepresentutationResponse", "obtainUserRepresentutationRequest", "obtainUserRepresentationError", "obtainUserRepresentutationrequest", "obtainUserReputationsQuery", "obtainUserRepresentationrequest", "obtainUserReputationsRequest", "obtainUserRelutationsResponse", "obtainUserReputionRequest", "obtainUserReporationQuery", "obtainUserRepresentationTarget", "obtainUserRepetitionRequest", "obtainUserReputationsTask", "obtainUserRepresentutationTarget", "obtainUserRepationQuery", "obtainUserRelutationsQuery", "obtainUserRepresentutationError", "obtainUserRepositoryResponse", "obtainUserReplutationResponse", "obtainUserReplutationRequest", "obtainUserRelutationResponse", "obtainUserRepositoryQuery", "obtainUserRepationRequest", "obtainUserRepresentutationQuery", "obtainUserReputationTarget", "obtainUserReporationRequest", "obtainUserRepetitionTarget"], "obtainUserReputationResponse": ["obtainUserReportutationResponse", "obtainUserReputationsResponse", "obtainUserRepulationAnswer", "obtainUserReportutationResp", "obtainUserReputationService", "obtainUserRepositoryAnswer", "obtainUserReportutationAnswer", "obtainUserReputationAnswer", "obtainUserReportositoryResp", "obtainUserReportositoryResponse", "obtainUserReputationResp", "obtainUserRepulationResp", "obtainUserRepulationService", "obtainUserReportositoryAnswer", "obtainUserReportositoryService", "obtainUserRepositoryService", "obtainUserReputationsResp", "obtainUserRepositoryResponse", "obtainUserReportutationService", "obtainUserReputationsService", "obtainUserRepositoryResp", "obtainUserReputationsAnswer", "obtainUserRepulationResponse"], "rateUserRequest": ["scaleOwnerRequest", "rateuserCommand", "createUserrequest", "rateTimerequest", "raceUserRecord", "raceUserrequest", "rateUserChange", "rateOwnerResponse", " rateUserrequest", "scaleUserResponse", "rateUsersResponse", "rateJobRequest", "rateRowJob", "createuserrequest", " rateUserJob", "rateSamplerequest", "rateUserJob", "rateuserQuery", "raceRowrequest", "RateLineRequest", "raceUserRequest", "rateUserrequest", "createuserRequ", "rateUsersAccess", "RateUsersChange", "rateLinerequest", "rateUserCommand", "rateRowRequest", "RateUserRequest", "rateuserAccess", "RateUserrequest", "rateUsersRequest", "RateUserQuery", "rateLineResponse", "rateUserRequ", "createuserRequest", "RateLineResponse", "createuserCommand", "rateOwnerRequest", "rateuserRequest", "rateLineRequ", "RateClientRequest", "rateDateGrant", "rateUserRecord", "RateUserQUEST", "rateuserrequest", "rateUserQUEST", "rateClientRequest", "RateUsersrequest", " rateUserQuery", "rateTimeResponse", "rateUsersQuery", "rateTimeRequest", "scaleOwnerAccess", "rateuserResponse", "rateUserAccess", "scaleUserRequest", "rateRowRecord", "rateUsersChange", "rateuserRequ", "rateClientResponse", "rateOwnerRecord", "rateOwnerAccess", "RateUsersRequest", "rateProxyQuery", "raceRowRecord", "rateClientrequest", "rateRowResponse", "rateClientJob", "scaleOwnerResponse", "rateSampleCommand", "RateUserGrant", "RateUsersResponse", "rateuserQUEST", "rateUsersQUEST", "rateClientGrant", "rateLineCommand", "rateUsersrequest", "rateProxyRequest", "RateUserChange", "RateClientResponse", "rateLineRequest", "rateLineQuery", "createUserRequ", "rateRowrequest", "rateDateRequest", "RateClientGrant", "rateDateResponse", "rateUserQuery", "rateLineGrant", "rateJobChange", "RateUsersQUEST", "createUserCommand", "RateLineQuery", "rateOwnerrequest", "rateSampleRequest", "scaleUserAccess", "rateProxyResponse", "RateUsersQuery", "rateUserGrant", "rateSampleRequ", "RateUserResponse", "createUserRequest", "raceRowRequest", "rateProxyQUEST", "RateLinerequest", "rateJobResponse"], "rateUserResponse": ["rateWordReturn", "rateUsersresponse", "RateUserReply", "rateMethodVersion", "RateUserVersion", "rateUsersReply", "rateUsersResponse", "rateTimeAnswer", "rateUserReturn", "rateWordRequest", "ratesUserRequest", "rateUserVersion", "ratesClientRequest", "rateUserData", "RateUsersReply", " rateClientRequest", "rateClientResp", "RateUserRequest", "rateUsersRequest", "rateMethodRequest", "rateUserAnswer", "rateTimeStatus", "rateUsersStatus", "rateControllerResp", "rateuserRequest", "rateDateData", "ratesClientMessage", "rateClientRequest", "rateFileRequest", "rateMemberRequest", "rateTimeResponse", "rateUserMessage", "rateTimeRequest", "rateuserResponse", "RateUsersresponse", "rateManagerResponse", "rateuserReply", " rateUserAnswer", "rateFileReturn", " rateClientresponse", "rateClientResponse", "rateControllerMessage", "ratesUserMessage", " rateClientResponse", "rateMemberResponse", "RateUsersRequest", "rateDateVersion", "RateUserData", "rateUserresponse", "rateWordResponse", " rateUserReturn", " rateUserStatus", "rateWordresponse", "rateManagerRequest", "rateUserStatus", "rateManagerResp", "RateUsersResponse", "rateControllerRequest", "rateuserresponse", "rateMemberresponse", "rateFileresponse", "rateUsersAnswer", "rateManagerMessage", "rateUserResp", " rateUserresponse", "ratesUserResponse", "RateUserresponse", "rateDateRequest", "rateDateResponse", "rateUserReply", "rateControllerResponse", "rateFileResponse", "rateMemberReply", "rateClientMessage", "ratesClientResponse", "ratesUserResp", "RateUserResponse", "rateClientReturn", "rateMethodData", "rateMethodResponse", "rateClientresponse", " rateClientReturn", "ratesClientResp"], "fis": ["bi", "sfiss", "flisa", "Fis", "fiss", "sfIs", "FIs", "liss", "sfIS", "flis", "Fiss", "sfis", " fi", "fi", "bis", "fli", "FIS", "fIs", " fisa", "bisa", "fIS", "fisa", "lIS", "lIs", "lis"], "br": ["bn", "bi", "ch", "tr", "BR", "adr", "bl", "hr", "bh", "sr", "Br", "wr", "bd", "div", "bridge", "nr", "ger", "buf", "ber", "be", "bp", "vr", "ctr", "bf", "gb", "str", "browser", "pr", "bm", "shr", "bt", "bro", "gr", "mr", "cr", "lr", "fr", "dr", "kr"], "call": ["name", "execute", "url", "ell", "action", "char", "inv", "continue", "add", "message", "info", "label", "all", "query", "bridge", "log", "update", "called", "function", "cal", "result", "comment", "c", "report", "send", "command", "cell", "trace", "status", "draw", "frame", "check", "str", "play", "code", "contact", "test", "line", "word", "block", "request", "dial", "list", "cin", "callback", "Call", "n", "use"]}}
{"id1": "9805906", "id2": "20100809", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"dump": [" show", "zip", "link", "println", "stat", "init", " println", " debug", "display", "info", "copy", "flush", "download", "update", "debug", "read", "export", " dumps", "save", "send", "store", "load", " describe", "write", "show", "diff", "print", " dumped"], "source": ["remote", "Source", "sequence", "view", "origin", "parent", "init", "image", "shell", "select", "ource", "scope", "src", "se", "sample", "info", "copy", "file", "config", "start", "sys", "resource", "local", "template", "from", "search", "site", "java", "form", "sql", "store", "service", "check", "text", "spec", "iter", "input", "ie", "script", "ink", "SOURCE", "style"], "target": ["delete", "link", "it", "pattern", "replace", "dest", "current", "bolt", "arg", "copy", "mac", "Target", "file", "goal", "compatible", "host", "arget", "next", "local", "that", "template", "match", "gt", "top", "project", "base", "t", "test", "proxy", "table", "output", "tif", "term", "null", "to", "style"], "is": ["tis", "im", "bits", "are", "ib", "ri", "ois", "ip", "init", "it", "iss", "act", "si", "isin", "mos", "isa", "sis", "iso", "Is", "isf", "i", "ys", "sys", "ris", "ir", "es", "IS", "xs", "abs", "bis", "its", "ic", "in", "ios", "isl", "ims", "ins", "ms", "has", "ists", "ais", "iris", "ai", "s", "isc", "oss", "ics", "isi", "ls", "ist", "ar", "nis", "lis", "ii"], "os": ["bos", "obs", "oes", "cs", "ose", "Os", "ols", "css", "ts", "bs", "uts", "oS", "ps", "ox", "ds", "mos", "aos", "ns", "ants", "ost", "pos", "sys", "cos", "io", "ss", "OS", "es", "fs", "osi", "ot", "or", "ios", "nos", "o", "oses", "los", "dos", "s", "oss", "ros", "js", "outs", "ows", "ls", "oos"], "done": ["loaded", "disabled", "die", "enabled", "created", "continue", "progress", "flag", "given", "de", "Done", "di", "ded", "checked", "later", "filled", "complete", "needed", "only", "shown", "ished", "valid", "du", "led", "set", "seen", "dirty", "started", "d", "des", "finished", "made", " Done", "expected", "pleted", "did", " continued", "gone", "desc", "failed", "found"]}}
{"id1": "481364", "id2": "3945236", "code1": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"downloadFiles": [" downloadBytes", "getImages", "getBytes", "dumpBytes", "downloadfiles", "dumpfiles", " downloadImages", "dumpImages", " downloadfiles", "downloadBytes", "dumpFiles", "getFiles", "downloadImages", "getfiles"], "downloadFilesWorker": ["downloadImagesWER", "downloadFilesWalkER", "downloadImagesWr", "downloadFilesWler", "downloadFilesWorkER", "downloadFilesWr", "downloadImagesWorker", "downloadImagesWer", "downloadImagesWorkr", "downloadFilesWalkler", "downloadImagesWorkER", "downloadFilesWorkr", "downloadFilesWalker", "downloadFilesCleanr", "downloadImagesWorkler", "downloadFilesWer", "downloadFilesWalkr", "downloadFilesCleanler", "downloadFilesWorkler", "downloadFilesCleaner", "downloadImagesWler", "downloadFilesWER", "downloadFilesCleanER"], "startDownloadDate": ["startLoadTime", "startFileDate", "startUploadTime", "startLoadDay", " startUploadDay", "startUploadDo", "startDownloadDay", "startFileAt", "startLoadDate", "startUploadDay", "startdownloadTime", " startUploadDo", " startdownloadTime", "lastUpdateDay", "lastDownloadDay", "startDownloadDo", " startdownloadDate", "startUploadAt", "startDateDate", "lastUpdateDate", " startDownloadTime", "startDateDay", "startUploadDate", " startUploadDate", "lastUpdateAt", "lastDownloadTime", " startUploadTime", "startdownloadDay", "startUpdateAt", "lastDownloadAt", "startDateTime", " startdownloadDay", "startDownloadAt", "startdownloadDate", "lastDownloadDate", "startLoadDo", "startFileTime", " startDownloadDo", " startDownloadDay", "startFileDay", "startDownloadTime", "lastUpdateTime", "startUpdateDate", "startUpdateDay", "startUpdateTime", "startdownloadDo"], "refreshSpeed": ["reflexDuration", "RefreshSpeed", "RefreshDuration", "RefetchDuration", "refetchDuration", "RefreshAmount", "refreshTime", "refillSpeed", "refetchSpeed", "reflexSpeed", "refreshAmount", "refillAmount", "RefetchAmount", "RefetchSpeed", "RefetchTime", "RefreshTime", "refreshDuration", "refillTime", "reflexTime", "refetchTime", "reflexAmount", "refetchAmount", "refillDuration"], "lastDate": ["nextDate", "lastdate", "LastDate", "lastDay", "nextDay", "nextTime", "LastDay", "lastTime", "nextdate", " lastdate", "LastTime", " lastDay", " lastTime", "Lastdate"], "totalSizeRead": ["TotalNumberLength", "TotalNumberWritten", "totalSizeLength", "totalNameRead", "TotalSizeLength", "totalLengthReader", "TotalSizeREAD", "totalBytesREAD", "TotalSizeread", "TotalSizeReader", "totalNumberWritten", "TotalNumberread", "totalLengthWritten", "TotalSizeWritten", "totalBytesWritten", "totalLengthRead", "totalBytesRead", "totalNumberReader", "totalLengthREAD", "TotalNumberReader", "totalNumberREAD", "totalSizeREAD", "totalSizeread", "TotalNumberRead", "totalNumberread", "TotalNumberREAD", "totalLengthLength", "totalLengthread", "TotalSizeRead", "totalNameread", "totalNameWritten", "totalNumberLength", "totalSizeWritten", "totalSizeReader"], "totalNumberRead": [" totalNumbersLength", "TotalNumberWritten", " totalNumberLength", "totalSizeLength", "totalNumbersLength", "TotalNumbersWritten", "totalStringREAD", " totalNumbersWritten", "totalCounterread", " totalNumberFound", "totalNumberFound", "totalNumbersRead", "totalNumberWritten", "totalnumberFind", "totalNumbersREAD", "TotalNumberread", "totalStringLength", "totalNumbersread", "totalNumbersFind", "totalNumberFind", " totalNumberREAD", " totalNumberFind", " totalNumbersFound", " totalNumbersFind", "totalCounterWritten", "TotalNumbersREAD", "totalStringWritten", "totalnumberWritten", "totalNumbersFound", "totalnumberFound", "totalNumberREAD", "totalSizeREAD", "totalCounterREAD", "TotalNumberRead", "totalNumberread", "TotalNumberREAD", " totalNumbersREAD", "totalNumbersWritten", "totalSizeFind", "totalStringRead", "TotalNumbersread", "totalSizeFound", "totalnumberRead", " totalNumbersRead", " totalNumberWritten", "TotalNumbersRead", "totalNumberLength", "totalCounterRead", "totalSizeWritten"], "photo": ["p", "info", "large", " video", "trip", "phone", " Photo", " bio", "mop", "document", "upload", "Flickr", "news", "pool", "jpg", "ickr", "member", " photograph", " microphone", " photographer", "facebook", "person", "prototype", "camera", "lo", " PHOTO", "jj", " portrait", "row", "gif", " photograp", " photos", "song", "pixel", "room", "vision", "job", "mm", "json", " avatar", "profile", "record", "behavior", "video", "photos", "post", "api", "policy", " geo", "primary", "pair", "handle", " attachment", "picture", "go", "parent", "image", " patient", "settings", "album", "copy", "son", "entry", "phot", " logo", "pg", "file", " photography", "Photo", "opus", "snap", "slot", "media", "application", "page", "instance", "op", "item", "jp", "to"], "url": ["mail", "Url", "link", "name", "raw", "char", "ul", "atl", "r", "sb", "mount", "location", "ssl", "resource", "build", "bel", "dl", "base", "uri", "github", "web", "http", "nl", "sl", "str", "ll", "google", "api", "address", "ref", "loc", "https", "l", "open", "get", "arl", "request", "URL", "ml", "ls", "ur"], "connection": ["established", "Connection", "link", "response", "online", "conn", "system", "created", "socket", "statement", "description", "connect", "database", "opening", "network", "session", "log", "ion", "resource", "io", "channel", "context", "information", "data", "application", "handler", "c", "uri", "communication", "web", "command", "sql", "console", "condition", "relation", "l", "client", "open", "con", "position", "to", "directory"], "dis": ["auto", "tem", "sle", "not", " Dis", "del", "mor", "is", "shell", "display", "def", "inner", "ex", "se", "lor", "de", "sys", "Dis", "ris", "sd", "DIS", "serv", "disc", "di", "ly", "dl", "det", "san", "nl", "bis", "du", "body", "mil", "sol", "ser", "no", "please", "lo", "rel", "des", "wise", "dist", "mis", "dd"], "fos": [" fof", " foes", "poes", "fioss", "fo", "wof", "mo", "mos", "foes", "woss", "hos", "fios", "pos", "eof", "eos", "hof", "poss", "wos", "fol", "hoss", "foss", "mof", "po", "fiol", "eoss", "woes", "moss", " fo", "eol", "hol", "wo", "fiof", " foss", "fof"], "b": ["bi", "erb", "p", "bs", "mb", "v", "bl", "B", "r", "a", "ab", "w", "sb", "nb", "buffer", "bin", "i", "h", "buf", "bb", "j", "bar", "bit", "f", "eb", "base", "m", "c", "bf", "gb", "blue", "br", "y", "t", "lib", "buff", "pb", "l", "db", "bound", "bt", "ob", "s", "rb", "z", "fb", "be", "n"], "sizeRead": ["SIZERead", " sizeWritten", "sampleRead", "SizeReader", "sizeLoad", "SIZEread", "sampleread", "SizeWrite", "sumLoad", "SizeLength", "SIZEReader", "sizeReader", "sizeread", "scaleWritten", "seeRead", " sizeLength", "nameRead", "scaleRead", "lengthLoad", "SIZELoad", "statusRead", "numberFind", "nameReader", "seeread", "seeREAD", "SIZELength", "sumRead", " sizeLoad", "sampleREAD", "lengthRead", " sizeFind", "sizeWritten", " sizeReader", "scaleReader", "statusLength", "statusReader", "sumREAD", "sizeFind", "sampleReader", " sizeWrite", "sizeREAD", "numberRead", "sumLength", "seeReader", "numberLoad", "statusWrite", "nameWritten", " sizeREAD", "SizeRead", "sizeLength", "SIZEREAD", "sizeWrite", "lengthFind"], "totalDiffTime": ["totalDeltaSize", "totalDifferentTime", "totalDeltatime", "totalChangetime", "totalDifferentSize", "totalDeltaTime", " totalDifftime", "totalDifferentInfo", " totalDiffInfo", "totalChangeSize", "totalDeltaInfo", " totalDiffSize", "totalDifftime", "totalChangeTime", "totalDiffInfo", "totalDiffSize"], "totalSpeed": [" successfulExperience", "privatePerformance", "totalWeight", " successfulSpeed", "TotalSpeed", "TotalWeight", "equalExperience", " successfulSlow", "privatespeed", "equalRate", "equalSpeed", "totalSlow", "totalRate", "totalPerformance", " totalRate", "equalSlow", "privateWeight", "completespeed", " successfulRate", "completeSpeed", "totalspeed", " totalExperience", "privateSpeed", " totalSlow", "completeWeight", "Totalspeed", "completePerformance", "totalExperience", "TotalPerformance"], "list": ["sequence", "ls", "array", "part", "pool", "v", "nt", "info", "stack", "detail", "all", "sort", "alist", "local", "data", "top", "listed", "queue", "batch", "dl", "cont", "lists", "coll", "left", "range", "set", "st", "collection", "ll", "chain", "out", "load", "history", "l", "table", "LIST", "null", "tree", "ml", "print", "pair", "ul"]}}
{"id1": "8046691", "id2": "3536332", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"retrieveFile": ["retrievedLink", "detrieveLink", "retractImage", "retrievedFile", "retireImage", "retrieveLocal", "retrieveLink", "detrievedImage", "retireLocal", "retireLink", "retractLink", "retractLocal", "retractFile", "retireFile", "detrieveLocal", "detrievedLink", "detrieveFile", "detrievedLocal", "detrievedFile", "detrieveImage", "retrievedLocal", "retrievedImage", "retrieveImage"], "url": ["remote", "Url", "name", "pl", "path", "image", "string", "char", "job", "run", "u", "file", "location", "ssl", "host", "resource", "build", "bel", "call", "id", "f", "m", "dl", "base", "abs", "uri", "web", "nl", "http", "el", "sl", "rl", "str", "ll", "address", "ref", "rect", "un", "l", "get", "arl", "row", "URL", "ml", "ls", "ur", "cp"], "link": ["task", "stream", "master", "info", "linked", "pack", "links", " check", "library", "set", "block", "list", "self", "sign", "index", "Link", "msg", " reload", "le", "path", " lock", "def", "message", "download", "detail", "error", " load", "type", "tag", "thread", " relay", "ink", "style", " jump", "mail", "remote", "light", "query", "ssl", "ld", "base", "install", "post", "load", "relation", "loop", "db", "share", "ls", "handle", "go", "key", "init", " LINK", "image", "system", "loader", "add", "entry", "lock", "label", "file", "log", "network", "build", "local", " block", "map", " delay", "ment", "let", "dl", "mark", "page", "status", "check", "lib", "rel", "l", "write", "open", "get", "line", "tool", "ml", "cp", "li"], "httpConn": ["appConn", " httpConnection", "httpCon", "httpsCon", "hoverCon", "socketConnect", "httpConnection", "ttpSyn", "HTTPCons", "httpCmd", "hoverCons", "httpsConn", "appConnect", "ttpCons", "appConnection", "ttpConn", "realconn", "realConnect", "ttpCt", "htmlConn", "httpsconn", "localconn", "ttpconn", "localConn", "localCon", "localConnection", "hoverConnection", "httpSyn", "ttpCmd", " httpCon", "hoverSyn", "internalCon", "HttpConnection", "hoverCt", "httpsCmd", "ttpConnect", "hoverConnect", "internalCt", "httpConnect", "hoverConn", "socketConn", " httpCons", "appconn", " httpCmd", "HttpConn", "htmlCt", "htmlConnect", "internalConn", "httpsCons", "ttpCon", "httpsConnect", "socketConnection", "HttpCon", "HTTPConn", "httpsConnection", " httpSyn", "realConn", "internalconn", "internalConnect", "ttpConnection", "socketconn", "httpCons", " httpconn", " httpCt", "internalConnection", " httpConnect", "httpCt", "HTTPCon", "htmlconn", "realCt", "HTTPConnect", "HttpConnect", "httpconn"], "outs": ["bits", " layouts", "offs", "obs", " ops", "ips", "als", "ts", "bs", "ports", "locks", "uts", "uploads", "ats", "sets", "ds", "ns", "aos", "gets", " out", "aps", "cos", " outputs", "gs", "ends", "orts", "ches", "uds", "nets", "yout", "aches", "dates", "fits", "cells", "lists", "its", "boxes", "ops", "tops", "ims", "ins", "ios", "out", "nos", "lets", "plays", "eps", "uns", "vals", "os", "s", "checks", "ows", "qs", "ks", "ls"], "bins": ["bkins", " binos", "blids", "linos", "binn", "blins", "blinn", " binn", "louts", " bids", "hin", "blkins", "bin", "wins", "lobs", "hins", "houts", "routs", "blinos", "win", "lins", "binos", "lin", "blouts", "blans", " bkins", "bobs", "wobs", "rkins", "linn", " bans", "wouts", "bans", "bids", "hobs", "rans", "lids", "rins"], "bouts": ["wbouts", "bbins", "bonds", "obins", "obyout", " bout", "baints", "bbouts", "wout", "Baints", "fbins", "fbbs", "waos", "Bouts", "waints", "wonds", "wins", "obouts", " baints", "wbonds", "wbout", "bbbs", "byout", "Baos", "wbaos", "fbouts", "bbs", "Bins", "bbyout", " baos", "baos", "wouts", "fbyout", " bonds", "obbs", "bout"], "postData": ["PostDATA", "Postdata", " postDATA", " postQuery", "postDat", "PostData", "POSTData", "POSTDat", "PostBody", "POSTdata", "postBody", "POSTBody", "postsData", "POSTDATA", " postDat", "POSTBytes", " postdata", "postDATA", " postBytes", "postsdata", "postsDATA", "formdata", "postdata", "formData", "formDat", "postsBytes", "PostQuery", "postQuery", "formDATA", "postBytes", " postBody", "PostBytes", "POSTQuery"], "mimePattern": ["metyTemplate", "smimepattern", " muxTemplate", "smetyPattern", "mimepattern", "muxpattern", "smimeFormat", "mIMEPattern", "mimesFormat", "smetypattern", "metyFormat", "mimeTemplate", "mIMEFormat", "metypattern", "mimesTemplate", "muxPattern", " muxPattern", " mimepattern", "mIMEpattern", "smimePattern", " mimeTemplate", "mimeFormat", " muxpattern", "metyPattern", "mimespattern", "mimesPattern", "muxTemplate", "smetyFormat"], "matcher": [" matter", "mature", "Match", "statcher", "Mather", "mather", "Matching", " mather", "matches", "Matmatch", "disches", "Matter", "stather", " mature", "Mature", "pather", " matmatch", "disure", "dismatch", "Matches", "patter", "discher", "patcher", "match", "matmatch", "matching", " match", "Matcher", "statter", "statching", " matches", "matter", "patch", " matching"], "byteBuffer": ["bbuffer", "noteBuff", "byteVar", "ByteFFER", " byteBuff", " byteVar", "charBuffer", " byteFFER", " byteBuilder", "noteVar", " bytebuffer", "ByteBuffer", "charBuilder", "letterMatrix", "wordbuffer", "bBuffer", "byteMatrix", "letterbuffer", "ByteBuff", "noteBuilder", "byteFFER", "wordBuffer", "charVar", " byteMatrix", " byteFrame", "noteBuffer", "byteBuilder", "wordMatrix", "bFFER", "letterBuffer", "charBuff", "byteFrame", "letterFrame", "Bytebuffer", "wordFrame", "byteBuff", "bytebuffer", "bBuff"], "count": ["cache", "counter", "len", "child", "amount", "ch", "cap", "first", "find", "char", "cc", "continue", "nt", "current", "add", "max", "acc", "last", "number", "all", "start", "buffer", "err", "read", "ount", "val", "call", "num", "result", "comment", "c", "batch", "force", "cont", "conf", "ctr", "sum", "check", "depth", "code", "loop", "length", "total", "iter", "Count", "core", "n", "more", "list", "size", "cycle", "found", "C", "index", "ind"]}}
{"id1": "14773780", "id2": "10674824", "code1": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    @Before\n    public void setUp() throws Exception {\n        final URL url = getClass().getClassLoader().getResource(\"insecureSSL.keystore\");\n        final KeyStore keystore = KeyStore.getInstance(\"jks\");\n        final char[] pwd = \"nopassword\".toCharArray();\n        keystore.load(url.openStream(), pwd);\n        final TrustManagerFactory trustManagerFactory = createTrustManagerFactory();\n        trustManagerFactory.init(keystore);\n        final TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n        final KeyManagerFactory keyManagerFactory = createKeyManagerFactory();\n        keyManagerFactory.init(keystore, pwd);\n        final KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();\n        final SSLContext serverSSLContext = SSLContext.getInstance(\"TLS\");\n        serverSSLContext.init(keyManagers, trustManagers, null);\n        localServer_ = new LocalTestServer(serverSSLContext);\n        localServer_.registerDefaultHandlers();\n        localServer_.start();\n    }\n", "label": 0, "substitutes": {"testImageInfo": [" testPhotoInfo", " testImagesData", "checkPhotoInfo", " testImagesFile", "checkPhotoList", " testPhotoData", "checkImageInfo", " testImageData", "checkImageFile", "checkPhotoFile", " testImagesList", "checkImageList", "checkImageData", " testImageFile", " testImageList", " testImagesInfo", "checkPhotoData", " testPhotoFile", " testPhotoList"], "IOException": [" IOEx", " IOProblem", "AudioException", "IOEx", "APIException", "AudioProblem", "APIProblem", "AudioEx", "APIEx", "IOProblem"], "start": ["offset", "init", "first", "it", "now", "begin", "before", " started", "birth", "starting", "art", "read", "parse", "id", "step", "base", "from", "time", "send", "wait", "enable", "set", "st", "check", "t", "create", "started", "seed", "wind", " Start", "open", "get", "end", "trans", "reset", "size", "Start", "print", "rest"], "i": ["ix", "name", "im", "bi", "go", "init", "key", "p", "is", "it", "x", "mi", "phi", "gi", "ui", "g", "ex", "si", "major", "info", "u", "b", "gu", "ti", "ci", "me", "multi", "j", "di", "conv", "id", "xi", "f", "m", "batch", "iq", "q", "uu", "y", "ic", "in", "qi", "out", "us", "o", "ai", "I", "s", "to", "n", "my", "pi", "yi", "sim", "index", "ind", "li"], "url": ["mail", "Url", "link", "external", "path", "key", "string", "pattern", "xml", "ul", "r", "u", "mount", "location", "log", "gl", "resource", "host", "id", "dl", "base", "uri", "res", "web", "http", "q", "nl", "el", "str", "ll", "ref", "rel", "l", "null", "lr", "URL", "gif", "ls", "ur"], "istream": ["ositream", "ositiver", "istorage", "istroy", "istable", "ISTstream", "itream", "iptream", "ositrace", "iptorage", "istrace", "iptstream", "itable", "istiver", "intable", "intream", "iststream", "astorage", "astroy", "iptroy", "ISTream", "ISTorage", "aststream", "ISTroy", "astream", "ositable", "itrace", "intiver", "itiver", "intrace"], "ii": ["ni", "nai", "cgi", "ri", "mi", "chi", "gi", "ji", "si", "ini", "hi", "ami", "iu", "irm", "cli", "ista", "iso", "imi", "sci", "cci", "ti", "ci", "zi", "di", "oci", "iov", "xi", "fi", "obi", "iii", "iy", "II", "ei", "qi", "ij", "ki", "iri", "jj", "ai", "vi", "ice", "yi", "pi", "iti", "ati", "ia", "ushi", "li"], "width": ["wy", "len", "path", "wa", "shape", "x", "const", "wn", "dim", "Width", "foo", "w", "dx", "idth", "value", "min", "layout", "data", "fw", "step", "cut", "left", "scale", "body", "draw", "frame", "crop", "text", "widget", "weight", "tall", "write", "length", "wid", "position", "px", "cale", "size", "window", "area", "format"], "height": ["hang", "volume", "radius", "amount", "chip", "gravity", "shape", "stroke", "def", "capacity", "acity", "above", "cue", "grow", "div", "buffer", "rank", "resolution", "h", "padding", "kw", "density", "frame", "depth", "green", "alpha", "history", "angle", "length", "family", "dimension", "rise", "Height", "size", "window", "sky", "style"], "stop": ["delete", "Stop", "obj", "counter", "est", "shape", "jump", "termination", "it", " Stop", "delay", "wake", "peak", "disable", "success", "gc", "quit", "fin", "close", "next", "trip", "hop", "id", "result", "step", "pop", "wait", "enable", "pause", "ops", "set", "st", "no", "loop", "duration", "term", "null", "end", "skip", "period", " STOP", "rest"]}}
{"id1": "21821404", "id2": "10212189", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 1, "substitutes": {"getWebPage": ["getLivepage", "getwebpage", "getDebugPages", "getLivePage", "downloadwebUrl", "downloadWebPage", "getwebPage", "getwebPages", "downloadwebPages", "getWebUrl", "getDebugpage", "getDebugPage", "downloadwebPage", "downloadwebpage", "downloadWebUrl", "getwebUrl", "getLivePages", "downloadWebpage", "downloadWebPages", "getWebPages", "getDebugUrl", "getLiveUrl", "getWebpage"], "urlObj": ["urlobj", "urlOb", "UrlCtrl", " urlCtrl", "logInfo", "uriCtrl", "urlInfo", "logOb", "UrlOnce", "uriObj", "httpObj", "urlOnce", " urlOnce", "httpInfo", "urlInd", "UrlObj", " urlInfo", "Urlobj", " urlOb", "uriObject", "uriOnce", " urlInd", "uriobj", "urlObject", "UrlInd", " urlobj", "logObj", "httpObject", "UrlObject", " urlObject", "httpOb", "uriInd", "urlCtrl", "logObject"], "content": ["sequence", "response", "view", "html", "equ", "header", "string", "clean", "continue", "display", "message", "current", "title", "wrapper", "article", "temp", "value", "source", "buffer", "comments", "layout", "context", "reason", "read", "data", "template", "ext", "result", "complete", "comment", "txt", "cont", "Content", "articles", "page", "command", "body", "object", "str", "text", "code", "address", "load", "cm", "write", "output", "section", "core", "ce", "empty", "document", "ontent", "raw", "format"], "is": ["tis", "not", "are", "and", "iso", "Is", "when", "res", "web", "ot", "in", "ios", "isl", "rys", "isc", "ist", "has", "as", "name", "other", "rs", "e", "sis", "es", "\u00eds", "its", "ais", "iris", "by", "sels", "os", "net", "ese", "ire", "where", "ri", "ois", "isin", "a", "se", "job", "internet", "isa", "ir", "err", "ris", "id", "c", "fs", "or", "ms", "chain", "out", "was", "ians", "were", "mis", "re", "more", "be", "nis", "does", "string", "iss", "sys", "isf", "i", "sit", "his", "IS", "bis", "being", "ists", "ism", "plays", "s", "isi", "lis"], "reader": ["iterator", "iper", "ri", "liner", "writer", "per", "reading", "inner", "stream", "ocker", "loader", "r", "rr", "file", "ipper", "buffer", "read", "parser", "io", "rar", "dra", "roller", "handler", "anger", "ner", "in", "ser", "Reader", "er", "ader", "ro", "editor", "iter", "row", "runner", "dr"], "line": ["lane", "sequence", "link", "online", "liner", "ln", "le", "string", "stroke", "ine", "part", "char", "message", "sample", "lined", "entry", "e", "detail", "label", "Line", "file", "point", "email", "LINE", "record", "eline", "comment", "lin", "nl", "el", "page", "cell", "frame", "range", "piece", "text", "zone", "lo", "l", "section", "word", "block", "row", "inline", "print", "column"]}}
{"id1": "8132219", "id2": "7499186", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" Copyfile", " copyStream", " CopyFiles", "CopyFile", "copyStream", "CopyStream", "CopyFiles", " CopyFile", " CopyStream", "copyFiles", "Copyfile", " copyFiles", " copyfile", "copyfile"], "inFile": [" inPath", "innEmail", "outFilename", "inEmail", "ninName", "ninFilename", "dinFile", " inRow", "dinRow", "inputTemplate", "inName", "innPath", "inFilename", "inputName", "inTemplate", "inputFilename", "dinPath", "ninTemplate", " inEmail", "inPath", "outName", "outTemplate", "innRow", "inputFile", "inRow", "dinEmail", "innFile", "ninFile"], "outFile": ["ouFILE", " outFILE", "outFilename", "outFormat", "outputFile", "outfile", "outputfile", "inFilename", "outputFilename", "outputFormat", "destFormat", "ouFile", "destfile", "destFILE", " outFormat", "destFile", "ouFilename", "inTable", "outputTable", "outTable", "outFILE", " outfile", "inFILE", "outputFILE", "ouTable"], "in": ["inn", "inc", "up", "init", "is", "it", "ain", "sin", "inner", "isin", "old", "ini", "din", "info", "irm", "source", "ze", "ir", "bin", "i", "gin", "on", "id", "from", "In", "el", "ic", "ins", " input", "en", "IN", "o", "ai", "s", " din", "cin", "rin", "input", "inf", "ind"], "out": ["name", "p", "it", "Out", "g", "ex", "v", "w", "aos", "e", "file", "b", "all", "io", "one", "gt", "c", "res", "ot", "t", "en", "at", "o", "ne", "by", "output", "client", "os", "to", "co", "outs", "OUT", "net", "can", "n", "ou"], "inChannel": ["isinSlot", "innerChannel", "insideHandler", "isinCategory", "newPanel", "outStream", " inConnection", "innerchannel", "cinHandler", "cinComponent", "cinButton", "sinStream", "ginCategory", "innCase", "inBlock", "newCase", "innCategory", "inColumn", "insideComponent", "insideChannel", "vinChannel", "newChannel", "sinBlock", "outBlock", "vinPanel", "ginChannel", "vinCase", "isinCase", "innerChan", "insideButton", "innerConnection", "inSlot", "outchannel", "inStream", "outChan", "inCase", "sinSlot", "isinChannel", "inchannel", "sinCase", " inComponent", "inCategory", "cinChannel", "inConnection", " inHandler", "sinColumn", "innSlot", "outColumn", "sinChannel", "ginPanel", "innChannel", "cinStream", "vinCategory", " inChan", "inComponent", "outConnection", " inButton", "newCategory", "inHandler", "inPanel", "ginCase", "sinCategory", "inChan", "inButton", " inchannel", "cinBlock", "cinColumn"], "outChannel": ["inPassword", " outChan", "outCh", "oClient", "outStream", "oChannel", "OutChan", "OutChannel", "outClient", " outCh", " outClient", " outConnection", "exBlock", "outputChan", "outputCh", "oChan", "outBlock", "nStream", "inClient", "outPassword", "outputChannel", "outchannel", " outchannel", "outChan", "inStream", "OutCh", "inchannel", "outputConnection", "exChan", "outChain", "exChain", "nchannel", "OutConnection", "outConnection", "nChan", "oPassword", "exChannel", " outStream", "inChan", "nChannel", " outChain", " outPassword", " outBlock"]}}
{"id1": "19113613", "id2": "536614", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copy": ["delete", "link", "zip", "php", "ip", "init", "cross", "opy", "same", "replace", "download", "py", "Cop", "gc", "cos", "cop", "transfer", "map", "sync", "save", "clip", "crop", "slice", "move", "create", "clone", "write", "split", "share", "paste", "proxy", "to", "core", "Copy", "co", "cat", "pixel", "cp"], "in": ["inn", "inc", "up", "init", "is", "it", "mi", "act", "inv", "sin", "inner", "isin", "old", "ini", "info", "din", "all", "bin", "i", "ir", "gin", "local", "on", "id", "from", "In", "el", "y", "ic", "check", "ins", "inside", "en", "IN", "o", "by", "l", "iter", "con", "ai", "input", "rin", "cin", "ie", "re", "net", "ar", "inf", "ind"], "out": ["port", "cache", "obj", "not", "conn", "ch", "p", "it", "ver", "Out", "this", "inner", "v", "ex", "nt", "w", "aos", "outer", "ent", "all", "b", "log", "err", "ion", "sys", "io", "tmp", "local", "one", "gt", "on", "result", "base", "res", "ot", "y", "store", "set", "op", "t", "en", "at", "o", "OU", "l", "write", "output", "client", "con", "null", "os", "to", "end", "oss", "co", "over", "outs", "OUT", "net", "can", "n", "ou"], "source": ["Source", "attribute", "scan", "sequence", "cause", "unit", "origin", "parent", "key", "system", "select", "string", "shell", "sin", "inner", "this", "ource", "src", "scope", "si", "subject", "se", "title", "query", "start", "resource", "local", "template", "base", "space", "search", "from", "site", "status", "sql", "store", "prefix", "service", "range", "finder", "language", "relation", "position", "s", "input", "ie", "ce", "sp", "SOURCE", "style", "index", "use", "lower", "format"], "target": ["link", "url", "origin", "parent", "key", "other", "pattern", "dest", "scope", "arg", "bolt", "Target", "query", "point", "goal", "alias", "location", "ARGET", "resource", "join", "arget", "local", "match", "template", "that", "gt", "translation", "top", "root", "step", "base", "t", "test", "rel", "module", "table", "output", "tif", "term", "null", "to", "tree", "token", "print", "style"], "files": ["resources", "assets", "ports", "banks", "lines", "uploads", "pages", "members", "features", "users", "values", "reports", "thumbnails", "facts", "faces", "issues", "fs", "services", "pieces", "workers", "actions", "states", "packages", "modules", "jobs", "models", "tools", "details", "parts", "objects", "iles", "balls", "lets", "books", "items", "styles", "events", "plates", "les", "headers", "images", "ls"], "file": ["ile", "fp", "name", "port", "child", "le", "key", "path", "File", "image", "model", "full", "parent", "tile", "current", "job", "entry", "foo", "e", "label", "node", "event", "folder", "filename", "ve", "resource", "local", "data", "FILE", "user", "library", "f", "base", "el", "page", "feature", "play", "item", "rule", "relation", "work", "table", "line", "dir", "fe", "block", "word", "tree", "row", "field", "print", "document", "be", "pe"], "inCh": ["cinch", "outCod", "incCr", "dinCr", "rinCod", "incSam", "cinSam", " inCl", "inch", "inCr", "cinCor", "rinCh", "InCh", "InCod", "inCl", " inCod", "cinCh", "outChan", "dinCor", "rinChan", "dinCh", "inCor", " inChan", "incCor", "cinCod", "incCh", "dinSam", " inch", "cinChan", "InChan", "InCl", "inSam", "rinCl", "inCod", "inChan", "outch", "cinCr"], "outCh": ["newGr", " outChan", "newCol", "inch", "outCol", "newch", " outCol", "outputChan", "outputCh", "inCol", "outputCod", "newCod", "outChan", "newChan", "outGr", "outputGr", "newCh", " outch", " outCod", "inChan", "outch", " outGr", "outCod"]}}
{"id1": "15797402", "id2": "17627195", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public Document getContentAsDocument() {\n        synchronized (this.url) {\n            URLConnection connection = this.url.openConnection();\n            if (doReload(connection)) {\n                InputSource inputSource = new InputSource(connection.getInputStream());\n                DocumentBuilderFactory factory = new DocumentBuilderFactoryImpl();\n                this.document = factory.newDocumentBuilder().parse(inputSource);\n            }\n            return this.document;\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["execute", "php", "shape", "p", "apply", "xml", "process", "se", "add", "resource", "read", "parser", "build", "close", "map", "interpret", "dump", "save", "ping", "scale", "tag", "slice", "create", "load", "write", "split", "render", "transform", "print", "filter", "patch", "pe", "use", "handle", "format"], "stream": ["zip", "iterator", "sequence", "url", "response", "image", "clean", "message", "sample", "content", "stack", "download", "file", "event", "source", "buffer", "resource", "read", "channel", "archive", "data", "sync", "cont", "Stream", "http", "form", "instance", "console", "in", "chain", "test", "length", "output", "open", "ream", "input", "document", "reader", "window", "handle", "upload"], "handler": ["server", "shape", "writer", "pool", "hander", "loader", "message", "management", "event", "controller", "h", "resource", "parser", "function", "host", "processor", "password", "application", "storage", "worker", "hand", "service", "address", "Handler", "ctx", "policy", "connection", "callback", "reader", "wrapper", "handle"], "metadata": ["iterator", "adata", "header", "image", "still", "mt", "xml", "MD", "message", "memory", "info", "content", "unknown", "management", "detail", "json", "managed", "config", "property", "manager", "data", "template", "basic", "m", "general", "meta", "tar", "java", "details", "md", "parts", "mem", "google", "dirty", "definition", "module", "ctx", "hold", "policy", "common", "met", "dd", "td", "document", "pdf", "material", "handle", "properties"], "context": ["sequence", "response", "system", "cc", "usage", "current", "content", "stack", "event", "config", "location", "network", "resource", "reason", "local", "template", "translation", "command", "instance", "frame", "set", "collection", "environment", "chain", "condition", "Context", "component", "ctx", "module", "sc", "null", "connection", "dict", "options", "ce", "document", "state"], "name": ["url", "len", "path", "key", "NAME", "image", "nm", "system", "string", "version", "part", "none", "description", "old", "current", "title", "value", "label", "file", "source", "named", "all", "filename", "alias", "resource", "reason", "channel", "local", "data", "default", "on", "id", "comment", "base", "type", "time", "nl", "body", "prefix", "service", "Name", "create", "no", "l", "common", "client", "ame", "term", "family", "null", "size", "pass", "names", "n", "lower"], "out": ["auto", "url", "obj", "up", "external", "writer", "it", "Out", "v", "ex", "aos", "outer", "flush", "cmd", "file", "all", "sys", "cos", "io", "serv", "one", "conv", "user", "gen", "ou", "po", "res", "sum", "conf", "in", "lay", "us", "o", "OU", "table", "output", "con", "null", "to", "oss", "co", "list", "outs", "OUT", "net", "print", "n", "col", "cn"]}}
{"id1": "5148212", "id2": "4750967", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"copyFile": ["clonefile", "copyImage", " copyImage", "copFile", "copImage", "cloneFile", "copfile", "copyfile", " copyfile", "cloneImage"], "src": ["Source", "url", "sec", "inc", "obj", "path", "init", "inst", "sq", "attr", "rs", "ource", "sr", "syn", "file", "source", "ost", "lit", "start", "sys", "filename", "sit", "ipl", "txt", "usc", "from", "st", "img", "ins", "cur", "str", "sur", "urg", "sf", "ser", "loc", "usr", "rel", "pkg", "sc", "iter", "req", "rc", "input", "ie", "ident", "ls", "ur", "rest", "iv"], "dest": ["port", "obj", "origin", "ord", "vol", "master", "v", "min", "dat", "data", "coord", "cont", "st", "img", "spec", "iter", "req", "end", "dist", "comp", "est", "path", "nw", "deg", "source", "opt", "comb", "result", "sup", "foreign", "usr", "d", "ident", "orig", "nom", "tr", "Dest", "this", "target", "lit", "de", "etc", "prop", "gt", "way", "good", "test", "des", "doc", "output", "null", "fe", "fr", "trans", "tom", "sp", "cat", "desc", "them", "rest", "delete", "parent", "gov", "temp", "file", "sit", "crit", "loc", "tif", "nd", "dir", "to", "decl", "mk"], "bufSize": [" bufsize", " bufInfo", "bufInfo", "BufferSize", "fontSize", "fontInfo", "queueCount", "fontSIZE", "bufferLength", " bufSIZE", "bufLength", "queueLen", "bufferLen", "boxSIZE", "ufInfo", "fontsize", "ufsize", "BufferCount", "buffersize", "bufCount", "boxsize", "bufferSize", "BufferLen", "queueSize", "bufferCount", "bufSIZE", "bufferSIZE", "bufsize", "ufSIZE", "boxSize", "queueLength", "BufferLength", "ufSize", "bufLen"], "force": ["remote", "cp", "auto", "ace", "yes", "external", " confirm", "apply", "ignore", "replace", "fail", "forge", "flush", "vert", "e", "flag", "cmd", "allow", "ghost", "raise", "like", "start", "update", "func", "fx", "reason", "secure", "append", "default", "error", "sync", "only", "send", "enable", " enforce", "forced", "form", "quote", "frame", "rule", "fast", "dirty", "seed", "always", "write", "open", " override", "Force", "forcing", "require", "ce", "print", "pdf", "use", "handle"], "f": ["fp", "rf", "xf", "exp", "ef", "p", "part", "fm", "g", "v", "fo", "r", "F", "w", "e", "file", "b", "h", "uf", "fc", "m", "c", "fs", "fi", "elf", "conf", "bf", "lf", "t", "sf", "of", "d", "cf", "l", "inf", "dir", "s", "fac", "fr", "ct", "df"], "buffer": ["attribute", "sequence", "cache", "shape", "stroke", "char", "message", "memory", "sample", "stack", "database", "temp", "number", "variable", "buf", "Buffer", "parse", "append", "template", "bar", "library", "password", "result", "queue", "batch", "base", "command", "frame", "text", "buff", "binary", "history", "phrase", "write", "table", "paste", "length", "word", "iter", "line", "block", "row", "print", "document", "filter", "window", "index"], "read": ["im", "READ", "len", "ip", "key", "shape", "raw", "it", "find", "height", "bind", "select", "char", "reading", "stream", "before", "add", "info", "reads", " Read", "w", "run", "gets", "allow", "feed", "hello", "like", "query", "start", "log", "i", "parse", "give", "take", "record", "time", "send", "q", "valid", "reader", "check", "str", "range", "t", "en", "mem", "load", "write", "length", "open", "get", "ke", "iter", "word", "count", "end", "seek", "skip", "input", "readable", "need", "size", "print", "pe", "index", "fill", "ind", "Read"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "image", "mi", "it", "is", "ain", "per", "inner", "isin", "ex", "ini", "din", "mm", "irm", "source", "bin", "i", "ir", "io", "gin", "local", "internal", "on", "m", "from", "In", "or", "ic", "inside", "ins", "en", "IN", "by", "l", "client", "get", "con", "ma", "iter", "to", "cin", "rin", "input", "ie", "net", "ar", "inf", "oin", "ind"], "out": ["obj", "cache", "up", "not", "conn", "parent", "ln", "writer", "full", "it", "Out", "inner", "v", "ex", "nt", "aos", "oe", "outer", "flush", "file", "b", "sys", "bin", "ion", "cos", "io", "one", "conv", "user", "on", "ou", "ot", "or", "t", "at", "o", "ne", "OU", "write", "output", "client", "con", "os", "to", "oss", "end", "co", "list", "outs", "OUT", "net", "print", "note", "can", "n", "cn"]}}
{"id1": "14820302", "id2": "6260216", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public InputStream send(String s, String s1) throws IOException {\n        HttpURLConnection httpurlconnection = null;\n        DataInputStream datainputstream = null;\n        System.setProperty(\"java.protocol.handler.pkgs\", \"com.sun.net.ssl.internal.www.protocol\");\n        URL url = new URL(s1);\n        httpurlconnection = (HttpURLConnection) url.openConnection();\n        configureURLConnection(httpurlconnection);\n        DataOutputStream dataoutputstream = new DataOutputStream(httpurlconnection.getOutputStream());\n        dataoutputstream.write(s.getBytes());\n        httpurlconnection.connect();\n        datainputstream = new DataInputStream(httpurlconnection.getInputStream());\n        if (httpurlconnection.getResponseCode() != 200) {\n            System.out.println(\"Invalid Response Code! Code Returned = \" + Integer.toString(httpurlconnection.getResponseCode()));\n            return null;\n        }\n        if (!httpurlconnection.getContentType().equalsIgnoreCase(\"Text/xml\")) {\n            System.out.println(\"Invalid Content-Type! Content type of response received = \" + httpurlconnection.getContentType());\n            return null;\n        } else {\n            return datainputstream;\n        }\n    }\n", "label": 0, "substitutes": {"innerProcess": [" doRun", " innerHandle", "internalHandle", " inlineRun", "internalWork", " inlineHandle", " innerRun", "internalRun", " doHandle", " doWork", " doProcess", "internalProcess", " inlineWork", " innerWork", " inlineProcess"], "curi": ["cURI", "cpuri", "rcui", "curl", "cpu", "gcuri", "vcuri", "CURI", " cri", "cri", "lcuri", "ccumi", "cdu", "Curl", "ctURI", "gcui", " cdu", "pcdu", "gcdu", "cturi", "ctiti", "ciri", "pcumi", "Cri", "lcURI", " cris", "gcumi", " ciri", "rcdu", "ccris", " cumi", " cURI", " cui", "ccuri", "contpu", "conturi", "lciri", " curl", "cris", "cui", "mcURI", "cpiri", "lcri", "cpurl", "rcuri", " cpu", "mcri", "citi", "cpri", "Ciri", "contumi", "mciti", "vcris", "ctri", "Curi", " citi", "vcui", "pcpu", "rcumi", "ccui", "cumi", "contdu", "pcuri", "mcuri", "vcumi"], "regexpr": ["Regexfr", "reacepr", "regexPR", "rentaxPR", "reroxfr", "regexexpr", "fregexPR", "regexp", "rentaxexpr", "remapr", "revreexpr", "frentaxPR", "fregexpr", "cregexexpr", "Regexpr", "fregexexpr", "reroxpr", "remaPR", "remapre", "frentaxpre", "reactpr", "rentaxpre", "reactexpr", "remaexpr", "rentaxpr", "Regexp", "cregexPr", "regexpre", "reveloppr", "reveloppre", "cregexp", "revelopexpr", "reaceexpr", "reactp", "regexfr", "revelopPR", "frentaxpr", "fregexpre", "cregexpr", "revrePr", "reroxexpr", "reacePr", "reactfr", "reroxp", "regexPr", "Regexexpr", "revrep", "frentaxexpr", "reacep", "revrepr"], "cs": ["pc", "ces", "cons", "cas", "ws", "css", "ts", "bs", "cms", "cc", "rs", "cd", "cks", "ps", "ats", "tc", "CS", "ns", "Cs", "ck", "gc", "cos", "gs", "acts", "caps", "ss", "aches", "cer", "fc", "c", "fs", "sts", "res", "ctr", "nc", "wcs", "acs", "ms", "vs", "csv", "cf", "ctx", "sc", "cus", "rc", "js", "ics", "qs", "hs", "ks", "mc", "ls", "cp", "cn"], "digest": ["displayse", "Digest", "signist", " digum", " digist", "hashester", "diger", "dest", " digested", "Digester", "signest", "der", " diger", "hashse", "displayested", "mixest", "displayer", "mixse", "hashest", "columnum", "columnist", "digse", "signse", "Digist", "mixist", "Digum", "displayEST", "displayest", " digse", "dse", "displayester", "digum", "mixested", "digested", "Digse", " digester", "columnest", " digEST", "digEST", "Diger", "hashEST", "DigEST", "digester", "dist", "digist", "Digested", "signested"], "s": ["ws", "p", "is", "ts", "sq", "bs", "bytes", "rs", "ps", "ats", "reads", "ds", "ns", "gets", "sb", "e", "b", "S", "gs", "h", "ss", "es", "less", "sam", "c", "sv", "sts", "services", "fs", "space", "abs", "its", "sql", "ims", "ms", "ins", "t", "str", "sol", "https", "eps", "js", "qs", "hs", "ls", "prints", "has", "n"], "m": ["sm", "M", "p", "nm", "v", "dm", "mo", "mm", " M", "mac", "managed", "perm", "b", "gm", "i", "me", "om", "esm", "f", "mu", "rm", "md", "ms", "mem", "t", "d", "cm", "l", "met", "mr", "ma", "em", "tm", "vm", "mc", "mt", "n"], "newDigestValue": ["newDigistValue", "newDigumentValue", "newdigestedVal", "newDigestedValues", "newdigestedValue", "newDigseValues", "newdigestVal", "newDigumentV", "newdigistValue", "newdigestValue", "newDigestedData", "newDigestedVal", "newDigistData", "newDigestValues", "newDigumentValues", "newdigestValues", "newDigestV", "newDigestedV", "newdigestedValues", "newDigestedValue", "newDigseV", "newDigseValue", "newdigestV", "newDigestVal", "newDigseData", "newDigumentVal", "newDigistVal", "newdigestData", "newdigestedV", "newdigistData", "newDigseVal", "newdigistVal", "newDigestData"]}}
{"id1": "6371607", "id2": "8062076", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "label": 1, "substitutes": {"removeRealm": ["removeSchems", "removeRealarm", "remrealarm", "remrealms", "removeScheM", "remRealM", "remrealm", "remRealmo", "removePerM", "removePermo", "removeRealmo", "removeAlmo", "removeSchem", "removerealms", "removerealarm", "removeAlarm", "removerealM", "removeRealms", "removeSchemo", "removePerarm", "remrealM", "remRealms", "remRealarm", "removeAlm", "removePerms", "removerealm", "removePerm", "removerealmo", "removeAlms", "remrealmo", "removeRealM", "remRealm"], "realmIds": ["realmIdParts", "realmIdList", "realmidss", "realmsByIds", "realmsIdids", "realmIDls", "realmsIdList", "realmByIdids", "realmsByIdParts", "realmIDNames", "realmIdls", "realmIdNames", "realmPaths", "realmidsls", "realmIDList", "realmsByIdids", "realmByIds", "realmsIdParts", "realmidsParts", "realmsIdNames", "realmidsNames", "realmsByIdls", "realmsByIdList", "realmsIds", "realmPathls", "realmidsids", "realmByIdNames", "realmByIdls", "realmIdids", "realmPathids", "realmIDs", "realmsByIdNames", "realmsIdls", "realmPathParts", "realmByIdList", "realmByIdParts", "realmidsList"], "psImpl": ["PSimpl", "PSImpl", "ppsImpl", "epsImpl", " psimpl", "epsimpl", "pseStack", "PSExpl", " psInstance", "psExpl", "psInstance", " psEl", "epsObj", "ppsExpl", "ppsInstance", " psObj", " psExpl", "pseImpl", "psimpl", "pseInstance", "psObj", "PSObj", "ppsStack", "pseEl", "PSEl", "ppsEl", "psStack", "epsExpl", "ppsimpl", " psStack", "psEl"], "iter": ["iterator", "ter", "former", "li", "ip", "lim", "it", "ver", "per", "older", "inv", "iller", "ator", "ider", "ait", "iz", "outer", "ipper", "nr", "walker", "vers", "i", "ir", "ger", "iner", "ori", "inter", "her", "ptr", "cer", "gen", " iterator", "gener", "coll", "valid", "ner", "its", "ser", "fer", "er", "loc", "loop", "vis", "upper", "liter", "Iter", " iv", "hex", "oper", "ev", "ind", "iv"], "realmId": ["realvInd", "balgmId", "RealmPath", "realgById", "trvInd", "realvmId", "realgmIs", "realgmid", "RealmRef", "realMById", "realomInd", "realgPath", "realMRef", "realnId", "palmID", "realvReference", "palmInt", "trvId", "trmReference", "realmIs", "realmid", "realgmId", "reallemInt", "trmID", "pallemid", "realnRef", "realMId", "realvID", "realomID", "realmRef", "pallemID", "palmId", "realMPath", "realmID", "realmeId", "RealmId", "trvID", "realmInd", "realvmid", "reallemID", "realmById", "realvId", "RealMPath", "balgmid", "pallemId", "reallemId", "realmiIs", "realmanReference", "realgRef", "trvReference", "realvmID", "realmanInd", "balmid", "realmiid", "RealMById", "realmeID", "balmId", "balgmIs", "RealmById", "pallemInt", "realomId", "RealMId", "balmID", "balmIs", "realmeInt", "realnById", "realgmID", "palmid", "realmiInt", "balgmID", "realmiId", "realmPath", "realmanID", "realnPath", "trmId", "realmiID", "trmInd", "RealMRef", "realgId", "realmInt", "reallemid", "realmReference", "realomReference", "realmeid", "realmanId", "realvmIs"]}}
{"id1": "11562173", "id2": "2199604", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkAudioChannel", "checkAudioStream", "checkContentFile", "assertInputstream", "checkContentChannel", "checkContentStream", "checkAudioFile", "checkInputstream", "checkOutputChannel", "assertOutputFile", "assertInputStream", "checkOutputFile", "checkInputFile", "checkOutputStream", "assertInputFile", "checkOutputstream", "checkContentstream", "assertOutputStream", "assertInputChannel", "checkAudiostream", "assertOutputChannel", "checkInputChannel", "assertOutputstream"], "in": ["inn", "al", "inc", "up", "raw", "is", "it", "inner", "ex", "old", "din", "mm", "file", "source", "b", "io", "gin", "on", "c", "from", "cont", "In", "or", "st", "ins", "en", "IN", "o", "doc", "l", "get", "con", "s", "input", "cin", "mc", "n", "ind"], "cmp": ["msg", "cs", "comp", "ch", "Comp", "cv", "pres", "resp", "different", "equal", "comm", "cb", "cc", "same", "cd", "eq", "tc", "cmd", "ck", "vp", "par", "qual", "tmp", "match", "conv", "result", "c", "coll", "cond", "mp", "com", "good", "ctrl", "cu", "rel", "csv", "pkg", "ctx", "dict", "co", "compl", "cod", "omp", "diff", "mc", "desc", "cp", "cn"], "all": ["attribute", "al", "active", "alph", "All", "none", "oll", "any", "full", "each", "first", "equal", "both", "and", "bl", "a", "ssl", "default", "ALL", "also", "call", "m", "only", "valid", "alpha", "ll", "test", "always", "l", "app", "total", "null", "other", "list", "empty", "kill", " ALL"], "stream": ["port", "zip", "view", "parent", "shape", "system", "our", "socket", "clean", "each", "Steam", "pipe", "se", "sample", "stack", "REAM", "mount", "event", "ost", "sudo", "network", "buffer", "host", "tmp", "channel", "local", "context", "sw", "sync", "time", "engine", "Stream", "form", "store", "draw", "console", "service", "st", "collection", "output", "ST", "row", "input", "screen", "ream", "dd", "sign", "window", "upload"], "out": ["obj", "up", "external", "not", "exp", "array", "p", "raw", "it", "clean", "Out", "v", "ex", "aos", "outer", "ent", "b", "sys", "log", "io", "tmp", "serv", "data", "conv", "batch", "res", "ot", "good", "check", "help", "str", "t", "at", "o", "ne", "pkg", "des", "output", "con", "to", "list", "outs", "OUT", "net", "n", "cn"], "i": ["ix", "bi", "ri", "init", "key", "span", "is", "mi", "x", "it", "phi", "gi", "ui", "ji", "si", "v", "hi", "ini", "info", "u", "iu", "cli", "\u0438", "json", "perm", "point", "gu", "ti", "ci", "me", "zi", "multi", "j", "di", "id", "xi", "m", "batch", "uri", "ii", "q", "y", "ic", "ei", "ims", "ms", "qi", "ij", "chain", "us", "ki", "client", "iter", "ai", "I", "n", "vi", "sym", "z", "pi", "sim", "index", "ind", "li"]}}
{"id1": "15409512", "id2": "11377441", "code1": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"inFileName": ["infilePath", " inFileSource", "inFILEName", "inFILEFace", " infileFace", "inFilenameNames", "inFilePath", "inFileSize", "intModelNames", "inFILESource", "inFileSource", "intModelName", "inModelName", " inFileSize", "inFilenamePath", "intFilename", "inPagename", "inFilenameFace", "inStreamPath", "intModelname", "infilename", " infileNames", "inFilename", "inFILEPath", "inFileFace", " inFileFace", "intFileSource", "inStreamName", "inFilenameSize", "inFileNames", " inFilePath", " infilePath", " inFileNames", "inStreamSize", "infileFace", "infileName", " infileSource", "inPageSource", "inModelNames", "inModelname", "infileSource", " infileName", "intFileName", "inFilenameName", "inPageName", "inModelSource", "intModelSource", "inFilenameSource", "infileNames", "inStreamNames", "intFileNames", " infileSize", "inPageNames", "infileSize"], "outFileName": ["outfileDir", "infileFile", "inFilenameNames", "inFilePath", "outTileFile", "outTileDef", "outPathDir", "inFileDef", "outFileFile", "inFilenamePath", "outTileName", "outFilenameFile", "outPathName", "outTileNames", " outFilenameNames", "outfileFile", "inFileFile", "outFILEName", " outFilenameName", "outfileName", "inFileNames", "outFilenameNames", "inFilenameDir", "outFilenamePath", "inFileDir", " outFilenameParent", "outFILEPath", "outfilePath", " outFileNames", "outFilenameParent", "outFILEParent", "infileDef", "infileName", "outFileDef", "outfileDef", "outPathPath", "outFILENames", "outFileDir", "inFilenameName", " outFilenamePath", "outfileParent", "outFilenameDir", "infileNames", "outFilenameDef", "outFileNames", "outFilePath", "outfileNames", " outFilePath", "outFileParent", "outPathNames", "outFilenameName", " outFileParent"], "position": ["port", "option", "character", "volume", "sequence", "offset", "portion", "journal", "amount", "initial", "p", "now", "osition", "present", "capacity", "order", "description", "usage", "pointer", "memory", "expression", "number", "value", "pos", "location", "point", "source", "ion", "layout", "slot", "limit", "buffer", "resolution", "Position", "minimum", "reference", "padding", "zero", "ment", "application", "see", "from", "type", "command", "direction", "address", "condition", "move", "relation", "no", "length", "total", "connection", "request", "block", "seek", "to", "start", "size", "operation", "POS", "document", "index"], "bis": ["fps", "bits", "bi", "cgi", "obs", "abin", "oi", "is", "bs", "isin", "bh", "irs", "ubs", "bil", "bat", "avi", "onis", "opus", "idis", "ints", "ris", "bb", "uds", "conv", "rison", "oris", "pins", "ads", "its", "ios", "ubis", "obos", "bes", "ais", "iris", "obb", "los", "phis", "dos", "lbs", "oss", "js", "bid", "BS", "bps", "ls", "nis", "lis", "rots"], "bos": ["tis", "bits", "bi", "obs", "ols", "ts", "bs", "ods", "tes", "bh", "ats", "boards", "aos", "asket", "ns", "ubs", "ths", "oops", "cos", "uds", "bys", "fits", "fs", "oids", "webkit", "pins", "ios", "aus", "bones", "ubis", "ippers", "nos", "bo", "bes", "los", "dos", "os", "eros", "jas", "oks", "oss", "ows", "BS", "ots", "rots", "oos"], "b": ["bg", "ch", "ib", "p", "bc", "bs", "back", "cb", "mb", "g", "v", "bh", "a", "B", "ab", "sb", "nb", "bin", "i", "h", "buf", "bb", "j", "bar", "bp", "bit", "f", "batch", "base", "eb", "m", "c", "q", "gb", "br", "body", "t", "d", "pb", "db", "l", "ob", "rb", "fb", "be"]}}
{"id1": "23370621", "id2": "21656668", "code1": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"downloadFile": [" downloadSingle", " downloadFiles", "downloadFiles", " downloadfile", "loadFile", "loadFiles", "downloadSingle", "loadfile", "DownloadFile", "DownloadFiles", "Downloadfile", "downloadfile", "loadSingle", "DownloadSingle"], "target": ["remote", "delete", "secondary", "path", "parent", "it", "ver", "pattern", " targ", "ret", "this", "dest", "touch", "v", "physical", "copy", "localhost", "bolt", "Target", "file", "tor", "source", "location", "filename", "buffer", "goal", "alias", "tmp", "arget", "local", "that", "template", "match", "gt", "root", "top", "default", "result", "fixed", "txt", "base", "type", "format", "tar", "set", "t", "out", "test", "rel", "table", "output", "tif", "dir", "null", "to", "tree", "tp"], "s3key": [" s2Key", "s2key", " s2url", "sdksecret", " s2secret", "s2url", "s3url", "s6secret", "s6key", "s3KEY", "s2secret", "s4KEY", "s6Key", " s3secret", "s4key", "s2Key", "sdkKey", "s2KEY", "sdkKEY", "sdkkey", "s3Key", " s3Key", "s4Key", "s4url", " s3KEY", "s3secret", " s3url", "sdkurl", " s2KEY", " s2key"], "in": ["inn", "inc", "up", "init", "raw", "is", "it", "mi", "and", "ain", "sin", "inner", "stream", "isin", "ini", "r", "din", "copy", "mm", "e", "file", "source", "nin", "bin", "i", "asin", "io", "read", "gin", "local", "data", "on", "f", "m", "from", "In", "sql", "or", "ins", "inside", "t", "en", "out", "IN", "o", "l", "con", "req", "iter", "s", "n", " din", "ai", "input", "cin", "re", "rin", "mc", "reader", "vin", "inf", "oin", "ind"], "temp": ["tem", "mk", "EMP", "tr", "p", "tx", "part", "dest", "tc", "current", "copy", "mm", "partial", "file", "unt", "buffer", "tmp", "Temp", "mod", "local", "dat", "template", " temporary", "top", "tab", "txt", "base", "fake", "res", "stem", "tim", "tar", "mp", "prefix", "porary", "t", "out", "mem", "test", "output", "null", "pt", " tmp", "to", "tm", "my", "mt", "emp"], "fout": ["ffou", "wOut", "fabyout", " foutput", "flowou", "fabouts", "flowoutput", "foutput", " fouts", "flou", "wout", "fou", "Fouts", "ffout", "vOut", "fto", "Fout", "fouts", " fyout", "flout", "Fyout", "flowout", "ifou", "ifout", "ffto", "ifOut", "ifoutput", "vouts", "fabOut", "wto", "flOut", "ffoutput", "vout", "floutput", "ffOut", " fou", "fabout", "FOut", "fOut", "vto", "wouts", "ffouts", "fyout", " fOut", "flowOut"]}}
{"id1": "8216539", "id2": "823074", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentasText", "getFileContentasString", "getFileContentasStr", "getFileTextAsString", "getFileTextAsStr", "getFileTextAsText", "getFileContentAsText", "getFileContentAsStr"], "filePath": [" fileInfo", "FileName", "fileInfo", "entryPATH", "ilePath", "basepath", "entryPath", "FILEPath", "FileDef", "FILEName", " fileString", "baseString", "FilePATH", "baseName", "FILEPATH", " fileDef", "basePath", "FILEpath", "entrypath", "filePATH", "entryName", "ileInfo", "ileDef", "FilePath", "ileName", "filepath", "Filepath", "fileString", " filepath", "fileName", "FileInfo", " fileName", "fileDef", "FileString"], "encoding": ["Encoding", "Encuing", "encordering", "Encordering", "ENCaching", "enoding", "ENCordering", "unicode", "characterordering", "unicuing", "characterging", "characteraching", "encaching", "unicoding", "Encging", "enaching", "Encode", "unicaching", "ENCoding", "Encaching", "ENCging", "enuing", "enode", "characteroding", "encuing", "encging", "encode"], "testURL": ["testRE", "testUR", "testedURL", " testRE", " testUR", "testSR", "checkSR", "testingSR", "TestUrl", "testingUrl", " testUrl", "TestUR", "testedUR", "checkURL", "checkUrl", "testedUrl", "checkUR", "testedRE", "testingUR", " testSR", "TestURL", "testUrl", "testingURL", "testingRE", "TestSR"], "input": ["stream", "submit", "context", "channel", "data", "accept", "from", "cont", "form", "in", "cur", "iter", "list", "has", "exist", "upload", "url", "act", "xml", "sample", "current", "config", "source", "start", "quit", "read", "audio", "address", "focus", "exec", "raw", "view", "active", "up", "ip", "json", "hello", "tmp", "batch", "comment", "unsigned", "q", "command", "Input", "output", "qa", "acl", "missing", "hidden", "can", "eval", "iterator", "lat", "init", "image", "PUT", "quick", "it", "inner", "add", "feed", "file", "op", "client", "open", "get", "pull", "empty", "reader"], "sw": ["sm", "SW", "wa", "su", "ws", "wh", "igm", "wn", "sk", "sh", "sa", "enc", "nw", "wra", "w", "ow", "sb", "Sw", " Sw", "wr", "aw", "iw", "fw", "hw", "sv", "sem", "sl", "we", "wl", "ews", "ew", "kw", "sur", "sf", "rew", "sn", "wo", "sc", "was", "tw", "ows", "sp"]}}
{"id1": "19868933", "id2": "23335922", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 0, "substitutes": {"copyFromFileToFileUsingNIO": ["copyFromFileToFileUsingNHIF", "copyFromFileToFileUsingNHIE", "copyFromFileToFileUsingRIF", "copyFromFileToFileUsingRFile", "copyFromFileToFileUsingNHFile", "copyFromFileToFileUsingMIF", "copyFromFileToFileUsingMIO", "copyFromFileToFileUsingNHIO", "copyFromFileToFileUsingNIE", "copyFromFileToFileUsingMIE", "copyFromFileToFileusingNIO", "copyFromFileToFileusingRIE", "copyFromFileToFileUsingNIF", "copyFromFileToFileUsingRIE", "copyFromFileToFileusingNFile", "copyFromFileToFileusingRFile", "copyFromFileToFileusingRIF", "copyFromFileToFileUsingNFile", "copyFromFileToFileusingNIE", "copyFromFileToFileusingRIO", "copyFromFileToFileUsingMFile", "copyFromFileToFileusingNIF", "copyFromFileToFileUsingRIO"], "inputFile": ["importFile", "importByte", "openPath", "loadPath", "outputPage", "loadfile", " inputByte", " inputfile", "openLe", "outputByte", "loadLe", "inputStream", " inputPath", "openFile", "inputByte", "inputPath", " inputPage", " inputStream", "inputfile", "importStream", "importPage", "loadFile", " inputLe", "inputPage", "openfile", "inputLe", "outputStream"], "outputFile": ["toPlace", "toStream", "outputfile", "resultPlace", "putDirectory", "inputDir", " outputPlace", "putfile", " outputDir", " outputfile", "toFile", "resultStream", "toFiles", " outputDirectory", " outputStream", " outputFiles", "outputPlace", "inputDirectory", "outputDir", "putFile", "inputfile", "putDir", "outputDirectory", "resultFile", "resultFiles", "outputFiles", "outputStream"], "inputChannel": [" inputManager", "loadChannel", "inputCategory", "httpConnection", "tableScope", "rawChannel", "internalChannel", "importChannel", "openConnection", "loadCategory", "rawFile", "outputchannel", "importManager", "httpChan", "internalListener", "inputBuffer", "InputConnection", "outputStream", "outputChan", "openchannel", "inputListener", "internalBlock", " inputConnection", "inputChuck", " inputBuffer", "inputStream", "loadChuck", "InputStream", "inputScope", " inputCategory", "outputBuffer", "inputChan", " inputListener", " inputBlock", "httpFile", "loadManager", "openChannel", "rawChan", "tableListener", "outputConnection", " inputChuck", "internalScope", "InputBuffer", "inputchannel", " inputStream", "httpChannel", "inputManager", "tableBlock", "inputConnection", " inputScope", "tableChannel", "openChan", "importCategory", "importChuck", "rawConnection", " inputChan", "inputBlock", " inputchannel", "InputChannel"], "outputChannel": ["removeCow", "languagechannel", " outputCategory", "publicCow", "consoleCow", "hiddenChan", " outputButton", "outputchannel", "languageCategory", "OutputFile", "outputChan", "putChan", "consolechannel", "consoleFile", "removechannel", "OutputStream", " outputchannel", "outputCategory", "putButton", "outputClient", "consoleStream", "publicChannel", "putCamera", " outputStream", "putChannel", "hiddenChannel", "hiddenButton", "outputCow", "hiddenCamera", "outputCamera", " outputCamera", "displayCategory", "OutputChan", " outputChan", "outputButton", "consoleChan", "displayClient", "consoleChannel", "OutputChannel", " outputClient", "displaychannel", "displayChannel", "languageClient", "publicchannel", "removeChannel", "languageChannel", "outputStream"]}}
{"id1": "1954410", "id2": "822452", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"doExecute": ["doEditExec", "doEditutes", "DoExecute", "DoExecit", "doEditit", "doCommute", "DoExecutes", "doCommutes", "DoExecExec", "doCommExec", "doEditute", "doCommit", "doExecutes", "doExecExec", "doExecit"], "mapping": ["Mappings", "mapped", "mappings", "mapper", " mapped", "Mapping", " mappings", " mapper", "smapped", "smappings", "Mapped", "smapper", "smapping", "Mapper"], "form": ["view", "parent", "path", "raw", " forms", "FORM", "forms", "subject", " Form", "config", "session", "orm", "template", "sam", "map", "fc", "Form", "f", "m", "type", " FORM", "format", "command", "formed", "app", "self", "owner"], "request": ["server", "model", "container", "question", "context", "host", "reference", "user", "cont", "store", "frame", "create", "req", "input", "quest", "document", "upload", "QUEST", "url", "version", "def", "xml", "message", "current", "resource", "project", "sw", "report", "http", "_", "Upload", "impl", "address", "reset", "remote", "view", "this", "se", "w", "Request", "query", "template", "command", "post", "window", "parent", "initial", "first", "true", "order", "allow", "Exception", "session", "application", "instance", "open", "client"], "response": ["view", "server", "resp", "xml", "message", "content", "success", "session", "respond", "application", "result", "res", "report", "send", "status", "frame", "Response", "write", "output", "connection", "re", "ce", "reply", "sp", "document", "print"], "errors": [" status", " flash", " mess", " elements", " warnings", " updates", " storage", " sessions", " error", " success", "Mess", " Messages", " problems", " messenger", " requests", " messages", " state", " flashes", " fails", " logs", " steps", " managers", "ages", " changes", " manager", " states", " statements", " moves"], "isMultipart": ["isMultiIParts", "isMultIPain", "isMultIPart", "isMultIPod", "isMultIPade", "isMultifare", "isMultIParts", "isMultipod", "isMultiipart", "isMultiplarts", "isMultipade", "isMultipain", "isMultifarts", "isMultiipare", "isMultiplade", "isMultiIPade", "isMultiipain", "isMultiparts", "isMultiiparts", "isMultospain", "isMultiart", "isMultiIPain", "isMultiplart", "isMultiipod", "isMultiplod", "isMultospart", "isMultiIPare", "isMultIPare", "isMultifain", "isMultospare", "isMultiarts", "isMultiIPart", "isMultifart", "isMultiipade", "isMultosparts", "isMultipare", "isMultiod", "isMultiIPod", "isMultiade"], "mailInstance": ["emailInst", "flexInstance", " MailInst", "emailinstance", " mailInst", " MailBuilder", " MailInstance", "emailance", "flexInst", "mailance", " mailinstance", " Mailinstance", "flexinstance", "emailBuilder", "mailInst", "mailBuilder", "emailInstance", " mailance", "mailinstance", "flexance", " mailBuilder"], "fields": ["views", "bits", "packs", "groups", "posts", "rules", "sections", "frames", "ports", "locks", "lines", "drivers", "forms", "strings", "pages", "members", "features", "days", "classes", "plugins", "users", "reports", "relations", "comments", "links", "keys", "tags", "holders", "dates", "files", "faces", "states", "services", "workers", "lists", "rows", "packages", "modules", "tests", "boxes", "models", "details", "phones", "parts", "objects", "levels", "balls", "types", "atts", "terms", "flags", "lights", "checks", "qs", "headers", "field", "orders", "images", "names", "prints", "properties"], "attachments": ["achions", "payances", "attments", "payements", "payments", "payitions", "attachresses", " attachions", "achresses", " attachresses", "attachitions", "Attachresses", "Attachions", "attachements", " attachances", "attachMENTS", "Attachitions", "achensions", "acheances", " attachitions", "AttachMENTS", "attMENTS", "achMENTS", "attachensions", "achitions", "Attachments", " attachements", "attensions", "attitions", "attachions", "Attachensions", "acheements", "achments", "achements", "acheitions", "attachances"], "items": ["resources", "groups", "ips", "lines", " Items", "pages", "members", " results", "reports", "links", "keys", "archives", "results", "apps", "files", " samples", "issues", "actions", "services", "photos", "packages", "ids", "rows", "its", "Items", " files", "objects", "phones", "parts", "tests", " images", " inputs", "events", "orders", "qs", "images", "names", "cases"], "iter": ["orient", "iterator", "ter", "former", "init", "altern", "tr", "writer", "cmp", "it", "each", "older", "inner", "order", "ator", "ait", "ite", "outer", "ipper", "walker", "i", "Iterator", "read", "iner", "inter", "gener", "result", "maker", "coll", "el", "ner", "its", "store", "set", "ser", "er", "loc", "loop", "test", "tif", "upper", "dir", "Iter", "list", "re", "oper", "reader", "ind", "li"], "item": ["ix", "link", "obj", "stat", "ex", "info", "one", "data", "el", "cell", "store", "element", "spec", "name", "url", "unit", "other", "claim", "attr", "xml", "member", "entity", "detail", "event", "resource", "on", "type", "details", "single", "rule", "row", "att", "raw", "addr", "attribute", "up", "anything", "ip", "job", "mm", "layer", "json", "record", "template", "step", "or", "object", "module", "area", "zip", "group", "key", "initial", "image", "it", "order", "inner", "add", "entry", "file", "change", "internal", "local", "related", "match", "atom", "page", "status", "instance", "er", "Item", "app", "word"], "aux": ["ix", "AU", "ras", "auto", "lim", "tx", "fax", "ex", "ox", "foo", "pet", "fat", "fam", "aos", "max", "aim", "ups", "fuck", "vers", "etc", "pad", "fx", "uf", "aw", "uds", "imp", "airs", "uff", "av", "abs", "ux", "mu", "du", "ax", "fu", "aus", "eu", "aff", "cu", "us", "au", "buff", "af", "net", "extra", "used", "area", "off"], "part": ["html", "p", "tx", "and", "partial", "pos", "par", "pad", "parts", "card", "piece", "zone", "bound", "pt", "block", "list", "comp", "version", "message", "sample", "member", "detail", "point", "start", "join", "top", "tab", "person", " Part", "worker", "prefix", "component", "party", "PART", "Part", "job", "pet", "photo", "layer", "half", "admin", "art", "tmp", "mod", "step", "base", "peer", "object", "api", "relation", "pkg", "section", "sp", "print", "primary", "patch", "pair", "wrapper", "group", "parent", "inner", "add", " parts", "temp", "local", "pod", "pre", "work", "split", "word", "format"], "baos": ["baOs", "biOS", "bao", "taops", "tao", "vaOs", "vaoss", "vaols", "poOS", "tais", "bioses", "boOs", "bais", "caoss", "caOs", "waos", "taoss", "waols", "booses", "baols", "poops", "baoses", "caos", "boos", "waOs", "bio", "bios", "booss", "baOS", "waoss", "kaops", "caOS", "pois", "cao", "caols", "kais", "boo", "pooss", "taOs", "vaos", "poo", "boOS", "baops", "baoss", "pooses", "poos", "kaoss", "taos", "kaos"], "body": ["mail", "name", "port", "html", "header", "head", "shell", "display", "description", "message", "subject", "content", "title", "detail", "json", "file", "ody", "buffer", "layout", "log", "data", "template", "default", "scroll", "tail", "comment", "base", "foot", "report", "format", "plain", "send", "post", "text", "summary", "t", "bill", "binary", "loop", "rel", "output", "null", "tree", "ODY", "size", "pass", "business", "note", "Body"], "preferencesInstance": ["preffiesinstance", "prefancesObj", "prefferencesObj", "prefiesinstance", "prefferencesInstance", "prefferencesinstance", "prefancesImpl", "prefutesInstance", "prefiesObj", "preferencesObj", "preferencesImpl", "prefiesInstance", "prefutesObj", "preffiesObj", "prefancesinstance", "prefancesInstance", "preferencesinstance", "prefferencesImpl", "prefiesImpl", "preffiesInstance", "preffiesImpl", "prefutesinstance", "prefutesImpl"]}}
{"id1": "9954926", "id2": "2324868", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"simulate": ["modulation", " simure", "modure", "smulate", "smulation", "simulates", "simulation", " simulation", "smure", "modulates", " simulates", "smulates", "simure", "modulate"], "out": ["cache", "obj", "conn", "p", "Out", "ex", "v", "content", "cmd", "last", "buffer", "ger", "io", "manager", "f", "res", "conf", "store", "in", "set", "help", "tree", "list", "state", "name", "writer", "inv", "pool", "put", "e", "gc", "error", "on", "report", "cfg", "at", "gr", "con", "os", "outs", "OUT", "screen", "net", "raw", "cn", "up", "exp", "hit", "nt", "w", "outer", "ent", "all", "nr", "err", "conv", "gen", "batch", "c", "base", "sum", "ins", "o", "OU", "output", "null", "co", "print", "can", "handle", "ou", "group", "go", "init", "gov", "it", "inner", "copy", "flush", "aos", "b", "log", "sys", "t", "write", "client", "to", "pretty", "n"], "file": ["port", "ile", "name", "fp", "path", "le", "File", "model", "handle", "pool", "message", "lock", "e", "b", "source", "buffer", "log", "filename", "resource", "io", "channel", "data", "template", "FILE", "library", "result", "f", "base", "type", "report", "console", "set", "play", "t", "db", "l", "output", "table", "connection", "input", "document", "format"], "obtainUserReputationRequest": ["obtainUserReputationrequest", "obtainUserReputationsResponse", "obtainUserRepresentationResponse", "obtainUserRelutationQuery", "obtainUserRepationrequest", "obtainUserReputationError", "obtainUserReputionTask", "obtainUserReputionTarget", "obtainUserReputionResponse", "obtainUserReputationTask", "obtainUserReputationsTarget", "obtainUserRelutationsTask", "obtainUserRelutationsRequest", "obtainUserRepositoryTask", "obtainUserRepresentationRequest", "obtainUserReputationsrequest", "obtainUserReplutationTarget", "obtainUserRepositoryRequest", "obtainUserReputationQuery", "obtainUserReporationError", "obtainUserRelutationRequest", "obtainUserRepetitionResponse", "obtainUserReputionrequest", "obtainUserReputionQuery", "obtainUserReporationResponse", "obtainUserRepationResponse", "obtainUserRelutationTask", "obtainUserRepationTarget", "obtainUserRepationError", "obtainUserRepresentationQuery", "obtainUserReputationsError", "obtainUserRepresentutationResponse", "obtainUserRepresentutationRequest", "obtainUserRepresentationError", "obtainUserRepresentutationrequest", "obtainUserReputationsQuery", "obtainUserRepresentationrequest", "obtainUserReputationsRequest", "obtainUserRelutationsResponse", "obtainUserReputionRequest", "obtainUserReporationQuery", "obtainUserRepresentationTarget", "obtainUserRepetitionRequest", "obtainUserReputationsTask", "obtainUserRepresentutationTarget", "obtainUserRepationQuery", "obtainUserRelutationsQuery", "obtainUserRepresentutationError", "obtainUserRepositoryResponse", "obtainUserReplutationResponse", "obtainUserReplutationRequest", "obtainUserRelutationResponse", "obtainUserRepositoryQuery", "obtainUserRepationRequest", "obtainUserRepresentutationQuery", "obtainUserReputationTarget", "obtainUserReporationRequest", "obtainUserRepetitionTarget"], "obtainUserReputationResponse": ["obtainUserReportutationResponse", "obtainUserReputationsResponse", "obtainUserRepulationAnswer", "obtainUserReportutationResp", "obtainUserReputationService", "obtainUserRepositoryAnswer", "obtainUserReportutationAnswer", "obtainUserReputationAnswer", "obtainUserReportositoryResp", "obtainUserReportositoryResponse", "obtainUserReputationResp", "obtainUserRepulationResp", "obtainUserRepulationService", "obtainUserReportositoryAnswer", "obtainUserReportositoryService", "obtainUserRepositoryService", "obtainUserReputationsResp", "obtainUserRepositoryResponse", "obtainUserReportutationService", "obtainUserReputationsService", "obtainUserRepositoryResp", "obtainUserReputationsAnswer", "obtainUserRepulationResponse"], "rateUserRequest": ["scaleOwnerRequest", "rateuserCommand", "createUserrequest", "rateTimerequest", "raceUserRecord", "raceUserrequest", "rateUserChange", "rateOwnerResponse", " rateUserrequest", "scaleUserResponse", "rateUsersResponse", "rateJobRequest", "rateRowJob", "createuserrequest", " rateUserJob", "rateSamplerequest", "rateUserJob", "rateuserQuery", "raceRowrequest", "RateLineRequest", "raceUserRequest", "rateUserrequest", "createuserRequ", "rateUsersAccess", "RateUsersChange", "rateLinerequest", "rateUserCommand", "rateRowRequest", "RateUserRequest", "rateuserAccess", "RateUserrequest", "rateUsersRequest", "RateUserQuery", "rateLineResponse", "rateUserRequ", "createuserRequest", "RateLineResponse", "createuserCommand", "rateOwnerRequest", "rateuserRequest", "rateLineRequ", "RateClientRequest", "rateDateGrant", "rateUserRecord", "RateUserQUEST", "rateuserrequest", "rateUserQUEST", "rateClientRequest", "RateUsersrequest", " rateUserQuery", "rateTimeResponse", "rateUsersQuery", "rateTimeRequest", "scaleOwnerAccess", "rateuserResponse", "rateUserAccess", "scaleUserRequest", "rateRowRecord", "rateUsersChange", "rateuserRequ", "rateClientResponse", "rateOwnerRecord", "rateOwnerAccess", "RateUsersRequest", "rateProxyQuery", "raceRowRecord", "rateClientrequest", "rateRowResponse", "rateClientJob", "scaleOwnerResponse", "rateSampleCommand", "RateUserGrant", "RateUsersResponse", "rateuserQUEST", "rateUsersQUEST", "rateClientGrant", "rateLineCommand", "rateUsersrequest", "rateProxyRequest", "RateUserChange", "RateClientResponse", "rateLineRequest", "rateLineQuery", "createUserRequ", "rateRowrequest", "rateDateRequest", "RateClientGrant", "rateDateResponse", "rateUserQuery", "rateLineGrant", "rateJobChange", "RateUsersQUEST", "createUserCommand", "RateLineQuery", "rateOwnerrequest", "rateSampleRequest", "scaleUserAccess", "rateProxyResponse", "RateUsersQuery", "rateUserGrant", "rateSampleRequ", "RateUserResponse", "createUserRequest", "raceRowRequest", "rateProxyQUEST", "RateLinerequest", "rateJobResponse"], "rateUserResponse": ["rateWordReturn", "rateUsersresponse", "RateUserReply", "rateMethodVersion", "RateUserVersion", "rateUsersReply", "rateUsersResponse", "rateTimeAnswer", "rateUserReturn", "rateWordRequest", "ratesUserRequest", "rateUserVersion", "ratesClientRequest", "rateUserData", "RateUsersReply", " rateClientRequest", "rateClientResp", "RateUserRequest", "rateUsersRequest", "rateMethodRequest", "rateUserAnswer", "rateTimeStatus", "rateUsersStatus", "rateControllerResp", "rateuserRequest", "rateDateData", "ratesClientMessage", "rateClientRequest", "rateFileRequest", "rateMemberRequest", "rateTimeResponse", "rateUserMessage", "rateTimeRequest", "rateuserResponse", "RateUsersresponse", "rateManagerResponse", "rateuserReply", " rateUserAnswer", "rateFileReturn", " rateClientresponse", "rateClientResponse", "rateControllerMessage", "ratesUserMessage", " rateClientResponse", "rateMemberResponse", "RateUsersRequest", "rateDateVersion", "RateUserData", "rateUserresponse", "rateWordResponse", " rateUserReturn", " rateUserStatus", "rateWordresponse", "rateManagerRequest", "rateUserStatus", "rateManagerResp", "RateUsersResponse", "rateControllerRequest", "rateuserresponse", "rateMemberresponse", "rateFileresponse", "rateUsersAnswer", "rateManagerMessage", "rateUserResp", " rateUserresponse", "ratesUserResponse", "RateUserresponse", "rateDateRequest", "rateDateResponse", "rateUserReply", "rateControllerResponse", "rateFileResponse", "rateMemberReply", "rateClientMessage", "ratesClientResponse", "ratesUserResp", "RateUserResponse", "rateClientReturn", "rateMethodData", "rateMethodResponse", "rateClientresponse", " rateClientReturn", "ratesClientResp"], "fis": ["bi", "sfiss", "flisa", "Fis", "fiss", "sfIs", "FIs", "liss", "sfIS", "flis", "Fiss", "sfis", " fi", "fi", "bis", "fli", "FIS", "fIs", " fisa", "bisa", "fIS", "fisa", "lIS", "lIs", "lis"], "br": ["bn", "bi", "ch", "tr", "BR", "adr", "bl", "hr", "bh", "sr", "Br", "wr", "bd", "div", "bridge", "nr", "ger", "buf", "ber", "be", "bp", "vr", "ctr", "bf", "gb", "str", "browser", "pr", "bm", "shr", "bt", "bro", "gr", "mr", "cr", "lr", "fr", "dr", "kr"], "call": ["name", "execute", "url", "ell", "action", "char", "inv", "continue", "add", "message", "info", "label", "all", "query", "bridge", "log", "update", "called", "function", "cal", "result", "comment", "c", "report", "send", "command", "cell", "trace", "status", "draw", "frame", "check", "str", "play", "code", "contact", "test", "line", "word", "block", "request", "dial", "list", "cin", "callback", "Call", "n", "use"]}}
{"id1": "20675046", "id2": "1097146", "code1": "    public Object getContent(ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {\n        try {\n            URL url = (getURL() != null) ? new URL(getURL().toExternalForm()) : new URL(((URL) ctxAttrValue).toExternalForm());\n            InputStream reader = url.openStream();\n            int available = reader.available();\n            byte contents[] = new byte[available];\n            reader.read(contents, 0, available);\n            reader.close();\n            return new String(contents);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return ex.toString();\n        }\n    }\n", "code2": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["setContents", "GetContents", "GetText", "getContents", " getContents", "GetBody", "setContent", " getBody", " getText", "setText", "GetContent", "setBody", "getText", "getBody"], "context": ["TEXT", "tx", "message", "content", "value", "event", "config", "network", "resource", "parser", "channel", "data", "template", "processor", "application", "base", "type", "command", "object", "text", "chain", "Context", "component", "ctx", "output", "input", "document", "state"], "ctxAttrName": ["ctxAddrKey", "ctxAddmKey", "ctxAttribName", "ctxAttrname", "ctxAttrsname", "ctxAddrName", "ctxAttribname", "ctxAddmName", "ctxAddmValue", "ctxAttribKey", "ctxAttmValue", "ctxAttmKey", "ctxAttrsName", "ctxAttrsKey", "ctxAddmname", "ctxAttrKey", "ctxAttmname", "ctxAddrValue", "ctxAttribValue", "ctxAddrname", "ctxAttmName", "ctxAttrsValue"], "ctxAttrValue": ["ctxAttmType", "ctxAttuData", "ctxAttrbName", "ctxAddrbvalue", "ctxAttrdValue", "ctxDetribType", "ctxAttrElement", "ctxAddrElement", "ctxAttuValue", "ctxAttrdName", "ctxAttrbValue", "ctxAddrbElement", "ctxAttrData", "ctxAttrType", "ctxAttribData", "ctxAddrName", "ctxDetrData", "ctxDetribVal", "ctxAttrdElement", "ctxAddrvalue", "ctxAttribVal", "ctxAttmData", "ctxAttuType", "ctxDetrVal", "ctxAddrbName", "ctxAttmValue", "ctxAttrbElement", "ctxDetrValue", "ctxDetrType", "ctxAttribType", "ctxAttmElement", "ctxAttmvalue", "ctxAddrbValue", "ctxDetribData", "ctxAttrbvalue", "ctxAttmVal", "ctxAttrdvalue", "ctxAddrValue", "ctxAttrVal", "ctxAttribValue", "ctxAttmName", "ctxDetribValue", "ctxAttrvalue", "ctxAttuVal"], "url": ["Url", "link", "hl", "name", "external", "path", "cert", "handle", "char", "sb", "mount", "file", "location", "b", "log", "ssl", "resource", "io", "build", "dl", "base", "uri", "web", "http", "nl", "sl", "el", "rl", "service", "str", "ll", "browser", "address", "ref", "loc", "rel", "l", "client", "null", "lr", "URL", "ls", "ur", "ul"], "reader": ["volume", "iterator", "READ", "ri", "shape", "writer", "image", "per", "older", "reading", "inner", "stream", "loader", "ator", "r", "sample", "info", "rr", "rx", "file", "source", "buffer", "resource", "read", "parser", "io", "rar", "builder", "data", "dra", "user", "handler", "uri", "driver", "peer", "rl", "check", "Reader", "er", "ro", "test", "length", "open", "upper", "iter", "row", "input", "readable", "runner", "dd", "rot", "handle"], "available": ["free", "loaded", "provided", "added", "active", "len", "usable", "played", "enabled", "required", "created", "full", "capacity", "bytes", "enough", "ready", "availability", "acity", "usage", "current", "max", "installed", "all", "buffer", "missing", "i", "ap", "read", "produced", "ocated", "checked", "num", "opened", "selected", "written", "needed", "release", "valid", "visible", " unavailable", "good", "released", "allowed", "out", "no", "supported", "Available", "bound", "length", "total", "alloc", "position", "count", "locked", "end", "readable", "sp", "used", "ed", "can", "index"], "contents": ["Contents", "Contacts", "CONTacts", "contented", "CONTented", "Contented", "contars", " contries", "content", " contentials", "ContContents", "Contentials", "Contries", "Contours", "Contars", " content", "CONTContents", "contours", " contContents", "Content", "mintented", "contries", "requentials", "contentials", "contacts", "requours", "CONTents", "requents", "contContents", " contacts", " contours", "requries", "mintent", "CONTent", "mintars", "CONTars", "mintents"]}}
{"id1": "1698200", "id2": "7458833", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginbitshare", "loginbitShare", " loginbitStock", " loginbitshare", "loginByteShare", " loginBitStock", " loginBitshare", "loginByteStock", "loginByteshare", "loginBitshare", "loginbitStock", " loginbitShare", "loginBitStock"], "params": ["metadata", "pres", "p", "posts", "settings", "cms", "auth", "ports", "rs", "ps", "stats", "members", "mm", "json", "Parameters", "config", "points", "comments", "param", "caps", "keys", "gs", "parser", "tags", "requires", "pps", "services", "pins", "pas", "http", "photos", "details", "hash", "parts", "changes", "types", "Par", "terms", "chains", "options", "ams", "headers", "acl", "pi", "names", "pretty", "cp", "properties"], "httpclient": ["Httpconnection", "httcontroller", "http2", "Httpclient", "httco", "httpsco", "hyper2", "ttpcontroller", "Httprequest", "https2", "httpscli", " httpClient", "httpconnection", "httclient", "ttpClient", "httpsrequest", "HttpClient", "httpsclient", " http2", "hyperconnection", "httpsClient", "httprequest", "httpClient", "httpco", "hyperclient", "ttpclient", "httpscontroller", " httpcli", "httClient", "httpcontroller", " httprequest", "ttpco", "httpcli", " httpconnection", "httpsconnection", "hypercli"], "httppost": ["httpppop", "httplost", " httpop", "httphost", "httmpost", "httppart", "httploster", "httpppoint", "httmpop", "httpplop", "httppoint", " httpppost", "httplpost", " httpost", "httpposter", "httplom", "httploint", "httpost", "httmppost", "httphpost", "httppppost", "httpoint", "httpplost", "httpom", "httpop", "httphoint", "httpperop", "httphoster", "httpplart", "httppposter", "httpploint", "httposter", " httppop", "httpplpost", "httpploster", "httppop", " httpom", "httplart", "httppom", "httpart", "httpppart", "httmpart", " httppom", "httpperom", "httpperost", "httpppost", "httpperpost", "httplop"], "formparams": ["foreargs", "formargs", "functionproperties", "feedparam", " formauthors", "functionauthors", "foreproperties", "foreauthors", "condnames", "feeddetails", "inputdetails", "batchnames", "functionargs", "formmembers", "formsettings", "condsettings", "forechanges", "condproperties", "functiondetails", "formednames", "formedparams", "batchtags", "functionchanges", " formdetails", "formparam", "formerrors", "formedtags", "inputparams", " formnames", "forenames", "inputParameters", "feedParameters", "inputparam", "inputnames", "batchparams", "batcherrors", "functionmembers", "formproperties", "formauthors", "functionparams", "foremembers", " formchanges", " formargs", "inputerrors", " formmembers", " formparam", " formsettings", "condparams", "inputtags", "formederrors", "foreparams", "formParameters", "foredetails", "formnames", "formdetails", "foresettings", " formproperties", " formParameters", "feedparams", "formchanges", "formtags"], "entity": ["metadata", "ell", "html", "activity", "inv", "xml", "enc", "Entity", "entry", "content", "ENT", "ent", "json", "ee", "event", "buffer", "ITY", "profile", "orm", "template", "data", "user", "note", "comment", "person", "eme", "security", "el", "quote", "form", "body", "ew", "object", "ity", "create", "out", "component", "fee", "line", "em", "ce", "empty", "document"], "httpresponse": [" httpreply", "HTTPResponse", "httpResponse", "procreply", "HTTPresult", "HTTPresp", "httpresp", "ttpResponse", " httpresult", "httpconnection", "procresult", "HTTPreply", "ttpconnection", "httpresult", "ttpresponse", "HTTPresponse", "HTTPconnection", " httpresp", "procresponse", " httpResponse", " httpconnection", "httpreply", "procResponse", "ttpresp"], "it": ["im", "al", "MIT", "est", "ip", "init", "is", "you", "act", "itter", "ul", "ex", "v", "mit", "It", "rit", "ite", "iz", "ut", "IT", "ent", "lit", "itted", "ate", "i", "sit", "il", "el", "ot", "he", "its", "ic", "st", "t", "at", "l", "ert", "iter", "et", "ect", "ist", "ed", "ind", "li"], "escookie": ["eyancel", "ecookie", "eccake", "espookie", "ectrl", "occookie", "httpsog", "escotton", "Escookie", "httpsotton", "Esccookie", "eccookie", "desctrl", "escue", "Escue", "ecoder", "iseccake", "descue", "espcookie", "ecog", "isecookie", "descookie", "occoder", "eycookie", "espace", "desccookie", "httpsookie", "escace", "httpscookie", "isecoder", "espancel", "esctrl", "eyace", "escog", "occcookie", "esccake", "escancel", "iseccookie", "occotton", "ecace", "ecotton", "occog", "escoder", "occcake", "eyookie", "ecancel", "Esctrl", "ecue", "esccookie"]}}
{"id1": "14598566", "id2": "2807585", "code1": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"copyFileByNIO": ["copyFileBynIO", "copyFilebyNII", "copyFilebynio", "copyFileBynio", "copyFileByNIR", "copyFileBynII", "copyFileByStandardIO", "copyFileByNII", "copyFileByNDIO", "copyFileByNDIR", "copyFilebynIO", "copyFilebyNio", "copyFileBynIR", "copyFilebyNIO", "copyFileByNDII", "copyFileByStandardIR", "copyFilebyNIR", "copyFileByNDio", "copyFileByStandardio", "copyFilebynIR", "copyFileByStandardII", "copyFilebynII", "copyFileByNio"], "in": ["inn", "inc", "up", "is", "it", "isin", "old", "din", "mm", "source", "b", "i", "gin", "on", "id", "from", "In", "el", "sql", "ic", "st", "ins", "en", "IN", "o", "vin", "l", "input", "cin", "rin", "ar", "as", "edIn", "ind"], "out": ["ch", "it", "Out", "g", "ex", "v", "nt", "w", "u", "b", "log", "err", "io", "serv", "gt", "po", "ot", "check", "str", "op", "t", "at", "o", "ne", "l", "output", "os", "null", "to", "oss", "s", "outs", "OUT", "net", "n", "ou"], "sourceChannel": ["parseCategory", "srcConnection", "sourceListener", "givenChannel", "srcProvider", "SourceListener", "parseMember", "seedButton", "seedCategory", "ourceChannel", "sourcechannel", "givenMessage", " sourceProvider", "srcCategory", "sourceConnection", "srcMember", "sourceChain", "parseButton", " sourceListener", "srcButton", "srcMessage", "sourceProvider", " sourceChan", "ourceChan", "sourceMessage", "givenProvider", " sourceChain", "srcChain", " sourcechannel", "Sourcechannel", "ourceChain", "sourceCategory", "srcChannel", "sourceChan", " sourceConnection", "ourcechannel", "srcListener", "sourceButton", " sourceMessage", "seedChannel", "seedMember", "srcChan", "SourceChannel", "SourceConnection", "sourceMember", "givenListener", "parseChannel", "ourceListener", "ourceConnection"], "destinationChannel": ["destensionStream", "destinationConnector", "destationChannel", "destensionConnection", "destationStream", "destationConnector", "destinatedChan", "destinationsComponent", "destinationsChannel", "destructionChannel", "destinatedConnector", "DestationChan", " destinationChan", "destationChan", "destinatorChan", " destinationConnection", "DestinationClient", "destructionComponent", "DestinationStream", "DestinatorChannel", "destinatedChannel", "destructionChan", "destensionChannel", "destinationsChan", "DestationStream", "destensionClient", "DestationChannel", "destinationClient", "destationClient", " destationConnection", "DestinatorConnection", "destinatorConnection", "destationComponent", "DestationConnector", "destinatorChannel", "destinationsConnection", "destinatorClient", " destationChan", "destinationComponent", "destructionConnection", "destensionChan", "DestinationChannel", "destensionConnector", "destationConnection", " destationChannel", " destinationComponent", "destinationChan", "DestinatorClient", "DestinatorChan", "DestinationChan", "destinatedStream", "destinationStream", "DestinationConnector", " destationComponent", "destinationConnection", "DestinationConnection"]}}
{"id1": "11477906", "id2": "20735941", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadFAULTSetting", "readdefaultSettings", "readDefaultsettings", "loadFAULTsettings", "loaddefaultsettings", "loaddefaultValues", "loaddefaultSettings", "loadDefaultValues", "readDefaultValues", "readDefaultSettings", "loadDefaultsettings", "loadFAULTSettings", "loaddefaultSetting", "readdefaultValues", "loadFAULTValues", "readDefaultSetting", "loadDefaultSetting", "readdefaultsettings", "readdefaultSetting"], "configFileName": ["configStreamname", "confFilenamename", "configFilenameLocation", "configFilePath", "configFILEname", "configFILEPath", "configPagename", "configFileLocation", "confFilenamePath", "configfilePath", "conffileName", "configFilenamePath", "confFileName", "conffileNames", "conffilePath", "configFilenameNames", "configFILELocation", "configFilenamename", "configStreamPath", "configStreamName", "confFilePath", "configPageName", "confFilenameLocation", "confFilenameName", "configStreamLocation", "configPageNames", "configFilenameName", "conffilename", "confFilename", "confFileLocation", "configFILEName", "configfileName", "confFileNames", "configFileNames", "configFilename", "configfileNames", "configPagePath", "configfilename"], "in": ["inn", "im", "al", "up", "init", "is", "it", "mi", "ain", "inner", "isin", "ini", "din", "info", "run", "e", "source", "ze", "bin", "i", "gin", "ad", "user", "on", "id", "m", "from", "In", "or", "check", "ins", "t", "en", "IN", "ro", "o", "doc", "l", "con", "ai", "ma", "n", " din", "cin", "rin", "input", "re", "mc", "ls", "ar", "inf", "ind"], "out": ["port", "cache", "obj", "not", "server", "are", "Out", "ex", "v", "io", "user", "res", "ot", "store", "ind", "auto", "writer", "gc", "read", "m", "ge", "at", "ne", "os", "con", "oss", "outs", "OUT", "net", "ing", "raw", "cn", "up", "nt", "w", "ent", "une", "all", "de", "conv", "gt", "or", "ins", "o", "OU", "des", "output", "null", "co", "can", "handle", "ou", "init", "it", "copy", "aos", "file", "update", "sys", "ion", "log", "po", "check", "t", "en", "client", "to", "over", "n", "off"]}}
{"id1": "2168610", "id2": "20920051", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"update": ["touch", "info", "user", "dates", "call", "set", "create", "count", "remove", "diff", "index", "ul", "UPDATE", "state", "msg", "now", "put", "current", "resource", "result", "num", " Update", "report", "send", "http", "insert", "component", "edit", "row", "size", "use", "where", "up", "offset", "select", "find", " UPDATE", "database", "u", "value", "id", "batch", "Update", "save", "draw", "load", "out", "print", "handle", "delete", "init", "action", "equal", "continue", "commit", "add", "run", "change", "date", "exit", "login", "status", "check", "op", "write", "updated", "get", "grade", "latest", "fill"], "o": ["obj", "ooo", "onet", "p", "oid", "fo", "a", "mo", "oo", "e", "iso", "i", "h", "k", "om", "O", "oco", "m", "c", "cont", "po", "q", "oa", "object", "t", "out", "bo", "lo", "l", "os", "ilo", "ob", "to", "ao", "co", "aco", "n", "oin"], "contact": ["mail", "port", "character", "lead", "charge", "group", "pp", "conduct", "action", "claim", "addr", "act", "char", "cc", "comm", "display", "consider", "fax", "message", "add", "info", "entry", "content", "panel", "ACT", "title", "detail", "controller", "config", "hello", "international", "acts", "close", "transfer", "match", "Contact", "translation", "phone", "cont", "force", "report", "CONT", "impact", "communication", "company", "cell", "form", "responsible", "details", "check", "service", "country", "address", "l", "work", "client", "compliance", "component", "module", "connection", "trans", "att", "print", "aco", "ct", "control", "cp", "format"], "pst": ["pster", "apstan", "Ppt", "prse", "lST", "dpster", " pset", "psth", "pSt", " pmt", "vpset", "drest", "Pct", "pest", "ipSt", "ply", "dst", " pstan", "jply", " pster", "dpt", "pth", "pmt", " pstra", "epstal", "tpstal", "vpct", "dpct", "ipmt", "pingst", "PST", "prST", "jpSt", "jpst", " pstal", "dct", "pingsta", "lct", "presth", "prest", "pset", "pingSt", "psta", "prst", "epnt", "pingct", "pect", "bpost", "pingth", " ply", "Pse", "pingstal", "pstal", "lse", "preSt", "phpstal", " post", "jpct", "ppt", "perest", "ipsta", "apost", "post", "phpnt", "jpST", "apSt", "phpct", "preth", "pST", "epct", "ipST", "Prest", " pct", "jpsy", "epst", "presta", "tpst", " psy", "pept", "pse", "prect", "bpstan", "jpster", "tpstra", "dpst", "ipsth", "bpst", "jpmt", "pnt", "pstan", "ipct", " pSt", "lst", "Pst", "phpst", "ipst", "tpct", "pingstra", "jpset", " pnt", "bpSt", "prct", "pct", "pstra", "ipth", "dpsy", " pST", "psy", "vpst", "apst", "vply", " psth"]}}
{"id1": "5237257", "id2": "13063241", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"download": ["delete", " checkpoint", "init", "Download", "copy", " downloads", "file", "export", " browse", " drop", "dump", "save", " downloading", " zip", "load", " seek", "write", " upload", "paste", "get", "open", " retrieve", " dump", " Download", " restore", " downloaded", " recover", "upload"], "fileName": ["resourceName", "projectname", "FILEFilename", "FileName", " fileFilename", "fileFilename", "FILEPath", "projectName", "filename", "FILEName", "fileTime", "imagePath", " fileTime", "resourcePath", "resourceTime", "resourceType", "fileType", "FILEname", " filename", "FilePath", "projectPath", "FileType", "projectFilename", "FileTime", "imageName", " fileType"], "filePath": ["languageName", "resourceName", "FILEP", "FileName", "FileId", "resourcepath", "ilePath", "FILEUrl", "FILEPath", "FILEStart", "FILEName", "ileStart", " fileUrl", "fileP", "FileP", "fileId", "resourcePath", "languageId", "FILEpath", "resourceUrl", " fileId", "FilePath", "ileName", "ileP", "filepath", "fileStart", "FileStart", " filepath", "languagePath", "fileUrl"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "is", "it", "mi", "ain", "sin", "inner", "isin", "ini", "r", "din", "nin", "bin", "i", "io", "read", "gin", "local", "one", "win", "on", "id", "f", "m", "from", "login", "In", "el", "or", "st", "inside", "ins", "en", "IN", "o", "l", "iter", "con", "ai", "n", "co", "input", "rin", "cin", "ie", "re", "net", "pi", "ar", "inf", "ind"], "out": ["name", "obj", "not", "up", "conn", "ch", "p", "it", "Out", "inner", "ex", "v", "nt", "aos", "w", "outer", "ns", "ent", "file", "sys", "ion", "i", "nin", "cos", "io", "conv", "gt", "user", "on", "ou", "po", "we", "or", "op", "t", "no", "at", "o", "ne", "OU", "write", "output", "client", "os", "null", "con", "to", "oss", "boot", "co", "na", "outs", "OUT", "end", "net", "note", "can", "n", "cn"]}}
{"id1": "23118425", "id2": "8330057", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"encrypt": ["Encipher", "encipher", "decipher", "enryption", "decrypted", "enrypted", "decryption", "enipher", "enrypt", "encryption", "Encryption", "decrypt", "Encrypt", "Encrypted", "encrypted"], "plaintext": ["broadtxt", " Plainth", " plainText", " plaintxt", "realtext", " Plaintext", "broadText", "publicth", "plainText", " Plainpassword", "realtxt", " plainth", "broadtext", "realstring", "plainpassword", " PlainText", "plainth", " plainstring", "plainstring", " plainpassword", "publicText", "plaintxt", "publicpassword", "realText", "broadstring", "publictext"], "md": ["sm", "metadata", "msg", "del", "dig", "mt", "cd", "mb", "MD", "nt", "dm", "dh", "mo", "mm", "ds", "der", "od", "cmd", "managed", "ind", "grad", "bd", "sd", "mod", "ad", "esm", "pd", "ld", "deb", "m", "det", "med", " Md", " dd", " mc", "good", "mp", "rm", "ms", "mg", "red", "mn", "d", "doc", "gr", "nd", "dd", "mc", "dr", "material", "mk", "df", "hd"], "raw": ["clear", "html", "orig", " RAW", "full", "clean", "bytes", "sh", "message", "original", "cooked", "known", "w", "unknown", "pack", "json", "ng", "all", "buf", "aw", "data", "available", " Raw", "unsigned", "custom", "valid", "draw", "random", "mem", "out", "rew", "hook", "core", "row", "input", "Raw", "hex", "extra", "bare", "rendered", "RAW", "n"], "hash": ["name", "ashed", "html", "key", "tr", "ssh", "height", "handle", "sh", "ASH", "bh", "message", "mac", "json", "h", "ash", "password", "id", "dump", "alert", "hed", "search", "Hash", "sum", "tag", "ashes", "check", "mask", "proof", "rh", "component", "total", "shadow", "cloth", "hex", "print", "href", "has", "sha"]}}
{"id1": "9449064", "id2": "12783713", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"readExp": ["readexp", "readLoc", "readExpress", "ReadEXP", "readerLoc", "passExp", "readerEx", "readExpl", "Readexp", " readExpl", "ReadEx", "passexp", "checkExpl", "readProp", "passExpress", "readerExp", " readLoc", "checkExp", "passExpl", "readerexp", "checkexp", " readProp", " readexp", " readExpress", "ReadProp", "readerEXP", "readEx", "checkExpress", "readerProp", " readEXP", "ReadExp", "ReadLoc", "readEXP", " readEx"], "writeExp": ["writeEv", "writeExt", " writeexp", " writeXP", "riteConf", "writeexp", "riteEXP", "riteReg", " writeEv", "updateExp", "applyEx", "writeXP", "writEXP", "writEx", "applyEXP", " writeExt", "writexp", "writExp", "applyXP", " writeReg", "updateEv", "riteExt", "writeEx", "writeReg", "updateReg", "riteExp", "writeConf", " writeConf", "writeEXP", "updateExt", "riteEv", " writeEXP", "writXP", " writeEx", "writConf", "applyExp", "riteexp"], "expFile": [" expFILE", "Expfile", "exFile", "docPlace", "mxFile", "repPath", " expPlace", "docField", "expDir", "repFILE", "exprName", "exfile", "exprDir", "docFILE", "exprFile", "exFILE", "expName", "ExpDir", "exFilename", "expPath", "ExpFile", "xpFiles", "expPlace", "exprFilename", "xpPath", "xpFILE", "mxName", "xpfile", " expfile", "exPlace", "expFILE", "xpFile", "xpField", "expFilename", "mxFILE", "mxFilename", "xpFilename", "xpName", "exFiles", "docFile", "docFilename", "exprfile", " expDir", " expFilename", " expFiles", "repFile", "exprFILE", "expfile", "expField", "expFiles", "repField", "docPath"], "exp": [" np", " resp", "obj", " est", " expansion", "comp", " ep", "ef", "pp", "resp", "EXP", " dj", " expanded", "comm", "lim", "def", "expr", " xp", " ne", "eq", "ps", "ox", " inst", "expression", "acc", "ent", " imp", "esp", " op", "plus", "bed", "opt", " disp", "push", "inst", "dem", "wx", " sc", "imp", "Exp", "zero", "isp", "ext", "ez", "f", " exc", "rep", "raw", " extr", "expl", " vec", " doc", "nz", "ev", "pr", "jp", "prov", "xp", "eps", " expand", "sc", " exponent", " lim", " expr", " ev", "pl", "inf", " rap"], "fi": ["ni", "xf", "ri", "mi", "ffe", "zo", "fif", "phi", "gi", "wi", "eric", "si", "ini", "uti", "FI", "ista", "fty", "i", "cci", "ti", "ci", "fa", "zi", "osi", "obi", "aci", "lf", "flo", "ei", "uci", "qi", "ico", "ki", "iri", "fe", "Fi", "pi", "isi", "ati", "abi", "ii", "li"], "oi": ["ni", "bi", "odi", "uo", "ri", "ivo", "mi", "eric", "ini", "ami", "uti", "oni", "avi", "igi", "iso", "obo", "i", "ovi", "ti", "ci", "ori", "io", "multi", "rio", "eni", "osi", "obi", "bis", "oa", "flo", "ei", "ta", "ico", "uci", "ki", "iri", "ita", "vi", "asi", "ink", "isi", "uta", "ati", "oin", "ii"], "jf": [" jF", "djfd", " jif", "jsxf", " jsf", "jjc", "jcsf", "jcfm", " jbf", "Jfd", "jssf", "jcxf", "jb", "jjv", " jb", "bjfm", "jjfm", " jv", " jfp", "jbf", "jxf", "jfd", "jackxf", "jackfd", "Jsf", "Jfx", "jcf", "jjF", "gc", "djbf", "jc", "jjfp", "jjif", "Jb", "jfp", "jF", "jjfc", "Jbf", "jif", "jackbf", "jsbf", "jfm", "jackf", " jfm", "JF", "gfm", "gf", "Jxf", "jjf", "bjv", "djf", "Jfm", "jfx", "Jf", "djxf", "gfc", "bjfp", " jfc", "jv", "bjf", "jcfx", " jfx", " jc", "jfc", "jsf", "jcb", " jxf", "Jif"], "sp": ["sm", "pl", "pp", "span", "p", "sk", "si", "sh", "ps", "se", "sb", "ep", "esp", "vp", "so", "par", "ap", "bsp", "sg", "sam", "bp", "isp", "sw", "sv", "lp", "asp", "spr", "space", "rep", "osp", "st", "SP", "op", "sf", "spe", "jp", "pb", "sc", "Sp", "pt", "spl", " esp", "cp", "tp"], "e": ["name", "p", "it", "E", "x", "v", "a", "w", "ee", "event", "i", "f", "m", " ev", "el", "t", "er", "d", "fe", "s", "re", "ie", "ev", "ed", "n", "pe"], "fo": ["tto", "xf", "uo", "ooo", "ato", "folio", "tf", "opa", "zo", "fif", "wi", "mo", "eno", "oe", "FO", "so", "obo", "io", "ti", "hea", "uf", "fa", "olf", "po", "flo", "ico", "ki", "bo", "ro", "lo", "o", "cf", "tif", "wo", "co", "aco", "wt", "oos"], "oo": ["uo", "ooo", "ato", "oes", "folio", "opa", "elo", "zo", "oid", "ola", "ox", "foo", "mo", "oe", "cro", "ko", "oooooooo", "so", "oto", "obo", "ora", "ollo", "oooo", "yo", "oco", "olo", "po", "oa", "flo", "aco", "ano", "ta", "ico", "bo", "ro", "lo", "o", "wo", "ilo", "goo", "aha", "ao", "co", "ero", "OO", "oos"], "ex": ["ix", "xe", "external", "six", "none", "su", "ac", "tx", "x", "act", "exe", "aux", "tex", "iox", "def", "rex", "ox", "Exc", "event", "cre", "de", "log", "Ex", "err", "sex", "es", "wx", "example", "ry", "ext", "EX", " exc", "el", "lex", "com", "ax", "or", "pex", "ic", "te", "status", "spe", "pers", "des", "ctx", "exc", "re", "except", "ception", "px", "hex", "nex"]}}
{"id1": "8000624", "id2": "21425787", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyFrom", " copiesTo", " copiesInt", "CopyFrom", " copiesFrom", " CopyInt", " CopyFrom", " copyTo", " copyInt", "CopyInt"], "dest": ["name", "origin", "path", "orig", "nom", "est", "p", "image", "Dest", "it", "pipe", "v", "src", "fn", "target", "copy", "w", "temp", "source", "filename", "opt", "tmp", "result", "txt", "cont", "st", "img", "mem", "them", "loc", "usr", "d", "output", "dir", "null", "th", "sp", "cat", "rest"], "in": ["inn", "ire", "al", "inc", "up", "init", "image", "is", "per", "ac", "ain", "it", "mi", "sin", "inner", "isin", "ini", "r", "din", "file", "min", "source", "nin", "bin", "i", "ir", "internal", "read", "gin", "local", "one", "ar", "win", "on", "m", "from", "login", "In", "ins", "inside", " input", "en", "t", "IN", "o", "by", "l", "client", "iter", "con", "ai", " din", "cin", "rin", "input", "re", "net", "reader", "inf", "ind", "thin"], "out": ["obj", "up", "not", "other", "ln", "writer", "full", "it", "Out", "inner", "v", "ex", "nt", "fn", "oe", "w", "outer", "flush", "e", "dis", "aos", "ns", "b", "all", "cos", "io", "one", "conv", "gt", "user", "batch", "res", "ot", "cn", "loss", "op", "t", "en", "at", "o", "ne", "by", "write", "output", "client", "os", "null", "boot", "to", "oss", "end", "co", "con", "outs", "OUT", "na", "list", "net", "note", "can", "n", "ou"], "c": ["character", "cap", "cs", "ch", "ac", "bc", "ec", "char", "cb", "cc", "cd", "arc", "g", "v", "current", "u", "e", "cl", "gc", "i", "k", "f", "uc", "unc", "cont", "cut", "conf", "nc", "code", "t", "lc", "d", "cm", "cf", "l", "sc", "con", "count", "rc", "cr", "ca", "z", "cod", "ce", "cat", "C", "n", "cp", "ct"]}}
{"id1": "3375722", "id2": "14502142", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"importarSetor": [" importatSetors", " importarDatero", " importarStors", " importatSelectero", " importarSelectr", " importarSelector", " importarSelectero", " importarStor", " importarSelectors", " importarDators", " importarSetors", " importarDator", " importarSetero", " importarDatr", " importatSelectr", " importatSelectors", " importatSetor", " importarSetr", " importarStr", " importatSelector", " importatSetr", " importatSetero", " importarStero"], "pArquivoXLS": ["pArquivoEXML", "pArquivoDXCS", "pArquivoDXML", "pArquivoOXls", "pArquiveEXls", "pArquivoOXML", "pArquarioEXML", "pArquivoEXLS", "pArquarioEXLS", "pArquiveEXLS", "pArquivoXXML", "pArquivoDXLS", "pArquarioXLS", "pArquivoXXls", "pArquarioEXCS", "pArquiveXls", "pArquivoXls", "pArquivoOXCS", "pArquiveXML", "pArquarioXML", "pArquivoEXls", "pArquarioXls", "pArquivoTXLS", "pArquiveXLS", "pArquivoTXCS", "pArquivoXCS", "pArquarioEXls", "pArquivoEXCS", "pArquiveEXCS", "pArquivoXXCS", "pArquivoTXls", "pArquivoTXML", "pArquiveXCS", "pArquiveEXML", "pArquivoDXls", "pArquarioXCS", "pArquivoXML", "pArquivoXXLS", "pArquivoOXLS"], "pCabecalhoSetor": ["pCabecalhoStor", "pCabecalhaSetar", "pCabecalhoSetr", "pCabecalhoSetar", "pCabecalhoStter", "pCabecalhoSetter", "pCabecalhaSetter", "pCabecalhoStar", "pCabecalhaSetr", "pCabecalhaSetor", "pCabecalhoStr"], "pAndamento": ["pAndimentO", "pandmentO", "pAndamentos", "pandamentO", "pandamentos", "pAndamentO", "pAndimentos", "pAndamente", "pAndimente", "pAndmente", "pandmente", "pAndmentos", "pAndimento", "pandmento", "pandmentos", "pAndmentO", "pandamente", "pAndementO", "pAndementos", "pAndemento", "pandamento", "pAndemente", "pAndmento"], "iLinha": ["aiLinva", "aiLinzo", "iLu\u00e7a", "iLuzo", "iPlanzo", "iPlanva", "aiLinha", "aiLin\u00e7a", "iLin\u00e7a", "iEn\u00e7a", "iLuva", "iLinzo", "aiPlan\u00e7a", "iEnzo", "iLuha", "aiPlanha", "iPlan\u00e7a", "iEnva", "iPlanha", "iLinva", "aiPlanva", "iEnha", "aiPlanzo"], "stmtLimpezaInicialDestino": ["stmtLimpezaIniciodestination", "stmtLimpezaInicialDestione", "stmtLimpezaInicialEstino", "stmtLimpezaInicioEstin", "stmtLimpezaInicioDestINO", "stmtLimpezaInicioDestino", "stmtLimpezaIniciodestinos", "stmtLimpezaInicioDestinos", "stmtLimpezaInicialdestin", "stmtLimpezaInitalDestione", "stmtLimpezaInicioEstination", "stmtLimpezaInicioEstINO", "stmtLimpezaInitalEstinos", "stmtLimpezaInicialDestINO", "stmtLimpezaInicialDecINO", "stmtLimpezaIniciodestINO", "stmtLimpezaInicialEstin", "stmtLimpezaInicialdestination", "stmtLimpezaInicioDestination", "stmtLimpezaInicioEstino", "stmtLimpezaInicialDecione", "stmtLimpezaInitalDestinos", "stmtLimpezaInicioDestin", "stmtLimpezaInicialDestinos", "stmtLimpezaInicialEstione", "stmtLimpezaInicialdestino", "stmtLimpezaInicialEstinos", "stmtLimpezaInitalEstione", "stmtLimpezaInicialdestinos", "stmtLimpezaInitalDestino", "stmtLimpezaInicialdestINO", "stmtLimpezaInitalDestINO", "stmtLimpezaInicialEstination", "stmtLimpezaIniciodestino", "stmtLimpezaInicialDecino", "stmtLimpezaInicialDestination", "stmtLimpezaInicialEstINO", "stmtLimpezaInicialDestin", "stmtLimpezaInitalEstino", "stmtLimpezaInicialDecinos", "stmtLimpezaInitalEstINO"], "stmtDestino": ["stmtDecino", "stmDestined", "stmtOrigoin", "stmtdestoin", "stmtdestano", "stmtDestoin", "stmpDestinos", "stmdestino", "stmtDescin", "stmdestin", "stmtDestined", "stmtDestination", "stmpDestination", "stmtDescino", "stmpDestoin", "stmtDecination", "stmtOrigination", "stmOrigination", "stmDestination", "stmtDecin", "stmtdestino", "stmtDesination", "stmpOriginos", "stmOrigined", "stmtOriginos", "stmtStinos", "stmDestano", "stmtDecano", "stmtdestin", "stmtStination", "stmpDestino", "stmDestino", "stmtDestano", "stmpOrigoin", "stmtDescined", "stmtdestination", "stmtStoin", "stmtdestinos", "stmDestin", "stmpOrigino", "stmtOrigino", "stmpOrigination", "stmtDescination", "stmdestination", "stmtDesano", "stmtStino", "stmtDesino", "stmOrigino", "stmtDestin", "stmtDesin", "stmtDestinos", "stmdestano", "stmOrigin", "stmtOrigined", "stmtOrigin"], "arquivo": [" arQuivo", " arquive", " araquive", "arquive", " arQuive", "araquiva", " araquario", "arquarius", "rquario", " arquiva", "araquarius", "arqive", "rquivo", "arqiva", " araquiva", " araquivo", "arquario", "arqarius", " arqario", "arqivo", "arquerarius", "raquario", "raquarius", "araquario", "rquarius", "arqario", " arqivo", " arQuario", "arquiva", " arquario", "raquivo", " arQuiva", "rquiva", " arqive", "araquivo", "arqueriva", " arqiva", "raquiva", "arquerivo", "arquerario"], "plan1": ["Plan01", "panel0", "Plan2", " plannerOne", " plan2", "panel1", " plan01", "PlanOne", "plan0", "Plan1", "panel01", "panel2", " planner1", " plan0", " planOne", " planner0", "plan2", "plan01", "planOne", " planner2", "Plan0"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTROs2", "QUANTIDADE_DE_REGISTRANS_", "QUANTIDADE_DE_REGISTEROS2", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTERos_", "QUANTIDADE_DE_REGISTERAS_", "QUANTIDADE_DE_REGISTRAS__", "QUANTIDADE_DE_REGISTERos2", "QUANTIDADE_DE_REGISTROs__", "QUANTIDADE_DE_REGISTRos__", "QUANTIDADE_DE_REGISTRAS2", "QUANTIDADE_DE_REGISTRos2", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTEROS__", "QUANTIDADE_DE_REGISTROS__", "QUANTIDADE_DE_REGISTROS2", "QUANTIDADE_DE_REGISTERos__", "QUANTIDADE_DE_REGISTRos_"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTERosON", "QUANTIDADE_DE_REGISTRATESON", "QUANTIDADE_DE_REGISTRATIONSON", "QUANTIDADE_DE_REGISTEROS2", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTERos_", "QUANTIDADE_DE_REGISTEROSON", "QUANTIDADE_DE_REGISTERos2", "QUANTIDADE_DE_REGISTRosON", "QUANTIDADE_DE_REGISTRATIONS_", "QUANTIDADE_DE_REGISTRAS2", "QUANTIDADE_DE_REGISTRos2", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRIES_", "QUANTIDADE_DE_REGISTROS2", "QUANTIDADE_DE_REGISTROSON", "QUANTIDADE_DE_REGISTRIES2", "QUANTIDADE_DE_REGISTRos_"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTERAS_", "QUANTIDADE_DE_REGISTRATIONS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRIES_", "QUANTIDADE_DE_REGISTRos_"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstipados", "quantidadeDeRegistrosEstimated", "quantidadeDeRegistrosEstifados", "quantidadeDeRegistrosEstifated", "quantidadeDeRegistrosEstimados", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstIMadas", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstipated", "quantidadeDeRegistrosEstIMados", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstIMada", "quantidadeDeRegistrosEstIMated", "quantidadeDeRegistrosEstifadas"], "vSetor": ["vSETar", "valuesSETora", "vSelectero", "vSETor", "valuesSetar", "valuesSetor", "vSelectar", "vEndor", "vSelectora", "vSETora", "valuesSetora", "vSetero", "valuesSETar", "valuesSETor", "vEndora", "vSetar", "vEndero", "vSETero", "valuesSETero", "valuesSetero", "vEndar", "vSetora", "vSelector"], "vSubsetor": ["vSubsetOR", "vSubscriptor", "vSubmento", "vSubseto", "vSubeto", "vSubetOR", "vSubsetation", "vsubseto", "vSubetor", "vSubmentor", "vsubscripto", "vSubmentOR", "vSubscripto", "vsubscriptor", "vSubscriptation", "vsubsetation", "vsubsetor", "vSubscriptOR", "vsubscriptation", "vsubscriptOR", "vSubmentation", "vsubsetOR", "vSubetation"], "vSegmento": ["vSegemento", "vSegMENTao", "vSeggmentao", "vIncremento", "vSegmentO", "vIncrementO", "vIncreemento", "vSegMENTano", "vIncreementao", "vSegMENTO", "vIncreementano", "vSegMENTo", "vSegmentao", "vSegementao", "vIncreementO", "vSegementO", "vSegmentano", "vSeggmentano", "vIncrementano", "vSeggmentO", "vIncrementao", "vSegementano", "vSeggmento"], "registroAtual": ["RegistroATuel", "RegistrosAtomic", "RegistrosAtUAL", "RegistroatUAL", "RegistroAtuel", "RegistrosAtual", "RegistroActuel", "RegistroATual", "RegistroActUAL", "RegistrosAtuel", "RegistroActual", "RegistrosActomic", "RegistroAtomic", "RegistrosActUAL", "RegistroATUAL", "RegistroActomic", "Registroatual", "RegistroAtUAL", "RegistroAtual", "Registroatomic", "RegistrosActual", "Registroatuel", "RegistrosActuel", "RegistroATomic"], "vPapeisPorSegmento": ["vPapeisPorGmentO", "vPapeisPorSegemente", "vPapeisPorSegmentedO", "vPapeisPorGamentO", "vPapeisPorSegmentede", "vPapeisPorGamente", "vPapeisPorGamento", "vPapeisPorSegmentao", "vPapeisPorSegemento", "vPapeisPorGamentao", "vPapeisPorSegmentO", "vPapeisPorGmentao", "vPapeisPorSegementao", "vPapeisPorGmente", "vPapeisPorSegamentao", "vPapeisPorSegementO", "vPapeisPorSegamente", "vPapeisPorSegmente", "vPapeisPorGmento", "vPapeisPorSegmentedao", "vPapeisPorSegamentO", "vPapeisPorSegmentedo", "vPapeisPorSegamento"], "sql": ["mail", "url", "html", "string", "sq", "software", "socket", "statement", "select", "inv", "expr", "xml", "description", "fn", "scl", "expression", "series", "cmd", "json", "wal", "params", "query", "pg", "log", "session", "sys", "sd", "email", "orm", "template", "ql", "pel", "sv", "dl", "security", "spr", "comment", "nl", "cfg", "install", "prefix", "details", "str", "sol", "spec", "condition", "pr", "csv", "rel", "eps", "db", "table", "seed", "s", "js", "SQL", "sp", "ls"]}}
{"id1": "17296916", "id2": "17996547", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"logging": ["debugStorage", "debugger", "debuging", " logger", "logStorage", " logStorage", " loging", "Logging", "loging", "logger", "LogStorage", "debugging", "Loging", "Logger"], "wrap": ["zip", "link", "xf", "wa", "W", "shape", "ws", "x", "find", "message", "nw", "add", "wra", "w", "window", "ow", "pack", "safe", "grow", " wrapped", "start", "pad", "read", "me", "build", "wx", "inter", "aw", "parse", "ad", "box", "root", " wrapper", "wire", "sw", "force", "web", "we", "rap", "form", "ew", "store", "python", "chain", "gate", "create", "wind", "work", "get", "word", "reset", "transform", "sp", "wrapper", "use", "handle", "format"], "buffer": ["attribute", "sequence", "cache", "view", "header", "writer", "display", "document", "message", "memory", "wrapper", "database", "face", "flag", "layer", "surface", "bridge", "builder", "buf", "Buffer", "bb", "append", "profile", "template", "bar", "reference", "library", "button", "queue", "batch", "note", "base", "complete", "report", "command", "trace", "quote", "body", "frame", "store", "console", "buff", "binary", "bo", "phrase", "pb", "table", "output", "line", "iter", "ob", "block", "position", "word", "row", "screen", "reset", "size", "flash", "reply", "print", "directory", "window"], "encoding": ["enclanguage", "enumging", "Encoding", "enaling", "cododer", "ecoded", "enoding", "enoded", "encaling", "enumoder", "enumlanguage", "cryption", "Encoder", "ecoder", "encoded", "enging", "Encaling", "encoder", "enryption", "enoder", "encryption", "Encryption", "enlanguage", "cododing", "codryption", "ecoding", "cododed", "ecryption", "coder", "caling", "clanguage", "enumoding", "encging", "cging", "coding"], "getEncoding": ["getOrigination", "getEncryption", "getOrigoding", "getExpryption", "getEncression", " getEncryption", "getEncination", "getEnryption", "getEnging", " getEncling", "getencling", "getencryption", "getEncging", "getExpression", " getEnoding", " getEncging", "getEnoding", "getencging", " getEnging", "getExpging", " getEnryption", "getOrigling", "getencoding", "getEnling", " getEnression", "getencression", " getEncression", "getEnination", " getEncination", "getEncling", " getEnling", "getOrigryption", "getExpoding", " getEnination", "getEnression", "getencination"], "headers": ["writers", "groups", "fields", "header", "head", "pres", "frames", "ports", "rs", "drivers", "members", "ers", "heads", "users", "values", "params", "reports", "blocks", "comments", "relations", "caps", "keys", "tags", "holders", "authors", "ters", "builders", "pins", "modules", "ids", "ilers", "ppers", "objects", "boxes", "weights", "ctors", "styles", "terms", "chains", "codes", "checks", "limits", "images", "names", "properties"], "is": ["tis", "obs", "ip", "ois", "does", "ri", "iss", "bs", "ui", "si", "isin", "as", "isa", "dis", "sis", "isd", "iso", "sys", "isf", "i", "Is", "ys", "ris", "IS", "\u00eds", "fs", "osi", "bis", "its", "or", "ic", "in", "ios", "isl", "ms", "ims", "ins", "has", "us", "ists", "ais", "iris", "was", "os", "isc", "mis", "isi", "ist", "nis", "lis"], "bos": ["tis", "bits", "bi", "obs", "cs", "ols", "soc", "ts", "bs", "ods", "banks", "ui", "tes", "uts", "ps", "bh", "stats", "boards", "aos", "oops", "cos", "bin", "ys", "sys", "ones", "uds", "ses", "fits", "fs", "oids", "pod", "bis", "bas", "tops", "ios", "bones", "ubis", "ms", "nos", "bo", "bes", "lets", "des", "los", "dos", "os", "eros", "jas", "oss", "js", "windows", "ows", "isi", "ots", "bot", "bytes", "oos"], "e": ["le", "p", "x", "E", "g", "ex", "v", "se", "r", "a", "oe", "ee", "de", "ate", "err", "i", "h", "me", "es", "error", "f", "m", "c", "ge", "t", "en", "er", "eeee", "o", "d", "ne", "exc", "re", "ae", "ie", "ev", "ed", "n"]}}
{"id1": "22441244", "id2": "17557289", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"send": ["mail", "sent", "execute", "msg", "init", "apply", "Send", "message", "add", "submit", "push", "transfer", "parse", "build", "export", "security", "save", "report", "set", "post", "create", "write", "get", "end", "reply", "print"], "hsession": [" HSession", "hhsession", "HSpace", "hship", "hhettings", "rsession", "hessions", "hsessions", "hhession", "hhessions", "hession", "hettings", "rssession", " HSpace", "hssession", "hhip", "rsess", "HSsession", "HSession", "HSessions", "rspace", " HSess", "HShip", "hhhip", "HSettings", " HSsession", "HSess", "hsettings", "hsess", "hspace"], "session": ["name", "cache", "sid", "view", "ip", "parent", "message", "job", "content", "lock", "event", "context", "manager", "password", "ess", "driver", "instance", "Session", "ession", "set", "store", "object", "client", "connection", "account", "document", "state"], "repositoryName": ["repositionNAME", "reposoryName", "repositablename", "repoositoryPath", "repositoryNAME", "repositoryData", "repoositoryName", "reposositoryName", "repositoryPath", "reposositoryData", "reposositoryPath", "repoitoryPath", "repoositoryname", "repositableData", "repoitoryTitle", "reposoryname", "reposositoryTitle", "repoositoryNAME", "repoitoryname", "repositableNAME", "repoitoryNAME", "repoositoryTitle", "repositorNAME", "repositorPath", "repositionPath", "repositorName", "repoitoryName", "reposositoryNAME", "repositoryTitle", "repositionName", "repositorTitle", "reposoryNAME", "reposoryData", "reposositoryname", "repositableName", "repositionTitle", "repoositoryData", "repoitoryData", "repositoryname"], "ideIdint": ["ideIdentint", "ideInfoINT", "ideIDline", "ideIdentline", " ideIdno", "ideidst", "ideThint", " ideThno", "ideDint", "ideDst", "ideIDind", "ideidint", "IDEidINT", "ideThline", "ideThno", " ideThline", "ideIdind", "ideIDno", "ideThind", "IDEidst", "ideIdline", "IDEIdINT", " ideThint", "IDEidint", "IDEIdint", "IDEIdst", "ideInfoint", "ideIdno", "ideIdINT", "ideIdentno", "ideIdentind", " ideIdind", "ideInfost", " ideThind", "ideIdst", "ideIDint", "ideDINT", "ideidINT", " ideIdline"], "to": ["auto", "ato", "eto", "tr", "about", "toc", "target", "tp", "pro", "pos", "tt", "TO", "tel", "top", "too", "phone", "po", "site", "company", "st", "ta", "range", "To", "t", "address", "contact", "no", "o", "by", "client", "os", "route", "co", "topic", "token", "addr"], "cc": ["cs", "cv", "ac", "CC", "ec", "cmp", "cb", "cloud", "cd", "tc", "toc", "cl", "cmd", "ck", "cci", "cca", "ci", "fc", "company", "ic", "ctrl", "ico", "cy", "dc", "cm", "cf", "sc", "cr", "rc", "ca", "co", "cin", "ce", "mc", "ct", "control", "cp", "cn"], "bcc": ["cbcc", "vcc", "sbcy", "cbck", "vck", "rbcy", "rbcm", "rbCC", "rbce", " bCC", "sbcc", "cbCC", "bcy", "bCC", "bck", " bck", "vce", "sbce", "cbcm", "bcm", " bcm", "sbck", "rbcc", "vcy", "bce", "rbck"], "subject": ["mail", "name", "metadata", "html", "header", "head", "description", "message", "content", "title", "Subject", "face", "source", "filename", "author", "host", "template", "id", "comment", "security", "uri", "form", "prefix", "heading", "text", "topic", "note"], "body": ["mail", "name", "zip", "url", "response", "html", "other", "any", "head", "shell", "news", "part", "back", "inner", "description", "bh", "message", "content", "title", "json", "params", "source", "b", "query", "buffer", "layout", "ody", "h", "data", "template", "padding", "default", "top", "files", "comment", "base", "report", "object", "post", "parts", "text", "code", "summary", "binary", "bill", "no", "output", "line", "null", "ODY", "inline", "background", "hex", "note", "business", "bytes", "handle", "Body"], "attachments": ["achmenttypes", "Attachresses", "attachachment", "achmentachment", "attments", "achmentresses", "achmentments", "attachtypes", "atttypes", "Attachtypes", "Attachments", "attachresses", "Attachachment", "attresses"], "isHtml": ["isChtml", " isWhtml", "isChip", " isHhtml", "ishap", " isWhHTML", "isVtml", "ishttp", "ishhtml", "isHttp", " isHip", "isHHTML", "isWhhtml", "isHap", "isHip", "isChhtml", "isChHTML", "IsHap", "isVHTML", "IsHttp", "isWhHTML", "IsHtml", "isWhip", "isJhtml", "isVip", " isWhip", "ishtml", "isJttp", " isWhhtml", "isVhtml", "isHhtml", "isJap", " isHHTML", "isJtml", "IsHhtml", "isWhtml"], "charset": ["CHippet", "chatsetter", "chippale", "charpetic", "chippET", "chARSets", "CHarsets", "quatsec", "CharsET", "charsale", "clarspace", "chablesec", "charpetter", "chersets", "chacterspace", "ChARSet", "quarsetter", "chARSet", "quatsetter", "chatsale", "chARSpace", "quarset", "charspace", "chippec", "CHarset", "channelsetic", "quatsale", "channelsET", "charsets", "chablesale", "chippets", "charpets", "charpET", "quarsec", "chippet", "charsec", "clarset", "charpet", "chersetter", "CHarsET", "CHippett", "ChARSetic", "Charset", "chARSetic", "CHippET", "clerset", "chacterset", "chARSetter", "Charsetter", "clarsets", "charsetter", "cherspace", "CHarsett", "charsett", "ChARSET", "clersets", "chactersetter", "ChARSetter", "quarsale", "cherset", "chatsec", "chablesetter", "charsET", "Charsetic", "charsetic", "clerspace", "clarsetter", "chactersets", "chippetter", "chARSET", "CHippets", "channelsetter", "channelset", "clersetter", "chableset", "chippett", "quatset", "chatset", "charpett"], "headers": ["metadata", "fields", "header", "head", "lines", "members", "ers", "heads", "users", "params", " heads", "relations", "comments", "keys", "authors", "ters", "files", " trailers", "ilers", "ppers", "details", "types", "ors", "codes", "limits", "names", "dr"], "priority": ["origin", "state", "order", "primary", "description", "title", "pos", "comments", "context", "profile", "password", "id", "phone", "security", "company", "status", "prefix", "serial", "grade", "policy", "position", " urgency", "flags", "due", "level", " severity", "properties"], "email": ["mail", "delete", "link", "url", "ell", "response", "view", "msg", "html", "die", "liner", "domain", "enter", "model", "external", "server", "shell", "initial", "document", "xml", "description", "fax", "gmail", "message", "sample", "entry", "Email", "oe", "database", "e", "detail", "label", "ee", "event", "all", "log", "ssl", "template", "password", "example", "call", "echo", "result", "ome", "comment", "il", "search", "report", "el", "http", "company", "instance", "object", "office", "console", "address", "element", "contact", "er", "test", "ne", "voice", "output", "line", "ilo", "license", "em", "et", "reset", "print", "note"], "user": ["name", "util", "ip", "User", "system", "auth", "owner", "usage", "entity", "users", "admin", "uid", "author", "profile", "me", "manager", "match", "id", "result", "person", "actor", "from", "login", "usa", "browser", "usr", "by", "client", "output", "USER", "creator", "account", "connection", "ident", "student", "used", "username", "use", "human"], "identity": ["entularity", "IDENTularity", "presentularity", "ethnicitate", "IDENTentity", "IDENTality", "identality", "primance", "recognance", "presentitate", "equity", "solidity", "ethnicentity", "IDENTicate", "personicate", "primentity", "personificate", "entity", "IDENTity", "instity", "IDENTance", "IDENTITY", "solidality", "recognentity", "identalty", "identator", "idiciary", "identiciary", "personity", "idality", "instator", "solidentity", "recognicate", "recognity", "idity", "instalty", "identicate", "idententity", "primicate", "ethnicity", "IDENTificate", "identITY", "personITY", "IDENTitate", "instentity", "primificate", "IDENTator", "identance", "identificate", "identifier", "ethnicularity", "IDENTifier", "identularity", "presententity", "ententity", "instularity", "solidularity", "personentity", "presentity", "IDENTalty", "entifier", "primity", "identitate", "equalty", "personiciary", "IDENTiciary", "idularity", "instifier", "idITY", "equentity", "equator"], "_returnPath": [" _returnAddress", "_returnName", "setsavepath", "_retPath", "_requestPoint", " _returnPoint", "_errorPath", " _errorPath", "setreturnpath", "_retpath", "setsaveTo", "setreturnUrl", "setreturnTo", "_errorUrl", "_ReturnAddress", " _errorAddress", "setreturnPath", "_returnCode", "_returnAddress", "_returnLocation", "_returnTo", "_deletePath", "_retPoint", "_retLocation", "_retUrl", "_errorAddress", "_savepath", "_replyPath", "_retTo", "_getTo", " _errorName", "_returnpath", "_replyDir", "_returnDir", "_saveTo", "_errorName", "_requestName", "_requestPath", "_ReturnName", "_requestAddress", "_resultTo", "_deleteTo", "_errorTo", " _returnName", " _errorPoint", "_replyCode", "_getDir", "_resultLocation", "_returnUrl", "_deletepath", "_ReturnPoint", "_errorpath", "_resultPath", "_retCode", "_getCode", "_savePath", "setsaveUrl", "_ReturnPath", "setsavePath", "_resultPoint", "_getPath", "_retDir", "_errorPoint", "_saveUrl", "_errorLocation", "_deletePoint", "_returnPoint"], "_from": ["longto", " _source", "letfrom", "_reset", "_addr", "\tauthor", "remaddr", "\tform", "_author", " _form", "remfrom", "longreset", "longfrom", "letto", "_about", " _actor", "_source", "remowner", "letabout", "\tfrom", "remlocal", "longsource", " _reset", "_local", "_owner", "_actor", " _author", "\tactor", " _about", "_form", "letsource"], "_replyTo": ["_closeTO", "_closeOf", "_ReplyTO", "_commentLine", "_returnTO", "_replyTO", "_replyLine", "_replyFrom", "_respondTo", "_responseFrom", "_commentTO", "_replyOf", "_respondTO", "_returnFrom", "_commentTo", "_ReplyTo", "_responseTo", "_responsePath", "_respondFrom", "_returnOnly", "_returnTo", "_backTo", "_responseLine", "_responseTO", "_backFrom", "_commentOf", "_closeTo", "_respondOnly", "_ReplyPath", "_replyPath", "_backPath", "_closeLine", "_ReplyFrom", "_ReplyOnly", "_replyOnly", "_responseOf", "_backTO"], "_to": ["_ta", "successta", "successtopic", "prisite", "successto", "prita", "pritopic", "prito", "successsite", "_topic", "_site"], "_cc": [" _cca", " _subject", " _cs", "_cs", "_subject", "_cca"], "_bcc": ["_rbcc", "_racc", "_wck", "_rbacc", "_wca", "_wcc", "_bca", "_bacc", "_wacc", "_rbck", "_rcc", "_rca", "_bck", "_rbca", "_rck"]}}
{"id1": "1586662", "id2": "19608872", "code1": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "code2": "    public void genDropSchema(DiagramModel diagramModel, boolean foreignKeys) {\n        try {\n            con.setAutoCommit(false);\n            stmt = con.createStatement();\n            Collection boxes = diagramModel.getBoxes();\n            BoxModel box;\n            String sqlQuery;\n            if (foreignKeys) {\n                for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                    box = (BoxModel) x.next();\n                    if (!box.isAbstractDef()) {\n                        dropForeignKeys(box);\n                    }\n                }\n            }\n            int counter = 0;\n            for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                box = (BoxModel) x.next();\n                if (!box.isAbstractDef()) {\n                    sqlQuery = sqlDropTable(box);\n                    System.out.println(sqlQuery);\n                    try {\n                        stmt.executeUpdate(sqlQuery);\n                        counter++;\n                    } catch (SQLException e) {\n                        String tableName = box.getName();\n                        System.out.println(\"// Problem while dropping table \" + tableName + \" : \" + e.getMessage());\n                        String msg = Para.getPara().getText(\"tableNotDropped\") + \" -- \" + tableName;\n                        this.informUser(msg);\n                    }\n                }\n            }\n            con.commit();\n            if (counter > 0) {\n                String msg = Para.getPara().getText(\"schemaDropped\") + \" -- \" + counter + \" \" + Para.getPara().getText(\"tables\");\n                this.informUser(msg);\n            } else {\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage() + \" // Problem with the JDBC schema generation! \");\n            try {\n                con.rollback();\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection rollback! \");\n            }\n        } finally {\n            try {\n                con.setAutoCommit(true);\n                stmt.close();\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection disconnect! \");\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doOne": ["DoOne", " do1", " doApp", "doOnce", "DoApp", " DoApp", "DoOnce", " DoOnce", " doOnce", "do1", " DoOne", "doApp", "Do1", " Do1"], "bid": ["bi", "bn", "sid", "fed", "bc", "tx", "bus", "bs", "cb", "oid", "hid", "bh", "mid", "hn", "sb", "rid", "bat", "berry", "b", "uid", "bd", "bin", "fin", "bb", "bank", "based", "id", "batch", "base", "bis", "bf", "bas", "buy", "bm", "db", "wid", "bt", "pid", "sat", "did", "wed", "vid", "ind"], "tid": [" tide", "ttid", "Tpid", "Tidem", " tids", " tidem", "intidem", "tide", "ppid", "prid", " tpid", "pbid", " tbid", "trid", "pids", "ttbid", "intide", "Tbid", "tId", " tId", "pId", "intid", "tidem", "intId", "Tide", "Tid", "ttrid", "ttids", "tbid", " trid", "tpid", "TId", "tids", "pid"], "aid": ["said", "sid", "ace", "aud", "cas", "ac", "wan", "am", "activity", "ance", "bind", "auth", "oid", "ant", "a", "mid", "ab", "acc", "uid", "sys", "alias", "tt", "ared", "kid", "ad", "bb", "aw", "aic", "bank", "pa", "ar", "antis", "id", "van", "dev", "med", "ard", "aida", "da", "ity", "ta", "aa", "alpha", "authorized", "lay", "card", "ay", "ida", "sn", "lan", "esa", "ma", "pid", "ca", "sat", "na", "ae", "af", "dd", "did", "iat", "ident", "ia", "Aid", "aka", "vid", "hd", "sha"], "delta": ["adelt", "felt", "dapter", "delt", " delt", "sdacl", "detime", " dacl", "Delt", " dbid", "rta", " duration", "dacl", "dbid", "dta", " detime", "Dapter", "fapter", "sdelta", "adota", "relta", "furation", "retime", "Delta", " dapter", "dota", "adacl", " dta", "sdota", "rota", "fota", "adelta", "duration", "felta", "relt", "dabid", "Dota", "adetime", "Duration", "Dbid", "sdelt", "Dta", " dota"], "aBalance": ["eBalance", " aAmount", "eAmount", "aAmount", "caBalance", "aaStatus", "caDelta", "aDelta", " aDelta", "aStatus", "ATransfer", "aaAmount", "aTransfer", " abalance", "ABal", "aStock", "caStock", "aaBal", "sabalance", "eBal", "saStock", "saDelta", "ABalance", "aBal", "Abalance", "aaTransfer", "cabalance", " aBal", "aaBalance", "eStatus", "abalance", " aStock", " aStatus", "aabalance", "saBalance", " aTransfer"], "RS": ["KS", "WS", "RO", "RW", "RES", "NS", "RP", "R", "TS", "ADS", "US", "rs", "ILS", "PS", "HR", "CS", "ALS", "OSS", "SS", "DS", "RM", "GS", "RD", "NRS", "OS", "RC", "VR", "IS", "Res", "DR", "RT", "LS", "VS", "RR", "HS", "ATS", "YS", "MR", "RB", "GC", "RE", "Rs", "FS", "MS", "USER", "SR", "ERS", "BS", "PRES", "ARS", "JS"], "Stmt": [" stmp", "STmp", "Stm", " Stmp", "stMT", "stmm", "STm", " stmt", "STMT", "Stmm", " StMT", " stm", "stmp", "stmt", "Stmp", "STmt", " Stmm", " stMT", "StMT", "STmm", "stm", " Stm"], "Query": ["Module", "Message", "Lock", "URI", "Wait", "Code", "Clean", "Chain", "Exp", "Package", "Make", "QL", "Spec", "Policy", "Host", "Str", "Size", "Version", "Link", "IQ", "Report", "General", "Send", "Unit", "Action", "Menu", "Fix", "Q", "Notice", "Rule", "Question", "Script", " query", "SQL", "Function", "Core", "Format", "Statement", "When", "Template", "Request", "query", "Activity", "Command", "Find", "Form", "Update", "q", "Service", "Description", "And", "Force", "Get", "Call", "Event", "Body", "Check", "Post", "Config", "Comment", "Init", "Qu", "Line", "Do", "Remote", "Filter", "Test", "Term", "ERY", "Where", "Conn"], "res": ["resh", "Cons", "cons", "conn", "RES", "resp", "ret", "rs", "ns", "results", "val", "Res", "ptr", "rez", "result", "VAL", "rows", "cond", "ares", "set", "sol", "vals", "ress", "req", "rc", "row", "re", "ows"]}}
{"id1": "6371589", "id2": "17116123", "code1": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 1, "substitutes": {"insertUser": ["addPerson", "addAccount", "addUser", "insertPerson", "InsertPerson", "InsertUser", "addUsers", "insertAccount", " insertAccount", "InsertUsers", "insertUsers", " insertUsers", "InsertAccount", " insertPerson"], "newUsers": ["latestIDs", " NewPosts", "New", " newVersions", "newVersions", " NewStudents", " newPosts", " NewIDs", "NEWStudents", "newsUsers", " newusers", "newusers", "givenUsers", "givenVersions", "givenusers", " NewUsers", "newStudents", "_", "newIDs", "newsVersions", "newsPosts", "Secure", "latestStudents", "NEWIDs", "latestPosts", "NEWUsers", "newPosts", "latestUsers", "newsusers", "NEWPosts", "givenPosts"], "pass": ["access", "use", "conn", "ass", "pp", "pl", "p", "cross", "PASS", "auth", "wd", "pool", "def", "fail", "ps", "add", "ack", "pillar", "allow", "pg", "params", "pos", "session", "par", "priv", "prop", "push", "parse", "password", "crit", "save", "res", "pas", "conf", "Pass", "hash", "post", "miss", "oss", "skip", "na", "cat", "dr", "col"], "realmPass": ["RealgmPass", "calmAct", "balmiCat", "realmnPass", "realamAdd", "realimCat", "realmAss", "balmCat", "balmiDrag", "balmiPass", "realmspass", "realnPass", "balmDrag", "Realgmpass", "realgmFail", "realgmpass", "realmsPass", "realampass", "realmsAct", "realmiCat", "RealamCat", "balmipass", "realimAdd", "realemFail", "balmpass", "RealmAdd", "calmsAct", "realrpass", "realmsCat", "realmnCat", "calmsPass", "Realmpass", "realmAct", "realgmAdd", "realimPass", "calmPass", "balmPass", "realemAdd", "realemPass", "realmsAss", "RealmCat", "realgmAct", "realnpass", "RealamAdd", "realnCat", "calmsAdd", "realrAct", "RealgmFail", "realamPass", "RealmPass", "realmFail", "realmpass", "RealgmAdd", "realempass", "RealmFail", "realmnDrag", "realmnpass", "realmCat", "realamFail", "realnDrag", "realmsAdd", "realmiPass", "RealmAss", "realamCat", "realmAdd", "realrPass", "realrAdd", "realmDrag", "RealamPass", "calmspass", "realmiDrag", "calmpass", "realgmPass", "realamAss", "realmipass", "realimAss", "RealamAss", "calmAdd"], "userDirs": [" userDirir", "userDs", " userDns", "userDirir", "userPaths", "userPathns", " userDir", " userDirns", "userDns", " userDs", "userPathirs", " userDirirs", "userDir", "userDirns", "userDirirs", "userPathir"], "iter": ["orient", "ter", "inc", "li", "ip", "altern", "tr", "del", "rer", "it", "ver", "itter", "inner", "loader", "ator", "ait", "info", "kit", "iz", "outer", "train", "ipper", "ir", "i", "here", "err", "iner", "ci", "inter", "next", "ptr", "gener", "il", "maker", "coll", "el", "valid", "peer", "ner", "range", "ser", "spec", "er", "fer", "loc", "loop", "test", "vis", "ill", "Iter", "exec", "skip", "hex", "oper", "reader", "ind", "iv"], "user": ["info", "device", "from", "form", "store", "browser", "bo", "core", "self", "player", "used", "other", "User", "version", "part", "display", "message", "menu", "entity", "users", "event", "author", "resource", "error", "result", "project", "person", "body", "rule", "contact", "usr", "by", "component", "USER", "account", "row", "use", "volume", "ver", "confirmed", "usage", "job", "u", "vote", "query", "me", "profile", "record", "password", "dev", "comment", "usa", "time", "or", "object", "post", "test", "module", "term", "creator", "uu", "owner", "ter", "parent", "system", "per", "char", "entry", "file", "date", "match", "plugin", "role", "status", "check", "item", "us", "pre", "client", "open", "word", "student"], "realm": [" realmi", "schem", "ralc", "rems", "ralms", "palms", "schemi", "rec", "palm", "schemin", "chemn", " realmin", "realmn", "calmo", "chemi", "reall", "realc", "calmi", "calM", "rem", "trm", "trc", "ralm", " realgm", "trl", "Realmn", "Realmo", "realmi", "Realm", "realmo", "chem", " realmo", "palmi", "rall", "realgm", "rel", "RealM", "schems", "calgm", "realmin", "realM", "Realgm", "trms", "Realmi", "palmin", "calmn", "cheM", "calm"], "username": ["metadata", "master", "subject", "number", "successful", "month", "phone", "uri", "monitor", "ame", "platform", "dn", "river", "directory", "aka", "name", "url", "journal", "NAME", "uno", "approximately", "via", "title", "rue", "source", "utm", "method", "person", "displayText", "prefix", "language", "summary", "usr", "component", "family", "account", "token", "utf", "attribute", "kin", "localhost", "target", "unknown", "database", "json", "currency", "gender", "filename", "twitter", "information", "profile", "pron", "password", "batch", "mass", "sword", "java", "today", "frequency", "ername", "history", "output", "term", "seat", "href", "owner", "human", "character", "initial", "software", "description", "wordpress", "mobile", "uid", "sudo", "network", "minimum", "email", "login", "impact", "status", "instance", "latest"], "ph": ["eph", "php", "pl", "hp", "pha", "pp", " ep", "alph", "ch", "wh", "p", "phi", "pal", "tch", "sh", "aph", "fo", "dh", "prof", "uph", "gh", "eth", " pl", "her", "h", " perf", "eh", "kh", "PH", "arch", "ah", "pas", "phil", "ih", "prot", "hm", "iph", "pr", "rh", "pkg", "uth", "oth", "pt", "mph", "th", "pi", "ht", "phy", "mk", "oh", "Ph", "pd"], "realms": ["Realms", "alm", "realns", "Realents", "rems", "realents", "tenmes", "remins", "remes", "rens", "tenarms", "rem", "Realarms", "alarms", "tenms", "trns", "Realmins", "alents", "alms", "Realm", "Realns", "trarms", "realarms", "almes", "realmes", "trmins", "realmins", "trms", "Realmes", "tenents", "rearms"], "realmName": ["realrId", "realmcNames", "realrName", "realrNames", "almName", "realmiSpec", " realmType", "realmoName", "realmNames", "almId", "realrSpec", "realmcType", "almNames", "alrId", "realmoSpec", " realcNames", "alrSpec", "realmiId", " realcType", "alrName", "alrNames", "realmoNames", "realcFull", " realmNames", " realcName", "realarmName", " realmFull", "realmSpec", "realmoId", "realmId", "realmiNames", "realcType", "realarmNames", "realmType", "realarmFull", "realmcFull", "realarmType", " realcFull", "realmiName", "realcName", "almSpec", "realmFull", "realcNames", "realmcName"], "psImpl": ["pseimpl", "dsimpl", "psInstance", "psStr", "pseStr", "dsInstance", "dsStr", "pseImpl", "persInstance", "psimpl", "pseInstance", "dsImpl", "persimpl", "persImpl", "persStr"], "iterator": ["sequence", "ter", "operator", "inner", "stream", "order", "loader", "ator", "current", "integer", "values", "walker", "Iterator", "information", "next", "result", "vector", "trace", "instance", "set", "collection", "history", "runner", "size", "wrapper"]}}
{"id1": "23398710", "id2": "293167", "code1": "    public String getUser() {\n        try {\n            HttpGet get = new HttpGet(\"http://api.linkedin.com/v1/people/~\");\n            consumer.sign(get);\n            HttpClient client = new DefaultHttpClient();\n            HttpResponse response = client.execute(get);\n            if (response != null) {\n                int statusCode = response.getStatusLine().getStatusCode();\n                if (statusCode != 200) {\n                    this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n                }\n                StringBuffer sBuf = new StringBuffer();\n                String linea;\n                BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), \"UTF-8\"));\n                while ((linea = reader.readLine()) != null) {\n                    sBuf.append(linea);\n                }\n                reader.close();\n                response.getEntity().consumeContent();\n                get.abort();\n                String salida = sBuf.toString();\n                String user_firstname = salida.split(\"</first-name>\")[0].split(\"<first-name>\")[1];\n                String user_lastname = salida.split(\"</last-name>\")[0].split(\"<last-name>\")[1];\n                return user_firstname + \" \" + user_lastname;\n            }\n        } catch (UnsupportedEncodingException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (IOException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthMessageSignerException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthExpectationFailedException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthCommunicationException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        }\n        return null;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"getUser": ["getNick", " getuser", "setUser", " getNick", "createuser", "setuser", "createAccount", "createNick", " getAccount", "setAccount", "getuser", "createUser", "getAccount", "setNick"], "get": ["remote", "delete", "util", "url", "cache", "handle", "find", "this", "put", "g", "message", "getting", "entity", "gets", "download", "e", "query", "gm", "start", "resource", "read", "build", "parse", "give", "call", "GET", "uri", "github", "force", "send", "http", "q", "body", "set", "service", "post", "ge", "check", "play", "create", "pre", "got", "open", "request", "connection", "exec", "pull", "Get", "show", "self", "print"], "client": ["remote", "cache", "server", "conn", "ip", "this", "tc", "Client", "connect", "cli", "cl", "query", "network", "resource", "secure", "city", "io", "context", "call", "c", "http", "console", "service", "collection", "google", "api", "contact", "https", "create", "cm", "con", "connection", "request", "co", "net", "wrapper", "control"], "response": ["remote", "yes", "cache", "server", "answer", "image", "resp", "still", "version", "xml", "description", "message", "entry", "wrapper", "e", "json", "value", "success", "event", "source", "given", "pos", "network", "session", "ve", "channel", "next", "es", "function", "data", "respond", "one", "close", "example", "result", "application", "exit", "successful", "see", "res", "report", "send", "http", "site", "page", "status", "trace", "onse", "body", "Response", "service", "collection", "output", "open", "block", "connection", "request", "ce", "reset", "reply", "document", "window"], "statusCode": ["StatusTree", "magicLine", " statusCount", "magicName", "StatusLength", "postLine", "postcode", "messageCount", "StatusCode", " statusName", "magicCode", " statusLength", "statusName", " statuscode", "messageTree", " statusLine", "postCode", "statusLength", "magiccode", "statuscode", "postName", "messageLength", " statusTree", "messageCode", "statusTree", "statusLine", "StatusCount", "statusCount"], "sBuf": [" sBob", " sBfg", "sBluf", " sOBuf", "sOBob", "sOBuf", "sOBdf", "sBlbuf", "sBufffg", " sBbuf", " sBbuff", " sOBbuf", "sABbuf", "sBfg", " sOBdf", "sBuffbuff", "sBlfg", "sBuffbuf", "sBbuff", "sBuffdf", " sOBbuff", "sBbuf", "sABbuff", "sABuf", "sOBbuf", "sABob", "sBdf", " sOBob", "sOBbuff", " sBdf", "sBob", "sBuffuf"], "linea": ["lineea", " linealpha", "linA", " LINEA", "linkea", "linja", " lineea", "linkja", "lineA", "linkA", "lineja", "ineja", "linealpha", " LINEa", "Linealpha", "ineea", "lineas", "ineae", " LINEalpha", "Linea", "linkas", " LINEea", "LineA", "lineae", " lineas", " linee", "linka", "line", "linas", "linee", "inea", "lina", "linae", "Lineea", "linkae", " lineA", "linke"], "reader": ["then", "iterator", "writer", "image", "per", "older", "reading", "inner", "stream", "loader", "r", "entry", "rx", "file", "source", "buffer", "resource", "read", "parser", "builder", "rar", "data", "roller", "handler", "driver", "ner", "body", "rl", "ser", "collection", "Reader", "er", "ro", "upper", "iter", "row", "runner", "input", "dd", "field", "wrapper", "handle"], "salida": ["talanca", "salaria", "alida", "Salardo", "talida", "alanca", "Salanca", "altista", "alido", "sqlida", "talido", "Saliga", " salido", "Salida", "salardo", "sqlido", "altanca", "salista", "alista", "slida", "salido", "altido", "slista", "Salaria", "taliga", "slido", "sqlanca", "Salido", "salanca", "talaria", "slanca", " salaria", "sqlardo", "talardo", "altida", " saliga", "saliga"], "user_firstname": ["user__lastn", "user_firstame", "user_lastame", "user_firstno", "user_mostame", "user_firstmin", "user_lastmin", "user_firstuser", "user_Firstmin", "user__lastname", "user_fullno", "user_lastuser", "user_fullame", "user_fullmin", "user_Firstame", "user_mostno", "user_firstn", "user__lastno", "user_fulluser", "user__lastame", "user__firstno", "user_mostname", "user_Firstname", "user__firstame", "user_Firstuser", "user_fulln", "user_fullname", "user__firstn", "user_lastn", "user_mostn", "user_lastno", "user__firstname"], "user_lastname": ["user_fullName", "user_firstame", "user_lastame", "user_fullnames", "user_secondname", "user_secondName", "user_fullno", "user_longno", "user_fullame", "user_lastnames", "user_longame", "user_secondame", "user_firstnames", "user_firstName", "user_longnames", "user_longName", "user_longname", "user_fullname", "user_lastno", "user_lastName", "user_secondno"]}}
{"id1": "8747840", "id2": "339517", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["delete", "link", " mirror", " Copy", "add", "download", "gc", " replicate", "read", "transfer", "map", "sync", "save", "clip", "slice", "create", " cp", "move", "load", "csv", "clone", "write", "paste", "Copy", " copying", "cat", "cp", "upload"], "src": ["Source", "sec", "obs", "init", "inst", "sq", "bs", "sin", "rs", "via", "sr", "sb", "rx", "syn", "source", "start", "sys", "sit", "ipl", "txt", "from", "cont", "ctr", "st", "img", "cur", "sur", "sf", "ser", "urg", "ins", "usr", "rel", "pkg", "sc", "req", "rc", "input", "iv"], "dest": ["origin", "est", "orig", "nom", "del", "Dest", "master", "nt", "nw", "target", "mm", "temp", "deg", "source", "opt", "sit", "tmp", "gt", "cont", "way", "pas", "good", "st", "spec", "https", "loc", "test", "usr", "d", "des", "null", "req", "pub", "dist", "end", "trans", "th", "self", "rest", "mk", "decl"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "it", "ain", "inner", "isin", "old", "din", "info", "mm", "ze", "source", "bin", "i", "gin", "on", "id", "from", "In", "ic", "impl", "ins", "inside", "en", "IN", "con", "iter", "ai", "rc", "cin", "rin", "input", "ar", "inf", "ind"], "out": ["auto", "obj", "not", "ch", "conn", "writer", "p", "it", "Out", "inner", "g", "ex", "nt", "aos", "outer", "dis", "sys", "bin", "err", "io", "conv", "gt", "on", "res", "sum", "ot", "t", "en", "at", "o", "ne", "by", "write", "output", "client", "con", "os", "to", "oss", "end", "co", "over", "outs", "OUT", "net", "can", "n", "ou"], "buf": ["cap", "msg", "cv", "bus", "bs", "cb", "mb", "bh", "bl", "seq", "temp", "cmd", "b", "bed", "buffer", "log", "prop", "uf", "Buffer", "data", "conv", "bar", "col", "box", "gen", "tab", "queue", "batch", "arr", "cam", "mu", "good", "br", "fg", "str", "bag", "Buff", "buff", "ref", "pkg", "vec", "db", "block", "rb", "fb", "cat", "used", "aka", "bytes", "stab"], "c": ["cache", "cs", "ch", "ac", "bc", "ec", "cb", "cc", "cd", "a", "dec", "gc", "b", "jc", "cos", "i", "k", "ci", "call", "fc", "uc", "m", "unc", "cont", " C", "conf", "nc", "cu", "t", "code", "lc", "dc", "d", "cm", "l", "cf", "count", "cr", "rc", "co", "z", "ca", "cod", "ce", "mc", "C", "n", "cp", "ct"]}}
{"id1": "18374478", "id2": "17116123", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 1, "substitutes": {"updateUser": ["insertUser", "uploadUse", "uploadCommon", "gePer", "setUser", "setuser", "insertAccount", "geUser", " updateMe", "putUse", "updateByte", "updateOne", "insertGroup", " updateByte", " updateCommon", " updateUSER", "setUse", "geuser", "uploadMe", " updateAccount", "putUser", "updateGroup", "UpdateAccount", "setPer", " updateUse", "geUse", "UpdateUsers", "updateUse", "makeByte", "putOne", "putUSER", " updateOne", "updateUSER", "UpdateGroup", " updatePer", "updateCommon", "uploadUser", "makeUsers", "updateUsers", "putUsers", "putuser", " updateUsers", "updateAccount", "uploadUsers", "updateuser", " updateuser", "makeUser", " updateGroup", "updatePer", "updateMe", "insertUsers", "uploadUSER", "putMe", "putCommon", "makeOne", "UpdateUser", "putByte", "uploaduser"], "user": ["name", "util", "up", "other", "key", "User", "version", "ver", "per", "part", "char", "display", "this", "order", "v", "usage", "message", "add", "info", "device", "job", "content", "u", "users", "file", "config", "admin", "uid", "update", "author", "resource", "host", "me", "profile", "record", "data", "password", "result", "plugin", "base", "usa", "report", "sum", "valid", "form", "instance", "object", "post", "item", "rule", "usr", "by", "module", "table", "client", "get", "word", "USER", "account", "ud", "connection", "row", "re", "token", "used", "username", "use", "owner"], "conn": ["port", "link", "obj", "die", "enc", "info", "cmd", "cont", "res", "conf", "quote", "cur", "bo", "dc", "cf", "ctx", "Con", "pt", "req", "Connection", " con", "yn", "bind", "act", "cb", "pool", "cc", "org", "apt", "wn", "gc", "iw", "oc", "coll", "cfg", "ctr", "com", "con", "connection", "oss", "exec", "pub", "ce", "net", "mt", "col", "addr", "tp", "cn", "cons", "cert", "resp", "comm", "nt", "err", "ssl", "conv", "gen", "c", "pas", "nc", "gate", "out", "pkg", "cm", "db", "dt", "co", "cat", "mc", "ct", "handle", "ch", "socket", "wd", "typ", "ns", "connect", "pg", "wr", "log", "priv", "close", "lang", "t", "jp", "rel", "open", "client", "wp", "ann", "Conn", "n", "cp"], "autoCommit": ["AutoDebit", "AutoCommort", "anoActivort", "autoCollmit", "autoRemend", " autoCommend", "autoDeblate", "AutoCommmit", "anoActivmit", "autoCollit", "autoComort", "autoDebort", " autoCompe", "anoActivit", " autoCompit", "autoComme", "AutoDebmit", "autoCollcommit", " autoComme", " autoCompmit", "autoActivmit", "autoCompend", "anoCommlate", " autoCompend", "autoQue", "autoComlate", "AutoCommcommit", "autoQumit", "autoCommmit", "anoCommit", "autoReme", "autoActivort", "AutoDebcommit", "autoComcommit", "autoDebit", "autoRemit", "autoCollort", "autoCommort", "autoCommcommit", "autoComit", " autoCommmit", "autoCompit", "AutoCommit", "autoDebmit", "autoCommlate", "AutoDebort", "autoQuend", "anoActivlate", "autoRemmit", "anoCommort", "anoCommmit", "autoCompe", "autoDebcommit", "autoQuit", "autoCommend", "autoCompmit", "autoActivit", "autoActivlate"], "deleteRoles": ["deleteToles", " deleteRoids", "deleteNroups", "deleteRadles", " deleteResols", "deleteResoids", "deleteRoids", "deleteRols", "deleteRanguages", "deleteRroups", "deleteTules", "deleteEroids", "deleteEroles", "deleteGroups", "detailCorroups", "deleteNols", "deleteGles", " deleteResroups", "deleteCorules", "deleteRadols", " deleteResles", " deleteRroups", "detailCoranguages", "deleteCoroles", "deleteRadoles", "deleterroups", "detailRules", "deleteNles", "deleteResols", "deleteRules", "deleteCorroups", "deleteRadoids", "deleteErols", " deleteRols", " deleteResoles", "deleteRles", "deleteResles", "detailRoles", "deleteCoranguages", "detailRanguages", "deleteroles", "deleteTroups", "deleteErles", "deleteranguages", " deleteRles", "deleteResoles", "deleteGols", "deleteGoles", " deleteResoids", "deleterules", "detailRroups", "detailCoroles", "detailCorules", "deleteNoles", "deleteTanguages", "deleteResroups"], "insertRoles": ["sequenceRrots", "insertNodes", "InsertRhips", "insertRsrots", "insertRobels", "insertRobles", "insertPodes", "insertRrots", "insertResoles", "insertCights", "insertReplroups", "sequenceRobles", "insertResles", "deletePodes", "insertCodes", "insertPights", "insertRhips", "insertColes", "sequenceRoles", "insertLiders", "insertLoles", "insertReploles", "insertRows", "stepReplodes", "insertRsoles", "insertReships", "insertRsles", "insertRights", "deletePoles", "InsertRles", "deleteRows", "insertNoles", "insertRepliders", "deletePights", "insertLroups", "insertRodes", "insertLodes", "insertGiders", "sequenceRles", "insertNhips", "stepRodes", "insertRsels", "stepRroups", "InsertRodes", "insertGodes", "insertRles", "insertCows", "insertNles", "sequenceRobrots", "insertReplodes", "stepReplroups", "insertRels", "insertRroups", "deleteRodes", "insertRoboles", "deleteRights", "insertResodes", "sequenceRoboles", "stepRoles", "insertRiders", "deletePows", "insertPoles", "sequenceRels", "insertGroups", "insertGoles", "stepRiders", "stepReploles", "insertPows", "InsertRoles", "sequenceRobels", "stepRepliders", "insertRobrots"], "role": ["le", "hole", "part", "char", "def", "r", "entry", "slave", "oval", "label", "node", "resource", "ole", "profile", "password", "right", "type", "rol", "peer", "cell", "tro", "te", "feature", "rl", "range", "office", "tag", "rice", "country", "rule", "zone", "ro", "relation", "rel", "word", "family", "ule", "block", "row", "Role", "ce", "hero", "aco", "col", "pe"]}}
{"id1": "5998352", "id2": "8135072", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"testStandardTee": [" testStandardNette", " testStandardTees", " teststandardTe", " teststandardMee", " testStandardEette", " testStandardEe", " teststandardTee", " testStandardMee", " testStandardNe", " testStandardMees", " testStandardTe", " testStandardMette", " teststandardMe", " testStandardEee", " testStandardNee", " testStandardTette", " testStandardEees", " teststandardMees", " teststandardTette", " testStandardNees", " testStandardMe", " teststandardMette", " teststandardTees"], "reference": ["remote", "attribute", "name", "link", "sequence", "external", "key", "string", "approximately", "pattern", "back", "description", "message", "pointer", "sample", "memory", "title", "expression", "associated", "argument", "value", "reverse", "hello", "Reference", "filename", "alias", "internal", "resolution", "information", "function", "template", "library", "example", "note", "specified", "type", "see", "search", "report", "prefix", "service", "collection", "relative", "address", "ref", "condition", "relation", "test", "definition", "section", "word", "position", "request", "using", "re", "operation", "print", "document", "directory", "register", "use"], "source": ["Source", "iterator", "sequence", "unit", "select", "shell", "operator", "inner", "stream", "ource", "src", "loader", "sample", "copy", "target", "file", "buffer", "resource", "context", "template", "base", "from", "force", "instance", "sql", "store", "console", "service", "ser", "spec", "seed", "get", "core", "input", "SOURCE", "reader", "style", "username", "format"], "destination1": ["destinatorName", "DestinatorName", "destension2", "desturationOne", "Destinationone", "destification1", "destinationsFirst", "destinationsOne", "stensionOne", "destationOne", "stinationOne", "stensionFirst", "destensionFirst", "destinationOne", "destinatorOne", "stension2", "destinator1", "destificateOne", "destinatorone", "destation1", "destregation1", "Destinatorone", "destinator01", "destation01", "desturationFirst", "destregationName", "stination1", "desturation1", "destificationone", "destinationFirst", "destination01", "destregationOne", "destinationName", "Destinator1", "desturation2", "destificate01", "destension1", "destinations1", "destinations2", "Destinator01", "Destination01", "stination2", "stension1", "DestinationName", "DestinationOne", "destificationOne", "destregationone", "destensionOne", "stinationFirst", "destificationName", "destinationone", "DestinatorOne", "destificate1", "Destination1"], "destination2": ["destension2", "destinate1", "destinated52", "destination3", "Destension1", "destinition2", "destendantB", "estination3", "destinator3", "Destension2", "destinition3", "estination52", "desturationtwo", "destendant2", "destinated2", "estinition2", " desturationtwo", "destension4", " destinationB", "destinationtwo", "destinition52", "destensionTwo", "destinator52", "desturation4", "destociationTwo", "desturation2", "destinationB", "estinition3", "Destination1", "destension1", " desturation2", " desturation4", "Destination2", "destination4", "desturationB", " desturationB", "destinationTwo", "destociation2", "DestinationTwo", "DestensionTwo", "destinated3", "destendanttwo", "estination2", "estinition52", "destensiontwo", "destociation1", "destinateTwo", "destinate2", " destinationtwo", "destination52", "destensionB", "destendant4", "destinator2", " destination4"], "tee": ["ceoe", "chete", " teE", "peE", " teoe", " tete", "chee", "teer", "teea", "peee", " teee", " teea", "tees", "cheee", "ceer", "pee", "tete", "teoe", "seee", "cheea", "see", "iee", "teE", "ceee", "peer", "teee", "cees", "seoe", "iete", "ieea", "seE", "peoe", "cee", "pees", "ceE", "ieee", " teer", " tees"]}}
{"id1": "20028790", "id2": "16079868", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"setBundleInfoName": ["setBundleFileNames", "setBundleInfNames", "setBundleInfoTitle", "setBundleFileName", "setBundleFileLabel", "setBundleDataLabel", "setBundleFileTitle", "setBundleInfoNames", "setBundleDataNames", "setBundleInfName", "setBundleDataName", "setBundleDataTitle", "setBundleInfLabel", "setBundleInfoLabel", "setBundleInfTitle"], "location": ["remote", "name", "where", "path", "Location", "availability", "description", "message", "localhost", "ocation", "point", "filename", "layout", "resource", "local", "reference", "template", "translation", "library", "comment", "uri", "program", "command", "color", "LOC", "language", "country", "address", "history", "loc", "l", "position", "document", "directory", "area"], "list": ["name", "sequence", "p", "pool", "v", "add", "stack", "ist", "detail", "all", "L", "local", "map", "listed", "batch", "dl", "m", "lists", "status", "set", "collection", "chain", "out", "spec", "l", "table", "LIST", "block", "net", "print", "missing", "level", "n"], "url": ["mail", "Url", "link", "hl", "html", "pl", "char", "r", "job", "sb", "mount", "lb", "b", "ssl", "build", "bel", "f", "dl", "base", "abs", "uri", "http", "nl", "sl", "el", "gb", "rl", "str", "ll", "google", "browser", "ref", "loc", "rel", "l", "open", "lr", "URL", "ur", "ul"], "br": ["ch", "tr", "BR", "bs", "hr", "bl", "r", "bh", "sr", "Br", "b", "wr", "bd", "bridge", "div", "read", "buf", "ber", "next", "be", "bp", "nl", "gb", "str", "browser", "er", "pr", "rel", "gr", "bt", "bro", "mr", "cr", "lr", "rb", "fr", "dr", "kr"], "line": ["name", "link", "sequence", "online", "ln", "liner", "le", "header", "stay", "string", "ine", "part", "char", "message", "se", "sample", "entry", "lock", "detail", "label", "Line", "source", "point", "buffer", "log", "next", "LINE", "data", "record", "eline", "comment", "lin", "nl", "page", "cell", "trace", "sql", "body", "frame", "store", "piece", "text", "code", "chain", "rule", "phrase", "lo", "l", "word", "iter", "block", "row", "inline", "print", "note", "linux", "style", "handle"], "pos1": ["indexOne", " posOne", "position3", "posone", "poOne", "positionOne", "pos0", "POS2", "POS0", "po1", "positionone", "poone", "POSOne", "pos3", "position1", "position2", "POS1", "pos2", " pos0", "position0", "posOne", "Pos0", "Pos1", "index3", "index1", "PosOne", "Pos2", " pos2", "po3", "indexone"], "bundleSymbolicName": ["bundleSyMBicalNames", "bundleSymbicalType", "bundleSyMBicalName", "bundleSymbolicalFamily", "bundleSymbularNames", "bundleSymbolicCode", "bundleSyMBolicNames", "bundleSymboryType", "bundleSymbolicNames", "bundleSyMBicalCode", "bundleSymbolicType", "bundleSymbololicNames", "bundleSyMBolicname", "bundleSymbolicalNames", "bundleSymbicalname", "bundleSyMBolicCode", "bundleSymbolicalName", "bundleSymboryCode", "bundleSyMBicalVersion", "bundleSyMBolicVersion", "bundleSymboryName", "bundleSymbololicFamily", "bundleSymbololicName", "bundleSymbicName", "bundleSymbicalFamily", "bundleSymboryVersion", "bundleSymbicalCode", "bundleSymbularFamily", "bundleSymbolicname", "bundleSymbularType", "bundleSymbularname", "bundleSymbicVersion", "bundleSyMBicalname", "bundleSyMBolicType", "bundleSymbolicVersion", "bundleSymbicalName", "bundleSymboryNames", "bundleSymbularName", "bundleSymbololicType", "bundleSymbicCode", "bundleSymbicNames", "bundleSymbicalVersion", "bundleSymbolicFamily", "bundleSymboryname", "bundleSyMBolicName", "bundleSymbolicalType", "bundleSyMBicalType", "bundleSymbicalNames"], "bundleName": ["brundleName", "basketname", " banchName", " banchname", "bachmentname", "baleVersion", "bundleString", "fundleVersion", "fasketType", "bachmentInfo", "bundlename", "baleInfo", "branchname", "fundleName", "bowerInfo", "brundlename", "banchInfo", "branchName", "bundleInfo", "banchName", " bundlename", " banchInfo", "bowerString", "fasketname", "bundleType", "brundleInfo", "fasketName", "bowerVersion", "baleName", "branchString", "fundlename", " bundleInfo", "balename", "bachmentName", "basketName", "bowername", "basketVersion", "bowerType", "bowerName", "banchString", "fundleType", "brundleString", "baleType", "fasketVersion", "branchInfo", "banchname", "basketType", "bundleVersion"], "info": ["obj", "fit", "tf", "image", "now", "def", "inner", "fo", "Info", "index", "job", "entry", "tip", "detail", "json", "value", "event", "all", "query", "iso", "update", "alias", "i", "information", "context", "me", "local", "data", "match", "user", "error", "dev", "ext", "f", "comment", "report", "http", "conf", "status", "instance", "te", "details", "check", "INFO", "summary", "item", "history", "iter", "block", "self", "note", "inf", "state"]}}
{"id1": "7948308", "id2": "14785308", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomGuID", "getRandomSuid", "getRandomSUID", "getRandomUuid", "getRandUuid", "getRandomGuuid", "getRandomUUID", "getRandUID", "getRandomGuUID", "getRandGUID", "getRandUUID", "getRandomGuid", "getRandUid", "getRandomGID", "getRandGid", "getRandomUID", "getRandomUid", "getRandomSid", "getRandGuid", "getRandomSID", "getRandGID", "getRandomGid"], "secure": ["sec", "clear", "active", "server", "domain", " Secure", "confirmed", "sr", "safe", "sys", "ssl", "weak", "sync", "security", "force", "prime", " insecure", "http", "status", "nice", "service", " securely", "Secure", "google", "https", "dirty", "sensitive", "client", "quiet", "stable", "strong", "ie", "pretty", "trust", "style", "encrypted"], "md5": ["MD2", " md6", " md2", " mdle", " mdke", "mdke", "dig4", "md3", " MD3", " Md3", "md4", "sha5", "dig5", " Md2", " Mdson", "MDke", " mdson", "sha3", " MDke", "MD5", " md4", " MD5", "md2", "dig3", "sha2", " MD2", "md6", "MDson", " md3", "MD4", "MD3", "digle", "sha6", "MD6", "MDle", "mdle", "mdson", " Md5"], "sbValueBeforeMD5": ["sbValueBeforeUMPD", "sbValueBeforeUM5", "sbValueBeforeUM55", "sbValueBeforeMT05", "sbValueAfterMD5", "sbValueBeforePD5", "sbValueLikeMD5", "sbValueBeforeMDody", "sbValueBeforeMDse", "sbValueLikemd5", "sbValueBeforeAMD25", "sbValueBeforeAMD2", "sbValueAtMAC512", "sbValueBeforeMAC5", "sbValueAtMD2", "sbValueBeforeMC2", "sbValueBeforePD2", "sbValueBeforeMDLE", "sbValueBeforeMOD25", "sbValueLikemd55", "sbValueLikemdPD", "sbValueAtMAC5", "sbValueAtMD5", "sbValueBeforePDody", "sbValueAfterMD2", "sbValueBeforeND2", "sbValueAfterMDody", "sbValueBeforeMACse", "sbValueBeforemd512", "sbValueAfterMDFive", "sbValueBeforeMP3", "sbValueBeforePDLE", "sbValueBeforeMP2", "sbValueBeforeDD3", "sbValueBeforeMDPD", "sbValueLikeMD55", "sbValueBeforeND3", "sbValueBeforeMP8", "sbValueBeforemdPD", "sbValueBeforeMODFive", "sbValueBeforeMD55", "sbValueBeforemd55", "sbValueBeforeDD8", "sbValueBeforeHEADLE", "sbValueBeforeHEAD5", "sbValueBeforeMD512", "sbValueBeforeMC3", "sbValueBeforeMOD2", "sbValueBeforeHEADody", "sbValueBeforeMT5", "sbValueBeforeHEAD2", "sbValueAtMAC2", "sbValueAtMACse", "sbValueAfterMD3", "sbValueBeforeMAC512", "sbValueBeforeMD05", "sbValueAtMD512", "sbValueAfterMDLE", "sbValueUnderMD2", "sbValueBeforeMOD5", "sbValueBeforeND5", "sbValueBeforemd2", "sbValueAfterMD05", "sbValueBeforeDD5", "sbValueBeforeMD3", "sbValueBeforeAMD5", "sbValueLikemd2", "sbValueBeforeMC5", "sbValueBeforeMD25", "sbValueBeforeMAC2", "sbValueBeforeDD2", "sbValueAfterMD25", "sbValueBeforeMD2", "sbValueBeforeMDFive", "sbValueBeforeMOD05", "sbValueAtMDse", "sbValueLikeMD2", "sbValueLikeMDPD", "sbValueBeforeMT2", "sbValueUnderMD5", "sbValueBeforeUM2", "sbValueBeforeMTFive", "sbValueBeforeMP5", "sbValueBeforemd5", "sbValueBeforeMD8", "sbValueBeforemdse", "sbValueAfterMD8", "sbValueUnderMD3"], "time": ["name", "ime", "sequence", "timeout", "counter", "race", "now", "system", "x", "ts", "ty", "estamp", "current", "TIME", "clock", "value", "start", "date", "tt", "when", "user", "top", "year", "id", "rate", "type", "timer", "tim", "today", "frame", "age", "t", "history", "Time", "duration", "etime", "work", "length", "total", "times", "client", "runtime", "hour"], "rand": ["msg", "rev", "sid", "init", "rd", "R", "and", "inv", "mid", "sample", "r", "nt", "rid", "grad", "ng", "uid", "round", "rank", "quant", "sam", "gt", "gen", "id", "rate", "pick", "Rand", "res", "reg", "rss", "random", "range", "hash", "serial", "seed", "rh", "frac", "nd", "gz", "rc", "cr", "pid", "dist", "z", "did", "rot", "trust", "dr"], "valueBeforeMD5": ["valueBeforeMT3", "valueBeforeMDFive", "valueBeforeDER2", "valuebeforeMD5", "valueAfterND7", "valueBeforeDER3", "valueBeforemd7", "valueAfterMD3", "valueAfterND5", "valueBeforeMC2", "valueAfterMD2", "valueBeforemd3", "valuebeforeMD2", "valueBeforemd5", "valueBeforeMT2", "valuebeforeMT3", "valueBeforeMC3", "valueAfterMD7", "valueBeforeND2", "valueBeforeMT5", "valueBeforeDER7", "valuebeforeMT2", "valueBeforeMTFive", "valueAfterND2", "valuebeforeMTFive", "valueAfterND3", "valueBeforeMD7", "valuebeforeMD3", "valueBeforeMD2", "valueBeforemd2", "valueBeforeMCFive", "valueBeforeND3", "valueBeforeND7", "valueBeforeMD3", "valueBeforeMC5", "valueBeforeND5", "valueBeforeDER5", "valuebeforeMDFive", "valuebeforeMT5"], "array": ["attribute", "response", "rays", "external", "ray", "image", "Array", "our", "arrow", "a", "sample", "RAY", "expression", "value", "number", "buffer", "archive", " Array", "data", "record", "ash", "map", "av", "batch", "atomic", "storage", "audio", "arr", "vector", "instance", "angular", "random", "range", "hash", "object", "ashes", "collection", "feature", "address", "binary", "angle", "app", "length", "share", "list", "row", "ary", "pair", "var", "area"], "sb": ["obs", "bg", "erb", "ib", "sq", "shell", "soc", "bs", "cb", "sth", "sh", "si", "sa", "bh", "sr", "abb", "nb", "lb", "gc", "ssl", "bsp", "bb", "sg", "bp", "sw", "sv", "lp", "eb", "bis", "bf", "gb", "ctrl", "rob", "sf", "wb", "ub", "kb", "pb", "bt", "sc", "ob", "s", "rb", "SB", "hs", "zb", "bps", "ls", "xb"], "j": ["msg", "obj", "key", "jump", "jl", "uj", "it", "ji", "g", "v", "ja", "job", "yy", "je", "json", "jo", "jc", "i", "k", "jack", "oj", "m", "kj", "q", "_", "J", "br", "bj", "__", "y", "str", "ij", "aj", "dj", "jp", "by", "jit", "jj", "n", "js", "z", "fr", "att", "bot", "ct", "index", "ind", "state"], "b": ["bi", "bg", "ib", "bc", "bs", "cb", "mb", "v", "B", "ab", "nb", "u", "bd", "i", "k", "ba", "bb", "bar", "bp", "beta", "eb", "bu", "bis", "gb", "bf", "br", "y", "d", "db", "bound", "bt", "rb", "fb", "be"], "valueAfterMD5": ["valueBeforeMD4", "valueBeforeMD6", "valueAfterMD2", "valueAfterMD6", "valueAftermd4", "valueAfterMT4", "valueAfterMT5", "valueAfterMT6", "valueBeforeMD2", "valueAftermd2", "valueAfterMD4", "valueAftermd5", "valueAfterMT2", "valueAftermd6"]}}
{"id1": "7044685", "id2": "2525897", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 1, "substitutes": {"encrypt": ["crypted", "crypt", " encrypted", "encryption", "Encryption", " encryption", "cryption", "Encrypt", "Encrypted", "encrypted"], "plaintext": ["aindata", " plainText", "maintext", "ainText", "messagedata", "plainText", "ainstring", " plainprint", " plaindata", "messageText", "plainprint", " plainstring", "aintext", "plainstring", "plaindata", "messageprint", "mainText", "ainprint", "messagetext", "mainstring"], "d": [" md", "ord", "dig", "p", "gd", "cd", "g", "D", "dm", "ds", "dh", "w", "dx", "e", "dec", "od", "ind", "bd", "de", "debug", "h", "sd", "dat", "ad", "mod", "di", "ded", "pd", "ld", "f", "m", "c", "dal", "dl", "done", "fd", "y", "da", "md", "red", "t", "db", "l", "nd", "end", "z", "dd", "did", "dr", "df", "hd"]}}
{"id1": "3252116", "id2": "22560224", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"getMD5": ["getHash10", "GetMD1", "getHash1", "getmd1", "getMC10", "Getmd4", "getHash5", "getMD1", "getmd10", "GetMD10", "getMD10", "Getmd1", "getMC5", "getMD4", "GetMD5", "getMC4", "getmd5", "GetMD4", "Getmd10", "getMC1", "Getmd5", "getmd4", "getHash4"], "source": ["Source", "name", "sequence", "origin", "image", "string", "this", "dest", "ource", "src", "message", "sample", "subject", "copy", "content", "target", "e", "file", "b", "start", "buffer", "data", "template", "f", "c", "base", "from", "site", "object", "ser", "text", "code", "seed", "output", "null", "input", "SOURCE", "style", "secret"], "s": ["cs", "ws", " returns", "p", "ts", "bs", "rs", "ps", "a", "ats", "ds", "ns", "gets", "sb", " ss", "b", "S", " outputs", "gs", "ss", "es", "ends", "xs", " gets", "ses", " samples", " ls", "ies", " ans", "abs", "fs", "sts", "ads", "its", " rs", " ts", "ins", "t", "parts", "ings", "bes", "eps", "uns", " sets", " es", "os", " streams", " fs", "js", "hs", "ls"], "hexDigits": [" hexDigitions", " hexDigbits", "hexdigits", "hexPosities", "hexPosits", "hexDists", "hexFunbits", "hexDigities", "hexDigbits", "hexDigit", "hexDits", "hexDigals", "hexDigitions", " hexDigals", " hexDigit", "exDigities", "hexFunit", "hexDigists", "exdigities", "exdigits", "hexdigities", "exdigals", "hexdigists", "hexFunits", "exDigals", "exDigitions", "exdigitions", "hexdigbits", " hexDigists", "hexdigit", "hexFunals", "hexPosals", "hexDities", " hexDigities", "hexDitions", "exDigits", "hexdigitions", "hexdigals", "hexPositions"], "md": ["sm", "amd", "dr", "dig", "mt", "cd", "mb", "MD", "nt", "add", "dm", "dh", "mm", "der", "od", "cmd", "grad", "hd", "ind", "bd", "de", "sd", "mod", "ad", "di", "ld", "m", "det", " Md", "cond", "rm", "ms", "red", "desc", "mn", "d", "nd", "dd", "td", "mc", "pdf", "mk", "df", "pd"], "tmp": ["zip", "obj", "up", "html", "comp", "cmp", "cb", "mb", "yy", "nb", "temp", "perm", "params", "tt", "etc", "np", "Temp", "local", "xs", "txt", "xy", "qq", "fake", "bis", "mp", "img", "bag", "cur", "sup", "buff", "dirty", "test", "proc", "pkg", "db", "table", "ctx", "sym", "js", "sp", "emp", "bytes"], "str": ["name", "obj", "stri", "cs", "ch", "tr", "p", "string", "it", "vol", "char", "arc", "v", "r", "w", "e", "STR", "div", "b", "buf", "data", "sw", "m", "c", "txt", "sl", "arr", "ctr", "br", "st", "set", "cast", "text", "t", "out", "gr", "sc", "iter", "Str", "cr", "list", "fr", "sp", "hex", "print", "cat", "dr", "ar", "n"], "k": ["ku", "unk", "ikk", "key", "ka", "p", "x", "kan", "sk", "g", "v", "w", "ko", "ck", "kk", "b", "kid", "h", "j", "kt", "tk", "id", "ak", "kh", "m", "c", "kl", "f", "kj", "q", "ik", "kw", "K", "set", "km", "t", "kar", "kn", "d", "ok", "l", "ke", "z", "ks", "mk", "n"], "i": ["ix", "bi", "im", "ip", "ri", "p", "mi", "it", "x", "is", "gi", "phi", "ui", "ji", "si", "v", "ini", "hi", "info", "index", " j", "e", "u", "iu", "\u0438", "cli", "io", "ci", "me", "ti", "zi", "j", "multi", "di", "inter", "conv", "xi", "m", "status", "ic", "in", "qi", "ij", "chain", "o", "ai", "I", "pi", "print", "sim", "n", "ii", "li"], "byte0": ["byte1", "node8", "Byte8", "hex0", "Byte140", "node2", " byte8", "Byte3", " byte1", "channel3", "pixelElement", "channel140", "pixel1", "byte6", "Byte1", " byteElement", "byte8", "node1", "byteElement", " byte2", "channel1", "hex1", "node0", "byte2", "Byte2", "byte3", " byte3", "hexElement", " byte6", "byte140", "pixel0", "hex6", "channel0", "pixel6", "Byte0", " byte140"]}}
{"id1": "18731843", "id2": "8069594", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doBody": [" sendbody", " sendHead", " dobody", "loadbody", "loadHead", " doContent", " writeBody", " doHead", " sendBody", " writeHead", " sendContent", "loadBody", "loadContent", " writebody", " writeContent"], "req": ["sq", "quick", "tx", "qt", "inv", "def", "rec", "ps", "hr", "cmd", "Request", "pro", "query", "err", "wx", "j", "express", "qq", "crit", "res", "reg", "q", "http", "conf", "Requ", "aj", "urg", "jp", "proc", "pkg", "ctx", "gr", "request", "exec", "requ", "fr", "js", "quest"], "resp": ["response", "exp", "wa", " res", "RES", "vol", "soc", "comm", "def", "ret", "rec", "Rep", "cl", "esp", "wr", "pos", "err", "serv", "next", "Res", "respond", "respons", "Resp", "result", "res", "rep", "http", "Response", "sol", "out", "rel", "output", "client", "re", "js", "trans", "sp"], "bis": ["fps", "bi", "bits", "obs", "pin", "oi", "mi", "is", "iss", "zo", "bs", "isin", "bh", "sb", "bat", "bil", "avi", "bie", "onis", "iso", "idis", "ris", "ses", "rison", "inet", "webkit", "pins", "lin", "ads", "aus", "ubis", "ios", "bes", "ais", "iris", "los", "bt", "phis", "os", "lbs", "oss", "atis", "mis", "cin", "bid", "bps", "isi", "be", "nis", "lis"], "bos": ["tis", "bits", "bi", "obs", "oi", "ols", "is", "ts", "bs", "ods", "banks", "tes", "uts", "bh", "asket", "aos", "ubs", "bil", "oops", "asis", "bin", "ys", "gs", "uds", "fits", "fs", "pins", "vas", "its", "bas", "acs", "ios", "ubis", "stones", "nos", "bo", "bes", "mes", "los", "dos", "os", "eros", "jas", "oss", "outs", "ows", "BS", "zb", "oos"]}}
{"id1": "2834524", "id2": "19739421", "code1": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"write": ["zip", "link", " overwrite", "println", " rewrite", "apply", "commit", "add", "flush", "download", "lock", "file", "update", "rite", "read", "next", "append", "export", "dump", "save", "check", "service", "Write", "create", "end", "print", "filter", "handle"], "jarOut": ["pkgOut", "JarOut", " jarOutput", "JarIn", "JarOver", "pkgIn", "jamNet", "javaStore", "jarNet", " jarIn", "Jarout", "javaGen", "browserOut", " jarGen", "jarOutput", "javaOutput", "pkgOver", "JarStore", "browserIn", "jamIn", "JarGen", "jamOut", "jarout", "javaOut", "JarOutput", " jarout", "jarIn", "jamOver", "JarNet", "javaout", "browserOutput", "browserout", " jarStore", "jarGen", "pkgNet", "jarOver", "javaIn", "jarStore"], "allEntries": [" allents", "allEnrys", " allentries", " allenties", "allEnies", "allEntrys", " allEnties", "allenties", "allEntryrys", "allentries", "allENTrys", "allEntlections", " allentrys", "allEntryries", " allEntarts", "allentarts", "allENTries", "allEntarts", "allEnties", "allEnts", " allEntrys", " allEntlections", "allEntryies", "allentrys", "allEnarts", "allENTlections", "allENTies", "allents", "allentlections", "allEnries", " allEnts"], "iterator": ["sequence", "ter", "former", "ippy", "immigration", "counter", "liner", "writer", "operator", "iver", "continue", "inner", "stream", "loader", "ator", "members", "current", "copy", "sample", "integer", "pointer", "database", "outer", "series", "internet", "menu", "number", "starter", "values", "ski", "walker", "i", "Iterator", "builder", "pie", "iner", "next", "tmp", "pee", "issues", "timer", "rows", "trace", "vector", "instance", "inator", "set", "range", "finder", "collection", "loop", "table", "iter", "creator", "versions", "list", "runner", "size", "river", "reader"], "jar": ["zip", "cert", "magic", "vol", "char", "job", "Jar", "entry", "gem", "pack", "json", "file", "jo", "folder", "resource", "archive", "parse", "rar", "j", "be", "library", "car", "tab", "batch", "pod", "tar", "java", "bag", "browser", "class", "binary", "zone", "jp", "lib", "pkg", "cf", "module", "jj", "dir", "war", "sp", "bare", "cp"], "jarEntries": ["JarEntires", " jarEntities", "jarEnities", "jarEntrs", "jarMatries", "jarEnries", "jarMatires", "jarEntities", "jarContrys", " jarEntarts", " jarentries", "jarEntires", "jarAddies", "jarentrs", "jarEntrys", "JarEntrs", "jarIntries", "jarenties", "jarEies", " jarEntents", "jarEarts", "Jarentrs", "jarEnrys", "jarInties", " jarEntrys", " jarContities", "jarContities", "Jarentires", "jarEries", "jarentries", " jarenties", "jarContries", "jarentents", "jarContents", "Jarentries", "jarentarts", "jarEnties", "jarEntents", "jarAddries", "jarentires", "jarEents", "jarEnents", "jarEntarts", "jarMaties", "jarIntires", " jarContrys", " jarContents", "jarAddarts", "JarEntries", " jarContries", " jarEnties", " jarentents", "jarIntrs", " jarentarts", "Jarenties", "JarEnties", "jarMatrs", "jarAddents"], "o1": ["co1", "e1", "oOne", " o512", "oo8", "icoone", "e0", "oa8", "o512", " o2", "os2", "co11", "o8", "ico2", "os1", "a0", "eOne", "os512", "o10", " o8", " o5", " o0", " oOne", "oa6", "o5", "eone", "o0", "ico512", "a2", "os5", "oa10", "a1", " oone", "e512", "oa11", "oo10", "e5", "oone", "co6", "oa1", " o11", " o6", "co2", "o6", "ico1", "o11", "aOne", " o10", "o2", "e2", "oa2", "oo1"], "entryStream": ["enterStreamer", "EntrySteam", "entryForm", "rowSteam", "rowPage", " entrySteam", "rowStream", " entryPage", "resultPage", "entrySteam", "entryPage", "EntryStream", "resultStream", " entryPoint", "inputStream", "inputStreamer", "inputForm", "EntryForm", "EntryStreamer", "inputSteam", "enterSteam", "resultSteam", "enterStream", "rowPoint", "enterForm", "entryPoint", "entryStreamer", "resultPoint"]}}
{"id1": "13657527", "id2": "6908537", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    public String login() {\n        System.out.println(\"Logging in to LOLA\");\n        try {\n            String data = URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_email(), \"UTF-8\");\n            data += \"&\" + URLEncoder.encode(\"pw\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_pw(), \"UTF-8\");\n            URL url = new URL(URL_LOLA + FILE_LOGIN);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line, sessid;\n            line = rd.readLine();\n            sessid = get_sessid(line);\n            this.set_session(sessid);\n            wr.close();\n            rd.close();\n            return sessid;\n        } catch (Exception e) {\n            System.out.println(\"Login Error\");\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"getDatasetsList": ["getDatasetsStatus", "getDatasetResult", "getDatisetsList", "getDatasuresStatus", "getDatasetList", "getDatisetsStatus", "getDatasuresResult", "getDatisetList", "getDatisetsResult", "getDatisetResult", "getDatasesStatus", "getDatisetStatus", "getDatasetsResult", "getDatasesList", "getDatasesResult", "getDatasuresList", "getDatasetStatus"], "surl": ["sURL", "sUrl", "jslim", "lsmail", "jsUrl", "stsserver", "stsuri", "lsuri", "jsuri", "sslim", " smail", "sysserver", "ssURL", "smail", "lsUrl", " sUrl", "esname", "suri", "ssUrl", "esURL", "sysurl", "lsserver", "syslt", "slim", "esurl", "sname", "slt", "sserver", "ssurl", "sysuri", "stsurl", " sname", " suri", "lslt", "ssuri", "esuri", "esUrl", "lsurl", "jsurl", "stslt"], "datasetsList": ["dataselinesName", "datasetList", "datasetsName", "datisetsName", "datasagesLock", "datasensList", "datasETSGroup", "datarsetsTable", "datarssetsTable", "datarsetslist", "datassetsData", "datisetName", "datarsetsLock", "datisetList", "datasetsData", "datisetsList", "datisetMap", "datasetsMap", "datasourcesLock", "datasourcesTable", "datarsetsMap", "datmassetsMap", "datassetslist", "datarsetList", "datasagesTable", "datasamesSet", "datasuresList", "datasetsSet", "datasagesSet", "datarsetsSet", "datasagesList", "datasetlist", "datasETSList", "datassetsLock", "datmasetsList", "datasetsTable", "datarsetSet", "datasourcesList", "datasuresSet", "datarsetMap", "datassetsSet", "dataselinesMap", "datasetMap", "datasetGroup", "datarsetsList", "datasetName", "datasetData", "datasamesMap", "datasetsGroup", "datasagesMap", "datisetGroup", "datmasetsData", "datasamesList", "datasetsLock", "datisetsMap", "datarssetsSet", "datmassetsLock", "datmasetsLock", "datmassetsList", "datassetsTable", "dataselinesGroup", "datassetsList", "dataselinesList", "datisetsGroup", "datmasetsMap", "datasetLock", "datarssetsList", "datasourcesSet", "datasenslist", "datasureslist", "datasensMap", "datasuresMap", "datasETSMap", "datmassetsData", "datarssetsLock", "datassetsMap", "datasagesData", "datarsetlist", "datasETSName", "datasetslist", "datasetSet", "datasameslist"], "result": ["sequence", "response", "cert", "answer", "first", "Result", "def", "ret", "description", "message", "menu", "detail", "success", "folder", "buffer", "results", "record", "successfully", "there", "default", "successful", "complete", "comment", "search", "res", "report", "valid", "status", "form", "details", "set", "chain", "contact", "test", "relation", "table", "diff", "found", "exist"], "reader": ["iterator", "READ", "liner", "rd", "rer", "writer", "per", "socket", "operator", "older", "reading", "inner", "stream", "via", "loader", "r", "rr", "redo", "layer", "file", "query", "buffer", "author", "resource", "read", "parser", "rar", "roller", "handler", "driver", "timer", "peer", "ner", "body", "rl", "range", "ser", "Reader", "er", "bo", "ro", "test", "client", "upper", "iter", "mr", "row", "runner", "field", "river", "dr", "wrapper", "handle"], "url": ["mail", "Url", "link", "key", "org", "char", "stream", "loader", "r", "mount", "file", "location", "ssl", "resource", "user", "id", "dl", "il", "uri", "web", "http", "sl", "nl", "rl", "str", "ll", "browser", "address", "l", "client", "null", "lr", "row", "URL", "ls", "ur", "ul"], "s": ["cs", "ws", "string", "sq", "ts", "still", "is", "full", "bs", "rs", "tes", "strings", "ps", "v", "ats", "r", "sample", "ds", "ns", "sb", "gets", "series", "source", "b", "i", "gs", "h", "S", "ss", "es", "less", "sw", "sv", "abs", "sts", "ids", "its", "y", "sql", "str", "ms", "ins", "t", "has", "us", "csv", "l", "os", "sym", "js", "qs", "hs", "ls", "as", "n"], "list": ["sequence", "ls", "php", "group", "array", "full", "part", "pool", "def", "add", "stack", "member", "detail", "all", "log", "layout", "join", "L", "local", "top", "listed", "batch", "dl", "cont", "format", "lists", "left", "form", "set", "st", "single", "collection", "ll", "chain", "test", "l", "table", "word", "LIST", "block", "ml", "pretty", "print", "note", "ist", "li"]}}
{"id1": "15896098", "id2": "20991673", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "label": 1, "substitutes": {"getSHA256Checksum": ["getSHA256Checkchecksums", "getSHA256Checkcksume", "getSHA256Checkchecksume", "getSHA256Checsums", "getSHA256Checksam", "getSHA256Checkums", "getSHA256Checksums", "getSHA256Chechecksum", "getSHA256Chechecksam", "getSHA256Checkchecksum", "getSHA256Checsum", "getSHA256Checsume", "getSHA256Checkcksum", "getSHA256Checkcksums", "getSHA256Chechecksume", "getSHA256Checkume", "getSHA256Chechecksums", "getSHA256Checkcksam", "getSHA256Checksume", "getSHA256Checkum", "getSHA256Checsam", "getSHA256Checkchecksam", "getSHA256Checkam"], "source": ["Source", "name", "url", "sequence", "path", "image", "string", "this", "ource", "src", "message", "sample", "subject", "target", "content", "value", "file", "filename", "buffer", "context", "reason", "data", "template", "base", "from", "status", "body", "in", "text", "out", "seed", "output", "s", "input", "SOURCE", "style", "secret", "raw", "format"], "checksum": ["checkum", "cksume", " checkssum", "checkume", "cssum", "checkumb", "checksim", " checksums", "checkssum", " checksume", "csim", "checkim", "ckssum", "checksume", " checksumb", "csume", "checksums", "cksim", "cksums", "cksum", "checksumb", " checksim", "cksumb", "checkums", "csum"], "md": ["sm", " MD", "dr", "mt", "wd", "def", "cd", "mb", "MD", "nt", "dm", "dh", "mo", "mm", "der", "od", "cmd", "grad", "hd", "ind", "bd", "sd", "mod", "ad", "di", "ld", "m", "det", " Md", "down", "Cmd", "pm", "mp", "red", "ms", "mg", "mn", "d", "mand", "dd", "mc", "pdf", "mk", "df", "pd"], "byteData": ["byteRel", "ByteBytes", "ioDATA", "routeDATA", "sliceDat", "bytesData", "byteParts", "wordArray", "routeData", "ioDat", "ioData", "bleRel", "ByteParts", "reverseDat", " byteParts", "bytedata", "wordData", "channeldata", "channelRel", "reverseDATA", "reverseCount", " byteCount", "byteCount", "ioList", "phraseBytes", " bytedata", "channelData", "wordBytes", "channelParts", "ByteData", " byteArray", "phraseData", "ByteDATA", "bytesDATA", "bleData", "sliceList", "bytesArray", "phraseParts", "byteDATA", "reverseData", "sliceDATA", "routeCount", "byteDat", " byteDATA", "byteArray", "bleParts", "routeDat", " byteDat", "bytesBytes", "sliceData", " byteList", " byteBytes", "bledata", "wordDATA", "byteList", "byteBytes", "phraseDATA", " byteRel"], "sb": ["sm", "erb", "bg", "ib", "SF", "sq", "shell", "bs", "cb", "mb", "si", "sa", "bh", "sbm", "sh", "nb", "lb", "b", "ssl", "bsp", "bb", "sg", "sam", "sw", "sv", "lp", "eb", "bash", "bis", "gb", "bj", "bf", "sf", "wb", "ub", "kb", "pb", "db", "obb", "bt", "ob", "rb", "SB", "zb", "sp", "bps", "xb"], "i": ["ix", "im", "ime", "phi", "ui", "hi", "major", "info", "ski", "gu", "io", "ci", "multi", "di", "uri", "ic", "set", "ity", "ei", "qi", "I", "list", "my", "sim", "ind", "ii", "si", "life", "iu", "series", "point", "xi", "m", "ki", "remote", "ip", "ri", "this", "g", "u", "cli", "json", "\u0438", "err", "me", "id", "q", "y", "ims", "ms", "ij", "chain", "history", "loop", "o", "ai", "ie", "print", "bi", "init", "oi", "any", "mi", "it", "gi", "ji", "ini", "ion", "ti", "j", "iy", "er", "l", "client", "to", "pi", "iq", "li"], "hexString": ["hexResource", "hashstring", "shortArray", "fullBuffer", " hexArray", "htmlBuffer", "hexArray", "hexStore", " hexstring", " hexBuffer", "htmlstring", "exArray", " HexResource", " HexBuffer", " hexResource", "htmlString", "fullStore", "exString", "hashArray", "exBuffer", "shortstring", "hashString", " hexStore", "shortString", "exstring", "shortBuffer", "fullstring", " HexString", "hashBuffer", " Hexstring", "fullString", "shortResource", "htmlArray", "hexstring", "hexBuffer", "exStore"], "hex": ["zh", "hl", "php", "html", "comp", "exp", "alph", "none", " ex", "full", "tx", "x", "tex", "def", "sh", "rex", "ex", "temp", "json", "hello", "lit", "ph", "alias", "h", "prop", "sex", "ext", "dump", " Hex", "cont", "mix", "solid", "oct", "he", "com", "form", "pex", "des", "rh", "term", " sex", "flash", "cat", "rendered", "raw"]}}
{"id1": "5061606", "id2": "10795866", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNecessesed", "createSettingsIfNecessesar", "createSettingsIfNeccessed", "createSettingsIfNeccesar", "createSettingsIfNacessible", "createSettingsIfNecessar", "createSettingsIfNacessary", "createSettingsIfNeccessible", "createSettingsIfNecessed", "createSettingsIfNecessesary", "createSettingsIfNacessesar", "createSettingsIfNeccesary", "createSettingsIfNeccessar", "createSettingsIfNacessesed", "createSettingsIfNecessible", "createSettingsIfNacessed", "createSettingsIfNeccesible", "createSettingsIfNacessesible", "createSettingsIfNacessar", "createSettingsIfNeccesed", "createSettingsIfNecessesible", "createSettingsIfNacessesary", "createSettingsIfNeccessary"], "out": ["timeout", "obj", "up", "server", "conn", "go", "ch", "init", "yes", "writer", "it", "Out", "cho", "inv", "ex", "nt", "flush", "oe", "outer", "w", "aos", "ent", "max", "file", "gc", "cos", "ion", "log", "err", "sys", "io", "one", "that", "conv", "on", "exit", "f", "comment", "ou", "again", "res", "report", "ot", "or", "t", "bo", "o", "ne", "OU", "write", "output", "client", "con", "null", "os", "to", "oss", "end", "co", "list", "outs", "OUT", "net", "print", "note", "can", "n", "off", "cn"], "fSettings": ["fsettings", "cfSetting", "bfsettings", "cfSettings", "fOptions", "bfSettings", "cfSetup", "finalsettings", "bfChanges", " fOptions", " fSetting", "sfsettings", "fSetup", "hSettings", "sfOptions", "cfsettings", " fChanges", "fChanges", "eSettings", " fsettings", "sfSetup", "eSetting", "sfSettings", "finalSetting", "finalOptions", "sfChanges", "finalSettings", " fSetup", "esettings", "sfSetting", "hsettings", "hSetting", "bfSetting", "fSetting"], "src": ["url", "ls", "view", "attr", "sq", "rs", "dest", "fn", "sr", "sb", "rx", "syn", "config", "source", "sys", "filename", "sit", "resource", "tmp", "root", "txt", "cont", "rl", "cur", "ser", "img", "sf", "spec", "loc", "rel", "pkg", "sc", "ur", "dir", "rc", "th", "rt", "desc", "upload"], "in": ["inn", "ln", "init", "is", "and", "sin", "inner", "isin", "r", "din", "info", "source", "bin", "i", "gin", "ad", "id", "from", "In", "ins", "inside", "en", "IN", "l", "iter", "n", " din", "input", "rin", "cin", "vin", "inf"]}}
{"id1": "19687456", "id2": "16572931", "code1": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"testReadPerMemberSixSmall": [" testReadPerMemberSixsmall", " testReadPerMemberSixLarge", " testReadPermemberEightLarge", " testReadPermemberSixLarge", " testReadPermemberSixsmall", " testReadPerMemberEightLarge", " testReadPerMemberEightMember", " testReadPerMembersixSmall", " testReadPerMembersixLarge", " testReadPerMemberEightSmall", " testReadPerMembersixsmall", " testReadPerMembersixMember", " testReadPermemberSixMember", " testReadPermemberSixSmall", " testReadPerMemberSixMember", " testReadPermemberEightsmall", " testReadPerMemberEightsmall", " testReadPermemberEightSmall", " testReadPermemberEightMember"], "gzin": ["znin", "gzgen", "gtnin", "ctxins", "gifIN", "zcin", "gcIn", "gdin", "gdins", "gdcin", "gilpin", "zipisin", "gtins", "resppin", "gtIn", "zagvin", "ctxin", "urgins", "gtgen", "zaginner", "cfgins", "cfgcin", "cfgin", "zaggen", "zagadd", "gifin", "zipin", "gcin", "cfgadd", "gifIn", "gifinner", "gdinner", "respin", "zagcin", "gilvin", "respvin", "gzinner", "gznin", "zagpin", "quscin", "zagin", "gzIn", "qusisin", "ctxIN", "zgen", "gtcin", "urgIN", "gzcin", "urgin", "gzvin", "cliins", "gcins", "gifins", "cliin", "zin", "gzpin", "gcIN", "zagnin", "gtin", "cliIN", "zipcin", "gzadd", "gtIN", "gifadd", "gzisin", "gzIN", "zagins", "gilcin", "qusin", "gzins", "gilin", "gifcin", "gilisin"], "i": ["ix", "im", "ip", "init", "go", "p", "is", "it", "x", "phi", "gi", "ui", "ex", "v", "ini", "index", "u", " j", "ind", "gu", "ci", "me", "multi", "j", "di", "id", "m", "batch", "q", "wait", "y", "ic", "mill", "ms", "qi", "chain", "us", "client", "ai", "I", "pi", "print", "sim", "n", "ii", "li"], "count2": ["found4", "ountTwo", " count5", "count4", "count5", " countTwo", "Count4", "const2", "found2", " count4", " count1", "found1", "Count2", "countTwo", "ount2", "constTwo", "Count1", "count1", "ount5", "const5"], "count3": ["ountThree", "commandthree", "trustthree", "currency3", "currencyThree", "count313", "countthree", "trust43", " countThree", "ount3", " countthree", "count43", "command3", "ount43", "countThree", "ountthree", "ount313", "trust3", " count313", "currency313", "currencythree", "command43"], "countEnd": ["foundend", "CountEnd", "ountEND", "ountEnd", "countEND", "ountend", "foundBegin", "foundEnd", "CountEND", "ountBegin", "detailEND", "countend", " countEND", "Countend", "detailend", "detailBegin", "countBegin", " countend", "detailEnd", "CountBegin", " countBegin", "foundEND"]}}
{"id1": "17199913", "id2": "7948308", "code1": "    protected static InputStream loadResource(String resource) throws MissingResourceException {\n        Thread thread = Thread.currentThread();\n        ClassLoader cLoader = thread.getContextClassLoader();\n        URL url = cLoader.getResource(resource);\n        if (url == null) {\n            throw new MissingResourceException(\"Unable to find resource '\" + resource + \"'.\", resource, resource);\n        }\n        try {\n            InputStream is = url.openStream();\n            return is;\n        } catch (IOException e) {\n            throw new MissingResourceException(\"Unable to load resource '\" + resource + \"' (IOException).\", resource, resource);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 0, "substitutes": {"loadResource": ["loadresource", "parseStream", "openStream", "getResource", "openFile", "parseFile", "parseresource", "getStream", "loadFile", "openresource", "loadStream", "parseResource", "getresource", "openResource", "getFile"], "resource": ["sequence", "server", "model", "subject", "buffer", "context", "function", "reference", "library", "from", "uri", "res", "web", "color", "hash", "collection", "create", "element", "core", "field", "document", "directory", "state", "name", "resources", "path", "version", "problem", "ource", "message", "issue", "title", "event", "controller", "source", "location", "resolution", "reason", "property", "method", "project", "prefix", "address", "rule", "component", "request", "connection", "ce", "use", "remote", "attribute", "response", "pattern", "scope", "pointer", "expression", "value", "node", "query", "filename", "record", "template", "password", "id", "comment", "base", "release", "relation", "module", "common", "term", "null", "re", "operation", "print", "image", "string", "system", "action", "OURCE", "description", "entry", "file", "date", "application", "space", "role", "status", "instance", "service", "phrase", "Resource", "client", "get"], "thread": ["name", "tem", "parent", "system", "task", "this", "process", "loader", "tc", "subject", "job", "nt", "current", "cmd", "event", "buffer", "session", "tt", "context", "inter", "template", "user", "method", "Thread", "type", "time", "worker", "engine", "object", "service", "t", "TH", "connection", " Thread", "th", "ct", "window"], "cLoader": ["cUrl", "lcBuilder", "cReader", "dcLoader", "lcLoader", " cLoad", "lcJar", "lcUrl", "ccJar", "dcBuilder", "lcReader", " cUrl", "dcUrl", " cBuilder", "dcReader", " cReader", "lcLoad", "cJar", "cLoad", " cJar", "ccReader", "ccLoader", "cBuilder", "ccLoad"], "url": ["mail", "Url", "link", "util", "name", "pl", "oul", "path", "org", "char", "cloud", "mb", "loader", "job", "mount", "file", "lb", "log", "gl", "ssl", "build", "bb", "bel", "user", "kl", "f", "dl", "abs", "uri", "web", "http", "nl", "sl", "el", "rl", "fl", "impl", "str", "ll", "browser", "ref", "loc", "rel", "l", "lr", "URL", "ml", "norm", "ls", "ur"], "is": ["im", "ri", "mi", "iss", "cms", "ui", "si", "isin", "as", "dis", "isa", "iso", "Is", "isf", "i", "ris", "IS", "imp", "bis", "instance", "its", "ios", "isl", "ms", "ims", "has", "ism", "ais", "get", "os", "ai", "isc", "mis", "isi", "ist", "nis", "lis"]}}
{"id1": "255765", "id2": "310182", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"f": ["fp", "name", "rf", "fab", "tf", "path", "exp", "fed", "p", "it", "def", "ret", "fm", "fax", "fo", "fn", "v", "g", "F", "info", "r", "w", "e", "file", "b", "filename", "h", "fx", "fa", "j", "fw", "fc", "m", "c", "base", "fs", "fi", "fd", "elf", "q", "bf", "lf", "y", "form", "t", "sf", "test", "o", "d", "cf", "l", "ft", "dir", "n", "fac", "fr", "fb", "df"], "in": ["inn", "im", "al", "inc", "up", "init", "ac", "is", "it", "inner", "isin", "ex", "add", "r", "din", "info", "mm", "all", "make", "nin", "bin", "h", "log", "io", "gin", "local", "on", "m", "from", "again", "In", "ic", "ins", "t", "en", "er", "IN", "at", "o", "by", "l", "lo", "get", "iter", "ai", "con", "n", " din", "ma", "cin", "rin", "input", "re", " IN", "pi", "reader", "inf", "oin", "ind", "thin"], "cbuf": ["cfuf", "rbbuf", "bcuff", "rboff", "abbbuf", "rbuf", "cduff", "cbdf", "cbbf", "cduf", "rbfg", "cdbuf", "CBf", "cbf", "cdoff", "sbbuf", "cfuff", "sbuff", "CBbuf", "nbbuf", "nbuff", "cduffy", "cbuff", "cff", "gbf", "sbuf", "rbather", "abbdf", "cfbf", "CBuffy", "CBbf", "gbbf", "nbfg", "rbuff", "CBuff", "sbather", "bcdf", "rbuffy", "gbuf", "bcfg", "cbuffy", "cbfg", "abbfg", "gbuff", "CBuf", "cbbuf", "cbather", "bcather", "rbdf", "cboff", "abbuf", "bcbuf", "nbuf", "bcoff", "bcuf"], "read": ["scan", "link", "is", "stream", "ready", "old", "reads", "pack", "buffer", "io", "data", "ly", "ead", "saw", "set", "range", "text", "miss", "iter", "count", "core", "end", "seek", "skip", "input", "readable", "trust", "index", "pe", "ind", "READ", "clear", "est", "ignore", "bind", "height", "fail", "ret", "current", "r", "start", "error", "sync", "report", "send", "poll", "depth", "mem", "Reader", "slow", "hold", "row", "ink", "raw", "view", "ip", "orig", "burst", "select", "find", "reach", "reading", "se", " Read", "ed", "value", "hello", "query", "rank", "k", "parse", "give", "record", "rate", "dev", "mix", "ank", "wait", "q", "chain", "load", "test", "length", "ke", "ai", "roll", "re", "print", "handle", "key", "it", "x", "add", "shift", "run", "connect", "allow", "feed", "log", "close", "default", "ext", "think", "check", "play", "pre", "write", "ok", "open", "get", "need", "reader", "n", "fill", "Read"], "totRead": ["tottWrit", "totalCheck", "totReader", "ltotRead", "toteAdd", "toteFind", "tcotDisplay", "atotaPrint", "tottNeed", "notaLoad", "trotRead", "totNeed", "trotFind", "retotReader", "ttottAdd", "tiatFill", "tOTFind", "totaBuild", "tokLoad", "notPrint", "totCheck", "tacotCheck", "taotConnect", "tfatWrite", "totPrint", "tobyPrint", "totAdd", "notalLoad", "tottAdd", "totaLoad", "totaFind", "tOTRead", "tiatVal", "notRead", "tiotBreak", "totaNeed", "notalNeed", "totBreak", "tiotVal", "ptotFind", "tottedRead", "trotWrite", "ttottNeed", "taotRead", "taotDisplay", "totalWrite", "totWrit", "totalLoad", "tobyCheck", "ptotWrite", " totRun", " totLength", "tiotFill", "totalFind", "tobyNeed", "ptOTFind", "retotRead", "tobyLoad", "tcotSend", "totaDisplay", "toteWrite", "tootRead", "tootConnect", "tiatSend", "ttotNeed", "retottPrint", "totalNeed", "tcotCheck", " toteRead", "letrotFind", "tootCheck", "atotaFill", "toiotRead", "totalLength", "letotSee", "totHave", " totalRead", "letrotSee", "taotCheck", "notalCheck", "ltotBuild", "tootDisplay", " totFind", "ptOTLoad", "tacotConnect", "tottReader", "tiotRead", " totalBuild", "ttotRead", "tootBreak", "tootVal", "tcotBreak", "tcotConnect", "tottWrite", "notaRead", "totaCheck", "totRun", "tiotHave", "atotHave", "ptOTWrite", "tiatBuild", "letotFind", " toteFind", "totSend", "toteNeed", "trotSee", "tokFind", "ptotLoad", "totalSee", "notCheck", "tcotVal", "totaRead", "toiotSend", "totVal", "totaPrint", "notReader", "totedHave", "tottedReader", "tiotSend", " toteRun", "tacotRead", "totFill", "tacotDisplay", "toteReader", "totaConnect", "totaLength", "tobyWrite", "tiatLoad", "toteLoad", " totBuild", "tiotReader", "tottRead", "atotaHave", "totDisplay", "toteRead", "totaAdd", " totWrite", "ptotRead", "ltotFill", "notalRead", "totaHave", "toticRead", "tokWrite", "tiatRead", "tottRun", "tOTLoad", "totConnect", "totSee", "tOTWrite", "ttotWrite", "toiotBreak", "notLoad", "totedPrint", "toteRun", "letrotRead", "letrotWrite", "tottedWrit", "totalBuild", "notWrite", "atotPrint", "tiotPrint", "totLoad", "toiotVal", "retottWrit", "toteFill", "toteBuild", "ltotaRead", "totLength", "letotRead", "toticWrite", "totalPrint", "totWrite", "atotaRead", "tiotWrit", "notalPrint", "retotPrint", "retottReader", "atotRead", "ltotaLoad", "ltotaFill", "totaReader", "tiatBreak", "tcotRead", " totalWrite", "totaSee", "ltotLoad", "totedRead", "notalWrite", "tootSend", "ltotaBuild", "totalRead", "toticFind", "notNeed", "atotFill", " totalLength", "notaReader", "totaFill", "tokRead", "toteLength", "totBuild", "tOTNeed", "tobyRead", "ptOTRead", "tottFind", "letotWrite", "tottPrint", "ttottRead", "notaWrite", "tfatReader", " toteWrite", "totaWrite", "retotWrit", "ttottWrite", "toticRun", "totedFill", "retottRead", "tfatRead", "totFind", "tfatLoad", "ttotAdd", "tottedPrint"], "out": ["auto", "obj", "up", "ch", "writer", "Out", "g", "ex", "v", "r", "w", "aos", "b", "sys", "log", "io", "conv", "c", "res", "we", "or", "t", "at", "o", "OU", "write", "output", "con", "os", "to", "oss", "end", "co", "s", "outs", "OUT", "net", "n", "ou"], "i": ["ix", "im", "php", "p", "is", "phi", "ui", "v", "hi", "info", "ski", "io", "ci", "multi", "di", "uri", "ei", "set", "ic", "ity", "qi", "ico", "I", "my", "sim", "ia", "index", "ind", "ii", "si", "r", "integer", "e", "iu", "point", "xi", "m", "iii", " I", "ki", "ice", "ip", "ri", "you", "this", "g", "mm", "\u0438", "cli", "me", "zi", "id", "c", "q", "y", "ims", "ij", "chain", "o", "ai", "ie", "print", "bi", "init", "oi", "any", "mi", "it", "x", "gi", "ji", "ini", "ami", "um", "b", "ion", "ti", "j", "iy", "status", "PI", "t", "us", "l", "client", "to", "s", "pi", "iq", "dr", "li"]}}
{"id1": "421042", "id2": "812803", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"url": ["Url", "name", "link", "util", "html", "pl", "path", "key", "domain", "external", "string", "pattern", "char", "xml", "r", "job", "mount", "cl", "file", "config", "location", "b", "log", "gl", "ssl", "resource", "default", "bel", "ld", "dl", "base", "uri", "web", "http", "sl", "nl", "el", "page", "sql", "q", "rl", "str", "impl", "ll", "browser", "address", "ref", "loc", "un", "l", "get", "term", "URL", "ls", "ur"], "in": ["inn", "name", "al", "online", "ln", "include", "init", "is", "mi", "inner", "isin", "din", "source", "min", "update", "nin", "bin", "i", "read", "serv", "gin", "on", "f", "m", "c", "again", "login", "In", "from", "body", "check", "ins", "en", "out", "IN", "o", "l", "line", "con", "ma", "ai", "s", " din", "null", "cin", "input", "rin", "mc", "reader", "vin", "n", "oin"]}}
{"id1": "17475530", "id2": "10451698", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkToImages", "testAddLinkstoPicture", "testAddLinksToPicture", "testAddLinkFromImage", "testAddLinktoImage", "testAddLinksToimage", "testAddLinkFromImages", "testAddLinktoImages", "testAddLinkToPicture", "testAddLinkFromPicture", "testAddLinkFromimage", "testAddLinkForImages", "testAddLinksToImages", "testAddLinkForImage", "testAddLinkstoImages", "testAddLinksToImage", "testAddLinktoPicture", "testAddLinkToimage", "testAddLinkForimage", "testAddLinktoimage", "testAddLinkstoimage", "testAddLinkstoImage", "testAddLinkForPicture"], "in": ["inn", "al", "inc", "up", "init", "include", "is", "it", "and", "inner", "isin", "ex", "ini", "r", "din", "info", "add", "v", "file", "source", "all", "nin", "bin", "i", "k", "gin", "one", "password", "on", "m", "from", "In", "sum", "sein", "or", "set", "check", "ins", "inside", "en", "out", "er", "IN", "at", "o", "by", "doc", "get", "ma", " din", "input", "cin", "rin", "show", "re", "pi", "mc", "ed", "vin", "ind"]}}
{"id1": "8024375", "id2": "16969205", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomSuid", "getRandomSUID", "getRandomUuid", "getRandUuid", "getRandomUUID", "getRandUID", "getRandGUID", "getRandUUID", "getRandomCuid", "getRandomGuid", "getRandUid", "getRandomCID", "getRandomGID", "getRandomCUID", "getRandGid", "getRandomUID", "getRandomUid", "getRandomSid", "getRandGuid", "getRandomSID", "getRandGID", "getRandomCid", "getRandomGid"], "secure": ["sec", "clear", "active", "server", " Secure", "confirmed", "sr", "safe", "sys", "ssl", "weak", "sync", "security", "force", "prime", " insecure", "http", "status", "nice", "service", "protect", " securely", "Secure", "google", "https", "dirty", "sensitive", "client", "quiet", "stable", "strong", "ie", "pretty", "trust", "secret", "encrypted"], "md5": ["MD512", "metadata3", "MD2", " md6", " md2", " mdle", "md45", "dig4", "md3", " md45", "metadata5", "metadata2", "md4", "sha5", "sha512", " md512", "dig5", "metadata45", "md512", "sha3", "MD5", " md4", "md2", "dig3", "sha2", "md6", "MD45", " md3", "MD4", "MD3", "digle", "sha6", "MD6", "MDle", "mdle"], "sbValueBeforeMD5": ["sbValueBeforeIM1", "sbValueAfterMDson", "sbValueBeforeOLD5", "sbValueBeforeSMson", "sbValueBeforeDD512", "sbValueAfterMD5", "sbValueBeforeLM2", "sbValueAfterND4", "sbValueAfterMDLeft", "sbValueBeforeAMD2", "sbValueBeforeMDson", "sbValueBeforeAMDFound", "sbValueBeforeMAC5", "sbValueBeforeSM5", "sbValueWithoutMD512", "sbValueBeforeLM512", "sbValueAfterMD1", "sbValueAfterMD4", "sbValueBeforeMDLeft", "sbValueAfterMDFound", "sbValueBeforeDD65", "sbValueBeforeDS5", "sbValueBeforeLM5", "sbValueAfterMD2", "sbValueBeforeND2", "sbValueBeforeDDFive", "sbValueBeforeOLD512", "sbValueAfterMDFive", "sbValueBeforeND4", "sbValueWithoutDD5", "sbValueBeforeMP2", "sbValueBeforeMS2", "sbValueBeforeOLD2", "sbValueBeforeAMDson", "sbValueBeforeNDson", "sbValueAfterND2", "sbValueBeforeMS3", "sbValueBeforeMD512", "sbValueBeforeMS1", "sbValueBeforeDS2", "sbValueWithoutMD5", "sbValueAfterNDson", "sbValueBeforeMP1", "sbValueBeforeMOD2", "sbValueBeforemdFound", "sbValueBeforeIM2", "sbValueBeforeMT5", "sbValueBeforeMACFive", "sbValueBeforeSM2", "sbValueAfterMD3", "sbValueBeforeMTson", "sbValueBeforeMDFound", "sbValueBeforeMS5", "sbValueBeforeIM5", "sbValueBeforeMOD3", "sbValueBeforeMPLeft", "sbValueWithoutDD2", "sbValueBeforeMOD1", "sbValueBeforeMOD5", "sbValueBeforeDS512", "sbValueWithoutDD512", "sbValueBeforeND5", "sbValueBeforemd2", "sbValueBeforeMD4", "sbValueBeforeMD3", "sbValueBeforeDD5", "sbValueBeforeAMD5", "sbValueBeforeSM4", "sbValueBeforeMAC65", "sbValueBeforeMAC2", "sbValueBeforeDD2", "sbValueBeforeIMLeft", "sbValueBeforeMD2", "sbValueBeforeMDFive", "sbValueBeforeMT2", "sbValueAfterND5", "sbValueBeforeMT4", "sbValueBeforeMD65", "sbValueAfterMD65", "sbValueBeforeMP5", "sbValueWithoutMD2", "sbValueBeforemd5", "sbValueBeforemdson", "sbValueBeforeMD1"], "time": ["name", "ime", "timeout", "counter", "race", "est", "now", "system", "ts", "ty", "estamp", "current", "TIME", "clock", "value", "start", "date", "when", "user", "top", "year", "id", "rate", "timer", "tim", "today", "frame", "set", "age", "t", "history", "Time", "duration", "etime", "work", "length", "total", "times", "client", "size", "runtime", "hour"], "rand": ["rev", "sid", "init", "rd", "and", "inv", "mid", "sample", "r", "nt", "rid", "grad", "ng", "uid", "round", "rank", "rad", "quant", "sam", "gt", "gen", "rate", "id", "pick", "Rand", "res", "reg", "rss", "std", "random", "range", "hash", "red", "serial", "seed", "rh", "frac", "gz", "nd", "rc", "cr", "pid", "dist", "roll", "z", "did", "rot", "rt", "dr"], "valueBeforeMD5": ["valueBeforeMT3", "valueAfterND7", "valueBeforeMOD7", "valueAfterMD3", "valueAfterND5", "valueBeforeMC2", "valueAfterMD2", "valueBeforeMC7", "valueBeforeMOD5", "valueBeforeMT2", "valueBeforeMC3", "valueAfterMD7", "valueBeforeND2", "valueBeforeMT5", "valueBeforeMOD2", "valueAfterND2", "valueAfterND3", "valueBeforeMD7", "valueBeforeMD2", "valueBeforeMOD3", "valueBeforeMD25", "valueBeforeND3", "valueBeforeMT25", "valueBeforeND7", "valueBeforeMC5", "valueBeforeMD3", "valueBeforeND5", "valueBeforeMC25"], "array": ["attribute", "response", "rays", "external", "ray", "image", "Array", "our", "raw", "arrow", "sh", "a", "sample", "RAY", "expression", "number", "buffer", "archive", " Array", "data", "record", "ash", "map", "av", "batch", "atomic", "storage", "audio", "arr", "vector", "instance", "angular", "random", "range", "hash", "object", "feature", "collection", "address", "binary", "angle", "app", "length", "share", "list", "row", "ary", "pair", "var", "area"], "sb": ["obs", "erb", "bg", "ib", "sq", "soc", "bs", "cb", "sth", "sh", "si", "sa", "bh", "sr", "abb", "nb", "lb", "gc", "ssl", "bsp", "bb", "sg", "bp", "sw", "sv", "lp", "eb", "bis", "bf", "gb", "ctrl", "rob", "sf", "wb", "ub", "kb", "pb", "db", "bt", "ob", "rb", "SB", "hs", "zb", "bps", "xb"], "j": ["ix", "msg", "obj", "off", "key", "jump", "uj", "jl", "it", "ji", "g", "v", "ja", "job", "yy", "je", "json", "ju", "jo", "jc", "i", "k", "jack", "oj", "m", "kj", "q", "_", "J", "br", "bj", "__", "str", "ij", "aj", "t", "dj", "us", "jp", "jit", "jj", "js", "z", "att", "bot", "ct", "index", "ind"], "b": ["bi", "bg", "ib", "bc", "bs", "cb", "mb", "v", "B", "a", "ab", "nb", "u", "bd", "k", "ba", "bb", "bar", "bp", "beta", "eb", "bu", "bis", "gb", "bf", "y", "br", "d", "db", "bound", "bt", "rb", "fb", "be", "xb"], "valueAfterMD5": ["valueAfterMD3", "valueAftermd7", "valueAfterID2", "valueAfterMD2", "valueAfterID3", "valueAfterMD7", "valueBeforeMD7", "valueBeforeMD2", "valueAftermd2", "valueAfterID7", "valueBeforeMD3", "valueAftermd3", "valueAfterID5", "valueAftermd5"]}}
{"id1": "5237257", "id2": "6403868", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"download": ["delete", " checkpoint", "init", "Download", "copy", " downloads", "file", "export", " browse", " drop", "dump", "save", " downloading", " zip", "load", " seek", "write", " upload", "paste", "get", "open", " retrieve", " dump", " Download", " restore", " downloaded", " recover", "upload"], "fileName": ["resourceName", "projectname", "FILEFilename", "FileName", " fileFilename", "fileFilename", "FILEPath", "projectName", "filename", "FILEName", "fileTime", "imagePath", " fileTime", "resourcePath", "resourceTime", "resourceType", "fileType", "FILEname", " filename", "FilePath", "projectPath", "FileType", "projectFilename", "FileTime", "imageName", " fileType"], "filePath": ["languageName", "resourceName", "FILEP", "FileName", "FileId", "resourcepath", "ilePath", "FILEUrl", "FILEPath", "FILEStart", "FILEName", "ileStart", " fileUrl", "fileP", "FileP", "fileId", "resourcePath", "languageId", "FILEpath", "resourceUrl", " fileId", "FilePath", "ileName", "ileP", "filepath", "fileStart", "FileStart", " filepath", "languagePath", "fileUrl"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "is", "it", "mi", "ain", "sin", "inner", "isin", "ini", "r", "din", "nin", "bin", "i", "io", "read", "gin", "local", "one", "win", "on", "id", "f", "m", "from", "login", "In", "el", "or", "st", "inside", "ins", "en", "IN", "o", "l", "iter", "con", "ai", "n", "co", "input", "rin", "cin", "ie", "re", "net", "pi", "ar", "inf", "ind"], "out": ["name", "obj", "not", "up", "conn", "ch", "p", "it", "Out", "inner", "ex", "v", "nt", "aos", "w", "outer", "ns", "ent", "file", "sys", "ion", "i", "nin", "cos", "io", "conv", "gt", "user", "on", "ou", "po", "we", "or", "op", "t", "no", "at", "o", "ne", "OU", "write", "output", "client", "os", "null", "con", "to", "oss", "boot", "co", "na", "outs", "OUT", "end", "net", "note", "can", "n", "cn"]}}
{"id1": "9796161", "id2": "2807585", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getMD5": ["toMD7", "toSHA4", "getMD2", "toMD5", "getSHA5", "toSHA7", "getMD7", "getSHA2", "getSHA7", "toSHA5", "getmd7", "getMD4", "getSHA4", "toSHA2", "toMD2", "getmd5", "getmd2", "getmd4", "toMD4"], "s": ["p", "is", "sq", "ts", "ws", "bs", "string", "bytes", "rs", "strings", "v", "ps", "ats", "src", "g", "ns", "sb", "gets", "b", "source", "i", "S", "h", "gs", "ss", "es", "xs", "data", "ends", " gets", "ses", "f", "sv", "ies", "c", "sts", "space", "fs", "abs", "its", "y", "sql", "str", "ms", "text", "t", "ins", "l", "aws", "os", "js", "ls", "n"], "m": ["sm", "M", "nm", "am", "mi", "fm", "g", "v", "dm", "mo", "mm", "man", "e", "mac", "managed", "perm", "gm", "h", "mod", "me", "om", "manager", "rem", "mut", "mu", "pm", "rm", "y", "md", "ms", "hm", "mask", "bm", "cm", "l", "made", "mr", "em", "tm", "vm", "mc", "mt", "mk"]}}
{"id1": "3024992", "id2": "4830847", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 0, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2null_", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter2nullOut", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter2NullOut", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_NULLin", "testCopy_readerToWriter_nullOut", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_null_", "testCopy_readerToWriter_NULLOut", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_NULLIn", "testCopy_readerToWriter_NullOut", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_NULL_", "testCopy_readerToWriter_nullin"], "baout": ["dboul", " bain", "BAit", "abaOut", "baouth", "BAouts", "caOut", "buouts", "baOut", "BAOut", "dbouth", "BAouth", "buin", "gain", "BAin", "gaouth", "dbin", " baOut", "bait", "gaoul", "abaout", "dbout", "buOut", "gaout", "abain", "baoul", " baouts", "abait", "bain", "BAout", "buout", "baouts", "cain", "caout", "BAoul", "cait"], "out": ["it", "Out", "pool", "ex", "sys", "err", "io", "serv", "tmp", " OUT", "gen", "result", "res", "in", "ser", "er", "o", "write", "output", "gr", "null", "outs", "OUT", "net", "n"], "writer": ["println", "Writer", "wrote", "this", "inner", "killer", "wright", "nw", "target", "w", "outer", "writ", "file", "buffer", "builder", "channel", "data", "processor", "handler", "driver", "maker", "worker", "NULL", "service", "usher", "riter", "widget", "er", "rw", "write", "output", "woman", "client", "null", "player", "print", "document", "reader", "window"]}}
{"id1": "693636", "id2": "2198730", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 1, "substitutes": {"createEmptyCart": ["createNewOrder", "createThisProduct", "createEmptyTransaction", "createThisCart", "createThisOrder", "createZeroTransaction", " createEmptyProduct", " createNewCart", "createZeroOrder", "createNewProduct", "createEmptyProduct", "createNewTransaction", "createZeroProduct", "createZeroCart", "createThisTransaction", " createNewProduct", " createEmptyTransaction", " createNewTransaction", " createNewOrder", " createEmptyOrder", "createNewCart", "createEmptyOrder"], "SHOPPING_ID": ["SHOPPAP_ID", "SHOPPTING_URL", "SHOPPINGIDId", "SHOPPINGVALid", "SHOPPAP_IDS", "SHOPPAP_UID", "SHOPPTINGIDNAME", "SHOPPINGIdID", "SHOPPOTINGID", "SHOPPIP_ID", "SHOPPING_UID", "SHOPPOT_UID", "SHOPPOT_IDs", "SHOPPINGINGId", "SHOPPINGIdNAME", "SHOPPING_Id", "SHOPPINGIDUID", "SHOPPIP_UID", "SHOPPINGITID", "SHOPPAP_Id", "SHOPPINGVALUID", "SHOPPINGPIDs", "SHOPPING_VID", "SHOPPINGIdVID", "SHOPPINGITIDs", "SHOPPING_IDS", "SHOPPINGIDID", "SHOPPING_NAME", "SHOPPINGPNUM", "SHOPPTINGIDID", "SHOPPTINGIDURL", "SHOPPTING_ID", "SHOPPOTINGNUM", "SHOPPING_id", "SHOPPTINGIDVID", "SHOPPINGVALID", "SHOPPING_IDs", "SHOPPOTINGIDs", "SHOPPINGPID", "SHOPPINGITNUM", "SHOPPING_URL", "SHOPPINGINGNUM", "SHOPPINGIDURL", "SHOPPINGIDIDS", "SHOPPINGIDVID", "SHOPPINGIdURL", "SHOPPINGITUID", "SHOPPTING_VID", "SHOPPINGINGIDS", "SHOPPOT_NUM", "SHOPPING_NUM", "SHOPPTING_NAME", "SHOPPINGINGIDs", "SHOPPIP_id", "SHOPPINGPUID", "SHOPPINGINGUID", "SHOPPOT_ID", "SHOPPINGINGID", "SHOPPINGIDNAME", "SHOPPOTINGUID"], "con": ["pc", "cons", "conn", "ch", "ln", "soc", "ain", "const", "cc", "pool", "xc", "ex", "connect", "pen", "bon", "pg", "gc", "ren", "cos", "ran", "col", "conv", "win", "cover", "cal", "fc", "c", "cont", "po", "coll", "conf", "com", "nc", "ctrl", "CON", "cur", "en", "bo", "un", "cf", "ctx", "open", "client", "Con", "db", "rc", "connection", "dial", "ca", "co", "re", "Conn", "cat", "mc", "ct", "can", " conn", "cp", "cn"], "insert_cart": ["insertTheprogress", "entry_progress", "insertPcart", "insert_Cart", "import_cart", "insert_cod", " insert_start", "insertMemprogress", "insert2progress", " insert2art", "import___cart", "insertingpt", "insert___cart", "insert_pot", "insert2pot", "entry_art", " insert2cart", "insert_progress", "insert2start", "insert2pt", "entryMemcart", "insert___art", "insert___pt", "import___pt", "insertptquant", "insertThecart", "insertptcod", "insert_controller", "insertingstart", "insertPpt", " insert2pt", "insertMemarticle", "import_Cart", "insert2cart", "insert_article", " insert_quant", " insert2cod", "insertPart", "insert_pt", "import_pt", "insert2cod", "insertTheart", "insertptcart", " insert_pt", "insertPTcod", "insertPTart", "insert___controller", "insertingcart", "insertPcontroller", "entryMemprogress", "insert_art", "entry_article", "insert_start", "insertPTquant", "insertMemart", "import_controller", "insert2art", "insertingart", "insertPTcart", "insert2quant", "insertptart", " insert_cod", "entryMemart", " insert_art", "insertMemcart", "insert_quant", "import_pot", "import___art", "entry_cart", " insert2quant", "insert2article", "entryMemarticle", "import_art", "insertThearticle", "insert2controller", "import___controller", "insert2Cart", " insert2start"]}}
{"id1": "6840241", "id2": "14598566", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copy": ["delete", "link", "system", "opy", "replace", "gc", "cop", "read", "close", "transfer", "map", "cover", "call", "sync", "save", "clip", "slice", "create", "move", "load", "clone", "write", "share", "Copy", "size", "cat", "print", "cp"], "source": ["Source", "cache", "origin", "parent", "image", "shell", "select", "pse", "inner", "stream", "ource", "src", "master", "subject", "sample", "se", "si", "scope", "sr", "wrapper", "info", "start", "session", "resource", "context", "local", "template", "base", "from", "site", "status", "sql", "body", "store", "inside", "ins", "spec", "table", "iter", "input", "ie", "ce", "size", "sp", "SOURCE", "reader", "style", "state"], "sink": ["Source", "asink", "slource", "asinker", "sinker", "sue", "ssender", "sender", "slue", "ssinker", "Sender", "ssink", "asender", " sinker", "ssource", "slender", "asource", "Sink", " sue", " sender", "Sue", "slink", "Sinker"]}}
{"id1": "7087108", "id2": "300397", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"doGet": ["invokeget", " handleGET", " handleSet", " handleget", "doGET", " handleGet", "doSet", "invokeGet", "doget", " doGET", "invokeGET", "invokeSet", " doSet", " doget"], "request": ["attribute", "QUEST", "url", "server", "enter", "initial", "model", "first", "select", "version", "handle", "each", "order", "xml", "begin", "message", "subject", "info", "construct", "Request", "hello", "query", " Request", "question", "change", "controller", "context", "local", "reference", "call", "setup", "application", "project", "complete", "the", "search", "report", "worker", "http", "command", "instance", "store", "frame", "post", "relative", "create", "address", "forward", "open", "get", "client", "position", "req", "core", "requ", "input", "re", "remove", "reset", "transform", "quest", "document", "index", "raw"], "response": ["view", "server", "image", "resp", "xml", "description", "message", "success", "context", "next", "one", "respond", "respons", "default", "application", "result", "res", "report", "http", "page", "status", "onse", "frame", "Response", "body", "out", "write", "output", "os", "render", "connection", "re", "ce", "reply", "print"], "path": ["name", "url", "where", "PATH", "ath", "key", "full", "system", "string", "select", "pattern", "p", "dest", "title", "temp", "mount", "value", "config", "location", "query", "filename", "log", "prop", "template", "project", "base", "uri", "prefix", "check", "text", "relative", "chain", "test", "pkg", "output", "dir", "Path", "route", "th", "transform", "print", "hex", "patch"], "file": ["ile", "port", "name", "mail", "link", "view", "le", "key", "File", "image", "full", "model", "job", "run", "lock", "e", "source", "filename", "resource", "channel", "local", "FILE", "bar", "library", "user", "result", "f", "base", "report", "valid", "page", "form", "bool", "object", "console", "check", "chain", "rule", "binary", "bo", "relation", "spec", "load", "db", "table", "output", "disk", "word", "real", "null", "fe", "to", "tree", "ca", "document", "be", "handle", "upload"], "in": ["inn", "al", "inc", "up", "kin", "is", "it", "and", "sin", "inner", "isin", "ini", "sample", "din", "copy", "mm", "ck", "source", "bin", "i", "asin", "read", "gin", "one", "on", "again", "In", "sum", "or", "pic", "ic", "ins", "en", "out", "mn", "IN", "cm", "l", "con", "s", " din", "cin", "input", "rin", "mc", "reader", "as", "ind", "thin"]}}
{"id1": "21326424", "id2": "18748516", "code1": "    public APIResponse delete(String id) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/variable/delete/\" + id).openConnection();\n        connection.setRequestMethod(\"DELETE\");\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            response.setDone(true);\n            response.setMessage(\"Variable Deleted!\");\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Delete Variable Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"delete": ["execute", "clear", "del", "put", " purge", "commit", "destroy", "download", "query", "update", "de", "close", "data", "dump", "save", "release", "send", "Delete", "post", "check", "service", "create", "insert", "write", "get", "null", "request", "remove"], "id": ["name", "url", "iden", "path", "key", "string", "and", "part", "oid", "description", "message", "rid", "value", "event", "uid", "variable", "kid", "ID", "k", "data", "template", "ment", "aid", "type", "ids", "hash", "md", "code", "item", "ref", "db", "pid", "show", "Id", "ident", "token", "n", "vid"], "response": ["attribute", "sequence", "view", "server", "answer", "image", "version", "model", "action", "resp", "display", "description", "message", "entry", "content", "detail", "value", "json", "controller", "network", "information", "function", "me", "next", "data", "respons", "respond", "default", "example", "error", "application", "result", "exit", "see", "res", "report", "site", "command", "page", "onse", "object", "Response", "service", "hash", "frame", "collection", "summary", "api", "relation", "output", "position", "request", "render", "tree", "self", "reset", "reply", "document", "format"], "connection": ["remote", "character", "Connection", "link", "established", "conn", "writer", "statement", "government", "connected", "description", "subject", "pointer", "entry", "connect", "database", "number", "controller", "location", "network", "ion", "session", "cone", "builder", "creation", "city", "function", "close", "channel", "reference", "information", "library", "application", "c", "communication", "engine", "command", "generation", "console", "set", "office", "language", "condition", "bo", "relation", "client", "open", "con", "position", "to", "request", "license", "reset", "operation", "document", "directory", "wrapper"]}}
{"id1": "6403868", "id2": "21308543", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractuninstallItems", "extractuninstallFiles", "extractunInstallFiles", "extractUnpackFile", "extractunInstallFile", "extractunInstallItems", "extractUninstallFile", "extractUnpackFiles", "extractUnInstallFiles", "extractUninstallItems", "extractuninstallFile", "extractUnInstallFile", "extractUnpackItems", "extractUnInstallItems"], "_destPath": ["_restPath", "_destDir", "_srcKey", "_tempPoint", "_sourceDir", "_srcPoint", "_DestKey", "_privDir", "_destKey", "_DestPath", "_srcPath", "_privPath", "_destPoint", "_privTh", "_DestDir", "_tempPath", "_combDir", "_restPoint", "_srcDir", "_sourceFormat", "_DestPoint", "_restKey", "_destTh", "_DestTh", "_destFormat", "_sourcePath", "_restDir", "_tempFormat", "_combFormat", "_tempTh", "_privPoint", "_combPath", "_tempDir"], "upgrade": ["equcp", "downcheck", " upgrad", "exchange", "equgrad", " upchange", "unate", "exgrades", "upcp", "ungrade", "downchange", "ungrad", "upgrades", " upcheck", "upate", " upgrades", "equate", " upcp", "uncp", "downgrade", " upate", "upchange", "upgrad", "upcheck", "excheck", "equgrade", "downgrades", "exgrade"], "lastVer": ["nextRes", "oldVer", "nextServ", " lastver", "LastVersion", " lastVersion", " lastRes", "oldVersion", " lastVers", "LastVer", "oldVers", "lastVersion", "oldver", "latestVers", "latestVer", "latestServ", "Lastver", "lastVers", "lastServ", "nextVer", "latestRes", "nextVers", "lastRes", "LastVers", " lastServ", "lastver"], "oldlog": ["olderlog", "OLDpath", "OldLog", "OLDLog", "oldererr", "OLDlog", "oldLog", "Oldpath", " oldog", "olderog", "olderr", " olderr", "oldpath", "oldog", "Oldog", "OLDerr", "OLDog", "Oldlog", " oldpath", " oldLog", "olderLog", "olderpath"], "destPath": ["destTime", " destDir", "estName", "potPod", "DestFont", "gestName", "estPos", "destHost", "destNode", "destTh", "gestHost", "DestName", "estRef", " destTh", "locDisk", "descPath", "declFont", " destDirectory", "destFont", " destLog", "privRoot", "destDir", "altNode", "descKey", "destRoot", "srcDirectory", "srcDir", "destFull", "declFull", "foreignStream", "identPath", " destKey", "gestPath", " destParent", "restDir", "DestDir", "destRef", "DestPath", " destHost", "destName", " destPort", "gestTime", "sortFont", "DestFile", " destPoint", "DestRoot", "foreignDir", "DestRef", "identTh", "srcPath", "srcLog", " destRoot", "descNet", "gestDisk", "restPoint", "gestNet", "DestPod", "destPoint", "estDir", "gestNode", "destDirectory", "sortDir", "destPod", "destPos", "destKey", "altName", "destPort", "altPath", "identPort", "destDisk", "DestPoint", "DestFull", "privDir", "srcFile", " destName", "DestParent", "DestPort", "descPos", "srcPort", "destFile", "declDir", "descName", "identPoint", "sortPath", "foreignPath", "potStream", "originPoint", "altDir", "DestLog", "altPoint", "foreignPod", "sortFull", "locPath", " destRef", "potDir", "restFile", " destFile", " destNode", "destLog", "originTh", "originPath", " destPos", "restPath", "DestDirectory", "altHost", "altParent", "originPort", "estKey", "descTime", "privPath", "destParent", "DestPos", "declPath", "destStream", "locTime", "locNet", "descDisk", "potPath", "estPath", "privPos", "DestStream", "destNet"], "lastVerPath": ["lastVERDir", "lastVERVal", "lastVersPath", "lastResPath", "lastVerDir", " lastVersCh", " lastverPath", "highestVerVal", "lastVerspath", "lastverLog", "lastResForm", "highestVerFile", "lastVerForm", " lastVerpath", "lastVERpath", "lastverVal", "lastVERFile", "lastVersionpath", "lastRespath", " lastverDir", "lastResDir", "highestVerpath", "lastVerVal", "lastVERPath", "lastVersionFile", " lastverpath", " lastVerCh", "lastVersCh", "lastVerFile", "lastverDir", " lastVersPath", "lastVersVal", " lastVerFile", "highestVERpath", "lastverForm", " lastVerDir", " lastverForm", " lastVerLog", "lastVersionPath", " lastVerName", "lastVersLog", " lastVerForm", "highestVERVal", "highestVERPath", "lastverCh", "lastVersFile", "lastVersName", "lastVerCh", "highestVERFile", "lastverPath", "lastVerName", "lastVERForm", "lastVerLog", "lastverpath", "lastVerpath", "lastverFile", " lastVersLog", "lastverName", "highestVerPath", " lastVersFile", "lastVersionCh"], "bkdir": ["bkdi", "bckDir", "bckdi", "blkjgroup", "BkDir", "blkjdir", "bakDir", " bakDir", " bkrel", "bkpath", " bakfolder", "Bckdir", " bkkdir", " bkfolder", "bkjdi", "bakdir", "bukpath", " bakdir", "bqdir", "bkkdir", "bkjdir", "Bkpath", "BkDIR", "bckpath", "bukDIR", " bkkDir", "bakdi", "bqgroup", "blkjfd", "blkdi", "bkgroup", "blkjdi", "bkgDir", "bqfd", "bkgdir", " bakdi", " bkkfolder", "bkkfolder", "Bkdir", " bkkrel", "bakrel", "bkDIR", "bkkrel", "bkDir", "bkgfolder", "bkkdi", "bkfolder", "bkjgroup", "bkjfd", "bukDir", "blkdir", "bkkDir", "bckdir", "BckDIR", "blkgroup", "bukdi", "bukfd", "bqdi", "bkkDIR", "bukgroup", " bkDir", "bckDIR", "bkgrel", " bkdi", "blkfd", "Bckpath", "bukdir", "bckfolder", "bakfolder", "BckDir", "bkrel", "bkkpath", "bkfd"], "oldClassCopied": ["oldClassCopie", "oldclasscopies", "oldClassColied", "oldClassReplried", "oldClasscopified", "oldclasscopified", "oldClassCopyified", "oldclasscopie", "oldClassCopyied", "oldClasscopiated", "oldclassCopies", "oldClassChies", "oldclassCopified", "oldClassReplified", "oldDirCopiated", "oldClasscopried", "oldDirReplried", "oldDirCopied", "oldClassCopried", "oldClassChied", "oldDirReplies", "oldClassCopyies", "oldClasscopie", "oldClassCopies", "oldClassReplaced", "oldClassChried", "oldClassRepliated", "oldClassCopiated", "oldclassCopied", "oldClassColaced", "oldClassChiated", "oldClassCopaced", "oldDirReplied", "oldClassCopified", "oldClasscopied", "oldclassCopie", "oldClassReplied", "oldDirCopies", "oldClassCopyie", "oldClassColies", "oldDirCopried", "oldClassColified", "oldClasscopies", "oldClassReplies", "oldDirRepliated", "oldclassCopaced", "oldclasscopied"], "ls": ["cs", "ln", "ws", "ols", "ts", "bs", "rs", "lines", "ps", "las", "els", "irs", "ds", "ats", "ns", "ars", "ils", "gs", "acts", "es", "xs", "less", "LS", "lt", "dl", "abs", "fs", "lists", "lf", "its", "rl", "ms", "lv", "tl", "lc", "vs", "ists", "la", "los", "l", "sels", "lbs", "ics", "les", "qs", "ks", "lis"], "i": ["ix", "bi", "im", "ip", "init", "oi", "key", "mi", "is", "x", "ri", "phi", "gi", "ui", "ji", "it", "si", "a", "ini", "hi", "ami", "u", "cli", "b", "ski", "gu", "io", "ci", "me", "ti", "zi", "j", "multi", "di", "id", "xi", "fire", "m", "batch", "iq", "y", "ic", "eu", "ims", "ei", "qi", "ij", "chain", "us", "ki", "l", "I", "pi", "sim", "index", "ii", "li"]}}
{"id1": "19307120", "id2": "15745420", "code1": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "code2": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "label": 0, "substitutes": {"sendPost": ["sendpost", "doPOST", "dopost", "doText", " sendPOST", " sendpost", "doPost", " sendText", "postPOST", "postPost", "sendPOST", "postText", "postpost", "sendText"], "url": ["mail", "Url", "link", "pl", "path", "pp", "string", "ret", "u", "mount", "file", "location", "log", "ssl", "host", "build", "call", "dl", "base", "uri", "web", "http", "nl", "sl", "q", "str", "ll", "address", "ref", "https", "loc", "l", "term", "URL", "ls", "ur", "ul", "addr"], "param": ["option", "name", "ram", "key", "model", "p", "string", "commit", "amp", "Param", "mm", "argument", "params", "config", "start", "par", "prop", "meter", "property", "dem", "rem", "padding", "password", "cal", "aram", "project", "m", "comment", "conf", "command", "tag", "prefix", "post", "mem", "proc", "term", "block", "row", "input", "sp", "pass", "prom"], "result": ["response", "answer", "p", "string", "Result", "true", "continue", "ret", "confirmed", "description", "message", "memory", "r", "current", "temp", "value", "success", "query", "product", "buffer", "date", "reason", "results", "manager", "match", "data", "default", "complete", "comment", "res", "report", "valid", "command", "status", "sum", "feature", "cur", "code", "chain", "test", "output", "term", "request", "diff", "wrapper", "found"], "httpurl": ["httpsURL", "workUrl", "workurl", " httpURL", "hconn", "hUrl", "httpsconn", "webUrl", "httpsurl", "hURL", "workURL", "workconn", "weburl", "httpURL", "httpsUrl", "httpUrl", "hurl", "webURL", " httpconn", " httpUrl", "webconn", "httpconn"], "httpConn": [" httpConnection", "httpCon", "httpsCon", "httpConnection", "procconn", "procConnection", "hConn", "httpsConn", "hconn", "ttpConn", "httpsconn", "procCod", "ttpconn", "httpObj", "copconn", "hoverConnection", " httpObj", " httpCon", "ttpObj", "hConnection", "copCon", "hoverConnect", "httpConnect", "hoverConn", " httpCod", "HttpConn", "httpCod", "copCod", "hConnect", "procObj", "hoverconn", "ttpCon", "httpsConnect", "HttpCon", "httpsConnection", "Httpconn", "procConn", "ttpConnection", " httpconn", "procCon", "copConn", " httpConnect", "HttpConnect", "httpconn"], "out": ["auto", "timeout", "obj", "up", "ch", "init", "writer", "p", "it", "Out", "inner", "put", "ex", "v", "nt", "aos", "w", "flush", "outer", "cmd", "all", "sys", "cos", "io", "conv", "check", "set", "o", "by", "OU", "write", "output", "os", "to", "oss", "co", "outs", "screen", "OUT", "net", "pretty", "print", "n", "ou"], "in": ["inn", "al", "inc", "ri", "init", "is", "it", "per", "mi", "inner", "isin", "se", "din", "bin", "i", "read", "gin", "on", "from", "In", "el", "ic", "ins", "en", "er", "mn", "IN", "by", "iter", "ma", " din", "cin", "input", "rin", "re", "reader", "inf", "oin", "ind"], "line": ["port", "lane", "sequence", "link", "online", "liner", "le", "ln", "header", "ip", "string", "stroke", "ine", "continue", "message", "se", "lined", "entry", "e", "Line", "file", "point", "log", "email", "LINE", "record", "eline", "comment", "lin", "page", "cell", "body", "frame", "piece", "text", "code", "chain", "rule", "phrase", "l", "iter", "block", "ice", "row", "inline", "field", "print", "pe"]}}
{"id1": "7044685", "id2": "9718328", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    public void actionPerformed(ActionEvent e) {\n        if (\"register\".equals(e.getActionCommand())) {\n            buttonClicked = \"register\";\n            try {\n                String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\");\n                URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\");\n                URLConnection conn = url.openConnection();\n                conn.setDoInput(true);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = rd.readLine()) != null) {\n                }\n                rd.close();\n                wr.close();\n            } catch (Exception ex) {\n            }\n            setVisible(false);\n        } else if (\"cancel\".equals(e.getActionCommand())) {\n            buttonClicked = \"cancel\";\n            setVisible(false);\n        } else if (\"never\".equals(e.getActionCommand())) {\n            buttonClicked = \"never\";\n            setVisible(false);\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["crypted", "crypt", " encrypted", "encryption", "Encryption", " encryption", "cryption", "Encrypt", "Encrypted", "encrypted"], "plaintext": ["aindata", " plainText", "maintext", "ainText", "messagedata", "plainText", "ainstring", " plainprint", " plaindata", "messageText", "plainprint", " plainstring", "aintext", "plainstring", "plaindata", "messageprint", "mainText", "ainprint", "messagetext", "mainstring"], "d": [" md", "ord", "dig", "p", "gd", "cd", "g", "D", "dm", "ds", "dh", "w", "dx", "e", "dec", "od", "ind", "bd", "de", "debug", "h", "sd", "dat", "ad", "mod", "di", "ded", "pd", "ld", "f", "m", "c", "dal", "dl", "done", "fd", "y", "da", "md", "red", "t", "db", "l", "nd", "end", "z", "dd", "did", "dr", "df", "hd"]}}
{"id1": "17580775", "id2": "22320592", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"runInternal": ["loadInternal", "processImpl", "loadinternal", "mainInternal", "mainIntern", "processInternal", "loadImpl", "processinternal", "loadIntern", "runIntern", "mainImpl", "maininternal", "runImpl", "runinternal", "processIntern"], "connection": ["established", "link", "server", "subject", "device", "number", "context", "channel", "function", "reference", "general", "engine", "machine", "collection", "create", "no", "bo", "table", "document", "directory", "Connection", "version", "writer", "statement", "pool", "message", "current", "associated", "event", "controller", "resource", "creation", "computer", "method", "language", "address", "condition", "component", "con", "position", "reset", "connected", "government", "pointer", "database", "information", "translation", "setup", "c", "command", "generation", "relation", "creator", "operation", "encrypted", "character", "initial", "created", "socket", "description", "entry", "connect", "network", "ion", "session", "close", "default", "application", "communication", "page", "console", "client", "open", "to"], "visited": ["VISitted", "vITED", "VISed", "comed", "visitialized", "VISited", "comitted", "visiting", "Visiting", "VISitialized", "vised", "Vised", "comited", "VisITED", "Visitted", "Visited", "vited", "shownITED", "viting", "shownitted", "visITED", "shownited", "Visitialized", "comitialized", "vitted", "showniting", "visitted"], "startTimeStamp": ["startTimeStris", "startTimStamps", "startTimeStAMP", "startTimeStamps", "startTimStamp", "startTimstamp", "startTimestAMP", "startTimeMillamps", "startTimeMillamp", "startTimstAMP", "startTimeStrAMP", "startTimestamps", "startTimestis", "startTimeMillAMP", "startTimstis", "startTimeStramps", "startTimStis", "startTimeStramp", "startTimeMillis", "startTimeStis", "startTimStAMP", "startTimestamp", "startTimstamps"], "delayedProgress": ["delayingprogress", "dayProgress", "deliverContent", "dayedContent", "dayContent", "deliverprogress", "dayedProgress", "delayedprogress", "deliverProgress", "dayprogress", "delayingProgress", "dayedprogress", "delayprogress", "delayingContent", "delayProgress", "delayContent", "delayedContent"], "conn": ["Connection", "obj", "ch", "cert", "resp", "bc", "cmp", "addr", "comm", "cb", "org", "act", "cc", "enc", "nt", "nw", "connect", "cmd", "pg", "err", "col", "conv", "j", "hw", "txt", "c", "dl", "cont", "res", "cfg", "conf", "cell", "nc", "cur", "loc", "jp", "adj", "l", "ctx", "client", "open", "alloc", "con", "n", "exec", "js", "Conn", "mc", "ht", "att", "ct", "cp", "cn"], "fileName": ["fileValue", "resourcename", "resourceName", "FileName", "filename", "displayname", "filePath", "displayName", "resourcePath", "resourceType", "displayPath", "fileType", "displayValue", "Filename", " filename", " filePath", "FilePath", "FileType", " fileValue", "FileValue", " fileType"], "disp": ["DISpend", "wordP", "disP", "dispa", "disn", "layp", "desr", "nlp", "disccp", "lyn", "nlP", "Dispi", "laypol", "defp", "DisP", "defP", "disr", "lypi", "desp", "serpi", "laycp", "Disr", "dispi", "dispol", "discp", "discpol", "DIScp", " dispa", "sern", "serpa", "dispo", "defpi", " dispi", "Disp", "wordpat", "DISp", "lyp", "desP", "defr", "DISpol", "wordp", "despi", "serp", "Dispo", "lypa", "wordpo", "laypend", " disn", "dispend", "discpend", "nlpat", "nlpo", "dispat", "Dispat"], "p": ["pc", "php", "pp", "part", "v", "ps", "r", "pointer", "pro", "perm", "pg", "change", "pos", "vp", "point", "ph", "par", "i", "h", "pad", "np", "P", "j", "conv", "padding", "pa", "bp", "f", "m", "c", "lp", "ping", "op", "t", "pre", "pers", "jp", "dp", "d", "pkg", "wp", "pat", "pid", "sp", "pi", "primary", "n", "cp", "tp"], "response": ["remote", "sequence", "timeout", "yes", "escription", "server", "amount", "none", "version", "resp", "image", "continue", "description", "message", "index", "entry", "value", "json", "success", "number", "pos", "network", "function", "next", "respons", "zero", "error", "example", "application", "result", "exit", "type", "res", "time", "page", "status", "onse", "frame", "Response", "code", "environment", "relative", "no", "relation", "duration", "ne", "length", "total", "position", "block", "tree", "request", "more", "reset", "roads", "reply", "bytes"], "contentType": ["cellLength", "documentTYPE", "contentTypes", "ContentLength", "commandTypes", "contentTYPE", "messageLen", "contentTy", " contentLength", "cellTYPE", "commandLength", "messageTYPE", " contentTy", "documentLength", "ContentTypes", "ContentTy", "contentLength", "cellType", "documentLen", "messageLength", "commandTy", "messageType", "ContentType", "cellLen", "documentType", "commandType", " contentTypes"], "contentEncoding": ["contentDecoded", " contentEncryption", "contentDecoding", "contentencoring", " contentEncoder", "contentEnoding", "contentEncryption", "contentEncoring", " contentEncoring", "contentEnryption", "contentEncoded", " contentEnryption", "contentEncoder", "contentEvLength", "contentDecryption", "contentEnoder", " contentEnoring", " contentEncLength", "contentEncLength", "contentEnoring", " contentEnLength", "contentencoder", "contentDecLength", "contentencoding", "contentDecoder", " contentEnoder", "contentEvoder", "contentEvoded", " contentEncoded", " contentEnoding", "contentDecoring", "contentEnLength", " contentEnoded", "contentEnoded", "contentencryption", "contentEvoding"], "contentLen": ["componentLen", "ontentSize", "componentSize", "ontentLength", "ContentLen", "messageColl", "ontentNet", "ContentLength", "messageLen", "contentlen", " contentLength", "ContentSize", " contentSize", " contentColl", "componentlen", " contentNet", "contentLength", "ontentLen", "componentColl", "messagelen", "contentNet", " contentlen", "contentSize", "contentColl", "ContentNet", "messageSize"], "is": ["im", "are", "ip", "does", "version", "iss", "iz", "isd", "Is", "network", "i", "ss", "es", "IS", "id", "http", "its", "ih", "ims", "ize", "ists", "ism", "isc", "ice", "ie", "pi", "ist", "ii"], "url": ["Url", "link", "name", "html", "server", "path", "domain", "version", "string", "pattern", "org", "char", "xml", "mount", "location", "ssl", "host", "channel", "build", "git", "bel", "id", "dl", "base", "uri", "web", "http", "site", "page", "str", "ll", "browser", "address", "ref", "https", "l", "client", "www", "URL", "ls", "ur"], "loadNext": ["loadnext", "loadMore", " loadedMore", "loadedNext", " loadedFirst", " loadnext", " loadFirst", "loadedMore", " loadMore", " loadednext", " loadedNext", "loadedFirst", "loadednext", "loadFirst"], "itemsLoadedPartially": ["itemsLoadedpartially", "itemsLoadsPartully", "itemsLoadsPartial", "itemsLoadsPartially", "itemsLoadedpartial", "itemsLoadsPosially", "itemsLoadedPosully", "itemsLoadsPosfully", "itemsLoadedPosially", "itemsLoadedOnlyially", "itemsLoadedOnlyial", "itemsLoadedPartully", "itemsLoadedpartfully", "itemsLoadsPartfully", "itemsLoadedOnlyully", "itemsLoadedOnlyfully", "itemsLoadsPosial", "itemsLoadedpartully", "itemsLoadedPartfully", "itemsLoadedPosial", "itemsLoadedPartial", "itemsLoadedPosfully", "itemsLoadsPosully"]}}
{"id1": "13414771", "id2": "9347451", "code1": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 0, "substitutes": {"encriptPassword": [" descryptField", "EnribePassword", " descryptAuth", " desribePassword", " desribeAuth", " descryptPassword", "EncriptAuth", " desizeAuth", " desribeField", " descriptAuth", "EnribeAuth", " desizeKey", " descriptField", "EncriptField", " desribeKey", "EnribeField", "EnribeKey", " descriptKey", " desizePassword", " descriptPassword", "EncriptPassword", " desizeField", " descryptKey", "EncriptKey"], "passwd": ["passw", "defword", "mailw", " password", "assphrase", "psword", "pasw", "assword", "mailword", "mailphrase", "mailwd", "defw", "pwd", "paswd", "password", " passsword", "passsword", "pw", "passphrase", " passw", "pword", "defphrase", "pasword", "asswd", "assw", "defwd"], "md": ["mail", "sm", " MD", "and", "mt", "cd", "mb", "MD", "add", "nt", "dm", "dh", "ds", "mm", "mo", "der", "od", "cmd", "managed", "hd", "ind", "bd", "sd", "mod", "di", "ld", "m", "pdf", "down", "pm", "rm", "ms", "red", "desc", "mask", "mg", "hm", "mn", "at", "d", "ma", "dd", "td", "mc", "dr", "mk", "df", "pd"], "hash": ["cache", "ashed", "key", "uh", "sq", "ssh", "sh", "bh", "message", "sample", "mac", "h", "her", "ash", "checked", "password", "hed", "mass", "Hash", "ah", "sum", "check", "mask", "proof", "rh", "trust", "shadow", "kernel", "hex", "score", "filter", "hidden", "has", "oh", "hd", "sha"]}}
{"id1": "9272325", "id2": "7468827", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"sendPost": ["doPOST", "executeRequest", "httpGet", "doGet", "httpPOST", "doRequest", "doPost", "sendGet", "executePost", "executePOST", "executeGet", "httpPost", "sendPOST", "httpRequest", "sendRequest"], "reqUrl": ["requestUrl", "resStr", "requName", "reqPath", "requestPath", "requUrl", " reqPath", " reqStr", "resUrl", "requLink", "reqLink", "seqURL", "reqName", "reqStr", "seqUrl", "seqName", " reqURL", "seqLink", " reqName", "resURL", "requestURL", "resPath", " reqLink", "requURL", "reqURL", "requestStr"], "parameters": ["parmes", "promams", "publiceter", "promuments", "promations", "paruments", "equeters", "arameters", "equams", "aramuments", "paramuments", "equations", "paramams", "arammes", "publicams", "prometers", "parameter", "arameter", "parammes", "prometer", "pareter", "prommes", "publications", "publiceters", "pareters", "paramations", "equeter"], "urlConn": ["relConnection", "mountConnector", "utilConnection", "urlCo", "mountCtrl", " urlConnect", " urlConnector", "rowCo", "objCo", "retConn", "webConnect", "resourceLink", "objConn", "relCo", "resourceConn", "mountConn", "belConn", "retConnect", "urlConnector", "mountCo", "fileconn", "relConn", "urlCon", "fileConn", "urlConnection", " urlCon", "implDesc", " urlCtrl", "mountconn", "URLconn", "utilConnector", "nlConnect", "sslCond", "sslDesc", "urlConnect", "belDesc", "leftConn", "implCond", "sslCon", "mountWr", "sslCo", "nlConnector", "URLConnect", "implConn", "leftConnect", "objCtrl", "URLConn", "webConn", "httpConnection", "nlConn", "belCond", "URLCon", "urlLink", "httpConnect", "rowConn", "fileConnection", "sslConnector", "utilConn", "urlDesc", "httpConn", "urlCtrl", "rowConnection", " urlCo", "relconn", "sslConnect", "nlConnection", "leftconn", "implConnection", "fileCon", "utilConnect", "leftCon", "belConnection", "resourceWr", "resourceconn", "retconn", " urlWr", "relConnector", "sslConnection", "sslconn", "urlWr", "mountLink", "urlconn", "rowconn", "httpConnector", " urlConnection", " urlconn", "urlCond", "objconn", "sslConn", "webconn", " urlLink"], "params": ["units", "p", "string", "posts", "rs", "ps", "v", "json", "Parameters", "values", "config", "AMS", "points", "param", "keys", "tags", "results", "data", "padding", "pps", "password", "files", "phys", "m", "base", "services", "pins", "conf", "prefix", "changes", "types", "terms", "s", "ams", "options", "names", "bytes", "properties"], "url": ["Url", "name", "hl", "loader", "r", "sb", "mount", "lb", "location", "log", "ssl", "build", "bel", "f", "dl", "il", "abs", "uri", "base", "web", "http", "nl", "sl", "el", "uu", "rl", "str", "ll", "t", "out", "au", "https", "loc", "pkg", "l", "get", "URL", "self", "ls", "ur", "ul"], "b": ["bits", "obj", "p", "bc", "it", "bs", "cb", "mb", "v", "a", "B", "r", "w", "sb", "nb", "u", "buffer", "bin", "i", "buf", "bb", "orb", "bp", "bit", "f", "eb", "base", "m", "batch", "bis", "bf", "gb", "br", "buff", "binary", "d", "db", "l", "ob", "block", "n", "rb", "s", "z", "fb", "be", "bytes"]}}
{"id1": "10131427", "id2": "9236363", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" Copyfile", " copyStream", " CopyImage", " copyImage", "CopyFile", " cpImage", "CopyStream", " cpfile", " copyfile", " CopyFile", " CopyStream", " cpFile", " cpStream", "Copyfile", "CopyImage"], "in": ["inn", "inc", "up", "is", "it", "isin", "old", "r", "din", "mm", "source", "b", "i", "gin", "edIn", "on", "from", "In", "el", "ic", "st", "ins", "en", "IN", "o", "l", "n", "s", "input", "rin", "cin", "ar", "vin", "inf", "ind"], "out": ["ch", "it", "Out", "v", "ex", "nt", "w", "file", "b", "log", "err", "i", "io", "serv", "gt", "po", "ot", "check", "help", "str", "t", "o", "ne", "l", "output", "os", "to", "s", "oss", "outs", "OUT", "net", "n", "ou"], "sourceChannel": ["srcchannel", "singleApplication", "sourceStream", "seedButton", "resourceChannel", "ourceChannel", "singleChannel", "sourcechannel", "srcStream", "singleChuck", "seedChuck", "sourceConnection", "matchApplication", "sourceChain", "inputChain", "srcButton", "sourceApplication", " sourceChan", "ourceChan", "inputChan", "inputChannel", " sourceChain", " sourcechannel", "Sourcechannel", "sourceChuck", "seedApplication", "ourceButton", "singleButton", "matchButton", "ourceChain", " sourceButton", "srcChannel", "inputConnection", "sourceChan", " sourceConnection", "matchChannel", "matchChuck", "sourceButton", "ourcechannel", "SourceStream", "resourceStream", "seedChannel", "SourceChannel", "SourceConnection", " sourceStream", "resourcechannel", "ourceStream", "resourceConnection", "ourceConnection"], "destinationChannel": ["DestinationBlock", "destationChannel", "destensionConnection", "destinatoryChannel", "DestensionChan", "DestationCow", "destroyClient", "destinatedChan", "destinationsChannel", "destroyChannel", "DestationChan", "destinationsContext", "destationChan", "destroyConnection", "destinatedConnection", "DestationConnection", "DestinationCow", "DestinationClient", "destinatoryCow", "DestationContext", "DestensionConnection", "destationContext", "destinatedChannel", "destinationBlock", "DestensionChannel", "destationCow", "destroyChan", "destensionChannel", "destinationsChan", "desticationCow", "destinationContext", "destensionClient", "DestationChannel", "destinatedContext", "DestationBlock", "destinationClient", "destationClient", "DestensionClient", "desticationChan", "destinationsConnection", "destinatoryChan", "DestinationContext", "destensionChan", "DestinationChannel", "destationConnection", "destinationChan", "DestinationChan", "desticationChannel", "destinationCow", "destinatoryBlock", "destinationConnection", "destationBlock", "desticationBlock", "DestinationConnection"]}}
{"id1": "15445861", "id2": "17557289", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpFiles", " copyDir", "cpfile", " cpfile", "cpDir", " cpFile", " cpDir", "copyDir", "cpFile", " cpFiles", "copyFiles", "copyfile", " copyFiles", " copyfile"], "srcFile": ["srcDir", "sourceFile", "sqFile", "synfile", " srcPage", " srcTime", "srcfile", "sourceLine", " srcDir", "rcfile", "sourceModel", "destModel", "sysfile", "destPage", "synFile", "rcLine", "sysFile", "synLine", "rcTime", "srcPage", "rcFile", " srcModel", "sysWeb", "sysLine", " srcfile", "destfile", "srcModel", "srcPath", "srcLine", " srcWeb", "sqLine", "rcPath", "sourceDir", "sqTime", "srcTime", "rcPage", "sqPage", "rcDir", "sourcePath", "srcWeb", " srcPath", " srcLine", "sourcefile", "sourcePage", "synWeb"], "destFile": ["sourceFile", "gtFILE", "tomPort", " destDir", "portPage", "potDir", "destPage", "optFolder", "portLine", "DestDir", "Destfile", "gtEmail", "sourceFine", "gtFile", "destPort", "tomFILE", "gtPort", "estPort", "portPlace", "expFile", "DestTable", "destFine", "destTable", "gtPage", "estFILE", " destPort", "potPort", "imgDir", "destFolder", "destEmail", "imgFine", "expPage", "expLine", "DestFile", "estFile", " destFolder", " destTable", "DestFolder", "gtPlace", " destfile", "optDir", "optTable", "destLine", "expPlace", "destfile", "estEmail", "destFILE", "tomFile", "DestPort", "tomEmail", "optFile", "portFile", "sourceDir", "potfile", "imgFile", "destDir", "gtLine", "imgfile", "potFile", "sourcefile", "destPlace", "DestFine"], "in": ["inn", "im", "al", "inc", "up", "init", "is", "it", "ain", "act", "inner", "isin", "old", "ini", "din", "info", "mm", "irm", "source", "i", "io", "gin", "on", "from", "In", "el", "ic", "inside", "ins", "en", "IN", "by", "inf", "con", "iter", "input", "rin", "cin", "ar", "ze", "ind"], "out": ["auto", "obj", "cache", "up", "ch", "writer", "it", "and", "Out", "inner", "ex", "v", "nt", "aos", "outer", "dis", "gc", "sys", "log", "err", "io", "one", "user", "on", "c", "res", "sum", "cn", "t", "at", "o", "by", "ne", "write", "output", "client", "con", "null", "to", "end", "co", "outs", "OUT", "net", "can", "n", "ou"], "buffer": ["attribute", "character", "sequence", "cache", "initial", "display", "document", "message", "sample", "memory", "stack", "temp", "bridge", "bone", "variable", "pad", "buf", "reason", "Buffer", "append", "bank", "template", "bar", "library", "queue", "batch", "base", "comment", "command", "body", "frame", "mem", "buff", "binary", "history", "phrase", "table", "total", "length", "word", "iter", "paste", "block", "row", "print", "window", "raw"], "no": ["ni", " No", "yes", "not", "go", "none", "vo", "never", " NO", "a", "mo", "eno", "index", "who", "nn", "how", "ko", "number", "node", "nr", "No", "pos", "start", "i", "io", "read", "zero", "num", "po", "ano", "nos", "NO", "lo", "un", "ne", "o", "sn", "bo", "total", "os", "to", "orno", "na", "n", "sha"]}}
{"id1": "3745402", "id2": "2525897", "code1": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 1, "substitutes": {"createCipher": ["createChip", "createClipher", "CreateClBlock", "createClortex", "CreateCBlock", "CreateCip", "CreateClortex", "createCip", "createCCortex", "createClBlock", "createChipher", "createCCBlock", "createCCip", "createClip", "createCBlock", "createChortex", "createCortex", "CreateCipher", "CreateClip", "CreateClipher", "CreateCortex", "createCCipher", "createChBlock"], "passwd": ["passw", "pPassword", "secretPassword", "ppassword", "Passsword", "passWD", "secretpassword", "pasWD", "allowPassword", " passphrase", "pwd", "paswd", "password", " passsword", "alloww", "passsword", "passpassword", "passPassword", "Passwd", "PassWD", "Passphrase", "passphrase", "pw", "allowpassword", "allowwd", " passWD", "secretw", "pasphrase", "secretwd"], "mode": ["name", "sequence", "theme", "power", "version", "stroke", "operator", "DE", "message", "Mode", "device", "mm", "config", "purpose", "de", "mod", "me", "default", "password", "method", "m", "type", "force", "role", "format", "time", "command", "status", "scale", "te", "range", "depth", "code", "loop", "phrase", "module", "position", "size", "MODE", "ode", "state"], "keySpec": ["KeyDef", "ekSpec", "keyspec", "caseConfig", " keySpe", "caseSpe", "ekspec", " keyDef", "Keyspec", "caseSupp", "KeyConfig", "keyDef", "KeySpec", "caseSpec", "keySupp", "keySpe", " keySupp", "KeySpe", "ekDef", " keyspec", " keyConfig", "ekSpe", "keyConfig", "KeySupp"], "keyFactory": [" keyGen", "KeyFact", "linkFact", " keyFact", " keyFamily", "keyFamily", "pairFactory", "KeyGen", "keyGen", "KeySpec", "linkFactory", "pairFamily", "pairFact", "linkGen", "KeyFamily", "keyFact", "KeyFactory", "pairSpec"], "key": ["name", "cache", "ch", "cert", "p", "char", "sk", "message", "lock", "source", "k", "context", "data", "KEY", "password", "root", "result", "Key", "type", "crypt", "sum", "y", "service", "hash", "chain", "out", "ki", "seed", "client", "ke", "get", "policy", "ek", "ca", "input", "token", "net", "pair", "mk", "secret", "sky", "state"], "md": ["sm", "magic", "dig", "and", "mt", "cd", "mb", "MD", " cmd", "dm", "dh", "mo", "mm", "der", "od", "cmd", "grad", "hd", "mac", "bd", "de", "sd", "mod", "ld", "m", "det", "pdf", "fd", "Cmd", "hash", "ms", "red", "mg", "mn", "d", "nd", "met", "mand", "js", "dd", "td", "mc", "dr", "mk", "df", "pd"], "digest": ["Digest", "mditude", " digist", "mdEST", "Diget", "dest", " digested", "ditude", "diger", "digitude", "minet", "mdest", "minest", "diget", "digests", "digress", " digitude", "decer", "mdress", "digested", "decests", "miner", "mdist", "digEST", "decEST", "Diger", "Digress", "DigEST", "dist", "decet", "digist", "decress", "Digests", "dested", "decest", "minEST", "mdests", "mdested"], "salt": [" sbit", "satter", "cALT", " sass", "sALT", "calt", " saled", " satter", "sart", "sbit", "Sass", "Sbit", "SALT", "Salt", "cbit", "strift", "snapatter", "sass", "Sift", "strALT", "Satter", " sift", "strass", "saled", "snapalt", "Saled", "stralt", " sALT", " sart", "snapALT", "caled", "sift", "snapart", "Sart"], "i": ["ix", "im", "bi", "ip", "p", "is", "mi", "x", "it", "phi", "gi", "ui", "ji", "si", "v", "a", "ex", "ini", "info", "index", "u", "iu", "b", "err", "io", "ci", "ti", "zi", "multi", "j", "di", "id", "xi", "f", "m", "batch", "ii", "q", "y", "ic", "set", "slice", "ms", "qi", "t", "us", "o", "ai", "I", "s", "ie", "pi", "ish", "sim", "n", "ind", "li"], "paramSpec": ["pixelSpe", "pixelSpec", "pixelSet", "aramType", "paramSpe", "parConfig", "paramSec", "paramConfig", "paramType", "ParamSpec", "aramConfig", "parSpe", " paramConfig", "ParamSet", "ParamSpe", "aramSec", "aramSpe", "aramSet", "parSec", "paramSet", "parSpec", "pixelType", "aramSpec", " paramSpe", "ParamType", " paramSec"], "cipher": ["curaster", "cooder", "uciph", "encaster", "curiper", "Cipher", "ciph", "curipher", "cusiber", "ciper", "encipher", "Cacher", "xciber", "curoder", "cusiph", "cusipher", "ucipher", "ciber", "Coder", "coiper", "encoder", "coacher", "xcipher", "caster", "enciper", " cacher", " coder", "Caster", "clisher", "uclisher", "xciph", " ciper", "xclisher", "cacher", "coder", "coipher", "Ciper", "uciber", "cuslisher"]}}
{"id1": "5951610", "id2": "149935", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": ["testApplicationHTTP", "testNetURL", "TestNetworkHTTP", "TestNetHTTP", "testNetHTML", "testNetHTTP", "testNetworkHTML", "TestNetURL", "testApplicationURL", "testNetworkURL", "TestNetworkURL", "testApplicationHTML", "TestNetHTML", "TestNetworkHTML"], "url": ["mail", "Url", "link", "hl", "util", "obj", "html", "pl", "path", "cert", "conn", "org", "back", "ret", "bl", "r", "u", "mount", "cl", "lb", "location", "b", "all", "log", "gl", "ssl", "resource", "channel", "host", "email", "lt", "m", "dl", "base", "il", "uri", "github", "web", "http", "nl", "sl", "el", "rl", "console", "ocl", "str", "fl", "impl", "t", "ll", "address", "ref", "https", "loc", "rel", "l", "get", "term", "lr", "blog", "www", "pull", "URL", "ml", "acl", "norm", "print", "ls", "ur", "ul"], "urlConnection": ["sslDiscussion", "dbPosition", " urlConn", "utilConnection", "httpSet", "lsConnect", "emailConnection", "methodConnection", "browserConn", "emailConnect", " urlConnector", " urlConnect", "urlInfo", "lrConn", "railConnect", "resourceConn", "lrConnection", "lsConn", " urlResponse", "urlConnector", "browserConnection", "mlConn", "fileDiscussion", "urlListener", "fileConn", "urlCon", "browserConnect", " urlCon", "utilSet", "urlResponse", "managerConnection", "urlSet", " urlDiscussion", "railConnection", "railHandler", "utilConnector", "urlHandler", "urlConnect", "sslPosition", "httpInfo", " urlSet", "lrConnector", "lsConnection", "nameConnection", " urlHandler", "nameConnect", "implConn", "consoleConnection", "mlCon", "consoleConn", "lsConnector", "managerInfo", "fileConnect", "httpConnection", "implConnector", "emailConnector", " urlListener", "browserConnector", "urlPosition", "urlService", "emailConn", "httpHandler", "railListener", " urlInfo", "httpConnect", "methodConnector", "fileConnection", "sslConnector", " urlService", "dbConnection", "utilConn", "urlConn", "implConnect", "nameConn", "mlMachine", "resourceResponse", "consoleCon", "dbConnect", "httpConn", " urlMachine", "resourceConnector", "resourceConnection", "nameConnector", "dbConn", "urlDiscussion", "sslConnect", "implConnection", "utilConnect", "utilService", "methodConn", "lrResponse", "methodConnect", "sslConnection", "consoleMachine", "managerConnect", "managerConnector", "mlConnection", "httpConnector", "urlMachine", "utilListener", "httpService", "httpListener", "sslConn", " urlPosition"], "rd": ["drm", "rod", "ered", "rend", "ri", "rer", "ord", "dig", "gd", "ined", "rs", "adr", "nder", "hr", "repl", "r", "din", "ped", "rr", "rand", "rn", "rid", "rx", "grad", "ck", "wr", "bd", "art", "ird", "rown", "RD", "dra", "ptr", "rez", "ded", "ld", "fd", "std", "rm", "rl", "rob", "red", "xd", "rg", "rw", "d", "rh", "usr", "nd", "ra", "dir", "mr", "erd", "rc", "rb", "lr", "rax", "fr", "dd", "rt", "dr", "rus", "ind"], "line": ["port", "link", "where", "online", "len", "liner", "ln", "le", "none", "stay", "string", "ine", "part", "continue", "lines", "pipe", "message", "entry", "edge", "lock", "cl", "side", "Line", "number", "file", "node", "point", "buffer", "log", "channel", "next", "email", "LINE", "record", "eline", "error", "comment", "lin", "time", "nl", "LIN", "page", "status", "cell", "frame", "set", "check", "range", "zone", "load", "loop", "lo", "l", "length", "iter", "block", "ice", "row", " LINE", "inline", "column"]}}
{"id1": "7006052", "id2": "13499897", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyFilesTo", "copyfileFrom", " copyFilesFrom", " copyFilesThrough", "copyToFrom", " copyFilesTo", "copyFileThrough", "copyfileOver", " copyFileThrough", "copyFilesThrough", "copyFilesFrom", "copyFilesOver", "copyToTo", "copyToOver", "copyFileOver", " copyFilesOver", "copyfileThrough", " copyFileOver", "copyToThrough", "copyFileFrom", " copyFileFrom", "copyfileTo"], "src": ["Source", "url", "sec", "obs", "init", "inst", "sq", "bs", "sin", "rs", "sr", "sb", "rx", "config", "source", "start", "sys", "cos", "sit", "ipl", "txt", "cont", "http", "ctr", "rl", "st", "cur", "ins", "ser", "sf", "usr", "rel", "pkg", "sc", "req", "rc", "input", "rt", "iv"], "dest": ["port", "origin", "orig", "exp", "est", "del", "pl", "Dest", "nt", "target", "source", "de", "tmp", "dat", "result", "done", "cont", "way", " dst", "good", "st", "desc", "mem", "them", "loc", "test", "usr", "d", "des", "dir", "req", "end", "dist", "www", "pub", "trans", "home", "rest", "decl"], "destFile": ["srcDir", "sourceFile", "srcfile", "destPage", "DestDir", "Destfile", " destPage", "distPage", "DestFile", "distfile", "srcFile", " destfile", "newDo", "destfile", "destFiles", " destDo", "sourceFiles", "newfile", "sourceDir", "newFile", "srcFiles", "distDo", "destDo", "newPage", "destDir", "DestFiles", "distFile", "sourcefile"], "in": ["inn", "im", "al", "inc", "up", "init", "is", "it", "per", "ain", "act", "sin", "inner", "isin", "ini", "din", "info", "mm", "ze", "bin", "i", "io", "read", "gin", "on", "from", "In", "el", "ic", "ins", "inside", "en", "IN", "iter", "con", "ai", "rc", "cin", "rin", "input", "inf", "ind"], "out": ["auto", "obj", "writer", "p", "it", "and", "Out", "inner", "g", "v", "ex", "nt", "aos", "outer", "b", "sys", "cos", "io", "gt", "on", "res", "po", "we", "ot", "cn", "t", "en", "at", "o", "by", "ne", "write", "output", "client", "os", "null", "con", "to", "oss", "co", "outs", "OUT", "net", "can", "n", "ou"], "buf": ["cap", "obj", "msg", "alph", "cv", "bc", "tx", "bus", "cb", "bh", "seq", "cmd", "b", "buffer", "var", "log", "bin", "pad", "prop", "Buffer", "uf", "data", "conv", "bar", "box", "gen", "tab", "queue", "batch", "arr", "cam", "mu", "good", "br", "str", "bag", "cur", "Buff", "img", "buff", "abet", "pkg", "vec", "db", "cf", "block", "rb", "cat", "aka", "bytes", "cp"], "len": ["cap", "elt", "pl", "ln", "le", "exp", "del", "cmp", "lon", "v", "nt", "mid", "seq", "e", "mun", "pos", "fin", "val", "ld", "il", "dl", "coll", "el", "lf", "str", "ll", "en", "t", "no", "rel", "la", "l", "length", "vec", "Len", "lan", "wid", "count", "lic", "end", "z", "compl", "lif", "size", "ls", "n"]}}
{"id1": "2022160", "id2": "18211588", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"write": ["port", "execute", "link", "fit", "writer", "find", "apply", "fail", "put", "process", "commit", "copy", "flush", "w", "connect", "writ", "run", "partial", "change", "log", "network", "walk", "rite", "read", "close", "next", "append", "export", "call", "wire", "sync", "batch", "see", "written", "save", "only", "send", "wait", "patch", "scale", "store", "set", "code", "Write", "create", "output", "get", "to", "render", "end", "size", "cycle", "print", "wrote", "writing", "register", "handle", "format"], "byteBuffers": ["byteCountters", "byteNamesers", "bytesPackerers", "byteIndexerers", "ByteBuffers", "byteOffer", "byteOffters", "bytesBuffators", " byteBuffusters", "bitBuffonents", "bytebuffodes", "byteFrags", " byteNamesines", "ByteBuffERS", "bitEnters", "ByteHeadrs", "byteCounters", "byteNamesERS", " bytePackers", "byteBytesERS", "byteBytess", " bytePackusters", "bytesPackators", "bytesHeadters", "bytesHeadered", "bytesHoldters", "bytesbufflers", "byteIndexators", "bytePackators", "bytebuffainers", "bytePacklers", "byteBuffines", "ByteHeadERS", "bytebufflers", "bytebuffERS", " byteBuffels", "byteEntrs", "bytePackters", " bytePacklers", "byteBuffrys", "bytePackrs", "bytePackainers", "byteHoldiers", "byteHeader", "bytesHeaders", "bytebuffines", "byteCombonents", "byteDeflers", "byteFragers", "byteEnters", "byteOrders", "byteBuffERS", " bytebuffters", " byteNameserers", "byteBuffonents", "bytesbuffrys", "byteBytesrys", " byteBufferers", "bitBuffrs", "byteOffered", "bitBuffers", "bytesBuffters", "byteCombers", " byteNamesers", " byteBuffs", "bytesBuffer", "byteBindERS", " byteDefERS", "bytebuffers", "bytesBufflers", "bytebuffiers", "byteBuffrs", "bytesBuffered", "bytebuffusters", "bytePackers", "bytesbuffers", "bytebufferers", "byteBufferines", "byteNamesines", "byteBuffiers", " byteBuffERS", "byteBuffters", "bitBuffters", "byteHolderers", "bytesBuffrys", "byteCountERS", "byteBufferlers", "byteEntters", "byteCorners", "byteCombters", " byteBuffainers", "bytebuffters", "bytesPackers", "bytesHoldERS", "byteHeadERS", "bytePackerers", " bytebuffERS", "byteBufferters", "bytePacker", "bitEntrs", "byteBytesers", " byteDefels", "ByteHeadered", "byteBufferERS", "byteHeadrs", " byteBuffines", " byteBuffters", "bytebuffs", "byteDefels", "bytebuffered", "byteBindodes", "byteHoldERS", "bytesbuffodes", "byteBinders", "byteBufflers", "byteBuffererers", " byteDeflers", "byteCountered", "byteBufferers", "byteHoldered", "byteCornerers", "byteBindlers", " bytebuffers", "bytesbuffs", "byteOffers", "byteCorniers", "byteBufferered", " byteBuffered", "bytesBuffodes", "byteBuffodes", "bitEntonents", "ByteBuffered", " bytebuffiers", "bytebuffrys", "bytesBuffs", "byteHoldters", " bytePacks", "byteHolders", "byteOrdrs", " bytePackainers", "byteWaitERS", "byteHeadters", "bytesHolders", "byteBuffels", " bytebufferers", "bytesBufferers", "byteOrdters", "byteBuffators", "byteIndexers", "bytesHoldered", "byteOrdonents", "byteBuffainers", "bytesPackrs", " byteBufflers", "bytePackered", "byteCombrs", "bytesBuffrs", " bytePackerers", "byteWaitainers", "bytePackrys", " byteDefers", "bitEntters", "bytesBuffers", "byteIndexrs", "byteBuffusters", "byteDefers", "bytePackusters", "byteEntonents", " bytebuffered", "bytesHeader", "ByteHeaders", "byteBufferels", " bytePackERS", "byteHeaders", "byteWaiterers", "bytesBuffERS", "byteFraglers", "bytePackERS", "ByteBuffrs", "byteCornters", "byteDefERS", " byteBuffiers", "byteFragusters", " byteNamesERS", "byteWaiters", "byteBuffer", "bytePacks", "bytesbuffERS", "byteHeadered", "byteBuffs", "byteNameserers", "byteBuffered"], "m_initialOutBuffer": ["m_finalOutputBuff", "m_initialoutCache", "m_InitialOutBuff", "m_initialEndLength", "m_initialInThread", "m_firstoutBuff", "m_initialInbuffer", "m_initialOutputBuffer", "m_initialOutLength", "m_currentInChannel", "m_currentoutCache", "m_initialInQueue", "m_currentOutBuffer", "m_initialByteBuffer", "m_initialNetBuffer", "m_currentoutBuffer", "m_InitialOutLength", "m_initialoutWriter", "m_finalOutputQueue", "m_initialNetThread", "m_InitialoutLength", "m_InitialOutCache", "m_initialNetQueue", "m_finalOutBuff", "m_currentoutBuff", "m_firstoutBuffer", "m_initialCheckBuff", "m_initialoutBuffer", "m_currentInBuff", "m_initialHostBuffer", "m_currentOutQueue", "m_initialOutChannel", "m_initialOutThread", "m_initialHostBuff", "m_finalOutQueue", "m_InitialoutCache", "m_firstOutBuff", "m_initialInLength", "m_currentOutCache", "m_initialCheckBuffer", "m_InitialoutBuff", "m_initialByteBuff", "m_initialInChannel", "m_initialOutputQueue", "m_firstoutWriter", "m_initialOutCache", "m_initialoutQueue", "m_initialCheckChannel", "m_initialCheckQueue", "m_initialByteWriter", "m_initialOutputThread", "m_currentoutQueue", "m_initialoutLength", "m_initialOutWriter", "m_initialOutputBuff", "m_initialOutbuffer", "m_currentInBuffer", "m_initialInBuff", "m_currentOutBuff", "m_initialHostView", "m_initialHostbuffer", "m_initialOutBuff", "m_currentOutChannel", "m_initialEndBuffer", "m_firstOutCache", "m_initialEndBuff", "m_initialInView", "m_finalOutThread", "m_firstoutCache", "m_finalOutputThread", "m_InitialoutBuffer", "m_initialEndCache", "m_firstOutBuffer", "m_firstOutWriter", "m_initialInBuffer", "m_finalOutputBuffer", "m_initialInWriter", "m_initialInCache", "m_initialOutView", "m_initialNetBuff", "m_currentInQueue", "m_finalOutBuffer", "m_initialNetCache", "m_InitialOutBuffer", "m_initialByteCache", "m_initialOutQueue", "m_initialNetChannel", "m_initialoutBuff"], "buffer": ["sequence", "cache", "server", "stream", "container", "holder", "builder", "context", "buf", "channel", "manager", "engine", "store", "bo", "table", "iter", "block", "tree", "list", "background", "document", "directory", "url", "timeout", "pool", "message", "stack", "source", "bridge", "Buffer", "processor", "button", "timer", "thread", "address", "connection", "row", "callback", "flash", "filter", "attribute", "response", "header", "memory", "database", "layer", "profile", "template", "bar", "queue", "batch", "comment", "base", "command", "chain", "loop", "length", "output", "null", "pair", "window", "iterator", "initial", "socket", "temp", "internal", "match", "map", "page", "buff", "binary", "phrase", "empty"], "buffers": ["ufers", "offers", "rendters", "buffings", " buffors", "bufards", "combers", "buffERS", " buffters", "ufERS", "combards", "comblers", "combERS", "ufors", "ufards", "holders", "holdERS", "buffors", "offters", "holdters", "bindERS", "renders", "uflers", "bufflers", "rendERS", "bufters", "rendlers", "bindlers", "ufters", "holdings", "bufings", "bufers", "offERS", "bindters", "binders", " buffings", "offors", "bufERS", " buffERS", "buffards", "buffters", "buflers"], "result": [" resulted", "response", "cache", "group", "other", "answer", "Result", "ver", "created", "true", "continue", "ret", "description", "process", "message", "r", "current", "progress", "json", "event", "success", "make", "product", "resource", "context", "reason", "results", "next", "profile", "data", "that", "match", "user", "error", "successful", "complete", "comment", "done", "see", "search", "res", "report", "role", "valid", "we", "status", "mate", "details", "cur", "ser", "load", "relation", "test", "output", "iter", "null", "request", "re", "runner", "diff", "pair", "wrapper", "uu"], "encrypted": ["sequence", "external", "other", "created", "confirmed", "temp", "ended", "internal", "secure", "channel", "context", "checked", "password", "error", "available", "engine", "chain", "verified", "armor", "finished", "table", "locked", "options", "flash", "extra", "selected", "secret"]}}
{"id1": "14047629", "id2": "11952735", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"source": ["Source", "iterator", "sequence", "image", "system", "shell", "stream", "ource", "src", "message", "sample", "se", "copy", "content", "expression", "file", "event", "query", "buffer", "resource", "channel", "data", "result", "from", "q", "sql", "console", "service", "in", "address", "seed", "proc", "output", "position", "request", "input", "SOURCE", "reader", "format"], "process": ["cp", "execute", "link", "flow", "pp", "init", "p", "complex", "and", "task", "pipe", "se", "memory", "job", "run", "connect", "cmd", "node", "file", "make", "network", "session", "sys", "context", "function", "parse", "build", "processor", "method", "call", "project", "Process", "command", "status", "pm", "store", "frame", "object", "service", "post", "check", "thread", "console", "chain", "mem", "condition", "code", "create", "class", "proc", "work", "component", "place", "term", "exec", "pid", "script", "processing", "program", "use", "handle", "state"], "processStdOut": ["processStrrEr", "processStstdEr", "processStrrIn", "processStdEx", "processStrdOut", "processStstEx", "processStdEr", "processStrrEx", "processStstdEx", "processStrIn", "processStrEx", "processStrdEr", "processStrEr", "processStstdIn", "processStstEr", "processStrdEx", "processStrdIn", "processStstdOut", "processStstOut", "processStstIn", "processStrOut", "processStrrOut"], "processStdIn": ["processStrIN", "processStdin", "processStsIN", "processStdsIns", "processStackdsIN", "processSTdIN", "processStackdsOut", "processStackdsin", "processStrIns", "processStackdin", "processStackdIN", "processStrIn", "processStrin", "processSttIN", "processSttIns", "processStdsIN", "processSTtIN", "processStackdsIn", "processStsOut", "processSTtOut", "processStackdOut", "processStdIns", "processSttOut", "processSttIn", "processStdsIn", "processStdsin", "processStrOut", "processSTdIn", "processStsIn", "processStdsOut", "processSTdOut", "processSTtIn", "processSTtIns", "processStsin", "processStdIN", "processStackdIn", "processSTdIns"]}}
{"id1": "5836744", "id2": "13657103", "code1": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 0, "substitutes": {"read": ["access", "scan", "READ", "stat", "init", "find", "reading", "stream", "ready", "process", "reads", "download", "connect", "run", "query", "buffer", "close", "parse", "data", "sync", "report", "check", "create", "load", "test", "write", "open", "get", "seek", "input", "readable", "show", "print", "reader", "index", "handle", "Read"], "name": ["link", "path", "NAME", "parent", "key", "image", "string", "nm", "domain", "version", "part", "order", "old", "message", "info", "title", "w", "value", "file", "event", "location", "named", "start", "filename", "mod", "local", "data", "default", "on", "id", "comment", "base", "type", "uri", "search", "nl", "prefix", "normal", "Name", "str", "code", "mem", "t", "address", "ref", "no", "create", "client", "ame", "word", "ma", "term", "null", "size", "sp", "names", "n", "state"], "status": ["access", "sequence", "msg", "stat", "server", "version", "iss", "x", "char", "continue", "US", "xml", "description", "ex", "v", "json", "flag", "progress", "cli", "uses", "gc", "source", "success", "iso", "Status", "comments", "gl", "update", "ssl", "err", "error", "id", "result", "exit", "complete", "sync", "type", "login", "ping", "report", "mode", "wait", "format", "scale", "prefix", "details", "service", "st", "check", "console", "summary", "code", "set", "str", "sc", "s", "size", "print", "score", "dr", "index", "use", "handle", "state"], "url": ["mail", "Url", "link", "hl", "html", "cert", "char", "r", "cl", "mount", "log", "gl", "ssl", "host", "build", "user", "bel", "f", "dl", "base", "web", "http", "nl", "sl", "rl", "service", "fl", "str", "ll", "browser", "ref", "rel", "pkg", "l", "client", "open", "www", "URL", "net", "ur", "ul", "li"], "in": ["inn", "im", "pc", "inc", "al", "pin", "is", "mi", "inner", "stream", "isin", "ini", "din", "file", "all", "source", "bin", "i", "io", "gin", "serv", "m", "from", "In", "sum", "form", "body", "or", "ins", "en", "out", "IN", "client", "con", "ma", "ai", "input", "cin", "rin", "mc", "reader"]}}
{"id1": "4798332", "id2": "8024375", "code1": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"SHA": ["HTML", "SU", "SE", " MD", "MD", "ASH", "SA", "SO", "H", " hash", "GET", "HS", " sum", " signature", "Hash", "PI", "HT", " Signature", "AC", "MA", " Sha", "ES", "DATA", "SH", "HA", "sha", " GET"], "source": ["Source", "name", "url", "sequence", "cause", "unit", "origin", "image", "string", "this", "dest", "ource", "src", "scope", "message", "sample", "original", "subject", "content", "copy", "expression", "target", "info", "config", "query", "filename", "reason", "data", "template", "base", "type", "space", "uri", "search", "from", "site", "sql", "body", "object", "str", "ins", "text", "spec", "seed", "position", "request", "s", "input", "score", "SOURCE", "style", "secret", "raw", "format"], "result": [" resulted", "sequence", "url", "response", "cache", "comp", "cert", "su", "answer", "key", "Result", "true", "continue", "ret", "cup", "this", "description", "message", "r", "current", "currency", "value", "success", "product", "filename", "join", "reason", "results", "RESULTS", "data", "successful", "complete", "comment", "search", "res", "report", "valid", "status", "br", "details", "hash", "cur", "str", "text", "summary", "out", "test", "relation", "csv", "table", "output", "term", "null", "sign", "wrapper", "found", "format"], "digest": ["mdum", "decger", "Digest", " digum", "hashester", "nest", " digested", "Digester", "signester", "signest", "hashested", "mdest", "nester", "hashest", "digse", "mdester", "num", "digger", "Digum", "nested", "decested", " digse", "digum", "digested", "hashum", "Digse", " digester", "Digger", "signger", " digEST", "digEST", "decEST", "DigEST", "digester", "decester", "decest", "Digested", "mdse", "signested"], "bytes": ["bits", "groups", "clips", "ips", "bags", "frames", "bs", "strings", "tes", "lines", "pages", "classes", "gets", "values", "reports", "blocks", "gs", "keys", "results", "es", "loads", "files", "seconds", "pieces", "steps", "services", "gb", "its", "parts", "binary", "Bytes", "words", "latest", "s", "outs", "images", "bps", "names", "units"]}}
{"id1": "16572931", "id2": "411595", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"unJar": ["UnZip", "removeExt", " unZip", "removeJar", "unZip", "removePath", " unPath", "UnExt", "removeZip", "UnJar", "unPath", " unExt", "UnPath", "unExt"], "jarPath": [" jarpath", "jarHost", "jarFile", "reportpath", "javapath", "relInfo", "jarpath", "jarLocation", "javaInfo", "carPath", "carBase", "jobPath", "jarUrl", "reportUrl", "relpath", " jarBase", "carpath", "pkgpath", "browserpath", "jobLocation", "jarFull", "jName", "javaFull", "browserName", "javaName", " jarLocation", "reportPath", "relHome", "jobpath", "javaUrl", "jobFile", "javaPath", " jarUrl", "bareHost", "jarBase", "barePath", "pkgName", " jarName", "pkgPath", "browserPath", "bareFull", "browserInfo", "javaLocation", "jPath", "browserUrl", "carName", "javaFile", " jarFile", "jHost", "reportName", "jarHome", "jarName", "javaBase", " jarHome", "browserHome", "jFull", "jarInfo", "bareName", " jarInfo", "javaHost", "pkgInfo"], "jarEntry": ["jitEntry", "sessionentry", "jitEnt", "javaEnt", "browserEntry", "jobEntry", "sessionEnt", "reportEnt", "springItem", "jarEnt", "javaItem", "jentry", "reportentry", "jitInfo", "certentry", "jarPost", "JarEnt", "jItem", "browserName", "jEnt", " jarEnter", "browserentry", "springEnt", "browserPost", "certEnt", "jarEnter", "certName", "jobEnt", "reportEntry", " jarEnt", "browserEnt", "browserEnter", " jarentry", " jarName", "javaPost", "jarentry", "certEntry", "javaentry", "jarItem", "browserInfo", "jitEnter", "springEntry", "sessionName", "JarPost", "javaEntry", "jEntry", "jobPost", "springentry", "jarName", "sessionEntry", "JarEntry", "jarInfo", " jarInfo", "Jarentry", "reportPost"], "path": ["port", "p", "phi", "partial", "cmd", "mount", "min", "walk", "context", "host", "data", "trace", "set", "text", "core", "tree", "input", "self", "hex", "home", "index", "name", "url", "PATH", "ath", "full", "message", "distance", "title", "location", "point", "here", "join", "method", "right", "prefix", "address", "ref", "at", "Path", "position", "room", "where", "select", "pattern", "this", "value", "template", "root", "id", "base", "left", "api", "history", "test", "pkg", "module", "output", "print", "zip", "parent", "key", "string", "x", "it", "order", "temp", "file", "folder", "log", "near", "check", "relative", "with", "loc", "client", "dir", "to", "route", "empty", "transform", "pi", "format"], "relPath": ["relPort", "Relpath", "elName", "elEntry", "relName", "elpath", "RelEntry", " relPort", "relpath", "RELText", "RELName", "RelText", "RelPort", " relText", "RELPath", " relEntry", "RELPort", "RelPath", " relName", "RelName", "relEntry", "elPath", " relpath", "relText"], "jar": ["sea", "zip", "comp", "le", "cert", "vol", "zo", "se", "ja", "job", "Jar", "pack", "jo", "jc", "og", "archive", "rar", "j", "be", "bar", "car", "deb", "tab", "batch", "jet", "tar", "java", "good", "ctr", "bag", "lib", "jp", "pkg", "jit", "jj", "war", "ie", "star", "sp", "bare", "ar", "cp"], "ze": ["zip", "zed", "sle", "le", "zo", "ea", "sk", "se", "oe", "je", "enz", "e", "ee", "jo", "so", "aze", "ve", "zie", "zi", "zes", "ez", "ZE", "Ze", "sl", "te", "ge", "zing", "zy", "za", "ne", "ke", "cz", "ene", "z", "ae", "ie", "zer", "ce", "be", "she", "pe"], "bin": ["bi", "bg", "pin", "kin", "abin", "ln", "skin", "pan", "sin", "png", "jin", "bl", "din", "spin", "bat", "dll", "ebin", "b", "bed", "fin", "gin", "di", "sam", "win", "box", "bu", "pic", "in", "ic", " Bin", "buff", "binary", "lib", "bm", "db", "bian", "con", "cin", "obin", "thin"]}}
{"id1": "62362", "id2": "22046596", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"convert": ["Converting", "conVERT", "consvert", "CONversion", "conversion", "unfer", "converted", "compvert", "compversion", "consversion", "compverts", "Converted", "unversion", "converting", "CONverted", "CONfer", "unvert", "converts", "consVERT", "Conversion", "CONverting", "conprocess", "ConVERT", "CONVERT", "CONvert", "consverting", "Confer", "unverted", "confer", "Conprocess", "unverts", "compprocess", "Convert", "Converts", "unprocess"], "src": ["Source", "scan", "url", "hl", "path", "orig", "attr", "sq", "inst", "addr", "cc", "sin", "rs", "stream", "ource", "href", "sr", "rx", "file", "config", "source", "ebin", "start", "filename", "sys", "SourceFile", "sit", "ipl", "host", "func", "RC", "scene", "iv", "txt", "from", "cont", "uri", "http", "its", "st", "str", "ser", "ins", "cur", "img", "loc", "rel", "usr", "pkg", "buster", "sc", "ur", "req", "rc", "s", "dist", "input", "SOURCE", "rest", "upload"], "dest": ["port", " destinations", "orig", "est", "Dest", "mat", " Destination", "target", "temp", " orig", "source", " destination", "gin", "dat", "result", "txt", " dst", " Dest", "img", "test", "foreign", "write", "table", "tif", "disk", "dir", "dist", "rest"], "in": ["inn", "up", "is", "inner", "stream", "isin", "r", "din", "file", "source", "b", "bin", "i", "io", "serv", "ad", "ar", "m", "from", "res", "In", "el", "sql", "st", "ins", "en", "IN", "d", "l", "input", "cin", "rin", "reader", "as", "inf", "ind"], "p": ["fp", "pc", "php", "pl", "pp", "per", "it", "part", "g", "ps", "r", "pro", "py", "pg", "vp", "b", "ph", "i", "h", "ap", "parser", "P", "parse", "j", "pa", "pd", "f", "m", "lp", "c", "ping", "rep", "pm", "post", "prot", "op", "t", "pre", "er", "pers", "at", "jp", "dp", "d", "pb", "l", "pkg", "wp", "pt", "pi", "sp", "cp", "pe", "tp"], "ds": ["cs", " os", "ports", "drivers", "dh", " ads", "ss", "scripts", "di", "dates", "edes", "sts", " d", "tests", "nas", "dds", "aws", "hd", "obs", "posts", "bs", "rs", "cks", "DS", "ys", "uds", " dd", "eds", "its", "vs", "dp", "d", "os", "terms", "outs", "qs", "dd", "pd", "tp", "ras", "ts", "ods", "Ds", "tes", " DS", "ps", "points", "ils", "gs", "amps", "docs", "xs", "ands", " des", "workers", "lists", "ads", "des", "db", "eps", "dos", "iffs", "dt", "js", "ks", "ls", "mys", "yes", "ws", "gd", "ats", "els", "sets", "ns", "sd", "tags", "loads", "dl", "ags", "s", "hs", "df"], "format": ["name", "unit", "lat", "path", "shape", "version", "it", "settings", "mat", "pattern", "act", "fm", "MAT", "ats", "title", "file", "source", "layout", "parse", "sche", "template", "top", "id", "fc", "f", " Format", "type", "mode", "status", "form", "tag", "feature", "set", "t", "spec", "at", "cf", "table", "output", "module", "l", "policy", "feat", "size", "pretty", "pi", "filter", "mt", "ct", "style", "Format"], "hasPixelData": ["haspixelDATA", "hasFramedata", "HaspixelData", "hasixelData", "hasPixeldata", "hasixelDATA", "hasFrameDATA", "hasFrameData", " hasPixelDATA", "HasPixelDATA", "hasPixelDATA", "HasPixelData", "HaspixelDATA", "haspixeldata", "Haspixeldata", "HasPixeldata", " hasPixeldata", "hasixeldata", "haspixelData"], "inflate": ["Informate", "inFlocate", "informate", "invalidocate", " invalidATE", "inflATE", "inflated", "informated", "inFLated", "infolat", "incelicate", "inFlATE", "informat", "Inflat", "infolated", "invalidicate", "inFLat", "informocate", "incelocate", "Inflocate", "inFlate", "Informocate", "inFLocate", "incelate", "inflocate", "invalidate", "inFLate", " inflocate", "infolate", "inflicate", "invalidATE", "infolocate", "inFlicate", "Informated", " invalidicate", "Inflated", " invalidate", "incelATE", "inflat", " invalidocate", "Inflate", " inflicate", " inflATE", "Informat"], "pxlen": ["packls", "mxdec", "pexlen", "packln", "pxls", "pexfun", "xpden", "mxln", "phpdec", "tmpln", "pxden", "mxlength", "mmlen", "xyln", "mmln", "phpln", "pixellength", "pxdec", "xplen", "pixells", "pexln", "tmplength", "xylength", "cpden", "pxlin", "tmplin", "mmlength", "phplength", "pixelfun", "xylin", "cplength", "mmlin", "packdec", "pxln", "pexlength", "xylen", "tmplen", "xplength", "pxfun", "phplen", "mxlen", "pxlength", "pexls", "pexden", "pixellen", "packlen", "xpln", "packfun", "cplen", "cpln", "packlength"], "out": ["name", "msg", "obj", "group", "up", "conn", "ln", "init", "writer", "gov", "inv", "Out", "ex", "aos", "outer", "temp", "cmd", "log", "err", "sys", "io", "inter", "user", "crit", "res", "cfg", "sum", "store", "prefix", "client", "output", "dir", "gr", "list", "outs", "OUT", "screen", "net", "pretty", "print", "ou"]}}
{"id1": "16719805", "id2": "8788371", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copFile", "Copyfile", "CopyFolder", "cloneResource", "transferfile", "clonefile", " copyDir", "CopyFile", "copyDirectory", "linkfile", "linkDir", "copyPath", "copPath", "linkPath", "copyResource", "cloneDir", "copyDir", " copyFolder", "copfile", "linkFile", "CopyDir", "cloneFile", "cloneDirectory", "cloneFolder", "transferFile", "transferResource", " copyResource", "transferDirectory", "copyFolder", " copyDirectory", "copyfile", "copDir", " copyfile", " copyPath"], "from": ["name", "url", "view", "html", "origin", "parent", "path", "orig", "initial", "vol", "init", "raw", "part", "def", "this", "old", "add", "se", "before", "entry", "original", "without", "window", "a", "config", "source", "so", "start", "query", "when", "local", "low", "base", "cont", "el", "left", "form", "simple", "or", "st", "normal", "range", "str", "of", "with", "chain", "at", "From", "by", "db", "self", "empty", "reset", "star", "as", "style"], "to": ["port", "tu", "not", "eto", "tx", "phi", "io", "TO", "one", "that", "tz", "ot", "st", "range", "parts", "no", "bo", "table", "pt", "tree", "name", "auto", "full", "tty", "two", "oto", "tt", "top", "on", "tab", "type", "into", "by", "os", "size", "token", "style", "tp", "ato", "this", "dest", "nt", "toc", "target", "pro", "tmp", "must", "template", "base", "or", "o", "output", "total", "null", "co", "tom", "be", "parent", "it", "copy", "temp", "file", "b", "so", "global", "too", " too", "po", "ta", "To", "t", "op", "client", "pretty"], "children": ["resources", "cache", "groups", "child", "fields", "pres", "tr", "bc", "ports", "stories", "lines", "uploads", "ps", "pages", "kids", "members", "many", "classes", "content", "els", "parents", "names", "days", "users", "nil", "values", "config", "gc", "reports", "relations", "blocks", "comments", "when", "keys", "links", "all", "roots", "ren", "docs", "projects", "apps", "files", "issues", "fs", "services", "cont", "cycles", "packages", "modules", "ids", "jobs", "tests", "objects", "details", "parts", "ms", "videos", "times", "items", "styles", "tree", "ml", "codes", "may", "Children", "follow", "ls", "desc", "mods", "cases"], "i": ["ix", "remote", "im", "bi", "ip", "key", "init", "oi", "ri", "is", "it", "x", "mi", "phi", "gi", "ui", "ji", "eric", "g", "si", "v", "hi", "info", "ami", "u", "iu", "json", "cli", "point", "ti", "ci", "me", "ori", "multi", "j", "di", "user", "id", "xi", "batch", "m", "c", "iq", "uri", "ii", "q", "wait", "status", "y", "ic", "set", "ims", "ms", "qi", "t", "ij", "us", "ei", "ki", "chain", "get", "ai", "I", "s", "ie", "my", "pi", "print", "sim", "index", "ind", "li"], "f": ["fp", "ff", "rf", "xf", "fab", "tf", "ef", "p", "fm", "g", "fo", "v", "F", "file", "b", "ph", "fx", "fa", "uf", "fw", "fc", "c", "fi", "fd", "bf", "lf", "y", "fg", "flo", "fu", "sf", "t", "o", "d", "cf", "l", "ft", "fe", "n", "alf", "fb", "ct", "df"], "in": ["inn", "im", "al", "inc", "up", "conn", "init", "is", "it", "ain", "act", "sin", "inner", "xml", "isin", "ini", "din", "info", "mm", "source", "ze", "like", "io", "In", "body", "ins", "inside", "en", "IN", "iter", "ai", "con", " din", "input", "rin", "cin", "ar", "inf", "oin", "ind"], "out": ["auto", "obj", "up", "external", "conn", "writer", "it", "Out", "put", "ex", "nt", "r", "aos", "outer", "flush", "b", "sys", "err", "ion", "io", "on", "res", "ot", "or", "cn", "t", "at", "o", "ne", "by", "write", "output", "con", "null", "os", "end", "oss", "co", "outs", "OUT", "net", "can", "n", "ou"], "buf": ["msg", "cap", "orig", "cv", "bc", "nm", "tx", "cb", "stack", "seq", "temp", "cmd", "b", "buffer", "log", "uf", "col", "conv", "bar", "box", "tab", "queue", "batch", "arr", "ctr", "cfg", "good", "br", "cam", "img", "bag", "cur", "Buff", "mem", "buff", "uffy", "ref", "pkg", "vec", "db", "cf", "block", "feat", "fac", "fr", "fb", "cat", "window", "cp"], "read": ["READ", "len", "raw", "each", "it", "find", "height", "bind", "handle", "select", "reading", " count", "ready", "stream", "add", "reads", "shift", "w", " Read", "run", "pack", "last", "config", "hello", "query", "start", "buffer", "give", "val", "take", "tell", "send", "wait", "range", "check", "str", "depth", "text", "play", "mem", "load", "loop", "un", "write", "length", "open", "get", "ok", "iter", "req", "count", "hold", "end", "first", "need", "input", "readable", "seek", "skip", "size", "print", "reader", "index", "fill", "ind", "Read"]}}
{"id1": "3197876", "id2": "11673907", "code1": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"showTopLetters": ["showTopLetterters", "showTopLetors", "showBottomItors", "showBottomIters", "showBottomLetter", "showTopItter", "showTopLetter", "showBottomLetters", "showTopLetterors", "showTopLetterers", "showTopIters", "showBottomItters", "showTopLers", "showBottomLeters", "showBottomLetors", "showTopLors", "showBottomItter", "showTopItors", "showTopLeters", "showTopItters", "showTopLter", "showTopLters", "showTopLetterter"], "tempArray": [" tempArea", "empInstance", "empMessage", " tempInteger", "tempInteger", "templateMessage", "tempIndex", "temarray", "empAt", " tempInstance", "temArea", "temAs", "tempAt", "tmpMap", "tempAs", "tmpArray", "temIndex", "temArray", "tmpAmount", " temparray", "emparray", "temparray", "tempAlpha", "templateArray", "temMap", "empOrder", " tempIndex", "tmpAs", "temAmount", "tempMessage", "tmpAt", "temInstance", "tmpArea", "empMap", "tmparray", "empAlpha", "tempInstance", "empArea", " tempAlpha", "empInteger", "tmpOrder", " tempAmount", "temAlpha", "templateAlpha", " tempAt", "empArray", " tempAs", "tempOrder", "templateArea", "tmpInstance", "tempArea", "empIndex", " tempOrder", "empAs", "temMessage", "temAt", "tempMap", "tmpInteger", "tempAmount"], "tempArrayLetters": ["tempArrayLatriers", "tempArrayFilchers", "tempArrayLetterts", "tempArrayLetTER", "tempArrayLetriers", "tempArraySetaters", "tempArrayLETlets", "tempStringFilriers", "tempRAYPatiers", "tempAreaLETers", "tempRAYLetts", "tempArrayLetterters", "tempArrayLETchers", "tempArrayFillets", "tempArrayDelters", "tempArrayletators", "tempAreaLETter", "tempArrayLetaters", "tempAreaFilowers", "tempArrayDelers", "tempArrayFilriers", "tempArrayPainers", "tempArrayFilbers", "tempArrayLETers", "tempArrayLetarers", "tempArrayLetteriers", "tempArraySetiers", "tempRAYPatters", "tempArrayLatters", "tempArrayMailets", "tempArrayPatiers", "tempArrayLetchers", "tempAreaLETTER", "tempArrayFilowers", "tempAreaFilaters", "tempArrayFileTER", "tempRAYLeters", "tempAreaLetter", "tempRAYLetarers", "tempAreaLeters", "tempArrayPainters", "tempAreaLetowers", "tempArrayLETter", "tempAreaLetters", "tempArrayDellets", "tempStringLetriers", "tempArrayLetter", "tempAreaLetets", "tempAreaLETbers", "tempArrayFilebers", "tempArraySetts", "tempRAYPatts", "tempArrayItters", "tempArraySeters", "tempArrayleters", "tempArrayLETTER", "tempArrayDeleners", "tempAreaFilbers", "tempRAYDeleners", "tempArrayFilter", "tempArrayletTER", "tempAreaFilators", "tempArrayShutlets", "tempAreaFilers", "tempArrayLatter", "tempAreaFilners", "tempArrayPatts", "tempArrayPatters", "tempArrayColowers", "tempAreaLetchers", "tempArrayShuters", "tempStringFilters", "tempArrayColers", "tempArrayLETriers", "tempRAYLeteners", "tempAreaLETters", "tempStringLetter", "tempArrayButlets", "tempAreaFilters", "tempArrayLETeners", "tempAreaLetners", "tempStringLeters", "tempArrayLETters", "tempRAYLetlets", "tempArrayButters", "tempArraySetators", "tempStringFilers", "tempArrayLetts", "tempAreaLETchers", "tempRAYLetters", "tempArrayLetlets", "tempAreaLetaters", "tempArrayLaters", "tempAreaLetlets", "tempRAYDelters", "tempArrayMailers", "tempArrayLetowers", "tempArrayLeteners", "tempArrayItets", "tempArrayletbers", "tempStringLetters", "tempArrayPainowers", "tempArrayLeters", "tempAreaFilets", "tempArrayPainners", "tempArrayIters", "tempArrayFilners", "tempRAYPatarers", "tempStringFilter", "tempArrayFilets", "tempArrayFilters", "tempArrayLETbers", "tempArrayButers", "tempArrayLetbers", "tempArrayButeners", "tempArrayLatchers", "tempAreaLETlets", "tempArrayMailters", "tempArrayLetets", "tempArrayColters", "tempArrayLetators", "tempArrayLetterarers", "tempAreaLetbers", "tempAreaLetators", "tempArrayletters", "tempArrayShutters", "tempArrayletaters", "tempArrayLetiers", "tempArraySetarers", "tempArrayColners", "tempArrayLetners", "tempArrayFilaters", "tempArrayFilers", "tempArrayFileers", "tempArrayPatarers", "tempRAYDelers", "tempArrayShutter", "tempAreaLetTER", "tempArrayMailbers", "tempRAYDellets", "tempArrayFilators", "tempRAYLetiers", "tempArraySetters", "tempArrayItbers", "tempArrayFileters"], "resultTopFiveLetters": ["resultTopFiveLetter", "resultTop5Alter", "resultTop5Leters", "resultTopTwoLetaters", "resultTopFiveFilers", "resultTopFiveAlators", "resultTopFourLetters", "resultTopFiveFilators", "resultTopFiveMatters", "resultTopFiveLETiers", "resultTopFiveGetter", "resultTopTwoLETaters", "resultTopTwoLetiers", "resultTopFiveMaters", "resultTop5Alers", "resultTopFiveGeters", "resultTopFiveItters", "resultTopFiveGetators", "resultTopFiveMatter", "resultTop5Alators", "resultTopFourMatters", "resultTopFiveItiers", "resultTopFiveLetators", "resultTopFiveAlter", "resultTopFiveLETators", "resultTopFiveFiliers", "resultTopFiveAlers", "resultTop5Letators", "resultTopTwoLetters", "resultTopTwoLETiers", "resultTop5Letters", "resultTopFiveGetters", "resultTopFourMaters", "resultTopFiveMataters", "resultTopFiveAlaters", "resultTopFiveItators", "resultTop5Alters", "resultTopFiveLETaters", "resultTopFiveLeters", "resultTopFourLetaters", "resultTopFiveItaters", "resultTopFourMataters", "resultTopFiveLetiers", "resultTopTwoLETators", "resultTopFourMatter", "resultTopFourLetter", "resultTopFiveFilters", "resultTopFiveLETters", "resultTopTwoLETters", "resultTopFourLeters", "resultTopFiveLetaters", "resultTopFiveFilaters", "resultTopFiveFilter", "resultTopTwoLetators", "resultTop5Letter", "resultTopFiveAlters"], "tempCount": ["tempCast", "temLength", "totalTr", "tmpCast", "temMax", "tmpLength", "totalC", "empCount", "temTr", "temCast", "tempCounter", "stemSize", "temSize", "empCounter", "tempMax", "empC", "stemCounter", "tempC", "temC", "empMax", "tempTr", "tmpSize", "totalCount", "stemLength", "tmpCount", "empTr", "stemCount", "temCount", "tmpMax", "tempSize", "totalCounter", "empCast", "tmpCounter", "tempLength", "temCounter"], "tempLetters": ["tmpLetinters", "tempLetators", "tempFormaters", "tempMatchers", "tempPaininters", "tempLetchers", "temLETters", "tempFormatters", "tempSetinters", "tempPainTER", "tmpPainTER", "tempMatators", "tempAlaters", "templateLETners", "tempLETners", "tempLETators", "tempLETchers", "templateLetaters", "tempAlners", "tempLetaters", "temLETners", "tmpPainters", "tempFuninters", "tempLETaters", "tempPainters", "templateLeters", "templateLetners", "tempPainators", "templateLETaters", "tempFunters", "tempSetTER", "tempMatters", "temLetners", "templateLetters", "tmpPaininters", "temLetators", "tempSetters", "temLETators", "tempAlchers", "tempMatners", "templateLETers", "temLetters", "tempFunators", "tempFunTER", "tempLetinters", "temLETchers", "temLetchers", "tempSetators", "templateLETters", "tempLetTER", "tempLETers", "tempLeters", "tmpPainators", "tmpLetters", "tempAlators", "tempFormatners", "tempLetners", "tempAlters", "tempFormataters", "tempLETters", "tempAlers", "tmpLetators", "tmpLetTER"], "j": ["ix", "obj", " J", "jump", "jl", "uj", "x", "ji", "it", "g", "ja", "job", "json", "ijk", "jo", "b", "jc", "err", "Ja", "k", "oj", "kj", "q", "jac", "J", "bj", "y", "ij", "aj", "dj", "no", "pr", "jp", "adj", "at", "jit", "jj", "js", "z", "fr", "Job", "att", "n", "ind"], "i": ["ix", "ni", "im", "bi", "ip", "init", "oi", "ri", "mi", "is", "it", "gi", "phi", "ui", "this", "ji", "wi", "si", "a", "ini", "hi", "info", "ami", "u", "iu", "cli", "\u0438", "source", "point", "ir", "io", "ci", "ti", "me", "zi", "multi", "ori", "di", "id", "xi", "m", "uri", "fi", "ii", "sim", "status", "y", "ei", "in", "ic", "ims", "qi", "ij", "chain", "ki", "o", "iri", "ai", "I", "asi", "list", "ie", "pi", "print", "ish", "iq", "ia", "index", "ind", "li"]}}
{"id1": "596993", "id2": "21488868", "code1": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"makeLoginRequest": ["makeLoginMessage", " makeFacebookRequest", " makeFacebookPost", " makeFacebookResponse", "makeFacebookRequest", "makeFacebookPost", " makeLoginPost", "makeSubmitResponse", "makeFacebookMessage", " makeLoginMessage", "makeloginRequest", "makeLoginResponse", "makeSubmitRequest", " makeLoginResponse", "makeloginPost", "makeSubmitMessage", "makeloginMessage", " makeFacebookMessage", "makeloginResponse", "makeFacebookResponse", "makeSubmitPost", "makeLoginPost"], "url": ["Url", "name", "path", "string", "char", "ul", "r", "job", "cl", "file", "location", "b", "ssl", "k", "build", "bel", "call", "dl", "base", "abs", "uri", "web", "http", "sl", "nl", "el", "str", "ll", "browser", "address", "ref", "https", "un", "l", "open", "URL", "re", "ls", "ur"], "urlConnection": ["mountConnection", " urlConn", "xmlConnection", "browserConn", "UrlSession", " urlConnect", " urlConnector", "UrlLink", "handleConnect", "mountConn", "loadConnection", "loadConn", "browserconnection", "urlConnector", "browserConnection", "httpStream", "browserConnect", "urlconnection", "UrlConnect", "mountClient", "nlLink", "UrlConn", "nlConnect", "urlConnect", " urlInstance", "sslPort", "sslSession", "loadInstance", "consoleConnect", "sslStream", "nlconnection", "httpLink", "browserInstance", "consoleConnection", "consoleConn", "xmlConnector", " urlClient", "fileConnect", "httpConnection", "fileconnection", "mountConnect", "logConnection", "handleStream", "urlTree", "urlLink", "loadConnect", "UrlInstance", "logConnect", "httpConnect", "fileConnection", "sslConnector", "urlSession", "sslTree", "urlConn", "browserClient", "fileSession", "handleConn", "httpSession", "urlClient", "httpConn", "mountSession", " urlTree", "Urlconnection", " urlPort", "sslConnect", "nlConnection", "urlStream", "xmlPort", " urlconnection", "consoleSession", "httpconnection", "sslconnection", "sslConnection", "urlPort", "mountconnection", "urlInstance", "xmlTree", " urlSession", "logConn", "UrlConnection", "logLink", "handleConnection", "sslConn"], "content": ["sequence", "metadata", "cache", "lead", "conn", "any", "version", "image", "action", "settings", "activity", "pattern", "const", "continue", "filter", "handle", "xml", "description", "message", "current", "subject", "title", "expression", "json", "value", "config", "values", "cmd", "label", "network", "layout", "comments", "node", "context", "reason", "function", "data", "template", "example", "media", "comment", "cont", "search", "Content", "format", "report", "command", "form", "body", "object", "mask", "text", "summary", "language", "address", "create", "code", "contact", "cm", "output", "trust", "core", "license", "script", "size", "document", "names", "ontent", "control", "raw", "properties"], "outputStream": ["outputBlock", " outputStyle", "networkSteam", " outputstream", "OutputForm", "Outputstream", " outputSteam", "outputForm", "outputStyle", "networkStreamer", "OutputView", "OutputStyle", "OutputStream", "OutputStreamer", "OutputBlock", "inputForm", "inputView", " outputBlock", "outputView", "OutputSteam", "inputSteam", "networkStream", "outputstream", " outputView", "outputSteam", " outputForm", "inputBlock", "networkstream", "inputStyle", " outputStreamer", "outputStreamer"], "responseCode": ["ResponseCount", "usageCount", "responseCount", "usageCategory", "statusType", " responseCategory", "sequenceCode", "usageCode", "sequenceCount", "responseType", "ResponseType", "sequenceType", "statusCode", "ResponseCategory", " responseChoice", "sequenceStatus", "responseCategory", "usageChoice", "ResponseChoice", "ResponseStatus", "ResponseCode", "responseStatus", "responseChoice", " responseCount", "statusStatus", "statusCount"], "inputStream": ["thisSteam", "fileStream", "InputSteam", "viewThread", "fileStreamer", " inputSteam", "InputView", "thisStream", "errorView", "errorForm", " inputStreamer", "outputStyle", "outputForm", "thisStreamer", "viewSteam", "inputStreamer", "InputStream", "inputView", "viewStream", "inputForm", "outputView", "actStyle", "inputSteam", "errorSteam", "actStream", " inputView", "inputThread", "fileSteam", "outputThread", "errorStream", " inputQueue", "actView", "outputSteam", "actSteam", " inputThread", "fileQueue", "viewView", "inputStyle", " inputStyle", "thisQueue", "inputQueue", "InputForm"]}}
{"id1": "22022715", "id2": "8921716", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"digest": ["mdum", "mnests", "Digest", "dest", "Digested", "Digate", "Digge", "mdine", "mden", "mdest", "mnest", "date", "dine", "digen", "dests", "digge", "digests", "digate", "Digum", "decested", "mnen", "digum", "digested", "mnist", "Digine", "den", "dum", "mdist", "digine", "dist", "digist", "decge", "decate", "decest", "dge", "dested", "mdests", "mdested"], "s": ["p", "is", "string", "ts", "sq", "bytes", "strings", "v", "a", "ats", "r", "ps", "sb", "e", "b", "i", "S", "h", "ss", "ses", "f", "sv", "c", "m", "space", "sts", "sql", "y", "str", "ms", "text", "t", "o", "l", "js", "ls", "n"], "ret": ["elt", "tr", "resp", "it", "ts", "back", "xt", "rs", "Return", "repl", "nt", "r", "pet", "arg", "RET", "uf", "val", "tmp", "rem", "buf", "data", "gt", "ext", "result", "txt", "det", "cont", "res", "rep", "report", "reg", "arr", "rets", "gb", "rm", "Ret", "t", "out", "ref", "test", "jp", "ert", "ft", "over", "re", "az", "reset", "cat", "att", "rt", "mt", "found"], "md": ["mail", "sm", " MD", "dr", "del", "and", "mt", "cd", "mb", "MD", "dm", "dh", "mo", "mm", "ds", "man", "der", "od", "cmd", "managed", "hd", "ind", "bd", "sd", "mod", "di", "ld", "m", "det", "med", " Md", "pm", "rm", "mg", "ms", "red", "mn", "d", "nd", "met", "mand", "dd", "mc", "pdf", "mk", "df", "pd"]}}
{"id1": "14303294", "id2": "12004824", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public HttpResponse executeHttpRequest(HttpRequestBase httpRequest) {\n        HttpResponse response = null;\n        try {\n            HttpParams httpParams = new BasicHttpParams();\n            HttpConnectionParams.setConnectionTimeout(httpParams, maxTime);\n            HttpConnectionParams.setSoTimeout(httpParams, maxTime);\n            httpclient = new DefaultHttpClient(httpParams);\n            response = httpclient.execute(httpRequest);\n            maxTime = 15000;\n        } catch (Exception e) {\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"getServerHash": ["getClientMac", "getserverPassword", "getserverSalt", "getUserHash", "toClientMac", "getClientPassword", "toClientPassword", "getServerSalt", "getserverHash", "getClientHash", "getUserPassword", "getUserSalt", "getUserMac", "toServerMac", "getserverMac", "toClientSalt", "getServerMac", "getClientSalt", "toServerSalt", "toClientHash", "toServerHash", "getServerPassword", "toServerPassword"], "passwordHash": ["passwordHas", "PasswordPassword", "swordSalt", "passwordSalt", "serverKey", "PasswordHas", "PasswordHash", " passwordSalt", "passwordPassword", "swordHash", "emailHas", "PasswordKey", "passwordHTML", " passwordKey", "emailHTML", "emailSalt", " passwordPassword", "serverHash", "serverSalt", "PasswordHTML", "passwordKey", "swordHas", "emailHash", "swordHTML", "serverPassword"], "PasswordSalt": ["passwordToken", "PasswordPassword", "UserToken", "passwordSalt", " PasswordHash", "UserHash", "PasswordHash", " passwordSalt", "passwordPassword", "UserSalt", "passwordSecret", " PasswordSecret", " passwordToken", " passwordPassword", " PasswordToken", "PasswordToken", " PasswordPassword", "UserSecret", "PasswordSecret"], "hash": ["cache", "response", "html", "key", "dig", "height", "char", "sh", "message", "sample", "copy", "shift", "mac", "value", "json", "log", "h", "build", "score", "match", "ash", "map", "password", "echo", "result", "search", "Hash", "report", "crypt", "sum", "tag", "mask", "serial", "address", "test", "component", "total", "word", "block", "row", "transform", "hex", "print", "filter", "index", "handle", "sha"], "digest": ["mdested", "dEST", "Digest", "dester", "decse", "mdEST", "hashester", "dest", " digested", "descester", "Digester", "Diggest", "descested", "hashested", "displayested", "diggest", "mdest", "hashest", "digse", "mdester", "displayest", " digse", "decested", "displayester", "digested", "Digse", " digester", "descest", " digEST", "digEST", "hashgest", "DigEST", "digester", "decester", "displaygest", "dested", "decest", "Digested", "descse"]}}
{"id1": "19810820", "id2": "8490297", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyBytechannel", " copyFilesChannel", "copyFilechannel", " copyFileStream", " copyStreamChannel", " copyByteStream", " copyBytechannel", "copyByteFile", " copyFilechannel", " copyFilesFile", " copyStreamchannel", " copyStreamFile", " copyByteFile", "copyFileStream", " copyFilesStream", "copyFileFile", "copyByteChannel", "copyByteStream", " copyByteChannel", " copyFileschannel", " copyFileFile", " copyStreamStream"], "src": ["Source", "sec", "ls", "obs", "init", "inst", "sq", "bs", "rs", "dest", "sr", "sb", "rx", "syn", "source", "start", "sys", "filename", "SourceFile", "tmp", "RC", "txt", "usc", "sync", "from", "cont", "sl", "ctr", "rl", "st", "in", "cur", "ser", "ins", "sf", "img", "loc", "usr", "rel", "sc", "req", "rc", "s", "input", "js", "rt", "SOURCE"], "dst": [" dnd", "Ddest", "ddest", " dist", "jest", "Dth", "Dut", "Dest", "bist", "sest", "sth", "dest", "dth", "dnd", "best", " dth", "jut", "sst", "sut", "Dnd", "snd", "dut", " ddest", "jdest", "bdest", "jst", "bst", " dest", "sdest", "Dist", "dist", "Dst"], "preserveModificationTime": ["preserveQualificationsTime", "preserveModificationsTim", "preserveModifyPoint", "preserveModificationsTime", "preserveModifiedTime", "preserveModifierTimes", "preserveModificationTim", "preserveModifyTimes", "preserveModificationPoint", "preserveSpecificationTim", "preserveModificationsLength", "preserveModifyingLength", "preserveModifyingPoint", "preserveSpecificationTimes", "preserveSpecificationsTime", "preserveModificationLength", "preserveModifiedTimes", "preserveModifyTime", "preserveModifiedTim", "preserveSpecificationTime", "preserveQualificationsPoint", "preserveQualificationTime", "preserveModifierTim", "preserveQualificationsTimes", "preserveModificationsPoint", "preserveModifierTime", "preserveQualificationLength", "preserveQualificationsLength", "preserveSpecificationsTimes", "preserveModificationTimes", "preserveSpecificationsTim", "preserveModificationsTimes", "preserveModifyingTimes", "preserveModifyLength", "preserveQualificationPoint", "preserveModifyingTime", "preserveQualificationTimes"], "inputChannel": ["outputChuck", "innerChannel", "clientConnection", "inputCategory", "innerStream", "innerchannel", "clientChan", "infoChuck", "openConnection", "outputchannel", "inputBuffer", "outputStream", "outputChan", "inputListener", " inputConnection", "interfaceChannel", "inputChuck", "InputChan", " inputBuffer", "infoChannel", "innerChan", "inputStream", "InputStream", "outputBuffer", " inputGray", "inputChan", "evalChannel", " inputListener", " inputCategory", "openChannel", "entityChan", "interfaceListener", "hiddenChannel", "clientGray", " inputChuck", "entityChannel", "InputBuffer", "hiddenListener", "inputchannel", " inputStream", "inputConnection", "openGray", "openChan", "infoChan", "hiddenCategory", "infochannel", "interfaceCategory", " inputChan", "clientChannel", " inputchannel", "inputGray", "Inputchannel", "evalChan", "InputChannel"], "outputChannel": [" outputConnection", "coinChannel", "writeChannel", " outputButton", "displayButton", "writeChan", "putchannel", "outputchannel", " outputManager", "Outputchannel", "outputStream", "outputChan", "writeStream", "putChan", "writechannel", "writeManager", " outputchannel", "OutputStream", "putButton", "doubleChannel", "inputChan", " outputStream", "displayChan", "putChannel", "outputConnection", "coinInstance", "coinField", "doubleField", "inputManager", "webchannel", "inputConnection", "doubleChan", "OutputChan", "webChannel", " outputChan", "webManager", "outputButton", "coinChan", "inputField", "OutputChannel", "OutputConnection", "outputManager", "doubleInstance", "displaychannel", "displayChannel", "outputInstance", "outputField", "inputInstance", "OutputManager"], "length": ["volume", "then", "sequence", "len", "offset", "amount", "shape", "required", "full", "height", "present", "capacity", "max", "partial", "number", "json", "value", "all", "buffer", "start", "limit", "join", "ENGTH", "data", "padding", "available", "library", "ength", "base", "type", "needed", "time", "HH", "left", "details", "text", "load", "history", "loop", "duration", "l", "component", "term", "family", "expected", "count", "to", "position", "width", "list", "end", "size", "Length", "bytes"], "total": ["free", "sequence", "active", "offset", "amount", "full", "required", "equal", "created", "unique", "this", "description", "current", "info", "title", "max", "unknown", "last", "number", "all", "quant", "local", "less", "bar", "checked", "zero", "translation", "available", "num", "successful", "complete", "base", "done", "otal", "sum", "valid", "meta", "scale", "good", "ta", "t", "summary", "eta", "no", "count", "to", "stable", " Total", "size", "Total", "note", "used", "index", "raw", "human"]}}
{"id1": "12242903", "id2": "22752444", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 1, "substitutes": {"hashKey": ["processLink", "processKey", "hashLink", "updatekey", "processkey", "updateKey", " hashkey", "processValue", "hashkey", " hashValue", "updateValue", " hashLink", "updateLink", "hashValue"], "key": ["port", "attribute", "name", "link", "cache", "ace", "obj", "path", "cert", "string", "char", "this", "sk", "description", "message", "foo", "entry", "title", "lock", "value", "json", "hello", "source", "k", "data", "KEY", "template", "password", "id", "Key", "base", "type", "conf", "y", "prefix", "service", "piece", "text", "code", "item", "chain", "phrase", "seed", "client", "null", "et", "token", "hex", "username", "secret", "encrypted", "state"], "hashed": ["khash", " hushed", "ahash", "khhed", "khashing", "rhoted", "enhrypted", "hored", "rhashed", "hhed", "thash", "thored", " hhed", "shashed", "thashed", "ahashed", "rhamped", "enhash", " hored", "hoted", "enhashed", "rhhed", "khashed", "shhed", " hoted", " hashing", "ahushed", "ahored", "hashing", "enhhed", "shoted", "hoashing", " hamped", "hoashed", "hoash", " hrypted", "khrypted", "hamped", "shamped", "hohed", "hrypted", "thushed", "hushed"], "md5": [" md0", " MD45", "MD2", " md2", "md45", "det55", "md3", " md45", " MD3", " md55", "sha5", "md0", "dig5", "det3", "sha3", "MD5", " MD5", "md2", "det5", "dig3", "dig55", "sha0", " MD2", "MD0", "sha2", "MD45", "md55", " md3", "MD3"], "hash": ["radius", "ashed", "html", "array", "uh", "sq", "height", "ssh", "sh", "message", "sample", "shift", "square", "number", "carry", "h", "build", "hz", "ash", "checked", "hed", "search", "Hash", "ah", "sum", "tag", "check", "always", "length", "total", "trust", "count", "shadow", "kernel", "block", "hex", "score", "has", "index", "handle", "sha"]}}
{"id1": "3958807", "id2": "10385815", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadBixedStream", "loadBinaryInput", "loadBignedStream", "loadEmbinaryStream", "loadEmbbinaryFile", "loadBbinaryInput", "loadEmbbinaryInput", "loadEmbinaryFile", "loadBignedFile", "loadBixedInput", "loadEmbbinaryStreamer", "loadBixedStreamer", "loadBbinaryFile", "loadBixedFile", "loadBignedStreamer", "loadEmbinaryStreamer", "loadEmbbinaryStream", "loadEmbinaryInput", "loadBinaryStreamer", "loadBbinaryStream", "loadBbinaryStreamer", "loadBignedInput", "loadBinaryFile"], "streamName": ["streamPath", "resourceName", "recordname", " streamHandle", " streamType", "streamname", "stringName", "stringType", "longPath", "filePath", "stringNAME", "StreamNAME", "streamType", "fileNAME", " streamname", "resourceType", "recordName", "recordHandle", "streamHandle", "StreamName", "resourceNAME", "longName", "Streamname", " streamPath", " streamNAME", "streamNAME", "fileName", "recordNAME", "StreamHandle", "longNAME"], "streamToLoad": ["stringWillAdd", " stream2Read", " stream2Use", "streamtoAdd", " streamToload", "streamTOLoad", " streamToUse", "streamTOUse", "stringToLoad", "streamToUse", "streamToload", "streamWillload", "streamWillLoad", "streamTORead", "streamTOAdd", "streamToRead", "streamtoLoad", "stream2Load", "streamToAdd", " stream2Load", "streamtoload", "stringWillLoad", "stream2Read", "stream2load", " streamWillload", "stringToAdd", "streamWillAdd", "streamTOload", " streamWillLoad", " stream2load", "stringWillload", "stream2Use", "stringToload", " streamToRead"], "sz": ["insiz", "siz", "Sch", "insz", "rsz", "Sz", "Sld", " sch", " sld", " sze", "insze", "rsiz", "insch", "rsld", "sld", " siz", "sze", "rsze", "sch", "Sze", "Siz"], "req": ["comp", "sq", "quick", "attr", "qt", "comm", "inv", "org", "seq", "rx", "cmd", "Request", "query", "wx", "qq", "res", "pas", "q", "http", "wcs", "Requ", "cur", "urg", "jp", "usr", "proc", "pkg", "ctx", "client", "gr", "request", "dq", "requ", "fr", "qs", "require", "quest"], "resp": ["msg", "response", "obj", "rend", "html", "conn", "exp", "RES", "p", "soc", "cmp", "vol", "comm", "inv", "ret", "rec", "nt", "r", "content", "dis", "cl", "esp", "cmd", "wr", "pos", "sys", "serv", "wx", "Res", "respond", "Resp", "respons", "conv", "result", "fs", "res", "rep", "report", "pas", "http", "status", "body", "Response", "sol", "https", "jp", "rel", "proc", "output", "gr", "client", "os", "request", "re", "fr", "compl", "sp", " Resp"], "out": [" outs", "utt", "obj", "ws", "vol", "ts", "bs", "Out", "ex", "nt", "w", "aos", "sys", "cos", "log", "gs", "io", "conv", "gt", "yout", "sw", "ou", "res", "ot", "in", "ins", "t", "us", "o", "output", "client", "os", "null", "to", "oss", "co", "outs", "OUT", "net", "n", "cn"], "bos": ["bi", "bits", "obs", "ws", "ols", "ts", "bs", "ods", "banks", "tes", "uts", "bh", "boards", "mos", "aos", "bat", "oops", "sys", "bin", "ys", "fits", "base", "oids", "bis", "bas", "ios", "ubis", "bones", "buff", "nos", "bo", "bes", "des", "los", "dos", "os", "eros", "jas", "oss", "js", "bles", "BS", "bot", "bytes", "oos"]}}
{"id1": "8801182", "id2": "16621503", "code1": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"downloadImages": ["DownloadImage", "getimages", "getImages", "Downloadimages", "downloadImage", " downloadImage", " downloadItems", "getItems", "DownloadItems", " downloadimages", "downloadItems", "DownloadImages", "downloadimages", "getImage"], "uriPrefix": ["uriServixed", "URIPredIX", "uriPredacing", "urlDiffix", "uriServfix", "uriTermIX", "uriPix", "urlDiffic", "uriTermacing", "uriSequixed", "uriPrefIX", "URIPrefixed", "urlPrefix", "URIPrefacing", "urlDifffix", "uriDifffix", "uriReplic", "uriRadIX", "uriPrefic", "uriPreffix", "uriPredixed", "urlPrefic", "URIPredixed", "uriRadix", "uriPrefixed", "uriReplfix", "urlPreffix", "URIPrefix", "uriPredix", "uriSequic", "uriPredfix", "URIPredix", "uriDiffix", "uriTermfix", "urlPrefixed", "uriRadixed", "uriReplix", "uriPrefacing", "URIPreffix", "uriTermix", "URIPrefIX", "uriPacing", "urlDiffixed", "uriDiffixed", "uriServix", "uriServIX", "uriDiffic", "uriPIX", "uriRadfix", "uriReplixed", "uriSequfix", "uriPredIX", "uriSequix", "uriPfix", "URIPredfix", "URIPredacing"], "fileWithListOfImages": ["fileWithListofImage", "fileWithListAndImages", "fileWithlistAndImages", "fileWithlistAndFiles", "fileWithListWithImage", "fileWithlistOfFiles", "fileWithListOfFiles", "fileWithRestOfImages", "fileWithListofImages", "fileWithListOfimages", "fileWithRestofImages", "fileWithListWithImages", "fileWithRestofimages", "fileWithRestOfImage", "fileWithListWithimages", "fileWithlistOfImages", "fileWithListofFiles", "fileWithRestOfimages", "fileWithListAndFiles", "fileWithListofimages", "fileWithRestofImage", "fileWithListOfImage"], "outputDir": ["outputdir", "inputUrl", "outputPath", "OutputDirectory", "targetDir", "OutputPath", "targetdir", "inputDir", "Outputdir", "targetPath", "outdir", "outputFolder", "outFolder", "OutputDir", "inputFolder", "outDir", "OutputUrl", " outputDirectory", " outputdir", "outDirectory", "inputPath", "outputUrl", " outputPath", "outPath", "OutputFolder", "outputDirectory", "outUrl", "targetDirectory"], "list": ["link", "cache", "array", "p", "and", "v", "old", "info", "cont", "form", "rm", "set", "st", "collection", "table", "block", "count", "tree", "show", "document", "ist", "index", "def", "pool", "detail", "config", "source", "layout", "the", "details", "single", "summary", "dict", "filter", "view", "this", "cl", "all", "record", "queue", "batch", "base", "see", "lists", "chain", "load", "history", "re", "print", "parent", "add", "copy", "log", "L", "local", "map", "listed", "dl", "status", "t", "item", "pre", "l", "get", "LIST", "li"], "current": ["currently", "counter", "active", "external", "parent", "initial", "head", "now", "system", "created", "present", "continue", "this", "unique", "ex", "old", "integer", "urrent", "future", "number", "update", "i", "next", "multi", "top", "Current", "result", "complete", "URRENT", "valid", "recent", "today", "set", "cur", "collection", "aj", "create", "loop", "length", "open", "reported", "client", "total", "position", "latest", "component", "count", "size", "index", "handle"], "startTime": ["StartTim", "startTimes", " startTim", "StartTimes", "StartTime", "endTim", "startTim", "endTimes", "endTime", " startTimes"], "it": ["ore", "im", "al", "ip", "init", "you", "yt", "qt", "and", "ul", "It", "hit", "nt", "ex", "mit", "ait", "rit", "ort", "iz", "ut", "old", "IT", "lit", "itted", "all", "i", "h", "ct", "io", "j", "they", "let", "il", "oc", "wait", "el", "we", "pit", "he", "its", "br", "or", "st", "ble", "op", "t", "chain", "item", "at", "jit", "l", "ert", "iter", "exec", "et", "ie", "iot", "att", "ht", "ing", "them", "exist", "she", "ind"], "urlString": ["urlStr", "uriStr", "charFormat", "urlList", "urlStream", " urlClass", "nameObject", "urlSet", " urlStr", "urlNumber", "charString", "strNumber", " urlList", "urlClass", "uriString", "imageStr", " urlStream", "urlFormat", "strStr", " urlNumber", "linkString", "nameString", " urlSet", "charObject", "uriObject", "browserString", "imageString", "nameStr", "charStr", "browserSet", "UrlString", "imagestring", "UrlFormat", "uriNumber", "UrlStr", "uriSet", "urlShort", " urlShort", "urlObject", "imageShort", "linkStream", "strString", "urlstring", "Urlstring", "strClass", "UrlObject", " urlObject", "linkSet", "uriClass", "browserList", "linkList", "browserStream", " urlstring", "UrlShort", "nameSet", " urlFormat"], "url": ["mail", "Url", "link", "html", "handle", "r", "b", "gl", "resource", "ssl", "io", "git", "il", "dl", "base", "uri", "web", "http", "nl", "el", "rl", "str", "ll", "browser", "address", "ref", "rel", "l", "open", "URL", "ml", "ur", "ul", "li"], "file": ["port", "link", "File", "p", "task", "info", "buffer", "io", "channel", "data", "user", "bit", "f", "el", "range", "table", "tree", "input", "field", "document", "name", "path", "le", "full", "entity", "e", "fil", "resource", "error", "result", "iff", "il", "type", "report", "http", "family", "row", " File", "pixel", "ile", "fp", "filename", "id", "comment", "base", "object", "db", "output", "print", "column", "handle", "al", "parent", "key", "image", "true", "entry", "run", "local", "email", "FILE", "files", "page", "feature", "play", "t", "work", "dir", "real"], "in": ["inn", "inc", "up", "inas", "init", "is", "find", "ine", "and", "ain", "inner", "stream", "isin", "add", "r", "din", "index", "ini", "irm", "min", "nin", "bin", "i", "ir", "read", "io", "gin", "local", "inter", "one", "on", "within", "il", "from", "In", "ic", "inside", "ins", "with", "an", "en", "no", "IN", "o", "by", "l", "con", "iter", "n", " din", "input", "rin", "cin", "ing", "ar", "inf", "found", "ind"], "out": ["obj", "cache", "conn", "Out", "ex", "content", "max", "cmd", "io", "manager", "one", "user", "res", "conf", "ot", "store", "set", "end", "auto", "msg", "writer", "inv", "on", "at", "gr", "con", "os", "outs", "OUT", "screen", "net", "cn", "up", "nt", "outer", "dis", "ent", "all", "nr", "err", "append", "conv", "gen", "sum", "or", "ins", "o", "OU", "output", "null", "co", "print", "desc", "can", "ou", "al", "init", "gov", "inner", "aos", "flush", "sys", "log", "ion", "inter", "crit", "status", "write", "client", "to", "pretty", "n", "format"], "c": ["cp", "pc", "cache", "cs", "ch", "ac", "bc", "cb", "arc", "cc", "cd", "char", "v", "r", "u", "e", "gc", "cos", "err", "k", "fc", "f", "m", "unc", "uc", "cont", "conf", "nc", "code", "t", "cu", "chain", "lc", "dc", "o", "d", "l", "cm", "cf", "con", "count", "rc", "cr", "z", "ce", "cat", "mc", "C", "n", "col", "ct"]}}
{"id1": "4618237", "id2": "11562173", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFileAsDisk", "writeFile2File", "writeFilesToDisk", "writeFileAndStream", "writeFiles2File", "writeFileAndFiles", "writeFileAndDisk", "writeFiles2Stream", "writeFiles2Files", "writeFilesToStream", "writeFile2Files", "writeFiles2Disk", "writeFileAsFile", "writeFileToDisk", "writeFilesToFiles", "writeFileAndFile", "writeFileToFiles", "writeFilesToFile", "writeFileAsStream", "writeFileToStream", "writeFileAsFiles", "writeFile2Disk", "writeFile2Stream"], "fin": ["fp", "rf", "fur", "ln", "kin", "init", "fre", "inv", "fn", "ini", "mid", "din", "irm", "han", "syn", "Fin", "fil", "fa", "ran", "FIN", "fw", "fc", "f", "raf", "fi", "lin", "fd", "lf", "ic", "mil", "fl", "in", "details", "normal", "en", "mn", "lo", "focus", "fr", "rin", "jen", "n"], "fout": ["ffou", "fboutput", "ffin", "kOut", " foutput", "foutput", "Fou", "kout", "fou", "ffout", "fpo", "Fout", "fbpo", "tin", "Fin", "fbOut", "tOut", " fpo", "tout", "fbout", "tou", "ffOut", "koutput", "FOut", "kpo", "fOut", " fOut"], "append": ["printf", "bold", "include", "string", "equal", "apply", "animate", "replace", "fail", "add", "vert", "allow", "ended", "grow", "update", "folder", "push", "join", "ends", "express", "ext", "batch", "force", "send", "command", "buff", "flat", "insert", "seed", "csv", "app", "pend", "end", "note", "absolute", "ind"], "inChannel": ["Inchannel", "pinMachine", "inputCategory", "intClient", "iChannel", "outStream", "InStream", " inConnection", "innCategory", "iChan", "insideClient", "sinMachine", "inCommand", "insideChannel", "InChannel", "outCommand", "inListener", "rinListener", "innButton", "inputListener", " inCategory", "rinChannel", "intChannel", "pinCategory", "inClient", "innMachine", "outchannel", "rinCategory", " inCommand", "inMachine", "outChan", "inStream", "inputChan", "inputChannel", "insideSession", "InConnection", "inchannel", "inCategory", "inConnection", "iCommand", "rinChan", " inClient", "sinChannel", "innChannel", " inListener", " inStream", " inChan", "intSession", "insideChan", "pinButton", "sinButton", "outConnection", "inSession", "intChan", "iStream", "sinCategory", "inButton", "inChan", " inchannel", " inSession", "pinChannel"], "outChannel": ["outScope", " outController", " outChan", "outCh", "outController", "invChannel", "invCh", "nameChan", "outputScope", "netMember", "outMember", "nameChannel", "outputchannel", " outCh", "OUTchannel", "netchannel", " outConnection", "outputChan", "outputCh", "OUTChannel", " outScope", "netCh", "outputChannel", "outchannel", "invMember", " outchannel", "outChan", "netController", "userCh", "inchannel", "outputConnection", "OUTChan", "userChannel", "nameConnection", "nameScope", "inCh", "OUTController", "outConnection", "netChan", "inChan", "netChannel", "userMember"]}}
{"id1": "12869602", "id2": "22338097", "code1": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"test_validate_tag_getTopAlbums": ["test_validate_tag_getTopAlalbums", "test_validate_tag_getTopAllalbumments", "test_validate_tag_getTopAllalbumes", "test_validate_tag_getTopAlogges", "test_validate_tag_getTopAlbumls", "test_validate_tag_getTopAllalbumls", "test_validate_tag_getTopAllbumes", "test_validate_tag_getTopAloggments", "test_validate_tag_getTopAlbumes", "test_validate_tag_getTopAlalbumments", "test_validate_tag_getTopAllbumls", "test_validate_tag_getTopAloggs", "test_validate_tag_getTopAllalbums", "test_validate_tag_getTopAllbums", "test_validate_tag_getTopAlalbumls", "test_validate_tag_getTopAlalbumes", "test_validate_tag_getTopAloggls", "test_validate_tag_getTopAllbumments", "test_validate_tag_getTopAlbumments"], "factory": [" facter", "cactory", "cancy", "Facter", "facter", "ciller", " fancy", "fFactory", "facactory", "facade", "lactory", "lancy", "cacter", "fade", "facFactory", "vacter", "FFactory", "liller", "vactory", "facacter", "lacter", "vFactory", "Factory", " filler", "fancy", "Fade", "vade", "filler"], "schemaLocation": ["schealPath", "schemaslocation", "semalocation", "scheatureLocation", "scheaturePath", "schemasLocation", "scheaturelocation", "schemaLoc", "schemelocation", "schemaPath", "syallocation", "schembolLoc", "scheatureLoc", "schemalocation", "schemasLoc", "schemePath", "schealLocation", "scheallocation", "symaPath", "seatureLocation", "seaturelocation", "symaLocation", "syalLocation", "semaLocation", "syalPath", "schemeLocation", "seatureLoc", "schembolLocation", "schembollocation", "symalocation", "semaLoc"], "schema": [" scheature", "cheator", "schem", "cheme", "validma", "ScheEMA", " schem", "validm", "mama", "Schema", "scheme", "mame", "scheEMA", "validature", "cheEMA", "chem", "chema", "scheature", "Scheme", "validme", "Scheator", "maator", "maEMA", "cheature", "scheator", " scheme"], "validator": ["verator", "variigator", "validma", "verener", " valider", "navma", "verer", "validigator", "variator", "naver", " validigator", "varima", "valma", "scheener", "valener", "varier", "valer", "scheer", "valator", "verma", "scheator", "valider", "navigator", "validener", " validma", "navator"], "url": ["Url", "link", "name", "hub", "external", "html", "char", "xml", "ul", "r", "u", "mount", "file", "location", "b", "log", "gl", "ssl", "resource", "channel", "user", "bel", "f", "base", "abs", "dl", "uri", "res", "web", "http", "sl", "nl", "service", "str", "ll", "browser", "address", "api", "rel", "l", "get", "null", "URL", "ur", "window"], "inputStream": ["Inputstream", "audioStream", "sourcestream", " inputSteam", "sourceStream", "audioStreamer", " inputstream", "audiostream", " inputStreamer", "sourceSteam", "InputStreamer", "InputStream", "inputStreamer", "feedstream", "inputSteam", "sourceSource", "inputstream", "inputSource", "feedSource", " inputSource", "feedSteam", "feedStream"], "source": ["Source", "iterator", "sequence", "response", "inner", "stream", "ource", "src", "scope", "xml", "sample", "series", "file", "session", "resource", "context", "channel", "data", "result", "from", "sl", "status", "sql", "body", "store", "console", "service", "in", "ser", "str", "sf", "class", "input", "sp", "SOURCE", "reader", "wrapper"]}}
{"id1": "14054923", "id2": "17580775", "code1": "    protected Document getRawResults(String urlString, Map args) throws Exception {\n        int count = 0;\n        Iterator keys = args.keySet().iterator();\n        while (keys.hasNext()) {\n            String sep = count++ == 0 ? \"?\" : \"&\";\n            String name = (String) keys.next();\n            if (args.get(name) != null) {\n                urlString += sep + name + \"=\" + args.get(name);\n            }\n        }\n        URL url = new URL(urlString);\n        URLConnection conn = url.openConnection();\n        conn.connect();\n        SAXBuilder builder = new SAXBuilder();\n        return builder.build(conn.getInputStream());\n    }\n", "code2": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "label": 0, "substitutes": {"getRawResults": ["getOriginalResults", "getFullResults", "getRawResult", "getrawResults", "getOriginalresults", "getFullValues", "getFullResult", " getrawResult", " getRawValues", "getrawresults", " getrawResults", "getRawValues", "getFullresults", " getRawResult", "getrawResult", " getRawresults", "getOriginalValues", "getRawresults", "getOriginalResult", " getrawresults", " getrawValues", "getrawValues"], "urlString": [" urlRest", "urlStr", "lObject", "requestString", "urlData", " urlStr", "lString", "buildStr", "uristring", "uriString", "buildData", "lAddress", "baseStr", "lRest", "baseString", "basestring", "requestData", " urlAddress", "baseAddress", "lStr", "buildstring", "uriObject", "buildString", "requeststring", " urlData", "urlObject", "urlstring", "urlAddress", " urlObject", "lstring", "uriRest", " urlstring", "urlRest", "requestStr"], "count": ["counter", "will", "race", "amount", "OUNT", "now", "find", "consider", "continue", "corruption", "nt", "current", "nb", "repeat", "number", "make", "start", "i", "next", "ount", "scroll", "call", "f", "c", "cont", "coll", "conf", "cond", "ound", "code", "thread", "chain", "length", "hold", "Count", "z", "size", "follow", "ct", "index", "ind", "state"], "keys": ["hands", "writers", "groups", "owners", "makers", "fields", "ports", "strings", "drivers", "ars", "ds", "ers", "values", "mers", "appers", "vers", "holders", "ters", "Keys", "nets", "airs", "files", "bys", "ites", "ies", "workers", "oids", "actions", "rows", "ids", "ppers", "unders", "ms", "ators", "ings", "types", "times", "phis", "items", "aws", "ians", "chers", "ties", "ors", "lights", "ics", "chains", "headers", "ks", "ues", "names", "ients"], "sep": [" seep", "SEfac", "semps", "Sepa", "seep", "separp", "Seps", "separps", "semep", "SEep", "sefac", "semp", "Seep", "SEp", "separep", " sepa", "Sep", " sefac", "sepa", " seps", "SEps", "seps", "separpa", "semfac"], "name": ["child", "path", "key", "NAME", "other", "init", "string", "part", "def", "order", "v", "old", "a", "current", "add", "entry", "title", "info", "parent", "label", "value", "all", "named", "admin", "alias", "me", "local", "on", "id", "tab", "m", "comment", "search", "Name", "str", "t", "chain", "create", "no", "l", "common", "client", "ame", "word", "family", "n", "to", "na", "field", "sp", "missing", "names", "var"], "url": ["mail", "Url", "link", "hl", "pl", "cert", "ret", "mb", "sb", "mount", "cmd", "b", "err", "gl", "ssl", "parse", "bel", "base", "dl", "il", "uri", "abs", "res", "web", "http", "nl", "sl", "str", "ll", "browser", "ref", "https", "loc", "rel", "l", "open", "URL", "norm", "net", "ls", "ur"], "conn": ["obj", "die", "ch", "init", "cert", "resp", "socket", "addr", "cb", "comm", "org", "act", "enc", "nt", "ns", "connect", "cmd", "sys", "fin", "ssl", "close", "conv", "sync", "res", "pas", "nc", "cur", "gate", "jp", "rel", "db", "ctx", "client", "open", "con", "connection", "exec", "ann", "Conn", "ct", "n", "cp", "cn"], "builder": ["alph", "building", "writer", "bus", "bean", "operator", "order", "loader", "factor", "adder", "flower", "layer", "b", "buffer", "parser", "build", "function", "manager", "bar", "builders", "Builder", "base", "handler", "good", "instance", "sf", "pb", "component", "client", "built", "upper", "block", "creator", "dict", "runner", "filter", "eng", "reader", "control", "BU"]}}
{"id1": "9826240", "id2": "22022715", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "label": 1, "substitutes": {"checkHashBack": ["checkClearDown", " checkhashUp", "checkHashDown", " checkHashback", " checkHashUp", "checkLockUp", "checkClearBack", "checkHashback", "checkLockDown", "checkHashUp", "checkhashUp", " checkhashDown", "checkhashDown", "checkhashBack", "checkClearback", "checkLockBack", " checkhashBack", "checkhashback", " checkHashDown", " checkhashback", "checkClearUp", "checkLockback"], "facade": ["funcade", "latade", "formade", "Facades", "facaded", "formace", "facades", "Facade", "latlegate", "facace", " facades", "glader", "glage", "Facader", " facage", "latace", "facader", "latader", "servade", "servaded", "famade", " facaded", "funclegate", "faclegate", "Facage", "famace", "Facaded", "formacet", "Facificate", "facacet", "facage", "Faclegate", "funcader", "servades", "glade", "formificate", "famificate", "famacet", "Facacet", "funcage", "servage", "facificate", "funcace", "glace", "Facace"], "req": ["msg", "obj", "p", "resp", "sq", "tx", "uj", "qt", "aux", "org", "required", "attr", "rec", "forge", "r", "e", "cmd", "Request", "params", "err", "etc", "wx", "data", "Resp", "rpm", "queue", "qq", "res", "needed", "reg", "q", "http", "ctr", "good", "forced", "body", "wcs", "Requ", "cur", "out", "urg", "jp", "proc", "rh", "work", "ctx", "gr", "pkg", "mr", "request", "rb", "requ", "compl", "qs", "require", "quest", "desc"], "txtTransactionID": ["txtTxKey", "textTxID", "xtTxKey", "xtTxID", "txtTransKey", "txtTxName", "txtOrderID", "txtTransName", "txtTransactionName", "textTransactionId", "textTransactionName", "txtTransactionId", "txtTXID", "textTransactionID", "textTxName", "txtTransID", "txtOrderId", "txtTXId", "xtTransactionKey", "txtTransId", "xtTransactionName", "xtTransactionId", "txtTXName", "txtTransactionKey", "txtOrderKey", "xtTxName", "txtTxId", "xtTxId", "xtTransactionID", "txtTxID", "textTxId", "txtOrderName"], "txtOrderTotal": ["txtOrdComplete", "txtJobId", "strTransactionComplete", "txtTradeComplete", "txtTransactionBase", "txtTransactionComplete", "txtOrderComplete", "txtOrderSum", "txtOrdInfo", "xtOrdSum", "xtOrdId", "xtOrderSum", "txtJobInfo", "txtOrderInfo", "txtOrdBase", "txtArticleSum", "strTransactionTotal", "xtOrderInfo", "strOrderComplete", "txtJobSum", "txtTradeBase", "xtOrdTotal", "txtOrderId", "txtArticleInfo", "xtOrderId", "txtOrdSum", "txtTransactionTotal", "txtTradeTotal", "xtOrdInfo", "strTransactionBase", "txtOrdTotal", "txtOrdId", "strOrderBase", "txtJobTotal", "txtArticleTotal", "txtArticleId", "xtOrderTotal", "txtOrderBase", "strOrderTotal"], "txtShopId": ["xtSiteid", "txtServerid", "txtServerID", "xtSiteId", "txtStreetId", "txtSiteID", "textStoreId", "txtSiteAid", "textShopId", "textShopById", "textShopid", "txtStoreID", "txtShopid", "txtShopID", "txtStreetid", "txtSiteById", "xtShopid", "txtShopById", "textStoreById", "xtSiteID", "txtServerId", "txtSiteid", "xtShopAid", "xtShopId", "textShopID", "txtStoreById", "txtForgeId", "textStoreid", "txtStreetID", "textStoreID", "xtSiteAid", "txtForgeid", "txtSiteId", "txtForgeAid", "txtShopAid", "txtStoreId", "txtServerAid", "txtStoreid", "txtForgeID", "txtStreetById", "xtShopID"], "txtArtCurrency": ["txtArtConurrency", "txtArticleConurrency", "txtArtColurrency", "txtArtConcurrency", "txtArtCcurrency", "txtArticleCocurrency", "txtArticleCurrencies", "txtArtCoulture", "txtArtCurrencies", "txtArtConulture", "txtArtCategories", "txtArtCourrencies", "txtArticleCcurrency", "txtArticleCurrency", "txtArticleCourrency", "txtArticleCulture", "txtArtConategories", "txtArtCocurrency", "txtArticleCategories", "txtArticleConcurrency", "txtArtColcurrency", "txtArticleCoulture", "txtArtCoategories", "txtArtCourrency", "txtArtColategories", "txtArticleConategories", "txtArticleCourrencies", "txtArtConurrencies", "txtArtCulture"], "txtHashBack": ["txthashback", "txtClearback", "txtClearBack", "txthashBACK", "xtHashBack", "txtClearFront", "texthashBACK", "txtFilterBack", "txtFilterback", "txtRawBack", "xtStockback", "texthashFront", "txtHashFront", "txtHashback", "txthashFront", "xtHashFront", "texthashback", "xtHashback", "txtFilterBACK", "txtStockBack", "txtLockBACK", "txtHelpback", "txtStockFront", "txthashBack", "textHashBACK", "textHashFront", "txtFilterFront", "xtStockBACK", "xtStockBack", "xtHashBACK", "txtRawBACK", "txthashValue", "txtRawValue", "txtLockback", "txtHashBACK", "txtStockBACK", "textHashValue", "txtHelpBACK", "txtClearBACK", "txtHashValue", "txtStockback", "txtHelpFront", "textHashback", "txtRawback", "txtLockBack", "texthashValue", "txtLockFront", "txtHelpBack", "texthashBack", "textHashBack", "xtStockFront"], "hashSeed": ["hoAseed", "hashAsetter", "hashSourceeed", " hashSeeds", " hashSee", "hashSeiper", "hoAsetter", "hashFetter", "hoSep", "hoSeed", "hashSetter", "hashSourceeder", "hoAsep", "hashSourceep", "hashSliper", " hashSeee", "hoAseder", "hashAseder", "hashSeeed", "hashSleeds", "hashFep", "hashFeed", "hashAsep", "hashSiper", "hashSeee", "hashSeeeds", "hashSourceetter", "hashSlee", " hashSiper", "hashAseed", "hoSetter", " hashSeeed", "hashFeder", "hoSeder", " hashSeeeds", "hashSeder", "hashSep", "hashSleed", " hashSeiper", "hashSeeds", "hashSee"], "securityValue": ["secData", "SecurityValues", " securityVal", "securityVal", "SecurityValue", "securityData", "SecurityVal", "securityValues", "secValues", " securityData", "secVal", " securityValues", "secValue", "SecurityData"], "digest": ["dEST", "Digest", "contest", "macested", "dester", "diger", "dest", "Diget", " digested", "Digester", "contested", "contests", "der", " diger", "Diggest", "diggest", "dependested", "equester", "equse", "diget", "digse", "digests", "macest", "dependest", "macgest", " digse", "dse", "equet", "digested", "dependgest", "Digse", " digester", " diget", " digests", " digEST", "digEST", "Diger", "DigEST", "digester", "Digests", "dested", "contse", "macester", "Digested", "equest", "dependester"], "array": ["attribute", "response", "view", "rays", "shape", "ray", "raw", "Array", "string", "our", "now", "arrow", "v", "a", "RAY", "max", "number", "buffer", "archive", " Array", "stage", "record", "ash", "export", "map", "ar", "bar", "av", "batch", "audio", "arr", "vector", "instance", "angular", "object", "range", "ashes", "collection", "binary", "angle", "length", "share", "list", "row", "iq", "pair", "area", "sha"], "sb": ["obs", "erb", "bg", "ib", "sq", "shell", "soc", "bs", "cb", "sbm", "sa", "bh", "abb", "nb", "lb", "gc", "rub", "ssl", "bsp", "bb", "orb", "esm", "sg", "sam", "sv", "lp", "eb", "abs", "bis", "gb", "bf", "bj", "ctrl", "rob", "gob", "sf", "wb", "kb", "pb", "obb", "sn", "bt", "ob", "rb", "SB", "zb", "bps", "ls", "stab"], "j": ["ix", "msg", "obj", "key", "jump", "uj", "x", "jl", "ji", "it", "g", "v", "ja", "job", "yy", "json", "jo", "jc", "ody", "i", "k", "oj", "from", "kj", "q", "_", "J", "el", "jet", "bj", "br", "ij", "aj", "dj", "jp", "jit", "gr", "jj", "js", "z", "att", "bot", "n", "ind", "state"], "b": ["bi", "bg", "ib", "bc", "bs", "cb", "mb", "v", "B", "ab", "nb", "bd", "h", "k", "ba", "bb", "bar", "bp", "bit", "beta", "eb", "base", "bu", "bis", "gb", "br", "bf", "binary", "db", "bound", "BB", "bt", "rb", "fb", "be"], "hash": ["url", "cache", "where", "response", "html", "key", "header", "version", "string", "uh", "height", "bh", "message", "sample", "ASH", "title", "json", "value", "h", "ssl", "data", "ash", "hz", "password", "result", "search", "Hash", "ah", "report", "crypt", "format", "sum", "tag", "ashes", "check", "address", "test", "rh", "buster", "total", "block", "flash", "hex", "filter", "href", "oh", "handle", "sha"]}}
{"id1": "15810440", "id2": "8921716", "code1": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"addRecipe": ["newRule", "setRecipe", "setDefinition", " addDefinition", "newDefinition", "newRecipe", "addRule", " addRule", "addDefinition", "setRule"], "name": ["sequence", "path", "NAME", "key", "image", "string", "version", "about", "system", "description", "title", "label", "value", "file", "config", "source", "named", "question", "filename", "alias", "admin", "data", "template", "root", "error", "comment", "base", "type", "category", "prefix", "in", "Name", "summary", "address", "definition", "common", "table", "ame", "word", "family", "term", "license", "names", "n"], "instructions": ["inemptIONS", "injectings", "inscriptions", "inSTRUCTION", "inscriptures", "injectION", "injectations", "construction", "INSTRUCTions", "inSTRUCTions", "insjectings", "conructures", "instructION", "INstructures", "instrations", "constructures", "INSTRUCTures", "instructures", " instructations", "inripts", "instructations", "inSTRUCTIONS", "instritions", "INstructIONS", "instractings", "conruction", "INstructions", "insstruction", "inription", "instructs", "inemptations", " inemptions", "inInstructION", "instracts", "injectures", "constructions", " inemptitions", "insjections", "inructures", "instructings", "inscriptations", "insjection", "conructations", "inructIONS", "instrIONS", "inSTRUCTures", "inInstructures", "INstructION", "instrions", "INSTRUCTION", "instractions", "constructations", "injectIONS", "instraction", "inructations", "injects", "inInstructions", "inructions", "inruction", "insstructs", "instructIONS", " instructitions", "inriptings", "insjects", " instructIONS", "inInstructIONS", "inemptions", "instructitions", "inructitions", " inemptIONS", "injections", " inemptations", "inriptions", "conructions", "inscription", "insstructings", "insstructions", "INSTRUCTIONS", "instruction", "injection", "inemptitions"], "categoryId": ["folderID", " categoryInfo", "familyid", " categoryById", " categoryid", "ategoryID", "categoryid", " categoryID", "currencyID", "currencyById", "familyById", "folderId", "categoryById", "familyID", "categoryInfo", "ategoryInfo", "folderid", "ategoryId", "folderById", "ategoryid", "currencyId", "currencyInfo", "categoryID", "familyId", "folderInfo"], "ainekset": ["ainysSet", "ainysets", "aineekset", "areewsET", "aineeksut", "areeksets", "aineeksets", "aineeksit", "ainsekset", "ainseksetter", "aineeksetter", "ainzensET", "ainewset", "aineksET", "aineksset", "ainzensit", "areewsSet", "aineeksSet", "ainzenset", "ainewsET", "ainskesSet", "areewsets", "areewsit", "ainskeset", "areeksit", "areeksset", "aineeksET", "areekset", "ainewsSet", "aineksit", "areewsset", "ainyset", "ainskesut", "aineeksset", "ainvesut", "ainzensset", "ainewsets", "areewset", "areeksSet", "ainysset", "ainseksut", "ainveset", "ainseksSet", "areeksET", "ainewsset", "aineksSet", "aineksut", "aineksetter", "ainvesetter", "ainkesetter", "ainskesetter", "aineksets", "ainkesut", "ainvesSet", "ainkesSet", "ainewsit", "ainkeset"], "pst1": ["pSTOne", "apstrOne", "pSTInternal", "pest2", "pcstore7", "pcstore2", "pST7", "pst001", " pctOnce", "pstrOnce", "pstyOnce", "pST2", "pert101", "pcst30", "pst8", "pcstore1", "apst3", "pST30", " pct2", "pct1", "PSt1", "prest51", "psta1", "patstra1", "psty2", "pstra51", "pestPre", "pst30", "pSt10", "prest8", "pstPre", "pST3", "pstr3", "pSt3", "prest001", "pstore2", "pst51", "wpst101", "pestOnce", "pconst8", "pstaInternal", "pmt2", "pconst001", "Pst2", "prest10", "patst8", "psta101", "pST101", "wpstaInternal", "pstOne", "pstore7", "pstr1", " pct1", "pst3", "pert1", "wpsta1", "pST1", "pctPre", "prest1", "pstOnce", "pstra1", "pSt1", "prestOne", "pcst2", " pstOnce", " pctPre", "patstra8", "pstore1", "wpst0", "PstOne", "apst1", "pcstore30", "pstrOne", "apstr1", "wpsta101", "pert0", "Pst10", "pstyPre", "pmt1", "pmt7", "patst001", "pStOne", "pstra8", "patstra51", "pst7", "prest2", "apstr3", "pst10", "pStOnce", "psty1", "PStOne", "pmt30", "pst0", "pctOnce", "pST0", "apstOnce", "patst1", "wpstInternal", "wpsta0", "pcst1", "psta0", "pSt2", "pst101", "PSt10", "apstrOnce", "pcst7", "pest1", "pST10", "pstInternal", "pstore30", "apstOne", "pconst1", " pstPre", "wpst1", "patstra001", "pSTOnce", "pstra001", "patst51", "pconst51", "pct2", "pertInternal", "Pst1", "PSt2"], "pst2": ["pstd2", "psth42", "pest2", "prost2", "psth22", "pster02", " pct8", "lpst2", "pswtwo", "pkt2", "pSt7", "pstat8", "PST1", "pST2", "PST2", "pst8", "PSTB", "prosetdb", "pkttwo", " pct2", "pst22", "pstd52", "Pst22", "pstB", "pct0", "pth2", "pusttwo", "psth1", "pust2", "ppsttwo", " pst8", "pSt3", "lpster7", "prosttwo", "pst02", "pset42", "pstattwo", "pstdb", "pest8", "proset2", "Pst2", "pST22", "psthtwo", "pst52", " pst3", "pSt8", "psthB", "PstB", "pset2", "ppusttwo", "pSt0", "psw8", " psttwo", "pster2", "psth2", "pst3", "pST1", "pSTB", "ppust2", "pct3", "prost42", "lpst7", "pSt1", " pst0", "ppst52", "psthdb", "psth7", " pct0", "lpster2", "lpster02", "psettwo", " pstattwo", "ppst2", "pstdtwo", "pst7", "psth02", "pSt22", "pth8", " pstat2", " pstat8", "lpst02", "pest3", "pst0", "pkt42", "pct8", "psttwo", "pktdb", "pSt2", "pest0", "pstat52", "psetdb", "psw2", "prosettwo", "pst42", "pStB", "ppust52", "pSt02", "prostdb", "pct2", "PST22", "pust52", "pthtwo", "proset42", "pster7", "pstat2", "Pst1", " pct3"], "rs": ["ls", "ras", "cs", "rd", "ws", "icks", "ges", "bs", "ps", "cks", "ats", "ars", "hr", "ds", "sr", "rates", "irms", "ubs", "RS", "ys", "vers", "gs", "ris", "xs", "bys", "fs", "sts", "res", "ags", "rows", "its", "wcs", "rl", "ims", "ours", "ms", "rys", "vs", "Rs", "usr", "acks", "times", "mr", "rc", "s", "js", "ires", "qs", "ows", "hs", "ks", "mc", "ues", "rt"], "retVal": [" retValid", "RETval", "contVAL", "rtVal", " retValue", "retsDev", "retsValue", "rtSel", "altRes", "retDev", "contValue", "altVal", "altValue", "rtval", " retval", "retval", "rtValue", "RETValue", "contRes", "Retval", "altVAL", "contVal", " retSel", "RETSel", " retVAL", "RetValid", " retDev", "retsVal", "retsval", "RETVal", "RetVal", "retVAL", " retRes", "retValue", "RETValid", "RetDev", "retRes", "RetValue", "retValid", "retSel"], "id": ["url", "sid", "key", "it", "oid", "hid", "a", "mid", "info", "ide", "rid", "uid", "start", "kid", "h", "ID", "alias", "val", "one", "record", "aid", "result", "num", "m", "f", "res", "time", "fd", "ids", "status", "in", "hash", "ref", "d", "db", "pid", " tid", "bid", "Id", "size", "ident", "index", "vid"], "aines": ["raines", "ainsves", "expresses", "ainces", "ainis", "ainves", "rainis", "aine", "AINe", "abais", "havees", "expressES", "abae", "abaces", "AINES", "ainses", "haveses", "asteris", "ainsesome", "expressces", "inse", "havee", "raine", "asteresome", "natis", "rainces", "insis", "ainsses", "nate", "ainsces", "ainES", "expresse", "AINes", "rainves", "rainES", "ainsis", "abaes", "astere", "nates", "haveis", "inses", "ainse", "AINves", "insses", "natesome", "asteres", "ainsES", "ainesome", "expressves"], "i": ["ix", "bi", "im", "sequence", "ip", "init", "go", "key", "mi", "is", "x", "it", "gi", "phi", "ui", "si", "v", "ini", "hi", "ami", "u", "e", "cli", "gu", "h", "io", "ci", "ti", "multi", "j", "di", "xi", "f", "m", "q", "ri", "y", "ei", "ic", "ms", "qi", "us", "o", "ai", "I", "my", "pi", "sim", "index", "ii", "li"]}}
{"id1": "255765", "id2": "10936821", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "label": 0, "substitutes": {"f": ["fp", "name", "rf", "fab", "tf", "path", "exp", "fed", "p", "it", "def", "ret", "fm", "fax", "fo", "fn", "v", "g", "F", "info", "r", "w", "e", "file", "b", "filename", "h", "fx", "fa", "j", "fw", "fc", "m", "c", "base", "fs", "fi", "fd", "elf", "q", "bf", "lf", "y", "form", "t", "sf", "test", "o", "d", "cf", "l", "ft", "dir", "n", "fac", "fr", "fb", "df"], "in": ["inn", "im", "al", "inc", "up", "init", "ac", "is", "it", "inner", "isin", "ex", "add", "r", "din", "info", "mm", "all", "make", "nin", "bin", "h", "log", "io", "gin", "local", "on", "m", "from", "again", "In", "ic", "ins", "t", "en", "er", "IN", "at", "o", "by", "l", "lo", "get", "iter", "ai", "con", "n", " din", "ma", "cin", "rin", "input", "re", " IN", "pi", "reader", "inf", "oin", "ind", "thin"], "cbuf": ["cfuf", "rbbuf", "bcuff", "rboff", "abbbuf", "rbuf", "cduff", "cbdf", "cbbf", "cduf", "rbfg", "cdbuf", "CBf", "cbf", "cdoff", "sbbuf", "cfuff", "sbuff", "CBbuf", "nbbuf", "nbuff", "cduffy", "cbuff", "cff", "gbf", "sbuf", "rbather", "abbdf", "cfbf", "CBuffy", "CBbf", "gbbf", "nbfg", "rbuff", "CBuff", "sbather", "bcdf", "rbuffy", "gbuf", "bcfg", "cbuffy", "cbfg", "abbfg", "gbuff", "CBuf", "cbbuf", "cbather", "bcather", "rbdf", "cboff", "abbuf", "bcbuf", "nbuf", "bcoff", "bcuf"], "read": ["scan", "link", "is", "stream", "ready", "old", "reads", "pack", "buffer", "io", "data", "ly", "ead", "saw", "set", "range", "text", "miss", "iter", "count", "core", "end", "seek", "skip", "input", "readable", "trust", "index", "pe", "ind", "READ", "clear", "est", "ignore", "bind", "height", "fail", "ret", "current", "r", "start", "error", "sync", "report", "send", "poll", "depth", "mem", "Reader", "slow", "hold", "row", "ink", "raw", "view", "ip", "orig", "burst", "select", "find", "reach", "reading", "se", " Read", "ed", "value", "hello", "query", "rank", "k", "parse", "give", "record", "rate", "dev", "mix", "ank", "wait", "q", "chain", "load", "test", "length", "ke", "ai", "roll", "re", "print", "handle", "key", "it", "x", "add", "shift", "run", "connect", "allow", "feed", "log", "close", "default", "ext", "think", "check", "play", "pre", "write", "ok", "open", "get", "need", "reader", "n", "fill", "Read"], "totRead": ["tottWrit", "totalCheck", "totReader", "ltotRead", "toteAdd", "toteFind", "tcotDisplay", "atotaPrint", "tottNeed", "notaLoad", "trotRead", "totNeed", "trotFind", "retotReader", "ttottAdd", "tiatFill", "tOTFind", "totaBuild", "tokLoad", "notPrint", "totCheck", "tacotCheck", "taotConnect", "tfatWrite", "totPrint", "tobyPrint", "totAdd", "notalLoad", "tottAdd", "totaLoad", "totaFind", "tOTRead", "tiatVal", "notRead", "tiotBreak", "totaNeed", "notalNeed", "totBreak", "tiotVal", "ptotFind", "tottedRead", "trotWrite", "ttottNeed", "taotRead", "taotDisplay", "totalWrite", "totWrit", "totalLoad", "tobyCheck", "ptotWrite", " totRun", " totLength", "tiotFill", "totalFind", "tobyNeed", "ptOTFind", "retotRead", "tobyLoad", "tcotSend", "totaDisplay", "toteWrite", "tootRead", "tootConnect", "tiatSend", "ttotNeed", "retottPrint", "totalNeed", "tcotCheck", " toteRead", "letrotFind", "tootCheck", "atotaFill", "toiotRead", "totalLength", "letotSee", "totHave", " totalRead", "letrotSee", "taotCheck", "notalCheck", "ltotBuild", "tootDisplay", " totFind", "ptOTLoad", "tacotConnect", "tottReader", "tiotRead", " totalBuild", "ttotRead", "tootBreak", "tootVal", "tcotBreak", "tcotConnect", "tottWrite", "notaRead", "totaCheck", "totRun", "tiotHave", "atotHave", "ptOTWrite", "tiatBuild", "letotFind", " toteFind", "totSend", "toteNeed", "trotSee", "tokFind", "ptotLoad", "totalSee", "notCheck", "tcotVal", "totaRead", "toiotSend", "totVal", "totaPrint", "notReader", "totedHave", "tottedReader", "tiotSend", " toteRun", "tacotRead", "totFill", "tacotDisplay", "toteReader", "totaConnect", "totaLength", "tobyWrite", "tiatLoad", "toteLoad", " totBuild", "tiotReader", "tottRead", "atotaHave", "totDisplay", "toteRead", "totaAdd", " totWrite", "ptotRead", "ltotFill", "notalRead", "totaHave", "toticRead", "tokWrite", "tiatRead", "tottRun", "tOTLoad", "totConnect", "totSee", "tOTWrite", "ttotWrite", "toiotBreak", "notLoad", "totedPrint", "toteRun", "letrotRead", "letrotWrite", "tottedWrit", "totalBuild", "notWrite", "atotPrint", "tiotPrint", "totLoad", "toiotVal", "retottWrit", "toteFill", "toteBuild", "ltotaRead", "totLength", "letotRead", "toticWrite", "totalPrint", "totWrite", "atotaRead", "tiotWrit", "notalPrint", "retotPrint", "retottReader", "atotRead", "ltotaLoad", "ltotaFill", "totaReader", "tiatBreak", "tcotRead", " totalWrite", "totaSee", "ltotLoad", "totedRead", "notalWrite", "tootSend", "ltotaBuild", "totalRead", "toticFind", "notNeed", "atotFill", " totalLength", "notaReader", "totaFill", "tokRead", "toteLength", "totBuild", "tOTNeed", "tobyRead", "ptOTRead", "tottFind", "letotWrite", "tottPrint", "ttottRead", "notaWrite", "tfatReader", " toteWrite", "totaWrite", "retotWrit", "ttottWrite", "toticRun", "totedFill", "retottRead", "tfatRead", "totFind", "tfatLoad", "ttotAdd", "tottedPrint"], "out": ["auto", "obj", "up", "ch", "writer", "Out", "g", "ex", "v", "r", "w", "aos", "b", "sys", "log", "io", "conv", "c", "res", "we", "or", "t", "at", "o", "OU", "write", "output", "con", "os", "to", "oss", "end", "co", "s", "outs", "OUT", "net", "n", "ou"], "i": ["ix", "im", "php", "p", "is", "phi", "ui", "v", "hi", "info", "ski", "io", "ci", "multi", "di", "uri", "ei", "set", "ic", "ity", "qi", "ico", "I", "my", "sim", "ia", "index", "ind", "ii", "si", "r", "integer", "e", "iu", "point", "xi", "m", "iii", " I", "ki", "ice", "ip", "ri", "you", "this", "g", "mm", "\u0438", "cli", "me", "zi", "id", "c", "q", "y", "ims", "ij", "chain", "o", "ai", "ie", "print", "bi", "init", "oi", "any", "mi", "it", "x", "gi", "ji", "ini", "ami", "um", "b", "ion", "ti", "j", "iy", "status", "PI", "t", "us", "l", "client", "to", "s", "pi", "iq", "dr", "li"]}}
{"id1": "9413074", "id2": "16063533", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "label": 0, "substitutes": {"getLocation": ["newLocation", " getlocation", "loadLocation", "getURL", "getURI", " getURL", "GetLoc", "newlocation", "loadURL", "getDescription", "getLoc", "GetDescription", "newLoc", " getLoc", "Getlocation", "GetURI", "loadURI", "GetLocation", "newDescription", " getDescription", " getURI", "loadDescription", "GetURL", "getlocation"], "clazz": ["ClClass", "scamp", "klClass", "scaz", "claz", "klaz", " claz", "Clazz", " clos", "CLazz", "klclass", "Clamp", "CLclass", "Claz", "clclass", "klazz", "CLaz", " clamp", "clClass", "Clos", "scazz", "clos", "scos", "clamp", "CLClass", "Clclass"], "url": ["remote", "Url", "link", "util", "mail", "hl", "conn", "path", "cert", "string", "handle", "socket", "org", "char", "ret", "this", "xml", "loader", "r", "u", "sb", "run", "mount", "log", "err", "gl", "buffer", "ssl", "resource", "host", "build", "channel", "user", "result", "f", "dl", "base", "abs", "uri", "web", "nl", "http", "q", "sl", "sql", "rl", "impl", "str", "ll", "browser", "address", "ref", "https", "loc", "rel", "l", "client", "get", "ob", "lr", "row", "URL", "ml", "ls", "ur", "ul", "addr"], "location": ["name", "where", "origin", "path", "none", "Location", "string", "display", "description", "scope", "availability", "message", "usage", "title", "expression", "ocation", "value", "update", "filename", "layout", "ion", "slot", "resource", "resolution", "function", "local", "reference", "behavior", "padding", "translation", "library", "media", "result", "selection", "application", "comment", "displayText", "type", "nl", "command", "trace", "peer", "region", "color", "feature", "range", "language", "summary", "direction", "address", "history", "loc", "relation", "l", "length", "family", "position", "row", "operation", "document", "directory", "area"], "file": ["ile", "port", "name", "fp", "path", "parent", "le", "File", "image", "full", "face", "entity", "run", "folder", "filename", "resource", "io", "channel", "FILE", "checked", "library", "user", "files", "f", "page", "object", "out", "binary", "angle", "ref", "db", "table", "output", "module", "dir", "block", "ca", "ory", " File", "pe", "format"]}}
{"id1": "3731077", "id2": "17996547", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"copyFile": ["downloadFile", "CopyFile", " cpfile", "copyDirectory", "CopyFiles", "Copyfile", "downloadFiles", "downloadDirectory", " cpFile", " cpFiles", "copyFiles", "copyfile", "CopyDirectory", "downloadfile", " cpDirectory"], "from": ["name", "link", "url", "view", "html", "origin", "orig", "path", "por", "vol", "string", "bean", "org", "part", "old", "add", "se", "a", "what", "without", "info", "before", "original", "pro", "file", "config", "source", "so", "start", "query", "local", "data", "f", "base", "form", "or", "st", "str", "range", "with", "of", "at", "un", "From", "by", "db", "term", "rom", "s", "input", "fr", "reset", "star", "ol", "as"], "to": ["name", "auto", "tu", "html", "eto", "parent", "none", "full", "it", "org", "phi", "this", "dest", "nt", "toc", "target", "temp", "two", "file", "oto", "tt", "etc", "TO", "one", "must", "that", "template", "top", "on", "f", "too", "base", "po", "into", "te", "or", "st", "ta", "To", "t", "no", "bo", "o", "by", "table", "total", "output", "null", "pt", "tree", "co", "tom", "th", "size", "token", "pretty"], "parentDir": ["parentFile", " parentFile", "masterDirectory", " parentdir", "parentFolder", " parentFolder", "parentDirectory", "masterDir", "netdir", "rootFile", "ParentFile", "ParentDir", "rootDir", "ParentDirectory", "Parentdir", "ParentFolder", "netFile", "parentdir", "rootdir", "netFolder", "netDir", "rootFolder", "masterFolder", "masterFile", " parentDirectory"], "in": ["inn", "al", "inc", "up", "ri", "init", "raw", "mi", "irc", "it", "ain", "is", "sin", "inner", "xml", "isin", "ini", "din", "mm", "config", "source", "min", "all", "update", "bin", "i", "ir", "gin", "local", "one", "win", "on", "id", "In", "conf", "form", "ins", "inside", "en", "IN", "o", "doc", "get", "con", "ma", "input", "rin", "cin", "re", " IN", "net", "mc", "print", "vin", "inf", "ind"], "out": ["auto", "obj", "go", "ln", "vol", "it", "css", "Out", "g", "ex", "v", "nt", "aos", "outer", "ns", "cmd", "file", "gc", "b", "all", "sys", "ion", "i", "cos", "err", "io", "nin", "one", "conv", "gt", "on", "c", "ou", "again", "res", "ot", "or", "op", "t", "no", "at", "ro", "o", "ne", "write", "output", "client", "os", "null", "con", "oss", "co", "na", "outs", "OUT", "list", "net", "can", "n", "cn"], "ic": ["ix", "mic", "pc", "inc", "iac", "icon", "ip", "icy", "ac", "bc", "irc", "it", "cc", "eric", "arc", "tc", "tic", "iu", "sic", "i", "nic", "ci", "aic", "fc", "icc", "c", "ik", "ot", "pic", "ico", "cu", "ins", "ican", "vc", "cus", "IC", "wic", "isc", "rc", "co", "cin", "ics", "ric"], "oc": ["mic", "oly", "pc", "ac", "irc", "ocon", "soc", "ec", "cot", "arc", "ocr", "ox", "tc", "toc", "OC", "oe", "anc", "roc", "osc", "gc", "ict", "cos", "og", "nic", "ci", "aic", "yo", "oci", "oco", "mot", "c", "unc", "voc", "ot", "oct", "nc", "ucc", "pic", "ico", "cu", "o", "vc", "oca", "alloc", "cus", "co", "ric", "aco"]}}
{"id1": "255765", "id2": "13333160", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"f": ["fp", "name", "rf", "fab", "tf", "path", "exp", "fed", "p", "it", "def", "ret", "fm", "fax", "fo", "fn", "v", "g", "F", "info", "r", "w", "e", "file", "b", "filename", "h", "fx", "fa", "j", "fw", "fc", "m", "c", "base", "fs", "fi", "fd", "elf", "q", "bf", "lf", "y", "form", "t", "sf", "test", "o", "d", "cf", "l", "ft", "dir", "n", "fac", "fr", "fb", "df"], "in": ["inn", "im", "al", "inc", "up", "init", "ac", "is", "it", "inner", "isin", "ex", "add", "r", "din", "info", "mm", "all", "make", "nin", "bin", "h", "log", "io", "gin", "local", "on", "m", "from", "again", "In", "ic", "ins", "t", "en", "er", "IN", "at", "o", "by", "l", "lo", "get", "iter", "ai", "con", "n", " din", "ma", "cin", "rin", "input", "re", " IN", "pi", "reader", "inf", "oin", "ind", "thin"], "cbuf": ["cfuf", "rbbuf", "bcuff", "rboff", "abbbuf", "rbuf", "cduff", "cbdf", "cbbf", "cduf", "rbfg", "cdbuf", "CBf", "cbf", "cdoff", "sbbuf", "cfuff", "sbuff", "CBbuf", "nbbuf", "nbuff", "cduffy", "cbuff", "cff", "gbf", "sbuf", "rbather", "abbdf", "cfbf", "CBuffy", "CBbf", "gbbf", "nbfg", "rbuff", "CBuff", "sbather", "bcdf", "rbuffy", "gbuf", "bcfg", "cbuffy", "cbfg", "abbfg", "gbuff", "CBuf", "cbbuf", "cbather", "bcather", "rbdf", "cboff", "abbuf", "bcbuf", "nbuf", "bcoff", "bcuf"], "read": ["scan", "link", "is", "stream", "ready", "old", "reads", "pack", "buffer", "io", "data", "ly", "ead", "saw", "set", "range", "text", "miss", "iter", "count", "core", "end", "seek", "skip", "input", "readable", "trust", "index", "pe", "ind", "READ", "clear", "est", "ignore", "bind", "height", "fail", "ret", "current", "r", "start", "error", "sync", "report", "send", "poll", "depth", "mem", "Reader", "slow", "hold", "row", "ink", "raw", "view", "ip", "orig", "burst", "select", "find", "reach", "reading", "se", " Read", "ed", "value", "hello", "query", "rank", "k", "parse", "give", "record", "rate", "dev", "mix", "ank", "wait", "q", "chain", "load", "test", "length", "ke", "ai", "roll", "re", "print", "handle", "key", "it", "x", "add", "shift", "run", "connect", "allow", "feed", "log", "close", "default", "ext", "think", "check", "play", "pre", "write", "ok", "open", "get", "need", "reader", "n", "fill", "Read"], "totRead": ["tottWrit", "totalCheck", "totReader", "ltotRead", "toteAdd", "toteFind", "tcotDisplay", "atotaPrint", "tottNeed", "notaLoad", "trotRead", "totNeed", "trotFind", "retotReader", "ttottAdd", "tiatFill", "tOTFind", "totaBuild", "tokLoad", "notPrint", "totCheck", "tacotCheck", "taotConnect", "tfatWrite", "totPrint", "tobyPrint", "totAdd", "notalLoad", "tottAdd", "totaLoad", "totaFind", "tOTRead", "tiatVal", "notRead", "tiotBreak", "totaNeed", "notalNeed", "totBreak", "tiotVal", "ptotFind", "tottedRead", "trotWrite", "ttottNeed", "taotRead", "taotDisplay", "totalWrite", "totWrit", "totalLoad", "tobyCheck", "ptotWrite", " totRun", " totLength", "tiotFill", "totalFind", "tobyNeed", "ptOTFind", "retotRead", "tobyLoad", "tcotSend", "totaDisplay", "toteWrite", "tootRead", "tootConnect", "tiatSend", "ttotNeed", "retottPrint", "totalNeed", "tcotCheck", " toteRead", "letrotFind", "tootCheck", "atotaFill", "toiotRead", "totalLength", "letotSee", "totHave", " totalRead", "letrotSee", "taotCheck", "notalCheck", "ltotBuild", "tootDisplay", " totFind", "ptOTLoad", "tacotConnect", "tottReader", "tiotRead", " totalBuild", "ttotRead", "tootBreak", "tootVal", "tcotBreak", "tcotConnect", "tottWrite", "notaRead", "totaCheck", "totRun", "tiotHave", "atotHave", "ptOTWrite", "tiatBuild", "letotFind", " toteFind", "totSend", "toteNeed", "trotSee", "tokFind", "ptotLoad", "totalSee", "notCheck", "tcotVal", "totaRead", "toiotSend", "totVal", "totaPrint", "notReader", "totedHave", "tottedReader", "tiotSend", " toteRun", "tacotRead", "totFill", "tacotDisplay", "toteReader", "totaConnect", "totaLength", "tobyWrite", "tiatLoad", "toteLoad", " totBuild", "tiotReader", "tottRead", "atotaHave", "totDisplay", "toteRead", "totaAdd", " totWrite", "ptotRead", "ltotFill", "notalRead", "totaHave", "toticRead", "tokWrite", "tiatRead", "tottRun", "tOTLoad", "totConnect", "totSee", "tOTWrite", "ttotWrite", "toiotBreak", "notLoad", "totedPrint", "toteRun", "letrotRead", "letrotWrite", "tottedWrit", "totalBuild", "notWrite", "atotPrint", "tiotPrint", "totLoad", "toiotVal", "retottWrit", "toteFill", "toteBuild", "ltotaRead", "totLength", "letotRead", "toticWrite", "totalPrint", "totWrite", "atotaRead", "tiotWrit", "notalPrint", "retotPrint", "retottReader", "atotRead", "ltotaLoad", "ltotaFill", "totaReader", "tiatBreak", "tcotRead", " totalWrite", "totaSee", "ltotLoad", "totedRead", "notalWrite", "tootSend", "ltotaBuild", "totalRead", "toticFind", "notNeed", "atotFill", " totalLength", "notaReader", "totaFill", "tokRead", "toteLength", "totBuild", "tOTNeed", "tobyRead", "ptOTRead", "tottFind", "letotWrite", "tottPrint", "ttottRead", "notaWrite", "tfatReader", " toteWrite", "totaWrite", "retotWrit", "ttottWrite", "toticRun", "totedFill", "retottRead", "tfatRead", "totFind", "tfatLoad", "ttotAdd", "tottedPrint"], "out": ["auto", "obj", "up", "ch", "writer", "Out", "g", "ex", "v", "r", "w", "aos", "b", "sys", "log", "io", "conv", "c", "res", "we", "or", "t", "at", "o", "OU", "write", "output", "con", "os", "to", "oss", "end", "co", "s", "outs", "OUT", "net", "n", "ou"], "i": ["ix", "im", "php", "p", "is", "phi", "ui", "v", "hi", "info", "ski", "io", "ci", "multi", "di", "uri", "ei", "set", "ic", "ity", "qi", "ico", "I", "my", "sim", "ia", "index", "ind", "ii", "si", "r", "integer", "e", "iu", "point", "xi", "m", "iii", " I", "ki", "ice", "ip", "ri", "you", "this", "g", "mm", "\u0438", "cli", "me", "zi", "id", "c", "q", "y", "ims", "ij", "chain", "o", "ai", "ie", "print", "bi", "init", "oi", "any", "mi", "it", "x", "gi", "ji", "ini", "ami", "um", "b", "ion", "ti", "j", "iy", "status", "PI", "t", "us", "l", "client", "to", "s", "pi", "iq", "dr", "li"]}}
{"id1": "19335986", "id2": "4468255", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncurredFailure", " uncaughtception", " uncuredException", "uncurredException", "uncappedception", "uncaughtError", "uncappedError", "uncuredFailure", " uncaughtError", "uncuredception", " uncuredFailure", "uncuredError", "uncaughtFailure", " uncuredception", "uncurredception", "uncurredError", "uncappedFailure", " uncuredError", "uncaughtception", " uncaughtFailure", "uncuredException", "uncappedException"], "t": ["tf", "p", "task", "g", "w", "title", " th", "b", "h", " st", "f", "m", "c", "Thread", "y", "thread", "out", " T", "o", "d", "T", "l", " title", "to", " tid", "window", "n", " ti"], "e": ["xe", "ele", "ef", "p", "Error", "it", "E", "x", "ec", "ea", "ex", "a", "se", "r", "oe", "u", "ee", "event", "b", "de", "err", "i", "es", "error", "f", "m", "c", "eg", "el", "te", "eu", "en", "er", "eeee", "o", "d", "exc", "fe", "ae", "ie", "ce", "et", "ev", "ed", "pe"], "display": ["name", "link", "view", "server", "present", "this", "dis", "label", "b", "log", "layout", "session", "Display", "DIS", "scroll", "report", "body", "details", "console", "draw", "lay", "play", "browser", "d", "l", "table", "output", "position", "s", "render", "list", "screen", "show", "print", "window", "style"], "shell": ["view", "server", "system", "ssh", "ui", "sh", "scope", "board", "expression", "sb", "dis", "cli", "b", "buffer", "session", "layout", "log", "quit", "scroll", "sound", "library", "echo", "storage", "report", "nl", "hell", "command", "form", "body", "console", "or", "help", "environment", "browser", "ro", "l", "output", "tool", "tree", "screen", "print", "program", "window", "control", "handle", "Shell"], "message": ["mail", "msg", "response", "metadata", "view", "image", "system", "Message", "description", "memory", "subject", "content", "menu", "title", "management", "member", "detail", "label", "hello", "question", "log", "layout", "buffer", "session", "meter", "email", "manager", "one", "template", "translation", "error", "button", "application", "echo", "payment", "m", "comment", "result", "report", "say", "command", "trace", "body", "object", "console", "language", "summary", "essage", "module", "open", "position", "request", "show", "field", "document", "window"], "e1": ["ee1", "ee2", "e0", "e3", " e3", "E2", " e2", "E3", "ee0", "E0", "e2", "E1", "ee3", " e0"]}}
{"id1": "8132219", "id2": "804637", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": [" Copyfile", " copyStream", " CopyFiles", "CopyFile", "copyStream", "CopyStream", "CopyFiles", " CopyFile", " CopyStream", "copyFiles", "Copyfile", " copyFiles", " copyfile", "copyfile"], "inFile": [" inPath", "innEmail", "outFilename", "inEmail", "ninName", "ninFilename", "dinFile", " inRow", "dinRow", "inputTemplate", "inName", "innPath", "inFilename", "inputName", "inTemplate", "inputFilename", "dinPath", "ninTemplate", " inEmail", "inPath", "outName", "outTemplate", "innRow", "inputFile", "inRow", "dinEmail", "innFile", "ninFile"], "outFile": ["ouFILE", " outFILE", "outFilename", "outFormat", "outputFile", "outfile", "outputfile", "inFilename", "outputFilename", "outputFormat", "destFormat", "ouFile", "destfile", "destFILE", " outFormat", "destFile", "ouFilename", "inTable", "outputTable", "outTable", "outFILE", " outfile", "inFILE", "outputFILE", "ouTable"], "in": ["inn", "inc", "up", "init", "is", "it", "ain", "sin", "inner", "isin", "old", "ini", "din", "info", "irm", "source", "ze", "ir", "bin", "i", "gin", "on", "id", "from", "In", "el", "ic", "ins", " input", "en", "IN", "o", "ai", "s", " din", "cin", "rin", "input", "inf", "ind"], "out": ["name", "p", "it", "Out", "g", "ex", "v", "w", "aos", "e", "file", "b", "all", "io", "one", "gt", "c", "res", "ot", "t", "en", "at", "o", "ne", "by", "output", "client", "os", "to", "co", "outs", "OUT", "net", "can", "n", "ou"], "inChannel": ["isinSlot", "innerChannel", "insideHandler", "isinCategory", "newPanel", "outStream", " inConnection", "innerchannel", "cinHandler", "cinComponent", "cinButton", "sinStream", "ginCategory", "innCase", "inBlock", "newCase", "innCategory", "inColumn", "insideComponent", "insideChannel", "vinChannel", "newChannel", "sinBlock", "outBlock", "vinPanel", "ginChannel", "vinCase", "isinCase", "innerChan", "insideButton", "innerConnection", "inSlot", "outchannel", "inStream", "outChan", "inCase", "sinSlot", "isinChannel", "inchannel", "sinCase", " inComponent", "inCategory", "cinChannel", "inConnection", " inHandler", "sinColumn", "innSlot", "outColumn", "sinChannel", "ginPanel", "innChannel", "cinStream", "vinCategory", " inChan", "inComponent", "outConnection", " inButton", "newCategory", "inHandler", "inPanel", "ginCase", "sinCategory", "inChan", "inButton", " inchannel", "cinBlock", "cinColumn"], "outChannel": ["inPassword", " outChan", "outCh", "oClient", "outStream", "oChannel", "OutChan", "OutChannel", "outClient", " outCh", " outClient", " outConnection", "exBlock", "outputChan", "outputCh", "oChan", "outBlock", "nStream", "inClient", "outPassword", "outputChannel", "outchannel", " outchannel", "outChan", "inStream", "OutCh", "inchannel", "outputConnection", "exChan", "outChain", "exChain", "nchannel", "OutConnection", "outConnection", "nChan", "oPassword", "exChannel", " outStream", "inChan", "nChannel", " outChain", " outPassword", " outBlock"]}}
{"id1": "22868825", "id2": "7499186", "code1": "    String sendRequest(String[] getVars, String[] postVars, Object[] fileVars, boolean getSessionKey) throws IOException {\n        String uri = wikiBaseURI;\n        if (getVars != null) for (int i = 0; i + 1 < getVars.length; i += 2) uri += (i == 0 ? '?' : '&') + urlEncode(getVars[i]) + '=' + urlEncode(getVars[i + 1]);\n        URL url = new URL(uri);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        if (!getSessionKey) {\n            String cookie = \"\";\n            for (String key : cookies.keySet()) cookie += (cookie.length() == 0 ? \"\" : \"; \") + key + \"=\" + cookies.get(key);\n            conn.setRequestProperty(\"Cookie\", cookie);\n        }\n        if (fileVars != null) {\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.connect();\n            PrintStream ps = new PrintStream(conn.getOutputStream());\n            for (int i = 0; fileVars != null && i + 2 < fileVars.length; i += 3) {\n                ps.print(\"--\" + boundary + \"\\r\\n\");\n                postFile(ps, conn, (String) fileVars[i], (String) fileVars[i + 1], (byte[]) fileVars[i + 2]);\n            }\n            for (int i = 0; postVars != null && i + 1 < postVars.length; i += 2) ps.print(\"--\" + boundary + \"\\r\\n\" + \"Content-Disposition: \" + \"form-data; name=\\\"\" + postVars[i] + \"\\\"\\r\\n\\r\\n\" + postVars[i + 1] + \"\\r\\n\");\n            ps.println(\"--\" + boundary + \"--\");\n            ps.close();\n        } else if (postVars != null) {\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.connect();\n            PrintStream ps = new PrintStream(conn.getOutputStream());\n            for (int i = 0; postVars != null && i + 1 < postVars.length; i += 2) ps.print((i == 0 ? \"\" : \"&\") + urlEncode(postVars[i]) + \"=\" + urlEncode(postVars[i + 1]));\n            ps.close();\n        }\n        int httpCode = conn.getResponseCode();\n        if (httpCode != 200) throw new IOException(\"HTTP code: \" + httpCode);\n        if (getSessionKey) getCookies(conn.getHeaderFields().get(\"Set-Cookie\"));\n        InputStream in = conn.getInputStream();\n        response = \"\";\n        byte[] buffer = new byte[1 << 16];\n        for (; ; ) {\n            int len = in.read(buffer);\n            if (len < 0) break;\n            response += new String(buffer, 0, len);\n        }\n        in.close();\n        return response;\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"sendRequest": ["formrequest", "sendrequest", "formRequest", " sendResponse", "formResponse", "submitPost", "submitResponse", " sendrequest", "formPost", "submitrequest", "submitRequest", " sendPost", "sendPost", "sendResponse"], "getVars": ["gettingVsrs", "getAttolder", "gotVals", "fileVARS", "getPals", "getPARS", "evalVCart", "gotVARS", "execVariys", "getChars", "getVaart", "gettingVARS", "gettingVsals", "execVARS", "getvars", "evalVolder", "gotVariers", "getVrs", "getVarials", "getVarp", "gotVariARS", "getVsals", "evalVColder", "gettingVals", "evalVCarp", "getVariys", "getVar", "getHar", "getVColder", "evalVCars", "fileHar", "getHARS", "getChar", "getVolder", "getVys", "getVaolder", "getVart", "getAttars", "execVys", "fileHrs", "gotVers", "getChARS", "getvals", "gettingVsars", "getAttart", "execVariarts", "evalVars", "getVsrs", "getvARS", "getVARS", "gotVars", "getHars", "fileVrs", "getVaarp", "gettingVars", "getVariarts", "evalVarp", "getvar", "gettingVsARS", "getVers", "getvrs", "getAttarp", "fileVar", "getVsers", "getVals", "getHarts", "execVariARS", "getVsars", "fileHARS", "getVarts", "getPars", "gettingVrs", "getHrs", "execVars", "evalVart", "getVCars", "gotVarials", "getHys", "getVariers", "getPers", "getVCart", "getVCarp", "getVsARS", "execVarts", "getVaars", "getChrs", "gotVariars", "fileHars", "execVariars", "getVariARS", "getVariars"], "postVars": ["getVsols", "postVsors", "putVants", "postNavals", "putVsats", "postVaols", "postNavols", "postVsats", " postVys", "postVats", "postVsants", "putVals", "getVols", "postVarials", "postVsols", "postJables", "putVors", "putInvors", "putVsars", "postVariars", "postInvals", " postvars", "getVsals", "putInvars", "putInvals", "postVants", " postvables", "putVats", "postVARS", "postJrs", "postVaaults", "postVaars", "getVaults", " postVrs", " postvys", "postVaults", "putVsARS", "putVsals", "postCARS", "postVsys", "postEvARS", "postInvors", "postCats", "postVals", "postVariants", "postVors", "postJars", "postVsars", "postEvats", "postVables", "postVsaults", "postEvals", "postVariors", "postVsables", "postvables", "postvars", "postVsals", "postInvars", " postVables", "getVsaults", "postVsARS", "putVars", "postVaals", "getVals", "putInvants", "postvrs", "putVARS", " postvrs", "getVsars", "postCals", "postCars", "postVsrs", "postvys", "postNavars", "postJys", "postInvants", "postEvars", "postVrs", "postNavaults", "postVys", "postVols"], "fileVars": ["fileBARS", "fileMarp", "fileVarp", "fileDevals", "ruleVals", "fileVARS", "fileVsavers", "fileJARS", " fileVals", "fileVsARS", "fileVels", "fileVavers", " fileVsarp", "fileVoters", "fileAVars", "filePolder", "fileVolarp", "fileVSals", "fileBaults", "fileVariVar", "fileBars", " fileVolder", "filePVar", "fileMar", "fileVolals", "fileDevar", "postVarts", "filevrs", "fileVariars", "postVsar", "fileInvar", " fileVels", "postVariars", "fileDevarp", "fileBoters", "filevPARS", " fileVaults", " fileVarp", "fileVsars", "postVARS", "fileVsrs", " fileVoters", " fileVsals", "filevar", "fileVsar", "filevPavers", "fileAVARS", "fileVolVar", " fileVsars", "fileDevars", "fileVariarp", "fileInvals", "ruleVars", "filevPars", "postVariarts", " filePals", "fileVsarp", " filePars", "fileVsels", "fileVarts", "fileVrs", "postVals", " fileVar", "filevars", "ruleVolals", "fileVolder", "filePARS", "fileVSars", "fileMars", "fileVarials", "fileVsals", "fileParp", "fileVariavers", " filePARS", "fileJars", "postVsars", "fileVariarts", "fileVolars", "ruleVarp", "fileVaults", "fileVSels", "postVariavers", "postVsals", "filePals", "fileVVar", "fileVar", "ruleVVar", "ruleVolVar", " fileVsar", "fileVariARS", "postVar", "fileMals", "fileJals", "ruleVolarp", "fileAVoters", "filePars", "filevParts", "postVavers", "fileVsarts", "postVsrs", "fileVSARS", "postVariARS", "fileInvars", "ruleVolars", "fileInvrs", "filevals", "fileVals", "fileVsolder", "postVrs", "fileAVaults", " fileVARS", " filePolder", "fileJolder"], "getSessionKey": ["getsessionId", "getESSIONId", "getsessionName", "gettingESSIONId", " getsessionId", " getsessionKey", "getESSIONkey", " getSessionId", " getSessionkey", " getsessionKeys", "gettingSessionId", " getSessionKeys", "gettingSessionKey", "getSessionName", "gettingESSIONkey", "getsessionkey", "getESSIONName", "gettingESSIONName", "gettingESSIONKey", "getSessionKeys", "getSessionId", "gettingSessionName", "getsessionKey", "getsessionKeys", "getESSIONKey", "getSessionkey", "gettingSessionkey", " getsessionkey"], "uri": ["link", "unit", "html", "origin", "ri", "domain", "path", "phi", "gi", "ui", "ugi", "wiki", "description", "URI", "subject", "href", "hi", "target", "title", "doi", "file", "source", "query", "location", "filename", "folder", "resource", "base", "general", "http", "du", "prefix", "range", "qi", "direction", "browser", "address", "api", "nu", "us", "iri", "dir", "ur", "term", "connection", "pi", "home", "directory", "uni"], "i": ["ix", "im", "p", "is", "phi", "ui", "v", "hi", "info", "io", "ci", "multi", "di", "f", "ic", "set", "ei", "qi", "I", "list", "sim", "index", "ii", "ind", "si", "menu", "e", "iu", "h", "on", "xi", "m", "slice", "ki", "lo", "ma", "ip", "exp", "ri", "g", "u", "cli", "\u0438", "err", "me", "zi", "id", "batch", "c", "q", "y", "ree", "ims", "ij", "chain", "loop", "o", "ai", "bi", "go", "init", "oi", "mi", "it", "x", "gi", "ji", "ini", "ami", "um", "ti", "j", "iy", "status", "ta", "t", "us", "l", "pi", "li"], "url": ["Url", "link", "hl", "org", "char", "atl", "r", "job", "sb", "b", "log", "gl", "ssl", "bel", "ld", "dl", "il", "abs", "nl", "http", "sl", "el", "str", "ll", "t", "api", "browser", "https", "loc", "au", "un", "l", "open", "arl", "www", "URL", "net", "att", "ls", "ur", "ul"], "conn": ["link", "obj", "cs", "ch", "cert", "init", "ws", "resp", "p", "socket", "addr", "org", "cb", "comm", "fail", "act", "auth", "enc", "forge", "nt", "typ", "ait", "ns", "connect", "cmd", "pg", "tn", "err", "sys", "fin", "ssl", "close", "secure", "j", "conv", "call", "txt", "res", "pas", "reg", "http", "cfg", "conf", "nc", "cur", "canon", "en", "https", "loc", "jp", "pkg", "ctx", "client", "open", "con", "req", "dt", "connection", "exec", "ann", "wp", "js", "Conn", "sp", "ls", "ct", "cp", "cn"], "cookie": ["timeout", "cache", "stay", "magic", "none", "header", "cert", "cb", "wine", "cel", "tc", "sample", "copy", "cue", "menu", "temp", "cmd", "ookie", "json", "gc", "query", "kee", "hello", "label", "value", "ck", "reason", "tmp", "KEY", "password", "comment", "c", "qq", "custom", "cell", "good", "cook", "cu", "coin", "browser", "cy", "binary", "chain", "jar", "bo", "csv", "country", "no", "cm", "code", "client", "term", "word", "ca", "co", "ie", "ce", "pretty", "token", "note", "window", "cn"], "key": ["wk", "child", "cert", "any", "x", "char", "ex", "ox", "member", "ow", "mac", "value", "label", "file", "k", "keys", "property", "me", "val", "j", "KEY", "hop", "box", "id", "Key", "type", "cell", "te", "y", "tag", "set", "prefix", "str", "code", "item", "cy", "chain", "choice", "phrase", "by", "table", "ke", "ice", "row", "et", "ie", "ce", "my", "pair", "col", "pe"], "ps": ["cs", "ips", "p", "ports", "Ps", "pos", "ss", "sts", "pers", "pt", "ros", "fps", "pp", "posts", "als", "css", "bs", "rs", "stats", "gets", "ups", "aps", "ys", "pps", "_", "mp", "its", "vs", "ress", "proc", "pd", "fp", "pl", "ts", "ds", "gs", "amps", "fs", "rep", "pas", "ins", "ms", "out", "pr", "eps", "dial", "js", "checks", "sp", "ks", "ls", "pres", "ws", "pse", "PS", "ats", "ns", "po", "ops", "plays", "hs", "cp"], "name": ["NAME", "part", "description", "add", "title", "label", "value", "alt", "filename", "val", "id", "type", "form", "range", "Name", "class", "address", " filename", "component", "dir", "position", "field", "ident", "extra", "names", "n", "format"]}}
{"id1": "21010945", "id2": "4272289", "code1": "    private static List runITQLQuery(String itqlQuery) throws Exception {\n        String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\");\n        String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery;\n        logger.debug(\"url for risearch query: \" + url);\n        URL urlObject = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) urlObject.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        logger.debug(\"response code: \" + con.getResponseCode());\n        if (con.getResponseCode() != 200 && con.getResponseCode() != 302) {\n            throw new FedoraAccessException(\"Could not access the risearch service at url: \" + url);\n        }\n        ArrayList arrayList = new ArrayList();\n        String inputLine;\n        int counter = 0;\n        while ((inputLine = br.readLine()) != null) {\n            logger.debug(\"reading line:\" + inputLine);\n            if (inputLine.indexOf(\"<html>\") >= 0) {\n                logger.error(\"problem quering the relationship\");\n                throw new Exception(\"Problem querying relationships; probably a bad ITQL query:\" + itqlQuery);\n            }\n            if (counter >= 1 && inputLine.indexOf(\"/\") >= 0 && inputLine.trim().length() > 0) {\n                logger.debug(\"adding line:\" + inputLine);\n                inputLine = inputLine.substring(inputLine.indexOf(\"/\") + 1);\n                arrayList.add(inputLine);\n                logger.debug(\"found relationship to item: \" + inputLine);\n            }\n            counter++;\n        }\n        br.close();\n        logger.debug(\"num relationships found: \" + arrayList.size());\n        return arrayList;\n    }\n", "code2": "    public static int[] sortstring(int[] a1) {\n        int temp;\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        return a1;\n    }\n", "label": 0, "substitutes": {"runITQLQuery": ["runITqlStatement", "runITQStatement", "runITSQLCommand", "runITQquery", "runITSQLQuery", "runITqlCommand", "runITSQLquery", "runATQLquery", "runATSQLCommand", "runITQQuery", "runITQLCommand", "runITQLStatement", "runATQLQuery", "runITSQLStatement", "runATSQLquery", "runATQLStatement", "runITqlquery", "runITQLquery", "runITqlQuery", "runITQCommand", "runATSQLQuery", "runATQLCommand", "runATSQLStatement"], "itqlQuery": ["itqlString", "itquString", "itQLquery", "itullString", "itquStatement", "itSQLquery", "itqlquery", "ITsqlQuery", "ITsqlStatement", "pitQLStatement", "itsqlStatement", "itsqlQuery", "itsqlquery", "itQLStatement", "itSQLQuery", "itullQuery", "ITqlStatement", "itQLString", "ITsqlString", "ITqlquery", "ITqlQuery", "itQLQuery", "pitQLString", "itquQuery", "itququery", "pitqlStatement", "pitQLQuery", "pitQLquery", "itqlStatement", "pitqlString", "ITqlString", "itullquery", "pitqlquery", "itSQLStatement", "ITsqlquery", "pitqlQuery", "itsqlString"], "escapedItqlQuery": ["escapedItQLRequest", "escapedItQLStatement", "escapedITQLQuery", "escapedItqlRequest", "escapedItsqlquery", "escapedItsqlString", "escapedItqQuery", "escapedItQLquery", "escapedItQLQuery", "escapedItellQuery", "escapedItellquery", "escapedItqquery", "escapedItsqlStatement", "escapedITqlString", "escapedITQLquery", "escapedITqlQuery", "escapedITQLRequest", "escapedItqlString", "escapedItellRequest", "escapedItsqlQuery", "escapedITQLString", "escapedITQLStatement", "escapedItqlquery", "escapedITqlquery", "escapedItellString", "escapedItsqlRequest", "escapedITqlRequest", "escapedItQLString", "escapedItqStatement", "escapedITqlStatement", "escapedItqlStatement"], "url": ["mail", "Url", "link", "hl", "util", "server", "external", "path", "pl", "len", "full", "string", "lim", "org", "this", "u", "mount", "location", "ssl", "k", "resource", "host", "build", "email", "dl", "base", "uri", "web", "http", "nl", "el", "sl", "impl", "ll", "ref", "https", "loc", "rel", "un", "l", "term", "ob", "ud", "lr", "www", "URL", "ml", "ol", "ls", "ur", "window", "ul", "addr"], "urlObject": ["urlConnection", " urlobject", "Urlobject", "belObject", "nlConnection", "urlOb", "urlObj", "nlObject", "urlOB", "UrlOb", "urlobject", "UrlOB", "nlObj", "UrlObj", "nlOB", "belObj", " urlOb", "belobject", " urlConnection", "belOb", "UrlConnection", "UrlObject", " urlOB", " urlObj"], "con": ["acon", "cons", "conn", "ln", "go", "bc", "soc", "ocon", "ain", "comm", "const", "ver", "sin", "ec", "fn", "connect", "pen", "bon", "apache", "commun", "syn", "cos", "cone", "ran", "conv", "win", "cal", "fc", "c", " Con", "cont", "conf", "com", "nc", "ctrl", "CON", "cur", "un", "cm", "cf", "open", "Con", "rc", "connection", "dial", "co", "fac", "Conn", "mc", "can", "cp", "cn"], "br": ["bn", "ch", "tr", "bc", "ver", "BR", "bs", "hr", "bl", "r", "bh", "Br", "wr", "b", "bd", "bridge", "buf", "bsp", "rain", "ber", "bp", "res", "arr", "ctr", "pre", "er", "pr", "shr", "bt", "bro", "mr", "cr", "lr", "rb", "gr", "ur", "fr", "ob", "dr", "reader", "n", "kr"], "arrayList": ["ArraySet", "arrayLine", " arraySet", "inputList", "arrayArray", " arrayLine", "instanceList", "inputCollection", "instancelist", "collectionSet", " arrayCollection", "collectionCollection", "Arraylist", " arrayArray", " arraylist", "ArrayArray", "collectionList", "inputSet", "instanceSet", "arraylist", "instanceArray", "arraySet", "collectionLine", "arrayCollection"], "inputLine": ["imageline", "readline", "feedline", " Inputline", "jsonRow", " InputFile", "listLine", " inputByte", "InputLINE", "singleRow", " inputLINE", "imageLINE", "fieldLine", "helloLINE", " inputPath", "helloByte", "inputByte", "inPath", "inputPath", "InputList", "singleLINE", "fieldFile", "outputLINE", "baseRow", "imageByte", "virtualL", "focusLine", "virtualLINE", "feedBlock", "inputList", "Inputline", "imageLine", "outputLine", "focusFrom", "baseLine", "readLine", " inputList", "jsonline", "lengthPoint", "feedLINE", "feedLine", "listRow", " InputLINE", "inLine", "helloline", "InputLine", "inputBlock", " inputPoint", "inline", "fieldLINE", "outputBlock", "outputL", "inputFrom", "inFrom", "singleLine", "jsonLINE", " InputLine", "fieldline", "inputL", "inputRow", "dataLINE", "lengthLINE", "inputline", "InputRow", "dataLine", " inputline", "inputPoint", "readLINE", " inputFile", "feedPoint", "singleline", "focusPath", "baseLINE", " inputFrom", "readRow", "lengthLine", "focusline", "listList", "helloLine", " inputRow", "inputLINE", "feedL", "listline", "dataline", "jsonLine", "virtualBlock", "inputFile", "virtualLine", "lengthline", "baseline"], "counter": ["sequence", "ter", "amount", "system", "Counter", "continue", "order", "inner", "loader", "message", "finger", "entry", "outer", "clock", "cookie", "currency", "number", "second", "controller", "nr", "container", "walker", "here", "meter", "conv", "taker", "processor", "cover", "book", "batch", "timer", "vector", "ctr", "random", "card", "code", "finder", "chain", "condition", "loop", "phrase", "ounter", "total", "count", "creator", "TER", "index"]}}
{"id1": "3266833", "id2": "5707205", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n", "label": 0, "substitutes": {"is": ["bits", "ois", "init", "any", "iss", "bs", "isin", "info", "isa", "sis", "iso", "Is", "isf", "i", "sys", "ris", "serv", "IS", "fs", "bis", "its", "in", "ios", "isl", "parts", "has", "us", "ists", "ais", "iris", "get", "was", "os", "s", "isc", "isi", "as", "lis"], "name": ["sequence", "url", "path", "NAME", "key", "image", "string", "parent", "version", "part", "this", "order", "description", "current", "info", "title", "value", "number", "file", "location", "named", "source", "filename", "alias", "admin", "i", "local", "data", "template", "default", "id", "base", "type", "search", "body", "prefix", "in", "normal", "Name", "code", "class", "create", "length", "get", "ame", "word", "family", "position", "term", "null", "self", "size", "names", "n", "handle", "format"], "contentType": ["contentTypes", "ContentLength", "contentQuery", "messagetype", "messageControl", " contentLength", "contentControl", "fileTypes", "mediaUnit", "Contenttype", "messageQuery", "mediaQuery", " contentUnit", "contenttype", "contentUnit", "messageUnit", "fileQuery", "ContentTypes", " contentControl", "contentLength", "mediatype", "messageLength", "mediaLength", "fileType", "messageType", "messageTypes", "mediaControl", "ContentType", "mediaTypes", "fileLength", " contenttype", "mediaType", " contentTypes"], "index": ["access", "sequence", "timeout", "offset", "path", "key", "image", "axis", "action", "x", "find", "height", "si", "info", "content", "max", "dx", "lock", "value", "number", "success", "pos", "start", "sort", "update", "i", "error", "id", "num", "batch", "type", "instance", "prefix", "slice", "depth", "code", "address", "create", "test", "exclusive", "length", "open", "fee", "position", "count", "n", "row", "list", "Index", "size", "level", "ind"], "extension": ["protension", "extitude", "protend", "xtend", "contend", "xtention", "xtension", "contention", "protention", "protitude", "contitude", "xtitude", "contension", "extend", "extention"], "isImage": [" isFile", "hasImage", " isItemImage", "isaPicture", "wasMedia", "hasimage", "isoItemImage", "isaimage", "isimage", "needsimage", "isPicture", "wasImage", "areItemImage", "isoMedia", "wasimage", "ISPhoto", "wasFile", " isMedia", "isoFile", "needsPhoto", "hasMedia", "areMedia", "isMedia", "isaImage", "isaPhoto", "isPhoto", "isItemImage", "ISPicture", "isFile", "needsPicture", "areFile", "areImage", "needsImage", "ISimage", "needsMedia", "hasFile", "needsFile", "isoImage", "ISImage"], "isAux": ["wasAxx", " isCAaux", " isAx", "wasAAUX", "isAaux", "isinAUX", "isSAmp", "isNAux", "isOAult", " isAaux", "isAcUX", "isAUX", "isAx", "isinPaUX", "isAndx", "isNAmp", "isCAaux", "isAAxx", "isPaux", "isinPaaux", "isiOAuxe", "isSAUX", "isiAuxe", "isAAux", "isaaux", "isCAiox", "isSAaux", "isPaaux", " isCAx", "isAcux", "isOAaux", " isCAUX", "isAxx", "isAAult", "wasAult", "isNAaux", "isiOAaux", "isOAux", "isAcx", "isAndUX", "isOAxx", "isiAaux", "wasAAxx", "isaiox", "isOAUX", "isinPaux", "isiOAiox", "isOAuxe", "isinAaux", "isAuxe", "isinAux", "isPaUX", "isiAux", "isPamp", "isiOAux", "isAmp", "isiAiox", " isCAux", "isauxe", "wasAAux", " isAUX", "isAult", "isAndux", "isaux", "wasAUX", "isSAux", "isOAiox", "isinPamp", "isCAUX", "isAndaux", "wasAAult", "isinAmp", "isCAx", "isNAUX", "isAAUX", "wasAux", "isAcaux", "isCAuxe", "isCAux", "isAiox"], "out": ["port", "auto", "timeout", "cache", "up", "conn", "go", "p", "vol", "it", " Out", "Out", "pool", "order", "this", "v", "ex", "nt", "w", "aos", "outer", "lock", "ent", "gc", "b", "pos", "sys", "log", "cos", "all", "ion", "io", "tmp", "conv", " OUT", "user", " output", "result", "batch", "res", "sum", "we", "in", "t", "chain", "at", "o", "by", "OU", "output", "con", "null", "boot", "to", "oss", "os", "co", "list", "outs", "OUT", "net", "n", "cn"], "bufferedImage": ["bufferredImage", "renderedImages", "bufferredimage", "bufferingVideo", "buffererImages", "bufferedImages", "bufferedVideo", "bufferredVideo", "bufferingimage", "bufferingImage", "renderedImage", "renderedimage", "buffererimage", "renderingImages", "renderingVideo", "bufferingImages", "bufferedimage", "buffererImage", "renderedVideo", "renderingimage", "bufferredImages", "buffererVideo", "renderingImage"], "inputStream": ["Inputstream", "InputSteam", "outputView", "outputSteam", "inputSteam", "InputView", "outputstream", "inputstream", "currentstream", "currentView", "InputStream", "currentStream", "inputView", "currentSteam", "outputStream"]}}
{"id1": "324679", "id2": "8665321", "code1": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"import_hints": [" import_cints", " import_harks", " import_prins", " import_hins", " import_Hints", " import_prints", " import_Hinters", " import_prarks", " import_printers", " import_Hins", " import_hinters", " import_cins", " import_Harks", " import_cinters", " import_carks"], "filename": ["fp", "name", "println", "path", "ln", "journal", "File", "image", "nm", "string", "png", "jpg", "fn", "original", "ename", "subject", "without", "title", "doi", "json", "nil", "file", "source", "location", "SourceFile", "fil", "finals", "til", "FILE", "there", "files", "kl", "txt", "kj", "stem", "bf", "LCS", "Filename", "output", "ame", "family", "latest", "wikipedia", "figure", "pdf", "directory", "username"], "pieceId": ["componentById", "ieceID", "pieceIdent", "peLog", "pairLike", "leagueNumber", "leagueIdent", " pieceLog", "ieceid", "componentId", "ieceLike", "pixelId", " pieceID", "caseLike", "pieceById", " pieceNumber", "leagueId", "peInt", "pieceLike", "pieceID", "ieceLog", "componentid", "pairInt", "caseById", "blockID", "peId", "peID", "iecePath", "blockById", "pieceLog", "pairById", "piecePath", " pieceIdent", "caseId", "ieceInt", "leagueName", "ieceById", "ieceIdent", "pieceid", "pixelPath", "pixelName", "caseInt", "pairId", " pieceName", "ieceName", " pieceInt", "pixelid", "pieceInt", "ieceNumber", "blockId", "ieceId", " pieceid", "pieceNumber", "componentID", "pieceName", "blockid", " piecePath"], "i": ["ni", "ix", "im", "bi", "go", "ip", "oi", "init", "p", "mi", "it", "x", "gi", "ui", "si", "v", "g", "ini", "r", "info", "index", "u", "cli", "ind", "pos", "b", "k", "ti", "ci", "io", "ori", "uli", "j", "multi", "di", "me", "xi", "m", "c", "uu", "y", "ic", "or", "sql", "qi", "t", "us", "ki", "o", "l", "iter", "ai", "I", "ie", "pi", "sim", "n", "ii", "li"], "col": ["pc", "ch", "path", "act", "char", "chron", "Col", "cel", "fn", "cmd", "file", "pos", "mon", "div", "COL", "prop", "city", "rem", "coord", "box", "win", "cal", "fc", "num", "c", "coll", "cell", "cond", "color", "ctrl", "cur", "lc", "loc", "dc", "ctx", "dir", "con", "pt", "co", "rot", "cul", "cat", "ct", "column", "cp", "cor"], "row": ["ue", "race", "ri", "tr", "our", "rs", "ror", "ox", "r", "ow", "rid", "square", "week", "pos", "nr", "round", "rank", "rown", "rog", "user", "box", "ry", "root", "num", "month", "res", "Row", "rows", "cell", "form", "frame", "range", "floor", "post", "loc", "ro", "rew", "length", "line", "family", "roll", "rc", "co", "re", "dd", "ows", "rot", "hour", "index", "cor"], "rotation": ["lato", "orientration", "rotate", "polutation", "lating", "portational", "portating", "portato", "rotration", "lenate", "poluation", "orientate", "polator", "orientation", "validation", "validate", "polating", "polational", "rotato", "rotational", "rotutation", "polation", "lenator", "validator", "orientuation", "lenutation", "portation", "polate", "rotator", "polato", " rotration", " rotuation", "lational", "rotating", "polration", "rotuation", "lation", "validutation", " rotate", "lenation"], "number": ["volume", "name", "counter", "portion", "amount", "span", "initial", "version", "string", "news", "NUM", "message", "integer", "production", "Number", "nb", "database", "file", "nr", "network", "maximum", "padding", "num", "umber", "result", "comment", "note", "type", "division", "population", "nine", "random", "numbered", "collection", "language", "nu", "no", "significant", "duration", "length", "total", "BER", "count", "block", "na", "size", "document", "directory", "n"], "temppiece": ["temppixel", "temppayer", "stemmpane", " temppyle", "tempperiece", " temppawn", "temppyle", "tmpprice", "tmptrice", "tempppiece", "temptpiece", "temapprice", "tempperipe", "temptrice", " temploly", " temptoly", "temptoly", "templiece", "temppsane", " templiece", " temppipe", "temappiece", "temploly", " temptane", "temppsayer", "tmptane", "temppane", "temppsiece", " temptiece", "stemppixel", "tmptiece", " temptpiece", " tempppiece", " temppayer", "tempperpiece", "temmpawn", "temmppiece", " temppane", "tempprice", "temappane", "temmpoly", "temptiece", "tmptyle", "stemmpixel", "temmpane", "stemmpiece", "temppawn", "temppsixel", "temmpiece", "temppspiece", "templyle", "stemmpyle", " temppoly", "tempperyle", "temptyle", " temptayer", " temptyle", "stemppiece", "temappyle", "tmppiece", "temppsawn", "templpiece", " templpiece", "temppsyle", "tmppyle", "temmpayer", "temptane", "templawn", "temptipe", "templipe", "temmpyle", "temmprice", "stemppyle", "temmpixel", " templawn", "stemppane", "tmppane", "temppipe", "temppsoly", " temptipe", "temppoly", "temptayer", "temptixel"], "lineread": [" linewrite", "ineload", "lexbuild", "linkreq", "LINEinput", "dayreadable", "linereadable", "linkreader", "linread", "LINEwrite", " linepass", "lexplay", "linefind", " lininput", "linreader", " linread", "rangeread", " linRead", " linedata", "lineload", "LINERead", "lindata", "lanereader", "cellload", "linestr", "cellread", " lineload", "linetext", "linRead", "lanereadable", "byteready", "cellreader", "linebuild", "lineRead", "linpass", "inetext", "laneread", "dayfind", "LINEread", " linwrite", "linereader", "dayread", "inereader", " linereader", "linreadable", "LINEpass", "ineread", "linreq", "linedata", "rangeplay", "linkreadable", "dayready", " linestr", " lineinput", "lanereq", "lexread", "linereq", "linfind", "celltext", "lineinput", " linebuild", "lexstr", "rangestr", "lineplay", "byteread", "LINEdata", "bytereadable", "linewrite", "linready", " lineRead", " lineplay", "bytefind", "linepass", "lineready", " linetext", "rangebuild", "linkread"], "tok": ["attook", "ttol", "wtyk", " tik", "vtawk", "qtoke", "ttawk", "wtok", "toke", "ttunc", "ttoc", " tak", "ttyk", " tTok", "vtak", "detok", "entop", "wtawk", "attople", "etik", "rtarr", "tak", "wtook", " tol", "pyk", " targ", "untTok", "attok", "vtook", "wtproc", " tk", "rtak", "vtproc", "ttok", "top", "wtk", " toc", "qtok", "tarr", "wtoc", "tople", "tproc", "attot", "qtTok", " tawk", "tk", "etok", " tople", "entawk", "untoke", "toc", " tarr", "tot", "tack", "entarr", "ttik", "entok", "pok", "untoc", "wtarg", " toke", "vtop", "tyk", "tik", " tunc", "detople", "wtack", "qtoc", " took", "vtack", " tproc", "etarg", " top", "detot", "ttarg", "detook", "ttk", "tTok", "wtol", "entk", "tol", " tot", "vtok", "pk", "tunc", "etunc", "targ", "rtok", "rtk", "tawk", "took", "untok", "entak", " tack", "pawk"], "entree": ["entropy", "montrie", "ntrape", "montabe", "antrie", "centree", "entrape", "sentour", "Entrees", "Entrie", "windool", "ntrie", "Entabe", "entrie", "antree", "centropy", "ntree", "entry", "sentropy", "sentrain", "Entee", "ptree", "centrain", "entrain", " entee", "ptrie", "intropy", "montrain", "sentree", "montee", "nthe", " entrie", "montrees", "entour", "intree", "entee", "entool", "montree", "ptrain", "ntee", "Entrain", "entabe", "antry", "entrees", " entrape", "windee", " entabe", "windrape", "ntool", " enthe", "Entree", " entool", "centour", "enthe", "windree", "intrain", " entry", "ptrees", "intour", "anthe", "ntry"], "byurl": ["bysl", " bydefault", "BYsl", " BYURL", "usedefault", "BYUrl", " BYUrl", "BYURL", " byURL", "useurl", " bysl", "byUrl", " byUrl", "BYdefault", "useUrl", " BYurl", " BYsl", "bydefault", "BYurl", "byURL", "useURL"], "url": ["mail", "Url", "link", "hl", "cert", "char", "r", "job", "download", "mount", "file", "log", "gl", "ssl", "resource", "io", "bel", "deb", "dl", "uri", "web", "nl", "http", "sl", "el", "rl", "ll", "browser", "ref", "rel", "l", "cf", "open", "URL", "re", "gif", "net", "ls", "ur", "ul"], "in": ["inn", "inc", "is", "it", "sin", "inner", "stream", "v", "ini", "din", "source", "bin", "io", "serv", "gin", "win", "f", "from", "In", "body", "ins", "t", "en", "out", "IN", "l", "get", "ma", "n", " din", "input", "rin", "cin", "mc", "reader", "inf"]}}
{"id1": "20275821", "id2": "23531898", "code1": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 0, "substitutes": {"getAttribute": [" getAtt", "getDirectory", "Getattribute", "readattribute", "readAttributes", " getDirectory", "fileAttribute", "getattribute", "GetAttribute", "getAttributes", "readAttribute", "readAtt", " getattribute", "GetDirectory", "fileAtt", " getAttributes", "getAtt", "fileAttributes", "readDirectory", "fileattribute", "GetAtt"], "url": ["Url", "link", "name", "server", "pl", "path", "conn", "string", "char", "r", "job", "u", "cl", "file", "b", "log", "gl", "ssl", "host", "resource", "conv", "user", "call", "dl", "abs", "base", "uri", "il", "web", "http", "el", "sl", "nl", "page", "q", "sql", "rl", "str", "ll", "address", "ref", "https", "loc", "l", "null", "connection", "URL", "document", "ls", "ur", "ul"], "con": ["free", "pc", "cons", "conn", "ln", "go", "bc", "soc", "ver", "ain", "comm", "const", "cc", "bean", "clean", "don", "bon", "pen", "connect", "pos", "cone", "fin", "close", "ran", "col", "conv", "on", "cal", "fc", "num", "c", "cont", "po", "conf", "com", "nc", "ctrl", "CON", "cur", "fl", "canon", "en", "un", "proc", "cm", "cf", "open", "client", "Con", "connection", "dial", "co", "re", "Conn", "trans", "mc", "ct", "can", "cp", "cn"], "response": ["sequence", "yes", "server", "amount", "none", "version", "resp", "def", "description", "usage", "message", "entry", "se", "e", "json", "number", "success", "esp", "pos", "network", "when", "next", "es", "respons", "zero", "error", "result", "application", "res", "http", "trace", "status", "body", "onse", "Response", "code", "relative", "country", "esi", "des", "total", "compliance", "client", "os", "position", "connection", "request", "reset", "roads", "net", "index", "state"], "redirect": [" Redind", "Reditional", " redir", "predir", "predirection", "redrict", "redir", "redirection", "rewirect", " redind", "rewind", "reditional", " redirection", "predirect", "Redirect", " Redirect", "redind", " redrict", " Redirection", "preditional", "rewrict", "Redir", " reditional", " Redrict", "Redirection", "rewirection"], "location": ["remote", "link", "where", "origin", "path", "Location", "system", "usage", "sample", "pointer", "ocation", "filename", "layout", "holder", "slot", "resource", "local", "reference", "template", "behavior", "translation", "comment", "uri", "command", "region", "details", "LOC", "language", "relative", "direction", "address", "zone", "history", "loc", "relation", "phrase", "hold", "position", "operation", "document", "directory", "area"]}}
{"id1": "18005010", "id2": "8747840", "code1": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 0, "substitutes": {"setProfile": ["storeProfile", "storeProperty", "setDefault", "SETProperty", "SETProf", "setProf", "storeProf", "SETProfile", "setProperty", " setDefault", "SETDefault", " setProf", " setProperty", "storeDefault"], "loginName": ["loginname", "fileKey", "fileNames", " loginKey", "filename", "displayname", " loginNames", "loginKey", "fileName", "displayKey", "displayNames", "displayName", " loginname", "loginNames"], "profile": ["port", "option", "picture", "header", "p", "pse", "settings", "pool", "usage", "sample", "memory", "panel", "title", "photo", "face", "prof", "json", "config", "update", "buffer", "log", "context", "property", "data", "template", "FILE", "user", "plot", "password", "result", "project", "note", "phone", "base", "report", "role", "pty", "feature", "details", "frame", "hash", "summary", "mem", "history", "relation", "Profile", "output", "client", "line", "table", "policy", "position", "account", "document", "style", "username", "properties"], "outStream": ["aosPoint", "servStream", "outFile", "aosWriter", " outFile", "outputFile", " outSteam", "aosStream", "Outstream", "exSteam", "outView", "OutSteam", " outView", "offSteam", " outWriter", " outPoint", "offStream", "outPoint", "offstream", "outputView", "exWriter", "OutWriter", "outstream", "servstream", "OutStream", "outputstream", "outWriter", "exPoint", "servView", "exStream", "outputSteam", "offWriter", "aosSteam", "OutFile", "servSteam", " outstream", "OutView", "outSteam", "outputStream"], "url": ["mail", "Url", "link", "html", "pl", "path", "cert", "string", "org", "char", "xml", "r", "mount", "location", "ssl", "resource", "host", "build", "email", "parse", "bel", "f", "base", "dl", "abs", "uri", "web", "http", "nl", "q", "service", "impl", "str", "ll", "browser", "address", "https", "loc", "rel", "l", "open", "get", "client", "URL", "re", "ls", "ur", "li"], "file": ["ile", "fp", "name", "link", "port", "path", "le", "File", "image", "pool", "document", "info", "entry", "download", "filename", "resource", "local", "email", "template", "FILE", "library", "result", "f", "base", "report", "web", "page", "lf", "body", "out", "binary", "db", "table", "output", "null", "tree", "print", " File", "format"], "connection": ["established", "Connection", "character", "link", "response", "online", "conn", "system", "still", "socket", "statement", "created", "connected", "pointer", "connect", "database", "number", "network", "session", "ion", "cone", "resource", "computer", "city", "channel", "close", "application", "c", "communication", "web", "command", "nc", "generation", "sql", "console", "condition", "no", "bo", "relation", "client", "open", "con", "position", "to", "dial", "net", "directory", "closure"], "writer": ["writers", "iterator", "println", "counter", "Writer", "external", "liner", "wa", "journal", "wrote", "ws", "operator", "owner", "inner", "fn", "loader", "wright", "commit", "entry", "w", "wrapper", "outer", "writ", "flush", "node", "event", "buffer", "walker", "network", "variable", "builder", "function", "processor", "comment", "handler", "storage", "written", "driver", "maker", "format", "worker", "caster", "ner", "draw", "usher", "widget", "er", "riter", "editor", "rw", "write", "client", "word", "creator", "WR", "runner", "document", "reader", "window", "wt", "writing"], "myEnum": [" myAnom", "someENum", " myENom", "someEnums", "myENum", " myEnet", "myEnUM", "myAcum", "myENet", " myENumb", "myenum", " myAnet", " myEnums", "myAnUM", "myEncums", "myAnumb", "myEncum", "myEnet", "someEnumb", "myEncumb", "myAnet", "someEnum", "myAnum", "myENumb", " myENum", "myAcom", " myEnom", "someEnUM", "someENUM", "myenom", " myAnums", "myENom", "myAcums", "myEncUM", "myEnums", "myEnom", " myAnum", "someENumb", "myAnums", "myAcet", "myENUM", "someENums", "myAnom", "myEnumb", "myenumb", " myEnumb", "myEncom", "myENums"], "key": ["attribute", "name", "ace", "child", "parent", "string", "it", "part", "char", "a", "ex", "v", "info", "entry", "index", "title", "member", "mac", "label", "value", "node", "variable", "i", "k", "keys", "host", "air", "val", "one", "column", "KEY", "id", "step", "Key", "m", "base", "type", "cell", "cond", "prefix", "hash", "str", "text", "item", "chain", "element", "no", "bo", "test", "word", "n", "ice", "ek", "row", "field", "token", "note", "primary", "pair", "var", "col", "pe", "owner"]}}
{"id1": "3046085", "id2": "14865947", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"s": ["name", "p", "string", "is", "rs", "strings", "g", "ps", "a", "v", "r", "w", "ns", "e", "b", "i", "S", "h", "gs", "ss", "es", "data", "f", "m", "c", "q", "its", "str", " ts", "text", "t", "os", "js", "ls", "n"], "tokenizer": ["okenazer", "toolize", " tokenisher", "terminiser", "webitor", "okenizable", "nodeizer", "terminizable", "tokenner", "nodeized", "tokenizers", "serializer", "okenize", "tokenization", "valueizable", "kinize", "operatorized", "templateizer", "terminazer", " tokenizable", "terminize", "tokenzie", "okenifier", "tokenisher", "templatezer", "serializable", "toolzer", "tokenized", "Tokenifier", " tokenzer", "tokenitor", " tokenization", "tokenener", " tokenzie", "operatorisher", "operatoriter", "tokeniner", "tokenzer", "webizable", "terminitor", "okenoser", "kinzer", "templateisher", "okenitor", "Tokenisher", "dateizable", "serialize", "okenizer", "operatorzie", "okeniser", "dateizer", "okenisher", "webisher", "okenzie", "Tokenized", "terminization", "Tokenizer", "tokenifier", "nodeisher", " tokenener", "webize", "tokenoser", "Tokener", "dateize", "templateizable", " tokenoser", "tokeniser", "webizer", "okenner", "operatorization", " tokenifier", "Tokenization", "toolizer", "toolizers", "kinizers", "Tokenener", "Tokenize", "okeniner", "tokenazer", "operatorazer", "kinizer", "serialzer", "okenener", "terminisher", "terminizer", "Tokenizers", " tokener", "templateer", " tokenner", "Tokenzer", "datezer", "okenzer", "webization", "tokenizable", "tokenize", "valueoser", " tokeniner", "templateization", "Tokenner", "operatoriner", "operatorizer", "nodeization", "okeniter", "tokeniter", "valueizer", "operatoriser", "terminiter", "tokener", "valueisher"], "title": ["name", "metadata", "horse", "lead", "version", "holiday", "story", "part", "description", "tip", "article", "itled", "label", "source", "filename", "art", "important", "author", "profile", "template", "id", "displayText", "type", "meta", "tag", "prefix", "text", "Title", "summary", "t", "phrase", "table", "total", "term", "position", "itle", "note", "primary"], "artist": ["volume", "attribute", "metadata", "picture", "image", "album", "part", "adult", "track", "photo", "associated", "assisted", "source", "folder", "art", "rank", "author", "archive", "music", "user", "gallery", "project", "person", "audio", "tag", "object", "item", "component", "voice", "position", "creator", "player", "chapter", "song", "directory", "username", "Artist"], "location": ["origin", "shape", "Location", "activity", "description", "source", "folder", "layout", "local", "reference", "translation", "gallery", "media", "phone", "comment", "time", "feature", "near", "language", "direction", "country", "address", "zone", "loc", "place", "position", "directory", "area"], "rating": ["rated", "fps", "genre", "metadata", "race", "movie", "confidence", "ranking", "rates", "rank", "profile", "credit", "music", "training", "library", "rate", "scoring", "media", "average", "meta", "scale", "erate", "boarding", "frequency", "playing", "weight", "score", "Rating"], "overplay": ["Override", "override", "appcast", " overcast", " override", " overgrade", "appplay", "overcast", "appride", "Overplay", "overgrade", "Overgrade", "appgrade", "Overcast"], "temp": ["name", "tem", "cache", "unit", "orig", "key", "now", "created", "texture", "current", "memory", "partial", "source", "buffer", "tmp", "Temp", "local", " Temp", "template", " temporary", "generated", "base", "type", "fake", "time", "stem", "Temperature", "prefix", "set", "porary", "mem", "loc", "test", "output", "term", "null", " tmp", "tm", "empty", "flash", "emp", "encrypted"], "tags": ["assets", "groups", "fields", "strings", "lines", "stats", "pages", "reports", "relations", "comments", "Tags", "links", "keys", "thumbnails", "nets", "dates", "files", "ags", "lists", "packages", "details", "parts", "stars", "balls", "types", "weights", "words", "styles", "tracks", "terms", "flags", "atts", "lights", "options", "images", "names", "marks"], "bytes": ["bits", "groups", "len", "fields", "ips", "frames", "bs", "lines", "tes", "mb", "uploads", "pages", "classes", "gets", "values", "blocks", "comments", "gs", "keys", "es", "loads", "files", "seconds", "services", "rows", "ids", "gb", "parts", "videos", "vals", "Bytes", "words", "terms", "images", "bps"], "hasher": ["haher", "hater", "haspher", " hasger", "hadter", " haser", " hasest", "Haspher", "hadpher", "haster", "haveher", " hadter", "hydHer", " haster", " hadDR", " hascher", "hydher", "hashed", " hadher", "hadHer", " hashed", "HasDR", "haveest", "hasHer", "hadger", " hasHer", "Hasher", " hader", "hadher", "hadhed", "haveter", " hasDR", "Haster", "hadcher", "Haser", "hasger", "hascher", "hashers", " haspher", "haser", " hashers", "hasDR", "Hashed", "hydger", "hydcher", "hasest", "havehers", "haest", "hahers"]}}
{"id1": "4481712", "id2": "2511579", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 0, "substitutes": {"deleteObject": ["deleteobject", "getObj", "destroyObject", "destroyObj", "deleteObj", "getObject", "destroyobject", " deleteobject", "deleteItem", "destroyItem", "getobject", " deleteItem", "getItem", " deleteObj"], "id": ["name", "delete", "url", "link", "sid", "path", "key", "p", "it", "oid", "description", "message", "mid", "info", "rid", "value", "event", "uid", "kid", "i", "h", "k", "ID", "data", "f", "type", "ids", "tag", "object", "hash", "md", "t", "ref", "d", "db", "pid", "row", "Id", "ident", "n", "vid"], "conn": ["port", "obj", " core", "enc", " mem", "cmd", "pos", " win", "host", "win", "conf", " connection", "cur", "mn", "bo", "dc", "cf", "ctx", "pt", "core", "ca", " con", " cs", " col", " comm", "org", "act", "cc", "cb", " ac", "nw", "here", "coll", "cfg", " mc", "com", " cc", "con", "connection", " compat", "pub", "oss", "ce", "net", "col", "addr", "cn", "tp", "cons", "cert", " ex", " conv", "resp", "comm", "auth", "nt", " net", "err", "ssl", "conv", "gen", "ld", " ce", "c", " ch", "pas", "nc", "ll", "gate", " cp", " cont", "pkg", "db", "co", "ens", "cat", "mc", "ct", "ch", "ws", "socket", " cmd", "ns", "connect", "pg", "sys", "priv", " cx", "close", "local", "lang", " rc", " c", " db", "ctrl", "canon", "en", "urg", "loc", " pc", "rel", "jp", "open", "client", "wp", " dc", "ann", "Conn", "nick", "n", "cp"], "stmt": ["STmp", "statmb", "Stm", "stpt", "astpt", "astm", "strm", "astmm", "statpt", "stMT", " stpt", "ostmt", " stmn", "stst", "STst", "stmm", "STm", "stmb", "ostm", "ostmm", "astmt", "strMT", "STMT", "Stmm", "utm", " stm", "utmp", "formmt", "strmn", "stmp", "utst", "utmt", "ststat", " ststat", "formm", "Stmn", "Stmp", "STmt", " stmm", "Stst", "formMT", "strmt", "Ststat", " stMT", "statmt", "Stmt", "StMT", "formstat", "stmn", "Stpt", "STmm", "Stmb", "stm", "strmb", " stmb", "statm", "ostpt"], "dbConn": ["DBConn", "dbObj", "dsCt", "dbCt", "DBObj", "DbCt", "DBRec", "DbRec", "DbObj", "dbCon", "dsConnect", " dbColl", "dbColl", " dbCt", " dbCon", "dsCon", "dsConn", "dbRec", "dbConnect", "DbColl", " dbRec", " dbObj", "DbConnect", "DBColl", "DbCon", " dbConnect", "DbConn"], "selfConnection": [" selfCategory", "ownThread", "SelfOnly", "selfConnect", "selfThread", "ownLink", "alsoLink", "SelfThread", "ownFree", "SelfCategory", "selfInfo", "SelfLink", "alsoConnection", "ownOnly", "Selfconnection", "reLink", "SelfConnect", "selfFree", "SelfFree", "alsoCategory", "selfOnly", " selfThread", "SelfInfo", "reconnection", " selfFree", "SelfConnection", "selfconnection", " selfconnection", " selfInfo", "selfCategory", " selfOnly", "reConnection", "reConnect", " selfLink", "alsoConnect", "selfLink", " selfConnect", "ownConnect", "ownConnection"]}}
{"id1": "14054923", "id2": "23585985", "code1": "    protected Document getRawResults(String urlString, Map args) throws Exception {\n        int count = 0;\n        Iterator keys = args.keySet().iterator();\n        while (keys.hasNext()) {\n            String sep = count++ == 0 ? \"?\" : \"&\";\n            String name = (String) keys.next();\n            if (args.get(name) != null) {\n                urlString += sep + name + \"=\" + args.get(name);\n            }\n        }\n        URL url = new URL(urlString);\n        URLConnection conn = url.openConnection();\n        conn.connect();\n        SAXBuilder builder = new SAXBuilder();\n        return builder.build(conn.getInputStream());\n    }\n", "code2": "    public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException {\n        StreamSource streamSource = new StreamSource();\n        if (item.getType() == Type.JAVA_OBJECT) {\n            LOG.debug(\"Streaming Java object\");\n            Object obj = ((JavaObjectValue) item).getObject();\n            if (!(obj instanceof File)) {\n                throw new XPathException(\"Passed java object should be a File\");\n            }\n            File inputFile = (File) obj;\n            InputStream is = new FileInputStream(inputFile);\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(inputFile.toURI().toURL().toString());\n        } else if (item.getType() == Type.ANY_URI) {\n            LOG.debug(\"Streaming xs:anyURI\");\n            String url = item.getStringValue();\n            if (url.startsWith(\"/\")) {\n                url = \"xmldb:exist://\" + url;\n            }\n            InputStream is = new URL(url).openStream();\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(url);\n        } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) {\n            LOG.debug(\"Streaming element or document node\");\n            if (item instanceof NodeProxy) {\n                NodeProxy np = (NodeProxy) item;\n                String url = \"xmldb:exist://\" + np.getDocument().getBaseURI();\n                LOG.debug(\"Document detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n            Serializer serializer = context.getBroker().newSerializer();\n            NodeValue node = (NodeValue) item;\n            InputStream is = new NodeInputStream(serializer, node);\n            streamSource.setInputStream(is);\n        } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) {\n            LOG.debug(\"Streaming base64 binary\");\n            BinaryValue binary = (BinaryValue) item;\n            byte[] data = (byte[]) binary.toJavaObject(byte[].class);\n            InputStream is = new ByteArrayInputStream(data);\n            streamSource.setInputStream(is);\n            if (item instanceof Base64BinaryDocument) {\n                Base64BinaryDocument b64doc = (Base64BinaryDocument) item;\n                String url = \"xmldb:exist://\" + b64doc.getUrl();\n                LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n        } else {\n            LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType()));\n            throw new XPathException(\"wrong item type \" + Type.getTypeName(item.getType()));\n        }\n        return streamSource;\n    }\n", "label": 0, "substitutes": {"getRawResults": ["getOriginalResults", "getFullResults", "getRawResult", "getrawResults", "getOriginalresults", "getFullValues", "getFullResult", " getrawResult", " getRawValues", "getrawresults", " getrawResults", "getRawValues", "getFullresults", " getRawResult", "getrawResult", " getRawresults", "getOriginalValues", "getRawresults", "getOriginalResult", " getrawresults", " getrawValues", "getrawValues"], "urlString": [" urlRest", "urlStr", "lObject", "requestString", "urlData", " urlStr", "lString", "buildStr", "uristring", "uriString", "buildData", "lAddress", "baseStr", "lRest", "baseString", "basestring", "requestData", " urlAddress", "baseAddress", "lStr", "buildstring", "uriObject", "buildString", "requeststring", " urlData", "urlObject", "urlstring", "urlAddress", " urlObject", "lstring", "uriRest", " urlstring", "urlRest", "requestStr"], "count": ["counter", "will", "race", "amount", "OUNT", "now", "find", "consider", "continue", "corruption", "nt", "current", "nb", "repeat", "number", "make", "start", "i", "next", "ount", "scroll", "call", "f", "c", "cont", "coll", "conf", "cond", "ound", "code", "thread", "chain", "length", "hold", "Count", "z", "size", "follow", "ct", "index", "ind", "state"], "keys": ["hands", "writers", "groups", "owners", "makers", "fields", "ports", "strings", "drivers", "ars", "ds", "ers", "values", "mers", "appers", "vers", "holders", "ters", "Keys", "nets", "airs", "files", "bys", "ites", "ies", "workers", "oids", "actions", "rows", "ids", "ppers", "unders", "ms", "ators", "ings", "types", "times", "phis", "items", "aws", "ians", "chers", "ties", "ors", "lights", "ics", "chains", "headers", "ks", "ues", "names", "ients"], "sep": [" seep", "SEfac", "semps", "Sepa", "seep", "separp", "Seps", "separps", "semep", "SEep", "sefac", "semp", "Seep", "SEp", "separep", " sepa", "Sep", " sefac", "sepa", " seps", "SEps", "seps", "separpa", "semfac"], "name": ["child", "path", "key", "NAME", "other", "init", "string", "part", "def", "order", "v", "old", "a", "current", "add", "entry", "title", "info", "parent", "label", "value", "all", "named", "admin", "alias", "me", "local", "on", "id", "tab", "m", "comment", "search", "Name", "str", "t", "chain", "create", "no", "l", "common", "client", "ame", "word", "family", "n", "to", "na", "field", "sp", "missing", "names", "var"], "url": ["mail", "Url", "link", "hl", "pl", "cert", "ret", "mb", "sb", "mount", "cmd", "b", "err", "gl", "ssl", "parse", "bel", "base", "dl", "il", "uri", "abs", "res", "web", "http", "nl", "sl", "str", "ll", "browser", "ref", "https", "loc", "rel", "l", "open", "URL", "norm", "net", "ls", "ur"], "conn": ["obj", "die", "ch", "init", "cert", "resp", "socket", "addr", "cb", "comm", "org", "act", "enc", "nt", "ns", "connect", "cmd", "sys", "fin", "ssl", "close", "conv", "sync", "res", "pas", "nc", "cur", "gate", "jp", "rel", "db", "ctx", "client", "open", "con", "connection", "exec", "ann", "Conn", "ct", "n", "cp", "cn"], "builder": ["alph", "building", "writer", "bus", "bean", "operator", "order", "loader", "factor", "adder", "flower", "layer", "b", "buffer", "parser", "build", "function", "manager", "bar", "builders", "Builder", "base", "handler", "good", "instance", "sf", "pb", "component", "client", "built", "upper", "block", "creator", "dict", "runner", "filter", "eng", "reader", "control", "BU"]}}
{"id1": "884867", "id2": "149935", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"zipname": [" zipbase", "gzname", "gzsize", "zebase", "zipName", "zname", "archivename", "znamed", "downloadnamed", "gznamed", " zipsize", "downloadName", "ziproot", " zipName", "gzroot", "tarroot", "zipsize", "tarsize", "polyname", "downloadname", "downloadfilename", "zipbase", "zeName", "zName", "archiveName", "tarnamed", " zipnamed", "zfilename", "polyName", " ziproot", "polynamed", "zeout", "zipnamed", "zename", "archivebase", "polyfilename", "zipfilename", "archiveout", "tarname"], "zipout": ["zion", "zipoutput", "zin", "gzgen", "zipclient", " zipion", "zname", "gzout", " zipclient", " zipgen", "gzion", "zipobj", "Zipn", "zipOut", "zipin", "zipall", "zipgen", "zOut", "zobj", "Zipin", "Zipclient", "sendout", " zipall", "zgen", " zipobj", "sendclient", " zipOut", " zipoutput", "zall", "sendname", "zout", "gzin", "sendn", "zipn", "Zipname", "sendoutput", "gzall", "zipion", "sendin", "Zipoutput", "gzobj", " zipin", "gzOut", "Zipout", "zn"], "out": ["obj", "conn", "ac", "p", " Out", "Out", "ex", "cmd", "io", "one", "res", "conf", "set", "str", " manager", "list", " outs", "name", "auto", "msg", "writer", "inv", "opt", " say", "on", " output", "cfg", "at", "by", "con", "os", "oss", "screen", "OUT", "outs", "net", "inf", "cn", "up", "ln", " bout", "g", "nt", "w", "ent", "all", "cos", "gt", " OUT", "gen", "ins", "o", " sys", "output", "dt", "null", "co", "print", "desc", "can", "ou", " fmt", "group", "ch", "go", "init", "gov", "inner", "aos", "log", "sys", " abort", "t", "en", "client", "to", "pretty", "n"], "buffer": ["attribute", "sequence", "cache", "message", "memory", "stack", "database", "temp", "variable", "pad", "buf", "Buffer", "append", "template", "bar", "library", "available", "button", "queue", "batch", "comment", "page", "command", "frame", "mem", "buff", "binary", "history", "phrase", "paste", "table", "output", "line", "iter", "block", "total", "tree", "row", "document", "filter", "window"], "in": ["inn", "im", "bi", "inc", "up", "init", "ac", "is", "it", "per", "and", "inner", "isin", "ex", "ini", "din", "info", "mm", "query", "like", "nin", "bin", "i", "read", "gin", "on", "from", "In", "form", "or", "ic", "check", "ins", "en", "IN", "by", "get", "con", "ma", "iter", "ai", "cin", "rin", "input", "pi", "mc", "reader", "inf", "oin", "ind"], "length": ["volume", "character", "sequence", "language", "len", "amount", "shape", "version", "string", "full", "height", "present", "phi", "display", "capacity", "reading", "message", "distance", "integer", "shift", "database", "value", "number", "hello", "point", "maximum", "read", "join", "ENGTH", "match", "padding", "library", "available", "tail", "ength", "type", "space", "needed", "vector", "depth", "bow", "frequency", "code", "collection", "impl", "class", "load", "no", "loc", "angle", "duration", "history", "total", "component", "family", "position", "count", "size", "print", "Length"]}}
{"id1": "17791385", "id2": "20247400", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["clonefile", " cpfile", "copyResource", " cpFile", " copyResource", "cloneResource", " cpFiles", "copyFiles", "copyfile", " copyFiles", " cpResource", " copyfile", "cloneFiles", "cloneFile"], "src": ["Source", "sec", "obs", "init", "inst", "sq", "bs", "sin", "rs", "via", "sr", "sb", "rx", "ck", "sel", "source", "start", "sys", "ys", "sit", "ipl", "txt", "usc", "from", "cont", "ctr", "ux", "rl", "st", "sur", "cur", "ins", "sf", "ser", "usr", "rel", "sc", "req", "rc", "input", "iv"], "dst": [" dnd", "Ddest", "ddest", "ddst", "Dth", "dnt", "dth", "dnd", " dth", "sst", "wdest", "dddest", "Dnt", "wst", "Dnd", "snd", "wth", "ddnt", " ddest", "sdest", "snt", "ddnd", "wnd", "Dst"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "is", "it", "ain", "act", "sin", "inner", "rec", "isin", "din", "info", "mm", "ze", "min", "source", "i", "bin", "gin", "on", "from", "In", "ic", "st", "inside", "ins", "en", "IN", "iter", "con", "ai", "input", "cin", "rin", "ar", "inf", "oin", "ind"], "out": ["auto", "obj", "up", "writer", "it", "and", "Out", "inner", "g", "ex", "nt", "oe", "outer", "aos", "dis", "sys", "bin", "io", "conv", "gt", "on", "ou", "res", "po", "sum", "ot", "st", "t", "at", "o", "ne", "by", "write", "output", "client", "os", "con", "to", "oss", "co", "outs", "OUT", "net", "can", "n", "cn"], "buf": ["msg", "cap", "pl", "cv", "tx", "bus", "cb", "bytes", "bh", "seq", "cmd", "ck", "b", "bed", "buffer", "log", "prop", "uf", "Buffer", "conv", "bar", "box", "gen", "tab", "batch", "arr", "cam", "mu", "good", "br", "cur", "bag", "Buff", "buff", "pkg", "vec", "db", "cf", "stab", "block", "norm", "cat", "fb", "aka", "var", "cp"], "len": ["cap", "elt", "ln", "le", "exp", "lim", "vol", "cmp", "lon", "v", "nt", "seq", "e", "pos", "all", "ren", "h", "fin", "L", "val", "fun", "ld", "num", "il", "dl", "coll", "el", "lf", "str", "fl", "t", "ll", "en", "lib", "no", "loc", "rel", "l", "length", "lan", "Len", "wid", "count", "lic", "end", "z", "compl", "size", "ls", "n"]}}
{"id1": "19739421", "id2": "7499186", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": ["UnknownOptionHandler", "UnknownCommandException", " UnknownCommandException", "UnknownParameterClass", "UnknownParameterHandler", " UnknownCommandError", "UnknownFormatException", "UnknownOptionError", " UnknownCommandHandler", "UnknownCommandClass", "UnknownFormatHandler", " UnknownOptionHandler", "UnknownParameterError", "UnknownParameterException", "UnknownCommandError", "UnknownOptionClass", " UnknownCommandClass", " UnknownOptionClass", "UnknownCommandHandler", "UnknownFormatClass", "UnknownFormatError", " UnknownOptionError"], "cmdLineParser": ["mdLineBuilder", "cmdlineOptions", "mdLineHandler", "commandlineReader", "commandLineBuilder", "cmdPageReader", "cmdlinePers", "cmdFrameParser", "mdLineReader", "CmdLineReader", "cmdNetParser", "cmdlineHandler", "mdlinearser", "commandLineRunner", "cmdLHandler", "CmdLineParser", "mdLineParser", "cmdLineRunner", "cmdListParser", "commandLineReader", "cmdLinePers", "mdLineparser", "commandlineBuilder", "commandlineRunner", "cmdLineReader", "cmdLBuilder", " cmdPageBuilder", " cmdPageParser", "cmdLineHandler", "cmdlineReader", "CmdlineProvider", "mdlineParser", "mdlineBuilder", "CmdLineProvider", "cmdPageParser", "cmdFrameRunner", "cmdSetparser", "mdlineHandler", "cmdlineStreamer", "cmdPageBuilder", "cmdChainReader", "cmdSetBuilder", "mdlineLoader", "cmdListReader", "cmdFrameReader", "cmdChainParser", "cmdChainarser", "cmdBlockOptions", "commandLineProvider", "cmdLineStreamer", "cmdLineBuilder", "cmdBlockProvider", "commandlineProvider", "cmdLineOptions", "commandLinePers", "mdLineLoader", "mdlineReader", "cmdLOptions", "cmdSetParser", "mdlineOptions", "CmdLineBuilder", "commandLineParser", "cmdLinearser", "cmdListparser", "mdLinearser", "cmdBlockBuilder", "cmdLParser", " cmdLineReader", "commandlinePers", "CmdlineReader", "mdLineOptions", "mdlineStreamer", " cmdLineBuilder", "cmdlineParser", " cmdPageReader", "cmdLineLoader", "cmdlineLoader", "mdLineStreamer", "cmdPageProvider", "cmdlineBuilder", "CmdlineParser", "cmdBlockHandler", "cmdBlockReader", "cmdlineparser", "cmdNetStreamer", "cmdBlockParser", "cmdLineProvider", "cmdlinearser", "cmdLineparser", "cmdFramePers", "cmdChainLoader", "cmdNetReader", "cmdListBuilder", "commandlineParser", "CmdlineBuilder", "cmdNetHandler", "mdlineparser", "cmdlineProvider", "cmdSetReader", "cmdlineRunner"], "formatOption": ["transformOption", "filterEntry", " formatEntry", " formatOperation", "formatOptions", "formatOperation", "transformOperation", "FormatOptions", " formatOptions", "formatEntry", "FormatOption", "transformEntry", "transformOptions", "filterOption", "FormatOperation"], "outputEncodingOption": ["outputencodingOption", "outputEncodingoption", "outputencodingOptions", "outputEncamingOptions", "outputEncamingoption", "outputEncappingOptions", "outputencachingOptional", "outputEncodingOptions", "outputEncachingOption", "outputencodingoption", "outputEncachingOptional", "outputencachingOptions", "outputEncappingOptional", "outputEncodingOptional", "outputencappingOptional", "outputEncamingOption", "outputencachingOption", "outputEncachingOptions", "outputencappingoption", "outputEncappingOption", "outputEncgingoption", "outputEncamingOptional", "outputencodingOptional", "outputencappingOption", "outputEncgingOption", "outputEncappingoption", "outputEncgingOptional"], "inputEncodingOption": ["inputEncappingOptions", "inputEncodingAttribute", "inputencodingoption", "inputEncappingoption", "inputenclingOptions", "inputEncordingOption", "inputencodingAttribute", "inputenclingAttribute", "inputEnclingoption", "inputCodingOption", "inputEncordingOptions", "inputEncodingoption", "inputEncappingAttribute", "inputenclingoption", "inputEncappingOptional", "inputEncordingoption", "inputenclingOption", "inputEncordingAttribute", "inputEncachingOptions", "inputCachingOptions", "inputEncendingOption", "inputEnclingAttribute", "inputEncappingOption", "inputEncachingOptional", "inputEncodingOptional", "inputEncendingOptions", "inputencodingOptions", "inputencodingOption", "inputCachingOption", "inputEncendingOptional", "inputEncodingOptions", "inputCodingOptional", "inputCachingOptional", "inputEnclingOptions", "inputEncachingOption", "inputCodingOptions", "inputEnclingOption"], "format": ["option", "name", "printf", "unit", "version", "string", "it", "pattern", "display", "fix", "what", "title", "file", "config", "source", "filename", "layout", "sort", "join", "parse", "template", "export", "method", "error", "f", "accept", "type", "force", "scale", "command", "form", "status", "prefix", "set", "language", "with", "api", "at", "module", "table", "output", "get", "term", "tif", "policy", "license", "transform", "pretty", "print", "note", "filter", "pi", "style", "use", "Format"], "outputEncoding": ["outputencaging", "currentEnling", "outputEngoder", "currentEnaching", "outputencoding", " outputDecoding", "outputEncaging", "currentEncaching", " outputEncacing", "outputEnording", " outputEncaming", "outputEnling", "outputEnaching", " outputEngoder", "outputEnging", " outputEngoding", "outputencging", "outputMessining", "outputEncalling", "currentEncling", "outputEncging", "publicEncoding", " outputEngacing", "currentEncoding", "outputEncaling", "currentEnoding", "outputEncoder", " outputEncoder", "outputEnaging", "outputEncacing", "outputDecling", "outputMessaming", "publicEncaging", "outputMessoding", "outputEngging", "outputEngacing", "outputEncryption", "responseEncoding", "outputEncling", "outputDecalling", "outputEnoding", "outputDecaming", "publicEncling", " outputEncining", "outputEngaling", "outputDecining", " outputEngaling", "outputEnacing", "outputCompining", "outputEnaling", "outputencling", "outputEncaming", " outputEncaling", "outputEncording", "outputCompryption", "outputCompoding", "responseEncling", "currentEncging", "outputencaching", "outputEncaching", "publicEncording", "outputDecoding", "outputMessryption", " outputDecryption", " outputEncryption", "currentEnging", "outputCompaming", "outputEnalling", "outputEngling", "outputEngaching", "outputEngoding", "outputDecryption", " outputDecining", "responseEncryption", "outputEncining", "outputencording", "outputEnoder", "responseEncalling", "outputEnryption", " outputDecaming"], "inputEncoding": ["inputEngale", "inputEnacing", "contextEnoder", "inputEncale", "inputEncing", "inputEnoding", "sourceEnling", "inputPackging", "inputEngoding", "inputencoding", "contextEncacing", "inputEnging", "sourceEncling", "inputEning", "inputChale", "inputChacing", "outputEncging", "outputEnoding", "contextEnoding", "inputEngoder", "contextEncoding", "inputencacing", "inputChoder", "inputPackoder", "inputencoder", "inputChoding", "outputEncale", "sourceEncoding", "inputEnoder", "contextEnacing", "sourceEncing", "outputEncoder", "outputEnale", "contextEnale", "inputEncoder", "contextEncale", "inputCodacing", "inputEncacing", "inputencing", "inputCodling", "contextEncoder", "inputPackale", "inputencale", "inputPackoding", "inputencling", "inputEnale", "inputEncling", "sourceEning", "outputEnging", "inputEngging", "inputEnling", "sourceEncacing", "outputEnoder", "sourceEnoding", "sourceEnacing", "inputCoding", "inputCododing", "inputEncging"], "remainingArgs": ["resainingGS", "mainedGS", "resainedLinks", "remistingLinks", "remainingItems", "remainsArgs", "remainargs", "remainGS", "mainingParts", "resainingItems", "remainsBlocks", "remainedItems", "resainedItems", "remainLinks", "remainsGS", "resainedargs", "remainedargs", "trainFrames", "trainingFrames", "remainBlocks", "resainingBlocks", "mainedParts", "remainingParts", "remainItems", "remainJs", "remainFrames", "trainingGS", "resainedGS", "remistingBlocks", "removalGS", "remendingGS", "remendingArgs", "trainGS", "remainParts", "remainedLinks", "remgoingParts", "resainingLinks", "remistingArgs", "trainingItems", "resainingParameters", "mainingGS", "remistingGS", "mainingArgs", "resainingArgs", "trainItems", "resainedParameters", "removalBlocks", "trainArgs", "mainedJs", "resainingargs", "trainingArgs", "remainingJs", "remainingParameters", "removalParameters", "removalArgs", "remgoingJs", "remainingLinks", "remainArgs", "remainsParameters", "remainedParts", "remgoingArgs", "resainedArgs", "remainedJs", "remgoingItems", "remgoingGS", "remainedBlocks", "remainedGS", "remainedFrames", "remendingItems", "mainingJs", "remendingFrames", "resainedBlocks", "remainingGS", "remainedArgs", "remgoingargs", "remainedParameters", "mainedArgs", "remainingBlocks", "remainingFrames", "remainingargs"], "inputFile": ["Inputfile", "InputPath", "hiddenFile", "acceptfile", "outputPath", "InputFile", "InputFILE", " inputfile", "outputfile", " inputLine", "inputPlace", " inputPlace", "requestPath", "hiddenPath", "acceptFile", "inputFILE", " inputLike", " inputFILE", "acceptLine", "hiddenfile", "inputLine", " inputPath", "inputPath", "acceptPlace", "requestfile", "inputLike", "InputPlace", "requestFile", "inputfile", "InputLine", "outputLike", "hiddenLike", "requestFILE"], "outputFile": ["coinDo", "outputDo", "clientFiles", "OutputFiles", "outputfile", "OutputFile", "OutputFilename", "inputDir", "writeFile", "clientDo", " outputDir", "cacheFilename", "clientFile", "outputFolder", " outputfile", "writeDo", "OutputDir", "outputFilename", "writeFolder", "inputFilename", "cacheDir", " outputFiles", "coinFile", "Outputfile", "outputDir", "coinFolder", "inputfile", "clientDir", "OutputDo", " outputDo", "cachefile", "writefile", " outputFolder", "cacheFile", "outputFiles", "coinfile"], "out": ["msg", "obj", "up", "conn", "ln", "init", "writer", "inv", "Out", "inner", "ex", "aos", "outer", "temp", "all", "log", "session", "err", "sys", "io", "inter", "manager", "user", "gen", "on", "error", "res", "report", "cfg", "in", "ins", "ser", "inf", "output", "gr", "dir", "con", "null", "list", "outs", "screen", "OUT", "net", "print", "pretty", "n", "ou"]}}
{"id1": "5061606", "id2": "18693224", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNecessesed", "createSettingsIfNecessesar", "createSettingsIfNeccessed", "createSettingsIfNeccesar", "createSettingsIfNacessible", "createSettingsIfNecessar", "createSettingsIfNacessary", "createSettingsIfNeccessible", "createSettingsIfNecessed", "createSettingsIfNecessesary", "createSettingsIfNacessesar", "createSettingsIfNeccesary", "createSettingsIfNeccessar", "createSettingsIfNacessesed", "createSettingsIfNecessible", "createSettingsIfNacessed", "createSettingsIfNeccesible", "createSettingsIfNacessesible", "createSettingsIfNacessar", "createSettingsIfNeccesed", "createSettingsIfNecessesible", "createSettingsIfNacessesary", "createSettingsIfNeccessary"], "out": ["timeout", "obj", "up", "server", "conn", "go", "ch", "init", "yes", "writer", "it", "Out", "cho", "inv", "ex", "nt", "flush", "oe", "outer", "w", "aos", "ent", "max", "file", "gc", "cos", "ion", "log", "err", "sys", "io", "one", "that", "conv", "on", "exit", "f", "comment", "ou", "again", "res", "report", "ot", "or", "t", "bo", "o", "ne", "OU", "write", "output", "client", "con", "null", "os", "to", "oss", "end", "co", "list", "outs", "OUT", "net", "print", "note", "can", "n", "off", "cn"], "fSettings": ["fsettings", "cfSetting", "bfsettings", "cfSettings", "fOptions", "bfSettings", "cfSetup", "finalsettings", "bfChanges", " fOptions", " fSetting", "sfsettings", "fSetup", "hSettings", "sfOptions", "cfsettings", " fChanges", "fChanges", "eSettings", " fsettings", "sfSetup", "eSetting", "sfSettings", "finalSetting", "finalOptions", "sfChanges", "finalSettings", " fSetup", "esettings", "sfSetting", "hsettings", "hSetting", "bfSetting", "fSetting"], "src": ["url", "ls", "view", "attr", "sq", "rs", "dest", "fn", "sr", "sb", "rx", "syn", "config", "source", "sys", "filename", "sit", "resource", "tmp", "root", "txt", "cont", "rl", "cur", "ser", "img", "sf", "spec", "loc", "rel", "pkg", "sc", "ur", "dir", "rc", "th", "rt", "desc", "upload"], "in": ["inn", "ln", "init", "is", "and", "sin", "inner", "isin", "r", "din", "info", "source", "bin", "i", "gin", "ad", "id", "from", "In", "ins", "inside", "en", "IN", "l", "iter", "n", " din", "input", "rin", "cin", "vin", "inf"]}}
{"id1": "822452", "id2": "12782570", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewrites", "readAndrewWrite", "readAndReprites", "readAndResWrite", "readAndResend", "readAndReprite", "readAndResrites", "readAndrewrites", "readAndRepWrite", "readAndrewend", "readAndRewWrite", "readAndResrite", "readAndRepend", "readAndRewend", "readAndrewrite"], "inFile": [" inFilename", "outFilename", "InFile", "outfile", "inTime", "INTime", "inputPlace", "inFace", "INFILE", "initPlace", " infile", "docFILE", "initFilename", "inFilename", "inputFilename", "iTime", "INFile", "initFace", "INFace", "InFilename", "iFILE", "Infile", "infile", "INPlace", "docFilename", "docFile", "inputFile", "INFilename", "inPlace", "iFile", "docTime", "iFilename", "initFile", "inFILE", "inputFace"], "outFile": [" outFILE", "outFilename", "reportFile", "outfile", "reportFILE", "nameFile", "nameFilename", "checkfile", "toFile", "inFilename", " outFilename", "reportfile", "checkFile", "nameFILE", "checkFILE", "checkFilename", "reportFilename", "infile", "toFilename", "outFILE", "toFILE", "namefile", "tofile", " outfile", "inFILE"], "iis": ["diIs", " iisc", " iIS", "IIs", "Ii", "eis", "liIs", "diiss", " ii", "iisc", "dii", "liisc", " iIs", " iiss", "Iis", "iIs", "iiss", "liis", "aiis", "iiris", "aiIS", "Iiss", "iiIs", "aiIs", "iris", "iiisc", "liris", " iris", "eIS", "iiis", "eIs", "diis", "iIS", "ii"], "dcmParser": ["dpmStatement", " dcmLoader", "dmmparser", "DpmParser", "DpmReader", "dpmPar", "dmmmParser", "decmarser", "Dpmparser", "dfmLoader", "dmmReader", " dpmarser", "decmReader", "DcmReader", "dcommParser", "dpmParser", "dpmPrivate", " dcmAssistant", " dpmparser", "deromReader", "dmReader", "dcfStatement", "deromParser", " dpmAssistant", "DcmBuilder", "DcmAdapter", "dcomBuilder", "deromarser", " dpmParser", " dpmPrivate", " dcmStatement", "dmarser", "dcrparser", "dcomLoader", "dromReader", "dmmarser", "dmmParser", "dmmmparser", "dcomParser", "dcfReader", "dpmBuilder", "dgrPar", "dpmReader", "dromparser", "dcmStatement", "dcmPrivate", " dpmListener", " dpmStatement", "dmparser", "dpmLoader", "dfmReader", "drumPar", "dpmListener", " dcmarser", "dfmParser", "Dcmparser", "dgrReader", "dcmAdapter", "dmoduleAssistant", "dmmAdapter", "DcmPar", "dcmLoader", "dromListener", "dpcParser", "dpcReader", "dcrBuilder", " dcmReader", "dromarser", "dfmBuilder", "DpmBuilder", " dcmparser", "dpcAssistant", "dcmPar", "dcommListener", " dcmPrivate", " dcmBuilder", "decmParser", "dgrStatement", "decmparser", "dcmAssistant", "drumBuilder", "dcmListener", "dcommReader", "DcmParser", " dpmPar", "drumReader", " dpmLoader", "dmParser", "dcmReader", " dcmListener", "dcommAssistant", "dmodulePrivate", " dcmPar", "DpmAdapter", "dcomReader", "dcmarser", "dgrParser", "dpmparser", "dmmmReader", "dromParser", "DpmPar", "dpmAssistant", "dcfParser", "dcrParser", "dpmAdapter", "dromAssistant", "drumParser", " dpmBuilder", " dpmReader", "dpmarser", "dcfPar", "deromparser", "dpcPrivate", "dmoduleReader", "dmoduleParser", "dmmmAdapter", "dcmparser", "dcmBuilder", "dcrReader"], "ds": ["obs", "cs", "ws", "gd", "bs", "ods", "Ds", "rs", "tes", " DS", "ps", "drivers", "sets", "dh", "ns", "aos", "dx", "der", "DS", "hd", "bd", "sys", "ys", "ils", "gs", "sd", "dat", "ss", "es", "data", "uds", "xs", " des", "sv", "dl", "fs", "services", "ads", "eds", "its", "details", "in", "da", "ims", "ins", "dds", "pers", "vs", "d", "des", "db", "eps", "dos", "os", "dt", "s", "dq", "js", "outs", "qs", "dd", "hs", "ks", "ls", "as", "df", "pd"], "pdReader": ["vdWriter", "pedRunner", "xdHelper", "ddHelper", "tdParser", "pdParser", "dpLoader", "pdCar", "ddParser", "ddRunner", "vdReader", "pedReader", "pdRunner", "pdHelper", "ddLoader", "pedLoader", "pdLoader", "ddRead", "ddWriter", "hdReader", "dpReader", "ddReader", "vdHelper", "pedCar", "pdRead", "tdRead", "hdWriter", "xdReader", "xdLoader", "xdWriter", "dpRunner", "vdLoader", "ddCar", "dpCar", "hdRead", "hdParser", "tdWriter", "tdReader"], "out": ["obj", "cache", "conn", "p", "Out", "ex", "v", "cmd", "pos", "io", "one", "data", "res", "in", "str", "end", "list", "name", "auto", "msg", " err", "full", "writer", "cb", "inv", "pool", "opt", "on", "sw", "cfg", "we", "at", "gr", "os", "con", "oss", "outs", "screen", "OUT", "net", "raw", "cn", "up", "nt", "w", "outer", "ent", "all", "nr", "err", "tmp", "conv", "gt", "gen", "id", "c", "sum", "ins", "o", "output", "null", "co", "js", "desc", "ou", "go", "ch", "it", "inner", "aos", "flush", "sys", "log", "serv", "inter", "txt", "status", "t", "en", "client", "s", "to", "over", "n"], "dcmEncParam": ["dcmencMsg", "dmmencMsg", "dmmEncPar", "dmmEnNum", "dmmencNum", "dmmEncParam", "dcmEncVal", "dmmEnParam", "dcmEscNum", "dmmEncMsg", "dmmEnPar", "dcmDecCmd", "dcmEnParam", "dcmencParam", "dcmencPar", "dcmDecMsg", "dcmEnPar", "dcmDecParam", "dcmEscVal", "dcmEnNum", "dcmEncPar", "dmmencCmd", "dcmencCmd", "dmmEncVal", "dcmEnVal", "dcmencNum", "dcmDecNum", "dcmEncNum", "dcmEncMsg", "dmmEncNum", "dmmEncCmd", "dcmEscParam", "dcmEncCmd", "dcmEscPar", "dmmencParam"], "pdWriter": ["PDEditor", "pcWriter", "tdWriter", "dpEditor", "PDReader", "PDWrite", "pdWrite", "pidWriting", "PDWriter", "pdwriter", "dpReader", "dpWriter", "tdEditor", "pdEditor", "pidWriter", "pcWrite", "pcWriting", "pcwriter", "dpWrite", "pidwriter", "tdWriting", "tdwriter", "pidWrite", "pdWriting", "tdWrite", "tdReader"]}}
{"id1": "11716816", "id2": "14054923", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    protected Document getRawResults(String urlString, Map args) throws Exception {\n        int count = 0;\n        Iterator keys = args.keySet().iterator();\n        while (keys.hasNext()) {\n            String sep = count++ == 0 ? \"?\" : \"&\";\n            String name = (String) keys.next();\n            if (args.get(name) != null) {\n                urlString += sep + name + \"=\" + args.get(name);\n            }\n        }\n        URL url = new URL(urlString);\n        URLConnection conn = url.openConnection();\n        conn.connect();\n        SAXBuilder builder = new SAXBuilder();\n        return builder.build(conn.getInputStream());\n    }\n", "label": 0, "substitutes": {"updateFile": ["downloadSourceFile", "updateContent", "archiveContent", "downloadFile", "UpdatePage", "downloadContent", "UpdateSourceFile", "archivePage", "downloadPage", "archiveSourceFile", "updatePage", "updateSourceFile", "UpdateContent", "UpdateFile", "archiveFile"], "file": ["ile", "fp", "name", "link", "url", "attribute", "port", "path", "le", "File", "image", "full", "p", "message", "info", "entry", "content", "issue", "title", "e", "source", "filename", "log", "h", "resource", "io", "channel", "local", "data", "FILE", "f", "base", "type", "report", "page", "t", "rule", "db", "table", "output", "get", "line", "null", "input", "document", "use", "handle", "format"], "IOException": [" IOProblem", "SecurityProblem", "SecurityException", "IOError", "OperationError", " IOError", "OperationException", "OperationProblem", "SecurityError", "IOProblem"], "destFile": ["Destile", " destPath", "sourceFile", " destDir", "destPage", "optFolder", "DestDir", "declFile", "destile", "targetDir", "Destfile", "DestPath", " destPage", "destPlace", " destPlace", " DestEmail", "destFolder", " destinationEmail", "destEmail", "destPath", "targetPath", "destSourceFile", "DestFile", "tempPath", " destFolder", "DestFolder", " destfile", "tempfile", "destfile", "declSourceFile", "DestSourceFile", " DestDo", " destinationDo", " destDo", " destinationDir", " destile", "optFile", "tempFile", "sourceDir", " DestDir", "targetFile", "destDo", "tempDir", "destDir", " destSourceFile", "DestPlace", "optPlace", "declFolder", "sourcePath", "declile", "sourceFolder", "DestPage", " DestFile", "optPage", " destEmail", " destinationFile", "targetFolder"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "raw", "is", "it", "mi", "ain", "act", "sin", "inner", "isin", "ini", "r", "din", "info", "mm", "all", "bin", "i", "io", "read", "gin", "local", "edIn", "on", "f", "m", "from", "In", "ic", "ins", "inside", "en", "IN", "ne", "l", "con", "ai", "iter", "s", " din", "n", "cin", "rin", "input", "ie", "re", " IN", "net", "pass", "inf", "oin", "ind"], "out": ["obj", "msg", "up", "cache", "ch", "conn", "it", "Out", "g", "v", "ex", "nt", "fn", "oe", "aos", "outer", "flush", "cmd", "b", "cos", "ion", "sys", "log", "io", "channel", "one", "conv", "gt", " OUT", "result", "ou", "again", "ot", "or", "t", "en", "chain", "no", "at", "jp", "o", "ne", "OU", "write", "output", "client", "os", "null", "con", "s", "oss", "to", "co", "outs", "OUT", "net", "note", "can", "n", "cn"]}}
{"id1": "2668853", "id2": "14758866", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2Files", "decodeFileAsFile", "decodeFileTOString", "decodeFileToString", "decodeFileTOFile", "decodeFileAsFiles", "decodeFileToFiles", "decodeFileToPage", "decodeFilesToFiles", "decodeFilesToFile", "decodeFileTOPage", "decodeFiles2Files", "decodeFiles2Page", "decodeFilesToPage", "decodeFileAsString", "decodeFileTOFiles", "decodeFile2File", "decodeFileAsPage", "decodeFiles2File", "decodeFile2Page", "decodeFilesToString", "decodeFiles2String", "decodeFile2String"], "infile": ["inFile", "inputwhere", "outFile", "InFile", " inwhere", "innfile", "inputfilename", "inwhere", "inbase", " inbase", "Inbase", "innwhere", "infilename", "inpath", "innbase", "Inpath", "outbase", "innfilename", "Infile", "outpath", "inputfile", "inputpath", "inputFile", "inputbase", " infilename"], "outfile": ["inFile", "Outfilename", "outFile", "listfile", "infp", " outFile", "tofp", "listfilename", "listFile", "Outfile", "infilename", "toFile", "inpath", "tofilename", " outpath", "Outpath", "outfp", "outfilename", "outpath", "listfp", " outfilename", "OutFile", "tofile"], "in": ["inn", "im", "al", "inc", "pin", "conn", "init", "image", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "io", "gin", "user", "on", "from", "In", "form", "amin", "ins", "inside", "en", "IN", "ro", "o", "by", "get", "iter", "con", "ai", "n", " din", "cin", "rin", "input", "re", "inf", "oin", "ind"], "out": ["ln", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "w", "aos", "outer", "flush", "ent", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "sequence", "cache", "view", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "bone", "variable", "pad", "black", "buf", "Buffer", "append", "template", "bar", "padding", "zero", "available", "password", "note", "batch", "base", "comment", "queue", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "length", "block", "tree", "row", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "shift", "run", "connect", "through", "query", "start", "i", "push", "close", "give", "data", "send", "wait", "q", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "iter", "count", "seek", "end", "skip", "need", "readable", "input", "size", "print", "reader", "index", "pe", "Read"], "success": [" convergence", "response", "town", " okay", "first", "same", "continue", "master", "support", " successes", "commit", " successful", "growth", "photo", " succeeds", "safe", " succeed", "submit", " succ", "second", "snap", "Success", "city", "close", "ccess", "successfully", "error", "warning", "ceed", "result", "successful", "complete", " successfully", "security", "accept", "crit", "sufficient", "done", "cont", "release", "democracy", "valid", "status", "good", "surv", "danger", "green", "summary", " Success", "please", "ok", " failure", "setup", "unity", "ratulations", " succeeded", "top", "cess", "primary", "exist"]}}
{"id1": "4593011", "id2": "12454178", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "label": 1, "substitutes": {"loadDDL": ["readDDL", "loadSDL", "loadDSLS", "readDDDL", "readPDl", "loadSDLS", "loadSDDL", "loadDSl", "loadDDl", "loadPDl", "loadSDl", "readPDLS", "loadPDLS", "loadDDLS", "loadDDDL", "readPDDL", "readDDl", "readDDLS", "loadPDDL", "loadPDL", "loadDSDL", "loadDSL", "readPDL"], "stmt": ["Stm", "stpt", "sttx", "stemt", "stMT", " stpt", " stmn", " superstmt", "stmm", "STm", "steMT", "stmb", "tMT", "Stdo", "strMT", " Stmt", "STMT", "Stmm", "Sttr", " StMT", " stm", " superstm", "strmn", "tmt", "stdo", "stem", "Stmn", " superstMT", "Sttx", "strmb", "STmt", "ttr", "stedo", " superstpt", "STtx", " stmm", " sttx", "tmm", " sttr", "strmt", " stMT", " Stpt", "Stmt", "StMT", "sttr", " stdo", "stmn", "Stmb", "stm", " Stm", " stmb"], "qry": ["sqries", "quries", "qury", "qutry", "Qries", "qries", " qries", "qtry", "quri", "Qrys", "Qri", " qtry", "qrys", "Qry", " qri", "sqrys", "sqtry", "sqri", "sqry", " qrys", "qri"], "q": [" sq", "p", "sq", "qu", "qt", "g", "v", "w", "u", "e", "query", "i", "h", "k", "j", "ql", "ry", "f", "m", "c", "qq", "Q", "y", "qi", "t", "qv", "o", "d", "pkg", "l", "dq", "z", "qa", "qs", "quest", "iq", "n"]}}
{"id1": "10131427", "id2": "17158020", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"copyFile": [" Copyfile", " copyStream", " CopyImage", " copyImage", "CopyFile", " cpImage", "CopyStream", " cpfile", " copyfile", " CopyFile", " CopyStream", " cpFile", " cpStream", "Copyfile", "CopyImage"], "in": ["inn", "inc", "up", "is", "it", "isin", "old", "r", "din", "mm", "source", "b", "i", "gin", "edIn", "on", "from", "In", "el", "ic", "st", "ins", "en", "IN", "o", "l", "n", "s", "input", "rin", "cin", "ar", "vin", "inf", "ind"], "out": ["ch", "it", "Out", "v", "ex", "nt", "w", "file", "b", "log", "err", "i", "io", "serv", "gt", "po", "ot", "check", "help", "str", "t", "o", "ne", "l", "output", "os", "to", "s", "oss", "outs", "OUT", "net", "n", "ou"], "sourceChannel": ["srcchannel", "singleApplication", "sourceStream", "seedButton", "resourceChannel", "ourceChannel", "singleChannel", "sourcechannel", "srcStream", "singleChuck", "seedChuck", "sourceConnection", "matchApplication", "sourceChain", "inputChain", "srcButton", "sourceApplication", " sourceChan", "ourceChan", "inputChan", "inputChannel", " sourceChain", " sourcechannel", "Sourcechannel", "sourceChuck", "seedApplication", "ourceButton", "singleButton", "matchButton", "ourceChain", " sourceButton", "srcChannel", "inputConnection", "sourceChan", " sourceConnection", "matchChannel", "matchChuck", "sourceButton", "ourcechannel", "SourceStream", "resourceStream", "seedChannel", "SourceChannel", "SourceConnection", " sourceStream", "resourcechannel", "ourceStream", "resourceConnection", "ourceConnection"], "destinationChannel": ["DestinationBlock", "destationChannel", "destensionConnection", "destinatoryChannel", "DestensionChan", "DestationCow", "destroyClient", "destinatedChan", "destinationsChannel", "destroyChannel", "DestationChan", "destinationsContext", "destationChan", "destroyConnection", "destinatedConnection", "DestationConnection", "DestinationCow", "DestinationClient", "destinatoryCow", "DestationContext", "DestensionConnection", "destationContext", "destinatedChannel", "destinationBlock", "DestensionChannel", "destationCow", "destroyChan", "destensionChannel", "destinationsChan", "desticationCow", "destinationContext", "destensionClient", "DestationChannel", "destinatedContext", "DestationBlock", "destinationClient", "destationClient", "DestensionClient", "desticationChan", "destinationsConnection", "destinatoryChan", "DestinationContext", "destensionChan", "DestinationChannel", "destationConnection", "destinationChan", "DestinationChan", "desticationChannel", "destinationCow", "destinatoryBlock", "destinationConnection", "destationBlock", "desticationBlock", "DestinationConnection"]}}
{"id1": "16378239", "id2": "20619879", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"byReference": [" byRef", "byResource", "forResource", " byResource", "ByReference", "Byreference", " byreference", "forreference", "byRef", "forReference", "ByResource", "byreference", "ByRef", "forRef"], "inputStream": ["Inputstream", "inFile", "InputSteam", "inputReader", " inputSteam", "readableStream", "InputFile", " inputFile", " inputstream", " inputReader", "readableSteam", "InputStream", "readableReader", "readablestream", "instream", "inStream", "InputReader", "inputSteam", "inputstream", "inputFile", "inSteam"], "tempFile": ["tempUrl", "empfile", "empFile", "TempFile", "tmpName", "poraryUrl", "tempFiles", "tempName", "tmpPath", "empPlace", "empPath", "TempPath", "tmpDirectory", "poraryName", " tempfile", "Tempfile", "poraryPlace", "poraryDir", " tempChain", "TempDir", "tempPath", " tempDir", "tmpPlace", "tempfile", "tmpFile", " temporaryfile", " temporaryFile", "tempDirectory", "TempDirectory", "poraryFile", "TempUrl", "tempPlace", "poraryfile", " tempFiles", "empDirectory", "empName", " temporaryChain", "tempChain", "tempDir", " tempUrl", "tmpfile", "TempFiles", "TempChain", " temporaryFiles"], "out": ["auto", "msg", "up", "writer", "Out", "v", "ex", "aos", "dis", "ent", "file", "source", "all", "cos", "sys", "io", "serv", "one", "conv", "user", "again", "sum", "in", "lay", "ins", "t", "us", "o", "OU", "l", "output", "gr", "con", "os", "null", "to", "oss", "ao", "co", "s", "outs", "OUT", "net", "as", "n", "ou"]}}
{"id1": "10385815", "id2": "364438", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["delete", "opy", "replace", "download", "Cop", "file", "cop", "read", "transfer", "sync", "save", " duplicate", "clip", "rm", "slice", "create", "move", "load", "csv", "clone", "write", "paste", "Copy", " copying", "cat", "cp", "upload"], "fileFrom": ["fileForm", "projectStart", "inputFrom", " fileStart", "sampleInitial", "fileInitial", "inputObject", "FileObject", "ileTo", "FileForm", "ileFrom", "projectA", "ileObject", "fileA", "inputForm", " fileA", " fileInitial", "projectInitial", "ileForm", "projectFrom", "inputTo", "sampleA", "fileObject", "fileStart", "FileTo", "sampleFrom", "sampleStart", "FileFrom"], "fileTo": ["File2", "FileTO", "modelTO", "ile2", " fileDest", "FileDest", "modelTarget", "ileTo", "FileTarget", "fileTO", "modelTo", " file2", "modelDest", "ileDest", " fileTarget", "FileTo", "file2", "fileDest", "fileTarget", " fileTO", "ileTarget"], "inputStream": ["importFile", "imageChannel", "InputSteam", "audioStream", "audioSteam", "activeStreamer", " inputSteam", "InputFile", " inputFile", "imageStream", "sourceStream", "importChannel", "audioStreamer", "sourceChannel", "audiostream", "eventstream", "sourceSteam", "imageStreamer", "InputSource", "activeSteam", "InputStreamer", "InputStream", "activeChannel", "inputStreamer", "importSteam", "eventStreamer", "eventSteam", "activeStream", "inputSteam", "sourceSource", "inputstream", "inputSource", "eventStream", "importStream", "imageSteam", "inputFile", "imagestream", " inputSource", "InputChannel"], "outputStream": ["displaySteam", "writeChannel", "outputFile", "writeSocket", " outputFile", "webString", "Outputstream", "OutputFile", " outputSteam", "resultSocket", "writeStream", "writeSteam", "OutputStream", "resultStream", "webSteam", "inputString", "webFile", "outputSocket", "OutputSteam", "inputSteam", "displayStream", "inputstream", "outputstream", "resultSteam", "displaystream", "webChannel", " outputString", "resultChannel", "outputSteam", "OutputChannel", "webStream", "outputString", " outputSocket", "displayChannel"], "inputChannel": ["inputCategory", "localChannel", "readableConnection", " inputSteam", "readableChan", "operatorStream", "createSteam", "currentCategory", "readableChannel", " inputChain", "readChain", "InputConnection", "outputChan", "localConnection", "readCategory", " inputConnection", "readChannel", "InputChan", " inputCamera", "inputChain", "InputStream", "localChan", " inputCategory", "inputChan", "readChan", "operatorCamera", "outputConnection", "operatorConnection", "inputSteam", "currentChain", "createStream", "inputConnection", "createChannel", "currentChan", "outputSteam", "InputCamera", " inputChan", "createChan", "inputCamera", "currentChannel", "operatorChannel", "InputChannel"], "outputChannel": [" outputConnection", "writeContext", "updateCategory", "updatechannel", "writeChannel", "OutputContext", "putStream", "hiddenChan", "successConnection", "writeChan", "Outputchannel", "outputchannel", "putchannel", "OutputCategory", "successChannel", "outputChan", "putChan", "outputCategory", "OutputStream", " outputchannel", "putChannel", "writeConnection", "updateChannel", "outputConnection", "hiddenChannel", "hiddenchannel", "OutputChan", "outputContext", " outputChan", "hiddenCategory", "OutputChannel", " outputContext", "OutputConnection", "successStream", "updateChan", "successchannel"]}}
{"id1": "3375724", "id2": "22320592", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" insertarEmissoresDosTitulOsFe", " insertarEmissoresDosTituloC", " insertarEmissoresDosTitULosFe", " insertarEmissoresDosTitULoC", " insertarEmissoresDosTitULoFe", " insertarEmissoresDosTitULoT", " insertarEmissoresDosTitULosT", " insertarEmissoresDosTituloT", " insertarEmissoresDosTitulosC", " insertarEmissoresDosTitulasC", " insertarEmissoresDosTitulOsC", " insertarEmissoresDosTituloF", " insertarEmissoresDosTitULosC", " insertarEmissoresDosTitulasT", " insertarEmissoresDosTitulosT", " insertarEmissoresDosTitulosF", " insertarEmissoresDosTitulasFe", " insertarEmissoresDosTitULosF", " insertarEmissoresDosTitulOsF", " insertarEmissoresDosTitulasF", " insertarEmissoresDosTitulosFe", " insertarEmissoresDosTituloFe", " insertarEmissoresDosTitulOsT", " insertarEmissoresDosTitULoF"], "pArquivoTXT": ["pArquivoTOX", "pArquivoFxt", "pArquivoRXT", "pArquivoRxt", "pArquivotOX", "pArquivTOX", "pArquivTEX", "pArquivoXTXT", "pArquivoFRL", "pArquiveTxt", "pArquivoTxt", "pArquivTIN", "pArquivoNxt", "pArquivoFEX", "pArquiveNBT", "pArquivTxt", "pArquivoDRL", "pArquivoXTOX", "pArquivNXT", "pArquivoNBT", "pArquivotIN", "pArquivRIN", "pArquivoROX", "pArquivoXTIN", "pArquiveNxt", "pArquivotxt", "pArquivRxt", "pArquivoFXT", "pArquivoBxt", "pArquivoXTxt", "pArquivoBEX", "pArquivoTRL", "pArquivoDXT", "pArquivoNRL", "pArquivNxt", "pArquivotXT", "pArquivTRL", "pArquivoTEX", "pArquivROX", "pArquiveNXT", "pArquivNRL", "pArquivoFBT", "pArquiveNEX", "pArquivoTIN", "pArquivoRIN", "pArquivTXT", "pArquivRXT", "pArquivoNEX", "pArquivoDEX", "pArquivoNXT", "pArquivNEX", "pArquiveTEX", "pArquiveTBT", "pArquiveTXT", "pArquivoBXT", "pArquivoTBT", "pArquivoBBT", "pArquivoDxt"], "pAndamento": ["pandmentO", "pAndumentO", "pAndumentoS", "pAndamentos", "pandamentO", "pandamentos", "pAndamentO", "pAndumentos", "pAndmentoS", "pandamentoS", "pandmentoS", "pAndmentos", "pandmento", "pandmentos", "pAndmentO", "pAndamentoS", "pAndementO", "pAndementos", "pAndementoS", "pAndemento", "pAndumento", "pandamento", "pAndmento"], "numeroDoRegistro": ["numeroDoRegitulo", "numeroDoregistulo", "numeroDoregestro", "numeroDoRegestulo", "numeroDoRegistulo", "numeroDoRegestros", "numeroDoregistr", "numeroDoregestulo", "numeroDoRegitro", "numeroDoRegestro", "numeroDoRegestr", "numeroDoRegistros", "numeroDoRegitr", "numeroDoregestr", "numeroDoRegistr", "numeroDoregistro", "numeroDoRegendro", "numeroDoRegitros", "numeroDoRegendr", "numeroDoRegendulo", "numeroDoregestros", "numeroDoregistros", "numeroDoRegendros"], "in": ["inn", "scan", "inc", "pin", "kin", "ln", "sin", "inner", "isin", "din", " ins", "min", " out", "nin", "bin", "tin", "inning", "gin", " inn", "f", "m", "from", "In", "ner", "ins", " nin", "out", "IN", "inf", "con", "n", " din", "cin", "rin", "input", " sin", "reader", "vin", "edIn", "thin"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialDecaine", "stmtLimpezaIniciaEstinos", "stmtLimpezaIniciaEstINO", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialEstino", "stmtLimpezaInicialDestaine", "stmtLimpezaInicialStinos", "stmtLimpezaInicialStaine", "stmtLimpezaInicioDestINO", "stmtLimpezaIniciaDestINO", "stmtLimpezaInicioDestino", "stmtLimpezaInicialStino", "stmtLimpezaInicioDestinos", "stmtLimpezaInicioEstINO", "stmtLimpezaInicialDestINO", "stmtLimpezaIniciaEstino", "stmtLimpezaInicialdestination", "stmtLimpezaInicioEstaine", "stmtLimpezaInicioEstino", "stmtLimpezaInicialStination", "stmtLimpezaInicialDestinos", "stmtLimpezaInicialEstinos", "stmtLimpezaInicioEstinos", "stmtLimpezaInicioDestaine", "stmtLimpezaInicialdestino", "stmtLimpezaInicialdestinos", "stmtLimpezaIniciaEstination", "stmtLimpezaInicialEstaine", "stmtLimpezaInicialStINO", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialEstination", "stmtLimpezaInicialDecino", "stmtLimpezaInicialDestination", "stmtLimpezaInicialEstINO", "stmtLimpezaIniciaDestinos", "stmtLimpezaInicialDecINO", "stmtLimpezaInicialDecinos"], "sql": ["name", "url", "msg", "html", "ln", "pp", "string", "statement", "sq", "select", "socket", "inv", "xml", "description", "fn", "scl", "expression", "cmd", "json", "wal", "params", "query", "log", "session", "ssl", "join", "sd", "serv", "xs", "template", "ql", "pel", "sv", "dl", "spr", "nl", "q", "command", "lex", "details", "sol", "str", "spec", "csv", "seed", "rel", "sn", "eps", "s", "js", "SQL", "qs", "script", "sp", "ls", "raw", "format"], "stmtDestino": ["stmtdestorno", "stmmInstorno", "stmtDecino", "stmtDecinos", "stmtDestINO", "stmtStINO", "stMTDecino", "stmtDestination", "stmtStin", "stmtInstino", "stmmInstination", "stMTDestinos", "stmtStorno", "stmmDestinos", "stmmDestorno", "stMTDestin", "stmmInstinos", "stmtInstination", "stmtDecin", "stmtdestino", "stMTDecinos", "stMTDecINO", "stmtStinos", "stmtdestin", "stmtInstinos", "stmtStination", "stmmInstino", "stmmDestination", "stmtdestinos", "stmtdestination", "stmtDecINO", "stMTDestino", "stMTDestINO", "stMTDecin", "stmtStino", "stmtDestin", "stmtDestorno", "stmmDestino", "stmtDestinos", "stmtInstorno", "stmtdestINO"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABUCALH", "TAMANHO_DO_CABUCALLHI", "TAMANHO_DO_CABECILHI", "TAMANHO_DO_CABECARHA", "TAMANHO_DO_CABUCALLHA", "TAMANHO_DO_CABECALHA", "TAMANHO_DO_CABUCALLH", "TAMANHO_DO_CABECULH", "TAMANHO_DO_CABECALLHA", "TAMANHO_DO_CABECILHO", "TAMANHO_DO_CABECARHI", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECALH", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECARH", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABUCALHA", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECILHA", "TAMANHO_DO_CABUCALHI", "TAMANHO_DO_CABUCALHO", "TAMANHO_DO_CABECALLH", "TAMANHO_DO_CABECILH", "TAMANHO_DO_CABUCALLHO"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAP_FILE", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPEJFILE", "TAMANHO_DO_RODAPE2do", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPE2DO", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPE2Do", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPE_FILE", "TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAP_Do"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADABOSON", "TAMANHO_DOS_METADADSON", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADABO_", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADOON", "TAMANHO_DOS_METADADS_", "TAMANHO_DOS_METADADDSON", "TAMANHO_DOS_METADABOON", "TAMANHO_DOS_METADABOS_", "TAMANHO_DOS_METADADOSON", "TAMANHO_DOS_METADABos_", "TAMANHO_DOS_METADADDS_"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_REMES", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_POR_RegIN", "TAMANHO_MEDIO_POR_REGIN", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_POR_RECES", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_POR_REMESS", "TAMANHO_MEDIO_POR_REGis", "TAMANHO_MEDIO_POR_Regis", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_REMIN", "TAMANHO_MEDIO_POR_RegESS", "TAMANHO_MEDIO_POR_REMIS", "TAMANHO_MEDIO_POR_REGESS", "TAMANHO_MEDIO_POR_RECis"], "tamanhoDosArquivos": ["tamanhoDosArquesivaos", "tamanhoDosArquivalores", "tamanhoDosArquesivlos", "tamanhoDosArquivalo", "tamanhoDosArqivos", "tamanhoDosArquivelos", "tamanhoDosArquiveores", "tamanhoDosArquIVores", "tamanhoDosArquivao", "tamanhoDosArquivalos", "tamanhoDosArquesivalos", "tamanhoDosArqivores", "tamanhoDosArquesivo", "tamanhoDosArquivals", "tamanhoDosArquivaoes", "tamanhoDosArquIVoes", "tamanhoDosArquIVlos", "tamanhoDosArquiveoes", "tamanhoDosArqIVs", "tamanhoDosArqivs", "tamanhoDosArquiveo", "tamanhoDosArquivores", "tamanhoDosArquivoes", "tamanhoDosArquiveos", "tamanhoDosArquesivao", "tamanhoDosArquesivos", "tamanhoDosArquivlos", "tamanhoDosArquivs", "tamanhoDosArquIVos", "tamanhoDosArqIVos", "tamanhoDosArquives", "tamanhoDosArquIVo", "tamanhoDosArquivo", "tamanhoDosArquesivaoes", "tamanhoDosArquIVs", "tamanhoDosArquivaos", "tamanhoDosArqivo", "tamanhoDosArqIVores", "tamanhoDosArqIVo", "tamanhoDosArquesivoes"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstamados", "quantidadeDeRegistrosEstipados", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstimados", "quantidadeDeRegistrosEstamada", "quantidadeDeRegistrosEstamadas", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstimmados", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstamado", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstimmadas"], "registro": ["regestr", "regdistro", "regitro", "registr", "regestrob", "Regestr", "Registro", "regestros", "registros", "Regestrob", "regitrob", "regdistros", "Registros", "Regestro", "regdistr", "regitros", "regestro", "Registr", "Registrob", "regitr", "Regestros", "regdistrob", "registrob"], "campos": ["campo", "jamOS", "taro", " campo", "tarOS", "campOs", "tarOs", " campOS", "jamo", "campOS", " campOs", "taros", "jamos", "jamOs"]}}
{"id1": "20751378", "id2": "2910383", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"hashPassword": [" hashpassword", "HashPassword", "Hashpassword", "updatepassword", " hashPrivate", "hashPrivate", "hashText", "HashPrivate", "updatePrivate", "updateText", "hashpassword", " hashText", "updatePassword", "HashText"], "password": ["attribute", "name", "key", "p", "string", "PASS", "pattern", "auth", "wd", "description", "wordpress", "message", "device", "w", "expression", "database", "argument", "value", "hello", "Password", "query", " Password", "property", "email", "column", "padding", "default", "user", "application", "comment", "security", "login", "crypt", "sword", "command", "prefix", "language", "address", "phrase", "client", "word", "request", "connection", "shadow", "input", "reset", "pass", "token", "print", "directory", "username", "secret", "encrypted"], "hash": ["cache", "html", "array", "dig", "ashing", "number", "alg", "her", "ash", "user", "username", " Hash", "str", "block", "hex", "trust", "has", "index", "other", "version", "height", "replace", "put", "bh", "message", "title", "h", "here", "method", "result", "hed", "report", "tag", "mask", "address", "proof", "checking", "ha", "rh", "cloth", "token", "filter", "response", "where", "tr", "uh", "reading", "hing", "value", "locking", "hello", "also", "zero", "alert", "mass", "search", "Hash", "ah", "ping", " hashing", "sum", "object", "test", "total", "shadow", "print", "handle", "key", "string", "ho", "sh", "copy", "shift", "log", "build", "crypt", "check", "class", "oh", "sha"], "md": ["sm", "obj", "del", "and", "mt", "cd", "MD", "add", "dm", "dh", "ds", "mm", "man", "der", "od", "cmd", "managed", "hd", "ind", "grad", "bd", "sd", "mod", "ad", "sam", "di", "ld", "m", "det", "pm", "mp", "red", "ms", "mn", "d", "nd", "dir", "mand", "js", "dd", "mc", "dr", "mk", "df", "pd", "sha"]}}
{"id1": "22993368", "id2": "14878593", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2file", "decodeFileAsfile", "decodeFile2Files", "decodeStringToFiles", "decodeStringTofile", "decodeFileAsFile", "decodeFileTofile", "decodeFileToString", "decodeFileFilefile", "decodeFileAsFiles", "decodeFileToFiles", "decodeFile2file", "decodeFileFileFiles", "decodeString2String", "decodeFileFileString", "decodeString2File", "decodeString2Files", "decodeStringToFile", "decodeFileAsString", "decodeFile2File", "decodeStringToString", "decodeFile2String", "decodeFileFileFile"], "infile": ["inFile", "infolder", "outFile", "InFile", "fromfile", "isinname", "Inbase", "inbase", "frombase", "infilename", "isinfolder", "outname", "isinfile", "outbase", "fromFile", "inputname", "inputfolder", "Infile", "inname", "outfilename", "fromfilename", "Infilename", "outfolder", "inputfile", "inputFile", "isinFile"], "outfile": ["otfile", "inFile", " outname", "Outfilename", " outFILE", "outFile", " outFile", "todir", "Outfile", "outdir", "otFILE", "infilename", "toFile", "tofilename", "indir", "otname", "outname", "inname", "outfilename", "Outdir", "otFile", "outFILE", "OutFile", "tofile", "inFILE"], "in": ["inn", "im", "al", "inc", "up", "pin", "conn", "init", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "gin", "on", "id", "from", "In", "form", "or", "amin", "ins", "inside", "t", "en", "IN", "by", "get", "iter", "con", " din", "cin", "rin", "input", "re", "ar", "inf", "oin", "ind"], "out": ["auto", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "aos", "outer", "flush", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "null", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "character", "sequence", "cache", "view", "shape", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "variable", "bone", "pad", "buf", "black", "Buffer", "append", "template", "bar", "padding", "library", "available", "password", "button", "note", "batch", "base", "comment", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "block", "row", "print", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "shift", "run", "connect", "allow", "through", "query", "start", "i", "push", "close", "give", "send", "wait", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "req", "count", "iter", "seek", "end", "skip", "input", "readable", "need", "n", "size", "print", "reader", "index", "ind", "Read"], "success": ["response", "town", " okay", "first", "same", "fail", "continue", "primary", "scope", " successes", "support", " successful", "commit", "positive", "growth", "photo", " succeeds", "safe", " succeed", "submit", "value", " succ", "second", "snap", "Success", "city", "ccess", "successfully", "error", "ceed", "result", "successful", "complete", "setup", "done", "accept", "crit", "sufficient", "release", "democracy", "valid", "status", "good", "surv", "danger", "summary", "condition", "please", "ok", " failure", "unity", "ratulations", "cess", "exist"]}}
{"id1": "6613944", "id2": "14054923", "code1": "    public static String installOvalDefinitions(final String xml_location) {\n        InputStream in_stream = null;\n        try {\n            URL url = _toURL(xml_location);\n            if (url == null) {\n                in_stream = new FileInputStream(xml_location);\n            } else {\n                in_stream = url.openStream();\n            }\n        } catch (IOException ex) {\n            throw new OvalException(ex);\n        }\n        Class<OvalDefinitions> type = OvalDefinitions.class;\n        OvalDefinitions object = _unmarshalObject(type, in_stream);\n        String pid = _getDatastore().save(type, object);\n        return pid;\n    }\n", "code2": "    protected Document getRawResults(String urlString, Map args) throws Exception {\n        int count = 0;\n        Iterator keys = args.keySet().iterator();\n        while (keys.hasNext()) {\n            String sep = count++ == 0 ? \"?\" : \"&\";\n            String name = (String) keys.next();\n            if (args.get(name) != null) {\n                urlString += sep + name + \"=\" + args.get(name);\n            }\n        }\n        URL url = new URL(urlString);\n        URLConnection conn = url.openConnection();\n        conn.connect();\n        SAXBuilder builder = new SAXBuilder();\n        return builder.build(conn.getInputStream());\n    }\n", "label": 0, "substitutes": {"installOvalDefinitions": [" saveOevalEntications", " saveOvalDeclitions", " saveOvalEntinitions", " saveOvalEntications", " saveOevalEntinitions", " saveOvalDeclinitions", " saveOevalDefinitions", " saveOevalDefaults", " saveOevalDefications", " saveOvalDefaults", " saveOvalEntaults", " saveOvalDefinitions", " saveOvaldefitions", " saveOevalEntitions", " saveOvalDeclications", " saveOvaldefinitions", " saveOvalDeclaults", " saveOvalDefications", " saveOvalEntitions", " saveOvalDefitions", " saveOevalDefitions", " saveOvaldefications", " saveOevalEntaults", " saveOvaldefaults"], "xml_location": ["xmlContentLocation", " xml_position", "xml_uri", "xml_loc", " xml_loc", " xml_Location", "xmlContentloc", "xmlContenturi", "xml_Location", "xmlContentlocation", " xml_uri", "xml_position"], "in_stream": ["input_stream", "xmlptstream", "in_Stream", "in2store", "in67iterator", "xmlptStream", " in_ream", "inMemStream", "in_iter", "in67sign", "in___buffer", "in___iter", "in_store", "in_ream", "in2Stream", " in_Stream", "xmlptstore", "in_view", "inptstream", "inptresource", " in_iterator", "inMemstore", " in_sign", "xml_Stream", "in_resource", "input_buffer", "xmlptresource", "inptstore", "input_iter", "inMemstream", "xml_resource", "in67view", "in_sign", "xml_store", "in64stream", "in64Stream", "input_path", "xml_stream", "inptStream", " in_view", "in___path", "in_iterator", "in67stream", "in_path", "in64ream", "in___stream", "inMemresource", "in2resource", "in2stream", "in_buffer"], "url": ["mail", "Url", "link", "name", "path", "cert", "org", "char", "xml", "r", "download", "mount", "file", "location", "gl", "ssl", "resource", "host", "bel", "f", "dl", "abs", "uri", "web", "http", "nl", "sl", "el", "rl", "service", "impl", "str", "ll", "browser", "address", "ref", "loc", "rel", "l", "null", "lr", "URL", "ls", "ur", "ul"], "type": ["mail", "ime", "where", "ype", "TYPE", "shape", "model", "ver", "oid", "ty", "ped", "what", "info", "typ", "title", "cl", "file", "event", "function", "sche", "base", "ping", "role", "otype", "y", "check", "cast", "t", "class", "create", "test", "kind", "types", "module", "tool", "core", "tree", "Type", "ct", "style", "pe", "tp"], "object": ["name", "obj", "not", "array", "model", "version", "string", "system", "oid", "message", "info", "entry", "job", "entity", "detail", "value", "node", "json", "event", "resource", "context", "data", "id", "result", "instance", "objects", "class", "out", "element", "o", "output", "dict", "document"], "pid": ["port", "pc", "sid", "pp", "cert", "p", "pn", "pan", "oid", "png", "ps", " PID", "process", "pet", "title", "doi", "pg", " persistent", "uid", "prop", "PK", "pa", "id", "rpm", "po", "pty", "pm", "ids", "park", "pic", "pr", " pc", "ido", "proc", "pkg", "bid", "print", "vid", "pd"]}}
{"id1": "5399593", "id2": "19520541", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static URL[] getDirectoryListing(URL url) throws IOException, CancelledOperationException {\n        FileSystem.logger.log(Level.FINER, \"listing {0}\", url);\n        String file = url.getFile();\n        if (file.charAt(file.length() - 1) != '/') {\n            url = new URL(url.toString() + '/');\n        }\n        String userInfo = KeyChain.getDefault().getUserInfo(url);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.setAllowUserInteraction(false);\n        urlConnection.setConnectTimeout(FileSystem.settings().getConnectTimeoutMs());\n        if (userInfo != null) {\n            String encode = Base64.encodeBytes(userInfo.getBytes());\n            urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encode);\n        }\n        InputStream urlStream;\n        urlStream = urlConnection.getInputStream();\n        return getDirectoryListing(url, urlStream);\n    }\n", "label": 0, "substitutes": {"encrypt": ["ecrypt", "decode", "decrypted", "eccode", "enrypted", "deccode", "enrypt", "ecode", "encode", "enccode", "ecrypted", "decrypt", "enode", "encrypted"], "plaintext": ["preword", " Plainth", " plainText", "plaincontext", " plainword", "maintext", " Plaintext", "mainword", "plainText", "preText", " Plainpassword", " Plaininput", " plainth", "ainth", "precontext", " plaincontext", "aininput", "plainword", "plaininput", "plainpassword", "plainth", "ainpassword", "aintext", " plainpassword", "maincontext", " plaininput", "mainText", "pretext"], "UnsupportedEncodingException": ["UnsupportedEncryptionError", "UnsupportedEncodingEx", "UnsupportedEncodedException", "UnsupportedEncodedEx", "UnsupportedEncryptionEx", "UnsupportedCompoderException", "UnsupportedCompodingException", "UnsupportedEncoderEx", "UnsupportedEncryptionException", "UnsupportedCompodingEx", "UnsupportedCompoderError", "UnsupportedCompoderEx", "UnsupportedEncoderException", "UnsupportedEncoderError", "UnsupportedEncodingError", "UnsupportedEncodedError", "UnsupportedCompodingError"], "md": ["sm", " MD", "df", "del", " mm", "mt", "def", "cd", "mb", "MD", " m", " cmd", "add", "dm", "mo", "nt", "mm", "der", "od", "cmd", "grad", "ind", "gm", "bd", "sd", "mod", "ad", " mo", "pd", "ld", "m", "det", "med", " Md", " dd", " mc", "pm", "mp", "ms", "mg", "red", "mn", "d", "nd", "mand", "exec", "dd", "mc", "dr", "mk", " ma", "hd", "sha"], "raw": ["clear", "orig", " RAW", "full", "clean", "sh", "message", "cooked", "known", "pack", "json", "all", "strip", "read", "buf", "aw", "data", "available", " Raw", "unsigned", "custom", "valid", "draw", "mem", "serial", "out", "load", "des", "was", "hook", "n", "core", "row", "input", "empty", "Raw", "hex", "bare", "rendered", "RAW", "bytes"], "hash": ["zh", "name", "ashed", "html", "key", "tr", "ssh", "height", "sh", "bh", "ASH", "message", "unknown", "hat", "mac", "h", "ash", "password", "id", "dump", "result", "hed", "search", "Hash", "sum", "tag", "ashes", "check", "mask", "code", "proof", "component", "total", "shadow", "cloth", "hex", "hidden", "has", "sha"]}}
{"id1": "14882263", "id2": "16820041", "code1": "    private void UploadActionPerformed(ActionEvent evt) {\n        JFileChooser chooser = new JFileChooser();\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(\"*.jpg\", \"jpg\");\n        chooser.setFileFilter(filter);\n        File dir = new File(System.getProperty(\"user.home\"));\n        chooser.setCurrentDirectory(dir);\n        Component parent = null;\n        int returnVal = chooser.showOpenDialog(parent);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            UserStatus.setText(\"Bitte warten\");\n        }\n        try {\n            Pic.setVisible(false);\n            FTPClient client = new FTPClient();\n            client.connect(\"showus.de\");\n            client.login(\"web2\", \"kcinnay88\");\n            client.enterLocalActiveMode();\n            client.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            int reply = client.getReplyCode();\n            System.out.println(\"Connect returned: \" + reply);\n            FileInputStream in = new FileInputStream(chooser.getSelectedFile().getAbsolutePath());\n            System.out.println(\"Uploading File\");\n            client.storeFile(\"/html/Applet/user/\" + Config.id + \".jpg\", in);\n            client.logout();\n            in.close();\n            System.out.println(\"done\");\n            UserStatus.setText(\"Upload fertig, Bild wird aktuallisiert\");\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            UserStatus.setText(\"Fehler beim Upload\");\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 0, "substitutes": {"UploadActionPerformed": [" uploadActionRelected", " uploadActionReceived", " uploadEventOccformed", " uploadActionOcclected", " uploadEventPerformed", " uploadActionReuted", " uploadActionPerceived", " uploadEventOccuted", " uploadActionOccformed", " uploadEventPerceived", " uploadActionPerlected", " uploadActionPerformed", " uploadEventOcclected", " uploadActionOccceived", " uploadActionPeruted", " uploadActionOccuted", " uploadEventOccceived", " uploadActionReformed", " uploadEventPerlected", " uploadEventPeruted"], "evt": ["evtm", "evte", " EVte", "evtd", " emtd", " EVtm", " emte", " evte", " evtd", " evtm", " EVtd", " EVt", " emtm", " emt"], "chooser": ["composer", "choer", "choener", "boicker", "roer", "choicker", "Choicer", "Choener", "Choose", " choosen", "rooser", "chener", " choicker", "Choicker", " choener", "roicer", "CHOose", "choicer", "CHOicker", "boosen", "chicker", "boose", " choose", "CHOoser", "choser", "choosen", "compose", " choer", "CHOosen", "Choer", "choose", "composen", "booser", "Choosen", "chose", " choicer", "chosen", "roose", "CHOener", "compener", "Chooser"], "filter": ["util", "find", "pattern", "apply", "xml", "file", "query", "folder", "filename", "sort", "fil", "function", "profile", "match", "map", "Filter", "f", "handler", "type", "search", "only", "feature", "set", "service", "check", "mask", "finder", "sf", "range", "spec", "ref", "test", "table", "policy", "term", "list", "transform", "use", "format"], "dir": ["name", "path", "wd", "def", "Dir", "file", "div", "pos", "folder", "log", "ir", "tmp", "dat", "manager", "data", "root", "DIR", "id", "ext", "base", "dl", "res", "fd", " Dir", "dep", "set", "desc", "lib", "out", "ref", "loc", "rel", "d", "pkg", "db", "doc", "dial", "dist", "home", "directory", "window", "ind"], "parent": ["obj", "group", "server", "child", "p", "state", "part", "pool", "this", "g", "parents", "e", "config", "Parent", "pos", "container", "div", "holder", "context", "close", "tmp", "manager", "root", "m", "page", "instance", "form", "widget", "out", "ctx", "component", "gr", "null", "tree", "pid", "self", "sp", "window", "cp", "owner"], "returnVal": [" returnValue", "acceptVAL", "resultval", "submitValue", "submitType", "retval", "ReturnValue", "ReturnVal", "Returnval", "resultVAL", "returnValue", "returnval", "resultVal", " returnType", "submitVAL", "retVal", "returnType", "resultValue", "retVAL", "acceptVal", "returnVAL", "retValue", "ReturnVAL", "submitVal", "acceptValue", "acceptType", " returnVAL"], "client": ["remote", "util", "url", "cgi", "cache", "response", "server", "conn", "obj", "key", "system", "and", "pattern", "connected", "Client", "bolt", "rand", "window", "connect", "cli", "cl", "file", "controller", "cmd", "config", "ssl", "context", "secure", "channel", "close", "local", "io", "template", "default", "resource", "manager", "call", "phone", "c", "force", "web", "http", "cell", "console", "service", "collection", "chain", "api", "contact", "create", "google", "lib", "browser", "out", "proxy", "con", "connection", "dial", "core", "co", "cod", "ce", "acl", "net", "wrapper"], "reply": ["response", "intern", "answer", "shell", "notice", "back", "consider", "continue", "repl", "connect", "nb", "cmd", "vote", "py", "query", "nr", "close", "next", "embed", "respond", "match", "zero", "call", "echo", "result", "exit", "comment", "report", " replied", "command", "poll", "body", "nz", "bill", "ply", "proxy", "voice", "write", "connection", "route", "script", "Reply", "print", "trust", "state"], "in": ["inn", "inc", "conn", "p", "is", "it", "mi", "inner", "ex", "ini", "add", "din", "file", "bin", "i", "io", "serv", "gin", "f", "from", "login", "In", "sum", "sql", "body", "ic", "ins", "en", "out", "IN", "o", "by", "ma", "ai", "s", " din", "input", "cin", "rin", " IN", "pi", "mc", "reader", "ind"]}}
{"id1": "8046691", "id2": "11704429", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"retrieveFile": ["retrievedLink", "detrieveLink", "retractImage", "retrievedFile", "retireImage", "retrieveLocal", "retrieveLink", "detrievedImage", "retireLocal", "retireLink", "retractLink", "retractLocal", "retractFile", "retireFile", "detrieveLocal", "detrievedLink", "detrieveFile", "detrievedLocal", "detrievedFile", "detrieveImage", "retrievedLocal", "retrievedImage", "retrieveImage"], "url": ["remote", "Url", "name", "pl", "path", "image", "string", "char", "job", "run", "u", "file", "location", "ssl", "host", "resource", "build", "bel", "call", "id", "f", "m", "dl", "base", "abs", "uri", "web", "nl", "http", "el", "sl", "rl", "str", "ll", "address", "ref", "rect", "un", "l", "get", "arl", "row", "URL", "ml", "ls", "ur", "cp"], "link": ["task", "stream", "master", "info", "linked", "pack", "links", " check", "library", "set", "block", "list", "self", "sign", "index", "Link", "msg", " reload", "le", "path", " lock", "def", "message", "download", "detail", "error", " load", "type", "tag", "thread", " relay", "ink", "style", " jump", "mail", "remote", "light", "query", "ssl", "ld", "base", "install", "post", "load", "relation", "loop", "db", "share", "ls", "handle", "go", "key", "init", " LINK", "image", "system", "loader", "add", "entry", "lock", "label", "file", "log", "network", "build", "local", " block", "map", " delay", "ment", "let", "dl", "mark", "page", "status", "check", "lib", "rel", "l", "write", "open", "get", "line", "tool", "ml", "cp", "li"], "httpConn": ["appConn", " httpConnection", "httpCon", "httpsCon", "hoverCon", "socketConnect", "httpConnection", "ttpSyn", "HTTPCons", "httpCmd", "hoverCons", "httpsConn", "appConnect", "ttpCons", "appConnection", "ttpConn", "realconn", "realConnect", "ttpCt", "htmlConn", "httpsconn", "localconn", "ttpconn", "localConn", "localCon", "localConnection", "hoverConnection", "httpSyn", "ttpCmd", " httpCon", "hoverSyn", "internalCon", "HttpConnection", "hoverCt", "httpsCmd", "ttpConnect", "hoverConnect", "internalCt", "httpConnect", "hoverConn", "socketConn", " httpCons", "appconn", " httpCmd", "HttpConn", "htmlCt", "htmlConnect", "internalConn", "httpsCons", "ttpCon", "httpsConnect", "socketConnection", "HttpCon", "HTTPConn", "httpsConnection", " httpSyn", "realConn", "internalconn", "internalConnect", "ttpConnection", "socketconn", "httpCons", " httpconn", " httpCt", "internalConnection", " httpConnect", "httpCt", "HTTPCon", "htmlconn", "realCt", "HTTPConnect", "HttpConnect", "httpconn"], "outs": ["bits", " layouts", "offs", "obs", " ops", "ips", "als", "ts", "bs", "ports", "locks", "uts", "uploads", "ats", "sets", "ds", "ns", "aos", "gets", " out", "aps", "cos", " outputs", "gs", "ends", "orts", "ches", "uds", "nets", "yout", "aches", "dates", "fits", "cells", "lists", "its", "boxes", "ops", "tops", "ims", "ins", "ios", "out", "nos", "lets", "plays", "eps", "uns", "vals", "os", "s", "checks", "ows", "qs", "ks", "ls"], "bins": ["bkins", " binos", "blids", "linos", "binn", "blins", "blinn", " binn", "louts", " bids", "hin", "blkins", "bin", "wins", "lobs", "hins", "houts", "routs", "blinos", "win", "lins", "binos", "lin", "blouts", "blans", " bkins", "bobs", "wobs", "rkins", "linn", " bans", "wouts", "bans", "bids", "hobs", "rans", "lids", "rins"], "bouts": ["wbouts", "bbins", "bonds", "obins", "obyout", " bout", "baints", "bbouts", "wout", "Baints", "fbins", "fbbs", "waos", "Bouts", "waints", "wonds", "wins", "obouts", " baints", "wbonds", "wbout", "bbbs", "byout", "Baos", "wbaos", "fbouts", "bbs", "Bins", "bbyout", " baos", "baos", "wouts", "fbyout", " bonds", "obbs", "bout"], "postData": ["PostDATA", "Postdata", " postDATA", " postQuery", "postDat", "PostData", "POSTData", "POSTDat", "PostBody", "POSTdata", "postBody", "POSTBody", "postsData", "POSTDATA", " postDat", "POSTBytes", " postdata", "postDATA", " postBytes", "postsdata", "postsDATA", "formdata", "postdata", "formData", "formDat", "postsBytes", "PostQuery", "postQuery", "formDATA", "postBytes", " postBody", "PostBytes", "POSTQuery"], "mimePattern": ["metyTemplate", "smimepattern", " muxTemplate", "smetyPattern", "mimepattern", "muxpattern", "smimeFormat", "mIMEPattern", "mimesFormat", "smetypattern", "metyFormat", "mimeTemplate", "mIMEFormat", "metypattern", "mimesTemplate", "muxPattern", " muxPattern", " mimepattern", "mIMEpattern", "smimePattern", " mimeTemplate", "mimeFormat", " muxpattern", "metyPattern", "mimespattern", "mimesPattern", "muxTemplate", "smetyFormat"], "matcher": [" matter", "mature", "Match", "statcher", "Mather", "mather", "Matching", " mather", "matches", "Matmatch", "disches", "Matter", "stather", " mature", "Mature", "pather", " matmatch", "disure", "dismatch", "Matches", "patter", "discher", "patcher", "match", "matmatch", "matching", " match", "Matcher", "statter", "statching", " matches", "matter", "patch", " matching"], "byteBuffer": ["bbuffer", "noteBuff", "byteVar", "ByteFFER", " byteBuff", " byteVar", "charBuffer", " byteFFER", " byteBuilder", "noteVar", " bytebuffer", "ByteBuffer", "charBuilder", "letterMatrix", "wordbuffer", "bBuffer", "byteMatrix", "letterbuffer", "ByteBuff", "noteBuilder", "byteFFER", "wordBuffer", "charVar", " byteMatrix", " byteFrame", "noteBuffer", "byteBuilder", "wordMatrix", "bFFER", "letterBuffer", "charBuff", "byteFrame", "letterFrame", "Bytebuffer", "wordFrame", "byteBuff", "bytebuffer", "bBuff"], "count": ["cache", "counter", "len", "child", "amount", "ch", "cap", "first", "find", "char", "cc", "continue", "nt", "current", "add", "max", "acc", "last", "number", "all", "start", "buffer", "err", "read", "ount", "val", "call", "num", "result", "comment", "c", "batch", "force", "cont", "conf", "ctr", "sum", "check", "depth", "code", "loop", "length", "total", "iter", "Count", "core", "n", "more", "list", "size", "cycle", "found", "C", "index", "ind"]}}
{"id1": "7044153", "id2": "14609912", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendExceptionToHost", "sendExceptionTOHost", "sendErrorToClient", "sendErrorToHost", "sendExceptionTOServer", "sendExceptiontoHost", "sendExceptiontoClient", "sendErrorToServer", "sendErrortoHost", "sendExceptionToClient", "sendErrortoClient", "sendErrortoServer", "sendExceptionTOClient", "sendExceptiontoServer"], "server": ["port", "remote", "version", "string", "ver", "env", "erver", "v", "description", "localhost", "value", "Server", "host", "serv", "channel", "email", "password", "base", "site", "store", "service", "ser", "code", "address", "test", "client", "null"], "ex": ["ix", "obj", "eas", "exp", "none", "any", "tx", "x", "aux", "it", "fail", "exe", "xc", "rex", "ox", "Exc", "rx", "e", "Exception", "event", "Ex", "err", "wx", "one", "error", "example", "ext", "ry", "exit", "EX", "el", "lex", "com", "expl", "or", "pex", "ic", "an", "test", "exclusive", "exc", "except", "re", "ception", "hex", "nex"], "config": ["cache", "cert", "env", "settings", "Config", "auth", "content", "params", "log", "param", "debug", "context", "channel", "password", "fig", "c", "cfg", "conf", "form", "service", "text", "Configuration", "rc", "input", "figure", "ct", "control"], "prob": ["probes", " prbe", "prbj", "probe", " prbes", "prbes", " prb", "Probj", " prbj", "prb", "prbe", "Prob", "probj", "Probes", "Probe"], "dataSB": ["dataWB", "partialSL", " dataSM", "partialSB", "DATASW", "windowSN", "listBB", "dataGB", "mapBS", "ataNB", "cacheSM", "contentSF", "imageBP", "DATABS", "jsonsb", "partialGB", "relationMB", "mapSB", "valueBS", "imageSF", "keyBS", "ataSF", "relationSB", " dataBB", "ataBP", " dataSN", " dataMB", "windowSB", "cacheBB", "dataBP", "DATASF", "divBS", " dataSW", "imageSB", " dataHB", "relBS", "ataSR", "DATASB", "ataSB", "relationQB", "joinWB", " datasb", "imagesb", "relBB", "mapSL", "listEB", "dataBu", "dataSW", "windowBB", "listMB", "divSN", "nextQB", "datMB", "dataRB", "joinsb", "relationSN", "ataBu", "atasb", "cacheBS", "listSF", "dataMB", "imageSw", "cacheBW", "ataBB", "relationRB", "listsb", "nextBS", " dataSA", "resourcesb", "divSF", "resourceSF", "windowBS", "dataSA", "debugBB", "relationBu", "dataEB", " dataSF", "listSI", "listSB", "divSquare", "mapBB", "cacheSA", "defGB", "mapGB", "divBW", "ataQB", "datWB", "keySL", "dateBu", "windowSL", "joinSL", "nextSB", "divBB", "relationSquare", "relationBS", "nextGB", "contentBS", "relSW", "relationSF", "resourceSI", "defQB", "valueSW", "cacheSF", "imageSN", " dataSI", "dateQB", "dataBS", "divSB", "reasonBS", "debugSF", "reasonSF", "imageQB", "dataBW", "reasonSW", "imageHB", "imageSL", "cacheSB", "relSB", "nextBB", "datasb", "contentSN", "keySB", " dataNB", "jsonSB", "dateSB", "jsonSw", "dataSw", "dataHB", "dataSI", "ataMB", "dataQB", "nextSF", "ataSA", "imageNB", " dataBS", " dataEB", "dataSquare", "defBB", "ataSN", "keyBB", " dataGB", "resourceSB", "mapHB", "imageSM", "reasonSB", "windowSF", " dataQB", "partialBB", "defSB", "mapSF", "divNB", "datSL", " dataBP", " dataSquare", " dataSw", "mapSN", "joinSB", "relationBB", "contentNB", "relationSL", "contentSR", "imageBB", "relationNB", "ataSW", "jsonSF", "dataSF", "dataSL", "dataSM", "dataSN", "datSB", "ataBS", "contentSB", "debugRB", "dataBB", "ataSL", "dateBS", "cachesb", "joinSF", "dataSR", "ataEB", "ataWB", " dataSL", "imageBS", "valueBB", "imageSR", "joinMB", " dataBW", "valueSB", "debugSB", " dataRB", "dataNB"], "trace": ["sequence", "ace", "race", "span", "tr", "tile", "true", "stream", "tty", "message", "sample", "track", "se", "stack", "detail", "temp", "buffer", "network", "debug", "log", "profile", "data", "be", "dump", "batch", "comment", "fake", "time", "role", "report", "te", "feature", "frame", "body", "range", "store", "thread", "chain", "address", "create", "history", " Trace", "test", "table", "stable", "list", "tm", "th", "transform", "mt", "style"]}}
{"id1": "14773780", "id2": "10436471", "code1": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    @Override\n    public Cal3dModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        Cal3dModel model = new Cal3dModel(getFlags());\n        loadCal3dModel(getBaseURL(), url.toExternalForm(), new InputStreamReader(url.openStream()), model);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"testImageInfo": [" testPhotoInfo", " testImagesData", "checkPhotoInfo", " testImagesFile", "checkPhotoList", " testPhotoData", "checkImageInfo", " testImageData", "checkImageFile", "checkPhotoFile", " testImagesList", "checkImageList", "checkImageData", " testImageFile", " testImageList", " testImagesInfo", "checkPhotoData", " testPhotoFile", " testPhotoList"], "IOException": [" IOEx", " IOProblem", "AudioException", "IOEx", "APIException", "AudioProblem", "APIProblem", "AudioEx", "APIEx", "IOProblem"], "start": ["offset", "init", "first", "it", "now", "begin", "before", " started", "birth", "starting", "art", "read", "parse", "id", "step", "base", "from", "time", "send", "wait", "enable", "set", "st", "check", "t", "create", "started", "seed", "wind", " Start", "open", "get", "end", "trans", "reset", "size", "Start", "print", "rest"], "i": ["ix", "name", "im", "bi", "go", "init", "key", "p", "is", "it", "x", "mi", "phi", "gi", "ui", "g", "ex", "si", "major", "info", "u", "b", "gu", "ti", "ci", "me", "multi", "j", "di", "conv", "id", "xi", "f", "m", "batch", "iq", "q", "uu", "y", "ic", "in", "qi", "out", "us", "o", "ai", "I", "s", "to", "n", "my", "pi", "yi", "sim", "index", "ind", "li"], "url": ["mail", "Url", "link", "external", "path", "key", "string", "pattern", "xml", "ul", "r", "u", "mount", "location", "log", "gl", "resource", "host", "id", "dl", "base", "uri", "res", "web", "http", "q", "nl", "el", "str", "ll", "ref", "rel", "l", "null", "lr", "URL", "gif", "ls", "ur"], "istream": ["ositream", "ositiver", "istorage", "istroy", "istable", "ISTstream", "itream", "iptream", "ositrace", "iptorage", "istrace", "iptstream", "itable", "istiver", "intable", "intream", "iststream", "astorage", "astroy", "iptroy", "ISTream", "ISTorage", "aststream", "ISTroy", "astream", "ositable", "itrace", "intiver", "itiver", "intrace"], "ii": ["ni", "nai", "cgi", "ri", "mi", "chi", "gi", "ji", "si", "ini", "hi", "ami", "iu", "irm", "cli", "ista", "iso", "imi", "sci", "cci", "ti", "ci", "zi", "di", "oci", "iov", "xi", "fi", "obi", "iii", "iy", "II", "ei", "qi", "ij", "ki", "iri", "jj", "ai", "vi", "ice", "yi", "pi", "iti", "ati", "ia", "ushi", "li"], "width": ["wy", "len", "path", "wa", "shape", "x", "const", "wn", "dim", "Width", "foo", "w", "dx", "idth", "value", "min", "layout", "data", "fw", "step", "cut", "left", "scale", "body", "draw", "frame", "crop", "text", "widget", "weight", "tall", "write", "length", "wid", "position", "px", "cale", "size", "window", "area", "format"], "height": ["hang", "volume", "radius", "amount", "chip", "gravity", "shape", "stroke", "def", "capacity", "acity", "above", "cue", "grow", "div", "buffer", "rank", "resolution", "h", "padding", "kw", "density", "frame", "depth", "green", "alpha", "history", "angle", "length", "family", "dimension", "rise", "Height", "size", "window", "sky", "style"], "stop": ["delete", "Stop", "obj", "counter", "est", "shape", "jump", "termination", "it", " Stop", "delay", "wake", "peak", "disable", "success", "gc", "quit", "fin", "close", "next", "trip", "hop", "id", "result", "step", "pop", "wait", "enable", "pause", "ops", "set", "st", "no", "loop", "duration", "term", "null", "end", "skip", "period", " STOP", "rest"]}}
{"id1": "3558512", "id2": "6371589", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"serialize": ["serialate", "serialized", "Serializer", "erialate", "erializer", "finalized", "initialization", "serializer", "erialized", "finalization", "finalize", "erialize", "Serialze", "finalze", "Serialate", "serialze", " serialate", "serialization", "Serialization", "initialize", " serialized", "initialze", "initialized", "Serialized", " serializer", "Serialize"], "out": ["up", "ch", "p", "it", "Out", "pool", "stream", "v", "a", "w", "aos", "file", "b", "log", "err", "i", "io", "serv", " OUT", "result", "f", "sw", "c", "res", "report", "sum", "t", "o", "d", "OU", "output", "os", "to", "outs", "OUT", "n", "ou"], "parser": ["aser", "util", "rer", "magic", "writer", "p", "per", "now", "part", "inner", "xml", "loader", "job", "tp", "layer", "file", "ker", "Parser", "ger", "walker", "builder", "jack", "parse", "manager", "bank", "plan", "processor", "password", "arser", "base", "handler", "lp", "worker", "peer", "command", "instance", "tar", "asser", "language", "er", "proc", "pkg", "policy", "tree", "ler", "token", "reader", "style", "format"], "on_disk": ["on_link", "On2disk", "on_Disk", "on2Disk", " on_disc", "on_download", "On2link", "On_file", "On_Disk", " on_Disk", "on_volume", "On_cloud", "on_file", "On_link", "On2Disk", " on_volume", "on2link", " on_download", "on_dis", "On_disk", "on_disc", "on2file", " on_file", "on_cloud", "On2file", "on2disk", " on_dis"], "in": ["inn", "inc", "mi", "is", "it", "ain", "and", "sin", "inner", "isin", "r", "din", "min", "bin", "i", "io", "gin", "ad", "on", "id", "from", "In", "body", "ins", "inside", "en", "IN", " din", "input", "cin", "rin", " IN", "vin", "inf", "ind"]}}
{"id1": "8000624", "id2": "14093044", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "label": 0, "substitutes": {"CopyTo": [" copyFrom", " copiesTo", " copiesInt", "CopyFrom", " copiesFrom", " CopyInt", " CopyFrom", " copyTo", " copyInt", "CopyInt"], "dest": ["name", "origin", "path", "orig", "nom", "est", "p", "image", "Dest", "it", "pipe", "v", "src", "fn", "target", "copy", "w", "temp", "source", "filename", "opt", "tmp", "result", "txt", "cont", "st", "img", "mem", "them", "loc", "usr", "d", "output", "dir", "null", "th", "sp", "cat", "rest"], "in": ["inn", "ire", "al", "inc", "up", "init", "image", "is", "per", "ac", "ain", "it", "mi", "sin", "inner", "isin", "ini", "r", "din", "file", "min", "source", "nin", "bin", "i", "ir", "internal", "read", "gin", "local", "one", "ar", "win", "on", "m", "from", "login", "In", "ins", "inside", " input", "en", "t", "IN", "o", "by", "l", "client", "iter", "con", "ai", " din", "cin", "rin", "input", "re", "net", "reader", "inf", "ind", "thin"], "out": ["obj", "up", "not", "other", "ln", "writer", "full", "it", "Out", "inner", "v", "ex", "nt", "fn", "oe", "w", "outer", "flush", "e", "dis", "aos", "ns", "b", "all", "cos", "io", "one", "conv", "gt", "user", "batch", "res", "ot", "cn", "loss", "op", "t", "en", "at", "o", "ne", "by", "write", "output", "client", "os", "null", "boot", "to", "oss", "end", "co", "con", "outs", "OUT", "na", "list", "net", "note", "can", "n", "ou"], "c": ["character", "cap", "cs", "ch", "ac", "bc", "ec", "char", "cb", "cc", "cd", "arc", "g", "v", "current", "u", "e", "cl", "gc", "i", "k", "f", "uc", "unc", "cont", "cut", "conf", "nc", "code", "t", "lc", "d", "cm", "cf", "l", "sc", "con", "count", "rc", "cr", "ca", "z", "cod", "ce", "cat", "C", "n", "cp", "ct"]}}
{"id1": "1188100", "id2": "15768167", "code1": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"test": [" evaluate", "execute", "unit", "server", "est", "tested", "some", "sample", "Testing", " TEST", "testing", "debug", " Test", "example", "Test", "evaluate", " testing", "tests", "store", "check", " tests", "load", "show", "print", "use"], "s": ["sm", "cs", "ws", "is", "sq", "ts", "p", "bs", "still", "comm", "rs", "socket", "sa", "stats", "ats", "ps", "v", "ds", "w", "ns", "sb", "e", "so", "b", "sys", "session", "i", "gs", "S", "h", "ssl", "sports", "ss", "sd", "xs", "less", "j", "ses", "sw", "sv", "c", "m", "fs", "sts", "abs", "sl", "http", "south", "status", "sql", "y", "details", "st", "service", "store", "ms", "t", "spec", "pers", "https", "l", "aws", "os", "sc", "js", "z", "qs", "self", "ls", "n", "state"], "input": ["iterator", "active", "ahead", "ip", "initial", "image", "this", "inner", "stream", "current", "sample", "feed", "json", "file", "hello", "source", "start", "buffer", "i", "read", "io", "context", "data", "media", "accept", "cont", "form", "in", "inside", "text", "Input", "output", "get", "open", "null", "request", "my", "reader", "raw", "upload"], "writer": ["writers", "writing", "Writer", "external", "wrote", "operator", "inner", "stream", "loader", "wright", "w", "writ", "temp", "file", "buffer", "her", "builder", "manager", "processor", "wire", "handler", "storage", "written", "driver", "maker", "winner", "worker", "caster", "draw", "console", "service", "widget", "riter", "out", "rew", "editor", "write", "woman", "output", "term", "word", "creator", "to", "end", "WR", "player", "reader", "window", "format"]}}
{"id1": "3330775", "id2": "9033639", "code1": "    public static JSONObject getJSONData(String url) throws JSONException {\n        JSONObject jObject = null;\n        InputStream data = null;\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        URI uri;\n        try {\n            uri = new URI(url);\n            HttpGet httpGet = new HttpGet(uri);\n            HttpResponse response = httpClient.execute(httpGet);\n            data = response.getEntity().getContent();\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader;\n            reader = new BufferedReader(new InputStreamReader(data), 8192);\n            while ((line = reader.readLine()) != null) builder.append(line);\n            reader.close();\n            jObject = (JSONObject) new JSONTokener(builder.toString()).nextValue();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return jObject;\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"getJSONData": ["getJSONResponse", "loadjsonContent", "getjsonData", "loadJSONContent", "loadjsonData", "getJSONObject", "getBasicContent", "getJData", "getjsonContent", "getJResponse", "getJSONContent", "getBasicResponse", "getJContent", "loadjsonResponse", "loadJSONResponse", "getJObject", "loadJSONData", "getjsonObject", "loadjsonObject", "loadJSONObject", "getBasicData", "getjsonResponse", "getBasicObject"], "url": ["remote", "Url", "name", "util", "link", "pl", "path", "lim", "string", "pattern", "ret", "json", "file", "location", "b", "log", "i", "ssl", "host", "id", "result", "dl", "base", "web", "http", "nl", "sl", "str", "ll", "item", "address", "loc", "rel", "l", "URL", "ls", "ur", "href", "ul", "addr"], "jObject": ["jobject", "jDocument", "jpNull", " jObj", "jpObject", "jsonNull", "jData", " jAnonymous", "jsonDocument", "jsonobject", "reportDocument", "reportObject", " jobject", "jsonObject", "objDocument", "jObj", " jNull", "objData", "jpAnonymous", " jData", "jAnonymous", "jsonAnonymous", "jpobject", "jsonData", " jDocument", "jNull", "reportObj", "jsonObj", "reportData", "objObject", "objObj"], "data": ["name", "sequence", "cache", "html", "image", "string", "ata", "stream", "message", "sample", "content", "feed", "json", "value", "source", "buffer", "session", "resource", "dat", "results", "ad", "aw", "error", "media", "dev", "result", "done", "mu", "body", "details", "or", "text", "api", "no", "ne", "output", "block", "DATA", "input", "trans", "size", "window", "bytes", "area", "raw"], "httpClient": ["httpsBuilder", "ttpGet", "httpControl", "Httpclient", "httpBuilder", "httpsControl", "httpsGet", " httpBuilder", "ttpClient", "HttpClient", "httpsclient", "HttpControl", "HttpContext", "httpsContext", "httpsClient", "ttpContext", "HttpBuilder", "HttpGet", "ttpclient", "httpclient", " httpControl", "httpContext", " httpclient"], "uri": ["remote", "cp", "Url", "link", " ur", "util", "hub", "server", "origin", "ri", "domain", "path", "ip", "qu", "phi", "char", "ui", "via", "URI", "subject", "hi", "u", "source", "location", "point", "i", "resource", "archive", "host", "manager", "lu", "base", "hu", "http", "du", "range", "qi", "address", "nu", "api", "ref", "client", "iri", "term", "ilo", "connection", "URL", "pi", "ur", "directory", " URI", "uni", "uu"], "httpGet": ["htmlGet", "hGate", "htmlQuery", "httpGET", "HTTPGET", "hGet", "hGET", "httpQuery", "httpPut", "HTTPQuery", " httpQuery", "httpGate", "htmlGate", " httpPut", "HTTPPut", "hQuery", "HTTPGet", " httpGate", " httpGET", "htmlPut", "htmlGET"], "response": ["remote", "yes", "server", "answer", "image", "resp", "version", "socket", "still", "description", "message", "json", "success", "hello", "pos", "opening", "resolution", "resource", "context", "next", "respond", "result", "application", "successful", "report", "http", "page", "status", "body", "frame", "Response", "service", "object", "onse", "output", "client", "block", "connection", "request", "reply", "document"], "line": ["name", "link", "sequence", "online", "len", "ln", "key", "liner", "header", "stroke", "ine", "part", "message", "sample", "entry", "entity", "e", "label", "Line", "file", "number", "point", "log", "next", "LINE", "eline", "user", "error", "comment", "lin", "nl", "page", "status", "cell", "frame", "text", "code", "chain", "phrase", " Line", "l", "word", "block", "ice", "row", "inline", "field", "print", "column"], "builder": ["name", "ward", "alph", "building", "writer", "full", "bean", "operator", "order", "inner", "loader", "message", " builders", "board", "utils", "sb", "oster", "der", "number", "b", "ener", "buffer", "lower", "black", "parser", "build", "uf", "join", "ender", "bar", "library", "builders", "lu", "Builder", "base", "web", "trace", "language", "sf", "er", "by", "length", "atter", "built", "upper", "row", "fb", "eng", "control", "BU"], "reader": ["iterator", " readers", "util", "where", "ri", "writer", "per", "older", "reading", "inner", "stream", "loader", "message", "r", "ator", "entry", "oder", " writer", "e", "buffer", "ger", "read", "parser", "rar", "dra", "record", " read", "roller", "handler", "driver", "worker", "peer", "ner", "rl", "range", "Reader", "er", "bo", "ro", "iter", "mr", "row", "runner", "readable", "dd", "field", "river", "dr", "wrapper"]}}
{"id1": "160739", "id2": "21824901", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createFileSteam", " createInputstream", "createOutputSteam", "createOutputFile", "createInputStream", " createOutstream", " createOutFile", "createInputstream", " createInputStream", "createInputFile", " createFileStream", " createInputSteam", " createOutputstream", " createFilestream", " createFileFile", " createInputFile", " createOutSteam", "createOutputstream", "createInputSteam", " createOutputSteam", " createOutputFile", " createOutStream"], "inFile": [" inPath", " inFilename", "outFilename", "inputPort", "outfile", "dinPort", "ninFilename", "dinFile", " inDir", "inputDir", "ninPath", " infile", "inFilename", "dinPath", "inPath", "inputPath", "dinDir", "infile", " inPort", "inputFile", "inPort", "outPath", "ninfile", "inDir", "ninFile"], "outFile": ["OutFilename", "exFile", "outFilename", "OutPort", "outputFile", "outfile", "newPlace", "outputfile", "outPlace", "Outfile", "exfile", "toFile", "outPort", "inFilename", "exFilename", "outputFilename", "outputPlace", "infile", "toFilename", "newfile", "exPlace", "newFile", "inPort", "OutFile", "newFilename", "tofile", "toPort"], "k_blockSize": ["k_byteTime", "k2blockLength", "k_blockLength", "k_BlockLength", "k_byteName", "k2byteTime", "k4BlockStyle", "k_byteStyle", "k_BlockStyle", "k_blockName", "k4blockSize", "k_byteLength", "k_BlockCount", "k2blockCount", "k_byteCount", "k4BlockSize", "k_BlockName", "k_blockStyle", "k4blockStyle", "k2byteCount", "k2byteSize", "k4BlockCount", "k_BlockSize", "k4blockCount", "k4BlockName", "k_batchTime", "k_BlockTime", "k_batchLength", "k4blockName", "k_blockCount", "k_batchCount", "k_blockTime", "k2byteLength", "k2blockSize", "k_byteSize", "k_batchSize", "k2blockTime"], "byteCount": ["blockCounter", "charPtr", "bbCount", "bbSize", "blockCount", "bitSize", " bytePtr", "charCount", "lineLength", "wordSize", "blockLength", "byteCounter", "byteCode", "wordN", "bitCounter", "linecount", "bytePtr", "lineCount", "blockCheck", "bytecount", "bitCheck", "linePtr", " byteCounter", "wordCount", " byteCheck", "bitCount", "bitN", " bytecount", "bitLength", "byteN", "charLength", "byteSize", "wordCode", "charcount", " byteLength", "bbCode", "byteCheck", "bitCode", "byteLength", "bbN"], "buf": ["bn", "msg", "cap", "bg", "alph", "exp", "cv", "bc", "tx", "cb", "bl", "seq", "cmd", "b", "buffer", "uf", "Buffer", "conv", "queue", "batch", "txt", "arr", "ctr", "fg", "img", "bag", "str", "Buff", "mem", "buff", "cast", "cur", "proc", "pb", "vec", "pkg", "db", "doc", "ctx", "block", "rb", "cat", "bytes", "raw"], "ofp": ["OfP", "Ofl", "owld", "OFP", "OFl", " ofpa", "ofpa", "Ofp", "owlp", "Ofd", " ofl", "owlpa", "ofP", " ofP", "Ofpa", "OFp", "OFd", "owlP", " ofd", "ofd", "ofl"], "zos": ["zip", "zh", "tis", "zin", "init", "zag", "ws", "zo", "css", "settings", "bs", "socket", "sbm", "ps", "zers", "hess", "sis", "amia", "zona", "zon", "cos", "gs", "ossus", "es", "zi", "hz", "zes", "rez", "ez", "zzle", "rose", "LOS", "osi", "webkit", "zl", "south", "zik", "rss", "std", "python", "nz", "zy", "bes", "za", "jp", "los", "esa", "cz", "os", "jas", "eros", "oss", "sch", "enos", "z", "js", "psy", "zer", "zb", "zu", "zen", "ze"], "osw": ["sysW", "cosws", "oW", "cosd", "osd", "oswx", " osws", "oswd", "aosw", " osW", "opace", "iswx", "ossw", "osiwa", "aosew", "ossrw", "ow", "aosW", "osswx", "isw", "aospace", "aosws", "aosrw", "ossW", "osws", "osiw", "osswd", "issw", "sysrw", "isW", "aoswd", "cosw", "aoswa", " osd", "oswa", "osW", "osiW", "owa", " osew", "osrw", "syswd", "osew", "sysw", "osssw", "aosd", "cosew", "ospace", " oswx", "osipace", " ossw"], "bw": ["rbw", "bwt", " bex", "rbex", "bsw", " bws", "pbwy", " bwt", " bz", "pbwb", "pbew", "obw", "abwe", "bwl", "bbwt", "bwb", "sbwb", "sbwt", "bbex", "wbwt", "wbz", " bsw", "bwp", "bbw", "rbz", "bbx", "pbz", "bwy", "bwe", "bem", "obwb", "bws", "wbx", " bem", "obwt", "obwk", "obz", "abwy", " bend", "wbem", "sbz", "bewk", " bwp", "abew", "nbew", "bx", "abw", "pbwe", "nbw", "nbwe", "bend", "nbwy", " bx", "bex", " bwl", "wbw", "wbwp", "rbws", "wbend", "bwk", "bbws", "bbz", "sbw", "obwl", "bewl", "bz", "besw", "bbend", "pbwt", "bew", " bwk", "obsw", "pbw", "bbwp", "bbem"], "zot": [" ziot", " zonet", " zote", " zo", "zor", "ziphot", "zipot", "zerot", "zo", "zeror", "Zit", " zor", " zhot", "zott", "zerit", "zoo", "zoonet", "zerote", "ziot", "zote", "zoor", "zipiot", "zero", "Zote", "zonet", "zoot", "zeronet", " zott", "zhot", "zeriot", "zipiat", "zerhot", "Zot", "ziat", " ziat", "Zott", "zerott", "zeriat"], "ifp": ["isjp", "Ifjp", "isth", "Ifth", "iwd", "IfP", "iftp", "iwr", "ihr", " ifjp", "ihtp", "ihd", "isp", "iwp", "ifth", " ifd", "isP", "iwtp", "ifd", " ifr", " ifP", "ihp", "ifjp", "Ifp", "ifr", "ifP", " ifth", " iftp"], "zis": ["izi", "zinit", "zisc", "ziisa", "zois", " zIS", "ziinit", "ezis", "ezisc", "ezi", "izisa", "zeric", "zoinit", "eziss", "izinit", "zIS", "zoiss", "zipIS", "zipic", "zi", "iziss", " ziss", "zeris", "izisc", "zoisa", " zi", "zisa", "ziss", " zisc", "zipis", " zic", "ziis", "zerIS", "ziiss", "izis", "zic"], "isr": ["iossr", "iosr", "itspr", "sisrs", "iosstr", "isalstr", "isalsr", "isalr", "isalpr", "issrc", "sisr", "isrs", "isscr", "isstr", "isrc", " isrc", "issr", "iospr", "itssr", "siscr", "itsstr", "ispr", "sisrc", "issrs", " iscr", " isrs", "itsr", "iscr"], "br": ["bn", "bi", "Fr", "tr", "BR", " Br", "bh", "bl", "hr", "r", "sr", "Br", "b", "wr", "bd", "ber", "ba", "ptr", "bp", "vr", "ctr", "bf", "bj", "str", "pr", "bm", "rel", "obl", "shr", "bt", "bro", "gr", "mr", "cr", "lr", "rb", "fr", "js", "dr", "kr", "yr"], "zit": ["zip", "zipit", "zipIT", "ziIt", "zist", "ziit", "lexit", "izunit", "ziIT", "ziti", "ozit", "ezit", "zIt", "lexist", "zlit", "zop", "oziti", "izit", "zeot", "zeop", " zite", "czit", "ezite", "czip", "ozunit", "zeip", "ezlit", "zite", " zop", " zIT", "zipIt", "ziplit", "iziti", "ozip", " zip", "zunit", "zIT", "ziist", "lexIT", "lexIt", "czop", "czot", "zipite", "zeit", "cziti", "zipist", "izip", "czunit", "ezIT", " zlit"]}}
{"id1": "15896098", "id2": "10795866", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 0, "substitutes": {"getSHA256Checksum": ["getSHA256Checkchecksums", "getSHA256Checkcksume", "getSHA256Checkchecksume", "getSHA256Checsums", "getSHA256Checksam", "getSHA256Checkums", "getSHA256Checksums", "getSHA256Chechecksum", "getSHA256Chechecksam", "getSHA256Checkchecksum", "getSHA256Checsum", "getSHA256Checsume", "getSHA256Checkcksum", "getSHA256Checkcksums", "getSHA256Chechecksume", "getSHA256Checkume", "getSHA256Chechecksums", "getSHA256Checkcksam", "getSHA256Checksume", "getSHA256Checkum", "getSHA256Checsam", "getSHA256Checkchecksam", "getSHA256Checkam"], "source": ["Source", "name", "url", "sequence", "path", "image", "string", "this", "ource", "src", "message", "sample", "subject", "target", "content", "value", "file", "filename", "buffer", "context", "reason", "data", "template", "base", "from", "status", "body", "in", "text", "out", "seed", "output", "s", "input", "SOURCE", "style", "secret", "raw", "format"], "checksum": ["checkum", "cksume", " checkssum", "checkume", "cssum", "checkumb", "checksim", " checksums", "checkssum", " checksume", "csim", "checkim", "ckssum", "checksume", " checksumb", "csume", "checksums", "cksim", "cksums", "cksum", "checksumb", " checksim", "cksumb", "checkums", "csum"], "md": ["sm", " MD", "dr", "mt", "wd", "def", "cd", "mb", "MD", "nt", "dm", "dh", "mo", "mm", "der", "od", "cmd", "grad", "hd", "ind", "bd", "sd", "mod", "ad", "di", "ld", "m", "det", " Md", "down", "Cmd", "pm", "mp", "red", "ms", "mg", "mn", "d", "mand", "dd", "mc", "pdf", "mk", "df", "pd"], "byteData": ["byteRel", "ByteBytes", "ioDATA", "routeDATA", "sliceDat", "bytesData", "byteParts", "wordArray", "routeData", "ioDat", "ioData", "bleRel", "ByteParts", "reverseDat", " byteParts", "bytedata", "wordData", "channeldata", "channelRel", "reverseDATA", "reverseCount", " byteCount", "byteCount", "ioList", "phraseBytes", " bytedata", "channelData", "wordBytes", "channelParts", "ByteData", " byteArray", "phraseData", "ByteDATA", "bytesDATA", "bleData", "sliceList", "bytesArray", "phraseParts", "byteDATA", "reverseData", "sliceDATA", "routeCount", "byteDat", " byteDATA", "byteArray", "bleParts", "routeDat", " byteDat", "bytesBytes", "sliceData", " byteList", " byteBytes", "bledata", "wordDATA", "byteList", "byteBytes", "phraseDATA", " byteRel"], "sb": ["sm", "erb", "bg", "ib", "SF", "sq", "shell", "bs", "cb", "mb", "si", "sa", "bh", "sbm", "sh", "nb", "lb", "b", "ssl", "bsp", "bb", "sg", "sam", "sw", "sv", "lp", "eb", "bash", "bis", "gb", "bj", "bf", "sf", "wb", "ub", "kb", "pb", "db", "obb", "bt", "ob", "rb", "SB", "zb", "sp", "bps", "xb"], "i": ["ix", "im", "ime", "phi", "ui", "hi", "major", "info", "ski", "gu", "io", "ci", "multi", "di", "uri", "ic", "set", "ity", "ei", "qi", "I", "list", "my", "sim", "ind", "ii", "si", "life", "iu", "series", "point", "xi", "m", "ki", "remote", "ip", "ri", "this", "g", "u", "cli", "json", "\u0438", "err", "me", "id", "q", "y", "ims", "ms", "ij", "chain", "history", "loop", "o", "ai", "ie", "print", "bi", "init", "oi", "any", "mi", "it", "gi", "ji", "ini", "ion", "ti", "j", "iy", "er", "l", "client", "to", "pi", "iq", "li"], "hexString": ["hexResource", "hashstring", "shortArray", "fullBuffer", " hexArray", "htmlBuffer", "hexArray", "hexStore", " hexstring", " hexBuffer", "htmlstring", "exArray", " HexResource", " HexBuffer", " hexResource", "htmlString", "fullStore", "exString", "hashArray", "exBuffer", "shortstring", "hashString", " hexStore", "shortString", "exstring", "shortBuffer", "fullstring", " HexString", "hashBuffer", " Hexstring", "fullString", "shortResource", "htmlArray", "hexstring", "hexBuffer", "exStore"], "hex": ["zh", "hl", "php", "html", "comp", "exp", "alph", "none", " ex", "full", "tx", "x", "tex", "def", "sh", "rex", "ex", "temp", "json", "hello", "lit", "ph", "alias", "h", "prop", "sex", "ext", "dump", " Hex", "cont", "mix", "solid", "oct", "he", "com", "form", "pex", "des", "rh", "term", " sex", "flash", "cat", "rendered", "raw"]}}
{"id1": "6966398", "id2": "8135072", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"reader": [" readers", "ri", "rer", "writer", "older", "this", "rs", "stream", "inner", "ocr", "loader", "r", "rr", "sr", "rx", "redo", "file", "query", "buffer", "builder", "read", "parser", "io", "rar", "cer", " read", "roller", "handler", "driver", "ner", "rl", "Reader", "er", "ro", "iter", "mr", "rc", "lr", "row", "runner", "input", "rot", "dr", "wrapper"], "ks": ["KS", "ls", "ces", "obs", "cs", "kies", "uk", "icks", "ols", "ips", "bs", "sk", "cks", "ars", "ds", "ck", "kk", "ups", "eks", "agles", "ys", "k", "keys", "ss", "uds", "nets", "kas", "ses", "ans", "fs", "km", "ms", "ki", "vs", "kb", "eps", "akes", "kes", "ke", "oss", "ros", "checks", "qs", "ates", "hs", "kens", "mk", "kr", "sky"], "key": ["link", "obj", "mk", "power", "x", "ssh", "char", "sk", "ox", "info", "entry", "file", "k", "keys", "KEY", "user", "root", "password", "cer", "Key", "base", "type", "sign", "y", "object", "service", "ey", "hash", "er", "by", "client", "ke", "null", "core", "ek", "ca", "my", "trust", "pair", "tk", "sky", "owner"], "chain": ["sequence", "cache", "group", "path", "string", "ver", "pool", "stream", "stack", "number", "file", "channel", "sche", "bank", "Chain", "data", "root", "password", "box", "pair", "result", "batch", "base", "c", "type", "trace", "form", "frame", "range", "check", "hash", "piece", "code", "binary", "test", "table", "component", "family", "block", "chains", "ca", "list", "ce", "sign", "can"], "os": ["bos", "oes", "obs", "cs", "ose", "Os", "ols", "is", "ts", "css", "bs", "uts", "oS", "ps", "ox", "ds", "aos", "oso", "pos", "sys", "cos", "ys", "io", "OS", "osi", "fs", "oids", "ot", "ops", "ios", "ms", "us", "out", "o", "oses", "los", "oss", "js", "ls", "oos"], "stamper": [" stamter", " stummer", "stimper", " stramper", "stramPER", " stamPER", "stumter", "println", " stramPER", " stumter", "New", "annot", "def", "this", "stumper", "stamPER", " stammer", " stumpler", " stimmer", "stAmper", "stumpler", "important", "read", "stamter", "stAmmer", "stammer", "stAmpler", "stAmPER", " strampler", "Print", " stampler", "The", "strampler", "stampler", " stcampler", " strammer", "good", "_", "valid", "font", " stumper", " stcammer", "stimmer", "stummer", " stimper", "stramper", "stimPER", " stimter", " stcamter", " stimpler", "stimpler", "strammer", " stcamper"], "appearance": ["displayeared", "acreciation", "ascearance", "apeared", "appendix", "atteared", "Appearance", "displaylies", "acearance", "accears", " appearing", "Appeared", "acclies", "aplies", "displayearing", "displayendix", "appearing", "accearance", "applies", "displayearance", "attearance", "appearances", "attlies", " appendix", "aceared", "displayearances", "apearances", "displayears", "Applies", "apearance", "suppeared", "appears", "accearances", "ascearances", " appeared", "appreciation", "ascears", "Appearances", "acearances", "apreciation", "apearing", "ascearing", "suppearances", " appearances", "patternendix", "suppearance", "displayreciation", "appeared", "attearances", "apears", "patternearing", "patternearance", "patternearances"]}}
{"id1": "17996547", "id2": "20663364", "code1": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyDir", "CopyFile", "deleteFiles", "deleteDir", "CopyFiles", "Copyfile", "copyDir", "deleteFile", "CopyDir", "deletefile", "copyfile", " copyFiles", "copyFiles", " copyfile"], "fileToCopy": ["FILETOCopy", " filetoDelete", "fileToWrite", "fileToApply", "fileToDelete", "FILETOCop", "fileTOSave", " filetoRemove", "fileFromCopy", "fileTomDelete", " fileToRemove", "fileToCop", "file2Save", "FILETOApply", "filetoCopy", "filetoRemove", "filetoDelete", "fileTOApply", "fileTOCop", "fileToSave", "fileTomRemove", "fileFromRemove", "FILEToApply", "FILEToCop", "FILEToCopy", "file2Copy", "fileFromWrite", "FILETOSave", "file2Apply", " fileToDelete", "filetoWrite", "fileTOCopy", "fileToRemove", " filetoCopy", " filetoWrite", " fileToWrite", "fileTomCopy", "file2Cop", "FILEToSave", "fileTomWrite", "fileFromDelete"], "copiedFile": ["copifiedPlace", " copiedPath", "calledyingDir", "coricedfile", "copyingDir", "copriedfile", "copyingLog", "coriedFILE", "copriedLog", "callediedPlace", "coponeFilename", "calledyingFile", "coponeFILE", "copifiedFilename", "partriedFile", "copcedFile", "calledyingPlace", "coriedFilename", "copiedPlace", "coponefile", "copicedFile", " copriedPath", "copiatedPath", "callediedFILE", "copIEDLog", "copcedfile", "copriedPath", "copriedFile", "copicedfile", "copiedFILE", "copyingFolder", " copiedDirectory", "copriedFolder", "copanedPlace", "copanedFILE", "copIEDFile", "copyingPlace", "copiatedDirectory", "partiedFile", "copifiedFile", "copriedDirectory", " copriedFile", "copcedFilename", "copyingFilename", "copiedDir", "coricedFile", " copcedfile", " copcedFile", "copiatedFile", "copiedPath", "copriedFilename", "partriedFilename", "copicedFILE", "coriedFile", "copiedFolder", " copriedDirectory", " copriedFolder", "copifiedFILE", "calledyingFILE", "copyingDirectory", "copanedFile", "callediedFile", "partriedLog", " copiedfile", "copriedFILE", "copiedFilename", "coricedFilename", "copyingFILE", "copiedfile", " copcedFilename", "coricedFILE", "copyingFile", "coriedfile", "copiatedFolder", "copifiedfile", "copyingPath", "copiedDirectory", "copicedFilename", " copiedFilename", "partiedLog", "copifiedDir", "copiedLog", " copiedFolder", "coponeFile", "callediedDir", "copIEDFilename", "copanedDir", "partiedFilename"], "in": ["inn", "im", "al", "inc", "up", "init", "is", "it", "per", "ain", "inv", "inner", "isin", "ini", "r", "din", "irm", "file", "source", "bin", "i", "io", "read", "gin", "on", "f", "from", "In", "conf", "form", "ins", "inside", "en", "out", "ains", "IN", "doc", "get", "con", "iter", "ma", "ai", " din", "cin", "input", "rin", "re", "ar", "vin", "inf", "oin", "ind"], "outWriter": ["innerHandler", " outWrit", " outwriter", "OUTwriter", "outWriting", "OUTWriting", " outHandler", " outWrite", "outWrite", "outStream", "outputWrite", "innerStream", "backWriter", "OUTReader", "outputWriting", " outWriting", "outReader", "innerWrite", "innerWriter", "outwriter", " outReader", "backStreamer", "outStreamer", "outputReader", "OutReader", "backwriter", "OutWriter", "backReader", "outputHandler", "OUTWriter", " outStreamer", "outputWrit", "OutWrit", "outputwriter", "outHandler", " outStream", "outWrit", "OutWriting", "outputWriter", "outputStreamer", "outputStream"], "c": ["character", "pc", "cap", "cache", "cs", "ch", "ac", "bc", "cmp", "ec", "char", "cc", "cb", "cd", "v", "r", "u", "e", "cl", "gc", "cos", "i", "k", "col", "f", "uc", "m", "unc", "cont", "cut", "q", "nc", "code", "t", "chain", "out", "lc", "dc", "d", "cm", "l", "cf", "sc", "count", "rc", "cr", "ce", "mc", "C", "n", "cp", "ct"]}}
{"id1": "14609912", "id2": "8135072", "code1": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 0, "substitutes": {"lastModified": ["lastModification", "LastModmented", "lastModUsed", "LastVermented", "LastVerified", "lastMinUsed", "lastVerified", "LastModified", "LastVerification", "lastMinification", "lastModmented", "lastQualification", "lastQualmented", "lastVermented", "lastVerUsed", "LastModUsed", "lastQualified", "lastMinified", "LastVerUsed", "lastMinmented", "lastVerification", "lastQualUsed", "LastModification"], "url": ["Url", "name", "link", "cert", "key", "string", "char", "ret", "job", "run", "mount", "cmd", "file", "dll", "b", "ssl", "host", "build", "user", "dl", "abs", "uri", "web", "nl", "http", "page", "sl", "in", "str", "ll", "browser", "address", "ref", "un", "l", "client", "get", "URL", "re", "ur"], "conn": ["cons", "obj", "ch", "cert", "resp", "socket", "addr", "comm", "cb", "enc", "nt", "connect", "cmd", "fin", "close", "dat", "serv", "j", "conv", "c", "res", "pas", "cell", "nc", "sql", "cur", "canon", "gate", "loc", "jp", "db", "ctx", "client", "open", "con", "connection", "n", "oss", "nec", "exec", "Conn", "net", "ct", "cn"]}}
{"id1": "22479286", "id2": "7761195", "code1": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"md5": ["md3", " MD3", " MD2", "md4", "MD2", " MD4", "MD5", "MD4", " md4", "MD3", " MD5", " md3", " md2", "md2"], "plainText": ["batString", "ainDelete", "plainSync", "ainTerm", "richTEXT", " plainForm", "batText", "ainSync", "positionString", "longTEXT", "richPrint", "initialTrans", "initialText", "ainMessage", " plainDelete", " plainTEXT", "maintext", "ainText", "altPrint", "plainForm", "richString", "mainText", "plainMessage", "plainDelete", "flatMessage", "mainTEXT", "fullPrint", "plainTerm", "externalTEXT", "ainString", "longPrint", "ainForm", "batTerm", "batSync", "externalDelete", "flatText", "mainString", " plaintext", "flatTEXT", "plainString", "altTEXT", " plainTrans", "altString", "flatForm", "ainTEXT", "positionTEXT", "aintext", "positionText", "fulltext", "plaintext", "externalString", " plainMessage", "positiontext", "fullText", "externalText", "longText", "longString", "initialtext", " plainTerm", "fullString", "richText", "altText", "plainTEXT", "alttext", "ainTrans", "plainTrans", "ainPrint", " plainString", " plainSync", "initialString", "plainPrint"], "md": ["sm", " MD", "mt", "cd", "mb", "MD", "nt", "add", "dm", "dh", "mm", "man", "der", "od", "cmd", "ng", "hd", "ind", "grad", "bd", "de", "mac", "h", "sd", "mod", "ad", "di", "ld", "m", "det", "pdf", " Md", "down", "pm", "mp", "red", "ms", "mg", "desc", "mn", "d", "dir", "mand", "dd", "mc", "dr", "mk", "df", "pd"], "digest": ["Digest", "presentested", "presentest", " digity", "mdEST", "candidate", "candest", "compute", " digested", "digity", "Digity", "defEST", "digidate", "presentute", "mdest", "defested", "digse", "presentEST", "digests", "Digum", "candum", " digse", "Digidate", "digum", "candute", "defest", "digested", "compidate", "presentests", " digests", " digEST", "digEST", "digute", "defse", "presentity", "DigEST", "Digests", "compum", "compest", "Digested", " digute", "mdse", "Digute", "mdested"], "hexString": [" hexSingle", "expstring", "exSingle", "charBuffer", " hexArray", "charString", "charArray", "hexArray", " HexText", " hexstring", " hexBuffer", "rexArray", "exArray", "charText", " HexBuffer", "expBuffer", "exText", "exString", "rexString", "expString", "exBuffer", "expText", "hexSingle", "hexText", "rexSingle", " hexText", "rexBuffer", " HexString", " Hexstring", "hexstring", "hexBuffer"], "i": ["ix", "im", "bi", "ip", "init", "key", "is", "it", "x", "mi", "gi", "phi", "ui", "ji", "si", "v", "a", "g", "ex", "info", "index", "hi", "u", "\u0438", "iu", "b", "ski", "gu", "err", "io", "ci", "ti", "me", "j", "multi", "di", "conv", "id", "xi", "m", "c", "batch", "uri", "ii", "sim", "q", "y", "ic", "in", "set", "qi", "chain", "ai", "I", "to", "z", "ie", "my", "pi", "yi", "iq", "n", "ind", "li"]}}
{"id1": "20602651", "id2": "11562165", "code1": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 0, "substitutes": {"readURL": ["writeUR", "readUR", "loadUR", "readsURI", "writeUrl", "readsUrl", "writeURL", "writeURI", "readUrl", "readsUR", "readsURL", "readURI", "loadUrl", "loadURI", "loadURL"], "url": ["Url", "link", "name", "html", "key", "string", "char", "xml", "r", "job", "cl", "mount", "file", "b", "location", "log", "gl", "ssl", "build", "email", "bel", "kl", "base", "dl", "abs", "uri", "web", "http", "nl", "sl", "el", "rl", "str", "ll", "browser", "address", "rect", "rel", "l", "get", "URL", "print", "ur", "ul"], "istream": ["istob", "isem", "ismREAM", "oststream", "istsrace", "istroy", "istREAM", "ISTstream", "isdrace", "ostREAM", "isriver", "isroy", "istsore", "isream", "istrace", "istsstream", "istsream", "istore", "introy", "isdriver", "intream", "isstream", "istsriver", "iststream", "isob", "ostore", "ismream", "istsob", "intstream", "israce", "ISTream", "istsREAM", "istStream", "intStream", "ISTroy", "istsem", "isdob", "istriver", "ismstream", "istem", "ismore", "isdstream", "isdream", "isdem", "ISTStream", "isStream", "ostream"], "isr": ["asr", "aser", "sisrr", "itser", "siser", "risrd", "Isrs", "risr", " israr", "itsrar", "Isr", "Israr", "ISrs", "itsrr", "esrc", "sisr", "issrc", "isrd", "ISrt", "isrs", " iser", "isscr", "isrt", "isrc", "esrd", "issr", "Iscr", "ISer", " isrr", "issrar", "israr", " isrt", "esrar", "iser", "esr", "asrs", "isrr", "issrd", "issrs", " iscr", " isrs", "itsr", "ISr", "sisrar", "risrc", "iscr", "asrt", "risrar"], "in": ["inn", "name", "inc", "pin", "ln", "init", "del", "is", "it", "and", "inner", "isin", "add", "r", "din", "ind", "update", "nin", "bin", "i", "asin", "read", "gin", "user", "on", "m", "again", "login", "In", "lin", "el", "conf", "form", "sql", "check", "ins", "inside", "en", "out", "IN", "ill", "get", "ilo", "con", "ma", "n", " din", "end", "cin", "rin", "input", "can", "re", "net", "reader", "as", "inf", "thin"], "line": ["link", "sequence", "lane", "liner", "ln", "le", "header", "string", "stroke", "ine", "part", "char", "continue", "lines", "message", "lined", "entry", "detail", "e", "label", "Line", "number", "source", "pos", "point", "log", "next", "email", "LINE", "match", "eline", "result", "step", "comment", "lin", "nl", "page", "cell", "command", "range", "str", "piece", "text", "code", "chain", "out", "zone", "lo", "phrase", "l", "word", "block", "row", "inline", "print", "level", "style", "n"]}}
{"id1": "5061606", "id2": "17817568", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public Reader getGETReader_bak(URL url) {\n        Reader reader = null;\n        if (Navigator.isVerbose()) System.out.println(\"Web3DService.getGETReader caching \" + url);\n        int contentLength = -1;\n        URLConnection urlc;\n        try {\n            urlc = url.openConnection();\n            urlc.setReadTimeout(Navigator.TIME_OUT);\n            if (getEncoding() != null) {\n                urlc.setRequestProperty(\"Authorization\", \"Basic \" + getEncoding());\n            }\n            urlc.connect();\n            String content_type = urlc.getContentType();\n            if (content_type == null || content_type.equalsIgnoreCase(\"x-world/x-vrml\") || content_type.equalsIgnoreCase(\"model/vrml\") || content_type.equalsIgnoreCase(\"model/vrml;charset=ISO-8859-1\")) {\n                InputStream is = urlc.getInputStream();\n                DataInputStream d = new DataInputStream(is);\n                contentLength = urlc.getContentLength();\n                byte[] content = new byte[contentLength];\n                if (d != null) {\n                    d.readFully(content, 0, contentLength);\n                }\n                is.close();\n                d.close();\n                ByteArrayInputStream bais = new ByteArrayInputStream(content);\n                reader = new InputStreamReader(bais);\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip\")) {\n                InputStream is = urlc.getInputStream();\n                BufferedInputStream bis = new BufferedInputStream(is);\n                GZIPInputStream gis = new GZIPInputStream(bis);\n                StringBuffer sb = new StringBuffer();\n                BufferedReader zipReader = new BufferedReader(new InputStreamReader(gis));\n                char chars[] = new char[10240];\n                int len = 0;\n                contentLength = 0;\n                while ((len = zipReader.read(chars, 0, chars.length)) >= 0) {\n                    sb.append(chars, 0, len);\n                    contentLength += len;\n                }\n                chars = null;\n                gis.close();\n                zipReader.close();\n                bis.close();\n                is.close();\n                reader = new StringReader(sb.toString());\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(cis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    cis.close();\n                    bufReader.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    GZIPInputStream gis = new GZIPInputStream(cis);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(gis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    bufReader.close();\n                    gis.close();\n                    cis.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"text/html;charset=utf-8\")) {\n                System.out.println(\"text/html;charset=utf-8\");\n            } else {\n                System.err.println(\"ContentNegotiator.startLoading unsupported MIME type: \" + content_type);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return reader;\n    }\n", "label": 0, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNecessesed", "createSettingsIfNecessesar", "createSettingsIfNeccessed", "createSettingsIfNeccesar", "createSettingsIfNacessible", "createSettingsIfNecessar", "createSettingsIfNacessary", "createSettingsIfNeccessible", "createSettingsIfNecessed", "createSettingsIfNecessesary", "createSettingsIfNacessesar", "createSettingsIfNeccesary", "createSettingsIfNeccessar", "createSettingsIfNacessesed", "createSettingsIfNecessible", "createSettingsIfNacessed", "createSettingsIfNeccesible", "createSettingsIfNacessesible", "createSettingsIfNacessar", "createSettingsIfNeccesed", "createSettingsIfNecessesible", "createSettingsIfNacessesary", "createSettingsIfNeccessary"], "out": ["timeout", "obj", "up", "server", "conn", "go", "ch", "init", "yes", "writer", "it", "Out", "cho", "inv", "ex", "nt", "flush", "oe", "outer", "w", "aos", "ent", "max", "file", "gc", "cos", "ion", "log", "err", "sys", "io", "one", "that", "conv", "on", "exit", "f", "comment", "ou", "again", "res", "report", "ot", "or", "t", "bo", "o", "ne", "OU", "write", "output", "client", "con", "null", "os", "to", "oss", "end", "co", "list", "outs", "OUT", "net", "print", "note", "can", "n", "off", "cn"], "fSettings": ["fsettings", "cfSetting", "bfsettings", "cfSettings", "fOptions", "bfSettings", "cfSetup", "finalsettings", "bfChanges", " fOptions", " fSetting", "sfsettings", "fSetup", "hSettings", "sfOptions", "cfsettings", " fChanges", "fChanges", "eSettings", " fsettings", "sfSetup", "eSetting", "sfSettings", "finalSetting", "finalOptions", "sfChanges", "finalSettings", " fSetup", "esettings", "sfSetting", "hsettings", "hSetting", "bfSetting", "fSetting"], "src": ["url", "ls", "view", "attr", "sq", "rs", "dest", "fn", "sr", "sb", "rx", "syn", "config", "source", "sys", "filename", "sit", "resource", "tmp", "root", "txt", "cont", "rl", "cur", "ser", "img", "sf", "spec", "loc", "rel", "pkg", "sc", "ur", "dir", "rc", "th", "rt", "desc", "upload"], "in": ["inn", "ln", "init", "is", "and", "sin", "inner", "isin", "r", "din", "info", "source", "bin", "i", "gin", "ad", "id", "from", "In", "ins", "inside", "en", "IN", "l", "iter", "n", " din", "input", "rin", "cin", "vin", "inf"]}}
{"id1": "4618237", "id2": "539195", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFileAsDisk", "writeFile2File", "writeFilesToDisk", "writeFileAndStream", "writeFiles2File", "writeFileAndFiles", "writeFileAndDisk", "writeFiles2Stream", "writeFiles2Files", "writeFilesToStream", "writeFile2Files", "writeFiles2Disk", "writeFileAsFile", "writeFileToDisk", "writeFilesToFiles", "writeFileAndFile", "writeFileToFiles", "writeFilesToFile", "writeFileAsStream", "writeFileToStream", "writeFileAsFiles", "writeFile2Disk", "writeFile2Stream"], "fin": ["fp", "rf", "fur", "ln", "kin", "init", "fre", "inv", "fn", "ini", "mid", "din", "irm", "han", "syn", "Fin", "fil", "fa", "ran", "FIN", "fw", "fc", "f", "raf", "fi", "lin", "fd", "lf", "ic", "mil", "fl", "in", "details", "normal", "en", "mn", "lo", "focus", "fr", "rin", "jen", "n"], "fout": ["ffou", "fboutput", "ffin", "kOut", " foutput", "foutput", "Fou", "kout", "fou", "ffout", "fpo", "Fout", "fbpo", "tin", "Fin", "fbOut", "tOut", " fpo", "tout", "fbout", "tou", "ffOut", "koutput", "FOut", "kpo", "fOut", " fOut"], "append": ["printf", "bold", "include", "string", "equal", "apply", "animate", "replace", "fail", "add", "vert", "allow", "ended", "grow", "update", "folder", "push", "join", "ends", "express", "ext", "batch", "force", "send", "command", "buff", "flat", "insert", "seed", "csv", "app", "pend", "end", "note", "absolute", "ind"], "inChannel": ["Inchannel", "pinMachine", "inputCategory", "intClient", "iChannel", "outStream", "InStream", " inConnection", "innCategory", "iChan", "insideClient", "sinMachine", "inCommand", "insideChannel", "InChannel", "outCommand", "inListener", "rinListener", "innButton", "inputListener", " inCategory", "rinChannel", "intChannel", "pinCategory", "inClient", "innMachine", "outchannel", "rinCategory", " inCommand", "inMachine", "outChan", "inStream", "inputChan", "inputChannel", "insideSession", "InConnection", "inchannel", "inCategory", "inConnection", "iCommand", "rinChan", " inClient", "sinChannel", "innChannel", " inListener", " inStream", " inChan", "intSession", "insideChan", "pinButton", "sinButton", "outConnection", "inSession", "intChan", "iStream", "sinCategory", "inButton", "inChan", " inchannel", " inSession", "pinChannel"], "outChannel": ["outScope", " outController", " outChan", "outCh", "outController", "invChannel", "invCh", "nameChan", "outputScope", "netMember", "outMember", "nameChannel", "outputchannel", " outCh", "OUTchannel", "netchannel", " outConnection", "outputChan", "outputCh", "OUTChannel", " outScope", "netCh", "outputChannel", "outchannel", "invMember", " outchannel", "outChan", "netController", "userCh", "inchannel", "outputConnection", "OUTChan", "userChannel", "nameConnection", "nameScope", "inCh", "OUTController", "outConnection", "netChan", "inChan", "netChannel", "userMember"]}}
{"id1": "12197169", "id2": "19096138", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"read": [" reader", "init", "find", "reading", "stream", " Read", "download", "connect", "run", "gc", "hello", "start", "log", " replay", "close", "next", " reads", "record", " ingest", " download", " request", " reopen", "load", " seek", "open", " retrieve", "reader", " recover", "Read"], "in": ["inn", "name", "url", "inc", "al", "is", "it", "and", "inner", "stream", "isin", "via", "add", "r", "din", "info", "entry", "message", "index", "run", "file", "source", "all", "update", "log", "bin", "when", "io", "record", "on", "f", "from", "again", "In", "conf", "or", "body", "check", "ins", "with", "out", "er", "IN", "ro", "at", "by", "o", "l", "ill", "get", "con", " din", "cin", "input", "re", "during", "ing", "reader", "as", "inf"], "line": ["link", "url", "lane", "sequence", "liner", "le", "ln", "path", "stroke", "string", "ine", "part", "char", "stream", "message", "sample", "se", "entry", "e", "detail", "Line", "file", "point", "log", "LINE", "record", "eline", "data", "comment", "lin", "page", "cell", "body", "frame", "piece", "text", "code", "chain", "lo", "l", "word", "block", "row", "inline"], "i": ["ix", "bi", "sequence", "im", "oi", "p", "mi", "is", "x", "phi", "si", "v", "hi", "index", "u", "cli", "ind", "ti", "ci", "me", "ori", "zi", "j", "multi", "di", "conv", "id", "xi", "f", "m", "base", "c", "y", "ei", "qi", "t", "o", "d", "l", "iter", "ai", "I", "to", "z", "pi", "sim", "n", "ii", "li"], "logDatum": ["logDoummy", " logBatum", "logDoictionary", "logdata", "LogDummy", " logBump", "logBatum", "logBictionary", "logRatum", "logRump", "Logdatum", "LogData", "logDump", "logTrata", " logDump", " logBummy", " logDictionary", "logDictionary", "logBummy", "logDum", "Logdata", "logdummy", "Logdum", "logdum", "LogDatum", "logBump", "Logdummy", "logDummy", " logDummy", " logBictionary", "logDoatum", "logdatum", "logTratum", "logData", "logRummy", "logDoump", "logRictionary", "logTrummy", "logTrum", "LogDum"]}}
{"id1": "15580610", "id2": "838844", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainClassizer", " trainclassification", " trainclassizer", " trainObjectizer", " trainObjectifier", " runClassification", " runclassizer", " runClassizer", " runclassifer", " trainModifer", " runclassifier", " runClassifier", " trainclassifer", " trainModifier", " trainModification", " trainObjectification", " runClassifer", " trainObjectifer", " trainclassifier", " trainClassifer", " runclassification", " trainModizer", " trainClassification"], "dir": ["url", "path", "wd", "this", "src", "dm", "Dir", "grad", "config", "div", "pos", "folder", "log", "ir", "io", "rad", "tmp", "local", "data", "root", "DIR", "files", "direct", "done", "dl", "base", " directory", "report", "prefix", "md", "lib", "loc", "d", "pkg", "db", "doc", "output", "module", "disk", "null", "dist", "dd", "dr", "directory", "addr"], "command": ["attribute", "option", "execute", "sequence", "clear", "response", "group", "link", "delete", "key", "power", "initial", "string", "statement", "multiple", "pattern", "and", "shell", "display", "document", "description", "message", "volume", "content", "menu", "expression", "shift", "mac", "argument", "cmd", "event", "config", "query", "sudo", "buffer", "Command", "archive", "function", "column", "template", "password", "method", "call", "button", "application", "mpeg", "comment", "base", "search", "force", "send", "form", "set", "text", "relative", "chain", "binary", "condition", "history", "requisite", "component", "paste", "position", "request", "connection", "three", "script", "operation", "pretty", "program", "directory", "control"], "length": ["needs", "volume", "character", "deep", "sequence", "len", "shape", "power", "full", "now", "height", "bus", "fleet", "capacity", "distance", "shift", "factor", "max", "value", "number", "last", "given", "strip", "pad", "limit", "build", "ENGTH", "append", "SIZE", "available", "dump", "ength", "space", "prototype", "pieces", "form", "depth", "collection", "load", "loc", "duration", "total", "ctors", "upper", "position", "count", "creator", "end", "transform", "size", "diff", "Length", "level"], "process": ["cp", "link", "view", "flow", "pp", "p", "system", "complex", "handle", "task", "display", "message", "connect", "run", "cmd", "node", "event", "start", "network", "session", "function", "parse", "channel", "record", "processor", "mpeg", "method", "call", "result", "search", "worker", "Process", "status", "object", "console", "service", "post", "check", "thread", "in", "class", "load", "proc", "component", "output", "term", "position", "exec", "pid", "request", "script", "processing", "program", "use"]}}
{"id1": "11475527", "id2": "9319440", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 1, "substitutes": {"addDataFromURL": ["addDatafromurl", "addDataFromUrl", "addDatafromLocation", "addDataToURL", "addTextFormUrl", "addTextFormLocation", "addDataFromLocation", "addDataFormurl", "addTextFormURL", "addTextFromURL", "addDataFormLocation", "addTextFormurl", "addTextFromLocation", "addDataFromurl", "addTextFromurl", "addDataToLocation", "addTextFromUrl", "addDataToUrl", "addDataTourl", "addDatafromUrl", "addDatafromURL", "addDataFormUrl", "addDataFormURL"], "theurl": ["heloader", " theloader", " theUrl", " thefile", "thUrl", "thurl", "Theurl", "heurl", "heUrl", "teURL", "theURL", "thefile", "Theuri", "theuri", "heURL", " theuri", "hefile", "teUrl", "TheURL", "TheUrl", " theURL", "heuri", "teurl", "thfile", "teuri", "thloader", "theUrl", "theloader"], "line": ["name", "link", "sequence", "lane", "online", "liner", "le", "ln", "header", "string", "stroke", "ine", "char", "message", "lined", "sample", "entry", "Line", "node", "source", "point", "email", "LINE", "eline", "record", "comment", "lin", "valid", "page", "cell", "status", "ner", "frame", "day", "code", "text", "chain", "rule", "zone", "l", " inline", "block", "ice", "row", "inline", "print"], "in": ["inn", "al", "inc", "pin", "conn", "include", "init", "ac", "is", "it", "mi", "ain", "inner", "isin", "old", "r", "din", "source", "bin", "i", "read", "serv", "gin", "win", "phys", "id", "f", "from", "again", "In", "or", "ic", "st", "ins", "t", "en", "out", "IN", "o", "lo", "proc", "l", "open", "con", "ai", "ma", "n", "cin", "rin", "input", "mc", "reader", "inf", "oin"], "data": ["iterator", "cache", "writer", "ata", "bus", "def", "this", "stream", "pipe", "a", "info", "content", "dec", "feed", "file", "query", "buffer", "join", "read", "dat", "next", "ad", "io", "user", "result", "body", "da", "text", "out", "d", "client", "DATA", "input", "size", "reader", "window", "raw"], "e": ["ue", "ele", "le", "p", "ec", "E", "x", "ine", "g", "ex", "a", "se", "r", "v", "entry", "oe", "ee", "event", "b", "de", "err", "ve", "i", "h", "me", "es", "error", "f", "m", "c", "te", "y", "or", "ge", "eu", "t", "element", "er", "eeee", "o", "ne", "d", "n", "re", "ae", "ie", "ce", "be", "ed", "ze", "pe"]}}
{"id1": "19784131", "id2": "7372311", "code1": "    public static String getMD5Hash(String original) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            StringReader sr = null;\n            int crypt_byte = 0;\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(original.getBytes());\n            byte[] digest = md.digest();\n            sr = new StringReader(new String(digest, \"ISO8859_1\"));\n            while ((crypt_byte = sr.read()) != -1) {\n                String hexString = Integer.toHexString(crypt_byte);\n                if (crypt_byte < 16) {\n                    hexString = \"0\" + hexString;\n                }\n                sb.append(hexString);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n        } catch (IOException ioe) {\n        }\n        return sb.toString();\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"getMD5Hash": ["getMD5hash", "getMD2Sum", "getMD5Key", "getMD4hash", "getMD3Sum", "getMD3hash", "getMD3Hash", "getMD3Key", "getMD2Key", "getMD2hash", "getMD2Hash", "getMD5Sum", "getMD4Hash", "getMD4Key", "getMD4Sum"], "original": ["name", "metadata", "origin", "orig", "initial", "modified", "string", "image", " Original", "created", "before", "message", "old", "sample", "content", " orig", "source", "actual", "filename", "data", "template", "regular", "Original", "base", "custom", "vector", "instance", "hash", "code", "o", "was", " originals", "input", "reset", "raw"], "sb": ["sm", "bn", "obs", "erb", "bg", "ib", "sq", "bs", "cb", "sk", "mb", "sa", "bh", "src", "ab", "nb", "lb", "b", "bd", "gc", "ssl", "bsp", "bb", "sg", "bp", "sv", "lp", "eb", "abs", "gb", "bj", "bf", "rob", "sf", "wb", "ub", "kb", "pb", "bt", "ob", "rb", "SB", "zb", "sp", "fb", "xb"], "sr": ["asper", "ri", "rd", "tr", "adr", "rs", "ear", "hr", "r", "rr", "rn", "rx", "nr", "her", "ssl", "rar", "sv", "spr", "sl", "vr", "rm", "rl", "sur", "ser", "sol", "rys", "rg", "pr", "usr", "gr", "mr", "rc", "lr", "rb", "cr", "fr", "SR", "rt", "dr", "kr", "yr"], "crypt_byte": [" crypt_buffer", "cryptitybyte", "crypt_frame", "cryptYpair", "cryptYchar", "crypt68source", "hex_byte", "crypt2bytes", "cryptolypair", "Crypt_source", "cryptitybuffer", "hex_pair", "crypt68char", " crypt_bytes", "Crypt_char", " cryptitybuffer", "cryptolybyte", "Crypt_bytes", "hex_char", "crypt68bytes", "crypt2source", "crypt_char", "Crypt_byte", "crypt_bytes", " cryptitybytes", " crypt_char", "four_byte", " cryptitybyte", "four_coin", "four_char", "hex_frame", "cryptYframe", "cryptolyframe", "cryptitybytes", "crypt_coin", "crypt_source", "cryptolychar", "crypt_buffer", "crypt2byte", "crypt68byte", "cryptYbyte", "cryptitychar", "crypt_pair", "crypt2char", "four_bytes", " cryptitychar"], "md": ["sm", "msg", "amd", " MD", "comp", "dr", "dig", "mt", "cd", "mb", "MD", " cmd", "dm", "dh", "mm", "der", "od", "cmd", "grad", "ind", "bd", "de", "sd", "mod", "pd", "method", "ld", "m", "det", " Md", "pm", "ms", "mg", "red", "mn", "d", "met", "dd", "mc", "pdf", "ct", "mk", "df", "hd"], "digest": ["ddest", "Digest", "ddet", "mdEST", "diger", "dest", "Digester", "Digate", "mdet", "der", "defests", "ddested", "hashested", "mdest", "hashest", "dests", "defested", "diget", "mdester", "digests", "digate", "hashet", "defest", "defer", "digested", " digate", " digester", "ddEST", " digEST", "digEST", "Diger", "hashEST", "DigEST", "digester", "Digests", "dested", "mdate", "Digested", "mdested"], "hexString": [" sexSummary", "hashstring", " sexStr", " sexString", "exNumber", "hexNumber", " hexstring", "exSummary", " hexNumber", "hexstring", "hashStr", " hexSummary", "exString", " hexChain", "exChain", "hexSummary", "hashString", " HexNumber", "exstring", " HexString", " HexStr", " Hexstring", " hexStr", "hashChain", "hexChain", " HexChain", "exStr", "hexStr"]}}
{"id1": "20995534", "id2": "2017833", "code1": "    private static Properties loadPropertiesFromClasspath(String path) {\n        Enumeration<URL> locations;\n        Properties props = new Properties();\n        try {\n            locations = Thread.currentThread().getContextClassLoader().getResources(path);\n            while (locations.hasMoreElements()) {\n                URL url = locations.nextElement();\n                InputStream in = url.openStream();\n                props.load(in);\n                in.close();\n                logger.config(\"Load properties from \" + url);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e);\n        }\n        return props;\n    }\n", "code2": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"loadPropertiesFromClasspath": ["loadPropertiesFromFilename", "loadPropertiesFromFileloader", "loadPropertiesfromclassname", "loadPropertiesFromClassloader", "loadPropertiesfromClassname", "loadPropertiesFromClassPath", "loadPropertiesfromClasspath", "loadPropertiesFromclassloader", "loadPropertiesFromclasspath", "loadPropertiesFromclassname", "loadPropertiesfromclasspath", "loadPropertiesFromClassname", "loadPropertiesfromclassloader", "loadPropertiesfromClassloader", "loadPropertiesFromclassPath", "loadPropertiesFromFilePath", "loadPropertiesfromclassPath", "loadPropertiesFromFilepath", "loadPropertiesfromClassPath"], "path": ["zip", "name", "PATH", "ath", "key", "p", "string", "full", "pattern", "xml", "entry", "w", "mount", "file", "config", "location", "filename", "log", "prop", "resource", "context", "data", "template", "root", "txt", "base", "type", "prefix", "str", "text", "item", "chain", "test", "module", "policy", "dir", "Path", "pt", "empty", "transform", "hex", "program", "directory", "format"], "locations": ["equATIONS", "LOCifications", "Locifications", "Lococations", "localations", "locATION", "locifications", "LOCocations", "localATION", " lococations", " locifications", "localates", "plATIONS", "lococations", "locators", "equations", " locATION", "equators", " locATIONS", "plocations", " locators", "LOCations", "LOCates", " locates", "LocATION", "localifications", "Locators", "LOCATIONS", "locATIONS", "LOCators", "Locates", "equifications", "Locations", "plations", "plates", "locates"], "props": ["prors", "propperties", "peperties", "prodates", "pregs", "privrs", "Progs", "pebs", " prors", "privps", "privperties", "rops", "Prors", " prodates", "propports", "proports", "propps", "rogs", "Probs", "progs", "Prodates", " properties", "propgs", "Props", "peps", "robs", "preports", "Properties", "probs", "preps", "roperties", "preperties", "privdates", "pegs", "Proports", "properties"], "url": ["mail", "Url", "name", "link", "server", "html", "key", "string", "pattern", "org", "char", "mb", "xml", "r", "mount", "file", "config", "location", "log", "gl", "resource", "bel", "user", "f", "dl", "uri", "web", "http", "sl", "nl", "el", "page", "rl", "str", "ll", "browser", "address", "ref", "element", "loc", "rel", "l", "term", "ob", "row", "URL", "ls", "ur"], "in": ["inn", "inc", "ln", "init", "is", "mi", "mat", "and", "inner", "stream", "isin", "as", "sample", "din", "info", "ind", "file", "source", "bin", "i", "io", "read", "gin", "data", "on", "media", "from", "In", "sum", "sql", "body", "ins", "en", "out", "mn", "IN", "cm", "con", "ma", "mr", "input", "cin", "mc", "reader", "vin", "cn"]}}
{"id1": "10281203", "id2": "2198730", "code1": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 1, "substitutes": {"makeRead": [" makePrint", "makeread", "makePrint", "recordread", "recordRead", " doPrint", " doRead", " makeread", " doReading", " makeReading", " doread", "makeReading", "recordReading", "recordPrint"], "user": ["name", "url", "server", "User", "string", "auth", "usage", "message", "database", "users", "file", "uid", "date", "author", "host", "password", "id", "project", "person", "command", "post", "rule", "by", "table", "client", "human", "word", "USER", "creator", "connection", "field", "student", "username", "use", "owner"], "databaseID": [" databaseSet", "directoryIDs", "databaseIDs", "directoryID", "connectionSet", "databaseSet", "connectionType", "directoryType", " databaseId", "connectionIDs", "directorySet", "databaseId", "directoryId", " databaseIDs", " databaseType", "connectionID", "databaseType", "connectionId"], "time": ["port", "ime", "timeout", "sequence", " Time", "version", "now", "string", "delay", "ty", "estamp", "message", "info", "TIME", "clock", "value", "second", "start", "date", "tt", "rate", "id", "year", "m", "type", "timer", "tim", "frequency", "age", "t", "text", "create", "Time", "duration", "etime", "times", "end", "tm", "runtime", "window"], "query": ["then", "sequence", "view", "string", "Query", "qu", "sq", "select", "task", "description", "message", "what", "entry", "menu", "title", "cmd", "question", "update", "join", "template", "ql", "call", "comment", "search", "q", "command", "quote", "sql", "body", "check", "text", "code", "create", "condition", "term", "request", "qa", "ask", "script", "transform", "quest"], "statement": ["sequence", "stat", "cmd", "number", "buffer", "yahoo", "function", "that", "library", "call", "storage", "quote", "st", "table", "list", "document", "state", "le", "journal", "bind", "article", "processor", "report", "sql", "language", "rule", "condition", "position", "connection", "mt", "volume", "Statement", "response", "shell", "ts", "confirmed", "se", "memory", "usage", "expression", "database", "minute", "template", "comment", "batch", "command", "frequency", "relation", "cm", "policy", "fr", "sp", "print", "ct", "execute", "init", "continue", "description", "commit", "copy", "entry", "ements", "session", "ment", "application", "communication", "status", "binary", "phrase", "sn", "word", "pretty"], "count": ["counter", "OUNT", "amount", "any", "now", "find", "nt", "message", "current", "nb", "number", "ind", "all", "ount", "call", "num", "complete", "batch", "c", "report", "sum", "status", "cond", "check", "parts", "code", "contact", "loc", "length", "total", "table", "ctx", "Count", "n", "list", "size", "found", "index", "handle", "state"]}}
{"id1": "18782385", "id2": "8801436", "code1": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveFile": ["storeFiles", " saveFiles", "savePage", "saveFiles", "outputFile", "storefile", "outputFiles", "savefile", "outputPage", "storePage", " savePage", "storeFile", " savefile", "outputfile"], "window": ["port", "remote", "volume", "wall", "view", "where", "server", "flow", "wa", "go", "html", "ws", "now", "height", "env", "system", "wd", "this", "scope", "before", "message", "device", "stack", "w", "lock", "file", "event", "query", " Window", "buffer", "session", "context", "stage", "wx", "manager", "Window", "win", "fw", "button", "box", "hw", "driver", "http", "wait", "page", "we", "form", "frame", "draw", "console", "browser", "widget", "history", "Win", "doc", "client", "focus", "screen", "WIND", "th", "document", "gui"], "stream": [" status", " resp", " con", " form", " session", " dos", "is", " response", " screen", "aos", " error", "REAM", " context", " im", " enc", " steam", " console", "Stream", " fin", " zip", " upstream", " sock", " upload", "os", " din", " is", "ream", " streams"], "outputDoc": ["outputDec", "documentDoc", "OutputDocument", "OutputCode", "outputCode", "exportDoc", " outputCode", "displayDocument", "OutputMat", "putDocument", "putDoc", "outputMat", "outputDocument", "OutputDoc", "OutputDec", " outputDocument", "Outputdoc", "outputdoc", "exportCode", " outputdoc", "putMat", "documentDocument", "toDocument", "toDec", "toDoc", "putDec", "toMat", "displayDoc", "documentdoc", "exportDocument", "displaydoc"], "dtd": ["sdTD", "Dtd", "sdtd", " dpd", "ttm", "DTD", " dtm", "dpd", "dtif", "dhTD", "dtm", " dTD", "sdpd", "dTD", "ttif", " dtif", "dhtd", "dhtif", "ttd", "Dpd", "dhtm", "tTD"], "uiElement": ["uObject", "clielement", "tiObject", "uiEngine", "guiFrame", "guielement", "umiComponent", "uiEvent", "uEvent", "UITag", "uEmail", "UIEntry", "culement", "tiItem", "cliMember", "uiMotion", "uciEvent", "iuToken", "UIlement", "zuSecret", "UISecret", "uiSecret", "iulement", "uMember", "zuLink", "UIEngine", "uciBlock", "guiEntity", "cuSecret", "iuE", "guiEvent", "iuFunction", "uiToken", "uiBlock", "iuMotion", "iuFrame", "tiEngine", "uciFunction", "UIBlock", "iuElement", "umiToken", "iuelement", "cliElement", "uiEmail", "zuEmail", "wuEmail", "wuLink", "cuEntry", "uilement", "cliEmail", "tielement", "iuTag", "zuElement", "uiEntity", "iuEntity", "tilement", "guiTag", "ucilement", "uiEntry", "uiComponent", "umiSecret", "tiElement", "tiEntry", "cuToken", "uItem", "uiFrame", "iuEvent", "umilement", "umiEngine", "UIelement", "uiFunction", "uFrame", "uciElement", "uiObject", "uFunction", "iuItem", "cuComponent", "iiMember", "UIEntity", "ulement", "uE", "UIElement", "guiElement", "UILink", "cuElement", "uiE", "uciE", "iuComponent", "uMotion", "iielement", "iuObject", "UIE", "uiTag", "uelement", "uiItem", "wuSecret", "uiLink", "uciMotion", "UIEvent", "iiEmail", "uiMember", "wuElement", "UIEmail", "guiE", "umiEntry", "umiElement", "uielement", "iuBlock", "iiElement", "uElement"], "currentLFClassName": ["currentLEFClassPath", "currentLEFclassNames", "currentLWStyleConfig", "currentLFClassNames", "currentLEFclassName", "currentLFFullNames", "currentLFSystemNames", "currentLFClassClass", "currentLWClassConfig", "currentLFclassNames", "currentLFFullName", "currentLFClassPath", "currentLFDisplayNames", "currentLFclassSet", "currentLEFclassPath", "currentLFClassSet", "currentLFSystemClass", "currentLEFClassClass", "currentLFStyleConfig", "currentLFFullSet", "currentLFClassConfig", "currentLFclassConfig", "currentLFclassName", "currentLFDisplayPath", "currentLFSystemName", "currentLFSystemPath", "currentLWStyleName", "currentLFStyleNames", "currentLWStyleSet", "currentLFclassClass", "currentLFDisplayClass", "currentLWStyleNames", "currentLEFClassName", "currentLWClassName", "currentLEFClassNames", "currentLEFclassClass", "currentLFStyleName", "currentLWClassSet", "currentLFFullConfig", "currentLFStyleSet", "currentLFDisplayName", "currentLWClassNames", "currentLFclassPath"], "systemLFClassName": ["systemLFFFileNames", "systemLFScreenNames", "systemLEFClassName", "systemLFFClassString", "systemLFFileNames", "systemLFSystemString", "systemLEFClassPath", "systemLFFilename", "systemLFFFilePath", "systemLFClassPath", "systemLFclassname", "systemLFFileName", "systemLEFclassPath", "systemLFSystemNames", "systemLFFFileString", "systemLFScreenname", "systemLFclassName", "systemLFScreenPath", "systemLFClassNames", "systemLFClassString", "systemLFclassString", "systemLEFclassName", "systemLFFFileName", "systemLFFileString", "systemLFclassNames", "systemLFFClassName", "systemLFclassPath", "systemLFSystemName", "systemLFClassname", "systemLFFClassPath", "systemLFSystemPath", "systemLFFClassNames", "systemLEFClassNames", "systemLFScreenName", "systemLFFilePath", "systemLEFclassNames", "systemLEFclassname", "systemLEFClassname"], "mainWindowElement": ["MainWinElement", "mainScreenLE", "mainSessionelement", "MainWindowElement", "mainwindowPort", " mainWindowEntry", " mainWinE", " mainFrameEntry", "mainScreenEntry", " mainWindowLE", "mainWinUser", "mainWinPort", "mainWinelement", "mainWindowPort", "MainWindowPort", "mainFrameMENT", " mainWindowMENT", " mainFrameE", "mainWinEntry", "mainFramelement", "mainSessionE", "mainWindowEntry", " mainWinEntry", "mainWindowlement", "mainWindowLE", "mainWinMENT", "mainWinLE", "MainWindowEntry", "mainSectionE", "mainSessionElement", "mainWinE", "mainwindowE", "mainwindowElement", "mainwindowUser", "MainWindowE", " mainFrameMENT", "mainFrameEntry", "mainScreenE", "MainWinelement", "mainWindowMENT", " mainWinLE", "mainWindowE", "MainWindowelement", "mainWinElement", "mainFramePort", "mainFrameelement", "mainWinlement", " mainFrameElement", "mainSectionElement", "mainWindowelement", "mainSessionEntry", "mainFrameUser", "mainSectionEntry", "MainWindowUser", "mainFrameLE", "mainFrameE", "MainWinEntry", " mainFramelement", " mainWinElement", "mainScreenElement", "MainWinUser", "mainwindowEntry", "mainWindowUser", "MainWinPort", "MainWinE", " mainWindowlement", "mainFrameElement", "mainwindowMENT", " mainWindowE", "mainSectionlement"], "volumeElement": [" volumelement", "audioEntry", "volumeEntry", "voiceEntity", "volumelement", "vineelement", "audioEntity", "volumeEntity", "VolumeElement", " volumeEntry", "vineElement", "VolumeEntity", "uiEmail", "audioE", "musicE", "voicelement", "vineE", " volumeEntity", "voiceMember", " volumeEmail", "audioElement", "vinelement", "voiceEntry", "voiceelement", "musicEntry", "volumeE", "uiEntity", "volumeMember", "musicElement", " volumeMember", "musicMember", "VolumeEmail", "voiceE", "uiE", "volumeEmail", "VolumeE", " volumeelement", "volumeelement", " volumeE", "voiceElement"], "player": ["volume", " Player", "radio", "played", "movie", "pool", "display", "pipe", "loader", "sample", "layer", "pro", "file", "controller", "source", "profile", "video", "taker", "youtube", "user", "Player", "PLAY", "driver", "audio", "program", "worker", "peer", "console", "service", "lay", "playing", "play", "ser", "speaking", "uner", "er", "aster", " playing", "table", "position", "live", "score", "game"]}}
{"id1": "9802073", "id2": "1141361", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 1, "substitutes": {"testAutoCommit": ["testAutoDebits", "testAutoCompute", "testAutoCommmit", "testAutoCompmit", "testAutoCommute", "testAutoComit", "testAutoCompit", "testAutoDebit", "testAutoCompits", "testAutoComits", "testAutoCommits", "testAutoDebmit", "testAutoComute", "testAutoDebute"], "con": ["cons", "obj", "conn", "go", "ln", "ac", "bc", "ver", "ain", "clean", "const", "cc", "comm", "act", "xc", "don", "rec", "enc", "tc", "connect", "pen", "gc", "cos", "local", "ran", "col", "conv", "win", "gen", "cal", "call", "fc", "c", "res", "coll", "conf", "nc", "com", "ctrl", "CON", "cur", "fl", "canon", "en", "out", "bo", "cm", "cf", "client", "ctx", "Con", "rc", "connection", "dial", "ca", "co", "re", "Conn", "fac", "cat", "mc", "ct", "can", " conn", "cp", "cn"], "stmt": [" stmp", "STmp", "Stm", "statmm", "statmb", "stpt", "stct", "strm", "Starm", " stgr", "strmp", " starm", "stMT", " stpt", "stgr", "strmm", " superstmb", " superstmt", "stmm", "STm", "stmb", "statgr", "STmb", "STMT", "Stmm", " stm", "strgr", " superstm", "STpt", "stmp", " superstarm", "Stmp", "Stct", "STmt", " stmb", " stmm", "strmt", " stMT", "starm", "statmt", "Stmt", " stct", "StMT", "Stpt", "statct", "stm", "strmb", "Stmb", "statm"], "rs": ["ras", "obs", "rt", "cs", "rd", "ws", "icks", "ges", "bs", "cks", "stats", "ats", "ars", "ds", "rates", "ers", "sr", "irms", "ubs", "RS", "sys", "ys", "vers", "gs", "ris", "results", "ss", "xs", "ems", "sts", "fs", "res", "ags", "rows", "its", "ares", "acs", "ims", "ms", "ins", "rys", "dds", "vs", "Rs", "usr", "acks", "times", "ra", "mr", "rc", "ros", "ires", "js", "qs", "ows", "hs", "ks", "arms", "ues", "ls"]}}
{"id1": "8490297", "id2": "19134229", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyDir", " cpfile", " cpFile", " cpDir", " duplicatefile", "copyDir", " duplicateDir", " cpFiles", "copyFiles", "copyfile", " copyFiles", " copyfile", " duplicateFile", " duplicateFiles"], "src": ["Source", "sec", "url", "obj", "obs", "stat", "msg", "comp", "init", "inst", "sq", "addr", "bs", "rs", "dest", "via", "subject", "target", "sr", "sb", "rx", "ck", "syn", "lb", "source", "config", "start", "sys", "filename", "nil", "sit", "ipl", "func", "resource", "tmp", "conv", "txt", "usc", "from", "cont", "uri", "http", "ctr", "rl", "st", "cur", "ser", "ins", "sf", "img", "impl", "spec", "loc", "usr", "rel", "pkg", "sn", "ctx", "sc", "req", "rc", "input", "ls", "desc", "iv"], "dst": [" dnd", "Ddest", "ddest", "sdst", "pust", "dest", "sddest", "sdth", "dth", "dnd", "dund", "dust", "dng", "Dnd", "dudest", "sdust", "pdest", "Dng", "pst", "dedest", " ddest", " dng", "dung", "deust", "deth", "Dst", "pth"], "in": ["inn", "im", "al", "inc", "up", "ln", "init", "is", "it", "ain", "sin", "inner", "isin", "din", "info", "mm", "min", "source", "ir", "i", "read", "gin", "on", "from", "In", "ic", "st", "ins", "inside", "en", "IN", "inf", "iter", "con", "rc", "ai", " din", "input", "rin", "cin", "ar", "ze", "oin", "ind"], "out": ["auto", "obj", "cache", "up", "ch", "writer", "p", "it", "and", "Out", "g", "v", "nt", "oe", "outer", "aos", "sys", "io", "gt", "on", "c", "ou", "res", "sum", "ot", "t", "at", "o", "by", "ne", "write", "output", "client", "os", "con", "to", "end", "co", "outs", "OUT", "net", "n", "cn"], "buf": ["cap", "msg", "cv", "bc", "nm", "bus", "tx", "cb", "char", "bl", "fam", "seq", "cmd", "b", "buffer", "bin", "log", "prop", "uf", "Buffer", "data", "conv", "bar", "box", "gen", "tab", "queue", "batch", "arr", "cam", "mu", "good", "br", "img", "bag", "cur", "Buff", "buff", "pkg", "vec", "db", "block", "rb", "fac", "fb", "cat", "aka", "bytes"], "len": ["hl", "elt", "cap", "le", "ln", "span", "yn", "del", "full", "cmp", "lon", "v", "nt", "seq", "e", "pos", "all", "ren", "fin", "val", "fun", "ld", "dl", "coll", "el", "nl", "lf", "ll", "en", "lib", "no", "l", "length", "vec", "Len", "lan", "wid", "count", "lic", "end", "compl", "size", "ls", "n"]}}
{"id1": "12242903", "id2": "5951961", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"hashKey": ["processLink", "processKey", "hashLink", "updatekey", "processkey", "updateKey", " hashkey", "processValue", "hashkey", " hashValue", "updateValue", " hashLink", "updateLink", "hashValue"], "key": ["port", "attribute", "name", "link", "cache", "ace", "obj", "path", "cert", "string", "char", "this", "sk", "description", "message", "foo", "entry", "title", "lock", "value", "json", "hello", "source", "k", "data", "KEY", "template", "password", "id", "Key", "base", "type", "conf", "y", "prefix", "service", "piece", "text", "code", "item", "chain", "phrase", "seed", "client", "null", "et", "token", "hex", "username", "secret", "encrypted", "state"], "hashed": ["khash", " hushed", "ahash", "khhed", "khashing", "rhoted", "enhrypted", "hored", "rhashed", "hhed", "thash", "thored", " hhed", "shashed", "thashed", "ahashed", "rhamped", "enhash", " hored", "hoted", "enhashed", "rhhed", "khashed", "shhed", " hoted", " hashing", "ahushed", "ahored", "hashing", "enhhed", "shoted", "hoashing", " hamped", "hoashed", "hoash", " hrypted", "khrypted", "hamped", "shamped", "hohed", "hrypted", "thushed", "hushed"], "md5": [" md0", " MD45", "MD2", " md2", "md45", "det55", "md3", " md45", " MD3", " md55", "sha5", "md0", "dig5", "det3", "sha3", "MD5", " MD5", "md2", "det5", "dig3", "dig55", "sha0", " MD2", "MD0", "sha2", "MD45", "md55", " md3", "MD3"], "hash": ["radius", "ashed", "html", "array", "uh", "sq", "height", "ssh", "sh", "message", "sample", "shift", "square", "number", "carry", "h", "build", "hz", "ash", "checked", "hed", "search", "Hash", "ah", "sum", "tag", "check", "always", "length", "total", "trust", "count", "shadow", "kernel", "block", "hex", "score", "has", "index", "handle", "sha"]}}
{"id1": "13783898", "id2": "3187685", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringAsDisk", "encodeStringAsStream", "encodeFileAsStream", "encodeFiletoDisk", "encodeStringAsFile", "encodeStringToStream", "encodeFileToFiles", "encodeStringToFiles", "encodeStringToDisk", "encodeStringAsFiles", "encodeFileAsFile", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileAsDisk", "encodeFiletoStream", "encodeFileFromFiles", "encodeFileAsFiles", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk", "encodeFileFromDisk", "encodeFileFromFile", "encodeFileToStream"], "infile": ["inFile", "outFile", "InFile", "inputfilename", "inbase", "Inbase", " inbase", " inFile", "infilename", "inpath", "Inpath", " inpath", "outbase", "Infile", "outfilename", "outpath", "inputfile", "inputpath", "inputFile", " infilename"], "outfile": ["inFile", " outname", "outFile", "infp", " outFile", "fromfile", "tofp", "newfilename", "todir", "outdir", "infilename", "toFile", "fromfp", "indir", "outname", "fromFile", "inname", "outfp", "outfilename", " outfilename", "newfile", "newFile", "fromdir", "newname", "tofile"], "in": ["inn", "im", "al", "inc", "up", "pin", "conn", "init", "image", "is", "it", "per", "ain", "inner", "isin", "ini", "din", "info", "source", "nin", "bin", "i", "gin", "on", "id", "from", "In", "form", "or", "amin", "ins", "inside", "t", "en", "IN", "ro", "by", "get", "iter", "con", " din", "cin", "rin", "input", "re", "ar", "inf", "oin", "ind"], "out": ["up", "writer", "it", "Out", "inner", "g", "ex", "fn", "nt", "aos", "outer", "flush", "file", "b", "sys", "ion", "opt", "io", "gt", "on", "ou", "res", "ot", "t", "en", "at", "o", "ne", "OU", "write", "output", "con", "os", "null", "to", "oss", "end", "co", "outs", "OUT", "net", "print", "can", "n", "cn"], "buffer": ["attribute", "character", "sequence", "cache", "view", "header", "initial", "display", "document", "message", "memory", "sample", "info", "stack", "temp", "number", "bone", "variable", "pad", "buf", "black", "append", "Buffer", "template", "bar", "padding", "library", "available", "password", "button", "note", "batch", "base", "comment", "queue", "command", "frame", "mem", "buff", "binary", "history", "phrase", "table", "paste", "total", "length", "block", "row", "print", "window", "column"], "read": ["READ", "len", "raw", "each", "select", "find", "first", "reading", "ready", "stream", "before", "add", "reads", " Read", "run", "connect", "allow", "through", "query", "start", "i", "push", "close", "give", "send", "wait", "check", "range", "set", "text", "load", "write", "ok", "length", "get", "open", "hold", "req", "count", "iter", "seek", "end", "skip", "input", "readable", "need", "n", "size", "print", "reader", "index", "ind", "Read"], "success": ["response", "town", " okay", "first", "same", "fail", "continue", "primary", "support", " successes", "commit", " successful", "positive", "growth", "photo", "safe", "value", "submit", " succ", "second", "snap", "Success", "city", "ccess", "successfully", "error", "warning", "ceed", "result", "successful", "complete", "setup", "done", "accept", "crit", "sufficient", "release", "democracy", "valid", "status", "good", "surv", "danger", "summary", " Success", "condition", "please", "ok", " failure", "unity", "ratulations", "cess", "ith"]}}
{"id1": "13757855", "id2": "20717531", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "label": 0, "substitutes": {"process": ["execute", "apply", "replace", "task", "display", "add", "run", "parse", "build", "processor", "call", "step", "project", "save", "Process", "create", "load", "loop", "proc", "write", "render", "transform", "processing", "filter", "handle", "format"], "tpl": ["ttopl", "terld", "topl", "timplug", "ttpl", "tpg", "turtle", " tplates", "ptpl", "timpl", "Tph", " turtle", "tspr", "atuple", "Tpl", "stplate", "otpl", "stbl", "tmpp", "tyPL", "templ", "stpg", "tPL", "ptbl", " tpp", "tembl", "tpp", "stopl", "itbl", "itPL", "tsurtle", "tyurtle", "otld", "typl", "ttplug", "itpl", "Tplate", "atld", " tplate", "terplate", "tplate", "tsbl", "stplug", "Tplates", "stpl", "ttpg", "Tspl", "ttph", "tplug", "timspl", "tph", "tpr", "ptld", "Tpp", "timpg", "atplate", " tbl", "stspl", "tmbl", "tspl", "Tld", "timbl", "timopl", "tmpl", "ptplates", "tsPL", "temPL", "tempr", "otplate", "tuple", "Tbl", "ttPL", "tld", "tplates", "itplate", " tld", "tmplate", "terpl", "tmplates", "tmPL", "atpl", " tuple", "TPL", "tbl", "timplate", "Tpr", "ttbl", " tPL", "teruple", " tph", "otbl"], "model": ["html", "parent", "M", "content", "node", "file", "product", "log", "Model", " Model", "data", "record", "project", "m", "base", "Document", "el", "models", "object", "md", " models", "module", "tree", "ml", "document"], "packageName": ["PackageClass", "pkgNames", "PackageRoot", " packageRoot", "viewname", "groupVersion", "groupFamily", "viewRoot", "viewClass", "packageNames", "groupNames", "packagename", "viewName", "packageFamily", " packageNames", "packageVersion", "pkgVersion", " packageClass", "PackageName", " packageFamily", "groupName", "pkgName", "packageClass", "packageRoot", "pkgFamily", "Packagename", " packagename", " packageVersion"], "outFileName": ["outFilename", "infileType", "outFNames", "outFileType", "outFilenameSize", " outFilenamename", "outStreamTime", "outFilenameTime", "outTableName", " outTableName", "outDirSize", "outFileSize", " outFilenamePath", "outTableChain", "outfileNames", "outFilenameName", "outImagePath", "outFilenamename", " outfileNames", "outStreamPath", "outfileTime", "outDirName", " outFileTime", "outDirTime", " outFilenameName", "outfileName", "outFilenamePath", "infileName", "outTableType", "outStreamType", "outfileType", "inFileTime", "outFileChain", " outFileType", "outTableTime", "infileNames", "outFileNames", " outFilePath", "infilePath", " outfileName", "outFPath", " outFilenameType", "outfileChain", "inFileName", "outFilenameChain", "outfilename", " outFileNames", " outFilenameChain", " outfilename", " outFileChain", "outFname", "outFilenameType", "outFileTime", "inFilePath", "outImagename", "outFName", " outfilePath", " outTableTime", " outFilenameSize", " outTablePath", "infileTime", " outTableSize", "outTablePath", " outFilename", "outDirPath", "outFilenameNames", "inFileType", "inFileNames", "outStreamNames", "outImageName", "outfilePath", "outImageSize", " outFileSize", "outFilePath", "outStreamName", "outTableSize", "outTablename"], "xsltParam": ["xsltParameter", "xsslParam", "xltParameter", "xsqlParam", "xltConf", "xsslConf", "xsslParameter", "xsmlParam", "xmlParam", "xsltConf", "xltParam", "xsqlParameter", "xmlConf", "xsmlParameter", "xsqlConf", "xsmlConf", "xmlParameter"], "artifact": ["artifacts", "artificial", "anificate", "ardificate", "ardificial", "artificate", " artificial", " artifacts", " artificate", "Artifacts", "ardifact", "anifacts", "partifact", "anificial", "arifact", "partifacts", "anifact", "Artifact", "arifacts", "ardifacts"], "destinationPath": ["destationDir", "estinationName", "destinerDir", "desturationpath", "desturationPath", " destinationTarget", " destociationDisk", "estinationKey", "desticationDir", "descositoryHost", "destATIONPort", "destociationHost", "destATIONPath", "destinationAt", "estinationPoint", "identinateKey", "destacementTime", "identinatePath", "destinatedTarget", "destificationLocation", "DestinationLocation", "estationPath", "estionPATH", "estationDir", "destinatePart", "destinationPoints", "destinationDisk", "destinatorPoint", "DestensionPath", "generinationAt", "destinationTime", "destinatorPath", "origininatedNow", "destregationpath", " destociationpath", "DestensionHost", "destificationDir", "destinationTemp", "DestensionTemp", "DestensionPod", "generinatePath", "destinoName", "destionPATH", "destinationName", "DestinationTemp", "destinateForm", "destinationJar", "chaininatedDisk", "desturationJar", "destociationPoint", "destinatedDisk", "destinatorParent", "destinantPod", "origininationForm", "generinateJar", "destinateLocation", "destinatedDriver", "destinateInfo", "destinerPart", "destesticSystem", "estinationHost", "destinatorpath", "estinationPATH", "destinateChain", "chaininationHome", "generinationSystem", "destinateUrl", "destinationForm", "destinatePath", "destinoTime", "estionPath", "destionpath", "destinantPath", "destositoryParent", "DestinationHost", "destinateNow", "delinationLog", "delinatePoints", "destociationHome", "destinateAt", "estinoPath", "destitutionPATH", "destitutionPoint", "destinerJar", "delinateForm", "destociationDisk", "destinationParent", "origininatedPath", "termininerTarget", " destinationpath", "generinationPath", "descinationParent", "destationPart", "identinateChain", "destinatedKey", "desticationPath", "destinateSystem", "destigationPath", "destinerSystem", "destacementKey", "DestinationPoint", "destesticJar", "destinationLocation", "destinationPATH", "chaininationDisk", "termininationJar", "delinationPoints", "destositoryPort", "destesticAt", "destinationpath", "destinatorPort", "destinationPart", "estinoKey", "estinoTime", "destationPath", "destinateKey", "destinateDir", "DestensionDir", "destensionTemp", "descinationPort", "destacementPath", "destinatorChain", "destregationDisk", "estinationDir", "delinationPath", "destinoHost", "destociationTarget", "chaininatedDriver", "estinationpath", "destinerAt", "destensionPath", "destociationLog", "destATIONParent", "DestinationPath", "destinationUrl", "termininationPath", "chaininatedPath", "destinatedPath", "destinationPort", "termininationTarget", "destositoryHost", "identinationChain", "generinateAt", "destationUrl", "destinerTarget", "termininationpath", "destinerpath", "destinationHost", " destociationPath", "destregationTarget", "origininationChain", "destinationLog", " destinationDisk", "destrancePoints", "descinationPath", "destensionHost", "destinateName", "destationHost", "estionpath", "destranceForm", "descinationHost", "generinateSystem", "DestificationPath", "destionPoint", "destinatorPATH", "destinatePoints", "destinationTarget", "destinoDir", "destigationNow", "destensionPod", "destinerHost", "destinationKey", "estinationPart", "destinoPath", "destinatedInfo", "destinatorHost", "estinationTime", "destacementName", "destitutionPath", "DestensionPoint", "destinationPod", "destinantTemp", "DestinationDir", "destensionPoint", "DestificationDir", "DestinationUrl", "delinatePath", "origininationPath", "origininationNow", "chaininationPath", "DestinationPod", "destventionDriver", "descositoryParent", "destinatedHome", "desticationPod", "destinationDir", "destranceLog", "descositoryPath", "destensionDir", "identinationKey", "destinateLog", "destinationInfo", "destventionPath", "destventionDisk", "estionPoint", "termininerPath", "generinationJar", "identinationPath", "desticationTemp", "delinateLog", "chaininationDriver", "destificationUrl", "destrancePath", "destinatepath", "destociationDriver", "destociationPath", "destinateJar", "destinationPoint", "chaininatedHome", "destventionHome", "destinationChain", "identinateInfo", "delinationForm", "destationLocation", "destATIONHost", "destinateTarget", "identinationInfo", "destinantDir", "destinateHost", "desturationTarget", "termininerpath", "destociationDir", "destitutionpath", "destociationPoints", "destinatedForm", "destociationForm", "destinationNow", "destigationForm", "destinatedNow", "termininerJar", "destinatedpath", "destinationDriver", "descositoryPort", "destinationSystem", "estationHost", "destociationpath", "destinatedChain", "origininatedChain", "destinoKey", "destositoryPath", "estinationPath", "destinateTime", "destionPath", "destinoPoint", "estinoName", "destigationChain", "destinatorKey", "destinationHome", "destregationPath", "estationPart", "DestificationLocation", "destinerPath", "destesticPath", "origininatedForm", "destificationPath", " destociationTarget", "DestificationUrl", "destinatorInfo"], "in": ["inner", "r", "din", "info", "w", "file", "bin", "i", "io", "id", "f", "m", "c", "In", "ins", "t", "IN", "o", "d", "doc", "l", "input", " IN", "reader", "n"], "out": ["msg", "obj", "println", "up", "cache", "ln", "conn", "go", "ch", "writer", "p", "it", "Out", "inv", "inner", "ex", "v", "nt", "w", "outer", "aos", "dis", "oe", "e", "cmd", "u", "file", "nr", "all", "log", "err", "sys", "ger", "b", "io", "gen", "f", "c", "res", "report", "cfg", "conf", "cn", "or", "ins", "t", "o", "l", "write", "output", "gr", "client", "con", "null", "os", "s", "to", "list", "co", "screen", "OUT", "outs", "net", "print", "can", "n", "raw", "ou"], "root": ["name", "Root", "println", "group", "child", "parent", "initial", "p", "New", "def", "Template", "scope", "se", "r", "parents", "node", "json", "config", "start", "de", "context", "roots", "data", "id", "dump", "m", "_", "impl", "chain", "create", "ok", "table", "dir", "tree", "graph", " roots"]}}
{"id1": "14390569", "id2": "21827619", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"title": ["name", "msg", "lead", "theme", "metadata", "html", "header", "string", "notice", "holiday", "description", "subject", "message", "tip", "content", "label", "question", "filename", "layout", "start", "template", "padding", " Title", "password", "setup", "type", "prefix", "heading", "details", "help", "parts", "text", "Title", "summary", "hash", "t", "term", "TIT", "itle", "size", "hd"], "imageURL": ["imageURI", "mediaURL", "mediaID", "ImageID", "photoURL", "photoUR", "mediaUrl", "photoString", "mediaURI", "photoUrl", "fileURI", " imageUrl", "ImageURL", "imageString", "imageUR", "ImageURI", "ImageUrl", "photoURI", "ImageUR", "fileString", " imageUR", "imageUrl", " imageString", "fileURL", "photoID", "imageID", " imageURI", "fileUrl"], "jd": [" jdt", "Jdo", " jad", "jjD", "Jp", "ujd", "qp", "ujad", " jdo", "jsd", "jjp", "ajd", "jobdt", "javadm", "jsdm", "Jbd", "jobd", "kdo", " jc", "jmd", "Jd", "javapd", "djd", "jD", "kbd", "simmd", "jjbd", "Jad", "simdt", "Jdt", "jbd", "ujD", "qD", "ajdm", "ijd", "djc", "ajds", "djsd", "djds", "gds", "simD", "jspd", "jsD", "javad", "jc", "ajpd", "kd", "jdm", "jsds", "ijD", "Jmd", "jobdo", " jsd", "qds", "jdo", "jad", "qbd", "jjd", "jpd", "ujdt", "simd", "kdt", "gdo", "zsd", "JD", "gd", "kds", "djad", "qdo", "djdo", "gbd", "ujmd", " jds", "javads", "qd", "Jc", "jds", "zad", " jD", "zd", "ijds", "Jds", "jdt"], "jl": ["Label", "ell", "elt", "gn", "ln", "uj", "ji", "jin", "ja", "yl", "igl", "kel", "ijk", "syn", "jc", "dll", "dyl", "j", "elly", "kl", " ol", "txt", "lp", " li", "dl", "kj", "abl", "lu", "jah", "il", "nl", "jet", "J", "jac", "bj", "rl", "mil", "isl", "ibl", "ij", "lv", "bol", "dj", "kn", "jj", "js", "elle", "li"], "icon": [" ion", "conn", " captcha", "image", "iban", "ocon", "chron", "eric", "png", " Icon", "ex", "fn", "ICO", " screen", " fruit", "pen", " widget", "Icon", " intent", "lock", "syn", "gc", "jc", "label", "ion", "nic", "fa", "conv", "cil", "\u4e2d", "addon", " tip", "pic", "font", "ic", "ico", " canvas", " lang", "con", "icol", "iao", " ancestor", " conn", "icons", "cn"], "chooser": ["composer", "poicer", " chooder", "boerer", "poose", "Choicer", "Choose", " choosen", " choerer", "Chooder", "choicer", "boosen", "boose", " choose", "CHOoser", "comperer", "choosen", "pooser", "compose", "CHOosen", "CHOicer", "choose", "composen", "booser", "Choosen", "pooder", " choicer", "compicer", "choerer", "chooder", "CHOose", "Chooser"], "jp": [" np", "p", " dj", "jin", "ja", "jc", " je", "np", " pl", " sp", "j", "JP", "bp", "kj", " gp", " pic", "bj", "pic", " joint", "ij", " cp", " ja", " sip", " ip", " ap", "js", "btn", "sp", " mp"], "jb": [" jbd", "qb", "qcb", "kjb", "kjcb", "Jb", "jbd", "qbd", "Jcb", "Jbd", "kjbd", " jcb", "jcb"], "e": ["p", "it", "E", "g", "v", "a", "w", "u", "ee", "event", "es", "f", "m", "c", "te", "or", "t", "en", "er", "o", "d", "s", "re", "ie", "ev", "ed", "n", "Event"], "returnVal": [" returnValue", "returnValid", "getVol", " returnVol", "retval", "responseValid", "ReturnValue", "ReturnVal", "Returnval", "returnVol", "returnValue", "returnval", " returnValid", "responseVal", "responseVol", "responseVAL", "getVal", "retVal", "getVAL", "retVAL", "returnVAL", "retValue", "getValid", "ReturnVAL", " returnval", " returnVAL"], "file": ["ile", "port", "name", "fp", "link", "work", "stat", "path", "le", "File", "image", "model", "full", "foo", "info", "target", "place", "run", "drop", "source", "filename", "buffer", "h", "resource", "io", "channel", "local", "FILE", "user", "library", "f", "il", "base", "type", "fs", "report", "http", "valid", "page", "status", "body", "or", "rule", "create", "angle", "class", "relation", "db", "table", "open", "get", "word", "dir", "null", "fe", "core", "to", "real", "tree", "document", "be", "handle", "format"], "fileName": ["handlename", "fileSystem", " fileClass", "FileNAME", "taskname", "FILENames", "FileExt", "FileName", "taskFace", "fileClass", "FileNames", "ileClass", "fileFace", "imageFace", " fileNAME", "handleNAME", "FILEPath", "handleClass", "filename", "FILEName", "fileExt", "FILESet", "FileFace", "ilename", "FileSystem", "entitySet", "filePath", "entityNAME", "taskPath", "fileNames", "imagePath", "handleName", "FILESystem", " fileNames", "fileNAME", "FILEExt", "imagename", "FILENAME", " fileSystem", "taskName", "Filename", " filename", "fileSet", " filePath", "FilePath", "ileName", " fileExt", "imageNAME", "entityPath", "entityName", "ileNAME", "imageName", "FileSet"], "ext": ["ix", "external", "exp", "len", "ord", "ag", "Ext", "ec", "aux", "exe", "part", "xt", "def", "EXT", "enc", "ex", "typ", "vert", "cmd", "ind", "txt", "sem", "cont", "lex", "eur", "prot", "t", "lib", "test", "xp", "exc", "dir", "word", "req", "pat", "end", "fr", "cod", "hex", "desc", "ct", "off"], "i": ["bi", "init", "mi", "is", "it", "phi", "gi", "ui", "si", "ini", "hi", "info", "iu", "cli", "ti", "ci", "ori", "j", "di", "id", "xi", "m", "fi", "status", "y", "ei", "qi", "ai", "I", "pi", "print", "index", "ii", "li"], "doIt": ["donIs", "didIt", "odoWhich", "diWhich", "doIT", "didYou", "donit", "waIT", "didIs", " doYou", "doneit", "waIt", " doWhich", "doHe", "doIs", "diHe", "doWhich", "waIs", " doIs", "doYou", "odoIt", " doIT", " doHe", " doit", "odoit", "donYou", "doneIt", "odoIT", "doit", "didit", "odoHe", "doneIT", "diIt", "donIt", "donIT", "diit"], "src": ["url", "sec", "comp", "init", "inst", "sq", "rs", "ource", "inner", "sh", "r", "copy", "sr", "sb", "rx", "lb", "source", "syn", "start", "sys", "gs", "ssl", "tmp", "conv", "ptr", "from", "cont", "sl", "http", "ctr", "rl", "crop", "rob", "impl", "ser", "ources", "ins", "st", "https", "loc", "usr", "rel", "proc", "sc", "rc", "sub", "rb", "input", "trans", "rt", "rest"], "dest": ["port", "cp", "origin", "est", "orig", "nom", "Dest", "master", "pipe", "nw", "target", "slave", "temp", "gest", "source", "sys", "comb", "tmp", "dat", "local", "coord", "pot", "cont", "way", "pas", "st", "desc", "mem", "out", "https", "loc", "foreign", "usr", "rel", "des", "proc", "output", "dir", "iter", "dist", "trans", "cat", "sp", "rest", "can", "decl"]}}
{"id1": "19810820", "id2": "11645260", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFileChannel": ["copyBytechannel", " copyFilesChannel", "copyFilechannel", " copyFileStream", " copyStreamChannel", " copyByteStream", " copyBytechannel", "copyByteFile", " copyFilechannel", " copyFilesFile", " copyStreamchannel", " copyStreamFile", " copyByteFile", "copyFileStream", " copyFilesStream", "copyFileFile", "copyByteChannel", "copyByteStream", " copyByteChannel", " copyFileschannel", " copyFileFile", " copyStreamStream"], "src": ["Source", "sec", "ls", "obs", "init", "inst", "sq", "bs", "rs", "dest", "sr", "sb", "rx", "syn", "source", "start", "sys", "filename", "SourceFile", "tmp", "RC", "txt", "usc", "sync", "from", "cont", "sl", "ctr", "rl", "st", "in", "cur", "ser", "ins", "sf", "img", "loc", "usr", "rel", "sc", "req", "rc", "s", "input", "js", "rt", "SOURCE"], "dst": [" dnd", "Ddest", "ddest", " dist", "jest", "Dth", "Dut", "Dest", "bist", "sest", "sth", "dest", "dth", "dnd", "best", " dth", "jut", "sst", "sut", "Dnd", "snd", "dut", " ddest", "jdest", "bdest", "jst", "bst", " dest", "sdest", "Dist", "dist", "Dst"], "preserveModificationTime": ["preserveQualificationsTime", "preserveModificationsTim", "preserveModifyPoint", "preserveModificationsTime", "preserveModifiedTime", "preserveModifierTimes", "preserveModificationTim", "preserveModifyTimes", "preserveModificationPoint", "preserveSpecificationTim", "preserveModificationsLength", "preserveModifyingLength", "preserveModifyingPoint", "preserveSpecificationTimes", "preserveSpecificationsTime", "preserveModificationLength", "preserveModifiedTimes", "preserveModifyTime", "preserveModifiedTim", "preserveSpecificationTime", "preserveQualificationsPoint", "preserveQualificationTime", "preserveModifierTim", "preserveQualificationsTimes", "preserveModificationsPoint", "preserveModifierTime", "preserveQualificationLength", "preserveQualificationsLength", "preserveSpecificationsTimes", "preserveModificationTimes", "preserveSpecificationsTim", "preserveModificationsTimes", "preserveModifyingTimes", "preserveModifyLength", "preserveQualificationPoint", "preserveModifyingTime", "preserveQualificationTimes"], "inputChannel": ["outputChuck", "innerChannel", "clientConnection", "inputCategory", "innerStream", "innerchannel", "clientChan", "infoChuck", "openConnection", "outputchannel", "inputBuffer", "outputStream", "outputChan", "inputListener", " inputConnection", "interfaceChannel", "inputChuck", "InputChan", " inputBuffer", "infoChannel", "innerChan", "inputStream", "InputStream", "outputBuffer", " inputGray", "inputChan", "evalChannel", " inputListener", " inputCategory", "openChannel", "entityChan", "interfaceListener", "hiddenChannel", "clientGray", " inputChuck", "entityChannel", "InputBuffer", "hiddenListener", "inputchannel", " inputStream", "inputConnection", "openGray", "openChan", "infoChan", "hiddenCategory", "infochannel", "interfaceCategory", " inputChan", "clientChannel", " inputchannel", "inputGray", "Inputchannel", "evalChan", "InputChannel"], "outputChannel": [" outputConnection", "coinChannel", "writeChannel", " outputButton", "displayButton", "writeChan", "putchannel", "outputchannel", " outputManager", "Outputchannel", "outputStream", "outputChan", "writeStream", "putChan", "writechannel", "writeManager", " outputchannel", "OutputStream", "putButton", "doubleChannel", "inputChan", " outputStream", "displayChan", "putChannel", "outputConnection", "coinInstance", "coinField", "doubleField", "inputManager", "webchannel", "inputConnection", "doubleChan", "OutputChan", "webChannel", " outputChan", "webManager", "outputButton", "coinChan", "inputField", "OutputChannel", "OutputConnection", "outputManager", "doubleInstance", "displaychannel", "displayChannel", "outputInstance", "outputField", "inputInstance", "OutputManager"], "length": ["volume", "then", "sequence", "len", "offset", "amount", "shape", "required", "full", "height", "present", "capacity", "max", "partial", "number", "json", "value", "all", "buffer", "start", "limit", "join", "ENGTH", "data", "padding", "available", "library", "ength", "base", "type", "needed", "time", "HH", "left", "details", "text", "load", "history", "loop", "duration", "l", "component", "term", "family", "expected", "count", "to", "position", "width", "list", "end", "size", "Length", "bytes"], "total": ["free", "sequence", "active", "offset", "amount", "full", "required", "equal", "created", "unique", "this", "description", "current", "info", "title", "max", "unknown", "last", "number", "all", "quant", "local", "less", "bar", "checked", "zero", "translation", "available", "num", "successful", "complete", "base", "done", "otal", "sum", "valid", "meta", "scale", "good", "ta", "t", "summary", "eta", "no", "count", "to", "stable", " Total", "size", "Total", "note", "used", "index", "raw", "human"]}}
{"id1": "17190057", "id2": "17158020", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"encode": ["EnCode", " enclose", "deode", " enode", "decode", "enclose", "Encode", "declose", "enCode", "Enclose", "Enode", " enCode", "deCode", "enode"], "input": ["name", "url", "sequence", "active", "image", "string", "it", "initial", "pattern", "act", "xml", "sample", "value", "cmd", "file", "hello", "source", "config", "buffer", " Input", "context", "data", "password", "audio", "q", "command", "form", "in", "check", "str", "text", "qi", "out", "address", "op", "Input", "output", "client", " inputs", "request", "qa", "print", "raw", "format"], "NoSuchAlgorithmException": ["NoSuchAlgorithmEx", "NoSuchAlryptionClass", "NoSuchALgorithClass", "NoSuchAlryptionException", "NoSuchALgorithmError", "NoSuchAlgorithmError", "NoSuchAlgorithError", "NoSuchALgorithException", "NoSuchAlgorithException", "NoSuchALgorithmClass", "NoSuchALgorithError", "NoSuchAlgorithmClass", "NoSuchALgorithEx", "NoSuchAlgorithClass", "NoSuchAlgorithEx", "NoSuchAlryptionError", "NoSuchALgorithmException", "NoSuchAlryptionEx", "NoSuchALgorithmEx"], "md": ["sm", "msg", "metadata", "dig", "mt", "def", "cd", "mb", "MD", "add", "nt", "dm", "mm", "der", "od", "cmd", "ng", "hd", "ind", "bd", "de", "sd", "mod", "ad", "sam", "di", "ld", "m", "det", "pdf", "pm", "mp", "rm", "red", "desc", "mg", "ms", "mn", "d", "cm", "nd", "mand", "strong", "js", "dd", "mc", "dr", "mk", "df", "pd", "sha"]}}
{"id1": "4056444", "id2": "22035737", "code1": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "code2": "    private static void loadMappings(Configuration cfg) {\n        try {\n            Enumeration en = LoadingUtils.getResources(MAPPINGS_FILE);\n            while (en.hasMoreElements()) {\n                URL url = (URL) en.nextElement();\n                logger.info(\"Found mapping module \" + url.toExternalForm());\n                InputStream inputStream = null;\n                try {\n                    inputStream = url.openStream();\n                    HibConfiguration hm = loadModuleMappings(inputStream);\n                    configureModuleMappings(cfg, hm.getSessionFactory());\n                } catch (IOException e) {\n                    logger.warn(\"Could not load mappings file \\\"\" + url.toExternalForm() + \"\\\"\", e);\n                } catch (JAXBException e) {\n                    logger.warn(\"Unable to instantiate JAXBContext \", e);\n                } finally {\n                    try {\n                        if (inputStream != null) inputStream.close();\n                    } catch (IOException e) {\n                        logger.debug(e);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            logger.warn(\"Could not find any mappings file hibernate.mappings.xml\", e);\n        }\n    }\n", "label": 0, "substitutes": {"hashPassword": [" hashpassword", "hashUser", "HashUser", "Hashpassword", "HashPassword", "updatepassword", " hashUser", "hashText", "updateUser", "updateText", "updatePassword", "hashpassword", " hashText", "HashText"], "password": ["attribute", "name", "key", "p", "string", "required", "PASS", "pattern", "present", "wd", "description", "message", "w", "expression", "database", "value", "hello", "Password", " Password", "email", "data", "padding", "default", "user", "login", "report", "sword", "command", "prefix", "random", "text", "address", "phrase", "word", "shadow", "account", "input", "reset", "pass", "token", "username", "secret"], "md": ["sm", "del", "mt", "cd", "mb", "MD", "sh", "add", "dm", "dh", "mo", "mm", "der", "od", "cmd", "grad", "hd", "ind", "bd", "sd", "mod", "ad", "sam", "di", "ld", "m", "det", "med", "hed", " Md", "pm", "red", "ms", "desc", "mg", "mn", "d", "cm", "db", "mand", "dd", "mc", "dr", "mk", "df", "pd", "sha"], "hash": ["name", "cache", "html", "array", "key", "dig", "full", "string", "version", "state", "char", "auth", "sh", "bh", "message", "mac", "value", "file", "all", "h", "mod", "build", "score", "ash", "map", "user", "id", "hed", "search", "Hash", "format", "crypt", " hashing", "sum", "username", "mask", "check", "code", "address", "test", "block", "shadow", "row", "token", "hex", "print", "filter", "has", "index", "secret", "handle", "sha"]}}
{"id1": "14390569", "id2": "21308543", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"title": ["name", "msg", "lead", "theme", "metadata", "html", "header", "string", "notice", "holiday", "description", "subject", "message", "tip", "content", "label", "question", "filename", "layout", "start", "template", "padding", " Title", "password", "setup", "type", "prefix", "heading", "details", "help", "parts", "text", "Title", "summary", "hash", "t", "term", "TIT", "itle", "size", "hd"], "imageURL": ["imageURI", "mediaURL", "mediaID", "ImageID", "photoURL", "photoUR", "mediaUrl", "photoString", "mediaURI", "photoUrl", "fileURI", " imageUrl", "ImageURL", "imageString", "imageUR", "ImageURI", "ImageUrl", "photoURI", "ImageUR", "fileString", " imageUR", "imageUrl", " imageString", "fileURL", "photoID", "imageID", " imageURI", "fileUrl"], "jd": [" jdt", "Jdo", " jad", "jjD", "Jp", "ujd", "qp", "ujad", " jdo", "jsd", "jjp", "ajd", "jobdt", "javadm", "jsdm", "Jbd", "jobd", "kdo", " jc", "jmd", "Jd", "javapd", "djd", "jD", "kbd", "simmd", "jjbd", "Jad", "simdt", "Jdt", "jbd", "ujD", "qD", "ajdm", "ijd", "djc", "ajds", "djsd", "djds", "gds", "simD", "jspd", "jsD", "javad", "jc", "ajpd", "kd", "jdm", "jsds", "ijD", "Jmd", "jobdo", " jsd", "qds", "jdo", "jad", "qbd", "jjd", "jpd", "ujdt", "simd", "kdt", "gdo", "zsd", "JD", "gd", "kds", "djad", "qdo", "djdo", "gbd", "ujmd", " jds", "javads", "qd", "Jc", "jds", "zad", " jD", "zd", "ijds", "Jds", "jdt"], "jl": ["Label", "ell", "elt", "gn", "ln", "uj", "ji", "jin", "ja", "yl", "igl", "kel", "ijk", "syn", "jc", "dll", "dyl", "j", "elly", "kl", " ol", "txt", "lp", " li", "dl", "kj", "abl", "lu", "jah", "il", "nl", "jet", "J", "jac", "bj", "rl", "mil", "isl", "ibl", "ij", "lv", "bol", "dj", "kn", "jj", "js", "elle", "li"], "icon": [" ion", "conn", " captcha", "image", "iban", "ocon", "chron", "eric", "png", " Icon", "ex", "fn", "ICO", " screen", " fruit", "pen", " widget", "Icon", " intent", "lock", "syn", "gc", "jc", "label", "ion", "nic", "fa", "conv", "cil", "\u4e2d", "addon", " tip", "pic", "font", "ic", "ico", " canvas", " lang", "con", "icol", "iao", " ancestor", " conn", "icons", "cn"], "chooser": ["composer", "poicer", " chooder", "boerer", "poose", "Choicer", "Choose", " choosen", " choerer", "Chooder", "choicer", "boosen", "boose", " choose", "CHOoser", "comperer", "choosen", "pooser", "compose", "CHOosen", "CHOicer", "choose", "composen", "booser", "Choosen", "pooder", " choicer", "compicer", "choerer", "chooder", "CHOose", "Chooser"], "jp": [" np", "p", " dj", "jin", "ja", "jc", " je", "np", " pl", " sp", "j", "JP", "bp", "kj", " gp", " pic", "bj", "pic", " joint", "ij", " cp", " ja", " sip", " ip", " ap", "js", "btn", "sp", " mp"], "jb": [" jbd", "qb", "qcb", "kjb", "kjcb", "Jb", "jbd", "qbd", "Jcb", "Jbd", "kjbd", " jcb", "jcb"], "e": ["p", "it", "E", "g", "v", "a", "w", "u", "ee", "event", "es", "f", "m", "c", "te", "or", "t", "en", "er", "o", "d", "s", "re", "ie", "ev", "ed", "n", "Event"], "returnVal": [" returnValue", "returnValid", "getVol", " returnVol", "retval", "responseValid", "ReturnValue", "ReturnVal", "Returnval", "returnVol", "returnValue", "returnval", " returnValid", "responseVal", "responseVol", "responseVAL", "getVal", "retVal", "getVAL", "retVAL", "returnVAL", "retValue", "getValid", "ReturnVAL", " returnval", " returnVAL"], "file": ["ile", "port", "name", "fp", "link", "work", "stat", "path", "le", "File", "image", "model", "full", "foo", "info", "target", "place", "run", "drop", "source", "filename", "buffer", "h", "resource", "io", "channel", "local", "FILE", "user", "library", "f", "il", "base", "type", "fs", "report", "http", "valid", "page", "status", "body", "or", "rule", "create", "angle", "class", "relation", "db", "table", "open", "get", "word", "dir", "null", "fe", "core", "to", "real", "tree", "document", "be", "handle", "format"], "fileName": ["handlename", "fileSystem", " fileClass", "FileNAME", "taskname", "FILENames", "FileExt", "FileName", "taskFace", "fileClass", "FileNames", "ileClass", "fileFace", "imageFace", " fileNAME", "handleNAME", "FILEPath", "handleClass", "filename", "FILEName", "fileExt", "FILESet", "FileFace", "ilename", "FileSystem", "entitySet", "filePath", "entityNAME", "taskPath", "fileNames", "imagePath", "handleName", "FILESystem", " fileNames", "fileNAME", "FILEExt", "imagename", "FILENAME", " fileSystem", "taskName", "Filename", " filename", "fileSet", " filePath", "FilePath", "ileName", " fileExt", "imageNAME", "entityPath", "entityName", "ileNAME", "imageName", "FileSet"], "ext": ["ix", "external", "exp", "len", "ord", "ag", "Ext", "ec", "aux", "exe", "part", "xt", "def", "EXT", "enc", "ex", "typ", "vert", "cmd", "ind", "txt", "sem", "cont", "lex", "eur", "prot", "t", "lib", "test", "xp", "exc", "dir", "word", "req", "pat", "end", "fr", "cod", "hex", "desc", "ct", "off"], "i": ["bi", "init", "mi", "is", "it", "phi", "gi", "ui", "si", "ini", "hi", "info", "iu", "cli", "ti", "ci", "ori", "j", "di", "id", "xi", "m", "fi", "status", "y", "ei", "qi", "ai", "I", "pi", "print", "index", "ii", "li"], "doIt": ["donIs", "didIt", "odoWhich", "diWhich", "doIT", "didYou", "donit", "waIT", "didIs", " doYou", "doneit", "waIt", " doWhich", "doHe", "doIs", "diHe", "doWhich", "waIs", " doIs", "doYou", "odoIt", " doIT", " doHe", " doit", "odoit", "donYou", "doneIt", "odoIT", "doit", "didit", "odoHe", "doneIT", "diIt", "donIt", "donIT", "diit"], "src": ["url", "sec", "comp", "init", "inst", "sq", "rs", "ource", "inner", "sh", "r", "copy", "sr", "sb", "rx", "lb", "source", "syn", "start", "sys", "gs", "ssl", "tmp", "conv", "ptr", "from", "cont", "sl", "http", "ctr", "rl", "crop", "rob", "impl", "ser", "ources", "ins", "st", "https", "loc", "usr", "rel", "proc", "sc", "rc", "sub", "rb", "input", "trans", "rt", "rest"], "dest": ["port", "cp", "origin", "est", "orig", "nom", "Dest", "master", "pipe", "nw", "target", "slave", "temp", "gest", "source", "sys", "comb", "tmp", "dat", "local", "coord", "pot", "cont", "way", "pas", "st", "desc", "mem", "out", "https", "loc", "foreign", "usr", "rel", "des", "proc", "output", "dir", "iter", "dist", "trans", "cat", "sp", "rest", "can", "decl"]}}
{"id1": "1769771", "id2": "300397", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyLine", "CopyLine", "CopyFile", " CopyFiles", "CopyStream", " copyLine", "copyStream", "CopyFiles", " CopyFile", " CopyStream", " copyFiles", "copyFiles", " CopyLine"], "in": ["inn", "inc", "up", "init", "is", "inner", "isin", "old", "ini", "r", "din", "mm", "b", "source", "bin", "i", "io", "gin", "on", "from", "In", "el", "ic", "ins", " input", "en", "IN", "l", "input", "cin", "rin", "inf", "ind"], "out": ["msg", "up", "p", "it", "Out", "v", "ex", "nt", "w", "file", "b", "update", "log", "err", "io", "serv", "gt", "c", "po", "res", "ot", "help", "op", "t", "at", "o", "l", "output", "os", "to", "s", "outs", "OUT", "net", "n", "ou"], "inChannel": ["dinConnection", " inCase", "Inchannel", "inScope", " inConnection", "cinRoom", "innCase", "insideClient", "inCommand", "dinChannel", "insideChannel", "InChannel", "innButton", " inCategory", "intChannel", "dinChan", "inClient", "sinClient", "outchannel", " inRoom", " inCommand", "cinCommand", "outChan", "ainClient", "insideCategory", "inCase", "ainScope", "sinCase", "inchannel", "cinChannel", "inCategory", "inConnection", "ainChannel", " inClient", "insideScope", "ainCategory", "sinChannel", "innClient", "innChannel", " inScope", " inChan", "inRoom", "sinButton", "intchannel", "outConnection", " inButton", "intCommand", "InCommand", "InChan", "sinRoom", "sinCommand", "dinchannel", "inButton", "inChan", " inchannel", "intChan"], "outChannel": ["inMember", " outMany", " outChan", "blockChannel", "outCh", "neChan", "aosSection", "neMember", "outManager", "outMember", "parentMany", "blockChan", "outputchannel", " outCh", "outMany", "inSection", "outSection", " outGate", "outputChan", "outputCh", "cnChannel", "outGate", "outchannel", "parentChannel", "outputChannel", " outchannel", "outChan", "aosChannel", "aosChan", "inchannel", "blockGate", "blockMany", "cnChan", " outManager", "neChannel", "inCh", "parentChan", "aosMember", "outputManager", "parentGate", "inChan", "cnManager", "neSection"]}}
