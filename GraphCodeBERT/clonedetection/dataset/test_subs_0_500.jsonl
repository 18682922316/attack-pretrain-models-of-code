{"id1": "20310134", "id2": "13516684", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpStream", " cpDirectory", " duplicateFile", " CopyDirectory", " cpFile", " CopyFile", " copyfile", " Copyfile", " duplicateDirectory", " duplicateStream", " copyStream", " CopyStream", " cpfile", " duplicatefile", " copyDirectory"], "in": ["b", "In", "is", "init", "on", "input", "rin", "id", "it", "r", "ain", "IN", "inn", "l", "inf", "as", "ins", "source", "inc", "from", "en", "ic", "up", "io", "el", "ind", "old", "din", "mm", "isin", "cin", "i", "gin", "ini"], "out": ["b", "ex", "at", "OUT", "net", "ou", "it", "err", "output", "nt", "t", "help", "l", "s", "gt", "c", "Out", "n", "null", "os", "p", "to", "io", "op", "ne", "outs", "msg", "w", "po", "g", "log", "serv", "v", "o", "ot"], "inChannel": ["oinApplication", "outchannel", " inApplication", "sinButton", "intButton", " inchannel", " inRoom", "insidePanel", "intChannel", " inClient", "inputPanel", " inListener", "oinChannel", " inCase", "cinListener", "inConnection", "inListener", "inputChannel", " inChan", "outConnection", "insideChannel", " inConnection", "sinRoom", "inApplication", " inButton", "dinCommand", "oinchannel", "inCase", "inClient", " inPanel", "cinButton", "inButton", "inCommand", "dinButton", "outApplication", "oinConnection", "inRoom", "insideCommand", "sinCase", "sinChannel", "cinChannel", "sinClient", "intCommand", "intChan", "cinClient", "cinCase", "inchannel", "inChan", "dinChannel", "sinListener", "cinRoom", "inPanel", " inCommand", "inputCommand", "dinChan"], "outChannel": ["outchannel", "outputCh", "fullChan", " outCategory", " outChan", "outCategory", "fullChannel", "cosChan", "OUTCan", "outerConnection", "inCh", "outputchannel", "outerChan", "cosChannel", " outConnection", "cosCategory", " outUser", "outConnection", "inCategory", " outCh", "outMember", " outCan", "OUTCategory", " outchannel", "fullCan", "OUTChan", "outputChan", "noteChan", "outUser", "noteMember", "noteChannel", "noteCategory", "outputChannel", "inMember", "outCh", "OUTChannel", "outCan", "outerChannel", "outerUser", "outputUser", "inchannel", "inChan", "outChan", "fullCategory", "cosMember", "outputConnection"]}}
{"id1": "19086952", "id2": "19868933", "code1": "    public static HttpResponse createUrlResponse(final URL url, final TcpConnection connection) throws IOException, NullPointerException {\n        String fullPath = url.toString();\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        final long length = conn.getContentLength();\n        if (connection.isDebugEnabled()) connection.logDebug(\"Sending \" + fullPath + \" to \" + connection.getRemoteAddress() + \" (length: \" + length + \").\");\n        return createInputStreamResponse(in, conn.getContentType(), length, connection);\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"createUrlResponse": ["createUrlView", "createFileResponse", "createFileResp", "createURLresponse", " createUrlresponse", "createurlresponse", "createFileresponse", " createURLResp", "createURLView", " createUrlView", " createURLResponse", "createurlResp", "createurlResponse", " createUrlResp", "createURLResp", " createURLresponse", "createurlView", "createFileView", "createURLResponse", "createUrlResp", " createURLView", "createUrlresponse"], "url": ["b", "ls", "path", "dl", "cert", "http", "URL", "sql", "address", "file", "l", "ur", "link", "string", "parser", "str", "gl", "job", "client", "email", "web", "html", "nl", "org", "browser", "image", "loc", "domain", "host", "mount", "uri", "char", "xml", "document", "el", "get", "build", "Url", "mail", "ssl", "location", "base", "bel", "name", "ll", "pl", "call"], "connection": ["message", "generation", "creator", "Connection", "ctx", "thread", "number", "application", "open", "subject", "context", "output", "database", "ion", "description", "session", "config", "current", "link", "network", "client", "directory", "intention", "builder", "c", "entry", "connected", "reason", "window", "self", "close", "computer", "processor", "to", "document", "nc", "command", "handler", "socket", "position", "using", "writer", "callback", "remote", "usage", "controller", "log", "condition", "con", "process", "server", "communication", "location", "response", "connect", "channel", "pool", "relation"], "fullPath": ["fullpath", " fullPort", "partialUrl", "FullPath", " fullpath", "fullName", "FullUrl", "Fullpath", "FullName", "partialPath", "partialName", "fullPort", "partialpath", "partialPort", " fullName", "fullUrl", "FullPort", " fullUrl"], "conn": ["obj", "init", "Conn", "ctx", "Connection", "cert", "conf", "alloc", "open", "comm", "cfg", "nt", "col", "reg", "exec", "oss", "cell", "ann", "cb", "proc", "connected", "c", "loc", "n", "cp", "ct", "cmd", "resp", "canon", "num", "nc", "iw", "desc", "ch", "conv", "enc", "con", "jp", "cont", "co", "res", "cur", "connect", "j", "pg", "ns"], "in": ["In", "ad", "user", "is", "or", "on", "out", "input", "rin", "sql", "m", "file", "IN", "ma", "reader", "inn", "and", "inside", "inf", "bin", "ins", "n", "stream", "inc", "from", "mc", "en", "mi", "ind", "body", "din", "isin", "get", "cin", "i", "gin", "sum", "inner"], "length": ["message", "path", "value", "offset", "number", "HH", "type", "address", "filename", "amount", "distance", "description", "ENGTH", "count", "left", "l", "frame", "string", "load", "padding", "size", "family", "end", "h", "len", "width", " Length", "loop", "ength", "result", "height", "sequence", "text", "position", "Length", "phi", "enc", "impl", "duration", "shape", "loss", "buffer", "history", "total", "data", "volume", "time"]}}
{"id1": "20929570", "id2": "11865906", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"toMd5": ["toDmHash", "toMd512", "toDd512", "toMMDHash", "toMmd512", "toMmd5", "toMm4", "toDdHash", "toMmd4", "toDm4", "toDm5", "toMm5", "toMdHash", "toMd4", "toMmHash", "toMm512", "toMMD5", "toDd5", "toMmdHash", "toDd4", "toMMD4", "toDm512", "toMMD512"], "str": ["b", "obj", "out", "input", "it", "r", "t", "s", "Str", "string", "ctr", "utt", "c", "n", "this", "txt", "a", "br", "p", "arr", "in", "char", "sp", "msg", "cr", "st", "text", "w", "STR", "ch", "wr", "enc", "e", "print", "v", "data", "name"], "messageDigest": ["messageDefester", "applicationDigest", "applicationdigse", "messageDecests", "messageDefer", "messageDigert", " messageDigester", "messageDigse", "messageDesignester", " messageDigse", "Messagedigests", "applicationdigest", "messagedigest", "Messagediger", "applicationdigester", "messageDester", "messageDecest", " messageDert", "MessageDigse", "messageDest", "MessagedigEST", "messageDecested", "messagemdse", "Messagedigse", " messageDigist", "messagedigist", "messagedigse", " messageDse", "applicationdigested", "messageDesignest", " messageDester", "messagediger", "messageDigEST", "messageDse", "messagedigert", "applicationDigester", "messageDecester", "messagedigEST", " messageDigert", "messagemdest", "messageDesignse", "messageDigist", "messagedigester", " messageDest", "messageDefEST", "messagemdert", "MessageDigester", "Messagedigester", "messagedigests", "applicationDigse", "messageDigester", "MessageDigest", "messageDert", "messagemdester", "MessageDigests", "messageDesignests", "applicationDigested", " messageDiger", "messageDecse", "messageDigests", "MessageDiger", "Messagedigest", "messageDefest", "messageDefist", "MessageDigEST", "messageDesignested", "messageDiger", "messagedigested", "messageDigested"], "byteArray": [" byteList", "viewArray", "fieldRAY", "helloBuffer", "byteString", "basicarray", "basicBuffer", " byteAddress", "fieldArray", "bytesAddress", "entityBuffer", "bytesRAY", "helloArray", "entityArray", "resourceStream", " byteRAY", "basicString", " byteString", "basicAddress", "viewStream", "resourceArray", "bytesLength", "fieldLength", " byteBuffer", "byteList", "seBuffer", "byteLength", "byteRAY", "seArray", "resourceBuffer", "entityList", " byteLength", "byteStream", "byteAddress", "entityarray", "bytearray", "viewBuffer", "basicArray", "basicList", "byteBuffer", "bytesArray", " byteStream", "bytesString", " bytearray"], "md5StrBuff": ["md5StringDb", "md5RatBuff", "md5StPref", "md4StringPref", "md5ObjBuff", "md5StrVert", "md4StrPref", "md4Strbuff", "md65TextBuff", "md4StringBuff", "md5RatBuffer", "md5BuffDb", "md7StringBu", "md5StringPref", "md8RatVert", "md5Buffbuff", "md65TextBuffer", "md5StCop", "md5ObjComp", "md5strComp", "md4StrBuff", "md5ObjVert", "md5StringBu", "md5TextBuff", "md7StrBu", "md7StringBuff", "md5strbuff", "md7StrPref", "md5StBuffer", "md7Strbuff", "md5StringCop", "md65StrComp", "md5Stbuff", "md5StBuff", "md5strVert", "md65StrCop", "md5StrPref", "md5ObjBuffer", "md5strBuffer", "md7StrBuff", "md4Stringbuff", "md5TextComp", "md5StrBu", "md8RatBuffer", "md5StringBuffer", "md65StrBuff", "md5StrComp", "md5TextCop", "md5StringBuff", "md5strBuff", "md8RatBuff", "md5StringComp", "md5BuffPref", "md5RatVert", "md7StringPref", "md5Stringbuff", "md5BuffBuff", "md8StrVert", "md65TextComp", "md4StrDb", "md5Strbuff", "md5StrDb", "md5StrBuffer", "md65StrBuffer", "md4StringDb", "md8StrComp", "md5TextBuffer", "md5StBu", "md8StrBuff", "md5strPref", "md5StrCop", "md5strBu", "md5strDb", "md7Stringbuff", "md8RatComp", "md5RatComp", "md8StrBuffer", "md65TextCop", "md5StComp"], "i": ["ex", "is", "my", "us", "cgi", "gi", "it", "xi", "info", "ci", "li", "gravity", "I", "m", "list", "t", "s", "l", "ai", "ix", "gu", "ki", "x", "c", "hi", "bi", "n", "ii", "q", "a", "go", "u", "multi", "mi", "h", "ic", "in", "batch", "uri", "major", "index", "io", "y", "ind", "json", "slice", "im", "phi", "iu", "status", "conv", "e", "ji", "chain", "me", "si", "v", "ei", "pi", "o", "ti", "cli", "j", "ui", "di", "ini", "ip"]}}
{"id1": "397240", "id2": "11933797", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrites", "readAndRepWrite", "readAndResWrite", "readAndRewend", "readAndResend", "readAndrewrite", "readAndrewWrite", "readAndResrite", "readAndRewrites", "readAndrewrites", "readAndReprite", "readAndrewend", "readAndRewWrite", "readAndRepend", "readAndReprites"], "inFile": ["InFile", "inputFilename", "docFile", "docFILE", "iFILE", "iFilename", "INTime", "inFILE", "InFilename", "initPlace", "initFilename", "inputPlace", "docTime", "inFace", "outfile", "infile", "iFile", " inFilename", "initFile", "inPlace", "INPlace", "docFilename", " infile", "inTime", "Infile", "initFace", "INFace", "iTime", "INFilename", "INFile", "INFILE", "inputFile", "inputFace", "inFilename", "outFilename"], "outFile": ["reportFile", " outFilename", "checkFilename", "outFILE", "inFILE", "toFILE", "reportFILE", "tofile", "nameFilename", "outfile", "infile", " outFILE", "reportfile", "reportFilename", "toFilename", "namefile", "nameFile", "toFile", "checkFile", " outfile", "checkFILE", "inFilename", "outFilename", "nameFILE", "checkfile"], "iis": [" iris", "iiIs", "liris", "iIS", "eis", "aiis", "Iiss", "liisc", "Ii", "liIs", "liis", "eIS", "iiisc", "ii", " iiss", "iiss", "iiis", "iiris", " iIs", "iIs", " iIS", "diIs", " ii", "iisc", "IIs", "eIs", "aiIS", "dii", "aiIs", "diis", " iisc", "iris", "Iis", "diiss"], "dcmParser": ["dgrParser", " dpmListener", "dpcReader", "dpmAssistant", "DpmReader", "dcrparser", "dcommReader", " dpmarser", "dcmListener", "dmoduleReader", "dmoduleAssistant", " dpmStatement", "dpmLoader", "dmmParser", " dcmarser", " dpmparser", "dcommListener", "deromParser", "dpmBuilder", "dromparser", "dcmAdapter", "dcrParser", "dfmParser", "dpmStatement", "dmmmReader", " dcmLoader", "dcomReader", "dcmBuilder", "dromAssistant", "DpmAdapter", "dcrBuilder", "dpmPrivate", " dcmPar", "dcomBuilder", "dcrReader", " dpmReader", "dcommAssistant", " dpmLoader", " dcmStatement", " dcmAssistant", "dmmarser", "dmmparser", "DcmBuilder", "dpmarser", "dgrStatement", " dcmBuilder", "dmmmparser", "dcmparser", "dcfStatement", "dromReader", "dcmAssistant", "decmParser", " dcmListener", "deromarser", "Dpmparser", "decmReader", "DcmParser", "dpmAdapter", " dpmParser", "dcmStatement", "dgrReader", " dpmPar", "DpmPar", "dmReader", "decmarser", "dpcAssistant", "DpmBuilder", "dmmReader", "decmparser", "drumParser", "dromarser", " dpmBuilder", " dcmPrivate", "dpcParser", " dpmAssistant", "dcmLoader", "DcmReader", "dromParser", "dmmmParser", " dcmparser", "dmmAdapter", "DpmParser", "drumReader", "dfmReader", "dpmReader", "dgrPar", "dcmReader", "dcfReader", "deromReader", "Dcmparser", "deromparser", "dcommParser", "dmparser", "drumPar", " dcmReader", "dcmarser", "dmarser", "dcmPrivate", "dpmparser", "dcmPar", "dmParser", "dmmmAdapter", "dpcPrivate", "dcfPar", "dromListener", "dcomParser", "dmodulePrivate", "DcmAdapter", "drumBuilder", "dfmBuilder", "dfmLoader", "dpmListener", "dcomLoader", "dpmPar", "dmoduleParser", "dpmParser", "dcfParser", "DcmPar", " dpmPrivate"], "ds": ["ls", "cs", "dos", "dl", "gs", "eds", "dh", "ils", "fs", "des", "vs", "ys", "da", "der", "sv", "s", "gd", "dds", "sets", " des", "as", "ads", "hd", "dq", "rs", "uds", "tes", "xs", "df", "os", "details", "ins", "pd", "dd", "services", "in", "bs", "Ds", "ods", "sys", "obs", "outs", "dt", "hs", "pers", " DS", "eps", "its", "js", "dat", "bd", "ps", "dx", "ks", "ss", "drivers", "sd", "d", "aos", "qs", "data", "ws", "DS", "db", "es", "ims", "ns"], "pdReader": ["ddHelper", "ddParser", "pdLoader", "xdHelper", "pdParser", "tdWriter", "xdLoader", "tdRead", "ddLoader", "vdLoader", "pdRead", "dpCar", "dpLoader", "ddWriter", "ddReader", "pdCar", "ddRunner", "dpRunner", "pedReader", "tdParser", "hdParser", "tdReader", "pedLoader", "pedCar", "hdRead", "pdRunner", "vdHelper", "xdReader", "pdHelper", "hdWriter", "ddRead", "xdWriter", "dpReader", "vdReader", "pedRunner", "hdReader", "ddCar", "vdWriter"], "out": ["over", "full", "on", " err", "err", "t", "str", "ins", "p", "ent", "outs", "ch", "writer", "log", "conn", "con", "co", "sum", "sw", "v", "o", "auto", "name", "status", "gen", "inv", "obj", "ex", "ou", "all", "id", "nt", "s", "cb", "c", "end", "txt", "os", "nr", "cn", "in", "desc", "conv", "serv", "raw", "inner", "outer", "pool", "cfg", "at", "net", "tmp", "list", "pos", "Out", "n", "en", "up", "io", "sys", "w", "js", "aos", "res", "data", "we", "OUT", "cache", "it", "output", "oss", "client", "gt", "one", "null", "screen", "go", "cmd", "to", "opt", "flush", "msg", "gr", "inter"], "dcmEncParam": ["dcmEnPar", "dcmEnVal", "dcmencCmd", "dcmEncVal", "dcmEnParam", "dcmencParam", "dcmEscPar", "dmmencParam", "dcmDecParam", "dmmEncCmd", "dcmEncCmd", "dcmencNum", "dmmEncMsg", "dmmencNum", "dmmEncPar", "dcmEncPar", "dcmEscNum", "dmmEnPar", "dcmDecCmd", "dcmEncMsg", "dcmEnNum", "dmmEnNum", "dcmEscVal", "dcmDecMsg", "dcmEscParam", "dmmEncParam", "dmmencCmd", "dmmEnParam", "dmmEncNum", "dcmEncNum", "dcmDecNum", "dcmencPar", "dcmencMsg", "dmmEncVal", "dmmencMsg"], "pdWriter": ["dpEditor", "PDReader", "tdWriter", "dpWriter", "pidWrite", "PDWriter", "pdwriter", "pidWriter", "PDWrite", "tdWriting", "tdReader", "PDEditor", "pidwriter", "pidWriting", "dpWrite", "tdwriter", "pcWriter", "pcWrite", "pdWrite", "pdWriting", "pcwriter", "tdWrite", "pdEditor", "pcWriting", "dpReader", "tdEditor"]}}
{"id1": "692738", "id2": "15362793", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"url": ["b", "ls", "external", "path", "dl", "http", "URL", "sql", "r", "address", "file", "config", "l", "ur", "gl", "string", "str", "link", "browser", "job", "cl", "web", "html", "nl", "key", "term", "loc", "domain", "page", "q", "uri", "pattern", "util", "char", "rl", "xml", "default", "el", "ref", "get", "log", "Url", "pl", "ld", "impl", "ssl", "resource", "location", "base", "bel", "name", "ll", "mount", "sl", "un"], "in": ["In", "read", "online", "check", "is", "init", "on", "out", "input", "rin", "al", "update", "f", "login", "ln", "IN", "ma", "inn", "reader", "m", "s", "l", "ai", "bin", "again", "include", "c", "vin", "ins", "n", "source", "from", "mc", "null", "en", "mi", "oin", "body", "din", "isin", "min", "nin", "cin", "serv", "con", "i", "gin", " din", "line", "inner", "o", "name"]}}
{"id1": "21092340", "id2": "4750967", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addInHarive", "addToExFile", "addToArchFile", "addInArchiver", "addInArchive", "addToHarive", "addToZipFile", "addToExive", "addInArchZip", "addInArchFile", "addToZipive", "addToZipiver", "addInHariver", "addToExZip", "addToZipZip", "addToHarZip", "addToArchZip", "addInHarZip", "addToArchiver", "addToExiver", "addToHarFile", "addToHariver", "addInHarFile"], "pod": ["ad", "message", "check", "device", "wp", "component", "pick", "project", "pkg", "task", "pc", "zone", "job", "proc", "top", "Pod", "p", "cp", "ods", "archive", "op", "spec", "policy", "body", "report", "post", "ack", "od", "disk", "pad", "module", "start", "pack", "poll", "volume", "point", "table"], "podArchiveOutputStream": ["podArchiveEntryPoint", "podArchiverOutputSync", "podArchiveOutputPoint", "podArchiverInputForm", "podArchiverInputSync", "podArchiveOutputForm", "podArchiveInputForm", "podArchiverOutputPoint", "podArchiveOutputMap", "podArchiverOutputMap", "podArchiveEntrySteam", "podArchiveOutputContext", "podArchiveStreamMap", "podArchiveOutStream", "podArchiverInputContext", "podArchiveoutputStream", "podArchiverInputSteam", "podArchiveResourceSteam", "podArchiveMainForm", "podArchiveOutputstream", "podArchiveResourcestream", "podArchiveStreamStream", "podArchiveOUForm", "podArchiveOutputSteam", "podArchiveoutputSteam", "podArchiveInputStream", "podArchiveInputPoint", "podArchiveoutputForm", "podArchiveOUSync", "podArchiverInputMap", "podArchiverInputstream", "podArchiveInputStreamer", "podArchiverOutputForm", "podArchiveStreamForm", "podArchiveInputSteam", "podArchiveMainStreamer", "podArchiverOutputStreamer", "podArchiveStreamSync", "podArchiveMainStream", "podArchiveOutContext", "podArchiverOutputstream", "podArchiveInputstream", "podArchiveOUStream", "podArchiveInputContext", "podArchiveOUMap", "podArchiverOutputSteam", "podArchiveResourceContext", "podArchiveInputMap", "podArchiveEntryStream", "podArchiveOutPoint", "podArchiveoutputStreamer", "podArchiveResourceStream", "podArchiverInputStream", "podArchiveMainSteam", "podArchiveOutstream", "podArchiverInputPoint", "podArchiveOutputSync", "podArchiveOutSteam", "podArchiverOutputStream", "podArchiveInputSync", "podArchiveOutputStreamer", "podArchiverOutputContext", "podArchiverInputStreamer"], "filename": ["message", "path", "title", "url", "binary", "subject", "ename", "output", "FN", "file", "description", "fp", "Filename", "string", "release", "original", "directory", "nm", "key", "family", "fn", "txt", "p", "png", "jpg", "uri", "nil", "archive", "version", "username", "fil", "folder", "ame", "kl", "upload", "FILE", "NAME", "names", "resource", "location", "stem", "latest", "name", "prefix", "println"], "source": ["SOURCE", "template", "supp", "src", "store", "input", "component", "sql", "Source", "info", "address", "select", "force", "shell", "context", "file", "ser", "ource", "seed", "use", "proc", "loader", "image", "stream", "from", "copy", "password", "spec", "sequence", "view", "body", "style", "get", "iterator", "series", "resource", "inner", "start", "sample", "service"], "entry": ["obj", "ment", "ce", "or", "sheet", "ace", "component", "query", "card", "tmp", "nt", "file", "task", "quick", "zip", "se", "link", "cell", "record", "Entry", "job", "system", "key", "word", "row", "ent", "good", "char", "archive", "attribute", "cue", "element", "set", "ie", "log", "line", "enter", "connection", "resource", "data", "ry", "comment", "channel", "book"]}}
{"id1": "14168494", "id2": "14194234", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    private String File2String(String directory, String filename) {\n        String line;\n        InputStream in = null;\n        try {\n            File f = new File(filename);\n            System.out.println(\"File On:>>>>>>>>>> \" + f.getCanonicalPath());\n            in = new FileInputStream(f);\n        } catch (FileNotFoundException ex) {\n            in = null;\n        } catch (IOException ex) {\n            in = null;\n        }\n        try {\n            if (in == null) {\n                filename = directory + \"/\" + filename;\n                java.net.URL urlFile = ClassLoader.getSystemResource(filename);\n                if (urlFile == null) {\n                    System.out.println(\"Integrated Chips list file not found: \" + filename);\n                    System.exit(-1);\n                }\n                in = urlFile.openStream();\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuffer xmlText = new StringBuffer();\n            while ((line = reader.readLine()) != null) {\n                xmlText.append(line);\n            }\n            reader.close();\n            return xmlText.toString();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"Integrated Chips list file not found\");\n            System.exit(-1);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"copyFile": [" cpStream", " cpFile", " CopyFile", "CopyFile", "CopyStream", " copyfile", " Copyfile", " CopyByte", "CopyByte", " copyStream", " CopyStream", " cpfile", " copyByte", " cpByte", "Copyfile"], "dest": ["rest", "out", "usr", "del", "des", "tmp", "nt", "dir", "Dest", "gt", "etc", "origin", "loc", "source", "nom", "them", "orig", "img", "pub", "good", "to", "way", "master", "result", "st", "w", "target", "temp", "trans", "dist", "cont", "d", "nw", "v", "np", "www", "doc"], "src": ["ls", "init", "input", "sc", "Source", "usr", "file", "ser", "sec", "rx", "sr", "rc", "sq", "inst", "req", "loc", "ins", "rs", "source", "from", "img", "sys", "st", "desc", "sb", "upload", "iv", "sub", "sel", "cont", "start", "cur", "rel", "sl"], "srcChannel": [" srcchannel", "srcChan", "srcCh", "rcCommand", " srcChain", " srcChan", "sqCan", "sourceChan", "instCh", "instCan", "destChain", "sourceChannel", "bgChannel", "instChan", "srcMessage", "destChannel", "instPanel", "rcChan", "destMessage", "rcchannel", "instChain", "sysChannel", "sysChan", "srcchannel", "bgPanel", "destChan", "sqChannel", " srcMessage", "rcChain", "instChannel", " srcCommand", "rcMessage", "srcCommand", "srcCan", "syschannel", "sourceCh", "bgCan", " srcCh", "srcChain", "sqChain", "sysCommand", "rcChannel", "srcPanel", "bgChain", "sqPanel"], "dstChannel": [" dstCh", "pdestClient", "dotHandler", "ddestCommand", "dbrHandler", "ddestButton", "dstCommand", "pstChannel", "pstButton", "dstClient", " dotButton", " dotChannel", "dbrChannel", "pdestButton", "dotCh", "dstCh", "dndButton", "ddestClient", "pdestCommand", "dndChan", "ddestChannel", "dotChan", "pstClient", "dndCommand", "dbrCh", "destChannel", " dotHandler", "dndCh", " dstChan", " dotChan", "dndChannel", "ddestCh", "pdestChannel", "dstChan", "ddestHandler", "dbrChan", "ddestChan", "destClient", "pstCommand", "dndClient", "dotChannel", "dstHandler", " dstHandler", "destCommand", "destButton", "dotButton", " dotCh", " dstButton", "dstButton"]}}
{"id1": "5760649", "id2": "13563706", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "label": 1, "substitutes": {"createFile": ["saveFiles", "saveStream", "uploadFile", "createStream", "savefile", "uploadFiles", " createStream", "createfile", "saveFile", " createfile", "uploadStream", " createFiles", "uploadfile", "createFiles"], "src": ["dest", "obj", "SOURCE", "rect", "is", "input", "url", "sc", "ser", "fp", "config", "rx", "sec", "sr", "abs", "fc", "rc", "str", "ctr", "sq", "inst", "stream", "loc", "rs", "source", "from", "txt", "uri", "pour", "comp", "sys", "ipl", "st", "sb", "resource", "res", "start", "cur", "SourceFile", "sit"], "filename": ["ren", "path", "title", "subject", "ename", "output", "FN", "file", "fp", "ln", "bf", "Filename", "string", "nl", "nm", "fn", "family", "txt", "n", "png", "xxx", "jpg", "nil", "username", "fil", "kl", "FILE", "v", "stem", "location", "name", "prefix", "SourceFile", "println"], "fis": [" fIS", "sfiss", "afiss", "sfios", "afis", "Fios", "bfiss", "fios", " fisi", "Fis", "ffis", "sfis", " fios", "afios", "fiss", "ffIS", "Fisi", "ffisi", "fais", " fais", "fIS", "ffos", " fiss", "bfis", "afais", "bfios", "FIS", "fisi", "sfais", "Fos", "bfos", "Fiss"], "fos": ["flos", " foses", " foes", "fios", "wOS", "Fis", "boes", "wios", "bis", "tis", "boss", "toss", "wis", "Foes", "foses", "tios", "wor", "foss", "Foss", "bos", "fOS", "floss", "vOS", " foss", "wos", "vor", "voses", "tos", "foes", "woss", "vos", "woses", " fOS", "flis", "flios", "Fos"]}}
{"id1": "7044685", "id2": "9099457", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    public static String hash(String value) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] md5hash = new byte[32];\n            md.update(value.getBytes(\"iso-8859-1\"), 0, value.length());\n            md5hash = md.digest();\n            return Hex.encodeHexString(md5hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["encrypted", "crypt", "Encrypt", " encrypted", "crypted", "Encryption", "cryption", "encryption", " encryption", "Encrypted"], "plaintext": ["messagedata", "plainText", "messageprint", "messageText", "ainText", "plainstring", "aintext", "mainText", "ainstring", "aindata", " plaindata", "messagetext", "ainprint", " plainText", "maintext", "plainprint", " plainstring", " plainprint", "plaindata", "mainstring"], "d": ["ad", "nd", "dl", "cd", "D", "dr", "dh", " md", "ds", "f", "da", "red", "z", "m", "fd", "t", "done", "gd", "md", "debug", "l", "c", "de", "hd", "dal", "did", "end", "df", "p", "ord", "h", "pd", "dd", "ded", "y", "mod", "ind", "w", "dec", "dat", "g", "e", "ld", "bd", "od", "dig", "dx", "sd", "db", "di", "dm"]}}
{"id1": "6304373", "id2": "7468827", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrTics", "uploadOrDeleteMediaOrTemics", "uploadOrDeleteMediaOrTplates", "uploadOrDeleteMediaOrTTemplate", "uploadOrDeleteMediaAndTemics", "uploadOrDeleteMediaAndTemTemplate", "uploadOrDeleteMediaAndTics", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTemppl", "uploadOrDeleteMediaOrTpl", "uploadOrDeleteMediaOrTempplates", "uploadOrDeleteMediaOrTempics", "uploadOrDeleteMediaAndTemplates", "uploadOrDeleteMediaAndTplates", "uploadOrDeleteMediaAndTempl", "uploadOrDeleteMediaAndTpl", "uploadOrDeleteMediaAndTTemplate", "uploadOrDeleteMediaOrTemTemplate", "uploadOrDeleteMediaOrTempTemplate"], "action": ["change", "operation", "commit", "ACTION", "actions", "function", "format", "on", "wrong", "article", "update", "type", "address", "error", "instance", "actor", "what", "mode", "verb", "exclusive", "feature", "fun", "ACT", "acl", "go", "act", "method", "expression", "op", "version", "policy", "view", "scene", "edit", "ction", "step", "Action", "behavior", "controller", "ase", "process", "event", "active", "now", "operator", "admin", "activation", "call"], "object": ["obj", "operation", "item", "article", "format", "function", "number", "office", "subject", "address", "class", "information", "project", "instance", "unknown", "actor", "what", "job", "entry", "image", "detail", "one", "oid", "not", "act", "version", "document", "attribute", "element", "property", "no", "entity", "event", "thing", "resource", "integer", "module", "objects", "model", "o", "hash", "node", "volume", "relation"], "numElements": ["numNles", "numEleles", "numEles", " numelement", "numNlem", "numelements", "numElelem", "numElelement", "numElelements", "numNlements", " numEles", "numelem", "numNlement", "numelement", "numElem", " numeles", " numelements", "numeles", " numElem", " numelem"], "req": ["obj", " serv", "conf", " cir", "Resp", "request", " fr", "Requ", "quest", " request", " std", "tx", "qt", "Request", " cred", "txt", "q", "Cmd", " resp", " cmd", " requ", "msg", "Msg", "requ", " conf", " msg", " res", "res"], "session": ["ess", "group", "http", "store", "cache", "thread", "search", "subject", "context", "task", "request", "config", "use", "browser", "client", "Session", "tx", "system", "window", "ession", "sid", "manager", "ses", "state", "socket", "stack", "parent", "essions", "conn", "ssl", "connection", "event", "response", "status", "local"], "ftp": ["fttp", "aftp", "FTp", " ftP", "FTtp", "FTps", "afps", " ftps", "afp", "ftP", "FTP", "afP", "ftps", " fttp"], "user": ["dev", "person", "group", "auth", "device", "display", "human", "store", "ver", "query", "info", "usr", "open", "author", "users", "db", "ser", "config", "current", "per", "use", "plugin", "instance", "browser", "client", "record", "job", "self", "system", "USER", "student", "word", "rule", "User", "ter", "manager", "to", "util", "used", "basic", "er", "username", "owner", "sys", "result", "part", "view", "usa", "form", "by", "parent", "usage", "me", "account", "event", "mem", "other", "order"], "links": ["ls", "Links", "actions", "tags", "packages", "dir", "properties", "blogs", "link", "network", "self", "html", "groups", "projects", "types", "mails", "details", "href", "Link", "owners", "js", "relations", "lines", "items", "rel", "flags", "scripts", "pages"], "folders": ["contors", "foldes", "contories", "temors", "dirers", "conters", "dirories", "dires", "temories", "foldories", "dirors", "foldors", "temers", "contes", "temes"], "folder": ["path", "collection", "files", "device", "center", "sheet", "card", "filename", "context", "database", "project", "older", "dir", "zip", "zone", "division", "feed", "directory", "email", "root", "size", "system", "container", "family", "host", "lower", "box", "area", "layout", "loop", "gallery", "letter", "old", "sequence", "room", "upload", "stage", "controller", "fold", "Folder", "buffer", "enter", "resource", "module", "location", "base", "volume", "topic", "region"], "server": ["device", "center", "store", "Server", "ver", "url", "database", "mobile", "instance", "ser", "seed", "browser", "client", "directory", "email", "test", "system", "root", "slave", "peer", "domain", "host", "computer", "manager", "area", "er", "version", "scale", "owner", "handler", "site", "console", "socket", "port", "engine", "remote", "stage", "buffer", "enter", "connection", "resource", "serving", "erver", "service", "localhost"], "login": ["match", "pin", "auth", "bridge", "net", "note", "fail", "number", "id", "pass", "search", "filename", "database", "author", "join", "phone", "cell", "lock", "email", "submit", "john", "blog", "nic", "fn", "computer", "in", "ping", "basic", "username", "owner", "token", "ername", "Login", "mail", "ident", "log", "insert", "license", "cookie", "account", "connection", "print", "skin", "profile", "name", "nick", "admin", "secret", "ip"], "password": ["path", "sword", "auth", "device", "value", "sudo", "pass", "strip", "Password", "database", "description", "paste", "encrypted", "ssh", "stroke", "parser", "pretty", "performance", "python", "padding", "email", "wordpress", "exclusive", "confirmed", "word", "picture", "pattern", "username", "attribute", "power", "PASS", "another", "policy", "command", "token", "photo", "worker", "crypt", "hello", "escape", "resource", "hash", "profile", "productive", "phrase", "prefix", "comment", "pool", "secret", "restricted"], "fileTransferFolder": ["fileMoveFile", "fileDownloadDirectory", "fileImportfolder", "FileUploadFile", "FileUploadfolder", "fileImportLocation", "fileDownloadFolder", "fileDownloadfolder", "FileUploadArea", "FileTransferDirectory", "fileTransferDirectory", "fileTransferArea", "FileUploadLocation", "fileImportArea", "fileTransferLocation", "fileUploadDirectory", "fileUploadFolder", "fileMoveDirectory", "fileImportFolder", "fileDownloadFile", "fileUploadFile", "fileTransferFile", "FileUploadFolder", "fileMovefolder", "fileUploadfolder", "FileTransferFolder", "fileDownloadLocation", "fileUploadArea", "fileMoveFolder", "fileUploadLocation", "FileTransferLocation", "FileTransferArea", "fileTransferfolder", "fileDownloadArea", "FileUploadDirectory", "FileTransferfolder", "FileTransferFile"], "liveFolder": [" liveDirectory", " livefolder", "liveDir", "embedDir", "LiveFolder", "liveDirectory", "livefolder", "embedFolder", " liveDir", "embedDirectory", "LiveDirectory", "LiveDir", "embedfolder", "Livefolder"], "servers": ["serctors", "teors", "Serors", "servors", "Serctors", "tectors", "teers", "serers", "Serers", "serors", "Servers", "servctors", "tevers", "servvers"], "message": ["essage", "Message", "template", "flash", "number", "warning", "application", "media", "say", "description", "m", "string", "trace", "browser", "summary", "management", "memory", "window", "reason", "mess", "alert", "document", "command", "msg", "result", "sequence", "body", "report", "show", "mail", "log", "buffer", "content", "contact", "language", "response", "data", "comment", "status"]}}
{"id1": "20247400", "id2": "335223", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"in": ["In", "check", "is", "init", "net", "on", "input", "rin", "it", "info", "file", "IN", "inn", "and", "inf", "bin", "ai", "ins", "source", "inc", "from", "ze", "up", "io", "ind", "din", "isin", "cin", "con", "i", "gin", " din", "inner"], "out": ["b", "obj", "ex", "check", "at", "or", "OUT", "net", "ou", "it", "write", "r", "err", "output", "ln", "list", "dir", "t", "str", "oss", "client", "gt", "Out", "n", "null", "ins", "os", "screen", "exit", "cmd", "to", "io", "ne", "sys", "outs", "msg", "w", "report", "writer", "OU", "log", "line", "con", "print", "o", "outer", "auto", "other", "name", "ot", "println", "we"], "buffer": ["b", "message", "match", "block", "header", "channel", "iter", "template", "function", "bridge", "display", "cache", "component", "binary", "address", "output", "database", "se", "append", "trace", "queue", "size", "memory", "Buffer", "window", "key", "limit", "source", "filter", "batch", "flush", "processor", "document", "attribute", "result", "bar", "command", "sequence", "view", "length", "position", "clear", "stack", "temp", "pause", "library", "shape", "buf", "event", "history", "total", "available", "sample", "buff", "data", "phrase", "db", "comment", "index", "table", "variable"]}}
{"id1": "11341711", "id2": "20375440", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"makeBackup": ["makebackups", "makeStups", "makeDupid", "makeBackupid", "makeStupid", "createBackup", "createbackups", "makeDpoint", "createBackpoint", "makeStpoint", "makeStup", "createbackupid", "makeBackups", "makeBackpoint", "makebackupid", "makebackup", "createBackups", "createbackup", "makeDup", "createBackupid", "createbackpoint", "makebackpoint", "makeDups"], "dir": ["path", "iter", "dep", "dl", "dr", "or", "src", "store", "draw", "out", "DIR", "url", "wd", "dis", "del", "tmp", "pkg", "file", "fd", "direct", "zip", "md", "directory", "rad", "Dir", "ir", "window", "loc", "dd", "in", "addr", "handle", "ind", "folder", "y", "dat", "Directory", "mail", "disk", " d", "dist", "d", "base", "data", "db", "vol", "local", "doc", "dm"], "sourcedir": [" sourcedirs", "isourcedir", "soredir", " sourcesdir", " sourceddir", "isourcer", "sourcesel", "isourcedr", "sourcedirs", " sourcesir", "sourcesir", "sourceir", "sourcesdir", "soreddir", "sourcesirs", "senderel", "isourceddir", "sourceire", "sourceirs", "sourcedel", "sourcesire", "sourcesr", "senderr", "sourceddir", "sourcer", "sourcedire", "soredire", "sourceel", " sourcesirs", "isourceel", "soredirs", " sourcedire", "senderdir", "isourcedel", "senderir", "sourcedr", " sourcesire", "isourceir"], "destinationdir": ["destinatorDir", "destensionDir", "estinatordir", "stinationsdiv", "stinationsdb", "destensiondb", "destineddiv", "stinationdir", "destinationsdir", "estinatorfolder", "destiondb", "estinationdb", "destinedir", "stinationdiv", "stinationsdir", "destinationDir", "destinatordir", "estinatorDir", "destinationsir", "stinationsir", "destionDir", "estinationdir", "destionfolder", "stinationdb", "stinationir", "estinationfolder", "destensionfolder", "destinatorir", "destineddb", "destinatordb", "estinationDir", "destineddir", "destinatorfolder", "destinationdiv", "destinationsdiv", "destiondir", "destinationsdb", "destensiondir", "destinationir", "estinatordb", "destinatordiv", "destinationfolder", "destinationdb"], "destinationDirEnding": ["destinationDirENDING", "destinationDirENDding", "destinationDirEvenING", "destinationDirEndding", "destinationDirFeediting", "destinationDirENDging", "destinationDirEvener", "destinationFileEnding", "destinationDirEndING", "destinationDirEndging", "destinationDirectoryENDging", "destinationDirServer", "destinationDirEnder", "destinationDirectoryEndging", "destinationFileEvenING", "destinationDirFeeder", "destinationDirENDiting", "destinationDirServding", "destinationDirEvenging", "destinationFileEndING", "destinationDirServing", "destinationDirENDer", "destinationFileEvener", "destinationDirEvending", "destinationDirFeeding", "destinationDirEnditing", "destinationDirectoryEnding", "destinationDirENDing", "destinationDirectoryENDer", "destinationDirectoryENDing", "destinationDirEvening", "destinationFileEnditing", "destinationDirectoryENDding", "destinationDirectoryEndding", "destinationDirectoryEnder", "destinationDirServging", "destinationDirEveniting", "destinationFileEnder", "destinationDirFeedING", "destinationFileEvening", "destinationFileEveniting"], "files": ["ls", "headers", "states", "iles", "bytes", "faces", "strings", "modules", "links", "actions", "words", "docs", "keys", "fs", "facts", "ames", "filename", "users", "file", "list", "parents", "prints", "forms", "params", "reports", "parts", "projects", "Files", "types", "resources", "mails", "fixes", "tools", "details", "events", "bs", "classes", "issues", "features", "images", "sections", "lets", "its", "ports", "uploads", "fields", "plates", "members", "tests", "names", "lines", "errors", "assets", "objects", "items", "qs", "ids", "obs", "values", "pages"], "checkdir": [" checkir", "ckthis", " checkfolder", "ckDir", "Checkdir", "workurl", "checkedfolder", "checkfolder", "checkurl", "workdir", "checkir", " checkthis", "checkeddb", "workDir", "checkdb", " checkdirectory", "checkeddir", " checkblock", "getfolder", "ckfolder", " checkDir", "keydir", "checkedir", "keydb", "Checkroom", "keyfolder", "checkblock", "getblock", "Checkblock", "CheckDir", "ckurl", "getdb", "ckroom", "workthis", "keyroom", "checkeddirectory", "checkDir", "checkedDir", "ckdir", "Checkfolder", "checkthis", "checkdirectory", "ckdirectory", "ckdb", "Checkdirectory", "getdir", "Checkir", "Checkdb", " checkdb", "checkroom", " checkurl"], "date": ["when", "user", "day", "note", "iso", "file", "use", "ate", "add", "zone", "de", "key", "close", "year", " day", "late", "dt", "msg", "set", "cal", "te", "dat", "none", "get", "month", "event", "resource", "d", "start", "now", "data", "Date", "tag", "time", "diff", "today", "doc", "ATE", " Date"], "msec": ["mtSec", "misec", "cmisec", "msc", "cmsc", "mtsec", " msc", "mtcl", "MSec", " mSec", "mtsc", " misec", "Msec", "Mct", "gmsc", "gmSec", "gmstr", "gmsec", "mtisec", "mSec", "cmcl", "mct", "mcl", "mtct", " mcl", "mstr", " mstr", "mtstr", " mct", "cmsec"], "checkFile": ["checkSourceFile", "checkFiles", "readFile", " checkSourceFile", "readFiles", " checkfile", " checkFiles", "Checkfile", "updateFile", " checkFILE", "updateFILE", "CheckFILE", "readfile", "CheckFile", "updateSourceFile", "readSourceFile", "readFILE", "CheckFiles", "checkFILE", "updateFiles", "checkfile"], "i": ["ij", "ex", "is", "init", "my", "gi", "id", "it", "xi", "qi", "info", "ci", "li", "I", "m", "ai", "ix", "iq", "gu", "ki", "hi", "bi", "key", "x", "ri", "ii", "multi", "mi", "major", "ic", "in", "batch", "index", "io", "y", "sequence", "ind", "exp", "im", "phi", "iu", "sim", "ie", "ji", "me", "si", "zi", "ei", "pi", "base", "ti", "name", "cli", "j", "ui", "di", "ini", "ip"], "f": ["b", "uf", "ft", "fs", "file", "bf", "fp", "fd", "tf", "fc", "m", "t", "l", "fl", "fo", "df", "p", "u", "fe", "fac", "fi", "fw", "lf", "F", "fg", "e", "fa", "fb", "d", "v", "cf", "o", "j", "fr"], "g": ["b", "group", "gs", "out", "gi", "gm", "vg", "tg", "gb", "file", "m", "config", "t", "s", "ga", "gd", "gl", "eg", "l", "gy", "gu", "bg", "go", "p", "gc", "graph", "og", "j", "gp", "msg", "ge", "w", "fg", "G", "e", "gg", "d", "v", "mg", "pg", "ig", "cfg"], "destinationFile": ["destinateEmail", "DestationFiles", "destinateFilename", "destarationFiles", "DestinationFilename", "DestinationEmail", "destationFile", "destationFiles", "destarationFilename", "destinatedFilename", "destinateFiles", "destinationEmail", "destinatorFilename", "destinationFilename", "destarationDirectory", "destinationsFiles", "destinatorDirectory", "destinationsFile", "DestationFilename", "destationEmail", "transinatedFile", "transinationFiles", "DestinationFiles", "transinationDirectory", "DestinationFile", "destinationDirectory", "transinatedFilename", "destinatorFile", "DestationEmail", "destinatedFile", "destinatedDirectory", "destinateFile", "destinationFiles", "transinatedFiles", "transinatedDirectory", "destinationsFilename", "destinatorFiles", "transinationFilename", "destinatedFiles", "destinationsEmail", "DestationFile", "transinationFile", "destationFilename", "destarationFile"], "sourceFile": ["sourceFiles", " sourceFiles", "ourcefile", "Sourcefile", " sourceFILE", " sourcefile", "SourceLine", "staticFILE", "sourceFilename", "sourcefile", "sourceLine", "staticFile", "srcFilename", "SourceFilename", "SourceFILE", "sourceFILE", "ourceFile", "staticfile", "srcFile", "SourceFiles", "staticFiles", "ourceLine", "srcfile", "ourceFilename", "SourceFile", "srcLine"], "infile": ["InFile", "INline", "inputfile", "Instream", "insblock", "INfield", "inline", "INfile", " inFile", "Inblock", "inFile", "inputline", "outblock", "insFile", "inputblock", "instream", "pinline", " instream", "outFile", " inline", "Infile", "insfile", "pinfield", " inblock", "inblock", "pinFile", "insstream", "pinfile", "INFile", "inputFile", " infield", "infield", "outline"], "outfile": ["outview", "Outstream", "outputfile", "inbuffer", "outlink", "outputpage", "outpage", "inline", "outputline", "inFile", "outstream", " outlink", " outpage", "instream", "outerview", "Outlink", "outFile", "inpage", " outbuffer", "inview", "outerbuffer", " outline", " outstream", "outputstream", " outFile", "OutFile", "outerstream", "inlink", "outbuffer", " outview", "outerfile", "Outfile", "outline"], "c": ["cs", "ce", "cd", "conf", "cache", "out", "sc", "k", "r", "err", "z", "m", "col", "pc", "t", "count", "rc", "bc", "cos", "cc", "cb", "cl", "x", "dc", "\u00e7", "n", "mc", "a", "p", "close", "cp", "ac", "gc", "ct", "u", "unc", "arc", "char", "C", "cm", "nc", "cr", "y", "cu", "ch", "uc", "ca", "e", "ec", "chain", "d", "v", "code", "o", "cf", "lc"]}}
{"id1": "22046596", "id2": "8754809", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" share", " rename", "write", "paste", " restore", " cp", " replicate", " cop", " Transfer", "cp", " insert", " copying", " duplicate", "Copy", " dup", " swap", " replace", "upload", " overwrite", " parallel", " move", " paste", "transfer", " seek", " mirror", " populate", " extend"], "s": ["ls", "b", "cs", "gs", "is", "gets", "src", "ts", "input", "ds", "fs", "ys", "f", "z", "ats", "sv", "l", "str", "string", "less", "sq", "sts", "ins", "rs", "source", "xs", "n", "os", "p", "ses", "ies", "S", "st", "its", "js", "sb", "g", "ps", "south", "ss", "sf", "v", "qs", "ws", "ms", "es", "sl", "ns"], "t": ["pt", "ht", "at", "template", "title", "tt", "ts", "it", "tc", "k", "f", "mt", "T", "nt", "kt", "l", "rt", "test", "gt", "n", "txt", "ent", "p", "h", "ct", "tr", "st", "unt", "w", "wt", "te", "ret", "g", "i", "v", "o", "ot", "j"], "in": ["In", "user", "iter", "is", "sin", "init", "input", "rin", "it", "info", "IN", "inn", "and", "inside", "inf", "ai", "bin", "ar", "ir", "ins", "source", "inc", "from", "en", "mi", "ic", "up", "io", "ind", "oin", "im", "din", "isin", "ie", "cin", "con", "i", "gin", " din", "inner"], "out": ["b", "ex", "check", "or", "net", "OUT", "ou", "it", "k", "output", "nt", "l", "client", "gt", "c", "Out", "n", "this", "en", "ac", "cn", "to", "up", "io", "sys", "outs", "result", "msg", "w", "ch", "g", "by", "con", "conn", "i", "co", "v", "can", "o", "outer", "aos", "res", "ot", "j", "channel"]}}
{"id1": "16931472", "id2": "17874479", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static final void main(String[] args) throws Exception {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(\"http://www.apache.org/\");\n        System.out.println(\"executing request \" + httpget.getURI());\n        HttpResponse response = httpclient.execute(httpget);\n        HttpEntity entity = response.getEntity();\n        System.out.println(\"----------------------------------------\");\n        System.out.println(response.getStatusLine());\n        if (entity != null) {\n            System.out.println(\"Response content length: \" + entity.getContentLength());\n        }\n        System.out.println(\"----------------------------------------\");\n        httpget.abort();\n    }\n", "label": 0, "substitutes": {"handler": ["read", "transform", "init", "accept", "update", "received", "output", "request", "processing", "done", "success", "proc", "end", "action", "hook", "processor", "handle", "forward", "adapt", "Handler", "handled", "controller", "render", "Handle", "execute", "index", "callback"], "result": ["Result", "full", "make", "cache", "out", "all", "output", "list", "map", "current", "done", "product", "met", "RESULTS", "success", "found", "results", "memory", "source", "page", "details", "created", "successful", "mate", "master", "valid", "sequence", "report", "status", "ret", "buffer", "total", "res", "hash", "profile", "response", "data", "complete", "table"], "target": ["external", "transform", "info", "project", "t", "Target", "test", "arg", "next", "source", "report", "e", "history", "name", "node", "service", "alias", "format", "thread", "subject", "that", "translation", "trace", "tif", "self", "window", "primary", "proxy", "scope", "handle", "valid", "controller", "bolt", "local", "table", "dest", "iter", "task", "trigger", "link", "top", "peer", "term", "this", "page", "expected", "manager", "layout", "tree", "version", "remote", "goal", "buffer", "jp", "prototype", "base", "arget", "closure", "match", "template", "http", "component", "it", "type", "output", "pkg", "gt", "detail", "object", "tool", "cmd", "to", "master", "view", "style", "parent", "internal", "complete"], "url": ["ls", "dl", "cert", "http", "URL", "lr", "git", "address", "f", "file", "l", "ur", "link", "browser", "client", "loader", "web", "html", "nl", "loc", "hl", "uri", "char", "rl", "el", "impl", "mail", "Url", "build", "ssl", "connection", "ul", "bel", "base", "rel", "ll", "mount", "hub", "service", "sl"], "reader": ["read", "driver", "iter", "liner", "Reader", "review", "context", "older", "file", "and", "parser", "loader", "builder", "rar", "stream", "row", "linger", "uri", "layer", "rl", "er", "runner", "upper", "ner", "rr", "writer", "reading", "redo", "iterator", "buffer", "rot", "resource", "inner", "cur", "operator", "readable", "ro"], "line": ["message", "LINE", "online", "range", "liner", "block", "iter", "user", "store", "out", "lo", "ln", "file", "inline", "frame", "ine", "l", "link", "eline", "lock", "trace", "cell", "string", "email", "lin", "network", "nl", "continue", "word", "rule", "row", "detail", "source", "limit", "le", "next", "page", "section", "Line", "loop", "state", "sequence", "text", "body", "style", "port", "no", "log", "entity", "chain", "buffer", "lines", "queue", "date", "zone", "print", "level", "code", "base", "sample", "now", "node", "point", "stay", "status", "comment", "ip"], "entry": ["pixel", "match", "ex", "check", "or", "ace", "it", "search", "office", "ary", "instance", "list", "quick", "add", "se", "cell", "record", "Entry", "job", "key", "term", "row", "pair", "ent", "object", "exit", "def", "char", "part", "element", "field", "ie", "e", "deep", "enter", "escape", "inner", "ry", "comment", "member"], "fromIndex": ["leftindex", "FromAlpha", "minindex", " fromindex", "forindex", "oldInd", "fromInt", "fromLink", " fromAlpha", "normalInt", " fromInt", "normalIndex", "FromInd", " fromPosition", "fromInd", "leftPosition", "forIndex", "fromindex", "FromIndex", "oldIndex", "minInd", " fromLink", "normalindex", "oldAlpha", "minIndex", "leftInd", "leftIndex", "normalInd", "forInd", "fromPosition", "FromLink", "forPosition", "oldLink", "minInt", "fromAlpha", " fromInd"], "r": ["b", "rect", "range", "dr", "vr", "err", "m", "sr", "l", "rt", "rb", "str", "rc", "rg", "ar", "rar", "n", "rs", "kr", "q", "p", "nr", "u", "er", "cr", "rr", "w", "g", "e", "R", "re", "render", "rd", "v", "res", "mr", "rate", "fr"]}}
{"id1": "10218878", "id2": "1097147", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"DecodeMapFile": ["DecodeFromfile", "DecodeFromFile", "DecodeToFiles", "DecvertMAPfile", "DecvertMAPFiles", "DecodeMAPFiles", "DecodeToLog", "DecvertMapFile", "DecvertMAPLog", "DecodeToFile", "DecvertMapfile", "DecvertMapLog", "DecodeMAPLog", "DecodeMapFiles", "DecodeFromFiles", "DecodeMapfile", "DecodeMAPFile", "DecvertMapFiles", "DecodeFromLog", "DecvertMAPFile", "DecodeMapLog", "DecodeTofile", "DecodeMAPfile"], "mapFile": ["listFile", "mapFilename", "imageFilename", " mapFILE", "listPath", " mapStream", "listFILE", "mapPath", " mapPath", "cacheFile", "MapFile", "cacheFILE", "cachePath", "MapStream", "imagefile", "Mapfile", "imageStream", "imageFile", "mapStream", " mapfile", "mapfile", "mapFILE", "MapFilename", " mapFilename"], "outputFile": [" outputFilename", "OutputFile", "OutputFilename", "mapDir", "writeFile", " outputDir", "inputStream", "inputName", "writeStream", "inputDir", "mapName", "OutputPath", "outFile", "writeDir", "outDir", "writeName", "outputFilename", "OutputDir", "mapStream", "outputStream", " outputPath", "outputDir", "inputFile", "outputPath", "outputName", "outFilename", "outPath"], "magicKey": ["encryptedKey", "encryptedChar", "magicField", " magicCode", "MagicId", "magickey", "prefixValue", "magicCode", "magicValue", "MagicName", "encryptedkey", " magicName", " magicKEY", "anticKey", "magicKEY", " magicCounter", " magicId", " magickey", "magicCounter", "MagicKEY", "uniqueKey", "serialName", " magicField", "prefixCode", "prefixKey", "magicId", "uniqueCounter", " magicValue", "antickey", "anticChar", "MagicKey", "uniqueCode", "serialKey", "serialId", "encryptedField", "anticField", "serialKEY", "magicChar", " magicChar", "magicName", "prefixCounter", "uniqueValue"], "buffer": ["message", "block", "header", "iter", "check", "template", "bridge", "display", "flash", "cache", "binary", "database", "paste", "stroke", "frame", "program", "bone", "bo", "queue", "append", "vector", "memory", "window", "Buffer", "stream", "row", "page", "detail", "screen", "batch", "char", "index", "initial", "document", "attribute", "command", "sequence", "length", "black", "stack", "shape", "buf", "history", "pad", "total", "sum", "print", "code", "base", "sample", "buff", "mem", "phrase", "filter", "button", "table", "variable"], "nread": ["renwrite", " nRead", "rnREAD", "Nget", "rnRead", " nreadable", "nwrite", "nreadable", "NREAD", "ncget", "rnread", "ncRead", "rawreader", "maxget", "nadd", "ncread", "rawtry", "ncwrite", " nREAD", "renread", "ncreadable", "NRead", "nreader", "nRead", "maxRead", "rawread", "ntry", "Nread", "maxadd", "nREAD", "rnwrite", " nwrite", "rentry", " ntry", " nreader", "maxread", "Nadd", "rawwrite", "Nwrite", "nget", "renreader", "Nreadable", "ncadd"], "map": ["read", "block", "place", "com", "bridge", "parse", "ape", "make", "cache", "ace", "where", "open", "address", "mt", "MAP", "mp", "m", "config", "per", "file", "app", "aps", "down", "lock", "load", "memory", "window", "image", "maps", "mask", "collect", "mate", "batch", "manager", "up", "apping", "master", "cm", "op", "mod", "view", "set", "clear", "form", "meta", "apper", "pl", "ml", "con", "shape", "module", "co", "man", "pack", "mem", "pose", "mount", "ap", "table", "ip"], "output": ["put", "online", "ilo", "block", "format", "display", "net", "ou", "cache", "out", "secure", "input", "update", "write", "open", "oe", "file", "icon", "current", "network", "queue", "client", "web", "stream", "next", "object", "exit", "batch", "result", "console", "hidden", "target", "socket", "port", "log", "entity", "four", "print", "can", "o", "outer", "blue", "response", "latest", "auto", "other", "plain", "Output"], "i": ["b", "ami", "is", "ni", "us", "gi", "it", "qi", "id", "xi", "ci", "li", "ms", "I", "m", "t", "ai", "ix", "gu", "ri", "x", "bi", "ii", "n", "q", "u", "mi", "multi", "uri", "ic", "batch", "index", "fi", "y", "ind", "phi", "iu", "sim", "g", "ie", "ji", "spin", "si", "v", "ei", "pi", "span", "ti", "cli", "ish", "j", "ui", "di", "ini", "ip"]}}
{"id1": "2668853", "id2": "18782385", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileTOFile", "decodeFile2String", "decodeFileAsFile", "decodeFileAsString", "decodeFilesToFile", "decodeFilesToString", "decodeFiles2File", "decodeFileToFiles", "decodeFile2Files", "decodeFileAsPage", "decodeFiles2String", "decodeFile2Page", "decodeFileTOString", "decodeFileToString", "decodeFiles2Page", "decodeFilesToPage", "decodeFiles2Files", "decodeFileTOPage", "decodeFile2File", "decodeFileToPage", "decodeFileTOFiles", "decodeFilesToFiles", "decodeFileAsFiles"], "infile": ["InFile", "inputfile", "outbase", "innbase", "innfilename", "inbase", "inFile", "outpath", "innfile", "Inbase", "outFile", "Inpath", " infilename", "Infile", "inputbase", "innwhere", "infilename", "inpath", "inputpath", "inputfilename", " inwhere", "inputFile", "inputwhere", "inwhere", " inbase"], "outfile": ["listFile", "Outfilename", "listfile", "inFile", "outpath", "tofile", "listfilename", " outfilename", "infp", "outFile", "tofp", "toFile", "outfp", " outFile", "outfilename", "OutFile", "Outpath", "infilename", "inpath", "listfp", "tofilename", " outpath", "Outfile"], "in": ["In", "user", "iter", "pin", "is", "init", "on", "input", "rin", "it", "al", "info", "ain", "per", "IN", "inn", "inside", "inf", "bin", "ai", "amin", "image", "ins", "n", "source", "inc", "from", "en", "io", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "o", "ro", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "ln", "t", "oss", "gt", "Out", "n", "end", "fn", "os", "ent", "en", "cn", "to", "flush", "opt", "io", "ne", "sys", "outs", "w", "writer", "OU", "g", "con", "co", "inner", "aos", "res", "o", "outer", "can", "print", "ot"], "buffer": ["message", "block", "header", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "queue", "padding", "zero", "memory", "window", "Buffer", "row", "batch", "tree", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "length", "black", "stack", "temp", "buf", "history", "pad", "total", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "shift", "input", "find", "Read", "write", "query", "open", "select", "ok", "give", "first", "reader", "add", "count", "need", "reads", "load", "send", "push", "before", "size", "run", "stream", "end", "q", "READ", "close", "pe", "len", "through", "set", "length", "text", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "data", "connect", "readable", "each", "index", "ready"], "success": ["setup", " succeed", "exist", "ccess", "commit", "cess", "accept", "growth", "warning", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", " succeeded", "submit", "top", "continue", " convergence", "crit", " successfully", "primary", "close", "successful", "good", "green", "please", "ceed", "master", "town", "result", "valid", " Success", "successfully", " okay", " failure", "ratulations", " succeeds", "sufficient", "photo", "snap", "city", "unity", "democracy", " successes", "complete", "cont", "support", "security", "danger", "response", "status", " succ"]}}
{"id1": "21063400", "id2": "19467540", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "label": 0, "substitutes": {"doImageProcess": [" doImagesProcess", "doItemImageWork", "doImagesProcess", "doMediaWork", "doMediaprocess", "doMediaProcess", " doImagesWork", "doImageWork", "doItemImageSort", " doImageprocess", "doItemImageprocess", "doImagesSort", "doImageprocess", "doImagesprocess", " doImageWork", "doMediaSort", " doImagesSort", "doItemImageProcess", "doImageSort", "doImagesWork", " doImagesprocess", " doImageSort"], "request": ["message", "template", "QUEST", "input", "query", "application", "address", "context", "select", "session", "reference", "frame", "quest", "client", "image", "Request", "version", "attribute", "document", "command", "view", "re", "question", "server", "resource", "model", "start"], "response": ["reply", "message", "user", "block", "collection", "format", "display", "http", "cache", "search", "write", "application", "query", "output", "description", "relation", "list", "frame", "network", "success", "answer", "onse", "entry", "window", "image", "next", "one", "page", "continue", "detail", "exit", "ve", "resp", "tree", "xml", "version", "document", "result", "site", "json", "view", "respond", "console", "sequence", "report", "position", "parent", "re", "fire", "connection", "content", "server", "print", "res", "model", "hash", "Response", "status", "reset"], "imgSize": [" imgName", "propError", "imgOwner", "imagError", " imgShape", " imgType", "imgError", "appShape", "imageSIZE", "imgName", "imagName", "certName", "imageInfo", "divSIZE", "imageStyle", "appsize", "divsize", "dimSize", "imgShape", "imageType", "appType", "divSize", "certSIZE", "certSize", "imgInfo", "imgType", "imgScale", "imagSize", "augShape", "imageSize", " imgStyle", "imgSIZE", " imgScale", "appSize", " imgOwner", "imagsize", "augsize", "augOwner", "appInfo", "imgStyle", "dimSIZE", "certScale", "imageScale", " imgSIZE", " imgInfo", " imgsize", " imgError", "appStyle", "propsize", "propName", "propSize", "dimsize", "augSize", "imgsize", "imageName", "appOwner"], "imageInputStream": ["imageInputPath", "photoInputstream", " imageStreamStream", "imageIntStream", "imageIntstream", " imageInputPath", "imageInputView", "imageInView", "photoInputSteam", "imageInStream", " imageStreamPath", "imageRawView", "imageRawStream", "fileInputStream", "imageRawstream", "imageOutputForm", "photoInputStream", "imageByteSteam", "mediaInputStream", "imageInterfaceView", "imageOutputReader", "imageOutputstream", " imageStreamSteam", "photoIntstream", "imageInputForm", "imageStreamStream", "imageInterfacestream", "fileInputstream", " imageInputSteam", "fileRawSteam", "imageInputstream", "imageByteForm", "fileRawStream", "imageInterfaceStream", "imageIntPath", "imageStreamSteam", "imageInSteam", "imageRawSteam", "fileInputView", "imageInputReader", "fileRawstream", "imageInterfaceSteam", "photoIntStream", "imageOutputStream", "imageByteReader", "imageOutputSteam", "fileInputSteam", "fileRawView", "imageIntSteam", "mediaInputForm", "imageStreamPath", "mediaInputReader", "imageInstream", "imageInputSteam", "mediaInputSteam", "photoIntSteam", "imageByteStream"], "imageBytes": ["imgParts", "imgBytes", " imageParts", "pictureBytes", "issueParts", "photoByte", "photoBytes", "pictureGs", " imageSeries", "audioBytes", " imageGs", "photoKeys", "imageParts", "imageBs", "photoGs", "imageGs", "imgSeries", "photoParts", "imageKeys", "imageByte", "audioParts", " imageByte", "imgGs", "issueKeys", " imageBs", "imageSeries", "audioBs", "issueBytes", "imgKeys", "pictureByte", "audioSeries", "imgBs", "issueGs", "pictureParts"]}}
{"id1": "5676111", "id2": "2518655", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "label": 0, "substitutes": {"get": [" fetch", "init", " recover", " finish", "download", "info", "sync", " put", " copy", "Get", "zip", "exec", "run", " delete", " reload", "gc", "dump", "delete", "upload", " download", "Download", "GET", "export", "print", "execute", " construct", "call"], "cnt": ["Cct", "Ccount", "ncht", "acNT", "cnc", "unclen", " cNT", " cht", "nnc", "Cnc", "clen", "cct", "uncnt", "Cnt", "ccount", " cnc", "nccount", "ncnt", " clen", "cNT", "uncNT", "CNT", "ncct", "acnc", "uncnc", "aclen", "nnt", " cct", "Cht", "nct", "acnt", " ccount", "nNT", "cht"], "url": ["ls", "path", "dl", "cert", "http", "URL", "fs", "open", "f", "r", "l", "ur", "gl", "str", "fl", "https", "link", "client", "google", "browser", "web", "nl", "loc", "null", "hl", "host", "mount", "cp", "uri", "addr", "handle", "char", "xml", "www", "el", "socket", "ref", "ret", "mail", "Url", "build", "con", "ssl", "ul", "bel", "base", "rel", "ll", "pl", "sl"], "conn": ["obj", "com", "Conn", "ctx", "net", "cert", "init", "yn", "open", "comm", "nt", "col", "l", "exec", "client", "ens", "gn", "org", "cb", "nl", "c", "loc", "os", "cp", "nec", "cn", "en", "cmd", "ct", "act", "coll", "addr", "resp", "cm", "nc", "ch", "access", "conv", "enc", "dial", "ca", "serv", "con", "jp", "connection", "cont", "co", "syn", "cons", "cur", "rel", "connect", "ns", "pas"], "is": ["nis", "iter", "init", "us", "isl", "vis", "it", "fs", "ib", "ys", "iso", "ms", "dis", "abs", "IS", "bis", "ist", "isc", "lis", "ends", "ri", "ists", "ins", "rs", "iss", "os", "ris", "ic", "in", "isf", "Is", "bs", "sys", "icks", "isi", "imp", "im", "its", "has", "isin", "ios", "ais", "sim", "ps", "i", "si", "mis", "isa", "iris", "sit", "es", "ip"], "filename": ["ren", "path", "title", "sql", "f", "ename", "subject", "file", "fp", "mson", "journal", "Filename", "sbm", "string", "str", "LCS", "nm", "til", "family", "fn", "txt", "source", "lua", "username", "fil", "nu", "river", "ame", "kl", "FILE", "FIL", "stem", "continental", "latest", "name", "prefix", "println", "knife"], "fos": ["flos", " foses", "vres", " foes", "fres", "boes", "boss", "los", "Foes", "foses", "loes", "Foss", "foss", " fows", "Foses", "bos", "Fows", "floes", "floss", "Fres", "Faos", " foss", "laos", "vaos", "voses", "foes", "bows", "faos", "vos", "loss", "fows", "flaos", "Fos", " faos", " fres"], "buffer": ["library", "message", "block", "bytes", "iter", "template", "display", "note", "cache", "binary", "output", "database", "paste", "frame", "bone", "append", "queue", "memory", "window", "Buffer", "page", "source", "scroll", "batch", "char", "document", "attribute", "command", "bar", "result", "sequence", "view", "length", "text", "stack", "temp", "buf", "event", "history", "total", "print", "available", "base", "sample", "buff", "data", "mem", "phrase", "comment", "button", "table", "variable"]}}
{"id1": "8778962", "id2": "364438", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFileString", "decodeFileAsfile", "decodeStringToString", "decodeFile2String", "decodeFileAsFile", "decodeFileFileFile", "decodeFileAsString", "decodeString2Files", "decodeFileToFiles", "decodeFile2Files", "decodeFileFilefile", "decodeFile2file", "decodeStringTofile", "decodeString2file", "decodeStringToFile", "decodeFileToString", "decodeString2File", "decodeStringToFiles", "decodeFile2File", "decodeFileFileFiles", "decodeString2String", "decodeFileTofile", "decodeFileAsFiles"], "infile": ["InFile", "inputfile", "inname", "frombase", "isinfolder", "Infilename", "outbase", "inbase", "inFile", "isinname", "Inbase", "infolder", "outFile", "fromfilename", "fromfile", "Infile", "isinFile", "inputname", "outfilename", "infilename", "outfolder", "fromFile", "inputFile", "inputfolder", "isinfile", "outname"], "outfile": ["inname", " outname", "Outfilename", "outFILE", "inFILE", "inFile", "tofile", "todir", " outFILE", "otfile", "outFile", "outdir", "Outdir", "indir", "outname", "otFile", "toFile", " outFile", "otname", "outfilename", "OutFile", "infilename", "otFILE", "tofilename", "Outfile"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "fn", "null", "os", "en", "cn", "to", "flush", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "aos", "res", "o", "auto", "can", "outer", "ot", "inner"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "black", "stack", "temp", "shape", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "shift", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", " succeed", "exist", "ccess", "commit", "cess", "value", "accept", "fail", "growth", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "scope", "successful", "good", "please", "ceed", "town", "result", "valid", "successfully", " okay", " failure", "ratulations", " succeeds", "sufficient", "photo", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "16798376", "id2": "21979717", "code1": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"run": ["launch", "block", "stop", "task", "apply", "exec", "test", "submit", "go", "cmd", "handle", "Run", "runner", "work", "command", "show", "process", "runs", " Run", "start", "execute", "invoke", "profile", "hello", "service", "call"], "ftp": ["ftjp", " ftping", "iftt", "aftc", "wtcp", "aftt", "gitt", "ftr", "ctp", "iftphp", "ftcp", "iftp", "iftop", "ftphp", " ftphp", "aft", "aftop", "iftf", "aftz", "aftxp", "ftt", "cttp", "iftr", " ftxp", "wtping", "aftphp", " ftr", "afp", "afttp", "aftping", "ftxp", "ctl", "gitping", "gitp", "wtp", "ftf", "iftz", "gitf", "aff", "ftop", "ffp", "wth", "ffcp", "aftp", " ftt", " fttp", " ftl", "ftl", "ctcp", " fth", "ftc", " ftjp", "aftl", "iftjp", "fft", " ftf", "fth", "aftjp", "afc", "ftz", " ftop", "fttp", "iftxp", "afth", "aftf", " ftcp", "aftcp", "fftp", "aftr", "afl", " ftc", "ftping", " ftz", "afping"]}}
{"id1": "14053882", "id2": "8064604", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"encrypt": ["decrypt", "encrypted", "encode", "Encode", "Encrypt", "decode", " encrypted", "Encryption", "encryption", " encryption", "Encrypted", " encode", "decryption", "decrypted"], "plaintext": ["plainth", "plainText", "broadText", "longText", "plainpassword", "mainpassword", " plainTEXT", "broadtext", "mainTEXT", "longth", "mainText", " plainth", "broadmessage", "longtext", "publicTEXT", " plainmessage", "longmessage", " plainText", "publictext", " plainpassword", "maintext", "plainmessage", "plainTEXT", "publicText", "publicpassword", "broadth"], "md": ["nd", "ng", " mc", "cd", "dr", "dh", "ds", "del", "mt", "grad", "nt", "MD", "m", "mp", "ma", "rm", "der", "mark", "mk", " ma", "met", "hd", " dd", "managed", "mo", "mc", "df", " mo", "dd", "cmd", "pd", "det", "sam", "ind", "mod", "sha", "mm", "ld", "med", "dig", "od", "mn", "mb", "esm", "metadata", "d", "sd", "mand", "mg", "ms", "sm", "dm"], "raw": ["known", "message", "RAW", "bytes", "extra", "full", "value", "out", "input", "all", "array", "r", "clean", "unknown", "encrypted", "original", "bare", "random", "n", "right", "row", "orig", " Raw", "hook", "good", "box", "sh", "bound", "valid", "Raw", "unsigned", "clear", "hex", "aw", " RAW", "buf", "custom", "rendered", "available", "base", "pack", "data", "strip"], "hash": ["message", "cert", "hat", "flash", "cache", "sign", "id", "search", "url", "ssh", "unknown", "ash", "hed", "ashes", "mac", "html", "key", "mask", "h", "handle", "alert", "href", "sh", "password", "tr", "shadow", "height", "json", "hidden", "ashed", "sha", "has", "hex", "Hash", "total", "sum", "print", "proof", "tag"]}}
{"id1": "411595", "id2": "536614", "code1": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"displayDiffResults": [" displayDiffStats", " displayDiffresults", " displaydiffresults", " displayChangeStats", " displaydiffStats", "displayDiffStats", "displaydiffResult", "displaydiffStats", "displayDiffResult", " displayChangeresults", " displayDiffResult", " displaydiffResult", " displayChangeResults", "displaydiffResults", " displaydiffResults", " displayChangeResult", "displaydiffresults", "displayDiffresults"], "outFile": ["outSet", "outDisk", "outputfile", "outFILE", " outDisk", "OUTFile", "targetFile", "nDir", "outfile", "OUTSet", " outFILE", "outDir", " outPath", "targetStream", "nFile", " outDir", "nfile", "targetPath", "outputStream", "outputFile", "outputSet", "nDisk", " outfile", "outputDir", " outSet", "targetFILE", "OUTfile", "outputPath", "outputDisk", "OUTPath", "outPath", "outputFILE"], "outStream": [" outStreamer", "reportFile", "writeView", "writeStreamer", "outputStreamer", "reportstream", "reportStream", "outstream", "writeStream", " outView", " outstream", "outView", "outputStream", "outputstream", "outputFile", "writeSteam", "reportSteam", "outputSteam", "outStreamer", "outputView", "outSteam", " outSteam"], "out": ["b", "external", "put", "over", "conf", "on", "update", "err", "file", "t", "pretty", "ent", "batch", "outs", "ch", "writer", "by", "log", "conn", "con", "co", "sum", "v", "o", "auto", "obj", "user", "ex", "init", "format", "ou", "all", "write", "nt", "again", "os", "in", "conv", "raw", "inner", "table", "check", "at", "empty", "net", "error", "list", "hit", "entry", "Out", "n", "page", "up", "io", "sys", "console", "w", "g", "print", "aos", "timeout", "OUT", "cache", "it", "output", "l", "oss", "client", "one", "screen", "go", "cmd", "to", "flush", "copy", "op", "can"], "bgcolor": ["fontColor", "fontcol", " backgroundcolor", "fontcolor", "bgColor", " backgroundname", "fontname", "bgcol", "bgname", " backgroundColor", "backgroundcol", " backgroundcol", "backgroundcolor", "backgroundname", "backgroundColor"], "onMouseOver": [" onmouseDown", "onmouseDown", "onMouseover", " onmouseover", " onMouseover", " onMouseOut", "onmouseOver", "onmouseOut", "onMouseDown", " onmouseOver", "onmouseover", " onmouseOut", "onMouseOut", " onMouseDown"]}}
{"id1": "17296916", "id2": "494226", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"logging": ["debugStorage", "Logging", "debugging", "Loging", "logStorage", " logger", "debuging", "logger", "LogStorage", "debugger", "Logger", " logStorage", " loging", "loging"], "wrap": ["xf", "message", "ad", "transform", "read", "format", "parse", "store", "grow", "find", "ew", "force", "wrapper", "wra", "wa", "ow", "use", "zip", "add", "link", "safe", "python", "web", "root", "wx", "x", "window", "word", "rap", "gate", "W", "box", "handle", "work", "sp", " wrapped", "w", "form", " wrapper", "get", "build", "chain", "me", "shape", "pad", "aw", "nw", "sw", "pack", "create", "inter", "start", "ws", "wind", "wire", "reset", "we"], "buffer": ["reply", "message", "library", "block", "header", "iter", "template", "bridge", "display", "note", "flash", "cache", "store", "binary", "face", "wrapper", "output", "database", "reference", "surface", "frame", "append", "trace", "queue", "bo", "directory", "builder", "size", "memory", "Buffer", "window", "row", "word", "quote", "screen", "batch", "flag", "layer", "document", "attribute", "bar", "command", "sequence", "view", "console", "body", "report", "position", "writer", "bb", "line", "buf", "complete", "reset", "print", "base", "buff", "profile", "ob", "phrase", "button", "table", "pb"], "encoding": ["cging", "cryption", "ecoding", "enoding", "encoded", "codryption", "Encaling", "ecoder", "encoder", "enlanguage", "coder", "Encoder", "enoder", "enging", "enclanguage", "clanguage", "enumlanguage", "Encoding", "enryption", "caling", "enaling", "cododer", "enumoding", "enoded", "enumoder", "Encryption", "encryption", "encaling", "encging", "ecoded", "enumging", "cododed", "coding", "cododing", "ecryption"], "getEncoding": ["getEncryption", " getEncling", "getExpryption", "getExpoding", "getencination", "getEnression", "getEncling", "getEnryption", "getEncression", "getencression", "getEncging", " getEncryption", " getEncination", "getExpging", "getEnination", " getEnling", "getencging", " getEncging", "getOrigoding", " getEnryption", "getencoding", "getOrigling", " getEnging", "getencling", " getEnoding", "getExpression", "getencryption", "getOrigryption", "getEnling", " getEnression", " getEncression", "getEnging", "getEnoding", " getEnination", "getOrigination", "getEncination"], "headers": ["header", "pres", "modules", "authors", "chains", "keys", "tags", "builders", "writers", "users", "properties", "head", "params", "comments", "ters", "boxes", "reports", "pins", "heads", "caps", "groups", "checks", "rs", "ilers", "weights", "limits", "frames", "ppers", "images", "ports", "ctors", "codes", "styles", "fields", "relations", "holders", "members", "names", "drivers", "ers", "objects", "ids", "terms", "values", "blocks"], "is": ["nis", "\u00eds", "or", "us", "isl", "was", "fs", "dis", "ys", "iso", "ms", "isd", "bis", "tis", "IS", "ist", "isc", "lis", "as", "ri", "ists", "does", "ins", "iss", "os", "ris", "ic", "in", "osi", "isf", "Is", "bs", "sys", "isi", "its", "has", "isin", "ios", "ais", "i", "sis", "si", "mis", "isa", "ois", "iris", "ui", "obs", "ims", "ip"], "bos": ["cs", "oos", "dos", "bytes", "pod", "ts", "ones", "fs", "oids", "ys", "des", "ms", "ows", "bas", "bis", "banks", "los", "ols", "cos", "tis", "bo", "oss", "bin", "bes", "bi", "uds", "tes", "os", "bits", "tops", "jas", "bs", "ods", "oops", "ubis", "ses", "sys", "bot", "isi", "soc", "uts", "windows", "lets", "js", "ios", "bh", "bones", "ps", "stats", "eros", "nos", "aos", "fits", "ui", "obs", "ots", "boards"], "e": ["ex", "r", "f", "err", "error", "oe", "m", "t", "ate", "se", "ae", "x", "de", "c", "n", "le", "a", "p", "exc", "en", "h", "ed", "er", "eeee", "ne", "ge", "E", "ie", "es", "g", "re", "me", "i", "d", "v", "o", "ev", "ee"]}}
{"id1": "6470716", "id2": "822452", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"st": ["sta", "nd", "th", "rest", "sth", "tt", "ste", "store", "ft", "std", "ust", "t", "ist", "rt", "se", "stable", "str", "stra", "sts", "inst", "sn", "stream", "ST", "sty", "ast", "ost", "est", "sh", "www", "sp", "set", "St", "step", "ld", "d", "stri", "sw", "start", "service", "sm"], "url": ["ls", "rect", "dl", "rest", "cert", "http", "URL", "r", "f", "address", "li", "shell", "file", "abs", "l", "ur", "gl", "string", "fl", "browser", "str", "client", "cl", "link", "web", "html", "nl", "loc", "domain", "null", "hl", "host", "mount", "uri", "addr", "char", "github", "il", "www", "el", "ch", "ref", "ret", "impl", "mail", "Url", "build", "ssl", "ul", "bel", "location", "base", "rel", "ll", "pl", "sl"], "fis": [" fisl", "ufi", "tais", "fois", "feois", "tiss", "Fier", "fier", " f\u00eds", "feier", "efiss", "xfier", "Fis", "xfi", "tis", "fisl", "ef\u00eds", "Fais", "fei", "ufis", "fiss", "f\u00eds", "flisl", "ufisl", "fais", " fais", "ufiss", "fliss", "fi", "tos", " fiss", " fi", "feis", "xfois", "uf\u00eds", "efis", "Fois", "flis", "xfis", "fli", "efi", "Fos", "Fi", "Fiss"], "zis": ["zos", "zenisi", "zipos", "zhisin", "zeniss", "ozIs", "zipisin", "czIs", " zIs", "zipits", "zenris", "zris", " zisa", " zisi", "czisa", "zits", "zhis", "zhes", "fiss", "czis", "ozisin", " zos", " zits", "zipis", "zipIs", "fris", "czits", "zisi", "zisin", "zipes", "ozes", "zisa", "zIs", " zris", "fisi", "zes", " ziss", "fits", "ozis", "zenis", "ozisa", "zhIs", "ziss", "ozits"], "entry": ["obj", "item", "match", "ce", "jar", "or", "zo", "out", "office", "info", "card", "be", "tmp", "nt", "list", "zip", "link", "se", "cell", "jo", "record", "Entry", "system", "key", "existent", "word", "de", "row", "null", "source", "ent", "def", "pattern", "char", "way", "attribute", "result", "field", "element", "valid", "sp", "form", "ie", "e", "log", "entity", "line", "enter", "chain", "event", "inter", "ry", "name", "comment", "index", "fr", "member"], "count": ["Count", "read", "match", "iter", "check", "counter", "number", "force", "err", "nt", "amount", "core", "current", "t", "add", "ctr", "cell", "cc", "size", "c", "found", "n", "end", "page", "ct", "num", "batch", "len", "char", "acc", "ind", "length", "last", "ch", "nb", "buffer", "cont", "max", "total", "sum", "code", "depth", "base", "start", "name", "ount", "comment", "index", "child", "call"], "data": ["message", "bytes", "block", "value", "format", "cache", " DATA", "number", "out", "all", "mu", "output", "done", "string", "bin", "size", "zero", "image", "reason", "n", "next", "source", "def", "good", "batch", "area", "part", "result", "json", "text", "DATA", "length", "step", "dat", "chain", "buffer", "ata", "raw", "buf", "d", "sample", "mem", "name", "table"], "fos": ["foos", "hOS", "fios", "foops", "wOS", "wis", "Foss", "foss", "fops", "hos", "fOS", "Fol", "hoss", "fol", "fiol", " foss", "wos", "fooss", "fool", "woss", "fiops", " fOS", "Fops", "his", "Fos", "fioss"], "dest": ["nd", "rest", "src", "ptr", "gest", "out", "des", "comb", "usr", "output", "std", "nt", "done", "Dest", "send", "bin", "test", "origin", "cat", "dc", "loc", "crit", "source", "nom", "them", "gate", "comp", "decl", "pipe", "det", "way", "master", "est", "result", "desc", "coord", "target", "exp", "writer", "dat", "foreign", "parent", "temp", "trans", "dist", "cont", "sum", "transfer", "mem", "member", "pas"]}}
{"id1": "2668634", "id2": "12172485", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"inputName": ["InputNames", "inputFilename", "interfaceFilename", " inputNames", "InputFilename", "interfacePath", "InputPath", "InputName", "outputFilename", "interfaceFile", "outputFile", "inputNames", "inputFile", " inputFile", "outputPath", " inputPath", "InputFile", "outputNames", "interfaceName", "inputPath"], "outputName": ["OutputName", "inputType", "OutputNames", "OutputType", " outputDir", "inputDir", "outputType", "OutputPath", " outputNames", "OutputDir", " outputPort", " outputPath", "OutputPort", "inputPort", "outputDir", "inputNames", " outputType", "outputPath", "outputNames", "inputPath", "outputPort"], "stripLoggers": ["skipLogger", "striplogging", "skipLoggers", "skiplogging", "skiplogger", "skipLogReferences", "skiplogReferences", "stripPathReferences", "stripLogger", "stripDebugger", "striplogReferences", "stripDebugReferences", "stripLogging", "skiploggers", "stripDebugging", "stripPathgers", "stripLogReferences", "striploggers", "stripPathger", "stripPathging", "stripDebuggers", "skipLogging", "striplogger"], "tempFile": [" tempDir", " temporaryFile", "tempfile", " temporaryField", "tempField", "empLock", "empfile", "tempLock", "tmpfile", "TempFile", "tempPlace", " tempPath", "TempDirectory", "TempDir", "tmpDir", " temporaryLock", " temporaryfile", " tempPlace", "temfile", "TempPlace", " temporaryDir", "tmpLock", "TempPath", "Tempfile", "tmpPath", " temporaryDirectory", "tempDir", "tmpPlace", "temPath", "empField", "tempPath", " tempfile", "empFile", "tmpField", "temFile", " tempDirectory", "temDir", "tmpFile", "tempDirectory"], "jin": ["quin", "pin", "lah", "von", "jon", "thin", "jac", "rin", "xi", "yang", "ln", "jing", "JR", "nik", "zip", "alin", "jo", "bin", "rake", "lin", "vin", " Jin", "jiang", "john", "ju", "txt", "jet", "erb", "olin", "ja", "pai", "nu", "zin", "tan", "tin", "json", "lu", "lig", "jc", "inx", "kin", "din", "rison", "nin", "cin", "jp", "gin", "spin", "ran", "jl", "jad", " inj", "zon", "rir", "jen", "via", "ini", "pak"], "jout": ["zout", "qio", "jpout", "jsout", " jou", " jOut", " jio", "qou", "zou", "zaos", "jsin", "jou", "jsOut", "zio", "qaos", "qout", "jOut", "jpOut", "jaos", " jaos", "jio", "jpin"], "srcChannel": ["rcChan", "rcchannel", " srcchannel", "sourcechannel", "srcChan", "srcCh", "sourceCh", "srcchannel", " srcCh", "sourceChannel", " srcChan", "rcCh", "rcChannel", "sourceChan"], "dstChannel": [" dstCh", " ddestChannel", "dgtFile", "doutChannel", "dgtChan", " ddestChan", "dstCh", "dgtCh", "ddestChannel", "doutCh", " dstChan", "ddestCh", "doutFile", "dstFile", "dstChan", "ddestChan", " ddestFile", "dgtChannel", " ddestCh", "doutChan", "ddestFile", " dstFile"], "portletApplicationName": ["portletApplicationCode", "portletapplicationOrder", "portletApplicationOrder", "portletAppType", "portableAppKey", "portletapplicationKey", "portableAppName", "portableApplicationValue", "portletServiceType", "portletCollectionCode", "portableApplicationCode", "portletAppName", "portletAppKey", "portableApplicationKey", "portletCollectionValue", "portableAppType", "portableAppOrder", "portletAppValue", "portletServiceKey", "portableApplicationType", "portletApplicationKey", "portletApplicationValue", "portletServiceName", "portableApplicationOrder", "portletAppCode", "portletServiceOrder", "portletapplicationName", "portletCollectionName", "portletapplicationType", "portletAppOrder", "portletCollectionType", "portableApplicationName", "portletApplicationType"], "webXml": [" webYaml", "webXML", "webExxml", "webXxml", " webTxxml", "WebTxm", "WebXxml", "webXMml", "webExml", "webExML", "webTxML", "webXMpl", "WebTxxml", "webYML", "webXMlim", " webXlim", "WebXml", "webTxpl", "webYxml", " webXaml", "webTxlim", "webXpl", "webXaml", "webWorkxml", "webTxxml", "WebXML", "webMaml", "webXom", "webTxm", " webXML", "webYpl", "webYaml", " webYom", "webXMom", "WebTxML", "webExm", "webMom", "webWorkML", " webTxml", " webYml", "webXMML", " webXxml", "WebXm", " webTxML", " webTxlim", "WebXpl", "webXMaml", "webXMxml", "webTxml", "WebTxpl", "webMml", "webXlim", "webWorkml", "webXMm", "webYml", " webXom", "webXm", "webMML", "webWorklim", " webYML", "webYom", "WebTxml"], "portletXml": ["portletTxML", "portletXng", "portvetXbl", "portletYng", "portvetXMml", "portletYML", "portvetXMng", "portableYml", "portableXxml", "portableYxml", "portletYql", "portletHexml", "portletTxng", "portletEbl", "portletYbl", "portantTxml", "portvetXml", "portletExml", "portletXMbl", "portableXql", "portableYML", "portantTxML", "portableXml", "portletXML", "portletXql", "portvetXxml", "portantXML", "portletXMql", "portantTxxml", "portantXng", "portvetXng", "portantXxml", "portantXml", "portantTxng", "portletXMng", "portletXMxml", "portvetXMbl", "portletEng", "portvetXMxml", "portletTxxml", "portletEml", "portableYql", "portletHeng", "portletHeML", "portletTxql", "portletXMml", "portletTxml", "portletHeml", "portletXbl", "portletXMML", "portletXxml", "portableXML", "portletYml", "portletYxml"], "contextXml": ["componentXmm", "componentYmx", "contextXaml", "contextEml", "ctxXml", "contextYmm", "contextXML", "contextCaml", "ctxXaml", "ctxXiml", "contextXiaml", "contextXmx", "componentYmm", "contextXitml", "contextAxmx", "componentYML", "ctxXiaml", "contextCML", "ctxXiML", "contextYtml", "contextEmx", "contextEML", "componentYml", "contextXiml", "contextCtml", "contextYmx", "ctxXtml", "componentXmx", "contextAxmm", "contextEmm", "contextAxml", "contextXiML", "componentXml", "componentXML", "contextYML", "ctxXitml", "contextYml", "contextYaml", "contextXtml", "contextCml", "ctxXML", "contextAxML", "contextXmm"], "src": ["dest", "obj", "SOURCE", "sl", "rob", " sou", "supp", "secure", "zh", "sc", "Source", "usr", "url", "filename", "tmp", "ln", "ser", "su", "sec", "sr", "rc", "buster", "ctr", "https", "str", "proc", "sq", "entry", "inst", "sup", "sn", "loc", "crit", "from", "txt", "scope", "comp", "addr", "kk", "sys", "sp", "ind", "st", "sol", "slice", "desc", "sb", "ie", "bh", "ident", "sel", "sing", "cont", "resource", "syn", "cur", "skin", "rel", "sit", "via"], "source": ["dest", "SOURCE", "iter", "channel", "check", "template", "format", "store", "secure", "input", "it", "query", "sql", "Source", "context", "shell", "file", "ser", "session", "instance", "reader", "ource", "seed", "zip", "se", "size", "entry", "origin", "feature", "image", "stream", "single", "scope", "null", "from", "unit", "in", "tree", "copy", "sp", "spec", "state", "sequence", "set", "console", "site", "style", "result", "ie", "get", "parent", "iterator", "series", "buffer", "raw", "resource", "sum", "inner", "start", "sample", "base", "status", "service", "table"], "zipEntries": ["zipEriers", "ipEntries", "ipEries", "zipEities", "zipentities", "zipEnties", "zipEntryires", "zipEnires", "zipEies", "zipEs", "zipEnables", "zoneEnties", "ipEntarts", "zoneEntities", "ipEntires", "zipIntriers", "zipEnities", "zoneEnities", "zipErs", "zoneEntables", "zoneEntries", "Zipentrs", "zipEntrys", "zipEnries", "zipEntriers", "zipentables", "ipEs", "zipEntryarts", "zipIntrs", "zipEarts", "zipEnies", "zipEries", "ipEnts", "Zipentries", "zipEires", "zipEnts", "ZipEntries", "ZipEnties", "ipEires", "zipentriers", "zipenties", "zipEntables", "zipEntarts", "zoneEnies", "zipEables", "zipIntries", "zipEntities", "Zipenties", "ZipEntriers", "ZipEntrs", "zipEntires", "zoneEnables", "zipentries", "zipInties", "zipEntryries", "zipEns", "ipEarts", "zoneEnries", "zipEntrs", "zipentrs", "Zipentriers", "zipEnarts"], "target": ["alias", "match", "template", "format", "title", "compatible", "prop", "type", "url", "filename", "class", "project", "pkg", "task", "t", "Target", "top", "test", "arg", "peer", "tif", "gt", "term", "family", "route", "label", "scope", "primary", "host", "tool", "pattern", "layout", "handle", "version", "owner", "result", "text", "parent", "controller", "goal", "buffer", "chain", "resource", "module", "location", "base", "arget", "name", "rel", "tag", "bolt", "local", "table"], "webRewriter": ["webWactor", "webWriter", "webRewrite", "WebWriter", "webRebler", "_", "webRewactor", "WebRewriter", "Input", "WebWactor", "WebRewler", "Entry", "entry", "WebRewrite", "webRebriter", "webRebactor", "webRewler", "webWrite", "webRepler", "json", "WebWler", "webWler", "webRepriter", "webRepactor", "File", "impl", "get", "WebWrite", "Supp", "New", "log", "webRebrite", "cont", "aos", "webReprite", "Log", "println", "WebRewactor"]}}
{"id1": "7396682", "id2": "1188100", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["pixel", "read", "opy", "write", "download", "clip", "Cop", "repeat", "sync", "core", "map", "php", "zip", "link", "load", "cat", "crop", "clone", "move", "fit", "proxy", "cop", "cp", "share", "gc", "py", "archive", "Copy", "cross", "slice", "delete", "upload", "transfer", "create", "replace", "split"], "srcFS": ["srcMS", "sysVS", "srcOS", "rcOS", "sourceVS", " srcVS", " srcMS", "rcFS", " srcfs", "srcCS", "rcFs", " srcSF", "rcfs", "srFS", " srcCS", "srcFs", "srMS", "sourceOS", "rcMS", "srcVS", "sysFs", "sourceCS", " srcOS", "srcSF", "sourcefs", "srcfs", "srFs", "sysOS", "sysFS", "srfs", "sourceFS", " srcFs", "sourceFs", "rcVS", "rcSF", "rcCS", "sourceSF"], "src": ["dest", "obj", "SOURCE", "path", "th", "check", "sin", "supp", "init", "http", "secure", "sci", "input", "sc", "Source", "usr", "subject", "filename", "tmp", "url", "sync", "pkg", "ser", "dir", "sec", "rx", "sr", "rc", "str", "ctr", "https", "proc", "sq", "inst", "sn", "req", "boot", "loc", "rs", "source", "from", "txt", "lb", "img", "pri", "uri", "comp", "addr", "nil", "sys", "spec", "st", "desc", "target", "sb", "iv", "sub", "cont", "resource", "syn", "cur", "start", "rel", "RC", "node", "sit", "obs", "via", "selected"], "dst": ["dest", "lgt", "lest", "dhst", "ddnd", "desdest", "dhDest", "degt", "ddlt", "ddst", "deest", "DST", "Dest", "Dlt", "dsgt", "dDest", "desst", "dslt", " dST", " ddest", "dlt", "ldest", "deslt", "Dst", "dsST", "ddest", "dhdest", "dddest", "dsdest", "dsst", "dedest", "DDest", " dest", " dDest", "dsest", "dsnd", "dgt", " dlt", "dST", "dhlt", "desnd", "dnd", "Ddest", "lst"], "deleteSource": ["delDest", "deleteTarget", "deleteSOURCE", "leteSources", "removeParent", "removeDest", " deleteTarget", " deleteSources", "delParent", "delSOURCE", "updateSource", "leteSOURCE", "updateSite", "leteSource", "DeleteSite", "deleteResult", "DeleteSource", "DeleteSOURCE", "removeSource", "removeSOURCE", "leteParent", "deleteParent", "deleteSite", "leteDest", "updateSourceFile", "leteResult", "destroySources", "closeSource", "deleteSources", "deleteSourceFile", "DeleteSourceFile", "leteTarget", "closeSourceFile", "deleteDest", "delSource", "destroySource", "updateSOURCE", " deleteResult", "closeSite", "closeSOURCE", "destroyResult", "destroyTarget"], "conf": ["css", "check", "com", "cms", "ctx", "cache", "prop", "ban", "Conf", "fs", "info", "comm", "f", "lib", "param", "ln", "m", "config", "map", "params", "irm", "job", "cc", "cb", "req", "q", "cn", "def", "plan", "cm", "acc", "report", "ch", "ref", "conv", "ca", "mm", "log", "conn", "con", "co", "cf", "hash", "scan", "comment", "pool", "cfg"], "contents": ["Contterms", "CONTants", "contends", " contENT", "contodes", "contresses", " Contents", "constENTS", "ContENT", " contterms", "Contodes", "Content", "contENT", "CONTENT", " ContENTS", "constends", "CONTends", " content", "CONTents", " contENTS", " Contresses", "CONTresses", "constaves", "CONTodes", "CONTaves", "CONTent", "Contents", "contaves", " Content", " contends", "contants", " contodes", "Contants", " contants", "content", "contENTS", "constents", "CONTterms", " contresses", "CONTENTS", " contaves", "contterms"], "i": ["ami", "ij", "iter", "is", "init", "my", "us", "gi", "id", "qi", "it", "ski", "xi", "\u0438", "ci", "li", "ms", "I", "m", "oi", "di", "ai", "ix", "docker", "iq", "client", "hi", "ki", "x", "key", "bi", "n", "ii", "q", "u", "multi", "mi", "ic", "ini", "y", "ind", "json", "im", "phi", "sim", "ie", "ori", "ji", "me", "chain", "si", "inner", "span", "ei", "pi", "o", "ti", "cli", "j", "ui", "index", "ims", "ip"], "in": ["In", "read", "check", "is", "out", "input", "sql", "r", "doc", "IN", "inn", "and", "reader", "add", "inf", "bin", "ins", "source", "from", "inc", "mc", "en", "ze", "char", "xml", "ind", "body", "din", "isin", "by", "re", "cin", "con", "raw", " din", "inner", "sample", "ini"]}}
{"id1": "23666973", "id2": "8665321", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["loadStreamSimple", "openResourceSimple", "loadStreamRaw", "openSteamRAW", "openFileRaw", "openSteamRaw", "openSteamInternal", "loadSteamInternal", "openResourceRaw", "openResourceRAW", "openStreamInternal", "loadSteamRaw", "openSteamSimple", "openStreamRAW", "loadSteamSimple", "loadSteamRAW", "openResourceInternal", "openFileSimple", "loadStreamInternal", "openFileRAW", "openFileInternal", "openStreamSimple", "loadStreamRAW"], "filename": ["message", "path", "ren", "bol", "src", "title", "sql", "download", "f", "ename", "subject", "file", "fp", "description", "bf", "journal", "mson", "reference", "Filename", "string", "original", "directory", "LCS", "nm", "word", "til", "fn", "missing", "txt", "source", "png", "jpg", "uri", "lua", "nil", "username", "document", "initial", "fil", "sequence", "length", "mpeg", "river", "ame", "wikipedia", "kl", "upload", "FILE", "java", "metadata", "stem", "location", "name", "prefix", "whatever", "println"], "stream": ["transform", "draw", "where", "find", "then", "file", "feed", "test", "next", "source", "still", "set", "body", "socket", "port", "engine", "stack", "get", "upload", "temp", "log", "history", "resource", "sw", "response", "status", "filter", "pod", "collection", "input", "open", "wrapper", "context", "zip", "trace", "proc", "window", "row", "pipe", "valid", "result", "conv", "chain", "shape", "cont", "sample", "ream", "local", "pool", "table", "Stream", "message", "read", "iter", "check", "rest", "clean", "list", "instance", "link", "load", "peer", "loop", "console", "length", "iterator", "buffer", "ssl", "export", "poll", "mount", "channel", "sl", "http", "store", "download", "output", "sync", "present", " Stream", "reader", "head", "back", "dd", "control", "old", "view", "form", "impl", "parent", "event", "content"], "url": ["ls", "b", "external", "path", "dl", "http", "URL", "lr", "r", "pkg", "file", "l", "ur", "gl", "link", "fl", "browser", "str", "job", "web", "nl", "loc", "hl", "mount", "uri", "char", "rl", "cal", "kl", "impl", "mail", "Url", "build", "mb", "ssl", "resource", "ul", "bel", "rel", "ll", "pl", "sl", "call"], "cl": ["Cl", "dl", "com", "ctx", "tc", "sc", "comm", "class", "fc", "gl", "fl", "load", "cc", "loader", "ocl", "c", "dll", "acl", "hl", "CL", "ct", "decl", "rl", "cm", "sh", "el", "cr", "scl", "lf", "cle", "kl", "impl", "log", "ctrl", "ssl", "ck", "cf", "lp", "ll", "pl", "lc"], "cn": ["css", "ern", "nn", "san", "cap", "yn", "wn", "hn", "bean", "unn", "ocon", "csv", "CN", "uan", "cdn", "gn", "arn", "nic", "tn", "fn", "tun", "atten", "pn", "cv", "gc", "rn", "ct", "unc", "nan", "dn", "cm", "nc", "tan", "jc", "non", "sen", "aren", "pan", "bn", "cin", "mn", "conn", "oul", "can", "cf", "CNN", "avan", "crow", "enn", "ns", "osen"]}}
{"id1": "21092340", "id2": "8062076", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "label": 0, "substitutes": {"addToArchive": ["addInHarive", "addToExFile", "addToArchFile", "addInArchiver", "addInArchive", "addToHarive", "addToZipFile", "addToExive", "addInArchZip", "addInArchFile", "addToZipive", "addToZipiver", "addInHariver", "addToExZip", "addToZipZip", "addToHarZip", "addToArchZip", "addInHarZip", "addToArchiver", "addToExiver", "addToHarFile", "addToHariver", "addInHarFile"], "pod": ["ad", "message", "check", "device", "wp", "component", "pick", "project", "pkg", "task", "pc", "zone", "job", "proc", "top", "Pod", "p", "cp", "ods", "archive", "op", "spec", "policy", "body", "report", "post", "ack", "od", "disk", "pad", "module", "start", "pack", "poll", "volume", "point", "table"], "podArchiveOutputStream": ["podArchiveEntryPoint", "podArchiverOutputSync", "podArchiveOutputPoint", "podArchiverInputForm", "podArchiverInputSync", "podArchiveOutputForm", "podArchiveInputForm", "podArchiverOutputPoint", "podArchiveOutputMap", "podArchiverOutputMap", "podArchiveEntrySteam", "podArchiveOutputContext", "podArchiveStreamMap", "podArchiveOutStream", "podArchiverInputContext", "podArchiveoutputStream", "podArchiverInputSteam", "podArchiveResourceSteam", "podArchiveMainForm", "podArchiveOutputstream", "podArchiveResourcestream", "podArchiveStreamStream", "podArchiveOUForm", "podArchiveOutputSteam", "podArchiveoutputSteam", "podArchiveInputStream", "podArchiveInputPoint", "podArchiveoutputForm", "podArchiveOUSync", "podArchiverInputMap", "podArchiverInputstream", "podArchiveInputStreamer", "podArchiverOutputForm", "podArchiveStreamForm", "podArchiveInputSteam", "podArchiveMainStreamer", "podArchiverOutputStreamer", "podArchiveStreamSync", "podArchiveMainStream", "podArchiveOutContext", "podArchiverOutputstream", "podArchiveInputstream", "podArchiveOUStream", "podArchiveInputContext", "podArchiveOUMap", "podArchiverOutputSteam", "podArchiveResourceContext", "podArchiveInputMap", "podArchiveEntryStream", "podArchiveOutPoint", "podArchiveoutputStreamer", "podArchiveResourceStream", "podArchiverInputStream", "podArchiveMainSteam", "podArchiveOutstream", "podArchiverInputPoint", "podArchiveOutputSync", "podArchiveOutSteam", "podArchiverOutputStream", "podArchiveInputSync", "podArchiveOutputStreamer", "podArchiverOutputContext", "podArchiverInputStreamer"], "filename": ["message", "path", "title", "url", "binary", "subject", "ename", "output", "FN", "file", "description", "fp", "Filename", "string", "release", "original", "directory", "nm", "key", "family", "fn", "txt", "p", "png", "jpg", "uri", "nil", "archive", "version", "username", "fil", "folder", "ame", "kl", "upload", "FILE", "NAME", "names", "resource", "location", "stem", "latest", "name", "prefix", "println"], "source": ["SOURCE", "template", "supp", "src", "store", "input", "component", "sql", "Source", "info", "address", "select", "force", "shell", "context", "file", "ser", "ource", "seed", "use", "proc", "loader", "image", "stream", "from", "copy", "password", "spec", "sequence", "view", "body", "style", "get", "iterator", "series", "resource", "inner", "start", "sample", "service"], "entry": ["obj", "ment", "ce", "or", "sheet", "ace", "component", "query", "card", "tmp", "nt", "file", "task", "quick", "zip", "se", "link", "cell", "record", "Entry", "job", "system", "key", "word", "row", "ent", "good", "char", "archive", "attribute", "cue", "element", "set", "ie", "log", "line", "enter", "connection", "resource", "data", "ry", "comment", "channel", "book"]}}
{"id1": "21063400", "id2": "8801436", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doImageProcess": [" doImagesProcess", "doItemImageWork", "doImagesProcess", "doMediaWork", "doMediaprocess", "doMediaProcess", " doImagesWork", "doImageWork", "doItemImageSort", " doImageprocess", "doItemImageprocess", "doImagesSort", "doImageprocess", "doImagesprocess", " doImageWork", "doMediaSort", " doImagesSort", "doItemImageProcess", "doImageSort", "doImagesWork", " doImagesprocess", " doImageSort"], "request": ["message", "template", "QUEST", "input", "query", "application", "address", "context", "select", "session", "reference", "frame", "quest", "client", "image", "Request", "version", "attribute", "document", "command", "view", "re", "question", "server", "resource", "model", "start"], "response": ["reply", "message", "user", "block", "collection", "format", "display", "http", "cache", "search", "write", "application", "query", "output", "description", "relation", "list", "frame", "network", "success", "answer", "onse", "entry", "window", "image", "next", "one", "page", "continue", "detail", "exit", "ve", "resp", "tree", "xml", "version", "document", "result", "site", "json", "view", "respond", "console", "sequence", "report", "position", "parent", "re", "fire", "connection", "content", "server", "print", "res", "model", "hash", "Response", "status", "reset"], "imgSize": [" imgName", "propError", "imgOwner", "imagError", " imgShape", " imgType", "imgError", "appShape", "imageSIZE", "imgName", "imagName", "certName", "imageInfo", "divSIZE", "imageStyle", "appsize", "divsize", "dimSize", "imgShape", "imageType", "appType", "divSize", "certSIZE", "certSize", "imgInfo", "imgType", "imgScale", "imagSize", "augShape", "imageSize", " imgStyle", "imgSIZE", " imgScale", "appSize", " imgOwner", "imagsize", "augsize", "augOwner", "appInfo", "imgStyle", "dimSIZE", "certScale", "imageScale", " imgSIZE", " imgInfo", " imgsize", " imgError", "appStyle", "propsize", "propName", "propSize", "dimsize", "augSize", "imgsize", "imageName", "appOwner"], "imageInputStream": ["imageInputPath", "photoInputstream", " imageStreamStream", "imageIntStream", "imageIntstream", " imageInputPath", "imageInputView", "imageInView", "photoInputSteam", "imageInStream", " imageStreamPath", "imageRawView", "imageRawStream", "fileInputStream", "imageRawstream", "imageOutputForm", "photoInputStream", "imageByteSteam", "mediaInputStream", "imageInterfaceView", "imageOutputReader", "imageOutputstream", " imageStreamSteam", "photoIntstream", "imageInputForm", "imageStreamStream", "imageInterfacestream", "fileInputstream", " imageInputSteam", "fileRawSteam", "imageInputstream", "imageByteForm", "fileRawStream", "imageInterfaceStream", "imageIntPath", "imageStreamSteam", "imageInSteam", "imageRawSteam", "fileInputView", "imageInputReader", "fileRawstream", "imageInterfaceSteam", "photoIntStream", "imageOutputStream", "imageByteReader", "imageOutputSteam", "fileInputSteam", "fileRawView", "imageIntSteam", "mediaInputForm", "imageStreamPath", "mediaInputReader", "imageInstream", "imageInputSteam", "mediaInputSteam", "photoIntSteam", "imageByteStream"], "imageBytes": ["imgParts", "imgBytes", " imageParts", "pictureBytes", "issueParts", "photoByte", "photoBytes", "pictureGs", " imageSeries", "audioBytes", " imageGs", "photoKeys", "imageParts", "imageBs", "photoGs", "imageGs", "imgSeries", "photoParts", "imageKeys", "imageByte", "audioParts", " imageByte", "imgGs", "issueKeys", " imageBs", "imageSeries", "audioBs", "issueBytes", "imgKeys", "pictureByte", "audioSeries", "imgBs", "issueGs", "pictureParts"]}}
{"id1": "12055086", "id2": "22046596", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"copyDeleting": [" copydeleving", " copyDeleging", " copydeletting", " copyDelingving", " copydeletging", " copydeleging", " copyDeleving", " copydeleting", " copyDelingging", " copyDeletging", " copydeletving", " copyDeeleving", " copyDelingting", " copydeleing", " copyDeeleting", " copyDeletting", " copyDelinging", " copyDeeleging", " copyDeeleing", " copyDeleing", " copyDeletving"], "source": ["SOURCE", "ce", "template", "init", "src", "store", "ace", "input", "search", "sql", "Source", "query", "ource", "seed", "se", "back", "oss", "original", "origin", "image", "from", "scope", "sp", "site", "spec", "body", "target", "style", "form", "parent", "resource", "start", "sample", "base", "service", "local"], "dest": ["th", "rest", "src", "it", "del", "comb", "dir", "Dest", "https", "bin", "origin", "cat", "loc", "cas", "end", "nom", "null", "orig", "them", "img", "pub", "tom", "decl", "way", "master", "est", "sp", "st", "w", "exp", "target", "mm", "port", "temp", "trans", "dist", "d", "lit", "pas"], "buf": ["b", "block", "bytes", "prop", "uf", "cap", "comb", "pkg", "bl", "bc", "rb", "str", "cb", "tx", "meg", "cat", "Buffer", "br", "cv", "img", "arr", "capt", "cmd", "box", "batch", "bs", "cp", "bag", "seq", "alph", "tab", "ref", "conv", "fg", "bh", "Buff", "eb", "aka", "pause", "buffer", "vec", "fb", "cf", "cur", "buff", "data", "cast", "bus", "db"], "in": ["In", "user", "read", "iter", "is", "init", "or", "on", "input", "rin", "al", "it", "info", "per", "IN", "inn", "inside", "inf", "bin", "ai", "ri", "ins", "inc", "from", "en", "ze", "ic", "el", "ind", "din", "mm", "isin", "by", "cin", "con", "i", "gin", "inner", "ini", "un"], "out": ["obj", "at", "net", "OUT", "ou", "on", "write", "dis", "output", "nt", "ion", "t", "oss", "client", "Out", "n", "end", "page", "os", "en", "cn", "to", "flush", "up", "io", "ne", "sys", "outs", "writer", "conv", "by", "log", "con", "conn", "i", "co", "sum", "inner", "aos", "can", "auto", "o", "v", "outer", "res"], "count": ["Count", "read", "counter", "check", "conf", "number", "cap", "z", "nt", "amount", "core", "current", "cond", "t", "add", "common", "ctr", "cc", "size", "c", "found", "n", "cloud", "q", "ct", "num", "coll", "batch", "len", "char", "acc", "ind", "length", "ch", "deep", "nb", "cont", "total", "sum", "max", "code", "span", "now", "start", "ount", "comment", "index"]}}
{"id1": "14865947", "id2": "6756635", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"execute": [" executes", " execution", " Exec", " dispatch", " eval", "exec", "run", " evaluate", " operate", "Command", " executed", " parse", "Exec", "command", "Action", " Execution", " executable", " query", "process", " resume", " Run", " executing", " proceed", "invoke", " manage", " command", " interpret", " executions"], "event": ["ex", "ce", " invocation", "context", "xe", " EVENT", "t", "frame", "se", "ae", "de", "exc", "pe", "ed", "command", " environment", "w", "E", "te", " frame", "Ev", " Event", " events", "Event", "EE", "ev", "ee", " command"], "shell": ["b", "message", "range", "template", "hell", "grid", "query", "sql", "search", "widget", "session", "ssh", "pty", "Shell", "help", "l", "lock", "cell", "root", "system", "html", "nl", "window", "detail", "scope", "hl", "tools", "screen", "h", "scroll", "quit", "tool", "layout", "handle", "tree", "sh", "sys", "ja", "bot", "console", "body", "sol", "round", "tab", "microsoft", "sb", "js", "windows", "style", "stack", "fr", "line", "buffer", "history", "base", "cli", "theme", "kernel", "pool"], "view": ["block", "template", "review", "display", "ou", "vp", "query", "widget", "list", "browser", "VIEW", "web", "html", "window", "image", "row", "screen", "vm", "cv", "ve", "tv", "layout", "tree", "version", "eye", "document", "w", "show", "see", "report", "buffer", "v", "views", "View", "ui", "iew"], "rootFolder": [" rootDirectory", "coverDisk", "coverFolder", "parentDir", "bottomLibrary", "RootEntry", " rootEntry", " rootLibrary", "RootFolder", "RootDirectory", "parentDirectory", "rootCategory", "bottomFolder", "RootDir", "parentEntry", "rootDirectory", "RootCategory", "parentFolder", " rootArea", "bottomDisk", "coverLibrary", "parentArea", "RootArea", "rootArea", "coverDirectory", " rootCategory", "rootDir", "rootEntry", "rootDisk", "rootLibrary", " rootDisk", "parentCategory", " rootDir", "bottomDirectory"], "dialog": ["logig", " Dializ", "dialig", "logDialog", "Dialj", "dialj", "dloc", "dialOG", "choDialog", "Dialog", "DialDialog", "closer", "callDialog", "selectig", "Dialoc", "dialogs", "choog", "dliz", "dlj", "dializ", "clog", "selectoser", " Dialog", " Dialoc", "selectDialog", " Dialj", "Dializ", "Dialogs", "clDialog", "dialDialog", "selectog", "logog", "dlog", "dialoc", "DialOG", "choogs", "logoser", "choOG", "callOG", "callogs", "clig", "callog", "dialoser"], "password": ["message", "user", "path", "sword", "words", "device", "pass", "Password", "query", "wd", "address", "database", "description", "login", "paste", "request", "encrypted", "secret", "string", "directory", "padding", "entry", "key", "word", "source", "picture", "p", "table", "expression", "pattern", "username", "attribute", "command", "shadow", "PASS", "clear", "definition", "buffer", "raw", "hash", "language", "data", "response", "phrase", "comment", "hello", "prefix", "reset"], "md5": ["mt5", " md6", "mm2", "md4", "md64", "md512", "MD3", "MD4", " md2", "ma64", "m5", "MD6", "mm5", "ma7", "md3", "mt4", "mm6", "MD2", "m3", "mb512", "md6", "MD7", "MD5", "mm7", "MD64", "m4", "MD512", " md512", "mt2", "md2", " md4", "mb4", "ma5", "md7", "ma2", " md7", " md64", "m2", "mb2", "mb5", "mt3"], "md": ["nd", "pt", "cd", "dr", "dh", "mt", "red", "nt", "MD", "m", "pm", "rm", "mk", "mac", "de", "hd", " dd", "mc", "df", "pd", "cmd", "dd", "ct", "det", "msg", "ind", "mod", "pdf", "mm", "ld", "bd", "od", "dig", "mn", "mb", "metadata", "d", " Md", "sd", "hash", "mg", "ms", "sm", "dm", "magic"]}}
{"id1": "14324112", "id2": "19206412", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"innerProcess": ["inlineprocess", "inlineRender", "inlineProcess", "innerprocess", " innerprocess", " innerSelect", "inlineSelect", "originalSelect", "originalRender", "originalprocess", " innerRender", "innerRender", "innerSelect", "originalProcess"], "curi": ["cuni", "citi", "crui", "cudi", "mcumi", "cvoid", "caddress", "lcudi", "crudi", " caddress", " cudi", "cphi", "luri", "lcvoid", "caturi", "mchtml", "Cuni", "dumi", "mcuni", "crdu", "acuri", "curl", "mcurl", "rcuri", "Ciri", " couri", "covoid", "rcri", " cui", "mcuri", " cri", "catphi", "chtml", "lcuri", "catumi", "uncdu", "cdri", "cduri", "duri", "cori", "Caddress", "lcdu", "cui", "achtml", "catuni", "cury", "lri", "Cdu", "liri", "wdu", "uncuri", "lciti", "cdumi", "ctumi", "ctiri", "couni", "uncri", "uncaddress", "Curi", " cdu", "cumi", "acri", "wuri", "ctui", "catvoid", "mciri", "Couri", "cri", "catury", "ctiti", "lcui", "coury", "cathtml", "wiri", " curl", "rcouri", "cdurl", "Cui", "cdui", " cumi", "diri", "cdu", "couri", "lcphi", "cophi", "Cumi", "lui", "rcui", "ctdu", "Cri", " ciri", "acuni", "wri", "ctri", "lcri", "coumi", "Curl", "ciri", "durl", "acumi", "cturi", " citi", "lcury", "cruri"], "maxsize": ["maxspace", "MAXnumber", "maxbytes", "Maxlen", " MAXlength", "minSize", "axbytes", "maxnumber", "mxsize", " MAXsize", "maxSIZE", "MAXSize", " maxSize", " maxnumber", "maxSize", " maxbytes", "maxlength", "MaxSIZE", "MaxSize", "maxize", "Maxbytes", " maxSIZE", "axlen", "axSIZE", "mxSIZE", "maxlen", "mxSize", "Maxsize", "Maxize", "MAXsize", " MAXnumber", " maxlen", "minSIZE", "MAXlength", " maxspace", "minsize", "axsize", "minspace", "axSize", "axize", " maxlength", " MAXSize", " maxize", "mxspace"], "regexpr": ["fregexpr", "consexexpr", "congexrepl", "bregexpr", "regexexpr", "reexper", "relypr", "regexper", "repatternpr", "reqexpr", "reexer", "repexpro", "replexpr", "repexpr", "reqps", "rexPR", "relyexpr", "brecreexpr", "regexpt", "repatternvr", "fregexpt", "relyrepl", "reewrepl", "brecreps", "repexPR", "regdvr", "reqer", "regexprop", "bregexps", "reexpr", "reexexpr", "fregexper", "regexps", "regexvr", "fregdper", "reexpt", "replexexpr", "frepexPR", "replexpro", "bregexer", "brecrepr", "consexpr", "congexprop", "reewprop", "fregdpr", "regdper", "recreer", "recreps", "congexexpr", "fregdvr", "rexexpr", "repexexpr", "regdpr", "reewpr", "rexpro", "fregexpro", "resexexpr", "brecreer", "resexpr", "resexrepl", "frepexpr", "regexrepl", "recreexpr", "regexpro", "consexrepl", "repatternper", "relyprop", "replexPR", "reexps", "bregexexpr", "fregdpt", "resexprop", "congexpr", "frepexpro", "recrepr", "fregexvr", "rexpr", "reewexpr", "reqpr", "consexprop", "regdpt", "fregexPR", "repatternpt", "frepexexpr", "regexer", "reexvr", "regexPR", "fregexexpr"], "cs": ["ls", "css", "cks", "gs", "cms", "ctx", "acs", "ics", "ts", "ds", "CS", "sc", "fs", "ats", "acts", "Cs", "csv", "ctr", "cc", "sts", "caps", "c", "cas", "rs", "ces", "ours", "ars", "cp", "gc", "cn", "bs", "cus", "unes", "nc", "icks", "its", "js", "es", "wcs", "ps", "ks", "ss", "cf", "mr", "qs", "ws", "ms", "sels", "ims", "ns"], "digest": ["dest", "shaum", "Digester", "shase", "Diger", "Digum", "ddester", "digester", " digse", "der", "dder", "signest", "digum", "digested", "Digist", "Digest", "diger", "signse", "dester", "ddist", "ddest", "hashse", "Digse", "digist", " diger", "hashester", "shaested", "signested", "dist", "signum", "Digested", " digester", "digse", "shaest", "hashest", "hasher"], "s": ["b", "ls", "gs", "is", "strings", "gets", "ts", "ds", "fs", "r", "f", "des", "ats", "t", "l", "str", "string", "less", "sq", "sts", "c", "x", "n", "a", "os", "p", "h", "S", "y", "text", "w", "sb", "js", "conv", "ps", "i", "stats", "ss", "v", "o", "qs", "ws", "simple", "j", "ms", "es", "ims", "ns"], "m": ["b", "tm", "message", "match", "mol", "M", "gm", "r", "f", "mt", "rm", "ym", "t", "l", "md", "c", "nm", "n", "mo", "p", "vm", "mi", "h", "cm", "mod", "w", "mat", "em", "mm", "g", "i", "fm", "d", "arm", "v", "span", "mr", "model", "ms", "sm", "dm"]}}
{"id1": "21033686", "id2": "5808579", "code1": "    public File read() throws IOException {\n        URLConnection conn = url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.connect();\n        int length = conn.getContentLength();\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        if (tempDir == null) {\n            tempDir = \".\";\n        }\n        File tempFile = new File(tempDir + \"/\" + new GUID() + \".dat\");\n        tempFile.deleteOnExit();\n        InputStream in = null;\n        OutputStream out = null;\n        ProgressMonitor monitor = new ProgressMonitor(parentComponent, \"Downloading \" + url, null, 0, length);\n        try {\n            in = conn.getInputStream();\n            out = new BufferedOutputStream(new FileOutputStream(tempFile));\n            int buflen = 1024 * 30;\n            int bytesRead = 0;\n            byte[] buf = new byte[buflen];\n            ;\n            long start = System.currentTimeMillis();\n            for (int nRead = in.read(buf); nRead != -1; nRead = in.read(buf)) {\n                if (monitor.isCanceled()) {\n                    return null;\n                }\n                bytesRead += nRead;\n                out.write(buf, 0, nRead);\n                monitor.setProgress(bytesRead);\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            monitor.close();\n        }\n        return tempFile;\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 0, "substitutes": {"read": ["iter", "pull", "gets", " Read", "wait", "shift", "all", "Read", "find", "write", "download", "open", "url", "query", "select", "input", "request", "reader", "count", "add", "send", "reads", "load", "feed", "size", "stream", "run", "end", "next", "READ", "close", "copy", "view", "reading", "upload", "get", "take", "buffer", "GET", "content", "seek", "print", "transfer", "create", "poll", "data", "skip", "connect", "readable", "index"], "conn": ["obj", "com", "init", "Conn", "net", "cert", "ctx", "conf", "url", "sql", "open", "comm", "nt", "exec", "ann", "client", "cb", "c", "fin", "ait", "gate", "cp", "close", "cn", "ct", "cmd", "aj", "addr", "canon", "act", "resp", "handle", "cmp", "nc", "cm", "msg", "socket", "ch", "access", "conv", "enc", "dial", "ca", "ctrl", "con", "jp", "ssl", "connection", "cont", "co", "syn", "res", "cur", "connect", "j", "pg", "ns", "pas"], "length": ["message", "rest", "number", "amount", "present", "ENGTH", "count", "l", "load", "L", "size", "family", "len", "default", "ength", "result", "height", "sequence", "position", "Length", "phi", "duration", "history", "total", "available", "data"], "tempDir": ["tempFolder", "poraryFolder", "empPath", "templateEar", "empStart", "templateFolder", "tmpStart", "tmpServ", "poraryStart", "templateDir", "tempServ", "poraryDir", " tempPath", "empDir", "empdir", "tmpFolder", "tempStart", "nullPath", "nulldir", "tmpDir", " tempFolder", "empFolder", "tmpEar", "tmpDirectory", "nullDir", "tmpPath", "templateDirectory", "tempPath", "poraryServ", "poraryEar", "tempEar", "empFile", "tempdir", "poraryDirectory", "empServ", "tmpdir", "tmpFile", "tempDirectory"], "tempFile": ["tempFolder", " tempField", "poraryFolder", "tempfile", "currentPlace", "currentB", "tempField", "empPlace", "poraryfile", "empfile", "tmpfile", "empB", "TempFile", "tempPlace", "empDir", " tempPath", "tmpFolder", "TempDir", "poraryFile", "empFolder", "TempPath", "Tempfile", "tmpPath", "tmpB", "tmpPlace", "empField", "tempPath", "tempB", "poraryPlace", "currentFile", "currentfile", "TempField", " tempfile", "empFile", "tmpFile"], "in": ["In", "ex", "iter", "is", "init", "or", "net", "conf", "on", "input", "rin", "al", "it", "all", "ain", "IN", "inn", "t", "add", "l", "inside", "str", "inf", "bin", "ai", "irm", "client", "image", "n", "ins", "source", "from", "inc", "en", "mi", "up", "io", "el", "ind", "st", "body", "din", "form", "isin", "log", "re", "nin", "cin", "con", "i", "gin", "raw", "internal", "ssl", "inner", "o", "local", "ini"], "out": ["b", "obj", "external", "ex", "at", "com", "or", "OUT", "net", "ou", "on", "it", "all", "write", "dis", "output", "oe", "m", "t", "s", "l", "oss", "client", "again", "boot", "Out", "n", "end", "null", "ins", "a", "os", "p", "cn", "to", "up", "io", "ne", "sys", "outs", "op", "w", "writer", "conv", "OU", "na", "an", "nin", "con", "co", "sum", "inner", "aos", "can", "o", "outer", "ot", "ns"], "monitor": ["message", "Monitor", "match", "display", "thread", "rain", "progress", "info", "tem", "m", "config", "stat", "program", "network", "ai", "trace", "lock", "summary", "loader", "umi", "system", "pool", "memory", "gray", "detail", "stream", "menu", "manager", "processor", "batch", "alert", "cm", "handler", "state", "console", "im", "report", "sim", "log", "chron", "monkey", "meter", "mon", "buffer", "timer", "history", "spin", "process", "timeout", "profile", "bm", "watch", "status", "member", "sm", "mx", "dm"], "buflen": ["bufllen", "buplun", "bulllen", " buplun", " bufllen", "buglun", "bucollength", "bucolleng", " buflength", "bulleng", " buflun", "buclun", " buplen", "bupleng", "buflength", "buglen", "buglength", " bufleng", " buplens", "bupllen", " bupllen", "buflun", "bullength", " bupleng", " buplength", "buclength", "buplen", "buplength", " buflens", "buplens", "buclens", "bucolllen", "bullen", "buclen", "buflens", "bucollen", "buglens", "bufleng"], "bytesRead": ["bytesWrite", "blocksWrite", "itemsWrite", "tesRead", "tesWrite", " bytesread", "tesNeed", " bytesReader", "BytesReader", "tesFound", "BytesFound", "bytesNeed", " bytesFound", "bytesSend", "itemsReader", "bytesReader", "tesWritten", "blocksWritten", "bytesFound", "linesRead", "linesWritten", "itemsSend", "blocksNeed", "blocksRead", "Bytesread", "BytesSend", "bytesread", "tesread", "BytesRead", " bytesSend", "linesWrite", "bytesWritten", "linesNeed", "BytesWrite", " bytesWrite", "itemsRead"], "buf": ["b", "block", "bytes", "ctx", "prop", "uf", "mu", "cap", "pkg", "bl", "rb", "ctr", "bin", "cb", "cat", "Buffer", "window", "row", "lim", "txt", "br", "orig", "img", "cv", "arr", "bu", "cmd", "batch", "box", "act", "bag", "tr", "bar", "cam", "msg", "seq", "tab", "conv", "Buff", "log", "buffer", "wb", "vec", "fb", "cur", "mem", "buff", "bed", "ob", "db"], "start": ["rest", "init", "ptr", "stop", "offset", "open", "tmp", "first", "t", "size", "end", "Start", "ST", "p", "len", "sp", "state", "st", "step", "art", "delay", "duration", "sample", "base", "name", "time"], "nRead": ["nWritten", "onReader", "dnWrite", "onRead", "ncView", "dnReader", "nnRequest", "numRead", "cnDisplay", "cnWritten", " nRequest", "numView", "ncRead", "onWrite", "nDisplay", "nnUpdate", " nCopy", "nsWritten", "nsDisplay", "pnWrite", "ncReader", "nsRead", "NRead", "NWrite", "nnReader", " nDisplay", "cnWrite", "dnUpdate", "cnRead", " nWrite", "numReader", "nView", "nWrite", "ncWrite", "nsWrite", "NRequest", "nnRead", "pnReader", "numWrite", "nnWrite", "nReader", " nWritten", " nUpdate", "pnRead", "onCopy", "nRequest", "pnCopy", " nReader", "nUpdate", "dnRead", "nCopy", " nView"]}}
{"id1": "22441244", "id2": "5989666", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"send": ["reply", "Send", "message", "init", "parse", "write", "save", "apply", "add", "push", "submit", "end", "sent", "msg", "set", "report", "post", "get", "mail", "build", "export", "transfer", "print", "security", "create", "execute"], "hsession": ["rsess", "HSessions", "hessions", "hhhip", "hsettings", "HSsession", "hettings", "HSess", "HSpace", "hsessions", "hspace", "hhession", "hsess", "hhsession", "hhessions", "rspace", "hession", "hhip", "rsession", " HSession", "hssession", "hship", "HShip", " HSpace", "HSession", " HSess", "hhettings", " HSsession", "HSettings", "rssession"], "session": ["message", "ess", "driver", "store", "cache", "context", "instance", "lock", "client", "Session", "job", "ession", "sid", "object", "manager", "password", "document", "state", "set", "view", "parent", "account", "connection", "event", "content", "name", "ip"], "repositoryName": ["repoositoryData", "reposoryData", "repositoryTitle", "repoositoryPath", "reposositoryname", "repositableData", "repositionPath", "repositoryNAME", "repositorNAME", "repositionNAME", "reposoryname", "reposoryNAME", "reposositoryData", "repositorName", "repoositoryTitle", "reposoryName", "repositorPath", "repoitoryname", "repositorTitle", "repoositoryname", "repositoryPath", "repoitoryTitle", "repositableName", "reposositoryNAME", "repositionTitle", "repoositoryNAME", "repoitoryData", "repositableNAME", "repositoryname", "reposositoryPath", "repositoryData", "repositablename", "repoitoryNAME", "repositionName", "repoositoryName", "reposositoryTitle", "reposositoryName", "repoitoryName", "repoitoryPath"], "ideIdint": ["ideIdentind", "IDEIdINT", "ideInfoINT", "ideIdentint", "ideIdline", "ideThind", "IDEidint", "IDEidINT", "ideIdINT", "ideIDind", "ideidint", " ideThline", "ideInfost", "ideIDline", "ideIdst", "ideIDno", "ideidst", "ideIdentline", "ideIdentno", "ideThint", "ideThline", " ideThint", " ideThind", "ideDst", "ideIDint", " ideIdind", "IDEIdst", "ideInfoint", "ideidINT", " ideIdline", "ideThno", "ideDINT", " ideThno", "ideDint", "ideIdind", " ideIdno", "ideIdno", "IDEIdint", "IDEidst"], "to": ["range", "tt", "tp", "address", "toc", "t", "about", "phone", "pos", "client", "To", "top", "too", "ta", "eto", "route", "os", "pro", "TO", "addr", "tr", "token", "site", "st", "company", "target", "po", "by", "no", "ato", "co", "contact", "o", "auto", "tel", "topic"], "cc": ["cs", "ce", "cd", "tc", "sc", "ci", "toc", "fc", "rc", "cl", "cb", "dc", "cloud", "mc", "cv", "ac", "cp", "ct", "cmd", "cn", "control", "ic", "CC", "ico", "cm", "cmp", "cr", "company", "cca", "cci", "ca", "ec", "cy", "ctrl", "cin", "ck", "co", "cf"], "bcc": ["bck", "bce", "cbcc", "cbCC", "vcy", "cbck", "sbck", " bck", "rbcm", "cbcm", "bcm", "rbCC", "vck", " bcm", "vce", "sbce", "rbce", "rbck", "vcc", "sbcc", "sbcy", "rbcy", "bCC", "rbcc", " bCC", "bcy"], "subject": ["message", "header", "template", "title", "note", "heading", "id", "face", "filename", "author", "description", "head", "html", "source", "Subject", "host", "uri", "text", "form", "mail", "content", "metadata", "security", "name", "prefix", "topic", "comment"], "body": ["b", "message", "bytes", "files", "template", "title", "note", "query", "url", "binary", "output", "shell", "ODY", "description", "any", "zip", "head", "news", "params", "back", "inline", "summary", "parts", "padding", "html", "top", "source", "null", "object", "h", "layout", "handle", "ody", "part", "default", "json", "business", "text", "bill", "report", "post", "hex", "bh", "mail", "no", "line", "buffer", "background", "content", "inner", "code", "base", "data", "name", "other", "comment", "response", "Body"], "attachments": ["attachtypes", "attachresses", "Attachments", "attachachment", "Attachresses", "Attachtypes", "atttypes", "achmentresses", "achmenttypes", "achmentments", "attments", "attresses", "Attachachment", "achmentachment"], "isHtml": ["isHap", " isHHTML", "isHHTML", " isWhtml", "IsHtml", "isChtml", "isWhhtml", "isVHTML", "isJttp", "isChip", "isVtml", " isWhip", "isWhip", " isHip", "ishttp", "isHttp", "IsHhtml", "isJhtml", "isWhHTML", "isVhtml", " isWhhtml", "isHip", "isChHTML", "isJap", "isChhtml", "ishtml", "IsHttp", "ishhtml", "isJtml", "isWhtml", " isWhHTML", "ishap", "isVip", " isHhtml", "isHhtml", "IsHap"], "charset": ["chippec", "ChARSET", "chersets", "charpetter", "ChARSet", "clarsetter", "quarsale", "CHarsets", "quatset", "quarset", "chARSets", "chippet", "chacterspace", "charsale", "Charset", "quarsec", "charsetter", "CHippets", "chablesetter", "chippets", "chableset", "chatsetter", "chippetter", "charpetic", "Charsetic", "clerset", "chARSetic", "chippET", "chablesec", "cherset", "chARSetter", "CHippett", "chablesale", "ChARSetter", "Charsetter", "charpett", "charsets", "channelsetter", "chacterset", "channelsET", "CHarsett", "quarsetter", "clersetter", "charpet", "chatset", "channelsetic", "charsET", "chactersetter", "clarspace", "clarsets", "chatsale", "charpET", "CharsET", "CHippet", "chARSet", "quatsec", "chippett", "quatsetter", "CHarsET", "ChARSetic", "charsetic", "chARSpace", "charspace", "chippale", "CHarset", "clerspace", "charsett", "chARSET", "cherspace", "chactersets", "CHippET", "charpets", "chersetter", "charsec", "clarset", "chatsec", "quatsale", "channelset", "clersets"], "headers": ["header", "files", "dr", "authors", "keys", "users", "head", "params", "comments", "ters", "heads", "types", " heads", "ilers", "details", " trailers", "limits", "ppers", "codes", "fields", "members", "relations", "names", "lines", "metadata", "ors", "ers"], "priority": ["title", "id", "grade", "context", "description", "properties", "phone", "comments", "pos", "origin", "due", "primary", "flags", "serial", " urgency", "password", "state", "policy", "company", "position", "status", "level", "security", " severity", "profile", "prefix", "order"], "email": ["external", "message", "ilo", "liner", "Email", "template", "ome", "voice", "note", "http", "all", "search", "office", "url", "address", "output", "database", "oe", "shell", "instance", "description", "echo", "link", "entry", "html", "gmail", "test", "detail", "domain", "label", "object", "die", "ell", "er", "il", "xml", "ne", "document", "initial", "result", "element", "el", "msg", "console", "company", "view", "password", "report", "em", "delete", "e", "mail", "log", "license", "line", "enter", "ssl", "event", "fax", "server", "contact", "print", "et", "model", "example", "sample", "response", "comment", "ee", "reset", "call"], "user": ["person", "match", "creator", "auth", "human", "id", "usr", "output", "author", "users", "login", "use", "actor", "browser", "client", "system", "student", "USER", "User", "from", "manager", "util", "used", "username", "owner", "result", "usa", "uid", "by", "ident", "usage", "entity", "me", "account", "connection", "profile", "name", "admin", "ip"], "identity": ["identificate", "IDENTator", "recognentity", "instifier", "identalty", "identicate", "primance", "primicate", "identance", "IDENTity", "equator", "identator", "ethnicentity", "identiciary", "entifier", "IDENTificate", "equity", "identifier", "equalty", "solidity", "presentularity", "IDENTifier", "presententity", "idITY", "entularity", "identality", "personity", "recognity", "IDENTITY", "ethnicularity", "idiciary", "instentity", "ententity", "IDENTicate", "IDENTitate", "presentitate", "primentity", "IDENTentity", "IDENTance", "idality", "equentity", "solidularity", "ethnicity", "recognance", "personicate", "instity", "solidentity", "instalty", "idularity", "recognicate", "instator", "personentity", "identitate", "IDENTality", "solidality", "identITY", "presentity", "idententity", "identularity", "entity", "IDENTalty", "personITY", "instularity", "IDENTiciary", "primity", "ethnicitate", "idity", "IDENTularity", "personificate", "personiciary", "primificate"], "_returnPath": ["_returnLocation", "_getPath", "setsavePath", "_deletePath", "setreturnTo", "_errorpath", " _returnPoint", "_errorAddress", "_resultLocation", " _errorPath", "setsavepath", "_errorName", "_deletePoint", "setreturnUrl", "_ReturnPoint", "_retPath", "_returnpath", " _returnAddress", "_returnUrl", " _errorName", "_savepath", "_replyPath", "_returnCode", "_getCode", "_retDir", "_errorPoint", "_requestName", "_errorTo", "_deletepath", "_requestAddress", "_returnDir", "_requestPath", "setreturnPath", "_errorPath", "_resultTo", " _errorPoint", "_getDir", "_ReturnPath", "_requestPoint", "_retUrl", "_getTo", "_errorLocation", "setsaveTo", "_deleteTo", "_resultPoint", "_errorUrl", "_returnTo", "setsaveUrl", "_retPoint", "_ReturnName", "_returnPoint", "_replyDir", " _errorAddress", "_savePath", "_retpath", "_saveUrl", "_retCode", "setreturnpath", "_retLocation", " _returnName", "_replyCode", "_returnName", "_returnAddress", "_ReturnAddress", "_resultPath", "_retTo", "_saveTo"], "_from": ["letto", "letabout", " _form", "remfrom", " _reset", "letsource", "_owner", "_reset", "_about", "_local", "remlocal", "longfrom", "_form", "letfrom", "\tactor", "_actor", "longsource", "\tauthor", "\tfrom", "_addr", "_author", "_source", " _source", " _about", "\tform", "remowner", "longto", " _actor", "remaddr", "longreset", " _author"], "_replyTo": ["_returnTO", "_backTO", "_backPath", "_returnFrom", "_responseLine", "_closeLine", "_replyPath", "_closeTO", "_ReplyTo", "_responseOf", "_respondTO", "_respondFrom", "_respondOnly", "_replyOnly", "_ReplyOnly", "_ReplyFrom", "_commentTO", "_commentLine", "_commentOf", "_closeTo", "_returnTo", "_replyOf", "_ReplyTO", "_commentTo", "_returnOnly", "_backFrom", "_replyFrom", "_replyLine", "_responseTo", "_responsePath", "_ReplyPath", "_responseFrom", "_replyTO", "_responseTO", "_backTo", "_respondTo", "_closeOf"], "_to": ["successto", "successtopic", "pritopic", "_ta", "successsite", "_site", "_topic", "prita", "prito", "prisite", "successta"], "_cc": [" _cs", "_cca", "_subject", " _cca", " _subject", "_cs"], "_bcc": ["_bacc", "_wck", "_bca", "_wca", "_wcc", "_rbca", "_bck", "_rca", "_rbck", "_wacc", "_rbcc", "_rcc", "_rck", "_rbacc", "_racc"]}}
{"id1": "7396682", "id2": "2324868", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"copy": ["pixel", "read", "opy", "write", "download", "clip", "Cop", "repeat", "sync", "core", "map", "php", "zip", "link", "load", "cat", "crop", "clone", "move", "fit", "proxy", "cop", "cp", "share", "gc", "py", "archive", "Copy", "cross", "slice", "delete", "upload", "transfer", "create", "replace", "split"], "srcFS": ["srcMS", "sysVS", "srcOS", "rcOS", "sourceVS", " srcVS", " srcMS", "rcFS", " srcfs", "srcCS", "rcFs", " srcSF", "rcfs", "srFS", " srcCS", "srcFs", "srMS", "sourceOS", "rcMS", "srcVS", "sysFs", "sourceCS", " srcOS", "srcSF", "sourcefs", "srcfs", "srFs", "sysOS", "sysFS", "srfs", "sourceFS", " srcFs", "sourceFs", "rcVS", "rcSF", "rcCS", "sourceSF"], "src": ["dest", "obj", "SOURCE", "path", "th", "check", "sin", "supp", "init", "http", "secure", "sci", "input", "sc", "Source", "usr", "subject", "filename", "tmp", "url", "sync", "pkg", "ser", "dir", "sec", "rx", "sr", "rc", "str", "ctr", "https", "proc", "sq", "inst", "sn", "req", "boot", "loc", "rs", "source", "from", "txt", "lb", "img", "pri", "uri", "comp", "addr", "nil", "sys", "spec", "st", "desc", "target", "sb", "iv", "sub", "cont", "resource", "syn", "cur", "start", "rel", "RC", "node", "sit", "obs", "via", "selected"], "dst": ["dest", "lgt", "lest", "dhst", "ddnd", "desdest", "dhDest", "degt", "ddlt", "ddst", "deest", "DST", "Dest", "Dlt", "dsgt", "dDest", "desst", "dslt", " dST", " ddest", "dlt", "ldest", "deslt", "Dst", "dsST", "ddest", "dhdest", "dddest", "dsdest", "dsst", "dedest", "DDest", " dest", " dDest", "dsest", "dsnd", "dgt", " dlt", "dST", "dhlt", "desnd", "dnd", "Ddest", "lst"], "deleteSource": ["delDest", "deleteTarget", "deleteSOURCE", "leteSources", "removeParent", "removeDest", " deleteTarget", " deleteSources", "delParent", "delSOURCE", "updateSource", "leteSOURCE", "updateSite", "leteSource", "DeleteSite", "deleteResult", "DeleteSource", "DeleteSOURCE", "removeSource", "removeSOURCE", "leteParent", "deleteParent", "deleteSite", "leteDest", "updateSourceFile", "leteResult", "destroySources", "closeSource", "deleteSources", "deleteSourceFile", "DeleteSourceFile", "leteTarget", "closeSourceFile", "deleteDest", "delSource", "destroySource", "updateSOURCE", " deleteResult", "closeSite", "closeSOURCE", "destroyResult", "destroyTarget"], "conf": ["css", "check", "com", "cms", "ctx", "cache", "prop", "ban", "Conf", "fs", "info", "comm", "f", "lib", "param", "ln", "m", "config", "map", "params", "irm", "job", "cc", "cb", "req", "q", "cn", "def", "plan", "cm", "acc", "report", "ch", "ref", "conv", "ca", "mm", "log", "conn", "con", "co", "cf", "hash", "scan", "comment", "pool", "cfg"], "contents": ["Contterms", "CONTants", "contends", " contENT", "contodes", "contresses", " Contents", "constENTS", "ContENT", " contterms", "Contodes", "Content", "contENT", "CONTENT", " ContENTS", "constends", "CONTends", " content", "CONTents", " contENTS", " Contresses", "CONTresses", "constaves", "CONTodes", "CONTaves", "CONTent", "Contents", "contaves", " Content", " contends", "contants", " contodes", "Contants", " contants", "content", "contENTS", "constents", "CONTterms", " contresses", "CONTENTS", " contaves", "contterms"], "i": ["ami", "ij", "iter", "is", "init", "my", "us", "gi", "id", "qi", "it", "ski", "xi", "\u0438", "ci", "li", "ms", "I", "m", "oi", "di", "ai", "ix", "docker", "iq", "client", "hi", "ki", "x", "key", "bi", "n", "ii", "q", "u", "multi", "mi", "ic", "ini", "y", "ind", "json", "im", "phi", "sim", "ie", "ori", "ji", "me", "chain", "si", "inner", "span", "ei", "pi", "o", "ti", "cli", "j", "ui", "index", "ims", "ip"], "in": ["In", "read", "check", "is", "out", "input", "sql", "r", "doc", "IN", "inn", "and", "reader", "add", "inf", "bin", "ins", "source", "from", "inc", "mc", "en", "ze", "char", "xml", "ind", "body", "din", "isin", "by", "re", "cin", "con", "raw", " din", "inner", "sample", "ini"]}}
{"id1": "6966398", "id2": "22046596", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"reader": ["read", "driver", "rer", "iter", "Reader", "dr", " readers", "cer", "lr", "input", "ocr", "query", "r", "wrapper", "older", "file", "rx", "sr", "rc", "parser", "loader", "builder", "roller", "ri", "rar", "stream", "row", " read", "rs", "this", "er", "runner", "rl", "io", "handler", "ner", "rr", "writer", "redo", "buffer", "rot", "inner", "mr", "ro"], "ks": ["ls", "cs", "cks", "sky", "kas", "keys", "ds", "fs", "k", "vs", "ys", "ans", "uk", "km", "agles", "mk", "ols", "KS", "oss", "akes", "ki", "checks", "uds", "ces", "kr", "eks", "ars", "sk", "bs", "kk", "ses", "kes", "icks", "ips", "kens", "hs", "eps", "ke", "ss", "ck", "ros", "ates", "kb", "nets", "qs", "kies", "ups", "ms", "obs"], "key": ["Key", "obj", "user", "KEY", "my", "sky", "cer", "sign", "keys", "type", "k", "info", "file", "core", "ssh", "mk", "link", "client", "root", "entry", "x", "null", "tk", "pair", "object", "sk", "trust", "char", "er", "password", "owner", "power", "y", "ey", "ca", "by", "ox", "ke", "ek", "base", "hash", "service"], "chain": ["path", "range", "group", "block", "check", "ce", "cache", "chains", "sign", "component", "number", "ver", "type", "binary", "file", "list", "frame", "string", "trace", "root", "test", "c", "stream", "family", "pair", "box", "batch", "password", "result", "sequence", "sche", "form", "ca", "stack", "piece", "Chain", "can", "code", "base", "hash", "data", "bank", "channel", "pool", "table"], "os": ["ls", "cs", "oos", "OS", "css", "is", "us", "oses", "ts", "out", "ds", "fs", "oids", "ys", "oes", "los", "ols", "cos", "oss", "pos", "oS", "Os", "bos", "ops", "oso", "osi", "bs", "ose", "io", "sys", "uts", "js", "ios", "ox", "ps", "aos", "o", "ot", "ms", "obs"], "stamper": ["read", " stumpler", "stAmPER", " stamter", "The", "stumpler", " stcamper", " stcammer", " stramper", " stcamter", " stimter", "stimPER", "_", "stramper", "stamPER", " stimmer", " stimper", "stampler", "stummer", "stammer", " stramPER", "println", " strampler", "annot", " stampler", "font", "this", "strampler", "def", "good", " strammer", " stcampler", "stimmer", " stammer", "stAmpler", "valid", "stimpler", "strammer", "stamter", " stamPER", "New", "Print", " stumper", " stimpler", "stumter", " stumter", "stAmmer", "stimper", "stramPER", "stumper", " stummer", "stAmper", "important"], "appearance": ["displayeared", " appearances", "Appearances", "apearances", "accearance", "appearances", "Appeared", "appearing", "displayearing", "atteared", "suppearance", "attlies", "attearances", "displayearances", "displayreciation", "apreciation", "ascearing", "aplies", "Applies", "apeared", "ascearances", "ascearance", "patternendix", "acearances", "aceared", " appeared", "acreciation", "acearance", "patternearance", "suppearances", "displaylies", "suppeared", "apears", "displayears", " appendix", " appearing", "appreciation", "appears", "appendix", "displayendix", "patternearances", "accearances", "applies", "apearing", "Appearance", "attearance", "acclies", "apearance", "displayearance", "ascears", "appeared", "accears", "patternearing"]}}
{"id1": "3053403", "id2": "6457199", "code1": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 1, "substitutes": {"fc": ["cs", "full", "tc", "f", "func", "fps", "aft", "bf", "fd", "pc", "mac", "rc", " dc", "dc", "inc", "unc", "util", "nc", "fab", "con", "fm", "co", "fa", "raf", "pic", "fr", "sc", "fs", "win", "cond", "fl", "xc", " con", "c", "ic", "coll", "ric", "act", "imp", "conv", "ec", "frac", "RFC", "anc", "irc", "dl", "ctx", "lc", "fp", "football", "ocl", "ff", "cas", "mc", "df", "acl", "hl", "cv", "gc", "wic", "console", "exp", "owl", "vc", "iac", "cf", "FC", "tf", "bc", "isc", "cl", "fn", "ac", "icc", "cm", "soc", "form", "uc", "fb", "disc", "las", "abc"], "buff": ["b", "tm", "aux", "th", "supp", "pp", "fred", "f", "func", "bf", "inf", "kw", "cell", "hd", "bg", "batch", "tab", "cho", "bb", "emb", "np", "font", "fr", "obj", "beck", "interest", "src", "ph", "note", "tt", "xff", "grow", "bind", "zz", "urg", "nt", "utf", "cond", "bis", "rb", "fl", "obb", "fo", "cb", "proc", "qq", "txt", "comp", "act", "fw", "alph", "xy", "ref", "hex", "mb", "vt", "td", " Buff", "att", "important", "alf", "nd", "ctx", "uf", "tmp", "ust", "boost", "bo", "bj", "printf", "html", "ff", "butt", "def", "off", "resp", "rend", "ind", "exp", "dat", "ld", "buffer", "orm", "pb", "hz", "prof", "gold", "pred", "alg", "tf", "norm", "back", "bin", "Buffer", "FF", "h", "cmd", "bound", " buffs", "lf", "ott", "form", "pdf", "sb", "Buff", "buf", "fb", "hold", "mem", "bed", "gz", "ob", "uff"], "encoding": ["enending", "escapending", "convoding", " enccode", "enoding", "encoded", " encryption", "encoder", "deccode", "encending", "coder", "encaching", "continoding", "enoder", "encode", "coded", "decoder", "continaching", " encusing", "encusing", "continryption", "enryption", "cending", "decryption", "convryption", "enoded", "enccode", "decoding", "encryption", "escapoding", "continusing", "convaching", "convusing", " encoder", " encaching", "escapoder", "coding", "escapoded"]}}
{"id1": "13644375", "id2": "732800", "code1": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"get": ["put", "read", "pull", "check", "gets", "http", "parse", "draw", "update", "query", "download", "open", "find", "select", "search", "give", "request", "Get", "current", "pre", "debug", "head", "exec", "send", "load", "run", "method", "command", "ge", "json", "set", "body", "show", "post", "see", "delete", "build", "GET", "resource", "print", "got", "create", "execute", "play", "like", "service", "we", "call"], "url": ["ls", "path", "dl", "full", "http", "URL", "parse", "id", "api", "address", "l", "ur", "link", "string", "str", "web", "html", "nl", "loc", "domain", "page", "host", "uri", "pattern", "rl", "href", "ref", "ret", "build", "Url", "pl", "server", "location", "base", "name", "ll", "mount", "sl"], "response": ["reply", "message", "block", "http", "all", "application", "open", "output", "request", "trace", "pos", "client", "answer", "onse", "entry", "image", "next", "page", "given", "still", "object", "successful", "resp", "tree", "document", "result", "json", "soc", "respond", "body", "post", "re", "connection", "resource", "content", "yes", "res", "Response", "data", "status", "service", "respons"], "entity": ["obj", "put", "person", "user", "group", "ce", "note", "component", "type", "info", "iso", "instance", "any", "session", "encrypted", "complex", "and", "load", "record", "client", "Entity", "entry", "email", "peer", "image", "one", "le", "ent", "object", "pe", "unit", "eme", "document", "el", "result", "unique", "json", "body", "ity", "form", "em", "e", "remote", "line", "me", "event", "resource", "content", "total", "model", "security", "base", "data", "comment", "channel", "member", "ee", "activity"]}}
{"id1": "1421557", "id2": "4118412", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeStringToFile", "encodeFileToFiles", "encodeStringAsDisk", "encodeFileFromStream", "encodeFileFromDisk", "encodeStringAsFile", "encodeFileAsFiles", "encodeFiletoFile", "encodeFiletoFiles", "encodeStringToStream", "encodeFileAsFile", "encodeFileAsDisk", "encodeFileAsStream", "encodeFileFromFile", "encodeStringAsStream", "encodeStringToDisk", "encodeFiletoDisk", "encodeFiletoStream", "encodeStringToFiles", "encodeFileToStream", "encodeStringAsFiles", "encodeFileToDisk"], "infile": ["InFile", "inputfile", "outbase", "inbase", " inFile", "inFile", "outpath", "Inbase", "outFile", "Inpath", " infilename", "Infile", "outfilename", "infilename", "inpath", "inputpath", "inputfilename", "inputFile", " inpath", " inbase"], "outfile": ["inname", "newfile", " outname", "newname", "newfilename", "newFile", "inFile", "tofile", "todir", "fromfp", " outfilename", "infp", "outFile", "fromfile", "outdir", "indir", "fromdir", "tofp", "toFile", "outfp", " outFile", "outfilename", "infilename", "fromFile", "outname"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "image", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ro", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "null", "fn", "os", "en", "cn", "to", "flush", "up", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "can", "aos", "o", "res", "outer", "inner", "ot"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "queue", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "length", "black", "stack", "temp", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", "commit", "ccess", "cess", "value", "accept", "fail", "growth", "warning", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "ith", "successful", "good", "please", "ceed", "town", "result", "valid", " Success", "successfully", " okay", " failure", "ratulations", "photo", "sufficient", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "1156851", "id2": "6260216", "code1": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public InputStream send(String s, String s1) throws IOException {\n        HttpURLConnection httpurlconnection = null;\n        DataInputStream datainputstream = null;\n        System.setProperty(\"java.protocol.handler.pkgs\", \"com.sun.net.ssl.internal.www.protocol\");\n        URL url = new URL(s1);\n        httpurlconnection = (HttpURLConnection) url.openConnection();\n        configureURLConnection(httpurlconnection);\n        DataOutputStream dataoutputstream = new DataOutputStream(httpurlconnection.getOutputStream());\n        dataoutputstream.write(s.getBytes());\n        httpurlconnection.connect();\n        datainputstream = new DataInputStream(httpurlconnection.getInputStream());\n        if (httpurlconnection.getResponseCode() != 200) {\n            System.out.println(\"Invalid Response Code! Code Returned = \" + Integer.toString(httpurlconnection.getResponseCode()));\n            return null;\n        }\n        if (!httpurlconnection.getContentType().equalsIgnoreCase(\"Text/xml\")) {\n            System.out.println(\"Invalid Content-Type! Content type of response received = \" + httpurlconnection.getContentType());\n            return null;\n        } else {\n            return datainputstream;\n        }\n    }\n", "label": 0, "substitutes": {"runWeb": ["processSite", "initHttp", " runSite", "initWeb", "initSite", " runHttp", "processHttp", "initweb", "processweb", "processWeb", " runweb", "runweb", "runSite", "runHttp"], "beginURL": ["useURI", "useUrl", "beginHTML", "endUrl", "useHTML", "BeginURI", "beginUrl", "endURL", "wardURL", "startALL", "startLocation", "createUrl", "BeginHTML", " beginALL", "endUR", "createHTML", "wardUR", "createURI", "beginURI", "BeginURL", " beginURI", "beginALL", "BeginLocation", "BeginUrl", "startURL", "createURL", " beginLocation", "BeginUR", "useURL", "startURI", "beginLocation", "beginUR", "BeginALL", "wardUrl"], "contextRoot": ["ctxHome", "contextPath", "resourceData", "resourcePath", "contextBase", " contextData", "ctxParent", "contextHome", "ctxBase", "ContextRoot", "ContextBase", " contextBase", " contextParent", "contextParent", "ContextURL", " contextPath", " contextBox", "contextData", "ctxBox", "contextURL", "ContextData", "ContextBox", "resourceRoot", "ctxRoot", "resourceURL", "contextroot", "ContextHome", "contextBox", "Contextroot", "resourceBase", "resourceroot", " contextURL", " contextHome", "ctxPath", " contextroot", "ContextPath", "ContextParent"], "pageURI": ["pURL", "PageUR", "requestURI", "Pageuri", "requestFile", "pURI", "puri", " pagePath", "PageURL", "PageName", "PageFile", " pageuri", "PagePath", "pageName", "pName", "pagePath", "pageURL", " pageURL", "pageuri", " pageName", "requestPath", "requestUR", " pageFile", "PageURI", "pageFile", "pageUR", " pageUR"], "vtURLs": ["vturlls", "vtULs", "vtOLls", "voltTLls", "vtURLS", "vtURls", "VTURers", "vtURLses", "vtSRList", "vtTLls", "vtURa", "voltTLList", "vturla", "vtSRs", "VTURs", "voltURLs", "VTURLa", "vtHTTPS", "vtURLa", "VTURLS", "vtURs", "vtOLses", "voltURLList", "voltURLls", "vtTLList", "vtHTTPa", "vtURLls", "VTURS", "vtGETses", "VTURses", "vtULls", "VTURls", "vtGETers", "voltTLs", "VTURLs", "vtGETls", "vtURS", "vtHTTPls", "VTURa", "vtSRls", "vturls", "vtTLs", "vtGETs", "vtOLers", "vtURList", "vtURses", "vturlS", "vtULS", "VTURLers", "vtURLList", "vtHTTPs", "VTURLls", "vtURLers", "vtURers", "VTURLses", "vtOLs"], "vtRobots": ["vtPlugbs", "vtRobotos", "vsRobugs", "virtReplots", "vtLegows", "vtTabops", "vetRubotos", "vetRobotos", "vtUbbs", "vtUbotos", "vetRubots", "vtRoborts", "vtUbots", "virtReplops", "vsHubotos", "vetRobows", "vtRobugs", "vtReplots", "vtTaborts", "vtReplorts", "vtHubugs", "vtLegot", "vtUbugs", "virtRobots", "vtRubot", "vtTaboles", "vtPlugugs", "vetRobot", "vtRobows", "virtRoborts", "vtHuboles", "vtHubops", "vetRobots", "vetRubows", "vsRobots", "vtLegotos", "vtRoboles", "vtRobot", "vtPlugots", "virtReplorts", "vsRobbs", "vtReploles", "vetRubot", "vtCapot", "vtTabots", "vsHubots", "vtPlugotos", "vtRubotos", "vtRobops", "vtHuborts", "virtReploles", "vtRubows", "vtHubbs", "vtRubots", "vtRobbs", "virtRoboles", "vsHubugs", "vtCapots", "vtCapows", "vsRobotos", "vtCapotos", "vtHubotos", "vtReplops", "vtHubots", "vsHubbs", "vtLegots", "virtRobops"], "indexer": ["indexor", "Indexer", "mixator", "IndexReader", "Indexe", " indexe", " indexReader", "documentReader", "mixer", "searchor", "Indexator", " indexener", "documenter", "Indexener", "searchner", "documente", "mixor", "indexator", "mixner", "indexner", "indexener", "documentener", "searcher", "Indexor", "Indexner", "indexReader", "searchator", "indexe"], "indexDoc": [" IndexDoc", "indexdoc", "IndexDoc", " IndexDocument", " indexPage", "indexDocument", " indexDocument", "IndexPage", "indexPage", "IndexDocument", " indexdoc", "Indexdoc", " IndexPage", " Indexdoc"], "sxURL": ["sfxBL", "sxsURL", " sfxUR", "desXUrl", " sXURL", "SxID", "sxyUR", " sxeUrl", "sxBL", "desxURL", "sxeURL", "sXURL", "sxfALL", " sxIL", "sXUSER", " sfxURL", "sXUR", "SxeBL", "sixURL", "sxsUSER", "sfxUSER", "sxxUrl", "desXURL", "sxeIL", "sxIL", "SXUrl", " sXUR", "sfxURI", "sxURI", "sxyURL", "sxeUR", " sxeUR", "sxxALL", "SxeURL", " sxELF", "sfxEL", "spxURL", "sixBL", "sxeURI", "spxELF", "SxeID", "spxUR", "sxEL", "sxePORT", "sfxIL", "SXUR", "SxeURI", "sxxUR", "sxyPORT", "spxUrl", "sXEL", " sfxELF", "SXURI", "desxUrl", "sxfUR", "sxUSER", "sXUrl", " sxUR", "sxPORT", "sxfURI", "sfxUR", "sxeBL", "sxeID", "sXALL", "sxALL", "sfxELF", "sxID", "SxURL", "sfxID", "SxUR", "sxfUrl", "SxURI", "desxUR", "SxUrl", "SxBL", " sxEL", " sfxUrl", "desXUR", "sxsUrl", "sxfURL", "sxxIL", "sXELF", " sXUrl", "sxsUR", "sXURI", "sixURI", "sixID", "sfxPORT", " sxeURL", "sxUrl", "sxELF", "sfxUrl", "desXALL", "sxUR", "sxxURL", "desxALL", " sxeIL", "SXURL", " sXEL", " sxUrl", "sxeUrl", "sxyUrl", "sxfEL", "sfxURL"], "sxRobotURL": ["sxRoboPATH", "sxRoboURI", "sxRobrotUR", "sxRoboteSTR", "sxroboteURL", "sxRobotSTR", "sxLegotPATH", "sxRobotPATH", "sxroboteURI", "sxNobosURL", "sxLegotSTR", "sxNobosSP", "sxRobotePATH", "sxRoboySP", "sxRobOTURI", "sxRoboteUR", "sxLegoteUR", "sxLegotURL", "sxRobosUR", "sxRobotHTTP", "sxRoboUR", "sxLegoteSTR", "sxNobotSP", "sxLegoURL", "sxNobosUrl", "sxLegotUR", "sxroboteUR", "sxRobotSP", "sxrobotURL", "sxRoboteURL", "sxRobOTURL", "sxrobotURI", "sxRobrotUrl", "sxRobosSTR", "sxRobotUR", "sxNobotUrl", "sxRobotUrl", "sxRobottSP", "sxRoboteUrl", "sxRobottUrl", "sxRobotURI", "sxRobOTUR", "sxRoboteURI", "sxRobottHTTP", "sxRoboSTR", "sxNobotURL", "sxRobosURL", "sxRoboUrl", "sxNobotHTTP", "sxRoboyHTTP", "sxRobOTUrl", "sxRobosUrl", "sxRoboURL", "sxLegoUR", "sxLegotUrl", "sxLegoUrl", "sxrobotUR", "sxRobosSP", "sxRobottURL", "sxRobrotPATH", "sxrobotUrl", "sxNobosHTTP", "sxRoboyURL", "sxLegoteUrl", "sxroboteUrl", "sxRoboyUrl", "sxLegoteURL", "sxRobosHTTP", "sxLegoPATH", "sxRobrotURL"], "pd": [" prod", "cd", "dl", "ht", "pp", " PD", "wp", "dh", "tp", "dp", " md", "ds", "PD", "pm", "fd", "bf", "PF", "parser", "rpm", "hd", " dd", "df", "p", "cp", "Parser", "dd", "dt", "xd", "po", "bd", "pps", "td", "d", " cd", "pard", "lp", "px", "pl", "vd", "pg", "pb"], "cb": ["cd", "cgi", "abb", "tc", "bp", "gb", "bf", "bc", "rb", "obb", "cc", "proc", "dc", "erb", "lb", "cv", "cp", "cn", "cor", "cr", "sb", "CB", "eb", "nb", "ctrl", "bb", "wb", "Callback", "fb", "xb", "bt", "cf", "kb", "ck", " CB", "callback", "pb"], "bIndexPage": [" bIndexUrl", " bLinkFile", "bAddFile", "bAddpage", "bAddDocument", " bLinkpage", "bIndexUrl", "bIndexPath", "bLinkFile", " bIndexPath", "boolCheckpage", " bLinkDocument", "bSearchPage", " bIndexFile", "blFoundPage", " bIndexDocument", "bCheckPage", "bIndexSite", "boolIndexPages", " bLinkPage", "blFoundFile", "boolCheckPage", "bAddPages", "boolCheckSite", "boolCheckPages", "bFoundPage", "bAddSite", "blIndexFile", "bLabelPage", "bProcessFile", "bCheckpage", "bIndexDocument", "bAddPage", "bIndexFile", "bFoundFile", "bLabelpage", "bindexFile", " bLinkPath", "bLinkDocument", "bIndexPages", "blFoundLine", "bFoundLine", "bCheckSite", "bProcessPage", " bLinkUrl", "bIndexLine", "bFindPath", "boolIndexPage", "bFoundpage", "bLinkPage", "bProcessLine", "bSearchpage", "bFindPage", "bIndexpage", "bConnectpage", "bLinkPath", "bSearchFile", "bSearchDocument", "bFindpage", "bLabelUrl", "bLinkUrl", "bLinkPages", "bCheckPages", "bLabelPath", "bindexPage", "bindexLine", "blIndexPage", "blIndexLine", "boolIndexpage", "bLinkpage", "bLinkSite", "boolIndexSite", "bFindUrl", " bIndexpage", "bConnectFile", "bConnectPage"], "urlConn": [" urlconn", "urlWin", "bbConnect", "URLConn", "webCo", "nlConn", "databaseConn", "nlConnector", "httpCh", "fileCt", "UrlConn", " urlConnect", "databaseCon", "webCons", "URLCon", " urlCons", "urlconn", "fileCon", "bbCh", "UrlCo", "httpConnector", " urlConnector", "webConnect", "urlCh", "URLCt", " urlCh", "urlCon", "urlCt", "urlConnector", "databaseconn", "URLconn", "urlCo", "urlConnect", "fileconn", "fileConn", "nlWin", "webConn", "bbConn", "bbconn", "UrlCons", "httpConn", "databaseCt", "urlCons", "UrlConnect", " urlWin", "httpconn", " urlCo", "httpWin", "httpConnect", "nlConnect"], "modDate": [" modTime", "modTime", "mtTime", "modifiedGe", "modifiedDay", " modGe", "mtGe", "modifiedTime", "mtDate", "modGe", "modifiedDate", "mtDay", " modDay", "modDay"], "bfReader": ["bfWriter", "bfParser", "fbWriter", "bbRead", "btWriter", "bbParser", "btRead", "btReader", "fbReader", "bfRead", "bbReader", "bbWriter", "btParser", "fbRead", "fbParser"]}}
{"id1": "21181542", "id2": "1141361", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 1, "substitutes": {"deleteRoleType": ["deleteResourceType", "deleteGroupTyp", "deleteResourceTyp", "deleteRoleTypes", "deleteResourceTypes", "deleteGroupType", "DeleteRoleTyp", "DeleteRoleType", "deleteRoleTyp", "deleteGroupTypes", "DeleteRoleTypes"], "id": ["path", "is", "mid", "aid", "Id", " pid", "iden", "it", "type", "url", "info", "ID", "ion", "instance", "and", "kid", "t", "add", "l", "link", "x", "key", "pid", " tid", "val", "end", "orig", "sid", "p", "oid", "created", "h", "def", "rid", "in", "bid", "part", "uid", "vid", "show", "ref", "edit", "ident", "no", "only", "i", "event", "hide", "d", "ide", "create", "hash", "name", "ids", "like", "node", "time", "index"], "namespaceId": ["namespaceOr", "typesACEId", "workshipID", "workspaceName", "typespaceAnd", "namespaceRef", "namespointId", " namesenceBirth", "namespointName", "namespaceAnd", "namespointid", "namesistenceOr", "namesaceID", "worksetAnd", "namesaceid", "namespacesId", "namespacesid", "namespaceLog", "nameshipID", "namesenceOr", "namesenceBirth", "typespaceId", "namesenceId", "nameshipKey", "namespacesBirth", "namespointRef", "namespaceKey", "workspaceID", "namesetId", "namesspaceid", "nameshipid", "worksetid", "namespaceid", "namesistenceIdent", "namesiteOr", "namesplaceRef", "namespacesID", "workspaceid", "worksplaceRef", "workspaceAnd", "namesistenceId", "namesplaceid", "worksplaceid", "namesiteIdent", "namesiteId", "namesspaceAnd", "namesenceID", "namespaceName", "namesistenceLog", " namespaceOr", " namesiteIdent", "namesaceKey", "namesspaceID", "namespacesKey", "namesositoryID", "typesACEID", " namesiteLog", "workshipid", "worksplaceId", "namesadeAnd", "worksetID", "workspaceId", "workshipKey", "namesositoryBirth", "nameshipId", "namespaceBirth", "namesACEID", "worksplaceName", "namespacesRef", "namespaceID", "namesplaceId", "namespointID", "workspaceRef", " namespaceID", "namesACEId", "workshipId", "namespaceIdent", "namespacesAnd", "namespacesName", "namespointAnd", "namesaceId", " namespaceBirth", "namesetid", "worksetId", " namesenceID", " namesiteId", "namesiteLog", "workspaceKey", "typespaceID", "namesetAnd", "namesetID", " namespaceLog", "namesenceLog", "namesplaceName", "namesadeID", " namespaceIdent", " namesenceId", " namesiteOr", "namesspaceId", "namesadeId", "namesACEAnd", "typesACEAnd", "namesenceIdent", "namesositoryId"], "removeReferencesInRoleTypes": ["removeReferencesInRuleTypes", "removeReferencesInRightNames", "removeReferencesFromMultipleTypes", "removeReferencesInMultipleType", "removeReferencesFromRoleFiles", "removeReferencesInRoleFiles", "removeReferencesInRightType", "removeReferencesFromMultipleType", "removeReferencesInRoleType", "removeReferencesFromMultipleFiles", "removeReferencesInRightTypes", "removeReferencesInroleFiles", "removeReferencesFromRoleType", "removeReferencesInroleType", "removeReferencesInRightFiles", "removeReferencesFromroleFiles", "removeReferencesInMultipleTypes", "removeReferencesFromRoleTypes", "removeReferencesInroleNames", "removeReferencesInRuleNames", "removeReferencesFromMultipleNames", "removeReferencesFromRoleNames", "removeReferencesInRoleNames", "removeReferencesFromroleType", "removeReferencesFromroleNames", "removeReferencesInRuleType", "removeReferencesFromroleTypes", "removeReferencesInroleTypes", "removeReferencesInRuleFiles", "removeReferencesInMultipleFiles", "removeReferencesInMultipleNames"], "permit": ["PERmitted", "Permitted", "Permiss", "permitted", "promitted", "permission", "PERmit", "proMIT", "promit", "PERMIT", " permitted", "Permission", " perMIT", "PerMIT", " permiss", "PERmiss", "PERmission", "Permit", "perMIT", "promission", "permiss"], "exist": ["alias", "remember", "there", "existence", "register", "find", "write", "save", "filename", "present", "login", "list", "know", "current", "mark", "use", "ist", "add", "same", "purpose", "include", "existent", "ext", "missing", "have", "icate", "existing", "attach", "require", "define", "respond", "see", "establish", "meet", "keep", " extant", "cont", "create", "connect", "status", "ready"], "msgBuf": ["msgBlim", "messageRbuff", " msgRuf", " msgRbuff", "messageMuff", "msgBeuf", "msgBfg", "msgPuff", "msgBsuf", "msgPbuf", "msgBsbuf", " msgMbuf", "messageRuf", "msgGlim", "msgRuff", "messageMbuf", "msgAuff", "msgBsuff", " msgMuf", "msgCfg", " msgMuff", "messagePbuf", " msgBbuf", "msgRbuff", "msgRbuf", "msgRlf", " msgBuff", "msgBebuf", "msgMuf", "msgMbuff", "msgCuf", "messageBbuf", "messageBlf", " msgCfg", "msgBuff", " msgBbuff", "msgVbuf", " msgCuf", "messageRlf", "msgRuf", "msgAbuf", "msgBsfg", "msgPuf", "msgAuf", "messageBuff", "messageRuff", "messagePuf", " msgRlim", " msgCuff", "msgVbuff", "msgGbuff", "msgCbuff", "msgBbuff", "msgPlf", " msgRbuf", "messageBuf", "msgMuff", "msgMbuf", "msgPfg", "msgGuf", " msgMbuff", "msgBefg", "messageBfg", "messageRbuf", "messagePuff", " msgBlim", "msgRlim", "messagePfg", "msgGbuf", "messageMbuff", "msgBbuf", "msgCuff", "msgBlf", "msgVuff", " msgCbuf", "msgCbuf", "messageBbuff", "msgAbuff", "messageMuf", "msgRfg", " msgBfg", "msgPbuff", "msgVuf", "msgBeuff"], "objects": ["models", "headers", "faces", "files", "points", "links", "authors", "docs", "books", "keys", "builders", "oids", "packages", "products", "versions", "articles", "parts", "apps", "jobs", "projects", "resources", "plugins", "flows", "bits", "tools", "locks", "beans", "classes", "frames", "organisms", "airs", "images", "ports", "uploads", "codes", "units", "relations", "lines", "ors", "errors", "assets", "items", "artifacts", "workers", "ids", "obs", "values", "pages", "blocks"], "sqlRightId": ["sqlrightName", "sqlrightId", " sqlrightId", "qlRightid", "qlRightId", "sqlRightid", "sqlLeftId", "sqlRightName", "qlrightid", "sqlHeadid", "qlrightId", " sqlrightRef", " sqlrightById", " sqlrightid", "sqlRightRef", "sqlLeftName", "qlrightName", "sqlHeadById", "sqlrightid", "sqlrightById", "sqlLeftid", " sqlRightid", "sqlHeadRef", "sqlHeadId", " sqlRightById", "qlRightName", "sqlrightRef", "sqlRightById", " sqlRightRef"], "sqlParent": ["invparent", "sprChild", "sysParent", "sysChild", "sqlChild", "sqlparent", "sysparent", "sysOwner", "invChild", "sqlOwner", "sprparent", "invParent", "sprParent", "invOwner", "sprOwner"], "sql": ["dl", "template", "description", "session", "ql", "md", "params", "term", "acl", "action", "cmd", "password", "sys", "SQL", "command", "spec", "json", "body", "statement", "drop", "orm", "security", "execute", "data", "comment", "db", "diff", "cfg"], "pstmt": ["wpastmk", "pctms", "pstmk", "pstartng", "pstatmm", "pstMT", "NEW", "pthmt", " pstms", "NULL", "Pstmt", "pstatStatement", "pstatem", "PstStatement", "pastmk", "pondm", "wpastm", "pthem", " pstatmt", "pstartm", "pthmp", "pndmk", "pndmt", "pstartr", "pstms", "pastm", "Exception", "wpstMT", "pStng", "pStm", "context", " pstem", "nt", "pstr", "PStm", "Pstmm", "pastMT", "pstmp", "pstatm", "postmk", "pndm", "insert", "postmt", "pStr", "pstem", "pctem", "wpstm", "Pstm", "pndMT", "pondStatement", "Pstr", "Pstatm", "PstatStatement", "PStng", "pctmt", "def", "Pstatmm", "pstm", " pstatms", "pastStatement", "pondmm", "wpastmt", "Delete", "pstng", "pstStatement", "wpstmt", "wpstmk", "pondmt", "_", "pastmm", " pstatem", "postm", "postMT", " pstmp", "Pstng", "tx", "pastmt", "pstatmp", "pStmt", "pstartmt", "pstmm", "pstatms", "pstatmt", "PStr", "pthms", "create", "pctmp", "Pstatmt", " pstatmp", "wpastMT", "PStmt"], "typeGid": ["typeRegID", "typeGuids", " typeCid", "TypeCid", " typeCids", "typeGenids", "typeRegid", "typeRegId", "typeGId", " typeGno", "TypeGID", "typeCID", "typeCno", "typeGno", "TypeCId", "typeGuID", "TypeCID", "typeGuid", " typeGids", " typeCno", "typeCId", "typeGids", "typeCids", "typeGuId", "typeGuno", "typeGenno", "typeGenid", "typeGID", "typeCid", "TypeGId", "TypeGid"], "defaultLevel": [" defaultDepth", "errorLevel", "DefaultLevel", "DefaultDepth", "errorDepth", "errorMode", "defaultDepth", " defaultlevel", "Defaultlevel", "defaultMode", " defaultMode", "DefaultMode", "errorlevel", "defaultlevel"], "success": [" succeed", "accept", "fail", "pass", "progress", "save", "warn", "info", "Success", "ok", "error", "first", "unknown", "rc", "summary", "submit", "continue", "primary", "close", "successful", "good", "result", "state", "successfully", "failed", "undo", "status"]}}
{"id1": "6908537", "id2": "20851065", "code1": "    public String login() {\n        System.out.println(\"Logging in to LOLA\");\n        try {\n            String data = URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_email(), \"UTF-8\");\n            data += \"&\" + URLEncoder.encode(\"pw\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_pw(), \"UTF-8\");\n            URL url = new URL(URL_LOLA + FILE_LOGIN);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line, sessid;\n            line = rd.readLine();\n            sessid = get_sessid(line);\n            this.set_session(sessid);\n            wr.close();\n            rd.close();\n            return sessid;\n        } catch (Exception e) {\n            System.out.println(\"Login Error\");\n            return \"\";\n        }\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"login": ["setup", "user", "auth", "register", " Login", "update", "write", "download", "open", "save", "session", "config", "request", "submit", "close", "in", "layout", "username", "password", "console", "Login", "dial", "log", "account", "connection", "connect", "hello"], "data": ["ment", "message", "dl", "value", "format", " DATA", "out", "input", "id", "info", "api", "red", "output", "error", "session", "join", "debug", "done", "string", "str", "feed", "success", "test", "html", "key", "window", "reason", "next", "this", "p", "action", "def", "password", "default", "part", "command", "result", "div", "json", "text", "DATA", "body", "post", "dat", "no", "ata", "connection", "content", "d", "response", "rel", "name", "db", "reset"], "url": ["ls", "dl", "cert", "net", "http", "URL", "r", "open", "pkg", "abs", "l", "ur", "gl", "str", "link", "web", "nl", "loc", "hl", "lb", "uri", "gc", "il", "xml", "www", "el", "conv", "ret", "ld", "mail", "Url", "re", "build", "log", "get", "ssl", "ul", "bel", "atl", "rel", "ll", "pl", "sl", "call"], "conn": ["ls", "obj", "inv", "Conn", "net", "cert", "yn", "open", "comm", "win", "nt", "pkg", "exec", "ann", "cb", "nl", "c", "fin", "loc", "n", "close", "cp", "nec", "cn", "ct", "cmd", "resp", "addr", "canon", "act", "pas", "nc", "socket", "ch", "conv", "dat", "enc", "ctrl", "con", "jp", "connection", "cont", "co", "nw", "syn", "res", "cur", "rel", "connect", "ll", "ns", "call"], "wr": ["dr", "wy", "spr", "wrote", "vr", "lr", "tw", "wid", "write", "r", "wn", "wm", "ln", "wa", "wer", "pr", "wx", "nl", "tn", "rew", "kr", "rw", "writ", "hw", "WR", "fw", "iw", "vet", "w", "wt", "writer", "kl", "mn", "RW", "wb", "nw", "sw", "mr", "wk", "wo", "hr", "fr"], "rd": ["nder", "nd", "rob", "rer", "dr", "erd", "ptr", "rog", "ro", "lr", "r", "red", "rx", "sr", "rc", "rt", "rb", "RD", "rad", "ri", "rar", "rs", "rw", "ris", "rn", "dd", "rid", "rl", "rend", "cr", "rr", "rod", "ld", "ird", "rh", "rex", "ra", "rand", "mr", "ry", "hr", "fr"], "line": ["LINE", "block", "iter", "liner", "header", "ste", "out", "id", "lo", "ln", "file", "inline", "l", "ine", "se", "ode", "eline", "link", "cell", "frame", "string", "str", "lin", "entry", "nl", "word", "row", "page", "le", "pe", "Line", "len", "char", "ne", "part", "el", "lf", "text", "e", "log", "no", "chain", "buffer", "code", "ide", "column", "comment", "stay", "fr"], "sessid": ["seessinfo", "Sessionname", "ssessionoid", "secessinfo", "descessid", " sesskey", " ssessioninfo", "Sessname", "secessid", " sessname", "sESSname", "seessoid", "sessionuid", "Sessionkey", "sessinfo", "ssessionuid", "Sessuid", "ssessioninfo", "sessname", "scessinfo", "sessoid", "seessname", "ssessionname", "desesskey", "ssessionid", "sessionkey", "descesskey", " ssessionname", "sessionid", "sESSuid", "scessoid", "sESSoid", "Sessid", "secessoid", "sessionoid", "sessuid", "descessuid", "scesskey", "desessuid", "scessname", "Sessionuid", "desessoid", " ssessionid", "scessid", "sessionname", "Sessionid", " sessinfo", "descessoid", "seessid", "scessuid", "ssessionkey", "desessid", "sESSid", "sessioninfo", "secessname", "Sesskey", "sESSkey", " ssessionkey", "sesskey"]}}
{"id1": "14473781", "id2": "8953394", "code1": "        @Override\n        protected String doInBackground(Void... params) {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpContext localContext = new BasicHttpContext();\n            HttpPost httpPost = new HttpPost(urlFormated);\n            try {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for (int index = 0; index < POSTparamList.size(); index++) {\n                    if (POSTparamList.get(index).getName().equalsIgnoreCase(\"image\")) {\n                        entity.addPart(POSTparamList.get(index).getName(), new FileBody(new File(POSTparamList.get(index).getValue())));\n                    } else {\n                        entity.addPart(POSTparamList.get(index).getName(), new StringBody(POSTparamList.get(index).getValue()));\n                    }\n                }\n                httpPost.setEntity(entity);\n                HttpResponse response = httpClient.execute(httpPost, localContext);\n                return processAnswer(response);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doInsideBackground", " doOnAsync", "doAsFuture", " doAsFuture", "doAsRequest", " doInRequest", " doAsAsync", "doAsAsync", " doAsBackground", " doInsideAsync", "doInAsync", "doInRequest", " doOnRequest", " doInAsync", " doInsideRequest", " doOnBackground", " doOnFuture", "doInFuture", " doAsRequest", " doInFuture", "doAsBackground", " doInsideFuture"], "params": ["ams", "files", "ctx", "conf", "vals", "Parameters", "tags", "sql", "options", "param", "list", "config", "properties", "parts", "proc", "cas", "details", "services", "settings", "Param", "images", "posts", "ps", "errors", "data", "terms", "values"], "httpClient": ["httpControl", "ttpClient", "hoverControl", "httpsclient", "httpsClient", "ttpConnection", "htmlClient", "htmlControl", "httpSystem", "httpsSystem", "httpsContext", "httpclient", "httpContext", " httpConnection", "hoverSystem", " httpSystem", "httpConnection", "hoverClient", "hoverContext", "htmlSystem", " httpclient", "httpsControl", "ttpSystem", "httpsConnection", "htmlContext", "ttpclient"], "localContext": ["currentContext", "localPort", "sessionCase", " localPort", "localCondition", "LocalPort", "LocalState", "localCase", " localState", "privatecontext", "Localcontext", "localcontext", "sessionState", "currentCondition", "privateContext", " localCondition", "localState", " localcontext", "privatePort", "sessionContext", "currentState", " localCase", "sessionCondition", "LocalContext", "privateState", "currentCase"], "httpPost": ["httpsPOST", "hoverPOST", "HttpPut", "ttpPut", "hoverpost", "ttpPOST", "httpsPre", "HttpPre", "workPut", "HttpPOST", "workPost", "httpPre", "httpPut", "httpPOST", "httpsPost", " httpPOST", " httpPut", "ttppost", "workPOST", "hoverPost", "ttpPre", "workPre", " httppost", " httpPre", "ttpPost", "httpsPut", "HttpPost", "httppost"], "entity": ["person", "put", "ment", "group", "ce", "empty", "template", "collection", "net", "note", "needed", "or", "secure", "component", "output", "translation", "oe", "encrypted", "complex", "and", "Entity", "email", "entry", "rule", "image", "quote", "one", "details", "ent", "object", "created", "ell", "pe", "unit", "eme", "xml", "document", "iam", "el", "result", "command", "unique", "policy", "body", "line", "orm", "event", "metadata", "intent", "total", "internal", "security", "create", "auto", "base", "data", "comment", "channel", "member", "local", "table", "activity"], "index": ["EX", "offset", "draw", "find", "search", "update", "add", "ix", "size", "zero", "image", "loc", "inc", "osit", "set", "ox", "get", "condition", "i", "max", "name", "connect", "each", "ex", "note", "all", "open", "context", "select", "lex", "IND", "success", "x", "key", "row", "axis", "num", "coll", "ax", "ask", "scale", "state", "eight", "see", "insert", "shape", "active", "date", "point", "iter", "check", "empty", "stick", "error", "instance", "unknown", "config", "request", "pos", "Index", "major", "layout", "version", "loop", "initial", "ind", "sequence", "length", "exp", "access", "column", "mount", "match", "display", "number", "mix", "address", "author", "sync", "go", "scroll", "document", "height", "slice", "position", "capacity", "seek", "create", "prefix"], "response": ["reply", "message", "value", "application", "api", "context", "output", "request", "zone", "frame", "pos", "answer", "entry", "onse", "image", "results", "still", "page", "object", "resp", "social", "tree", "xml", "document", "result", "json", "sequence", "respond", "body", "view", "e", "connection", "content", "res", "Response", "data", "hello", "service", "respons"]}}
{"id1": "838844", "id2": "5035872", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"convert": ["CONversion", "unvert", "consVERT", "ConVERT", "compvert", "Converts", "compprocess", "Converting", "consversion", "unfer", "Conprocess", "unprocess", "unverts", "CONvert", "conversion", "CONverting", "unverted", "confer", "CONfer", "Confer", "conVERT", "compverts", "Convert", "CONVERT", "CONverted", "consvert", "converts", "consverting", "converting", "compversion", "conprocess", "unversion", "converted", "Converted", "Conversion"], "src": ["SOURCE", "path", "rest", "sin", "http", "input", "url", "Source", "sc", "usr", "filename", "func", "pkg", "file", "ser", "config", "rx", "sr", "ource", "s", "rc", "buster", "ur", "str", "cc", "sq", "inst", "req", "stream", "ins", "rs", "source", "from", "txt", "host", "loc", "orig", "img", "hl", "uri", "addr", "href", "attr", "sys", "ebin", "st", "ipl", "scene", "its", "upload", "iv", "dist", "cont", "start", "cur", "rel", "RC", "SourceFile", "scan", "sit"], "dest": ["rest", "write", " Dest", " dst", " destinations", " orig", "dir", "Dest", "test", "tif", "source", "txt", "orig", "img", " destination", "est", "result", "target", "mat", "port", " Destination", "dat", "temp", "foreign", "disk", "dist", "gin", "table"], "in": ["In", "b", "ad", "is", "input", "rin", "sql", "r", "file", "m", "IN", "inn", "reader", "l", "inf", "bin", "as", "ar", "stream", "ins", "source", "from", "en", "up", "io", "el", "ind", "st", "din", "isin", "cin", "serv", "i", "d", "inner", "res"], "p": ["b", "pt", "at", "pp", "ph", "parse", "wp", "tp", "vp", "pa", "it", "dp", "r", "f", "pm", "m", "per", "fp", "pkg", "php", "pc", "t", "pre", "l", "parser", "prot", "c", "cp", "py", "pro", "pe", "pd", "h", "ping", "er", "op", "part", "j", "sp", "rep", "pers", "post", "g", "ps", "jp", "i", "d", "pi", "P", "lp", "pl", "ap", "pg", "pb"], "ds": ["cs", "eds", "ts", "tags", "gd", "ags", "ads", "hd", "uds", "pd", "bs", "outs", "eps", "ports", "ss", "edes", "workers", "DS", "nas", "cks", "ils", "amps", "des", "ats", "s", "ras", "iffs", "os", "hs", "aws", "tests", " d", " ads", "sd", "db", "scripts", "terms", "sets", "ns", "ls", "dos", "gs", "dl", "lists", "dh", "tp", "docs", "dp", "ands", "vs", "dds", "sts", "dates", "rs", "xs", "df", "dt", "mys", "posts", "its", "js", "els", "drivers", "ws", "di", "obs", "points", "ys", " os", "loads", " des", " dd", "tes", "dd", "Ds", "ods", " DS", "ps", "ks", "d", "yes", "qs"], "format": ["feat", "path", "at", "template", "title", "parse", "MAT", "id", "it", "type", "f", "mt", "output", "lat", "file", "ats", "fc", "t", "l", "pretty", "mode", "top", "feature", "size", "source", "Format", "ct", "unit", "act", "pattern", "layout", "settings", "version", "spec", "policy", "set", "sche", "mat", "style", "form", "shape", "fm", "module", "cf", "pi", "name", "tag", "status", "filter", "table", " Format"], "hasPixelData": ["hasixeldata", " hasPixelDATA", "HasPixelData", "hasFrameData", "hasFramedata", "hasPixeldata", "haspixeldata", "HaspixelDATA", "Haspixeldata", "HaspixelData", "HasPixelDATA", "hasPixelDATA", "haspixelDATA", "haspixelData", "hasixelDATA", "hasFrameDATA", "HasPixeldata", " hasPixeldata", "hasixelData"], "inflate": ["invalidate", "inFlicate", "Inflocate", "Informat", "inflocate", "inFlATE", "Inflat", "informate", "Informate", " invalidate", "invalidicate", "inFlate", "inFLate", "infolated", " inflocate", "Inflated", "informated", " invalidATE", "infolocate", "inflated", "inFLat", "invalidATE", "Informocate", "inFLocate", "incelATE", "inFlocate", " inflicate", "informocate", "Inflate", "inflATE", "incelocate", "informat", "invalidocate", "incelicate", " invalidicate", " invalidocate", "infolate", "inflicate", "inFLated", "Informated", "infolat", " inflATE", "incelate", "inflat"], "pxlen": ["phpdec", "pxden", "mmlen", "phplen", "pxln", "mxdec", "pixells", "packfun", "pxlin", "pexln", "tmplength", "mxlen", "pexfun", "cplength", "pxdec", "mmln", "tmpln", "xylength", "packdec", "xplen", "pexlen", "pixellen", "packlength", "pexlength", "tmplin", "xpden", "pexls", "pixelfun", "xyln", "packls", "packlen", "cpln", "mmlength", "mmlin", "phplength", "cpden", "xylen", "tmplen", "phpln", "pxfun", "pxlength", "xpln", "xplength", "mxln", "mxlength", "pexden", "packln", "xylin", "pixellength", "pxls", "cplen"], "out": ["inv", "obj", "user", "ex", "group", "init", "OUT", "net", "ou", "store", "err", "output", "list", "ln", "dir", "pretty", "client", "Out", "crit", "screen", "gov", "cmd", "up", "io", "sys", "outs", "msg", "writer", "log", "temp", "conn", "gr", "sum", "print", "aos", "res", "outer", "inter", "name", "prefix", "cfg"]}}
{"id1": "189963", "id2": "21092340", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrites", "readAndRepWrite", "readAndResWrite", "readAndRewend", "readAndResend", "readAndrewrite", "readAndrewWrite", "readAndResrite", "readAndRewrites", "readAndrewrites", "readAndReprite", "readAndrewend", "readAndRewWrite", "readAndRepend", "readAndReprites"], "inFile": ["InFile", "inputFilename", "docFile", "docFILE", "iFILE", "iFilename", "INTime", "inFILE", "InFilename", "initPlace", "initFilename", "inputPlace", "docTime", "inFace", "outfile", "infile", "iFile", " inFilename", "initFile", "inPlace", "INPlace", "docFilename", " infile", "inTime", "Infile", "initFace", "INFace", "iTime", "INFilename", "INFile", "INFILE", "inputFile", "inputFace", "inFilename", "outFilename"], "outFile": ["reportFile", " outFilename", "checkFilename", "outFILE", "inFILE", "toFILE", "reportFILE", "tofile", "nameFilename", "outfile", "infile", " outFILE", "reportfile", "reportFilename", "toFilename", "namefile", "nameFile", "toFile", "checkFile", " outfile", "checkFILE", "inFilename", "outFilename", "nameFILE", "checkfile"], "iis": [" iris", "iiIs", "liris", "iIS", "eis", "aiis", "Iiss", "liisc", "Ii", "liIs", "liis", "eIS", "iiisc", "ii", " iiss", "iiss", "iiis", "iiris", " iIs", "iIs", " iIS", "diIs", " ii", "iisc", "IIs", "eIs", "aiIS", "dii", "aiIs", "diis", " iisc", "iris", "Iis", "diiss"], "dcmParser": ["dgrParser", " dpmListener", "dpcReader", "dpmAssistant", "DpmReader", "dcrparser", "dcommReader", " dpmarser", "dcmListener", "dmoduleReader", "dmoduleAssistant", " dpmStatement", "dpmLoader", "dmmParser", " dcmarser", " dpmparser", "dcommListener", "deromParser", "dpmBuilder", "dromparser", "dcmAdapter", "dcrParser", "dfmParser", "dpmStatement", "dmmmReader", " dcmLoader", "dcomReader", "dcmBuilder", "dromAssistant", "DpmAdapter", "dcrBuilder", "dpmPrivate", " dcmPar", "dcomBuilder", "dcrReader", " dpmReader", "dcommAssistant", " dpmLoader", " dcmStatement", " dcmAssistant", "dmmarser", "dmmparser", "DcmBuilder", "dpmarser", "dgrStatement", " dcmBuilder", "dmmmparser", "dcmparser", "dcfStatement", "dromReader", "dcmAssistant", "decmParser", " dcmListener", "deromarser", "Dpmparser", "decmReader", "DcmParser", "dpmAdapter", " dpmParser", "dcmStatement", "dgrReader", " dpmPar", "DpmPar", "dmReader", "decmarser", "dpcAssistant", "DpmBuilder", "dmmReader", "decmparser", "drumParser", "dromarser", " dpmBuilder", " dcmPrivate", "dpcParser", " dpmAssistant", "dcmLoader", "DcmReader", "dromParser", "dmmmParser", " dcmparser", "dmmAdapter", "DpmParser", "drumReader", "dfmReader", "dpmReader", "dgrPar", "dcmReader", "dcfReader", "deromReader", "Dcmparser", "deromparser", "dcommParser", "dmparser", "drumPar", " dcmReader", "dcmarser", "dmarser", "dcmPrivate", "dpmparser", "dcmPar", "dmParser", "dmmmAdapter", "dpcPrivate", "dcfPar", "dromListener", "dcomParser", "dmodulePrivate", "DcmAdapter", "drumBuilder", "dfmBuilder", "dfmLoader", "dpmListener", "dcomLoader", "dpmPar", "dmoduleParser", "dpmParser", "dcfParser", "DcmPar", " dpmPrivate"], "ds": ["ls", "cs", "dos", "dl", "gs", "eds", "dh", "ils", "fs", "des", "vs", "ys", "da", "der", "sv", "s", "gd", "dds", "sets", " des", "as", "ads", "hd", "dq", "rs", "uds", "tes", "xs", "df", "os", "details", "ins", "pd", "dd", "services", "in", "bs", "Ds", "ods", "sys", "obs", "outs", "dt", "hs", "pers", " DS", "eps", "its", "js", "dat", "bd", "ps", "dx", "ks", "ss", "drivers", "sd", "d", "aos", "qs", "data", "ws", "DS", "db", "es", "ims", "ns"], "pdReader": ["ddHelper", "ddParser", "pdLoader", "xdHelper", "pdParser", "tdWriter", "xdLoader", "tdRead", "ddLoader", "vdLoader", "pdRead", "dpCar", "dpLoader", "ddWriter", "ddReader", "pdCar", "ddRunner", "dpRunner", "pedReader", "tdParser", "hdParser", "tdReader", "pedLoader", "pedCar", "hdRead", "pdRunner", "vdHelper", "xdReader", "pdHelper", "hdWriter", "ddRead", "xdWriter", "dpReader", "vdReader", "pedRunner", "hdReader", "ddCar", "vdWriter"], "out": ["over", "full", "on", " err", "err", "t", "str", "ins", "p", "ent", "outs", "ch", "writer", "log", "conn", "con", "co", "sum", "sw", "v", "o", "auto", "name", "status", "gen", "inv", "obj", "ex", "ou", "all", "id", "nt", "s", "cb", "c", "end", "txt", "os", "nr", "cn", "in", "desc", "conv", "serv", "raw", "inner", "outer", "pool", "cfg", "at", "net", "tmp", "list", "pos", "Out", "n", "en", "up", "io", "sys", "w", "js", "aos", "res", "data", "we", "OUT", "cache", "it", "output", "oss", "client", "gt", "one", "null", "screen", "go", "cmd", "to", "opt", "flush", "msg", "gr", "inter"], "dcmEncParam": ["dcmEnPar", "dcmEnVal", "dcmencCmd", "dcmEncVal", "dcmEnParam", "dcmencParam", "dcmEscPar", "dmmencParam", "dcmDecParam", "dmmEncCmd", "dcmEncCmd", "dcmencNum", "dmmEncMsg", "dmmencNum", "dmmEncPar", "dcmEncPar", "dcmEscNum", "dmmEnPar", "dcmDecCmd", "dcmEncMsg", "dcmEnNum", "dmmEnNum", "dcmEscVal", "dcmDecMsg", "dcmEscParam", "dmmEncParam", "dmmencCmd", "dmmEnParam", "dmmEncNum", "dcmEncNum", "dcmDecNum", "dcmencPar", "dcmencMsg", "dmmEncVal", "dmmencMsg"], "pdWriter": ["dpEditor", "PDReader", "tdWriter", "dpWriter", "pidWrite", "PDWriter", "pdwriter", "pidWriter", "PDWrite", "tdWriting", "tdReader", "PDEditor", "pidwriter", "pidWriting", "dpWrite", "tdwriter", "pcWriter", "pcWrite", "pdWrite", "pdWriting", "pcwriter", "tdWrite", "pdEditor", "pcWriting", "dpReader", "tdEditor"]}}
{"id1": "19849797", "id2": "9319440", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 0, "substitutes": {"copyFile": [" cpStream", "transferFiles", " cpFiles", "transferfile", "copyFiles", "transferFile", " cpFile", " copyfile", "transferStream", " copyFiles", " copyStream", " cpfile", "copyStream", "copyfile"], "sourceFile": ["srcPage", "ourcePath", " sourceTable", "ourcefile", " sourcefile", "srcTable", "sourcefile", "ourceField", "sourceLine", "ourceTable", "sourceTable", "sourceField", " sourceLine", "srcPath", " sourcePage", "ourceFile", " sourceField", "ourcePage", "sourcePage", "srcFile", "ourceLine", "srcfile", "srcField", "srcLine", "sourcePath", " sourcePath"], "destFile": ["DestFile", "restPlace", "destFilename", "declFolder", "optEntity", " destPath", "DestFilename", "declFile", "optFilename", "destEntity", "destPath", "srcDir", "restFiles", " destPlace", "optPath", "DestFiles", "declEntity", "srcEntity", " destFiles", "DestPath", "datFiles", "srcFiles", "restFile", "srcFolder", "optDir", "optFolder", "restFilename", "srcPath", " destDir", "DestDir", "datFile", "destFolder", "destDir", "srcFile", "destPlace", "optFile", "datFilename", "destFiles", "declDir", "datPlace", " destFilename"], "source": ["SOURCE", "match", "iter", "ce", "check", "init", "src", "parse", "store", "note", "component", "input", "search", "query", "Source", "force", "subject", "update", "shell", "reader", "ource", "use", "se", "back", "cause", "load", "before", "send", "slave", "standard", "origin", "score", "image", "stream", "missing", "scope", "from", "proxy", "in", "char", "copy", "scale", "attribute", "owner", "result", "spec", "sequence", "console", "body", "target", "style", "show", "ie", "none", "parent", "OURCE", "iterator", "series", "resource", "inner", "start", "sample", "pose", "create", "comment", "channel", "index", "service", "local", "table"], "destination": ["descation", "decinated", " destinated", "descinator", "Destinator", "Destificate", " destinator", "termininated", "destinated", "Destinate", "restinator", "restinated", "terminination", "decination", "Destinated", "Destment", "terminined", "descinate", "separment", "nonination", "veration", "separation", " destificate", "descination", "separinated", " destation", "verinated", "destinator", "termininate", "destation", "verificate", "destificate", " destined", "destinate", "noninator", "destment", "restination", " destinate", "noninate", "destined", "Destation", " destment", "separination", "decinate", "decined", "Destination", "noninated", "verination", "restinate"]}}
{"id1": "17522011", "id2": "20920051", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"read": ["transform", "iter", "check", "format", "parse", "input", "Read", "find", "write", "open", "download", "info", "walk", "select", "sync", "file", "config", "reader", "php", "link", "reads", "load", "test", "req", "word", "stream", "run", "READ", "close", "handle", "view", "text", "show", "report", "reading", "get", "build", "process", "rd", "raw", "resource", "content", "print", "create", "it", "readable", "hello", "reflect", "required"], "classLoader": ["thisloader", "Classloader", "moduleLoader", "ClassLoading", "moduleloader", "classLoading", "moduleReader", "thisLoader", "ClassLoader", " classManager", "classloader", "ClassReader", "thisReader", " classReader", "ClassManager", "moduleLoading", "ClassPath", " classloader", "fileManager", "fileLoader", " classPath", "thisPath", "fileReader", "classPath", "classManager", "classReader", "fileLoading", " classLoading"], "name": ["alias", "message", "path", "title", "id", "search", "type", "filename", "file", "m", "description", "current", "l", "common", "string", "root", "size", "nm", "key", "Name", "word", "family", "n", "missing", "label", "null", "source", "password", "part", "named", "old", "ame", "ref", "parent", "NAME", "names", "resource", "base", "prefix", "order", "local"], "all": ["collection", "multiple", "empty", "full", "many", "force", "optional", "list", "first", "any", "enabled", "and", "m", "required", "always", "also", "n", "null", "multi", "global", "both", "loop", "All", "attribute", "default", "valid", "ALL", "none", "only", "allowed", "active", "total", "oll", "latest", "each", "local"], "sm": ["tm", "imm", "igm", "arms", "SM", "sy", "Sm", "gm", "wm", "mt", "km", "tem", "shell", "m", "pm", "ym", "rm", "sem", "md", "sbm", "mg", "sym", "rpm", "nm", "asm", "sk", "cm", "sam", "sp", "mm", "sim", "hm", "mn", "mb", "hem", "esm", "sf", "ism", "arm", "model", "mem", "bm", "mph", "ms", "dm"], "enu": ["Enui", "enuu", "annu", "attenfu", "EnU", "deniu", "attenuu", "Enpu", " enfu", "Enu", "ennu", "denfu", "erpu", "eniu", " eniu", "attenu", "erui", "enus", "anu", " enui", "anus", "erU", " enU", " enus", "Ennu", " ennu", " encu", "encu", "enfu", " enuu", "enU", " enpu", "denuu", "ancu", "Enus", "denu", "atteniu", "eru", "enui", "enpu", "Encu"], "url": ["ls", "b", "user", "path", "dl", "cert", "net", "http", "URL", "r", "f", "open", "db", "pkg", "bl", "add", "l", "ur", "link", "gl", "browser", "job", "web", "nl", "key", "arl", "mount", "uri", "char", "rl", "il", "sp", "ol", "sb", "ref", "log", "Url", "build", "resource", "v", "bel", "base", "ll", "ob", "pl", "rel", "sl"], "is": ["ls", "mus", "nis", "iter", "init", "mos", "rest", "isl", "was", "out", "vis", "it", "fs", "dis", "vs", "iso", "abs", "bis", "tis", "IS", "isc", "oss", "lis", "ri", "ir", "ins", "iss", "bits", "os", "ris", "mi", "gc", "in", "act", "bs", "isf", "Is", "are", "ires", "sys", "obs", "isi", "im", "its", "has", "js", "isin", "sim", "ais", "ios", "ps", "i", "sis", "mis", "ism", "isa", "ois", "iris", "ms", "es", "ims", "ip"], "s": ["ls", "cs", "b", "css", "gs", "gets", "ts", "ds", "fs", "sql", "ves", "f", "m", "join", "ats", "sv", "abs", "prints", "l", "csv", "t", "string", "str", "less", "ols", "ags", "parts", "sts", "ings", "c", "ists", "results", "n", "tes", "rs", "os", "p", "h", "arts", "ies", "S", "y", "uts", "set", "hs", "sol", "its", "js", "conv", "g", "sb", "ps", "stats", "ss", "v", "qs", "ains", "ries", "ws", "ms", "es", "ns"]}}
{"id1": "11562173", "id2": "12055086", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["assertInputstream", "checkAudiostream", "checkOutputStream", "checkContentChannel", "checkOutputFile", "checkInputstream", "checkAudioChannel", "checkInputFile", "checkInputChannel", "assertOutputStream", "assertOutputChannel", "checkContentFile", "checkOutputstream", "checkOutputChannel", "checkAudioStream", "assertOutputstream", "assertInputFile", "checkAudioFile", "assertInputStream", "assertOutputFile", "checkContentStream", "checkContentstream", "assertInputChannel"], "in": ["b", "In", "ex", "is", "or", "on", "input", "it", "al", "file", "IN", "inn", "s", "l", "c", "ins", "source", "from", "inc", "n", "mc", "en", "up", "io", "ind", "st", "old", "din", "mm", "get", "cin", "con", "gin", "cont", "raw", "inner", "o", "doc"], "cmp": ["cs", "match", "pres", "cd", "com", "ctx", "different", "equal", "vp", "tc", "comm", "tmp", "pkg", "mp", "eq", "cond", "same", "csv", "cc", "cb", "qual", "c", "mc", "cv", "cp", "cn", "comp", "cmd", "resp", "coll", "good", "dict", "compl", "Comp", "msg", "result", "par", "desc", "cu", "ch", "cod", "conv", "ctrl", "ck", "co", "rel", "diff", "omp"], "all": ["empty", "full", "equal", "al", "list", "any", "first", "bl", "and", " ALL", "m", "always", "also", "l", "app", "test", "null", "a", "both", "attribute", "All", "valid", "default", "ALL", "alph", "kill", "none", "only", "ssl", "active", "total", "oll", "other", "ll", "each", "alpha", "call"], "stream": ["Stream", "collection", "each", "store", "draw", "sign", "input", "sudo", "time", "context", "tmp", "output", "sync", "REAM", "clean", "zip", "se", "network", "our", "system", "window", "row", "ST", "host", "screen", "dd", "pipe", "ost", "st", "console", "view", "socket", "form", "upload", "engine", "stack", "parent", "port", "shape", "buffer", "event", "Steam", "sw", "sample", "ream", "mount", "channel", "service", "local"], "out": ["b", "external", "obj", "ex", "check", "at", "OUT", "net", "it", "array", "des", "output", "tmp", "pkg", "list", "clean", "help", "t", "str", "Out", "n", "p", "ent", "not", "cn", "good", "batch", "to", "up", "io", "ne", "sys", "outs", "exp", "conv", "log", "serv", "con", "raw", "v", "res", "o", "outer", "aos", "data", "ot"], "i": ["ij", "iter", "is", "init", "us", "perm", "gi", "id", "qi", "it", "xi", "info", "\u0438", "ci", "li", "ms", "z", "I", "m", "ai", "ix", "client", "sym", "gu", "ki", "x", "bi", "key", "hi", "ri", "n", "ii", "q", "u", "multi", "mi", "uri", "ic", "batch", "ini", "index", "ind", "y", "json", "phi", "iu", "sim", "ji", "me", "chain", "si", "v", "ei", "pi", "span", "zi", "ti", "cli", "vi", "point", "j", "ui", "di", "ims"]}}
{"id1": "3024970", "id2": "15409512", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamTooutputFile", "testCopy_inputStreamTooutputStream", "testCopy_inputStreamtoOutputFile", "testCopy_inputStreamtoOutputStream", "testCopy_inputStreamtoOutputSteam", "testCopy_inputStreamTooutputstream", "testCopy_inputStreamtoInputStream", "testCopy_inputStreamtoInputFile", "testCopy_inputStreamtoInputstream", "testCopy_inputStreamToOutputSteam", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamToInputStream", "testCopy_inputStreamtoInputSteam", "testCopy_inputStreamToInputstream", "testCopy_inputStreamTooutputSteam", "testCopy_inputStreamToInputSteam", "testCopy_inputStreamToInputFile", "testCopy_inputStreamtoOutputstream", "testCopy_inputStreamToOutputFile"], "in": ["In", "inv", "read", "iter", "is", "sin", "init", "on", "input", "it", "rin", "al", "sql", "r", "doc", "ain", "IN", "inn", "l", "inside", "inf", "bin", "ai", "c", "ins", "n", "source", "from", "mc", "q", "p", "this", "en", "ac", "h", "mi", "ic", "up", "copy", "xml", "io", "el", "ind", "im", "din", "mm", "isin", "log", "nin", "cin", "con", "i", "gin", " din", "inner", "scan", "ini"], "baout": ["oain", "kain", "baio", "kaend", "abaot", "oaout", "caouts", " baend", "abain", "oaio", "calog", "kaout", "baouts", "Baout", "baend", "boin", "BAout", "Baouts", "abaOut", "oaOut", "boio", "caio", "abaout", "caout", "boOut", "Balog", " balog", "BAot", " baouts", "caend", " baot", "balog", "baot", "BaOut", "BAin", "kaOut", " bain", "cain", "BAOut", "bain", "caOut", "baOut", "boout", " baOut"], "out": ["b", "obj", "ex", "check", "at", "net", "OUT", "ou", "all", "it", "output", "list", "t", "oss", "client", "gt", "Out", "n", "null", "cmd", "to", "up", "copy", "io", "sys", "outs", "set", " Out", "conv", "OU", "g", "log", "serv", "con", "gr", "co", "sum", "aos", "res", "o", "ot"], "count": ["Count", "read", "counter", "number", "id", "z", "amount", "nt", "N", "current", "ctr", "size", "c", "found", "ct", "num", "resp", "length", "nb", "total", "sum", "code", "start", "skip", "ount", "index"]}}
{"id1": "12389873", "id2": "22855019", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public static MessageService getMessageService(String fileId) {\n        MessageService ms = null;\n        if (serviceCache == null) init();\n        if (serviceCache.containsKey(fileId)) return serviceCache.get(fileId);\n        Properties p = new Properties();\n        try {\n            URL url = I18nPlugin.getFileURL(fileId);\n            p.load(url.openStream());\n            ms = new MessageService(p);\n        } catch (Exception e) {\n            ms = new MessageService();\n        }\n        serviceCache.put(fileId, ms);\n        return ms;\n    }\n", "label": 0, "substitutes": {"load": [" fetch", " Init", " build", "init", " recover", "save", " destroy", " ping", " find", "construct", " validate", " register", " read", " startup", " reload", " search", " parse", " cleanup", " dump", "insert", " test", "execute", " scan", " ingest", " construct", " fill", " refresh"], "conn": ["obj", "pt", "com", "Conn", "Connection", "cert", "ctx", "conf", "ds", "yn", "open", "comm", "mt", "cfg", "nt", "ln", "col", "Con", "ctr", "ann", "cc", "ens", "cb", "org", "client", "c", "n", "mc", "gate", "cp", "en", "cn", "ct", "cmd", "dn", "coll", "die", "act", "nc", "ch", "wr", "enc", "conv", "close", "con", "mn", "connection", "co", "pen", "cur", "rel", "connect", "db", "pg", "ns", "pas"], "stmt": [" sttry", "STmb", "restaddr", "histmt", "constmt", "sttab", "stackMT", " superststat", "esttx", "Stmm", "istgt", "ostmid", " stm", "estgt", " Stmt", "stackmt", "stytx", " stpt", "stacktab", "Stmem", "Stgr", "ostmn", "stmg", "histcmd", " strm", "STmt", "putmm", "stmsg", "strmn", "ostpt", "histtry", "Stmsg", "estmt", "resttx", "stymem", "putmp", "stoprm", "restmt", "restMT", "istmt", "constm", "stgt", "stymsg", "stmp", "stgr", "strmt", "sttry", "STgt", " stmem", " stolt", "stackgt", " stmg", " superstm", "stst", " superstmn", "estgr", "ostmt", " stst", "Stcmd", "stcmd", "stymb", " stgr", "stopmm", "stym", "Stst", "istMT", " stmsg", "Stgt", "ostmem", "styMT", "STmsg", "STtx", " supersttr", " stgt", "estm", "stmid", "stackmid", "strstat", "stopmt", "stopmn", "Sttry", "stmem", "StMT", "stmm", "puttab", " StMT", "ostgr", "stolt", " stmp", " staddr", "ostgt", "Stm", "constst", "stackpt", " sttr", " stMT", "ostrm", "ststat", "putMT", "Stmb", "stygt", " stmb", "strm", "estmg", "strmg", " superstmg", "styaddr", "histgt", "ostmm", "stMT", "staddr", "STMT", "stackolt", "restmm", "ostolt", "stymg", " stmn", "stmb", " stmid", "sttx", "Stmt", "stymt", "putmt", " sttx", "stackmm", " stcmd", "restgt", "puttx", "estmb", " Stm", " superstMT", "stmn", " stmm", "restpt", "restmg", "stpt", " Sttr", "osttab", " superstmt", "estmm", "restgr", "putolt", "restmp", "constMT", "sttr", " ststat", "stm"]}}
{"id1": "14188043", "id2": "20128728", "code1": "    public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException {\n        AQUtility.debug(\"net\", urlPath);\n        URL url = new URL(urlPath);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setConnectTimeout(NET_TIMEOUT);\n        int code = connection.getResponseCode();\n        if (code == 307 && retry) {\n            String redirect = connection.getHeaderField(\"Location\");\n            return openHttpResult(redirect, false);\n        }\n        if (code == -1 && retry) {\n            return openHttpResult(urlPath, false);\n        }\n        AQUtility.debug(\"response\", code);\n        if (code == -1 || code < 200 || code >= 300) {\n            throw new IOException();\n        }\n        byte[] result = AQUtility.toBytes(connection.getInputStream());\n        return result;\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"openHttpResult": ["openHttpMessage", "getHttpRes", "openQueryRes", "openQueryResult", "getHttpResult", "OpenHTTPResponse", "openQueryResults", "OpenHTTPMessage", "getHTTPResponse", "openUrlResponse", "OpenHttpRes", "openhttpResult", "openHttpResults", "openHttpRes", "openHTTPResults", "openHTTPResponse", "OpenHTTPResult", "getHTTPRes", "openHTTPRes", "openHTTPResult", "openQueryResponse", "getHttpResults", "openhttpRes", "OpenHTTPRes", "openhttpResults", "OpenHttpResponse", "openUrlRes", "OpenHttpMessage", "getHttpResponse", "OpenHttpResults", "openUrlResult", "openHttpResponse", "openHTTPMessage", "getHTTPResults", "openUrlResults", "OpenHttpResult", "getHTTPResult", "OpenHTTPResults", "openUrlMessage", "openhttpMessage", "openhttpResponse"], "urlPath": ["urlName", "UrlFile", "xmlFile", "pathStr", "URLPath", "nlP", "urlString", "nlpath", "UrlString", " urlP", "dlStr", "UrlPath", " urlDir", "URLCh", "pathFile", "xmlStr", "urlP", "dlPath", "UrlName", "xmlPath", "URLDir", "urlDir", "urlFile", "URLString", "pathPath", "dlFile", "UrlP", " urlString", "Urlpath", "URLName", "urlCh", " urlCh", "nlFile", "UrlId", "UrlDir", "URLId", " urlId", " urlpath", "urlStr", " urlFile", "nlPath", " urlName", "UrlCh", "pathpath", "dlpath", "xmlpath", "urlId", "urlpath"], "retry": ["rettry", "redric", "retric", "attrain", "Retrying", "retrain", "retried", "pretried", "attry", "redrier", "terried", "terry", "tric", " retrying", "rery", "Retry", "retrying", "terrain", "rerying", "attrying", " rettry", "Retri", "attried", "pretric", "trier", "redwrite", "retwrite", "redry", "pretrain", "pretrier", "retri", "Rettry", "reri", "terrying", "pretrying", "twrite", "pretry", " retri", "retrier", "pretwrite"], "url": ["ls", "user", "sl", "dl", "http", "URL", "r", "open", "li", "file", "l", "ur", "link", "str", "https", "job", "loader", "web", "org", "nl", "loc", "uri", "char", "rl", "il", "get", "log", "Url", "pl", "conn", "ssl", "ul", "location", "base", "ll", "mount", "service", "www"], "connection": ["operation", "message", "online", "generation", "creator", "Connection", "http", "number", "application", "open", "subject", "context", "translation", "database", "ion", "description", "session", "l", "link", "network", "client", "directory", "entry", "connected", "c", "character", "builder", "close", "created", "uri", "established", "computer", "to", "cone", "io", "nc", "command", "set", "socket", "position", "using", "statement", "writer", "city", "usage", "controller", "conn", "con", "condition", "resource", "server", "communication", "creation", "pointer", "create", "response", "connect", "channel", "relation"], "code": ["change", "message", "check", "ce", "cd", "number", "component", "time", "id", "type", "force", "error", "currency", "sec", "coe", "zip", "count", "zone", "ode", "coded", "se", "rc", "success", "cc", "mode", "test", "size", "c", "zero", "entry", "rate", "x", "one", "page", "a", "go", "close", "xxx", "ord", "ct", "num", "cycle", "Code", "ne", "nc", "state", "sequence", "length", "desc", "ch", "dec", "cod", "ie", "codes", "e", "controller", "cont", "co", "level", "now", "create", "cast", "name", "status", "cause", "xx", "call"], "redirect": ["redistant", "regir", "promir", "redir", "promirect", "promistant", "Redirect", "predir", "regirection", "Redirection", "Redistant", "predirect", " redir", "predistant", "Redir", "Reduction", "predirection", "reduction", "redirection", "promirection", "regirect", " reduction", " redirection", "reguction"], "result": ["message", "transform", "Result", "match", "cert", "value", "out", "r", "output", "description", "request", "currency", "params", "success", "proc", "true", "test", "answer", "feature", "meg", "memory", "results", "reason", "root", "mask", "password", "command", "sequence", "length", "report", "ret", "process", "buffer", "date", "total", "res", "profile", "other", "data", "comment", "complete", "table", "cup", "vector"]}}
{"id1": "2668634", "id2": "6501291", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"inputName": ["InputNames", "inputFilename", "interfaceFilename", " inputNames", "InputFilename", "interfacePath", "InputPath", "InputName", "outputFilename", "interfaceFile", "outputFile", "inputNames", "inputFile", " inputFile", "outputPath", " inputPath", "InputFile", "outputNames", "interfaceName", "inputPath"], "outputName": ["OutputName", "inputType", "OutputNames", "OutputType", " outputDir", "inputDir", "outputType", "OutputPath", " outputNames", "OutputDir", " outputPort", " outputPath", "OutputPort", "inputPort", "outputDir", "inputNames", " outputType", "outputPath", "outputNames", "inputPath", "outputPort"], "stripLoggers": ["skipLogger", "striplogging", "skipLoggers", "skiplogging", "skiplogger", "skipLogReferences", "skiplogReferences", "stripPathReferences", "stripLogger", "stripDebugger", "striplogReferences", "stripDebugReferences", "stripLogging", "skiploggers", "stripDebugging", "stripPathgers", "stripLogReferences", "striploggers", "stripPathger", "stripPathging", "stripDebuggers", "skipLogging", "striplogger"], "tempFile": [" tempDir", " temporaryFile", "tempfile", " temporaryField", "tempField", "empLock", "empfile", "tempLock", "tmpfile", "TempFile", "tempPlace", " tempPath", "TempDirectory", "TempDir", "tmpDir", " temporaryLock", " temporaryfile", " tempPlace", "temfile", "TempPlace", " temporaryDir", "tmpLock", "TempPath", "Tempfile", "tmpPath", " temporaryDirectory", "tempDir", "tmpPlace", "temPath", "empField", "tempPath", " tempfile", "empFile", "tmpField", "temFile", " tempDirectory", "temDir", "tmpFile", "tempDirectory"], "jin": ["quin", "pin", "lah", "von", "jon", "thin", "jac", "rin", "xi", "yang", "ln", "jing", "JR", "nik", "zip", "alin", "jo", "bin", "rake", "lin", "vin", " Jin", "jiang", "john", "ju", "txt", "jet", "erb", "olin", "ja", "pai", "nu", "zin", "tan", "tin", "json", "lu", "lig", "jc", "inx", "kin", "din", "rison", "nin", "cin", "jp", "gin", "spin", "ran", "jl", "jad", " inj", "zon", "rir", "jen", "via", "ini", "pak"], "jout": ["zout", "qio", "jpout", "jsout", " jou", " jOut", " jio", "qou", "zou", "zaos", "jsin", "jou", "jsOut", "zio", "qaos", "qout", "jOut", "jpOut", "jaos", " jaos", "jio", "jpin"], "srcChannel": ["rcChan", "rcchannel", " srcchannel", "sourcechannel", "srcChan", "srcCh", "sourceCh", "srcchannel", " srcCh", "sourceChannel", " srcChan", "rcCh", "rcChannel", "sourceChan"], "dstChannel": [" dstCh", " ddestChannel", "dgtFile", "doutChannel", "dgtChan", " ddestChan", "dstCh", "dgtCh", "ddestChannel", "doutCh", " dstChan", "ddestCh", "doutFile", "dstFile", "dstChan", "ddestChan", " ddestFile", "dgtChannel", " ddestCh", "doutChan", "ddestFile", " dstFile"], "portletApplicationName": ["portletApplicationCode", "portletapplicationOrder", "portletApplicationOrder", "portletAppType", "portableAppKey", "portletapplicationKey", "portableAppName", "portableApplicationValue", "portletServiceType", "portletCollectionCode", "portableApplicationCode", "portletAppName", "portletAppKey", "portableApplicationKey", "portletCollectionValue", "portableAppType", "portableAppOrder", "portletAppValue", "portletServiceKey", "portableApplicationType", "portletApplicationKey", "portletApplicationValue", "portletServiceName", "portableApplicationOrder", "portletAppCode", "portletServiceOrder", "portletapplicationName", "portletCollectionName", "portletapplicationType", "portletAppOrder", "portletCollectionType", "portableApplicationName", "portletApplicationType"], "webXml": [" webYaml", "webXML", "webExxml", "webXxml", " webTxxml", "WebTxm", "WebXxml", "webXMml", "webExml", "webExML", "webTxML", "webXMpl", "WebTxxml", "webYML", "webXMlim", " webXlim", "WebXml", "webTxpl", "webYxml", " webXaml", "webTxlim", "webXpl", "webXaml", "webWorkxml", "webTxxml", "WebXML", "webMaml", "webXom", "webTxm", " webXML", "webYpl", "webYaml", " webYom", "webXMom", "WebTxML", "webExm", "webMom", "webWorkML", " webTxml", " webYml", "webXMML", " webXxml", "WebXm", " webTxML", " webTxlim", "WebXpl", "webXMaml", "webXMxml", "webTxml", "WebTxpl", "webMml", "webXlim", "webWorkml", "webXMm", "webYml", " webXom", "webXm", "webMML", "webWorklim", " webYML", "webYom", "WebTxml"], "portletXml": ["portletTxML", "portletXng", "portvetXbl", "portletYng", "portvetXMml", "portletYML", "portvetXMng", "portableYml", "portableXxml", "portableYxml", "portletYql", "portletHexml", "portletTxng", "portletEbl", "portletYbl", "portantTxml", "portvetXml", "portletExml", "portletXMbl", "portableXql", "portableYML", "portantTxML", "portableXml", "portletXML", "portletXql", "portvetXxml", "portantXML", "portletXMql", "portantTxxml", "portantXng", "portvetXng", "portantXxml", "portantXml", "portantTxng", "portletXMng", "portletXMxml", "portvetXMbl", "portletEng", "portvetXMxml", "portletTxxml", "portletEml", "portableYql", "portletHeng", "portletHeML", "portletTxql", "portletXMml", "portletTxml", "portletHeml", "portletXbl", "portletXMML", "portletXxml", "portableXML", "portletYml", "portletYxml"], "contextXml": ["componentXmm", "componentYmx", "contextXaml", "contextEml", "ctxXml", "contextYmm", "contextXML", "contextCaml", "ctxXaml", "ctxXiml", "contextXiaml", "contextXmx", "componentYmm", "contextXitml", "contextAxmx", "componentYML", "ctxXiaml", "contextCML", "ctxXiML", "contextYtml", "contextEmx", "contextEML", "componentYml", "contextXiml", "contextCtml", "contextYmx", "ctxXtml", "componentXmx", "contextAxmm", "contextEmm", "contextAxml", "contextXiML", "componentXml", "componentXML", "contextYML", "ctxXitml", "contextYml", "contextYaml", "contextXtml", "contextCml", "ctxXML", "contextAxML", "contextXmm"], "src": ["dest", "obj", "SOURCE", "sl", "rob", " sou", "supp", "secure", "zh", "sc", "Source", "usr", "url", "filename", "tmp", "ln", "ser", "su", "sec", "sr", "rc", "buster", "ctr", "https", "str", "proc", "sq", "entry", "inst", "sup", "sn", "loc", "crit", "from", "txt", "scope", "comp", "addr", "kk", "sys", "sp", "ind", "st", "sol", "slice", "desc", "sb", "ie", "bh", "ident", "sel", "sing", "cont", "resource", "syn", "cur", "skin", "rel", "sit", "via"], "source": ["dest", "SOURCE", "iter", "channel", "check", "template", "format", "store", "secure", "input", "it", "query", "sql", "Source", "context", "shell", "file", "ser", "session", "instance", "reader", "ource", "seed", "zip", "se", "size", "entry", "origin", "feature", "image", "stream", "single", "scope", "null", "from", "unit", "in", "tree", "copy", "sp", "spec", "state", "sequence", "set", "console", "site", "style", "result", "ie", "get", "parent", "iterator", "series", "buffer", "raw", "resource", "sum", "inner", "start", "sample", "base", "status", "service", "table"], "zipEntries": ["zipEriers", "ipEntries", "ipEries", "zipEities", "zipentities", "zipEnties", "zipEntryires", "zipEnires", "zipEies", "zipEs", "zipEnables", "zoneEnties", "ipEntarts", "zoneEntities", "ipEntires", "zipIntriers", "zipEnities", "zoneEnities", "zipErs", "zoneEntables", "zoneEntries", "Zipentrs", "zipEntrys", "zipEnries", "zipEntriers", "zipentables", "ipEs", "zipEntryarts", "zipIntrs", "zipEarts", "zipEnies", "zipEries", "ipEnts", "Zipentries", "zipEires", "zipEnts", "ZipEntries", "ZipEnties", "ipEires", "zipentriers", "zipenties", "zipEntables", "zipEntarts", "zoneEnies", "zipEables", "zipIntries", "zipEntities", "Zipenties", "ZipEntriers", "ZipEntrs", "zipEntires", "zoneEnables", "zipentries", "zipInties", "zipEntryries", "zipEns", "ipEarts", "zoneEnries", "zipEntrs", "zipentrs", "Zipentriers", "zipEnarts"], "target": ["alias", "match", "template", "format", "title", "compatible", "prop", "type", "url", "filename", "class", "project", "pkg", "task", "t", "Target", "top", "test", "arg", "peer", "tif", "gt", "term", "family", "route", "label", "scope", "primary", "host", "tool", "pattern", "layout", "handle", "version", "owner", "result", "text", "parent", "controller", "goal", "buffer", "chain", "resource", "module", "location", "base", "arget", "name", "rel", "tag", "bolt", "local", "table"], "webRewriter": ["webWactor", "webWriter", "webRewrite", "WebWriter", "webRebler", "_", "webRewactor", "WebRewriter", "Input", "WebWactor", "WebRewler", "Entry", "entry", "WebRewrite", "webRebriter", "webRebactor", "webRewler", "webWrite", "webRepler", "json", "WebWler", "webWler", "webRepriter", "webRepactor", "File", "impl", "get", "WebWrite", "Supp", "New", "log", "webRebrite", "cont", "aos", "webReprite", "Log", "println", "WebRewactor"]}}
{"id1": "5725177", "id2": "10715601", "code1": "    @Override\n    protected <T> T execute(final HttpMethod method, final String url, Parameters parameters, final Handler<T> handler) throws FoursquareException {\n        HttpURLConnection connection = null;\n        try {\n            switch(method) {\n                case GET:\n                    connection = openConnection(url.concat(\"?\").concat(formEncode(parameters)));\n                    connection.setRequestMethod(\"GET\");\n                    connection.connect();\n                    break;\n                case POST:\n                    connection = openConnection(url);\n                    connection.setRequestMethod(\"POST\");\n                    connection.setDoOutput(true);\n                    connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    connection.connect();\n                    final OutputStream out = connection.getOutputStream();\n                    out.write(formEncode(parameters).getBytes());\n                    out.flush();\n                    out.close();\n                    break;\n            }\n            final int statusCode = connection.getResponseCode();\n            if (statusCode / 100 != 2) {\n                final Error error = parseBody(connection.getErrorStream(), new ErrorHandler());\n                if (error == null) throw new FoursquareException(connection.getResponseMessage()); else if (\"error\".equals(error.getType())) throw new FoursquareException(error.getMessage()); else if (\"unauthorized\".equals(error.getType())) throw new AuthenticationException(error.getMessage()); else if (\"ratelimited\".equals(error.getType())) throw new RateLimitingException(error.getMessage()); else throw new FoursquareException(connection.getResponseMessage());\n            }\n            return parseBody(connection.getInputStream(), handler);\n        } catch (final IOException e) {\n            throw new FoursquareException(e);\n        } catch (final ParserConfigurationException e) {\n            throw new FoursquareException(e);\n        } catch (final SAXException e) {\n            throw new FoursquareException(e);\n        } finally {\n            if (connection != null) connection.disconnect();\n        }\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"T": ["TN", "TM", "M", "The", "U", "D", "Exception", "This", "AT", "N", "I", "Transaction", "t", "Z", "TC", "L", "A", "H", "XXX", "Ret", "Token", "W", "V", "TO", "O", "CT", "Single", "TT", "C", "Type", "S", "Y", "F", "E", "Complete", "TE", "R", "WT", "J", "Class", "B", "G", "TR", "TX", "P", "TYPE", "X", "Term"], "FoursquareException": ["FoursquareInternal", "FoursquerireException", "FoursquireException", "FoursquerareAlternative", "FoursqueroreException", "FoursqueroreWarning", "FoursquarkInstance", "FoursquareEx", "FoursQuareInstance", "FoursquareWarning", "FoursquarterError", "FoursquoreEx", "FoursquaireError", "FoursquarkInternal", "FoursquerireError", "FoursQuaireException", "FoursacquineTransaction", "FoursquareError", "FoursquareTransaction", "FoursQUareWarning", "FoursQUoreError", "FoursQUoreWarning", "FoursQUoreException", "FoursQUareMethod", "FoursquireInternal", "FoursQuoreException", "FoursQuareInternal", "FoursQuoreError", "FoursquarterWarning", "FoursacquineException", "FoursquaireException", "FoursquarterException", "FoursquareInstance", "FoursquireInstance", "FoursquoreWarning", "FoursquarkException", "FoursquerareError", "FoursacquareTransaction", "FoursquarkAlternative", "FoursQuoreWarning", "FoursquariMethod", "FoursquoreError", "FoursacquineWarning", "FoursQUareError", "FoursquireWarning", "FoursacquareWarning", "FoursQuoreInstance", "FoursquoreAlternative", "FoursqueroreAlternative", "FoursquoreInstance", "FoursquarkEx", "FoursquireError", "FoursQuaireEx", "FoursquoreMethod", "FoursquareAlternative", "FoursQuaireError", "FoursQuareError", "FoursQuareWarning", "FoursQUoreMethod", "FoursqueroreError", "FoursquineException", "FoursquoreTransaction", "FoursQUareException", "FoursquarkWarning", "FoursQuareException", "FoursQuaireWarning", "FoursquineWarning", "FoursquarkError", "FoursquineTransaction", "FoursquerireWarning", "FoursacquareException", "FoursquireTransaction", "FoursQuareEx", "FoursquerareException", "FoursquaireWarning", "FoursQuaireInternal", "FoursquarterAlternative", "FoursquareMethod", "FoursquariWarning", "FoursquoreException", "FoursquariException", "FoursquariError", "FoursquaireInternal", "FoursquerareWarning", "FoursquarkMethod", "FoursquaireEx"], "connection": ["creator", "device", "current", "directory", "connected", "still", "cone", "way", "writer", "engine", "license", "conn", "condition", "resource", "response", "connect", "node", "section", "relation", "library", "operation", "collection", "open", "subject", "context", "translation", "ion", "termination", "description", "c", "close", "command", "see", "statement", "usage", "chain", "pointer", "machine", "pool", "message", "generation", "Connection", "net", "function", "application", "information", "database", "session", "link", "network", "entry", "character", "management", "container", "tree", "version", "console", "remote", "creation", "location", "channel", "government", "number", "component", "query", "office", "specified", "reference", "client", "created", "document", "handler", "position", "no", "server", "communication", "create"], "out": ["external", "user", "group", "check", "net", "OUT", "store", "cache", "all", "write", "output", "list", "task", "file", "t", "network", "client", "entry", "Out", "n", "stream", "source", "page", "os", "in", "to", "flush", "up", "copy", "io", "outs", "result", "set", "writer", "conv", "log", "serv", "line", "conn", "i", "buffer", "co", "inner", "v", "aos", "o", "outer", "timeout", "response", "auto", "comment", "name", "data", "table"], "statusCode": ["exCount", "errorNo", " statusLength", "exStatus", "exCode", "excode", "statusStatus", "StatusStatus", "statuscode", " statusNo", "responseLength", "errorLength", "StatusCode", " statuscode", "errorNumber", "Statuscode", "StatusCount", "responseCode", "errorCode", "statusLength", " statusCount", "responseNo", "statusNumber", "statusNo", "statusCount", " statusNumber", "responseNumber", " statusStatus"], "error": ["user", "item", "extra", "empty", "or", "parse", "terror", "ace", "warning", "query", "type", "info", "r", "iso", "err", "address", "ion", "instance", "core", "ERROR", "description", "debug", "se", "original", "success", " Error", "entry", "feature", "detail", "row", "details", "er", "Error", "owner", "attribute", "result", "problem", "element", "ror", "option", "rage", "ack", "e", "bug", "no", "entity", "event", "resource", "errors", "base", "response", "danger", "node", "comment", "order", "relation"]}}
{"id1": "345515", "id2": "4272289", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public static int[] sortstring(int[] a1) {\n        int temp;\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        return a1;\n    }\n", "label": 0, "substitutes": {"url": ["b", "ls", "external", "path", "dl", "http", "URL", "sql", "r", "address", "file", "config", "l", "ur", "gl", "string", "str", "link", "browser", "job", "cl", "web", "html", "nl", "key", "term", "loc", "domain", "page", "q", "uri", "pattern", "util", "char", "rl", "xml", "default", "el", "ref", "get", "log", "Url", "pl", "ld", "impl", "ssl", "resource", "location", "base", "bel", "name", "ll", "mount", "sl", "un"], "in": ["In", "read", "online", "check", "is", "init", "on", "out", "input", "rin", "al", "update", "f", "login", "ln", "IN", "ma", "inn", "reader", "m", "s", "l", "ai", "bin", "again", "include", "c", "vin", "ins", "n", "source", "from", "mc", "null", "en", "mi", "oin", "body", "din", "isin", "min", "nin", "cin", "serv", "con", "i", "gin", " din", "line", "inner", "o", "name"]}}
{"id1": "6890417", "id2": "2221297", "code1": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "code2": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "label": 1, "substitutes": {"a1": ["sa0", "a0", "sa2", "area01", "ga0", "sa01", "sa1", "area2", "ga1", "ga5", " a0", "sa5", "sa4", "area4", "sa9", "area1", "ga9", " a01", "a01"], "a2": ["a0", " a02", "areaTwo", "a02", "aTwo", "e1", "A0", "e2", "ga0", "area2", "ga5", " a0", "eTwo", "ga4", "A4", "ga2", "area1", "A2", "area02", " aTwo", "A5", "e02"], "a3": ["A11", " aThree", "ga03", "pa1", "pa3", "A03", "aThree", "a03", " a03", "AThree", "pa5", "ga2", "pa11", "A3", "A2", "A5", "ga3", "A1", "gaThree"], "a4": ["alpha3", " a443", "era4", "an4", " a404", "alpha404", "a404", "era3", "era404", " aFour", "alpha443", "aFour", "a443", "era443", "asFour", "anFour", "as4", "alpha4"], "a5": ["b4", "n1", "n8", "an1", "ka6", "b6", "b5", "ka4", "b512", "ka512", "e6", "a512", "e4", " a6", "an6", "e512", "n5", "an8", "ka5", "n6", "e5", "a6", "an5"], "a8": ["b6", "b10", "sa10", "a7", "ga7", " a7", "ga5", "a08", "A8", "sa8", "A9", "aa10", "aa8", "ga9", "ga8", "b08", "a6", "sa08", "aa08", "A5", "aa6", "A7", "b8", "sa6"], "a9": [" a08", "alpha9", "sa10", " a99", "a7", "sa09", " a7", "alpha7", "a08", "sa99", "alpha12", "ca9", "ca99", "ca10", "a09", "A9", "ca09", "alpha08", "sa9", " a09", " a12", "A08", "a12", "A7", "A12", "a99"], "a10": ["ae12", "ae9", "e8", "p6", "an10", "p8", " a6", "an6", "ae8", "e9", "e10", "ae10", "an8", "e12", " a12", "a6", "a12", "p9", "p10", "an9"], "a11": ["A131", "A11", "A13", "e11", "e13", "A14", "as12", "e14", "a13", "as11", "as131", "as14", "a14", " a13", " a131", "e12", " a12", "a12", " a14", "A12", "a131"], "ps": ["ls", "cs", "pt", "css", "pres", "gs", "ams", "abilities", "pp", "points", "plays", "ts", "amps", "ds", "fs", "ys", "vs", "ms", "fps", "mp", "ats", "s", "aps", "params", "pos", "parts", "caps", "checks", "rs", "ops", "p", "ars", "pd", "pe", "Ps", "bs", "als", "sp", "pots", "ips", "helps", "pers", "eps", "PS", "its", "js", "ports", "pse", "ress", "pes", "ks", "pps", "qs", "ups", "ap", "es", "pr", "ims", "ns", "pas"], "url": ["ls", "dl", "http", "URL", "uu", "open", "r", "abs", "l", "ur", "gl", "link", "https", "browser", "str", "loader", "web", "nl", "proxy", "u", "cp", "uri", "gc", "rl", "il", "socket", "impl", "log", "Url", "ssl", "connection", "ul", "ll", "pl", "sl"], "request": ["change", "message", "pull", "rest", "http", "cgi", "QUEST", "query", "r", "open", "task", "session", "pc", "quest", "job", "client", "web", "builder", "req", "continue", "Request", "next", "q", "close", "method", "initial", "command", "result", "socket", "requ", "position", "get", "re", "process", "ssl", "connection", "resource", "server", "create", "start", "response", "trip", "connect", "complete", "reset", "call"]}}
{"id1": "18046717", "id2": "17792212", "code1": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"getFullClassName": ["getFullClassNames", "getFullMethodNames", "getFullMethodName", "getRealMethodname", "getFullMethodClass", "getFullFullname", "getRealClassname", "getFullFullNames", "getFullFullClass", "getRealMethodNames", "getFullClassname", "getFullclassName", "getRealMethodClass", "getRealClassClass", "getFullclassNames", "getRealClassNames", "getRealClassName", "getRealMethodName", "getFullclassClass", "getFullMethodname", "getFullFullName", "getFullclassname", "getFullClassClass"], "url": ["ls", "path", "dl", "cert", "http", "URL", "fail", "open", "address", "r", "file", "zip", "l", "ur", "link", "str", "browser", "job", "web", "html", "nl", "loc", "domain", "uri", "char", "xml", "kl", "ref", "mail", "Url", "log", "ssl", "resource", "ul", "location", "ll", "mount", "sl"], "className": [" classEvent", "ClassName", "cellString", "CLASSNAME", "classString", "classInfo", " classNames", "moduleName", "caseName", "cellDef", "CLASSEvent", " classClass", "moduleType", " classname", "interfaceNAME", "moduleClass", " classNAME", " classString", "classname", "classClass", "packageNames", "ClassNames", "Classname", " classInfo", "classDef", "cellType", " classType", "caseType", "ClassString", "interfaceEvent", "modulename", "CLASSName", "packageType", "ClassDef", "classEvent", "caseDef", "caseString", "cellName", "packageName", "classNames", "ClassType", "classType", "interfaceInfo", "ClassClass", "classNAME", "interfaceName", "CLASSInfo", "packageString"], "jis": ["ijris", "ujbs", "wris", " jais", "zipiss", "jris", "jus", "Jiss", "zris", " jbs", "ijiss", "jais", "wis", "zais", "jIS", " jiss", "zus", "zipis", "zipus", "Jis", "ijIS", "ujis", " jIS", " jris", "ijis", "jbs", "wbs", "ujris", "zipris", " jus", "zIS", "Jais", "jiss", "zis", "ujais", "ziss", "wais"], "zentry": ["gzlink", "ozentry", "zenter", "zlink", "ozEntry", "ziter", "zipoffice", "zipentry", "jentry", " zEntry", "zsystem", " zspace", "qentry", "jiter", "joffice", " zipEntry", "zspace", "jlink", " zipiter", "gzentry", "jEntry", "zoffice", "jenter", "ozsystem", "jspace", " zlink", "zipsystem", " zipenter", "qEntry", "qiter", " zipentry", "jsystem", "gzEntry", "gzspace", "qenter", "zipEntry", "ozoffice", "zEntry"], "name": ["message", "path", "item", "init", "format", "full", "title", "on", "number", "all", "id", "search", "info", "wrapper", "filename", "ma", "description", "core", "file", "zone", "common", "string", "str", "entry", "size", "nm", "key", "Name", "word", "n", "term", "source", "null", "one", "family", "run", "label", "tree", "part", "named", "old", "state", "text", "length", "ame", "min", "parent", "no", "NAME", "me", "names", "raw", "order", "total", "max", "base", "mem", "now", "admin", "comment", "prefix", "local"], "lastPos": ["latestPOS", "oldPos", " lastpos", "latestPosition", "lastLoc", " lastPosition", "oldpos", "lastpos", "latestPos", "latestRes", "leftLoc", "rightpos", "lastPOS", "rightPos", "latestDef", "latestLoc", "lastPosition", "lastRes", "leftPos", "rightPOS", "firstPosition", " lastLoc", "latestpos", "lastDef", " lastDef", " lastPOS", "firstPos", "leftpos", "oldLoc", " lastRes", "firstLoc", "firstRes", "rightDef", "leftPOS", "oldPOS"], "pos": ["pt", "ex", "pres", "slot", "pat", "conf", "offset", "prop", "z", "col", "cond", "pc", "add", "cos", "Pos", "oss", "apo", "bo", "proc", "top", "size", "prot", "zero", "x", "loc", "n", "floor", "end", "val", "p", "pro", "POS", "def", "off", "addr", "len", "op", "part", "lit", "sp", "ind", "exp", "position", "post", "port", "po", "no", "min", "trans", "ps", "i", "co", "max", "yes", "pg", "res", "start", "pose", "pi", "point", "pl", "px", "index", "diff", "pr", "doc"]}}
{"id1": "5061606", "id2": "18570190", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNeccessary", "createSettingsIfNacessary", "createSettingsIfNeccesar", "createSettingsIfNecessed", "createSettingsIfNacessed", "createSettingsIfNecessesary", "createSettingsIfNeccessible", "createSettingsIfNacessesary", "createSettingsIfNacessesible", "createSettingsIfNecessar", "createSettingsIfNacessar", "createSettingsIfNecessible", "createSettingsIfNeccesible", "createSettingsIfNecessesar", "createSettingsIfNacessesar", "createSettingsIfNacessible", "createSettingsIfNecessesed", "createSettingsIfNeccessar", "createSettingsIfNacessesed", "createSettingsIfNeccesed", "createSettingsIfNeccessed", "createSettingsIfNecessesible", "createSettingsIfNeccesary"], "out": ["inv", "obj", "ex", "init", "or", "OUT", "net", "note", "ou", "on", "it", "write", "f", "err", "output", "that", "nt", "ion", "file", "oe", "list", "t", "cos", "oss", "bo", "client", "again", "Out", "n", "end", "null", "one", "os", "go", "ent", "exit", "cn", "gc", "to", "flush", "off", "up", "io", "ne", "sys", "outs", "w", "report", "ch", "writer", "conv", "OU", "cho", "log", "yes", "con", "conn", "co", "server", "print", "aos", "res", "o", "outer", "timeout", "max", "ot", "can", "comment"], "fSettings": ["eSettings", "finalOptions", "sfsettings", "hsettings", "finalsettings", "finalSetting", "esettings", "hSetting", "cfSetting", "fChanges", "sfOptions", "sfSetup", "cfSettings", " fSetup", "finalSettings", "cfSetup", "bfSettings", "fsettings", "cfsettings", "sfSetting", "sfSettings", "fSetup", " fSetting", "bfsettings", "sfChanges", "fSetting", "bfSetting", " fChanges", "bfChanges", "fOptions", "hSettings", "eSetting", " fsettings", " fOptions"], "src": ["dest", "ls", "th", "sc", "url", "filename", "tmp", "pkg", "ser", "config", "dir", "rx", "sr", "rc", "rt", "ur", "sq", "root", "loc", "fn", "rs", "txt", "source", "img", "rl", "attr", "sys", "spec", "view", "desc", "sb", "upload", "cont", "sf", "resource", "syn", "cur", "rel", "sit"], "in": ["In", "ad", "iter", "is", "sin", "init", "input", "rin", "id", "info", "r", "ln", "IN", "inn", "and", "l", "inside", "inf", "bin", "vin", "ins", "n", "source", "from", "en", "din", "isin", "cin", "i", "gin", " din", "inner"]}}
{"id1": "8119563", "id2": "3514286", "code1": "    protected boolean checkLink(URL url) {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return true;\n        } catch (IOException e) {\n            MsgLog.error(\"DapParser.checkLink(): IOException: \" + e.toString());\n            return false;\n        }\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"checkLink": [" checklink", " checkUrl", "processLinks", "checkUrl", " checkLinks", "openLink", "processLink", "openLinks", "openUrl", "processUrl", "checkLinks", "processlink", "openlink", "checklink"], "url": ["b", "path", "dl", "cert", "http", "URL", "all", "address", "f", "file", "l", "ur", "link", "string", "str", "browser", "job", "email", "nl", "n", "host", "uri", "char", "rl", "xml", "ref", "build", "Url", "ssl", "server", "resource", "print", "location", "base", "name", "ll", "sl"], "connection": ["operation", "message", "generation", "Connection", "net", "function", "number", "application", "open", "database", "ion", "description", "session", "reference", "link", "network", "client", "directory", "entry", "system", "c", "character", "management", "connected", "category", "way", "version", "nc", "command", "position", "statement", "city", "conn", "condition", "resource", "communication", "pointer", "response", "connect", "channel", "service", "relation"]}}
{"id1": "947406", "id2": "14877116", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "label": 1, "substitutes": {"copy": ["ls", "init", "download", "save", "Cop", "sync", "paste", "map", " cp", "csv", "link", "load", " replicate", "printf", "cat", "clone", " cop", "move", "cp", "gc", "Copy", "slice", "delete", "upload", "transfer", "create", " Copy", "println"], "src": ["ls", "init", "input", "sc", "Source", "usr", "url", "subject", "tmp", "pkg", "ser", "config", "sec", "rx", "sr", "rc", "ctr", "sq", "inst", "req", "fx", "ins", "rs", "source", "from", "orig", "img", "bs", "rl", "sys", "st", "sb", "iv", "dist", "sf", "start", "cur", "rel", "sit", "obs"], "dest": ["rest", "id", "usr", "del", "home", "tmp", "des", "dir", "Dest", "https", "test", "origin", "req", "loc", "end", "source", "nom", "orig", "pub", "good", "decl", "master", "est", "mod", "st", "desc", "target", "mm", "temp", "deg", "trans", "dist", "cont", "d", "nw", "pas"], "in": ["In", "read", "user", "iter", "pin", "is", "sin", "or", "init", "net", "on", "input", "rin", "it", "win", "al", "info", "r", "all", "ain", "ma", "IN", "ln", "inn", "m", "file", "l", "inside", "inf", "bin", "ai", "ar", "ins", "inc", "mc", "from", "en", "ac", "mi", "act", "ini", "up", "ind", "st", "oin", "din", "mm", "isin", "min", "ie", "cin", "con", "conn", "i", "gin", "ck", "co", "raw", "inner", "o", "local", "doc"], "out": ["obj", "user", "ex", "at", "net", "OUT", "note", "ou", "on", "it", "write", "output", "oe", "nt", "file", "list", "rem", "t", "cos", "oss", "bin", "client", "gt", "Out", "null", "one", "os", "en", "not", "cn", "cmd", "to", "flush", "up", "io", "ne", "sys", "outs", "writer", "conv", "mit", "no", "nin", "con", "conn", "co", "sum", "inner", "can", "aos", "o", "outer", "res", "ot", "ns"], "buf": ["b", "block", "bytes", "prop", "uf", "mu", "cap", "pkg", "col", "bl", "bc", "rb", "queue", "cb", "cat", "Buffer", "font", "br", "cv", "img", "cmd", "box", "batch", "bs", "good", "len", "bag", "bar", "msg", "cam", "seq", "tab", "ref", "conv", "bh", "aka", "Buff", "log", "buffer", "mb", "vec", "pad", "fb", "cf", "cur", "mem", "buff", "bus", "db", "gen"], "n": ["b", "ren", "ni", "on", "nn", "number", "yn", "k", "z", "N", "nt", "m", "ln", "t", "l", "nor", "gn", "nm", "nl", "sn", "en", "cn", "num", "nan", "len", "ne", "nc", "acc", "nu", "y", "na", "no", "an", "nb", "mn", "i", "names", "nos", "d", "syn", "v", "span", "max", "ll", "j", " l", "ns", "un"]}}
{"id1": "442381", "id2": "13152325", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doBuildUpdate", " doApplicationInfo", "doFeaturecheck", "doApplicationQuery", "doVersioncheck", " doApplicationTest", " doVersionsTest", "doImageInfo", " doVersioncheck", "doFeatureCheck", "doBuildCheck", "doBuildcheck", "doFeatureQuery", " doVersionTest", " doVersionInfo", " doApplicationCheck", "doVersionUpdate", "doImageTest", " doVersionsCheck", "doVersionQuery", "doVersionInfo", "doFeatureTest", "doApplicationTest", "doVersionsTest", "doFeatureUpdate", " doVersionUpdate", " doApplicationQuery", "doVersionTest", "doFeatureInfo", "doImageCheck", "doVersionscheck", "doVersionsUpdate", "doImageQuery", " doVersionQuery", " doVersionsUpdate", " doVersionscheck", "doBuildTest", "doApplicationInfo", "doApplicationCheck", "doVersionsCheck"], "view": ["block", "check", "review", "display", "http", "input", "component", "query", "update", "subject", "widget", "context", "project", "file", "lock", "browser", "cell", "VIEW", "client", "virtual", "html", "self", "window", "image", "row", "this", "page", "q", "vm", "cv", "h", "box", "manager", "tv", "layout", "index", "tree", "version", "document", "eye", "show", "report", "form", "see", "port", "engine", "controller", "ml", "buffer", "server", "print", "v", "model", "views", "View", "iew", "pool", "call"], "url": ["b", "dl", "http", "URL", "r", "address", "f", "file", "l", "ur", "gl", "link", "str", "browser", "client", "job", "html", "nl", "loc", "domain", "hl", "lb", "host", "mount", "uri", "char", "rl", "ref", "get", "mail", "Url", "log", "build", "ssl", "oul", "ul", "v", "bel", "rel", "ll", "pl", "sl"], "in": ["In", "is", "sin", "init", "on", "out", "input", "rin", "info", "f", "ln", "ain", "IN", "inn", "reader", "l", "inf", "vin", " IN", "stream", "ins", "n", "source", "inc", "from", "body", "mat", "din", "isin", "cin", "mn", "i", "gin", " din", "asin", "inner", "can"], "bin": ["b", "sin", "init", "obin", "thin", "out", "cache", "rin", "all", "win", "binary", "lib", "ln", "file", "bl", "session", "inn", "reader", "cos", "brain", "rb", "abin", "cb", "bi", " Bin", "ins", "bg", "jin", "len", "sam", " bins", "ebin", "body", "din", "conv", "stock", "by", "nb", "bn", "re", "mon", "cin", "con", "buffer", "gin", " din", "spin", "ran", "inner", "buff", "bed", "db", "bur", "local"], "line": ["LINE", "message", "block", "range", "liner", "channel", "iter", "parse", "lo", "lane", "err", "ln", "file", "cat", "inline", "l", "ine", "frame", "string", "eline", "cell", "tile", "link", "record", "trace", "lin", "entry", "job", "key", "rule", "word", "stream", "row", "section", "page", "le", "next", "detail", "cmd", "Line", " block", "char", "part", "field", "sequence", "style", "port", "log", "ice", "chain", "lines", "zone", "stay", "print", "code", "base", "sample", "column", "comment", "point", "status"], "develBuild": ["deVELBuild", "DeVELbuild", "duVELBuild", "devBoot", "duffbuild", "depobuild", "develBuilt", "deeltaRelease", "duVELbuild", "deffBuild", "deffBuilder", "develRelease", "duvelbuild", "desVELLoad", "desVELbuild", "duvelBoot", "deployBoot", "devLog", "deeltaLoad", "DevelBuilt", "duvelBuild", "DeVELBuild", "depoBuild", "duffBuild", "deVELLoad", "deVELBoot", "deVELBuilt", "devbuild", "duvelBuilder", "deeltaBuild", "develBuilder", "duvelBuilt", "DevelLog", "deVELbuild", "deffbuild", "desvelbuild", "Develbuild", "desvelBuild", "deployLoad", "duffBuilt", "deployBuilt", "depoBuilt", "develLog", "depoLog", "duVELBuilder", "deploybuild", "develBoot", "desVELBuild", "devBuild", "deVELBuilder", "DeVELLog", "deVELRelease", "deployRelease", "duVELBoot", "deployBuilder", "desvelRelease", "devBuilder", "deployBuild", "DevelBuild", "deffBuilt", "DeVELBuilt", "deVELLog", "desvelLoad", "duffBuilder", "develLoad", "devBuilt", "desVELRelease", "deeltabuild", "develbuild"], "stableBuild": ["secureCraft", "stableBind", "stableCraft", " stableBuilder", " stablebuild", "activeMake", "devMake", "confirmedLong", "stableLong", "stablebuild", " unstableBuild", " unstableCraft", "stableMake", " unstableBuilder", " unstableLong", "securebuild", " stableBoot", " unstableBoot", " stableCraft", "devbuild", " stableLong", "devBind", "confirmedBuild", " stableBind", " stableMake", "secureBuilder", " unstableBind", "devBuild", "confirmedBoot", "stableBoot", "confirmedbuild", "secureBuild", " unstablebuild", "devBuilder", "stableBuilder", "activeBuilder", "activeBuild", "activebuild"]}}
{"id1": "7468827", "id2": "13565787", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 0, "substitutes": {"run": ["launch", "block", "download", "f", "func", "login", "task", "exec", "test", "submit", "fin", "go", "uri", "unit", "running", "Run", "runner", "loop", "work", "process", " Run", "start", "execute", "invoke", "poll", "begin", "hello", "call"], "con": ["com", "sin", "Conn", "acon", "conf", "cgi", "out", "win", "open", "comm", "bon", "ain", "ln", "Con", "fc", "pc", "cos", "rc", "xc", "cc", "cl", "c", "go", "cp", "en", "cn", "ct", "ic", "don", "act", "canon", "cone", "gc", "cm", "nc", "const", "cal", "ch", "conv", "CON", "dial", "re", "ctrl", "conn", "connection", "cont", "co", "ran", "syn", "cons", "cf", "cur", "can", "pen", "create", "connect", "ob", "pl", "mos", "un"], "encodedPassword": [" encressedPassword", "encodedEmail", "encryptedpassword", "encryptedEmail", " encodedSecret", " encressedpassword", "ecodedpassword", "ecodingPassword", " encressedEmail", "encryptedPass", "enccodedpassword", " encodedEmail", "encodedPass", "encryptedSecret", "encodingPass", "enccodedPass", "ecodingPass", "ecodedPass", "enccodedPassword", "encressedSecret", "encodingSecret", "encodedpassword", "encodingPassword", " encressedSecret", "encressedpassword", "ecodedPassword", "encodingpassword", "encodingEmail", "encressedEmail", " encodedpassword", "ecodingpassword", "encressedPassword", "encodedSecret", "encryptedPassword"], "encoder": ["enater", "ecoding", "enoding", "encoded", "ecoder", "encater", "Encoder", "enoder", "decoder", "Encoding", "ecODE", " encoding", "Encaser", " encaser", "encoding", "enoded", "enODE", "enaser", " encater", "decoding", "Encater", "encODE", "ecoded", "decoded", "encaser", "decODE"], "in": ["In", "read", "ex", "iter", "is", "sin", "init", "on", "out", "input", "rin", "it", "info", "ain", "per", "IN", "inn", "inside", "inf", "ai", "bin", "ri", "ins", "source", "inc", "from", "p", "en", "ic", "up", "io", "ind", "oin", "din", "isin", "get", "cin", "i", "gin", "asin", "inner", "un"], "fos": ["flos", "pios", "ffoes", " fout", "Fout", "fres", " foes", "fios", "boes", "boss", "poss", "Foes", "ffout", "pos", " fios", "foss", "Foss", "FOS", "bos", "fOS", "bres", "floes", "floss", "fout", "ffos", " foss", "Fos", "flres", "bios", "foes", "ffOS", " fOS", "flios", "poes", " fres"], "bout": ["sbout", "BOut", "sbOut", " bOut", "backinner", "binner", "bbout", "bbouts", "bco", "nbouter", "Binner", "wbout", " bouts", " bco", " bex", " bcache", "nbex", " bcan", "boe", "obex", "obouts", "backout", "sboe", "sbouts", "obco", "bbex", "wbex", "bboe", "Bcan", "bbco", "wbcache", "bex", "wbouter", " binner", "backcan", "bcan", " boe", "nbcache", "backOut", "bouts", "nbout", "bouter", " bouter", "Bout", "bOut", "bcache", "obout", "bbOut"], "data": ["message", "block", "bytes", "extra", "dl", "value", " DATA", "out", "all", "al", "mu", "info", "video", "done", "what", "size", "zero", "entry", "window", "image", "word", "next", "rew", "n", "row", "def", "good", "batch", "default", "valid", "result", "sequence", "DATA", "body", "mat", "step", "dat", "log", "chain", "buffer", "ata", "raw", "content", "d", "sample", "rel", "table", "normal"], "x": ["xf", "ex", "xi", "k", " i", "z", "xxxxxxxx", "rx", "lex", "t", "l", "xc", "ix", "tx", "wx", "fx", "xes", "n", "xp", "xs", "xxxx", "p", "xxx", "pe", "act", "ax", "j", "y", "w", "inx", "ux", "xy", "xa", "step", "ox", "no", "dx", "i", "d", "v", "X", "px", "index", "xx", "mx"], "lastIteraction": ["lastInteration", " lastIterative", "lastIterval", "lastIteration", " lastIterval", "lastiteration", "lastiteraction", " lastiteraction", " lastiteration", "lastinteraction", "lastiterative", "lastInteraction", "lastiterval", "lastinterval", "lastInterative", " lastIteration", "lastinteration", " lastiterval", "lastIterative", "lastInterval", "lastinterative", " lastiterative"], "e": ["ex", "or", "note", "r", "f", "err", "be", "oe", "error", "m", "t", "s", "l", "ate", "se", "ine", "ae", "c", "de", "n", "le", "a", "p", "en", "u", "h", "pe", "ent", "ed", "eeee", "er", "ne", "eu", "element", "y", "w", "exp", "E", "te", "ie", "es", "g", "re", "ec", "me", "i", "event", "d", "v", "ei", "o", "ev", "ee"]}}
{"id1": "539195", "id2": "8320469", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 0, "substitutes": {"copy": ["ls", "init", "download", "save", "Cop", "sync", " cp", "csv", "link", "load", "cat", "clone", " cop", "move", "cop", "cp", "gc", "to", "dump", "Copy", "slice", "delete", "upload", "transfer", "create", " Copy", "replace", "println"], "src": ["ls", "pres", "init", "sin", "spr", "input", "sc", "url", "usr", "Source", "filename", "urg", "pkg", "ser", "sec", "rx", "sr", "rc", "rt", "ctr", "str", "sq", "inst", "req", "loc", "ins", "rs", "source", "txt", "from", "orig", "host", "this", "img", "uri", "comp", "in", "addr", "rl", "attr", "sys", "spec", "st", "imp", "desc", "sb", "iv", "ident", "sel", "dist", "start", "cur", "rel", "sit"], "dest": ["rest", "it", "id", "usr", "del", "home", "tmp", "dir", "Dest", "https", "gt", "test", "origin", "req", "sup", "cat", "loc", "end", "source", "nom", "them", "orig", "p", "decl", "opt", "way", "master", "est", "st", "exp", "target", "deg", "temp", "trans", "dist", "cont", "d", "nw", "mem"], "ifp": ["ifpc", " ifpa", "ffpa", "ify", "iby", "iftpc", "ihp", "ibp", "ifop", "ifcp", "ihe", "alftp", "ffy", "Ifp", "iftp", "ifsp", "ihcp", " ife", "afp", "Ifop", "ffsp", "ifpa", "ffp", "afpp", "Ifcp", "afpc", "aftp", "ibpa", "ifpp", " ify", "alfpc", "iftpp", " ifop", "Ife", "ibsp", " ifcp", "ihop", " ifsp", "alfp", "ifttp", "alfpp", "ife"], "ofp": ["OFd", "OFjp", "Ofjp", "OFP", "Ofd", "Ofproc", "ofjp", " ofproc", "OFp", "offd", "ofP", "Ofp", " ofsp", "ofd", "offp", " ofd", "orfp", "ofproc", "orfd", "orfproc", "orfsp", "offjp", "Ofsp", "OfP", "offP", "ofsp"], "fis": ["flais", "gi", "fios", "wi", "Fis", "wis", "Fais", "flai", "fiis", "gais", "gis", "fiiss", "fiss", "fais", "giss", " fais", "fliss", "Fist", "fai", "Fiss", "fi", "Fai", "wiss", " fai", " fiss", " fi", "fiist", "fist", " fist", "flis", "Fos", "wais"], "fos": ["flos", "waos", " foses", " foes", "fios", "fiaos", "wios", "Foes", "foses", " fios", "Foss", "foss", "Foses", "fiis", "floes", "fioes", " foss", "wos", "woes", "foes", "woss", "faos", "woses", "flis", "flaos", "flios", "Fos", " faos"], "b": ["reb", "bit", "k", "binary", "gb", "f", "lib", "be", "z", "ab", "bis", "bc", "l", "rb", "cb", "bi", "bg", "br", "p", "bits", "h", "batch", "bs", "j", "bar", "y", "body", "ch", "sb", "eb", "g", "nb", "bd", "B", "bb", "mb", "wb", "fb", "d", "v", "base", "blue", "ob", "db", "pb"]}}
{"id1": "5237257", "id2": "15445861", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"download": ["init", " recover", " downloading", "write", "open", "save", " browse", " drop", " restore", "file", "paste", "load", " zip", "dump", "copy", "delete", " Download", "upload", " dump", "get", " upload", " downloaded", "Download", "export", " downloads", " seek", " checkpoint", " retrieve"], "fileName": [" fileType", " fileFilename", "resourcePath", "filename", "projectName", "fileType", "resourceTime", "FILEName", "imagePath", "fileTime", "projectPath", "FileName", "projectname", "fileFilename", "FilePath", "FileType", " filename", "FileTime", "resourceType", "FILEPath", " fileTime", "projectFilename", "resourceName", "FILEFilename", "FILEname", "imageName"], "filePath": ["resourceUrl", "languagePath", " filepath", "FileP", "resourcePath", "FILEStart", "filepath", "ileStart", "ileName", "FILEName", "FILEP", "FILEpath", "FILEUrl", "ileP", "fileStart", "FileName", "languageId", "languageName", "FilePath", "fileUrl", "FileStart", "resourcepath", "ilePath", " fileId", "FILEPath", "fileId", "resourceName", "fileP", " fileUrl", "FileId"], "in": ["In", "read", "iter", "is", "init", "or", "sin", "net", "on", "input", "rin", "it", "win", "al", "r", "f", "id", "ain", "m", "IN", "ln", "inn", "login", "l", "inside", "inf", "bin", "ai", "ar", "ins", "one", "n", "from", "inc", "en", "mi", "up", "io", "el", "ind", "st", "im", "din", "isin", "ie", "re", "nin", "cin", "con", "i", "gin", "co", "inner", "o", "pi", "local", "ini"], "out": ["obj", "user", "ex", "at", "or", "net", "OUT", "note", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "cos", "oss", "client", "gt", "boot", "Out", "n", "end", "null", "os", "ent", "p", "not", "cn", "to", "up", "io", "ne", "op", "sys", "outs", "w", "ch", "conv", "OU", "po", "na", "no", "nin", "conn", "con", "i", "co", "inner", "can", "aos", "o", "v", "outer", "name", "ns", "we"]}}
{"id1": "19584877", "id2": "8182932", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeStringToFile", "encodeFileToFiles", "encodeStringAsDisk", "encodeFileFromStream", "encodeFileFromDisk", "encodeStringAsFile", "encodeFileAsFiles", "encodeFiletoFile", "encodeFiletoFiles", "encodeStringToStream", "encodeFileAsFile", "encodeFileAsDisk", "encodeFileAsStream", "encodeFileFromFile", "encodeStringAsStream", "encodeStringToDisk", "encodeFiletoDisk", "encodeFiletoStream", "encodeStringToFiles", "encodeFileToStream", "encodeStringAsFiles", "encodeFileToDisk"], "infile": ["InFile", "inputfile", "outbase", "inbase", " inFile", "inFile", "outpath", "Inbase", "outFile", "Inpath", " infilename", "Infile", "outfilename", "infilename", "inpath", "inputpath", "inputfilename", "inputFile", " inpath", " inbase"], "outfile": ["inname", "newfile", " outname", "newname", "newfilename", "newFile", "inFile", "tofile", "todir", "fromfp", " outfilename", "infp", "outFile", "fromfile", "outdir", "indir", "fromdir", "tofp", "toFile", "outfp", " outFile", "outfilename", "infilename", "fromFile", "outname"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "image", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ro", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "null", "fn", "os", "en", "cn", "to", "flush", "up", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "can", "aos", "o", "res", "outer", "inner", "ot"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "queue", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "length", "black", "stack", "temp", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", "commit", "ccess", "cess", "value", "accept", "fail", "growth", "warning", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "ith", "successful", "good", "please", "ceed", "town", "result", "valid", " Success", "successfully", " okay", " failure", "ratulations", "photo", "sufficient", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "300397", "id2": "942693", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrites", "readAndRepWrite", "readAndResWrite", "readAndRewend", "readAndResend", "readAndrewrite", "readAndrewWrite", "readAndResrite", "readAndRewrites", "readAndrewrites", "readAndReprite", "readAndrewend", "readAndRewWrite", "readAndRepend", "readAndReprites"], "inFile": ["InFile", "inputFilename", "docFile", "docFILE", "iFILE", "iFilename", "INTime", "inFILE", "InFilename", "initPlace", "initFilename", "inputPlace", "docTime", "inFace", "outfile", "infile", "iFile", " inFilename", "initFile", "inPlace", "INPlace", "docFilename", " infile", "inTime", "Infile", "initFace", "INFace", "iTime", "INFilename", "INFile", "INFILE", "inputFile", "inputFace", "inFilename", "outFilename"], "outFile": ["reportFile", " outFilename", "checkFilename", "outFILE", "inFILE", "toFILE", "reportFILE", "tofile", "nameFilename", "outfile", "infile", " outFILE", "reportfile", "reportFilename", "toFilename", "namefile", "nameFile", "toFile", "checkFile", " outfile", "checkFILE", "inFilename", "outFilename", "nameFILE", "checkfile"], "iis": [" iris", "iiIs", "liris", "iIS", "eis", "aiis", "Iiss", "liisc", "Ii", "liIs", "liis", "eIS", "iiisc", "ii", " iiss", "iiss", "iiis", "iiris", " iIs", "iIs", " iIS", "diIs", " ii", "iisc", "IIs", "eIs", "aiIS", "dii", "aiIs", "diis", " iisc", "iris", "Iis", "diiss"], "dcmParser": ["dgrParser", " dpmListener", "dpcReader", "dpmAssistant", "DpmReader", "dcrparser", "dcommReader", " dpmarser", "dcmListener", "dmoduleReader", "dmoduleAssistant", " dpmStatement", "dpmLoader", "dmmParser", " dcmarser", " dpmparser", "dcommListener", "deromParser", "dpmBuilder", "dromparser", "dcmAdapter", "dcrParser", "dfmParser", "dpmStatement", "dmmmReader", " dcmLoader", "dcomReader", "dcmBuilder", "dromAssistant", "DpmAdapter", "dcrBuilder", "dpmPrivate", " dcmPar", "dcomBuilder", "dcrReader", " dpmReader", "dcommAssistant", " dpmLoader", " dcmStatement", " dcmAssistant", "dmmarser", "dmmparser", "DcmBuilder", "dpmarser", "dgrStatement", " dcmBuilder", "dmmmparser", "dcmparser", "dcfStatement", "dromReader", "dcmAssistant", "decmParser", " dcmListener", "deromarser", "Dpmparser", "decmReader", "DcmParser", "dpmAdapter", " dpmParser", "dcmStatement", "dgrReader", " dpmPar", "DpmPar", "dmReader", "decmarser", "dpcAssistant", "DpmBuilder", "dmmReader", "decmparser", "drumParser", "dromarser", " dpmBuilder", " dcmPrivate", "dpcParser", " dpmAssistant", "dcmLoader", "DcmReader", "dromParser", "dmmmParser", " dcmparser", "dmmAdapter", "DpmParser", "drumReader", "dfmReader", "dpmReader", "dgrPar", "dcmReader", "dcfReader", "deromReader", "Dcmparser", "deromparser", "dcommParser", "dmparser", "drumPar", " dcmReader", "dcmarser", "dmarser", "dcmPrivate", "dpmparser", "dcmPar", "dmParser", "dmmmAdapter", "dpcPrivate", "dcfPar", "dromListener", "dcomParser", "dmodulePrivate", "DcmAdapter", "drumBuilder", "dfmBuilder", "dfmLoader", "dpmListener", "dcomLoader", "dpmPar", "dmoduleParser", "dpmParser", "dcfParser", "DcmPar", " dpmPrivate"], "ds": ["ls", "cs", "dos", "dl", "gs", "eds", "dh", "ils", "fs", "des", "vs", "ys", "da", "der", "sv", "s", "gd", "dds", "sets", " des", "as", "ads", "hd", "dq", "rs", "uds", "tes", "xs", "df", "os", "details", "ins", "pd", "dd", "services", "in", "bs", "Ds", "ods", "sys", "obs", "outs", "dt", "hs", "pers", " DS", "eps", "its", "js", "dat", "bd", "ps", "dx", "ks", "ss", "drivers", "sd", "d", "aos", "qs", "data", "ws", "DS", "db", "es", "ims", "ns"], "pdReader": ["ddHelper", "ddParser", "pdLoader", "xdHelper", "pdParser", "tdWriter", "xdLoader", "tdRead", "ddLoader", "vdLoader", "pdRead", "dpCar", "dpLoader", "ddWriter", "ddReader", "pdCar", "ddRunner", "dpRunner", "pedReader", "tdParser", "hdParser", "tdReader", "pedLoader", "pedCar", "hdRead", "pdRunner", "vdHelper", "xdReader", "pdHelper", "hdWriter", "ddRead", "xdWriter", "dpReader", "vdReader", "pedRunner", "hdReader", "ddCar", "vdWriter"], "out": ["over", "full", "on", " err", "err", "t", "str", "ins", "p", "ent", "outs", "ch", "writer", "log", "conn", "con", "co", "sum", "sw", "v", "o", "auto", "name", "status", "gen", "inv", "obj", "ex", "ou", "all", "id", "nt", "s", "cb", "c", "end", "txt", "os", "nr", "cn", "in", "desc", "conv", "serv", "raw", "inner", "outer", "pool", "cfg", "at", "net", "tmp", "list", "pos", "Out", "n", "en", "up", "io", "sys", "w", "js", "aos", "res", "data", "we", "OUT", "cache", "it", "output", "oss", "client", "gt", "one", "null", "screen", "go", "cmd", "to", "opt", "flush", "msg", "gr", "inter"], "dcmEncParam": ["dcmEnPar", "dcmEnVal", "dcmencCmd", "dcmEncVal", "dcmEnParam", "dcmencParam", "dcmEscPar", "dmmencParam", "dcmDecParam", "dmmEncCmd", "dcmEncCmd", "dcmencNum", "dmmEncMsg", "dmmencNum", "dmmEncPar", "dcmEncPar", "dcmEscNum", "dmmEnPar", "dcmDecCmd", "dcmEncMsg", "dcmEnNum", "dmmEnNum", "dcmEscVal", "dcmDecMsg", "dcmEscParam", "dmmEncParam", "dmmencCmd", "dmmEnParam", "dmmEncNum", "dcmEncNum", "dcmDecNum", "dcmencPar", "dcmencMsg", "dmmEncVal", "dmmencMsg"], "pdWriter": ["dpEditor", "PDReader", "tdWriter", "dpWriter", "pidWrite", "PDWriter", "pdwriter", "pidWriter", "PDWrite", "tdWriting", "tdReader", "PDEditor", "pidwriter", "pidWriting", "dpWrite", "tdwriter", "pcWriter", "pcWrite", "pdWrite", "pdWriting", "pcwriter", "tdWrite", "pdEditor", "pcWriting", "dpReader", "tdEditor"]}}
{"id1": "11305840", "id2": "7296597", "code1": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "code2": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"setUpdateCliente": [" setupdateclienta", " setupdateClientes", " setUpdatePea", " setUpdateClienta", " setUpdatePersone", " setupdatecliento", " setUpdatePersono", " setupdatecliente", " setUpdatePersona", " setupdateCliente", " setupdateclientes", " setUpdatePees", " setUpdateCliento", " setUpdateclientes", " setUpdateClientes", " setupdateCliento", " setUpdateclienta", " setupdateClienta", " setUpdatecliente", " setUpdatecliento", " setUpdatePee", " setUpdatePeo", " setUpdatePersones"], "IDcliente": ["idClientel", "IDClientoe", "IDsclienti", "IDclientes", "IDclientE", "IDcellE", "IDClientee", "idClientes", "IDsClienti", "IDcliento", "IDactivee", "IDcelle", "idclientoe", "IDCliente", "IDstai", "IDClientE", "IDactiveE", "idclientes", "IDclienti", "IDstao", "IDsClientE", "IDcodee", "IDcodel", "IDsclientE", "idCliente", "idclientee", "idclientE", "IDcode", "IDactivees", "IDClienti", "IDClientes", "idclientel", "IDclientoe", "IDCliento", "idClientoe", "IDclientel", "idClientee", "IDactiveel", "IDparentoe", "IDstae", "IDcodoe", "IDcello", "IDscliento", "IDclientee", "IDstaE", "IDsCliento", "IDClientel", "idClientE", "IDparente", "IDcodes", "idcliente", "IDcelli", "IDsCliente", "IDscliente", "IDparentee", "IDparentE", "IDcodE"], "nombre": [" numbreb", "numbren", " nomer", "nuclereb", " nombres", "nombr", "numbres", " nombren", " nomere", "nomeren", "nometren", " nombreb", "nomeres", "nombren", "nomer", "nuclere", " nomeres", "numbr", " nomeren", "nucleren", " numbres", "numbreb", " numbren", " nombr", "nomereb", "numbre", "nucleres", "nometre", " numbre", "nombreb", "nometr", "nombres", "nometres", "nomere"], "paterno": ["pATEReno", "tatereno", "petterna", "patereno", "pATERne", "paterlo", "catterna", "paterna", "paterne", "patern", "peterno", "catterno", "tatterno", "peterlo", "caterna", "pATERna", "pattereno", "caterlo", "patterlo", "tatern", "peterna", "pattern", "catterlo", "caterno", "pettereno", "taterno", "tatterna", "catterne", "tattereno", "patterna", "pATERlo", "pettern", "patterno", "pATERno", "petterno", "pATERn", "tattern", "peterne", "caterne", "patterne", "taterna"], "materno": [" matterNO", "mterNo", "paterNo", "materna", " materna", "maserNo", "matterno", "mATERna", "mATERnumber", " matterna", "mterna", "paterna", "masernumber", "mterNO", "maserna", "paternumber", "pATERna", "matterna", "mATERNO", "mterno", "pATERnumber", " matterno", "materNo", "matterNO", "matternumber", "maserno", " matterNo", "pATERno", " materNO", " materNo", "maternumber", "mATERNo", "materNO", "mATERno", "matterNo", "pATERNo"], "ocupacion": ["ocuptarro", "incuppacion", "ocUpaci", "ocuptac", "ocuptaton", "ocupac", "ocuptanc", "ocuptaci", "ocuppac", "ocupsidad", "ocueac", "ocupaton", "ocuparro", "incuppanc", "ocUpacion", "incupacion", "ocUpidad", "ocueacion", "icupaci", "icuptaci", "ocupidad", "ocupsaci", "incuparro", "incupanc", "incupparro", "ocuptacion", "incupac", "ocueanc", "ocuppanc", "ocUpaton", "ocuppacion", "icuptacion", "ocupanc", "icupidad", "icuptaton", "ocupsacion", "ocupaci", "ocuptidad", "incuppac", "ocuearro", "ocupparro", "ocupsaton", "icuptidad", "icupacion", "icupaton"], "rfc": ["rcos", "rfa", "mfc", "urcos", "mwic", "rtc", "trfa", "mfl", "trtc", " rfa", "rfl", "rwic", "urwic", "trco", " rtc", " rfl", "yrfa", "urfc", " rco", "rco", "yrco", "yrtc", " rcos", "trfc", "urfl", "yrfc", " rwic", "mcos"], "stm": ["statm", "strm", "semc", "seM", "STm", "strmi", "strmt", "Stmi", "STM", "sem", "statmc", "stmi", "stmc", "Stmt", "STma", "Stm", "stma", "stmt", " stem", "statM", "strem", " stmi", "statma", "STmc", "sema", "stM", "Stem", " stmt", "stem"], "update": ["commit", "change", "Update", "check", "accept", "equal", "draw", "out", "fail", "component", "it", "write", "save", "open", "ok", "apply", "use", "add", "append", "UPDATE", "feed", "send", "success", "load", "include", "fill", "submit", "continue", "run", "end", "flush", "up", "layout", "initial", "result", "valid", "set", "report", "edit", "delete", "build", "remote", "updated", "remove", "only", "complete", "module", "create", "replace", "status", "local"]}}
{"id1": "1798720", "id2": "838844", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"save": ["init", "install", "accept", "store", "register", "update", "download", " Save", "filename", "Save", "pkg", "zip", "send", "release", " seal", "dump", "archive", "version", "saving", "folder", "delete", "upload", "aw", "export", "pack", "data"], "packageName": ["pkgType", " packageNames", "moduleCode", "pkgCode", "moduleName", "pkgKey", " packagename", "pkgNames", " packageKey", "moduleNames", "PackageNames", "moduleId", "packageKey", " packageType", "packageNames", "pkgname", " packageId", " packageCode", "packageCode", "packageType", "modulename", "pkgId", "pkgName", "PackageName", "PackageType", "PackageId", "packagename", "moduleKey", "packageId"], "fileContents": ["fileBytes", " fileBytes", "fileItems", "FileContent", "pageNames", " fileIngredients", "fileIngredients", " fileValues", "packageContents", "pageItems", "byteContent", "FileValues", "FileItems", "packageNames", "byteNames", "pageContents", "pageBytes", "FileBytes", "FileNames", "packageContent", "packageIngredients", "byteContents", "fileValues", "byteValues", " fileItems", " fileContent", "fileContent", "FileContents", "FileIngredients"], "fileNames": ["moduleVaults", "issueContents", "resourceNames", "messageValues", "moduleName", "FileKeys", "resourceContents", " fileKeys", " fileTypes", " fileLeaks", "resourceTypes", "dirTypes", "resourceNumbers", " fileValues", "FileTypes", "fileNumbers", "dirNames", "messageNames", "fileLeaks", "moduleNames", "moduleContents", "FileName", "fileVaults", " fileVaults", "FileValues", "fileTypes", "fieldNumbers", " fileName", "fieldTypes", "dirLeaks", "messageKeys", "dirKeys", "issueVaults", "fileKeys", "fieldNames", "FileContents", "messageName", "FileNames", "issueNames", "fieldContents", "fileName", "issueName", "fileValues", "resourceValues", "FileLeaks", " fileNumbers"], "dirBase": ["folderBas", "pathBas", "DIRBase", "directorybase", "directoryBase", "DirBase", "DirBottom", "pkgbase", "pathbase", "pkgBase", "directorySet", " directoryBase", "dirBuilder", "DIRBuilder", "irBase", "folderBasic", "folderbase", "DIRBas", "directoryBasic", "dirbase", "directoryBas", "DirBuilder", "pathBasic", "irBas", "DirBas", "dirBottom", "dirBas", " directoryBuilder", " directoryBas", "irSet", "folderBase", "DIRBottom", "pkgSet", "pkgBas", " directoryBottom", "irbase", "dirSet", "dirBasic", "pathBase"], "packageDir": ["podD", "moduleDef", "pkgRel", "moduleFolder", "pkgDir", "installDir", "installD", "packageRel", "modulePath", "pkgFolder", "packagePath", "moduleRel", " packageD", "podDef", "podDir", "installDef", " packageDef", "installDist", " packageFolder", "podDist", " packageRel", " packagePath", " packageDist", "packageDist", "pkgDef", "packageD", "packageFolder", "moduleDir", "pkgPath", "packageDef"], "created": ["loaded", "creator", "developed", "founded", "registered", "activated", "ced", "produced", "provided", "associated", "TED", "printed", "present", "forced", " started", "checked", "recorded", "confirmed", "existent", "given", "defined", "started", "locked", "successful", "creat", "added", "raised", " generated", "reported", "called", "filled", "Created", "allowed", "mounted", "joined", "creation", "create", "arted", "installed", "made", "released", "ready", "generated"], "currentPath": ["recentPoint", "recentPath", "currentPoint", "CurrentCh", "currentName", "currentlyPath", " currentName", "currentlyCh", "CurrentParent", " currentCh", "recentParent", "recentName", " currentPoint", " currentParent", "currentParent", "currentlyFile", "currentCh", "CurrentPoint", "currentlyName", "CurrentName", " currentFile", "CurrentFile", "currentFile", "CurrentPath"], "i": ["my", "xi", "mu", "info", "f", "I", "ai", "ix", "iq", "hi", "ri", "p", "mi", "u", "batch", "jj", "phi", "iu", "v", "ei", "o", "status", "ip", "ij", "ex", "init", "cgi", "id", "oi", "ki", "key", "ii", "os", "multi", "ic", "in", "sim", "chain", "zi", "ti", "ui", "ini", "qi", "ci", "li", "m", "iy", "this", "them", "major", "ind", "exp", "im", "ie", "g", "cli", "j", "index", "di", "ami", "gi", "it", "ski", "iii", "bi", "q", "go", "uri", "y", "slice", "ity", "ji", "me", "si", "yi", "pi"], "file": ["path", "header", "template", "format", "type", "info", "f", "dir", "l", "link", "fo", "rule", "row", "source", "le", "page", "p", "h", "ile", "handle", "io", "handler", "set", "body", "port", "FILE", "parent", "log", "disk", "buffer", "sf", "resource", "et", "local", "base", "play", "name", "comment", "db", "File", "pool", "table", "child"], "fos": ["flos", "oos", "ffoes", " foses", "oow", " foes", "fbaos", "fbos", "ffaos", "fbow", "Foes", "fo", "foses", "Fo", "Foss", "foss", "FOS", "ffo", "fOS", "sfoss", "fow", "floes", "floss", " fow", "Faos", "flo", "ffos", " foss", "wos", "oo", "woes", "fbo", "foes", "woss", "faos", " fo", "sfOS", "oaos", "woses", "floses", " fOS", "sfaos", "flaos", "Fos", " faos", "sfos"], "fileSrc": ["jobNci", "fileDsrc", "fileInsRC", "fileDrc", "fileDci", " fileSsrc", "jobSrc", "fileNci", "fileErc", "jobSci", "fileSRC", "jobNrl", "fileSci", "fileDource", "jobSri", "fileSource", "fileInsrc", "fileSsrc", " fileInsrc", "fileErl", "fileEri", "fileDrl", "fileEci", "fileInRC", " fileSRC", "fileSrl", "fileDri", "fileDRC", " fileSource", " fileInssrc", "jobNri", " fileInsRC", " fileInsource", "fileNrl", "fileInource", "fileInsource", "jobNrc", "fileSri", "fileInssrc", "fileNrc", "jobSrl", "fileNri", "fileInrc"], "fileDst": ["fileNld", "filedld", "fileNnd", "fileDnd", "fileDpl", "FileSst", "fileDot", "fileWpl", "FileDlt", "FileSot", "fileWst", "fileSpl", "FileDpl", "fileSlt", "fileNot", "fileDld", "filedst", "FileSpl", "fileNlt", "FileScr", "FileDld", "fileSnd", "fileScr", "fileNpl", "filednd", "fileSot", "fileDlt", "fileSst", "FileDst", "fileDcr", "fileNst", "FileDot", "fileNcr", "FileSld", "FileSlt", "filedcr", "FileSnd", "FileDcr", "fileWlt", "FileDnd", "fileWot", "fileSld"], "reader": ["read", "driver", "rer", "iter", "Reader", "dr", "review", "query", "r", "context", "author", "rx", "actor", "rc", "parser", "loader", "entry", "roller", "ri", "rar", "stream", "row", "ader", "rl", "er", "upper", "runner", "handler", "ner", "rr", "Larry", "reading", "controller", "iterator", "buffer", "rot", "resource", "inner", "ocker", "readable", "oder", "ler", "ro", "book"], "writer": ["wright", "read", "user", "driver", "iter", "liner", "Reader", "storage", "function", "creator", "format", "store", "draw", "query", "write", "wrapper", "writers", "editor", "parser", "player", "browser", "client", "walker", "loader", "builder", "test", "entry", "window", "word", "stream", "ter", "manager", "flush", "riter", "runner", "wire", "document", "caster", "handler", "console", "w", "writing", "report", "adder", "Writer", "worker", "iterator", "buffer", "server", "later", "print", "operator", "outer", "order", "maker", "println", "service", "table", "variable"], "line": ["LINE", "user", "range", "block", "liner", "message", "lined", "header", "number", "ln", "stroke", "frame", "ine", "inline", "link", "eline", "cell", "string", "record", "l", "entry", "lin", "nl", "rule", "continue", "word", "detail", "row", "page", "source", "le", "label", "pe", "Line", "valid", "ole", "sequence", "kin", "text", "style", "port", "entity", "chain", "edge", "date", "print", "code", "sample", "column", "comment", "point", "node"]}}
{"id1": "14865947", "id2": "530882", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"execute": [" executes", " execution", " Exec", " dispatch", " eval", "exec", "run", " evaluate", " operate", "Command", " executed", " parse", "Exec", "command", "Action", " Execution", " executable", " query", "process", " resume", " Run", " executing", " proceed", "invoke", " manage", " command", " interpret", " executions"], "event": ["ex", "ce", " invocation", "context", "xe", " EVENT", "t", "frame", "se", "ae", "de", "exc", "pe", "ed", "command", " environment", "w", "E", "te", " frame", "Ev", " Event", " events", "Event", "EE", "ev", "ee", " command"], "shell": ["b", "message", "range", "template", "hell", "grid", "query", "sql", "search", "widget", "session", "ssh", "pty", "Shell", "help", "l", "lock", "cell", "root", "system", "html", "nl", "window", "detail", "scope", "hl", "tools", "screen", "h", "scroll", "quit", "tool", "layout", "handle", "tree", "sh", "sys", "ja", "bot", "console", "body", "sol", "round", "tab", "microsoft", "sb", "js", "windows", "style", "stack", "fr", "line", "buffer", "history", "base", "cli", "theme", "kernel", "pool"], "view": ["block", "template", "review", "display", "ou", "vp", "query", "widget", "list", "browser", "VIEW", "web", "html", "window", "image", "row", "screen", "vm", "cv", "ve", "tv", "layout", "tree", "version", "eye", "document", "w", "show", "see", "report", "buffer", "v", "views", "View", "ui", "iew"], "rootFolder": [" rootDirectory", "coverDisk", "coverFolder", "parentDir", "bottomLibrary", "RootEntry", " rootEntry", " rootLibrary", "RootFolder", "RootDirectory", "parentDirectory", "rootCategory", "bottomFolder", "RootDir", "parentEntry", "rootDirectory", "RootCategory", "parentFolder", " rootArea", "bottomDisk", "coverLibrary", "parentArea", "RootArea", "rootArea", "coverDirectory", " rootCategory", "rootDir", "rootEntry", "rootDisk", "rootLibrary", " rootDisk", "parentCategory", " rootDir", "bottomDirectory"], "dialog": ["logig", " Dializ", "dialig", "logDialog", "Dialj", "dialj", "dloc", "dialOG", "choDialog", "Dialog", "DialDialog", "closer", "callDialog", "selectig", "Dialoc", "dialogs", "choog", "dliz", "dlj", "dializ", "clog", "selectoser", " Dialog", " Dialoc", "selectDialog", " Dialj", "Dializ", "Dialogs", "clDialog", "dialDialog", "selectog", "logog", "dlog", "dialoc", "DialOG", "choogs", "logoser", "choOG", "callOG", "callogs", "clig", "callog", "dialoser"], "password": ["message", "user", "path", "sword", "words", "device", "pass", "Password", "query", "wd", "address", "database", "description", "login", "paste", "request", "encrypted", "secret", "string", "directory", "padding", "entry", "key", "word", "source", "picture", "p", "table", "expression", "pattern", "username", "attribute", "command", "shadow", "PASS", "clear", "definition", "buffer", "raw", "hash", "language", "data", "response", "phrase", "comment", "hello", "prefix", "reset"], "md5": ["mt5", " md6", "mm2", "md4", "md64", "md512", "MD3", "MD4", " md2", "ma64", "m5", "MD6", "mm5", "ma7", "md3", "mt4", "mm6", "MD2", "m3", "mb512", "md6", "MD7", "MD5", "mm7", "MD64", "m4", "MD512", " md512", "mt2", "md2", " md4", "mb4", "ma5", "md7", "ma2", " md7", " md64", "m2", "mb2", "mb5", "mt3"], "md": ["nd", "pt", "cd", "dr", "dh", "mt", "red", "nt", "MD", "m", "pm", "rm", "mk", "mac", "de", "hd", " dd", "mc", "df", "pd", "cmd", "dd", "ct", "det", "msg", "ind", "mod", "pdf", "mm", "ld", "bd", "od", "dig", "mn", "mb", "metadata", "d", " Md", "sd", "hash", "mg", "ms", "sm", "dm", "magic"]}}
{"id1": "23672408", "id2": "3024970", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "label": 1, "substitutes": {"copyIconFiles": ["copyIndexfiles", " copyiconFiles", " copyIconImages", "copyIconDocuments", "copyiconfiles", "copyIndexImages", "copyIconfiles", " copyIconDocuments", "copyiconFiles", "copyiconDocuments", " copyIconfiles", "copyIndexFiles", " copyiconfiles", " copyiconDocuments", "copyIndexDocuments", "copyiconImages", "copyIconImages", " copyiconImages"], "clazz": [" clashed", "Clbo", " plus", "collazz", "clbo", "cluddy", "classazz", "classe", "chazz", "chojure", "escotted", "CLbean", "sclazz", "Close", "clus", " plazz", " classe", "callbo", "pkgazz", "cluster", "crazz", "clashed", "classotted", "Clab", "plashed", " cluster", "scloser", "close", "claz", "clbean", "relazz", "relaz", "descose", " clbean", " claz", "clace", "chotted", "descazz", "sclace", "plaz", "Clazz", "callazz", "crus", "closer", "sclbean", " clus", " cluddy", "crub", " plub", "pkgashed", "clab", " clbo", "escace", "classuster", "CLoser", "descaz", " clojure", "craz", "escojure", "CLace", "plazz", "pkgaz", "pkgasse", "colluddy", "Claz", "classuddy", "chace", " plaz", "descab", "clojure", "callace", " clace", "relab", "CLazz", "plasse", "collotted", "relose", " clotted", " club", "clotted", "escazz", " closer", "callaz", "club", "colluster", "Clace"], "i16": ["pi6", "ri157", " i216", "ji63", "ami19", "ri2016", "pi16", "ini2016", "ri6", "ami150", " i157", "iri2016", "ini160", "i63", "iniShort", "ii160", "ri16", "li19", "ini16", "i157", "iShort", "i150", "ami63", "ii16", "li2016", "iri157", "i2016", "ji150", "ami6", "pi150", "i19", "amiShort", " i6", "ji16", "iri16", "ii216", " i2016", "i24", " i24", "ii24", " i160", "i6", "pi63", "liShort", "ami2016", "ini216", "ini24", "ini19", "iri6", "li16", "i216", "i160", "ji6", "ami16"], "fileType": ["eventType", "formattype", "eventUnit", "formatValue", "coreDef", "fileTime", "FILEtype", "viewTYPE", "FileName", "coreFamily", "fileDef", " filePattern", "fileValue", "filePattern", "ileType", "resourceType", "issueType", "treetype", "eventFormat", "issuePattern", "issuetype", "Filetype", "fieldDef", "policyTyp", "resourceUnit", "fileList", "formatTime", "fileTYPE", "policyType", "coreTYPE", "eventTYPE", "coreType", " filetype", "viewValue", "treeTYPE", " fileValue", " fileTYPE", "fieldTYPE", "ileTyp", " fileFormat", "webList", "FILEType", "resourceFormat", "fieldType", "viewType", "relationTyp", "fileFormat", "webType", "coreHandler", "webDef", "webTYPE", "formatType", "fileTyp", "fieldTyp", "FileType", "webTyp", "fileHandler", "resourceTYPE", "relationType", "eventList", "fileName", "ilePattern", "policyFamily", "coreTyp", "formtype", "formatTYPE", "FILEName", " fileTyp", " fileUnit", "formName", "issueTyp", "treeType", "fileUnit", "relationFamily", "iletype", "formType", "relationHandler", "filetype", " fileTime", "viewtype", "policyHandler", "treeTime", " fileList", "fileFamily"], "desti16": ["destui32", "destgi24", "destii16", "desti18", "destui216", "desti2016", "resultii216", "desti216", "destxi160", "destii216", "destxi18", "destxi32", "destgi216", "resulti16", " destsi32", "destii2016", " destsi16", " destsi160", " desti160", "destxi16", "destsi16", "destui18", "destsi160", "destui160", "resulti216", " desti18", "destgi2016", "destsi32", "desti160", "destui2016", "resultii24", "destii24", "destui24", "destsi18", "destgi16", "desti24", " destsi18", "resultii2016", "destui16", "resultii16", "resulti2016", "resulti24"], "src": ["ls", "dest", "rob", "iter", "gs", "rest", "ctx", "ptr", "isl", "vr", "input", "sc", "usr", "tmp", "urg", "sync", "pkg", "ln", "ser", "std", "sec", "rx", "sr", "fc", "bc", "rc", "rb", "ctr", "bin", "proc", "cb", "sq", "inst", "etc", "nl", "sn", "req", "rg", "loc", "ins", "rs", "source", "txt", "hl", "bg", "img", "comp", "ibl", "addr", "rl", "cmp", "sys", "via", "sp", "st", "sol", "desc", "sb", "iv", "bh", "sub", "sel", "ssl", "cont", "syn", "inner", "cur", "rel", "cli", "scan", "sit", "obs", "sl"], "dst": ["dest", "nnd", "dLst", "rdest", "ndst", "Ddr", "ndest", "ddnd", "dLbl", "ndsts", "dLest", "nst", "dLcut", " ddr", "ddst", "dcut", " dcut", "ddr", "dmn", "dermn", "dLot", "nput", "ngt", "dsts", "dsnet", "rdst", " dot", "tst", " dnet", " dsts", "rbl", "tput", " ddest", "dLnet", "tgt", " dmt", "derst", "Dst", "fdr", "dbl", "ddest", "derdest", "Dnd", " dgt", "dot", "ndmt", " dbl", "dddest", "dsst", " dnd", "dmt", " dest", "rst", "dernd", "dsest", "dLdest", "rcut", "dgt", "tnd", "fnd", "ddmn", "dnet", "rdmt", "fdest", " dput", "fst", "dsot", "dput", "rdsts", "dnd", "Ddest", " dmn"], "i32": ["ip64", "i64", "i34", "pi34", "ic40", "ii342", "i22", " i28", "ic34", "ic31", "ic86", "i86", "xi31", "xi48", "ip32", "i31", " i64", "xi32", "pi32", " i342", "ini32", "ii32", "ii34", "ic342", "ii28", "i28", "i48", " i34", "isi32", "ic64", " i86", "ic48", "ini31", "pi64", " i31", "ic32", "ip31", "ip34", "ini22", "xi22", " i40", "ini48", "isi40", "pi31", "isi86", "i40", "i342", "isi64", "ic28", "ic22"], "desti32": ["destI90", "destic31", "destdi31", "DestI32", "destu256", "Desti31", "desti34", "destu90", "DestI90", "desti90", "destI256", "targetpi30", "destu31", "destpi32", "destic32", "desti31", "destic34", "desti256", "Desti256", "Desti32", "targetpi34", "targetpi31", "desti30", "destdi32", "destpi34", "destI32", "destI31", "destpi30", "targeti30", "destpi31", "DestI31", "targetpi32", "DestI256", "Desti90", "targeti34", "targeti31", "targeti32", "destu32", "destdi30", "destic30", "destdi34"]}}
{"id1": "22441244", "id2": "16590954", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"send": ["reply", "Send", "message", "init", "parse", "write", "save", "apply", "add", "push", "submit", "end", "sent", "msg", "set", "report", "post", "get", "mail", "build", "export", "transfer", "print", "security", "create", "execute"], "hsession": ["rsess", "HSessions", "hessions", "hhhip", "hsettings", "HSsession", "hettings", "HSess", "HSpace", "hsessions", "hspace", "hhession", "hsess", "hhsession", "hhessions", "rspace", "hession", "hhip", "rsession", " HSession", "hssession", "hship", "HShip", " HSpace", "HSession", " HSess", "hhettings", " HSsession", "HSettings", "rssession"], "session": ["message", "ess", "driver", "store", "cache", "context", "instance", "lock", "client", "Session", "job", "ession", "sid", "object", "manager", "password", "document", "state", "set", "view", "parent", "account", "connection", "event", "content", "name", "ip"], "repositoryName": ["repoositoryData", "reposoryData", "repositoryTitle", "repoositoryPath", "reposositoryname", "repositableData", "repositionPath", "repositoryNAME", "repositorNAME", "repositionNAME", "reposoryname", "reposoryNAME", "reposositoryData", "repositorName", "repoositoryTitle", "reposoryName", "repositorPath", "repoitoryname", "repositorTitle", "repoositoryname", "repositoryPath", "repoitoryTitle", "repositableName", "reposositoryNAME", "repositionTitle", "repoositoryNAME", "repoitoryData", "repositableNAME", "repositoryname", "reposositoryPath", "repositoryData", "repositablename", "repoitoryNAME", "repositionName", "repoositoryName", "reposositoryTitle", "reposositoryName", "repoitoryName", "repoitoryPath"], "ideIdint": ["ideIdentind", "IDEIdINT", "ideInfoINT", "ideIdentint", "ideIdline", "ideThind", "IDEidint", "IDEidINT", "ideIdINT", "ideIDind", "ideidint", " ideThline", "ideInfost", "ideIDline", "ideIdst", "ideIDno", "ideidst", "ideIdentline", "ideIdentno", "ideThint", "ideThline", " ideThint", " ideThind", "ideDst", "ideIDint", " ideIdind", "IDEIdst", "ideInfoint", "ideidINT", " ideIdline", "ideThno", "ideDINT", " ideThno", "ideDint", "ideIdind", " ideIdno", "ideIdno", "IDEIdint", "IDEidst"], "to": ["range", "tt", "tp", "address", "toc", "t", "about", "phone", "pos", "client", "To", "top", "too", "ta", "eto", "route", "os", "pro", "TO", "addr", "tr", "token", "site", "st", "company", "target", "po", "by", "no", "ato", "co", "contact", "o", "auto", "tel", "topic"], "cc": ["cs", "ce", "cd", "tc", "sc", "ci", "toc", "fc", "rc", "cl", "cb", "dc", "cloud", "mc", "cv", "ac", "cp", "ct", "cmd", "cn", "control", "ic", "CC", "ico", "cm", "cmp", "cr", "company", "cca", "cci", "ca", "ec", "cy", "ctrl", "cin", "ck", "co", "cf"], "bcc": ["bck", "bce", "cbcc", "cbCC", "vcy", "cbck", "sbck", " bck", "rbcm", "cbcm", "bcm", "rbCC", "vck", " bcm", "vce", "sbce", "rbce", "rbck", "vcc", "sbcc", "sbcy", "rbcy", "bCC", "rbcc", " bCC", "bcy"], "subject": ["message", "header", "template", "title", "note", "heading", "id", "face", "filename", "author", "description", "head", "html", "source", "Subject", "host", "uri", "text", "form", "mail", "content", "metadata", "security", "name", "prefix", "topic", "comment"], "body": ["b", "message", "bytes", "files", "template", "title", "note", "query", "url", "binary", "output", "shell", "ODY", "description", "any", "zip", "head", "news", "params", "back", "inline", "summary", "parts", "padding", "html", "top", "source", "null", "object", "h", "layout", "handle", "ody", "part", "default", "json", "business", "text", "bill", "report", "post", "hex", "bh", "mail", "no", "line", "buffer", "background", "content", "inner", "code", "base", "data", "name", "other", "comment", "response", "Body"], "attachments": ["attachtypes", "attachresses", "Attachments", "attachachment", "Attachresses", "Attachtypes", "atttypes", "achmentresses", "achmenttypes", "achmentments", "attments", "attresses", "Attachachment", "achmentachment"], "isHtml": ["isHap", " isHHTML", "isHHTML", " isWhtml", "IsHtml", "isChtml", "isWhhtml", "isVHTML", "isJttp", "isChip", "isVtml", " isWhip", "isWhip", " isHip", "ishttp", "isHttp", "IsHhtml", "isJhtml", "isWhHTML", "isVhtml", " isWhhtml", "isHip", "isChHTML", "isJap", "isChhtml", "ishtml", "IsHttp", "ishhtml", "isJtml", "isWhtml", " isWhHTML", "ishap", "isVip", " isHhtml", "isHhtml", "IsHap"], "charset": ["chippec", "ChARSET", "chersets", "charpetter", "ChARSet", "clarsetter", "quarsale", "CHarsets", "quatset", "quarset", "chARSets", "chippet", "chacterspace", "charsale", "Charset", "quarsec", "charsetter", "CHippets", "chablesetter", "chippets", "chableset", "chatsetter", "chippetter", "charpetic", "Charsetic", "clerset", "chARSetic", "chippET", "chablesec", "cherset", "chARSetter", "CHippett", "chablesale", "ChARSetter", "Charsetter", "charpett", "charsets", "channelsetter", "chacterset", "channelsET", "CHarsett", "quarsetter", "clersetter", "charpet", "chatset", "channelsetic", "charsET", "chactersetter", "clarspace", "clarsets", "chatsale", "charpET", "CharsET", "CHippet", "chARSet", "quatsec", "chippett", "quatsetter", "CHarsET", "ChARSetic", "charsetic", "chARSpace", "charspace", "chippale", "CHarset", "clerspace", "charsett", "chARSET", "cherspace", "chactersets", "CHippET", "charpets", "chersetter", "charsec", "clarset", "chatsec", "quatsale", "channelset", "clersets"], "headers": ["header", "files", "dr", "authors", "keys", "users", "head", "params", "comments", "ters", "heads", "types", " heads", "ilers", "details", " trailers", "limits", "ppers", "codes", "fields", "members", "relations", "names", "lines", "metadata", "ors", "ers"], "priority": ["title", "id", "grade", "context", "description", "properties", "phone", "comments", "pos", "origin", "due", "primary", "flags", "serial", " urgency", "password", "state", "policy", "company", "position", "status", "level", "security", " severity", "profile", "prefix", "order"], "email": ["external", "message", "ilo", "liner", "Email", "template", "ome", "voice", "note", "http", "all", "search", "office", "url", "address", "output", "database", "oe", "shell", "instance", "description", "echo", "link", "entry", "html", "gmail", "test", "detail", "domain", "label", "object", "die", "ell", "er", "il", "xml", "ne", "document", "initial", "result", "element", "el", "msg", "console", "company", "view", "password", "report", "em", "delete", "e", "mail", "log", "license", "line", "enter", "ssl", "event", "fax", "server", "contact", "print", "et", "model", "example", "sample", "response", "comment", "ee", "reset", "call"], "user": ["person", "match", "creator", "auth", "human", "id", "usr", "output", "author", "users", "login", "use", "actor", "browser", "client", "system", "student", "USER", "User", "from", "manager", "util", "used", "username", "owner", "result", "usa", "uid", "by", "ident", "usage", "entity", "me", "account", "connection", "profile", "name", "admin", "ip"], "identity": ["identificate", "IDENTator", "recognentity", "instifier", "identalty", "identicate", "primance", "primicate", "identance", "IDENTity", "equator", "identator", "ethnicentity", "identiciary", "entifier", "IDENTificate", "equity", "identifier", "equalty", "solidity", "presentularity", "IDENTifier", "presententity", "idITY", "entularity", "identality", "personity", "recognity", "IDENTITY", "ethnicularity", "idiciary", "instentity", "ententity", "IDENTicate", "IDENTitate", "presentitate", "primentity", "IDENTentity", "IDENTance", "idality", "equentity", "solidularity", "ethnicity", "recognance", "personicate", "instity", "solidentity", "instalty", "idularity", "recognicate", "instator", "personentity", "identitate", "IDENTality", "solidality", "identITY", "presentity", "idententity", "identularity", "entity", "IDENTalty", "personITY", "instularity", "IDENTiciary", "primity", "ethnicitate", "idity", "IDENTularity", "personificate", "personiciary", "primificate"], "_returnPath": ["_returnLocation", "_getPath", "setsavePath", "_deletePath", "setreturnTo", "_errorpath", " _returnPoint", "_errorAddress", "_resultLocation", " _errorPath", "setsavepath", "_errorName", "_deletePoint", "setreturnUrl", "_ReturnPoint", "_retPath", "_returnpath", " _returnAddress", "_returnUrl", " _errorName", "_savepath", "_replyPath", "_returnCode", "_getCode", "_retDir", "_errorPoint", "_requestName", "_errorTo", "_deletepath", "_requestAddress", "_returnDir", "_requestPath", "setreturnPath", "_errorPath", "_resultTo", " _errorPoint", "_getDir", "_ReturnPath", "_requestPoint", "_retUrl", "_getTo", "_errorLocation", "setsaveTo", "_deleteTo", "_resultPoint", "_errorUrl", "_returnTo", "setsaveUrl", "_retPoint", "_ReturnName", "_returnPoint", "_replyDir", " _errorAddress", "_savePath", "_retpath", "_saveUrl", "_retCode", "setreturnpath", "_retLocation", " _returnName", "_replyCode", "_returnName", "_returnAddress", "_ReturnAddress", "_resultPath", "_retTo", "_saveTo"], "_from": ["letto", "letabout", " _form", "remfrom", " _reset", "letsource", "_owner", "_reset", "_about", "_local", "remlocal", "longfrom", "_form", "letfrom", "\tactor", "_actor", "longsource", "\tauthor", "\tfrom", "_addr", "_author", "_source", " _source", " _about", "\tform", "remowner", "longto", " _actor", "remaddr", "longreset", " _author"], "_replyTo": ["_returnTO", "_backTO", "_backPath", "_returnFrom", "_responseLine", "_closeLine", "_replyPath", "_closeTO", "_ReplyTo", "_responseOf", "_respondTO", "_respondFrom", "_respondOnly", "_replyOnly", "_ReplyOnly", "_ReplyFrom", "_commentTO", "_commentLine", "_commentOf", "_closeTo", "_returnTo", "_replyOf", "_ReplyTO", "_commentTo", "_returnOnly", "_backFrom", "_replyFrom", "_replyLine", "_responseTo", "_responsePath", "_ReplyPath", "_responseFrom", "_replyTO", "_responseTO", "_backTo", "_respondTo", "_closeOf"], "_to": ["successto", "successtopic", "pritopic", "_ta", "successsite", "_site", "_topic", "prita", "prito", "prisite", "successta"], "_cc": [" _cs", "_cca", "_subject", " _cca", " _subject", "_cs"], "_bcc": ["_bacc", "_wck", "_bca", "_wca", "_wcc", "_rbca", "_bck", "_rca", "_rbck", "_wacc", "_rbcc", "_rcc", "_rck", "_rbacc", "_racc"]}}
{"id1": "11484416", "id2": "1371265", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"moveFile": ["Movefile", " movefile", "movefile", "copyImage", " moveImage", "MoveImage", "moveDirectory", "copyFile", " moveDirectory", "copyDirectory", "MoveFile", "MoveDirectory", "moveImage", "copyfile"], "orig": ["inv", "dest", "ex", "iter", "init", "or", "src", "was", "prop", "clip", "tmp", "rc", "original", "org", "origin", "lim", "proxy", "created", "img", "ord", "def", "good", "act", " ORIG", "copy", "existing", "old", "imp", "exp", "coord", "im", " original", "ori", "ie", "ret", "temp", "Original", "raw", "internal", "Origin", "Orig", "ra", "create", "dom", "base", "cur", "ip"], "target": ["dest", "match", "path", "template", "format", "src", "out", "it", "output", "tmp", "file", "t", "mac", "tile", "Target", "gt", "top", "test", "origin", "next", "source", "null", "png", "touch", "copy", "sys", "ret", "parent", "build", "goal", "base", "arget", "replace", "rel", "local", "table"], "buffer": ["read", "message", "bytes", "block", "header", "iter", "bridge", "display", "cache", "binary", "face", "output", "paste", "queue", "memory", "Buffer", "stream", "window", "limit", "page", "screen", "filter", "scroll", "batch", "char", "password", "document", "attribute", "bar", "command", "sequence", "length", "stack", "engine", "bb", "line", "buf", "history", "chain", "print", "available", "base", "mem", "buff", "data", "sample", "phrase", "bank", "comment", "button", "table", "variable"], "bread": ["billion", "bridge", "fred", "corruption", "bishop", "give", "inn", "bush", "nob", "bill", " ribs", "bled", "log", "ful", "cake", "bb", "neum", "oug", "bel", "stay", "fine", "wake", "uckle", "beck", " breadth", "shield", "brow", "rik", "less", "READ", "good", "eb", "four", " barely", "level", "ble", "fan", "ig", "read", "beat", "rain", "iber", "robe", " Bread", "score", "rown", "fee", "bn", "piece", "print", "leen", "boat", "brew", "blow", "spoken", "crafted", "gear", "jing", "broken", "bc", "web", "bi", "rew", "middle", "scroll", "don", "wei", "bad", "lf", "bird", "eric", "bold", "knife"], "fis": ["liss", "dis", "li", "Fis", "bis", " fris", "los", "lis", "freia", "bi", "ufis", "ufris", "bos", "fiss", "freis", "frei", "ufiss", "fris", "fi", "fia", "dia", " fiss", " fia", "biss", " fi", "Fris", "ufos", "di", "Fos", "Fiss"], "fos": ["oos", "foos", "toos", " foses", "ooes", "eis", " foes", " foos", "toes", "Fis", "ooses", "tis", "voos", "Foes", "foses", "pos", "poos", "Foses", "eos", "eoos", "Foos", "oot", " fus", " fot", "Fot", "tos", "foes", "vos", "pus", "vus", "poes", "voes", "eoes", "fus", "Fos", "fot"]}}
{"id1": "620855", "id2": "20519261", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doDatecheck", "doLicenseCheck", "doDateFix", "DoVersionFix", "doVersionFix", "doVersioncheck", "DoVersioncheck", "doVersionsFix", "DoDatecheck", "DoVersionUpdate", "doVersionUpdate", "doDateUpdate", "DoDateCheck", "doDateCheck", "doVersionsCheck", "DoDateUpdate", "doLicensecheck", "DoDateFix", "doVersionscheck", "doVersionsUpdate", "doLicenseUpdate", "doLicenseFix", "DoVersionCheck"], "view": ["block", "check", "review", "display", "http", "out", "input", "update", "query", "subject", "widget", "open", "context", "blade", "wrapper", "file", "help", "browser", "cell", "VIEW", "client", "web", "html", "self", "window", "image", "row", "this", "page", "q", "hl", "host", "cv", "table", "manager", "tv", "layout", "util", "index", "tree", "component", "document", "eye", "console", "show", "report", "form", "see", "engine", "get", "controller", "buffer", "server", "print", "v", "model", "views", "View", "iew", "doc", "call"], "url": ["b", "ls", "path", "dl", "http", "URL", "lr", "id", "r", "address", "f", "file", "l", "ur", "gl", "link", "str", "browser", "string", "client", "web", "html", "nl", "org", "loc", "null", "hl", "lb", "host", "mount", "uri", "char", "rl", "github", "json", "socket", "Url", "log", "ssl", "date", "oul", "ul", "v", "bel", "location", "language", "rel", "ll", "pl", "sl"], "in": ["In", "b", "is", "sin", "init", "out", "input", "rin", "info", "f", "ln", "ain", "IN", "file", "inn", "reader", "l", "inf", "vin", " IN", "stream", "ins", "n", "source", "inc", "kin", "body", "mat", "din", "isin", "cin", "mn", "i", "gin", " din", "asin", "inner"], "bin": ["b", "sin", "obin", "thin", "out", "cache", "rin", "win", "binary", "lib", "ln", "file", "bl", "inn", "reader", "cos", "rb", "abin", "loader", "bi", " Bin", "bg", "pipe", "len", "sam", " bins", "ebin", "din", "stock", "by", "nb", "bn", "mon", "cin", "con", "conn", "buffer", "gin", " din", "spin", "ran", "inner", "mem", "buff", "bed", "bur", "local"], "line": ["ls", "LINE", "path", "block", "range", "liner", "iter", "channel", "store", "lo", "err", "ln", "file", "col", "inline", "frame", "ine", "l", "string", "eline", "cell", "load", "link", "se", "record", "lin", "entry", "job", "trace", "cat", "word", "row", "section", "page", "le", "one", "cmd", "Line", "char", "part", "el", "field", "state", "text", "body", "style", "port", "log", "no", " Line", "ice", "lines", "chain", "print", "level", "ide", "base", "sample", "code", "column", "point", "comment", "lane"], "version": ["match", "value", "format", "title", "number", "ver", "update", "type", "info", "iso", "versions", "translation", "project", "ion", "description", "vers", "video", "string", "release", "browser", "python", "client", "test", "feature", "virtual", "key", "image", "VERSION", "software", "serial", "major", "Version", "scale", "command", "spec", "sequence", "river", "position", "form", "usage", "license", "VER", "date", "vision", "resource", "v", "hash", "latest", "language", "name", "tag", "volume", "status", "index"], "build": ["b", "dev", "develop", "match", "th", "full", "install", "fail", "make", "where", "ver", "update", "binary", "be", "lib", "project", "ward", "Build", "use", "add", "boost", "link", "release", "load", "builder", "test", "bor", "struct", "unit", "building", "util", "work", "old", "last", "round", "style", "uild", "bug", "log", "dist", "date", "hold", "print", "hash", "ble", "other", "ship", "tag", "db", "latest", "built", "arch"]}}
{"id1": "1005107", "id2": "6036012", "code1": "    public void googleImageSearch() {\n        if (artist.compareToIgnoreCase(previousArtist) != 0) {\n            MusicBoxView.googleImageLocation = 0;\n            try {\n                String u = \"http://images.google.com/images?q=\" + currentTrack.getArtist() + \" - \" + currentTrack.getAlbum() + \"&sa=N&start=0&ndsp=21\";\n                if (u.contains(\" \")) {\n                    u = u.replace(\" \", \"+\");\n                }\n                URL url = new URL(u);\n                HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n                httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n                BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n                String text = \"\";\n                String lin = \"\";\n                while ((lin = readIn.readLine()) != null) {\n                    text += lin;\n                }\n                readIn.close();\n                if (text.contains(\"\\n\")) {\n                    text = text.replace(\"\\n\", \"\");\n                }\n                String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n                for (String s : array) {\n                    if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                        String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                        googleImages.add(s1);\n                    }\n                }\n            } catch (Exception ex4) {\n                MusicBoxView.showErrorDialog(ex4);\n            }\n        }\n    }\n", "code2": "    public byte[] getClassBytes(String className, ClassLoader classLoader) {\n        URLClassLoader cl = new URLClassLoader(urls, classLoader);\n        String resource = className.replace('.', '/') + \".class\";\n        InputStream is = null;\n        try {\n            URL url = cl.getResource(resource);\n            if (url == null) {\n                throw new RuntimeException(\"Class Resource not found for \" + resource);\n            }\n            is = url.openStream();\n            byte[] classBytes = InputStreamTransform.readBytes(is);\n            return classBytes;\n        } catch (IOException e) {\n            throw new RuntimeException(\"IOException reading bytes for \" + className, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(\"Error closing InputStream for \" + className, e);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"googleImageSearch": ["googleImagesScroll", " googleImageFind", " googlePhotoQuery", " googlePhotoSearch", "googlePhotoFind", "googleImagesQuery", "googleImageQuery", "googlePictureSearch", " googlePhotoFind", " googlePhotoScroll", "googleImagesFind", " googleImageQuery", "googleImageFind", " googleImageScroll", "googlePhotoScroll", "googlePhotoSearch", "googlePhotoQuery", "googleImageScroll", "googlePictureScroll", "googlePictureFind", "googlePictureQuery", "googleImagesSearch"], "MusicBoxView": ["MusicCheckModel", "musicboxManager", "MusicBoxview", " MusicBookVIEW", "MusicboxManager", "musicboxView", "MusicAreaModel", "MusicTreeview", "MusicBookVIEW", "Musicboxview", "MusicCheckview", "MusicBoxVIEW", "musicBoxview", "MusicTreeVIEW", " MusicBookview", "MusicBoxModel", " MusicBookManager", "musicBoxManager", "musicboxModel", "MusicAreaManager", "MusicCheckManager", "MusicBookView", "musicBoxView", "MusicTreeManager", "MusicAreaview", "MusicAreaView", "MusicBookview", "MusicboxVIEW", "musicboxview", " MusicBookView", " MusicBoxview", "musicBoxModel", "MusicCheckView", "MusicboxView", " MusicBoxVIEW", "MusicTreeView", "MusicBookManager", " MusicBoxManager", "MusicboxModel", "MusicBoxManager"], "googleImageLocation": ["googleItemImageLoc", "googleItemImagePosition", "googlePictureLoc", "mobileImagePosition", "mobilePictureDirectory", "googlePicturePosition", "mobilePicturePosition", "googlePhotoDirectory", "googleImagePosition", "googlePictureDirectory", "googlePhotoPosition", "mobilePictureLocation", "googlePictureLocation", "googlePhotoLocation", "mobileImageLoc", "mobilePictureLoc", "mobileImageLocation", "googleItemImageLocation", "googlePhotoLoc", "googleImageDirectory", "googleImageLoc", "mobileImageDirectory", "googleItemImageDirectory"], "u": ["user", "ugi", " nu", "U", "us", "ou", "fu", "uf", "uu", "mu", "su", "t", "l", "au", "uci", "ur", "uni", "ut", "ue", "tu", "q", "p", "uri", "bu", "pu", "up", "eu", "nu", "lu", "uid", "cu", "iu", "i", "ul", "hu", "o", "\u00fc", "ru", "ui", "uv"], "url": ["ls", "dl", "http", "URL", "r", "f", "open", "api", "abs", "t", "l", "ur", "gl", "str", "https", "link", "job", "web", "nl", "arl", "hl", "h", "github", "char", "rl", "il", "www", "ref", "get", "build", "Url", "log", "ssl", "ul", "bel", "base", "atl", "name", "ll", "mount", "hub", "sl"], "httpcon": ["httcon", "Httpconv", "httpsco", "httpscon", "ttpCon", "httconn", "Httpco", "httpco", " httpco", "ttpconn", "httpconv", " httppen", "Httpconn", "httpen", " httpconv", " httpCon", "ttpconv", "httpsconn", "HttpCon", "httppen", "httpCon", "Httpcon", "httpsCon", "httpspen", "ttpcon", "httpsconv", "httpconn", " httpconn", "httconv"], "readIn": [" readIN", "readerIns", " readCon", "loadIn", "readin", "reportin", "reportIns", "ReadIn", "loadIN", "reportIn", "readOut", "Readin", "readerin", "loadCon", "ReadCon", "readerIN", "loadIns", " readin", "readIN", " readOut", "ReadOut", "readCon", "readerOut", "loadin", "reportIN", "readerIn", "readIns", "loadOut"], "text": ["ment", "message", "path", "read", "template", "value", "net", "title", "note", "tt", "out", "it", "input", "all", "binary", "info", "output", "translation", "description", "t", "left", "string", "str", "tx", "test", "html", "ext", "TEXT", "word", "image", "n", "source", "txt", "object", "ct", "xml", "msg", "ind", "sequence", "body", "state", "pdf", "none", "hex", "log", "tex", "line", "buffer", "cont", "content", "print", "inner", "Text", "data", "phrase", "comment"], "lin": ["ls", "lined", "pin", "liner", "lan", "ill", "lo", "sql", "li", "ln", "l", "LIN", "cell", "nl", "fin", "vin", "nic", "jin", "txt", "lim", "cil", "in", "Line", "rl", "Lin", "il", "late", " line", "lang", "tan", "lit", "ind", "lu", "kin", "oin", "mil", "sol", "lie", "lic", "isin", "log", "cin", "line", "lins", "gin", "inner", "lp", "ll", "pl", "sl", "lc"], "array": ["message", "range", "collection", "Array", "r", "ary", "among", "list", "ab", "map", "ash", "s", "string", "trace", "vector", "parts", "our", "ar", "row", "av", "a", "pair", "arr", "air", "archive", "part", "result", "sequence", "stack", "RAY", "ray", "aw", "atlantic", "v", "now", "rays", " Array", "hash", "angular"], "s1": ["S2", "SOne", "ls5", "s0", "ls0", "lsOne", "sOne", " s2", " s0", " sOne", "S0", "ls1", " s5", "s2", "S1", "s5", "ls2"], "ex4": [" ex2", "ex5", " ex5", "ex3", " ex6", "ex1", "EX4", " ex1", "nex6", "Ex2", "x3", "EX5", "nex2", "ex2", "x2", "EX2", "x6", "ex6", "nex3", "Ex1", "nex4", "EX1", "Ex4", "Ex5", "x4", " ex3"]}}
{"id1": "11082670", "id2": "21608109", "code1": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"lookupFutureEvents": ["lookUpFutureServices", "lookupAsyncServices", "lookupAsyncEvent", "lookupAsyncEvents", "lookUpAsyncEvents", "lookupFutureServices", "lookUpAsyncUsers", "lookUpFutureUsers", "lookupLatestServices", "lookUpFutureEvent", "lookupAsyncUsers", "lookupPastEvents", "lookupPastEvent", "lookUpAsyncEvent", "lookupFutureUsers", "lookUpFutureEvents", "lookupFutureEvent", "lookupLatestEvents", "lookupPastServices", "lookupLatestEvent", "lookupLatestUsers", "lookUpAsyncServices", "lookupPastUsers"], "groupIdentifier": [" groupIdentifer", "groupSpecification", "groupSpecificifer", "groupSpecifier", " groupidentificate", "groupIdification", " groupIdifiers", "groupIdifiers", "groupIdentificate", " groupidentification", " groupidentifier", "groupidentificate", "groupSpecifer", "groupIdentifiers", "groupSpecificifier", " groupIdentifiers", "groupIdifier", " groupIdifer", "groupSpecifiers", "groupidentifier", "groupIdentification", "groupIdentifer", " groupIdifier", "groupidentification", "groupSpecificificate", "groupidentifer", " groupIdentificate", " groupidentifer", "groupSpecificification", " groupIdification", "groupIdificate", " groupIdentification", "groupidentifiers", "groupIdifer"], "json": ["message", "jack", "format", "note", "human", "it", "query", "sql", "api", "database", "list", "request", "join", "JSON", "properties", "journal", "sv", "zip", "csv", "params", "string", "pretty", "network", "html", "details", "gc", "kj", "batch", "alert", "tree", "xml", "jj", "document", "state", "javascript", "report", "form", "js", "hex", "log", "lost", "stats", "raw", "metadata", "total", "print", "son", "now", "pi", "data", "response", "j", "status"], "requestUrl": ["requestURL", "RequestURL", " requestLink", "serviceUrl", " requestWar", "requestStr", "serviceStr", "RequestUr", "responseUr", "requestLink", "responseLink", " requestUr", "serviceURL", "responseURL", "requestWar", " requestStr", "RequestStr", "responseUrl", "RequestWar", "requestUr", "RequestUrl", "RequestLink", "serviceWar", " requestURL"], "url": ["b", "dl", "http", "URL", "input", "r", "open", "address", "f", "l", "ur", "link", "str", "browser", "web", "nl", "host", "p", "uri", "github", "char", "io", "socket", "sb", "ref", "ret", "get", "mail", "Url", "re", "build", "ssl", "resource", "ul", "res", "base", "rel", "ll", "mount", "sl"], "in": ["In", "b", "iter", "is", "conf", "on", "out", "input", "all", "info", "r", "f", "file", "ln", "IN", "inn", "reader", "and", "l", "bin", "again", "ins", "source", "from", "inc", "mc", "ic", "er", "io", "body", "din", "isin", "get", "impl", "re", "log", "cin", "con", "line", "gin", " din", "buffer", "raw", "inner", "ssl", "mr", "ob", "doc"], "inputLine": [" inputEntry", "outputLINE", " inputLINE", "firstRow", "readLine", "firstline", "InputLine", "firstLine", "outputEntry", "inputStream", "firstCell", "outputline", "inputline", " inputRow", "inputLINE", "inputEntry", "readline", " inputStream", "outputLine", "readRow", "InputRow", "Inputline", "readStream", " inputCell", "outputCell", "InputStream", " inputline", "configLINE", "outputRow", "configEntry", "configRow", "inputCell", "inputRow", "configLine"], "events": ["actions", "options", "versions", "forms", "reports", "groups", "types", "dates", "rows", "devices", "services", "issues", "ents", "sections", "tests", "videos", "names", "history", "errors", "assets", "objects", "views", "items", "archives", "es", "Events", "pages"], "jsonObj": ["JSONobj", "JSONObj", "xmlCons", "JSONCons", "sonObject", "jsonObject", "jsonCons", " jsonObject", "jsonobj", "sonEx", "sonObj", "javascriptCons", "jsonEx", "javascriptEx", "javascriptObject", "JSONObject", "xmlEx", "javascriptObj", "JSONEx", "xmlObj", " jsonobj", " jsonEx", "sonobj", "xmlObject"], "results": ["lists", "vals", "docs", "ms", "versions", "products", "users", "thumbnails", "forms", "RESULTS", "rings", "reports", "ings", "rows", "resources", "details", "roads", "roots", "successful", "orders", "photos", "finals", "issues", "games", "features", "idents", "images", "posts", "sections", "its", "rates", "tests", "ults", "lines", "runs", "assets", "errors", "res", "artifacts", "items", "objects", "Results", "terms", "values", "pages", "blocks"], "i": ["ami", "ij", "is", "us", "gi", "id", "it", "xi", "qi", "info", "ci", "li", "f", "I", "m", "di", "ai", "ix", "iq", "hi", "ki", "x", "bi", "ri", "ii", "u", "multi", "mi", "ic", "batch", "io", "y", "im", "phi", "sim", "ori", "ji", "me", "chain", "si", "print", "yi", "ei", "pi", "o", "cli", "j", "ui", "index", "ini", "ip"], "result": ["Result", "message", "match", "full", "function", "search", "associated", "wrapper", "context", "output", "class", "runtime", "first", "description", "currency", "done", "product", "success", "record", "true", "answer", "entry", "feature", "rule", "test", "detail", "primary", "pair", "details", "created", "successful", "mate", "manager", "dict", "document", "valid", "folder", "definition", "report", "status", "remote", "duration", "process", "complete", "total", "res", "profile", "response", "data", "latest", "relation", "table", "reverse"], "e": ["b", "ce", "f", "err", "t", "se", "eg", "ade", "de", "le", "p", "ent", "u", "pe", "ne", "element", "em", "entity", "eur", "v", "ei", "o", "or", "ome", "r", "s", "eff", "ae", "x", "c", "ue", "end", "die", "ze", "ef", "ec", "ke", "et", "ev", "oe", "m", "ine", "entry", "n", "a", "en", "ed", "eeee", "el", "exp", "E", "te", "ie", "g", "re", "j", "es", "ee", "it", "be", "ate", "l", "email", "one", "h", "ve", "er", "eu", "ge", "y", "me", "event", "d", "create"], "myDate": ["myData", "mysDay", "miData", "MyDate", "MYTime", "thisDat", "mineDate", "myDay", "MYD", " myWrite", "amiDate", "amiDay", " myCart", "morningD", "thisDay", "morningWrite", " myTime", "mineCart", "myDat", "myWrite", "mineD", " myBody", "MYCart", " myD", "thisDate", "miUser", " myEvent", "myUser", "mysUser", " myDay", "amiBody", " myDat", "myBody", "morningBody", "mysTime", "mineTime", "thisWrite", " myData", "miEvent", "myD", "myCart", "MyTime", "amiD", "morningDate", "miTime", "MyDay", "miDay", "miDate", "amiDat", "MYDate", "mysData", "mysDate", "mysEvent", "myEvent", "myTime", " myUser", "amiWrite"], "time": ["tm", "message", "template", "value", "format", "TIME", "title", "tt", "shift", "id", "tc", "type", "info", "context", "mt", "runtime", "instance", "join", "etime", "t", "zone", "string", "trace", "before", "hour", "test", "c", "year", "tim", "clock", "text", "Time", "ime", "timer", "event", "date", "code", "start", "timeout", "data", "name"], "tz": ["tm", " z", " td", "webkit", "tt", "ts", "tc", "z", " dst", "etime", " os", "cond", "zone", "etc", "Zone", "etz", " dd", "loc", "tk", "os", " ns", " ss", " zones", "dt", " zone", " xx", "hh", "local", "ns"]}}
{"id1": "21395184", "id2": "1985677", "code1": "    @Test\n    public void test30_passwordAging() throws Exception {\n        Db db = DbConnection.defaultCieDbRW();\n        try {\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"5\", 1);\n            PreparedStatement pst = db.prepareStatement(\"UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?\");\n            pst.setString(1, \"esis\");\n            db.executeUpdate(pst);\n            db.commit();\n            p_logout();\n            t30login1();\n            assertTrue(isPasswordExpired());\n            PeopleInfoLine me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().before(DateHelper.now()));\n            t30chgpasswd();\n            assertFalse(isPasswordExpired());\n            me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().after(DateHelper.now()));\n            p_logout();\n            t30login2();\n            assertFalse(isPasswordExpired());\n            t30chgpasswd2();\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"0\", 1);\n            db.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            db.rollback();\n        } finally {\n            db.safeClose();\n        }\n    }\n", "code2": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "label": 0, "substitutes": {"test30_passwordAging": [" t30_passwordAgent", " t30_password_gent", " t30_password_ging", " t30_passwordAging", " t30_password_ged", " t30_passwordLogged", " t30_passwordAlging", " t30_PasswordAlged", " t30_PasswordAlging", " t30_passwordLoggent", " t30_PasswordAgent", " t30_passwordAger", " t30_password_ger", " t30_passwordAged", " t30_PasswordAging", " t30_passwordAlged", " t30_PasswordAlger", " t30_passwordAlger", " t30_passwordLogging", " t30_PasswordAged", " t30_passwordLogger", " t30_PasswordAger", " t30_PasswordAlgent", " t30_passwordAlgent"], "db": ["b", "obj", "dl", "cd", "storage", "or", "src", "display", "http", "store", "ds", "sql", "gb", "mt", "lib", "database", "cfg", "pkg", "m", "fd", "bl", "bc", "app", "gd", "always", "rb", "back", "DB", "cb", "bur", "html", "quote", "cp", "gc", "dd", "ct", "pd", "og", "bs", "sys", "dt", "cr", "sb", "ref", "dat", "eb", "ld", "Db", "bd", "nb", "log", "conn", "bb", "con", "mb", "td", "fb", "d", "bt", "sd", "internal", "cur", "base", "data", "rel", "di", "pg", "pr", "table", "dm"], "pst": ["pth", "prsp", "apse", "psse", "psp", "lnd", "spst", "peste", "pstat", "psst", "prest", "cpth", "spnd", "pend", "prend", "prst", "apst", "pST", "lstat", "prese", "apSt", "pste", "preSt", "dth", "pestat", "cpst", "apnd", "spstat", "pest", "pse", "lste", "psnd", "dst", "pnd", "psSt", "pSt", "prST", "dST", "spste", "cpST", "cpsp", "lst", "prth", "dsp"], "me": ["my", "mage", "mu", "se", "queue", "de", "mo", "le", "mi", "pe", "eme", "ne", "Me", "body", "em", "e", "mail", "ml", "mite", "mph", "mia", "ome", "pa", "ma", "fo", "self", "ae", "ME", "gre", "see", "meta", "na", "pse", "spe", "got", "mos", "km", "mic", "here", "md", "gone", "this", "mer", "them", "mc", "gate", "he", "mes", "te", "med", "study", "mn", "di", "she", "mx", "we", "match", "ste", " Me", "be", "email", "meg", "true", "ware", "go", "ve", "eu", "msg", "ge", "hem", "men", "mem", "life", "made", "ms"]}}
{"id1": "5744992", "id2": "18164929", "code1": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"dorequest": ["dORErequest", "dOREquest", " sdirerequest", " sdireload", "doreq", "doseq", " sdorerequest", "doreload", "doseload", "direrequest", "dosequest", "direquest", "dOREq", "direq", " sdireq", "dOREload", "doserequest", "direload", " sdoreq", " sdirequest", " sdoreload", " sdorequest", "dorerequest"], "ps": ["poses", "pt", "pres", "gs", "mos", "pp", "ts", "ds", "fs", "ms", "pm", "mp", "ats", "aps", "s", "ples", "pins", "sts", "ops", "p", "pe", "Ps", "places", "ips", "pers", "eps", "PS", "ports", "perties", "pse", "pes", "ks", "pps", " props", "pl", "ap", "pr", "changes", "pas"], "method": ["tm", "message", "path", "format", "prop", "type", "url", "subject", " Method", "m", "request", "dir", "rem", "METHOD", "md", " meth", "period", "verb", "req", "key", "term", "right", "Method", "nom", "missing", "uri", "cmd", "ETHOD", "num", "tr", "command", "msg", "mod", "property", "body", "post", "form", " methods", "process", "code", "name", "time", "hod", "call"], "httpResponse": ["phpResponse", "phpReturns", "ttpResponse", "procOutput", "htmlresponse", "adminresponse", "ttpResp", "httpReply", "httpContent", "adminAnswer", "httpsContent", "httpsResponse", " httpReturn", "httpOutput", "httpsResp", "procAnswer", "ttpReply", "httpsReturns", "httpAnswer", "phpReply", "htmlReturn", "ttpReturns", "procresponse", "phpResp", "adminOutput", "htmlResponse", "htmlOutput", "htmlResp", "adminResponse", "httpReturn", " httpContent", "httpsReturn", "httpresponse", "procResponse", "htmlAnswer", "htmlContent", "httpsReply", " httpResp", "httpResp", "httpReturns"], "ourl": ["ourlf", "uroloc", "ourlt", "OURlt", "onselit", "ourlit", "OURl", " doulf", "ourloc", "ourlia", " doul", "ourslt", " doulia", "earl", " doult", "OURlia", "onsel", "earlit", "OURlf", "earloc", "ourslf", "earll", "urol", "onseloc", "ourslia", "ourll", "uroll", "onsell", "oursl", "urolit"], "httpConnection": [" httpSession", "hLink", "utilconnection", "httpconnection", " httpConn", "Httpconnection", "utilConnection", "httpLink", "ttpConnection", "hConnection", "utilConnect", "httpsApplication", "utilConn", "httpConsole", "streamConsole", " httpLink", "HttpConn", "ttpconnection", "hConnect", "ttpChannel", "hoverConn", "httpChannel", "opConnection", "streamConnection", "hoverConnect", "hoverSession", "ttpConnect", "httpsConn", "httpsLink", " httpconnection", "httpsConnect", "ttpConn", "httpsConsole", "hoverConnection", "httpsChannel", "opconnection", "HttpConnection", "hconnection", "opConnect", "streamConnect", "httpsconnection", " httpConsole", "streamconnection", " httpChannel", "HttpConnect", " httpApplication", "opConn", "httpConn", "httpApplication", "httpsSession", "httpsConnection", "httpSession", "hApplication", "httpConnect", " httpConnect"], "httpOutputStream": ["httpInputStyle", "httpResponseStream", "httpResponseSteam", "httpsInputForm", "httpSystemstream", "httpApplicationSteam", "ttpWriteStream", "httpoutputSteam", "httpOutputForm", "httpInputSteam", "httpInputStream", "httpOutputSteam", "httpResponseStyle", "httpsOutputStream", "httpWriteStream", "httpsInputStyle", "httpWritestream", "httpWriteTime", "httpsOutputStyle", "httpOutputstream", "httpSystemStream", "ttpWritestream", "httpoutputStream", "httpApplicationStream", "httpsOutputForm", "httpInputForm", "ttpWriteTime", "httpoutputTime", "httpSystemSteam", "ttpWriteSteam", "ttpOutputTime", "httpoutputstream", "ttpOutputstream", "httpSystemTime", "httpApplicationForm", "httpsInputSteam", "ttpOutputSteam", "httpResponseForm", "httpApplicationStyle", "httpsOutputSteam", "httpOutputStyle", "ttpOutputStream", "httpsInputStream", "httpOutputTime", "httpWriteSteam"], "postParams": [" postParPar", "postVariams", "postEnparams", " postPams", "postPersams", "postPARams", " postPargs", "postParAMS", "postPgs", "postParames", "postParamAMS", " postParms", "postParamams", " postParParam", "postParamas", "postVariAMS", " postParamb", "postParamans", "postEnams", " postPersgs", "PostParamparams", " postParamas", "postPams", "postParParam", "postPersgs", "postParperties", "postPARperties", "postPms", "postParans", "postPargs", "postParamParam", "PostParamams", "postParam", "postVarims", "postParamPar", " postParam", "PostParames", "postPersms", "postPersparams", " postParperties", " postPms", "postProms", "postVariPar", "postEnans", " postPersamas", "PostParamans", "postGradams", "postProAMS", "postParamparams", " postPgs", "postPARam", "postEnames", "postPperties", "postParamb", "PostParams", "postParamgs", "postPARamb", "postPARgs", "postParms", "postGradam", "PostParans", "postProams", "postPersames", "postParamamas", "PostParamames", "postPersamas", "postGradamb", "postPersAMS", "postPARParam", " postPersAMS", "postPARamas", " postParAMS", " postPersms", " postPperties", " postPersams", "postParPar", "postParamperties", " postPersParam", "postPARms", "postParamms", "postParamames", "PostParparams", "postParparams", "postPersans", "postPersParam"], "entry": ["pixel", "ce", "check", "let", "or", "ace", "search", "info", "card", "argument", "space", "instance", "add", "link", "cell", "Entry", "word", "row", "pair", "ent", "up", "char", "io", "attribute", "owner", "cue", "element", "field", "command", "set", "see", "step", "ie", "e", "entity", "iterator", "line", "piece", "connection", "event", "resource", "escape", "inner", "data", "ry", "point", "section", "member"], "httpBufferedReader": ["httpBuffeneder", "httpBuffleder", "httpBuffereder", "httpReferedBuffer", "httpBuffersStream", "httpRefledReader", "httpBuffererWriter", "httpRefledBuffer", "httpReferedRead", "httpBuffeder", "httpBuffledRead", "httpBuffenedRead", "httpBuffererStream", "httpBufferredReader", "httpRefereder", "httpBufferedRead", "httpBuffedRead", "httpBuffledBuffer", "httpBuffenedReader", "httpBuffererReader", "httpBuffledReader", "httpBufferredWriter", "httpBuffenedBuffer", "httpBufferedBuffer", "httpBuffersReader", "httpRefleder", "httpBufferedWriter", "httpReferedReader", "httpBufferredStream", "httpBuffersWriter", "httpRefledRead", "httpBuffedBuffer", "httpBuffedReader", "httpBufferedStream"], "text": ["message", "title", "input", "binary", "context", "description", "str", "tx", "ext", "TEXT", "txt", "xml", "password", "document", "command", "msg", "state", "json", "log", "buffer", "raw", "print", "code", "Text", "data", "name", "comment", "status"]}}
{"id1": "23517481", "id2": "17874479", "code1": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "code2": "    public static final void main(String[] args) throws Exception {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(\"http://www.apache.org/\");\n        System.out.println(\"executing request \" + httpget.getURI());\n        HttpResponse response = httpclient.execute(httpget);\n        HttpEntity entity = response.getEntity();\n        System.out.println(\"----------------------------------------\");\n        System.out.println(response.getStatusLine());\n        if (entity != null) {\n            System.out.println(\"Response content length: \" + entity.getContentLength());\n        }\n        System.out.println(\"----------------------------------------\");\n        httpget.abort();\n    }\n", "label": 0, "substitutes": {"md5": [" MD2", "MD5", " MD4", " md4", " MD3", " md3", "md3", " MD5", "md4", "MD3", "md2", "MD4", "MD2", " md2"], "uri": ["message", "path", "http", "qi", "uu", "query", "url", "force", "subject", "address", "filename", "du", "file", "description", "uni", "ur", "link", "directory", "ri", "origin", "term", "domain", "q", "u", " URI", "unit", "util", "char", "io", "password", "msg", "course", "requ", "URI", "remote", " ur", "i", "resource", "location", "name", "prefix", "ui", "via"], "messageDigest": ["Messagedigse", "messageDoest", "messageMDer", "messageDigester", "MessageDigest", "messageDigse", "messagedigse", " messageDigse", "messageMDester", " messagedigse", "messageMDse", "messagedigose", " messagedigose", "messagediger", "messageDoose", "messageDose", "messageDigEST", "messagedigment", "messageDigment", " messageDigment", "messagedigest", " messageDigose", "MessageDiger", "Messagedigest", "Messagediger", "messagedigEST", "MessagedigEST", "messageDigose", "messageDoment", "messagedigester", " messagedigment", "MessageDigEST", "messageDiger", "MessageDigester", " messagedigest", "MessageDigse", "messageMDest", "Messagedigester", "messageMDEST"], "bytes": ["sofar", "pieces", "gs", "strings", "files", "gets", "words", "clips", "amps", "gb", "users", "times", "loads", "odes", "s", "bps", "bes", "ings", "groups", "types", "uses", "tes", "ces", "xs", "bits", "bs", "Bytes", "classes", "ies", "outs", "frames", "steps", "images", "seconds", "ions", "buffer", "les", "ors", "terms", "es", "values", "pages", "blocks"], "stringBuffer": ["soundBuff", "StringChannel", "stringChannel", " stringLength", "soundBuffer", "stringView", "stringController", "Stringbuffer", "statusCenter", "stringCenter", " stringChannel", " stringController", "stringBuilder", "stringsQuery", "statusBlock", "stringLength", "libraryBlock", "stringBlock", "statusController", "ringBuilder", "StringLength", "statusBuffer", " stringbuffer", "ringQuery", " stringBuff", "stringbuffer", "StringBuff", "stringBuff", "ringBuffer", "stringsBuffer", "soundbuffer", "libraryController", "libraryCenter", "StringQuery", "StringView", " stringCenter", "stringsBuff", "stringQuery", " stringView", "soundChannel", "ringBuff", "ringView", " stringBlock", "stringsBuilder", "ringLength", "libraryBuffer"], "b": ["obj", "value", "out", "id", "k", "r", "f", "be", "binary", "z", "ib", "gb", "t", "s", "l", "rb", "c", "x", "bi", "n", "a", "p", "u", "h", "bs", "y", "w", "ch", "sb", "e", "nb", "B", "bb", "i", "d", "v", "o", "buff", "j"], "hex": ["xf", "ex", "solid", "com", "full", "ph", "prop", " Hex", "des", "mix", "red", "sv", "zip", "str", "tx", "html", "x", "ext", "term", "color", "pex", "hl", "serial", "h", "def", "percent", "comp", "dump", "sh", "sex", "json", "exp", "uint", "alph", "ch", "form", "bh", "none", "re", "tex", "raw", "escape", "imal", "print", "cf", "rex", "rendered", "hash", "buff", "lit", "hello", "alpha", "oct"]}}
{"id1": "810342", "id2": "11962480", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doDatecheck", "doLicenseCheck", "doDateFix", "DoVersionFix", "doVersionFix", "doVersioncheck", "DoVersioncheck", "doVersionsFix", "DoDatecheck", "DoVersionUpdate", "doVersionUpdate", "doDateUpdate", "DoDateCheck", "doDateCheck", "doVersionsCheck", "DoDateUpdate", "doLicensecheck", "DoDateFix", "doVersionscheck", "doVersionsUpdate", "doLicenseUpdate", "doLicenseFix", "DoVersionCheck"], "view": ["block", "check", "review", "display", "http", "out", "input", "update", "query", "subject", "widget", "open", "context", "blade", "wrapper", "file", "help", "browser", "cell", "VIEW", "client", "web", "html", "self", "window", "image", "row", "this", "page", "q", "hl", "host", "cv", "table", "manager", "tv", "layout", "util", "index", "tree", "component", "document", "eye", "console", "show", "report", "form", "see", "engine", "get", "controller", "buffer", "server", "print", "v", "model", "views", "View", "iew", "doc", "call"], "url": ["b", "ls", "path", "dl", "http", "URL", "lr", "id", "r", "address", "f", "file", "l", "ur", "gl", "link", "str", "browser", "string", "client", "web", "html", "nl", "org", "loc", "null", "hl", "lb", "host", "mount", "uri", "char", "rl", "github", "json", "socket", "Url", "log", "ssl", "date", "oul", "ul", "v", "bel", "location", "language", "rel", "ll", "pl", "sl"], "in": ["In", "b", "is", "sin", "init", "out", "input", "rin", "info", "f", "ln", "ain", "IN", "file", "inn", "reader", "l", "inf", "vin", " IN", "stream", "ins", "n", "source", "inc", "kin", "body", "mat", "din", "isin", "cin", "mn", "i", "gin", " din", "asin", "inner"], "bin": ["b", "sin", "obin", "thin", "out", "cache", "rin", "win", "binary", "lib", "ln", "file", "bl", "inn", "reader", "cos", "rb", "abin", "loader", "bi", " Bin", "bg", "pipe", "len", "sam", " bins", "ebin", "din", "stock", "by", "nb", "bn", "mon", "cin", "con", "conn", "buffer", "gin", " din", "spin", "ran", "inner", "mem", "buff", "bed", "bur", "local"], "line": ["ls", "LINE", "path", "block", "range", "liner", "iter", "channel", "store", "lo", "err", "ln", "file", "col", "inline", "frame", "ine", "l", "string", "eline", "cell", "load", "link", "se", "record", "lin", "entry", "job", "trace", "cat", "word", "row", "section", "page", "le", "one", "cmd", "Line", "char", "part", "el", "field", "state", "text", "body", "style", "port", "log", "no", " Line", "ice", "lines", "chain", "print", "level", "ide", "base", "sample", "code", "column", "point", "comment", "lane"], "version": ["match", "value", "format", "title", "number", "ver", "update", "type", "info", "iso", "versions", "translation", "project", "ion", "description", "vers", "video", "string", "release", "browser", "python", "client", "test", "feature", "virtual", "key", "image", "VERSION", "software", "serial", "major", "Version", "scale", "command", "spec", "sequence", "river", "position", "form", "usage", "license", "VER", "date", "vision", "resource", "v", "hash", "latest", "language", "name", "tag", "volume", "status", "index"], "build": ["b", "dev", "develop", "match", "th", "full", "install", "fail", "make", "where", "ver", "update", "binary", "be", "lib", "project", "ward", "Build", "use", "add", "boost", "link", "release", "load", "builder", "test", "bor", "struct", "unit", "building", "util", "work", "old", "last", "round", "style", "uild", "bug", "log", "dist", "date", "hold", "print", "hash", "ble", "other", "ship", "tag", "db", "latest", "built", "arch"]}}
{"id1": "11183087", "id2": "21152728", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "label": 1, "substitutes": {"doPost": [" dopost", "DoPost", " doPOST", "DoAdd", " doAdd", "handlePost", "dopost", "Dopost", "doAdd", "handlePOST", "handleAdd", "handlepost", "doPOST", "DoPOST"], "request": ["search", "project", "current", "law", "quest", "xml", "require", "report", "post", "get", "connection", "connect", "begin", "user", "collection", "the", "input", "register", "url", "open", "subject", "select", "context", "browser", "Request", "run", "handle", "command", "result", "controller", "enter", "question", "raw", "hello", "order", "setup", "message", "application", "argument", "list", "record", "req", "forward", "version", "initial", "work", "requ", "remote", "re", "print", "http", "QUEST", "query", "address", "first", "reference", "frame", "client", "web", "system", "object", "document", "position", "parent", "event", "server", "model", "start", "create", "complete", "reset", "call"], "response": ["reply", "message", "ce", "collection", "out", "write", "application", "context", "output", "frame", "send", "success", "entry", "onse", "image", "next", "one", "page", "environment", "exit", "ve", "resp", "to", "document", "default", "result", "view", "respond", "report", "e", "re", "connection", "server", "content", "print", "res", "Response", "status", "service"], "senha": ["senhas", "Senigma", "tenja", "Senho", "Senha", "ensenha", " senigma", "tenHa", "Senja", "senca", "senja", "Senwa", "renja", "senwa", "tinhas", "Senhi", "Senhas", " senca", "senigma", "senHA", "SenHa", "tinhi", "tenwa", "ensenho", " senHA", " senhi", " senhas", "senhi", "tinha", "tenha", " senho", "renwa", "senHa", "senho", "Senca", "ensenHA", "renHa", "tinigma", "renha", "SenHA", "ensenca"], "email": ["alias", "external", "message", "path", "ilo", "Email", "url", "office", "address", "oe", "login", "file", "echo", "zip", "ql", "string", "lock", "gmail", "image", "detail", "domain", "quote", "label", "le", "live", "Mail", "addr", "username", "password", "ne", "el", "elly", "e", "mail", "license", "line", "enter", "example", "sample", "name", "ails", "IL", "hello", "secret", "ip"], "messageDigest": ["Messagedigse", "messageIGse", "messageDigester", "MessageDigest", " messageDigester", "messageDig5", "messageDigse", "messagemdester", "messagedigse", " messageDigse", "messageMDester", "Messagedig5", " messagedigse", " messagediger", "MessageDig5", "messageIGEST", "messageMDse", "messageIGest", "messagediger", "messageDigEST", "messageDse", " messageDiger", "messageIGester", "messagedig5", "messagedigest", "messagemdEST", "Messagedigest", "messageDer", "messagedigEST", "MessagedigEST", "messageDester", "messagedigester", "MessageDigEST", "messagemd5", "messageDiger", "MessageDigester", " messagedigest", "messageDest", "MessageDigse", "messageMDest", "Messagedigester", " messagedigester", "messageMDEST", "messagemdest"], "usuario": ["ussuarius", "ussuarios", "usuarial", "usui\u00e9r", "usuiario", " usuarial", "cusuarios", "ussuino", "uscuino", "usuarius", "usuino", "ususarial", "usuiarios", " usurio", "cusuino", "uscuario", "usnuario", "usuiarial", " ussuarius", "ussurio", " usuarius", " ussuarial", "uscuarios", "usruarios", "ussu\u00e9r", "usruino", "cussuarios", "usnuarial", "ususarius", "ususrio", "cussu\u00e9r", "ususario", "usurio", "usruarial", "usuarios", "uscuarial", "usruario", " ussurio", "usnuarius", "usu\u00e9r", "cussuarial", "ussuarial", "cusuario", "uscu\u00e9r", "cussuino", "ussuario", "cusuarial", "cusu\u00e9r", "usnurio", "cussuario", " ussuario"], "redirect": ["rightirection", "inderer", "reddigate", "redir", "rederer", " reddraw", "Reddraw", "rightRECT", "reddraw", "redurl", "indirection", "redrict", "Redirect", "reddirection", "redRECT", "rightigate", "edirection", "Redirection", "edir", "edrict", " redurl", "Redigate", "predirect", "reddRECT", " redir", "REDirection", "REDir", "predirection", "REDurl", "RedRECT", "REDirect", "redirection", "predurl", "ederer", "edurl", "indrict", "rightirect", "Redurl", "indirect", "Redrict", "reddirect", "edirect", "preddraw", "Rederer", " redirection", "redigate"], "session": ["person", "user", "ess", "group", "store", "cache", "input", "sql", "application", "save", "context", "instance", "task", "current", "use", "s", "params", "browser", "shared", "client", "Session", "system", "window", "container", "still", "ession", "sid", "environment", "layout", "state", "json", "cookie", "condition", "connection", "metadata", "server", "data", "trip", "relation", "local", "ESSION", "activity"]}}
{"id1": "15018553", "id2": "15166511", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["encrypted", "uncrypted", "uncode", "encode", "Encode", "Encrypt", " encrypted", "unccrypt", "uncrypt", "Enccrypt", "Encrypted", " enccrypt", " encode", "enccrypt"], "text": ["message", "path", "read", "pt", "th", "value", "title", "input", "url", "select", "output", "translation", "nt", "t", "ut", "string", "str", "tx", "test", "x", "ext", "TEXT", "word", "txt", "source", "q", "p", "ct", "act", "pattern", "password", "document", "msg", "w", "body", "form", "buffer", "cont", "content", "print", "code", "v", "now", "Text", "data", "name", "phrase", "comment"], "md": ["ad", "nd", "cd", "mond", "dh", "del", "err", "mt", "grad", "MD", "mp", "m", "pm", "pkg", "and", "der", "rm", "mk", "t", "mac", "mode", "c", "de", "hd", " dd", "mo", "mc", "df", "img", "h", "ct", "cmd", "dd", "pd", " cmd", "det", "cmp", "msg", "ind", "mod", "sha", "mm", "ld", "bd", "od", "dig", "mn", "mb", "mand", "d", "metadata", " cd", "mem", "hash", "mg", "ms", "di", "doc", "dm"], "md5hash": ["md2sum", "md512sha", "md3hex", "md5sha", " md2cloth", "md3Hash", "md512h", " md2hash", "md5cloth", "md2sha", " md3Hash", "md3cloth", "md3sum", "md2hex", "md2Hash", " md2hex", " md3h", " md5cloth", "md3h", "md5h", "md512sum", " md5Hash", " md3sha", "md5hex", "md5Hash", " md5sha", " md5h", " md2sum", " md3sum", " md5sum", "md2hash", "md512hash", " md5hex", "md512Hash", "md5sum", "md2h", "md3hash", " md3hash", "md3sha", "md2cloth"]}}
{"id1": "20028790", "id2": "13595251", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 0, "substitutes": {"setBundleInfoName": ["setBundleInfTitle", "setBundleInfNames", "setBundleFileName", "setBundleFileNames", "setBundleFileLabel", "setBundleDataNames", "setBundleDataLabel", "setBundleInfLabel", "setBundleInfoLabel", "setBundleDataTitle", "setBundleFileTitle", "setBundleDataName", "setBundleInfoNames", "setBundleInfName", "setBundleInfoTitle"], "location": ["library", "path", "message", "Location", "template", "where", "address", "filename", "translation", "description", "reference", "ocation", "l", "program", "availability", "country", "directory", "loc", "color", "uri", "area", "layout", "document", "command", "position", "LOC", "remote", "history", "resource", "language", "name", "comment", "point", "local", "localhost"], "list": ["block", "dl", "collection", "net", "lists", "out", "all", "m", "map", "ist", "add", "l", "L", "missing", "detail", "n", "p", "batch", "listed", "spec", "sequence", "set", "stack", "LIST", "chain", "print", "v", "local", "level", "name", "status", "pool", "table"], "url": ["b", "dl", "http", "URL", "lr", "r", "gb", "f", "open", "abs", "l", "ur", "link", "str", "browser", "job", "google", "html", "nl", "loc", "hl", "lb", "mount", "uri", "char", "rl", "el", "sb", "ref", "mail", "Url", "build", "ssl", "ul", "bel", "base", "rel", "ll", "pl", "sl"], "br": ["b", "read", "bro", "dr", "bridge", "lr", "bp", "r", "be", "gb", "bl", "sr", "rb", "str", "browser", "pr", "nl", "ber", "next", "kr", "bs", "er", "BR", "tr", "div", "cr", "ch", "wr", "bh", "Br", "bd", "buf", "gr", "bt", "mr", "rel", "hr", "fr"], "line": ["message", "LINE", "block", "header", "liner", "online", "iter", "trace", "note", "store", "lo", "sql", "ln", "inline", "l", "ine", "frame", "string", "eline", "cell", "se", "record", "link", "lock", "entry", "lin", "nl", "rule", "word", "linux", "row", "next", "page", "source", "label", "le", "detail", "Line", "handle", "char", "part", "sequence", "text", "body", "style", "log", "chain", "buffer", "stay", "piece", "print", "code", "sample", "data", "name", "phrase", "point", "comment"], "pos1": ["position3", "index3", "positionone", " posOne", "po3", "Pos1", "posone", "position2", "pos2", "POS1", "pos3", "POS0", "position1", "position0", "pos0", "indexOne", "PosOne", "POSOne", "Pos0", " pos2", "poOne", "po1", "Pos2", "posOne", "index1", "poone", "POS2", "indexone", "positionOne", " pos0"], "bundleSymbolicName": ["bundleSyMBolicType", "bundleSymbololicNames", "bundleSymbolicalFamily", "bundleSymbolicalName", "bundleSymbularFamily", "bundleSyMBicalType", "bundleSymboryNames", "bundleSyMBicalname", "bundleSymbicalVersion", "bundleSymbololicFamily", "bundleSymbolicCode", "bundleSymbularType", "bundleSymboryname", "bundleSyMBicalVersion", "bundleSyMBolicCode", "bundleSymbicName", "bundleSymbolicalType", "bundleSymbicalFamily", "bundleSymbularname", "bundleSyMBicalNames", "bundleSymbicalName", "bundleSymbolicname", "bundleSyMBicalCode", "bundleSymbolicNames", "bundleSymbolicalNames", "bundleSymbolicVersion", "bundleSymbololicType", "bundleSymbicCode", "bundleSymboryName", "bundleSymbicalNames", "bundleSyMBicalName", "bundleSyMBolicName", "bundleSymbicNames", "bundleSyMBolicNames", "bundleSymbololicName", "bundleSymbolicType", "bundleSyMBolicVersion", "bundleSymbicalname", "bundleSymboryType", "bundleSymbicalType", "bundleSymbicalCode", "bundleSymboryCode", "bundleSymbolicFamily", "bundleSymbularName", "bundleSymbicVersion", "bundleSymboryVersion", "bundleSyMBolicname", "bundleSymbularNames"], "bundleName": ["basketname", "fasketType", "fasketname", "brundleInfo", "branchname", " banchname", "branchInfo", "balename", " banchName", "banchName", "fundlename", "bowerInfo", "bowerString", "bowerName", "basketVersion", "baleType", "bowerType", "banchname", "brundleName", "fundleName", "bachmentname", "bundleInfo", "brundlename", "banchInfo", "fundleVersion", "bundleType", "bachmentInfo", "branchName", "bundleVersion", "fasketName", "baleInfo", "basketName", "fasketVersion", "baleVersion", "bachmentName", " bundlename", "fundleType", "basketType", "banchString", " banchInfo", "bundleString", " bundleInfo", "brundleString", "bowername", "baleName", "bowerVersion", "bundlename", "branchString"], "info": ["dev", "user", "match", "iter", "block", "check", "item", "tip", "value", "http", "conf", "note", "all", "update", "query", "INFO", "information", "iso", "context", "f", "alias", "error", "instance", "tf", "fo", "inf", "job", "summary", "entry", "self", "ext", "image", "detail", "fit", "details", "def", "state", "json", "Info", "report", "te", "me", "history", "i", "event", "inner", "now", "data", "comment", "status", "index", "obj", "local"]}}
{"id1": "21488518", "id2": "16378239", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "label": 1, "substitutes": {"createNew": ["createResource", "CreateNew", "getNew", "dataFresh", "CreateResource", "createNext", "dataResource", "CreateFresh", "getNext", "dataNew", "CreateNext", "dataNext", "getFresh", "getResource", "createFresh"], "name": ["alias", "path", "template", "value", "format", "title", "time", "id", "type", "address", "filename", "ename", "lat", "file", "description", "current", "use", "common", "string", "client", "size", "nm", "key", "Name", "word", "n", "one", "null", "source", "missing", "end", "action", "handle", "version", "password", "part", "named", "old", "body", "ame", "none", "no", "NAME", "only", "names", "event", "resource", "code", "base", "now", "create", "data", "prefix", "index", "local", "normal"], "in": ["In", "b", "is", "input", "rin", "it", "al", "r", "err", "file", "ma", "IN", "inn", "reader", "t", "s", "bin", "c", "vin", "ins", "source", "from", "mc", "p", "en", "xml", "ind", "body", "mat", "din", "mm", "isin", "get", "cin", "con", "i", "gin", "asin", "inner", "data"], "length": ["read", "message", "bytes", "path", "value", "input", "amount", "description", "count", "padding", "size", "stream", "len", "password", "height", "sequence", "text", "body", "position", "Length", "enc", "duration", "shape", "buffer", "content", "total", "max", "data"], "contentType": ["contenttype", "Contenttype", "ContentType", " contentTypes", " contenttype", "contentLength", "mediaType", "ContentTypes", "ContentLength", "mediaTypes", "mediatype", "contentTypes", "mediaLength", " contentLength"], "dest": ["obj", "path", "there", "iter", "rest", "src", "prop", "home", "comb", "tmp", " Dest", " dst", "oe", "dir", "Dest", "origin", "cat", "self", "loc", "this", "source", "nom", "orig", "resp", "copy", " destination", "result", "folder", "coord", "target", "dat", "parent", "temp", "trans", "disk", "cont", "wb", "d", "mem", "lit", "table"], "out": ["obj", "external", "ex", "net", "OUT", "ou", "it", "write", "output", "ion", "file", "col", "t", "cos", "s", "oss", "client", "Out", "n", "end", "null", "os", "go", "ent", "en", "to", "off", "up", "copy", "io", "op", "sys", "outs", "set", "w", "conv", "OU", "port", "po", "log", "serv", "conn", "con", "co", "aos", "res", "o", "outer", "can"], "request": ["library", "message", "user", "QUEST", "input", "query", "search", "url", "open", "relative", "select", "reference", "current", "ire", "params", "quest", "push", "req", "Request", "move", "pair", "ask", "forward", "result", "require", "requ", "report", "re", "remove", "enter", "create", "response", "claim", "begin", "reset", "child"]}}
{"id1": "16557837", "id2": "19096138", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFromTo": ["copyFromDir", "copyfromFile", "transferfromTo", "copyFromFrom", "transferfromFrom", "transferfromFile", "transferFromDir", "copyFormTo", "copyFileTo", "copyFileFrom", "copyFileDir", "transferfromDir", "copyFromFile", "copyFormFrom", "copyfromFrom", "copyFileFile", "copyfromTo", "transferFromTo", "transferFromFrom", "copyFormDir", "copyFormFile", "transferFromFile", "copyfromDir"], "srcFile": ["srcPage", " srcFILE", "sortFiles", " srcPage", "ivFILE", "rcPage", " srcDir", "destPage", " srcSourceFile", " srcfile", "sbFilename", "sortPage", "destPath", "srcDir", "destfile", "sysfile", "sysPlace", " srcFiles", "rcFile", "sourcefile", "sysFilename", "rcFILE", "sourceFile", "sourceDir", "ivFile", "srcFilename", "srcFiles", "sysFile", "srcPlace", "sortSourceFile", "sortFILE", "ivPage", "srcPath", "srcFILE", "sortFile", "srcSourceFile", "rcFiles", "sbPlace", "destDir", " srcPath", "rcPath", "rcDir", "sbFile", "srcfile", " srcPlace", "sbfile", "ivSourceFile", " srcFilename", "sourcePath"], "destFile": [" destDirectory", "etcFilename", "DestFile", "memFILE", "memfile", "etcFILE", "destFilename", "etcDirectory", "descFilename", " destPath", "DestFilename", "DestDirectory", "optFilename", "destfile", "memFile", "destPath", "srcDir", " destfile", "DestFiles", "restDirectory", "destFILE", "optfile", " destFiles", "descFILE", "DestPath", "descDir", "srcFilename", "srcFiles", "Destfile", "restFile", "optDir", "restFilename", "srcPath", " destDir", "DestDir", "destDirectory", "destDir", "DestFILE", "srcDirectory", "memFilename", "descFile", "restFILE", "optFile", "destFiles", "etcFile", " destFilename", " destFILE"], "in": ["In", "read", "ex", "iter", "is", "init", "net", "on", "input", "rin", "it", "all", "id", "info", "ci", "m", "ain", "IN", "inn", "t", "add", "l", "inside", "inf", "bin", " input", "ar", "vin", " IN", "ins", "n", "source", "from", "mc", "inc", "en", "io", "ind", "body", "din", "mm", "isin", "re", "cin", "conn", "con", "i", "gin", " din", "co", "inner", "can", "o", "local", "ini"], "out": ["group", "over", "on", "file", "t", "str", "pretty", "summary", "boot", "ext", "ins", "p", " OUT", "not", "det", "ne", "outs", "unt", "set", "ch", " Out", "writer", "OU", "log", "conn", "con", "i", "co", "sum", "v", "o", "ot", "inv", "obj", "ex", "or", "ou", "all", "write", "ion", "nt", "c", "end", "txt", "os", "cn", "json", "desc", "outer", "pool", "table", "cfg", "at", "net", "list", "session", "term", "Out", "n", "up", "tree", "io", "sys", "w", "ret", "g", "print", "aos", "res", " output", "OUT", "store", "cache", "it", "output", "client", "null", "screen", "cmd", "to", "msg", "no", "gr", "can", "inter"], "fis": ["foos", "foist", "sfisan", "sfiss", "fois", "freris", "foens", "sfos", "elfisan", "foiss", "freens", "Fis", "sfis", " fisan", "elfos", " fois", "foris", "fiss", "fens", "freis", "cis", "Fist", "cfos", "fris", "foois", "cens", "cfois", "elfis", "cfiss", " fiss", "cois", "fist", "Fois", " fist", "cfis", "cris", "fisan", "elfiss", "freois", "Fos", "Fiss"], "fos": ["vot", "flos", "foos", "wres", "fois", "vios", "fortoss", "fres", " foes", "fios", "flot", "pis", "fortsys", "los", "wis", "fooes", "vom", "pos", "loes", "lis", " fios", "Foss", "foss", " fsys", "fortos", "fom", "Fres", "fortres", "floss", " fom", "fioes", " foss", "wos", " fot", "flres", "fous", "wom", "Fsys", "foes", "fsys", "vos", "pus", "flom", "poes", "lus", "voss", "voes", "flis", "fiios", "fus", "Fos", "fiot", "fot", " fres"], "srcModified": ["srcModsmodified", "srcMODified", "rcModified", "srcModsification", "srcMODification", "rcModify", "srcModsined", "srcModined", "srcmoded", "rcTred", "curModsification", "curModsmodified", "srcHasified", "srcTrified", "rcTrmodified", "srcTrify", "rcModed", "rcModifier", "srcHasifier", "srcTrmodified", "srcModifier", "curModsify", "srcMODify", "srcMODed", "curModsified", "srcmodified", "curModification", "srcModsified", "srcHasmodified", "curModify", "srcModsifier", "curModmodified", "rcModmodified", "rcModined", "rcTrined", "curModified", "srcmodify", "srcModed", "rcTrified", "srcModify", "srcModmodified", "srcModification", "srcTred", "srcModsify", "rcTrifier", "srcMODmodified", "rcTrify", "srcTrined", "srcHasined", "srcMODifier", "srcTrifier", "srcmodifier"]}}
{"id1": "19944975", "id2": "21824901", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["writeConfig", "outputContent", " writeConfig", "writeContent", "writeSettings", " writeContent", "outputConfiguration", "WriteContent", "WriteConfiguration", "outputSettings", "outputConfig", "WriteConfig", "WriteSettings", " writeSettings"], "out": ["b", "group", "check", "at", "over", "OUT", "ou", "all", "err", "output", "nt", "list", "file", "free", "t", "help", "pretty", "client", "c", "Out", "n", "this", "null", "p", "ent", " OUT", "h", "cmd", "to", "up", "io", "cm", "outs", "result", "msg", "set", "w", "report", "ch", "writer", "OU", "g", "log", "conn", "con", "print", "aos", "res", "o", "outer", "v", "cast", "pool", "table"], "url": ["user", "path", "rect", "dl", "cert", "net", "http", "URL", "r", "address", "f", "file", "abs", "l", "gl", "link", "str", "client", "nl", "key", "loc", "domain", "uri", "pattern", "char", "rl", "ref", "ret", "mail", "Url", "ssl", "resource", "bel", "location", "base", "rel", "ll", "name", "mount", "service", "sl"], "in": ["In", "user", "read", "is", "sin", "on", "input", "rin", "al", "it", "r", "f", "m", "ma", "IN", "file", "inn", "and", "reader", "l", "inside", "str", "bin", "ins", "source", "from", "null", "mc", "en", "up", "io", "el", "ind", "st", "body", "din", "isin", "none", "cin", "serv", "con", "i", "gin", " din", "sum", "inner", "sample"]}}
{"id1": "8164056", "id2": "15202804", "code1": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"encode": ["genode", "enoder", "Encode", " encoder", "genenc", " enccode", "enenc", "enode", "genoder", "Enenc", "gencode", " encenc", "Enoder", "Enode"], "str": ["b", "obj", "strings", "input", "it", "r", "comm", "m", "t", "Str", "string", "ctr", "c", "n", "this", "txt", "br", "p", "arr", "coll", "char", "tr", "sp", "msg", "spec", "st", "text", "w", "STR", "wr", "conv", "enc", "e", "print", "v", "res", "data", "name", "oct"], "buf": ["b", "aux", "agg", "obj", "iter", "block", "foo", "uf", "mu", "cap", "bp", "tmp", "output", "pkg", "bc", "rb", "bo", "queue", "cb", "proc", "printf", "que", "Buffer", "next", "bg", "txt", "av", "br", "cv", "cmd", "box", "batch", "hung", "bag", "bound", "bar", "msg", "bh", "Buff", "bn", "temp", "buffer", "cf", "cur", "aer", "buff", "np", "ob", "db", "var", "pool", "pb"], "md5": ["dd45", " Md3", "dig3", "dd5", " MD3", "MD3", " md12", "mdlet", "dig2", " mdct", " mdlet", " md3", "md3", " md8", "dig8", "MD2", "MD5", "dd8", " MDlet", "MD12", "md2", "md12", "dig45", " Mdct", "dig5", " Mdlet", "dd3", " MD5", " md45", "md45", " Md5", "md8", "dig12", " MDct", " md2", "mdct"], "bytes": ["b", "pieces", "gs", "words", "files", "gets", "clips", "vals", " slices", " tmp", "sites", "binary", "vs", "gb", "iers", "tmp", "fps", "bis", "ashes", "cb", "parts", "bes", "bps", "pointers", "ings", " b", "tes", "fixes", "xs", "bits", " pixels", "services", "bs", "Bytes", "classes", "outs", "frames", " buffers", "steps", "xy", "its", "seconds", "js", "bles", "ios", "names", " chunks", "terms", "es", "values", "pages", "blocks"], "i": ["b", "ij", "ex", "is", "init", "us", "gi", "qi", "ski", "id", "it", "xi", "\u0438", "ci", "li", "info", "I", "m", "di", "ai", "ix", "gu", "ki", "x", "c", "key", "hi", "bi", "n", "ii", "a", "q", "multi", "u", "mi", "uri", "ic", "in", "batch", "major", "io", "y", "ind", "json", "im", "phi", "iu", "sim", "ie", "conv", "ji", "chain", "me", "si", "v", "pi", "ti", "cli", "point", "j", "ui", "index", "ini", "ip"], "s": ["b", "ls", "gs", "is", "gets", "ts", "ds", "fs", "sql", "r", "f", "z", "join", "sv", "abs", "t", "l", "se", "string", "sq", "n", "rs", "txt", "single", "os", "p", "h", "S", "sp", "spec", "y", "sol", "hs", "set", "sb", "js", "conv", "g", "ps", "ss", "sf", "sw", "v", "j", "sl", "ns"]}}
{"id1": "15018553", "id2": "16142024", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["encrypted", "uncrypted", "uncode", "encode", "Encode", "Encrypt", " encrypted", "unccrypt", "uncrypt", "Enccrypt", "Encrypted", " enccrypt", " encode", "enccrypt"], "text": ["message", "path", "read", "pt", "th", "value", "title", "input", "url", "select", "output", "translation", "nt", "t", "ut", "string", "str", "tx", "test", "x", "ext", "TEXT", "word", "txt", "source", "q", "p", "ct", "act", "pattern", "password", "document", "msg", "w", "body", "form", "buffer", "cont", "content", "print", "code", "v", "now", "Text", "data", "name", "phrase", "comment"], "md": ["ad", "nd", "cd", "mond", "dh", "del", "err", "mt", "grad", "MD", "mp", "m", "pm", "pkg", "and", "der", "rm", "mk", "t", "mac", "mode", "c", "de", "hd", " dd", "mo", "mc", "df", "img", "h", "ct", "cmd", "dd", "pd", " cmd", "det", "cmp", "msg", "ind", "mod", "sha", "mm", "ld", "bd", "od", "dig", "mn", "mb", "mand", "d", "metadata", " cd", "mem", "hash", "mg", "ms", "di", "doc", "dm"], "md5hash": ["md2sum", "md512sha", "md3hex", "md5sha", " md2cloth", "md3Hash", "md512h", " md2hash", "md5cloth", "md2sha", " md3Hash", "md3cloth", "md3sum", "md2hex", "md2Hash", " md2hex", " md3h", " md5cloth", "md3h", "md5h", "md512sum", " md5Hash", " md3sha", "md5hex", "md5Hash", " md5sha", " md5h", " md2sum", " md3sum", " md5sum", "md2hash", "md512hash", " md5hex", "md512Hash", "md5sum", "md2h", "md3hash", " md3hash", "md3sha", "md2cloth"]}}
{"id1": "13563706", "id2": "8216539", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"doGet": ["doget", "DoGET", " doGET", " doget", "handleget", "DoGet", "doGET", "handleGET", " doPut", "handlePut", "handleGet", "doPut", "Doget", "DoPut"], "request": ["setup", "message", "transform", "path", "user", "each", "http", "QUEST", "input", "query", "search", "application", "url", "address", "context", "subject", "project", "first", "reference", "current", "use", "frame", "directory", "route", "Request", "forward", "xml", "initial", "attribute", "document", "command", "version", "view", "socket", "report", "position", "get", "parent", "re", "complete", "connection", "event", "resource", "create", "order", "hello", "reset", "call"], "response": ["reply", "message", "block", "header", "ce", "collection", "format", "display", "http", "search", "write", "application", "output", "description", "frame", "network", "success", "summary", "answer", "zero", "continue", "image", "next", "exit", "ve", "resp", "tree", "version", "document", "default", "result", "foundation", "sequence", "view", "respond", "json", "console", "report", "position", "see", "fire", "render", "condition", "connection", "server", "print", "res", "security", "hash", "Response", "example", "status", "service", "relation"], "selectedPage": ["selectionItem", "electionPage", "selectionFile", " selectedFile", "lectedLine", "selectedLine", "lectedFile", "selectPage", " selectedPort", "specifiedFrame", "selectItem", "selectionPage", "electedPage", "verifiedFile", "selectedDocument", "selectedpage", "namedPort", "matchedPort", "lectedItem", " selectedFrame", "lectedPort", " selectedpage", "singlepage", "selectLine", "namedLine", "matchedpage", "electedPort", "matchedPage", "selectFile", "selectionToken", "singlePage", "singleFrame", "lectedPage", "selectionLine", " selectedRow", "selectedToken", "namedFrame", "namedKey", "specifiedDocument", "selectPort", "lectedRow", "selectPath", "selectedRow", "verifiedRow", "singlePort", "specifiedPort", "lectedDocument", "selectedPath", " selectedPath", "selectedItem", "verifiedPage", "namedPage", "matchedFrame", "lectedKey", " selectedKey", "namedToken", "verifiedpage", "electionDocument", "lectedpage", "lectedToken", "selectedFile", "specifiedPage", "electedpage", "lectedFrame", "selectedKey", "selectedPort", "electionFrame", "namedpage", "lectedPath", "selectedFrame", "electionPort", "selectionPort", " selectedLine", "electedFrame"], "page": ["group", "pp", "project", "current", "phone", "image", "next", "p", "port", "log", "line", "resource", "profile", "node", "filter", "user", "collection", "url", "age", "self", "window", "row", "proxy", "successful", "result", "site", "chain", "pointer", "point", "pool", "table", "message", "block", "application", "instance", "network", "record", "peer", "layout", "version", "Page", "phrase", "channel", "pages", "display", "cache", "number", "office", "associated", "address", "be", "force", "output", "frame", "client", "rule", "created", "menu", "object", "to", "document", "view", "policy", " Page", "position", "form", "parent", "me", "server", "language", "complete"], "portalRequest": ["portaleApply", "portalingAccess", "portalaAccess", "portalityRequest", "portsalResponse", "PortalThread", " portalApply", "portalaCall", "portsortalEvent", "portualRequest", "terminalidQuery", "portortalContext", "portalidSession", "portalContext", "portortalQuery", "portualrequest", " portalCall", "portaleResponse", "portsortalResponse", "portaleSession", "PortalContext", "portaleContext", " portaleCall", "terminalRequest", "portalrequest", "terminalQuery", "PortalQuery", "portalidResponse", "portalingRequest", "portralContext", "PortalResponse", "portpalContext", "terminalResponse", "portalThread", "portalidContext", "portortalRequest", "PortaleContext", "portpalRequest", "portralResponse", "portalidRequest", "portralQuery", "portalFrame", "PortaleThread", "portalidFrame", "portsortalRequest", "portortalThread", " portaleRequest", "portalityResponse", "portpalThread", " portaleApply", "portortalrequest", "portalerequest", "portalingApply", "portalAccess", "portalQuery", "portralSession", "portaleQuery", "portsortalrequest", " portalAccess", "PortalRequest", "terminalidResponse", "portalaRequest", " portaleAccess", "PortalFrame", "portsalrequest", "portortalResponse", "PortaleRequest", "terminalidRequest", "portaleEvent", "portaleCall", "PortaleFrame", "portalityFrame", "portalingCall", "portpalResponse", "portaleThread", "portsalRequest", "portalaApply", "portaleAccess", "PortaleResponse", "portalityContext", "portaleRequest", "portualEvent", "portalApply", "portualResponse", "portalSession", "portsalEvent", "portaleFrame", "portalEvent", "portalidQuery", "PortaleQuery", "portralRequest", "terminalSession", "portalCall", "portortalEvent", "portalResponse", "terminalidSession"], "pageProp": ["poolProp", "propertyPriv", "pagePriv", " pageComp", "propertyProp", "pagePred", "agePro", " pagePriv", "profileZip", "pageProperty", "keyProperty", "profilePred", "poolPred", "phrasePr", "pagePro", "officeProp", "pageComp", "officePriv", "pageZip", " pagePr", "imagePr", "sectionPred", "imageProp", "agePred", "officeDef", "pageDef", "agePr", "propertyDef", " pagePred", "sectionPro", "imagePred", "pagePr", "imagePro", " pagePack", "phraseProperty", "profilePro", "propertyPack", "ageProp", "keyProp", " pagePro", "poolZip", "poolPro", " pageProperty", "sectionProp", "phraseComp", "keyComp", " pageDef", "profileProp", "officePack", "sectionZip", "keyPr", "phraseProp", "pagePack"], "possiblePage": ["PossiblyPage", "PossiblePage", "piblePage", "pibleChild", "pbableCollection", " packedLine", "possiblyCollection", "possibleLine", " possibleTag", "pentialPage", "possiblyUser", "pablePage", "pableLine", "pspecifiedPage", "pspecifiedPages", "packedTag", "possiblyTag", "pbableUser", "possiblyChild", "packedCollection", "possibleChild", " possibleLine", "PossiblePages", "Possiblepage", "PossiblyCollection", " packedTag", " possibleCollection", "pentialTag", "pibleCollection", "possiblepage", "pbableChild", "pspecifiedpage", "pibleUser", "possibleTag", "PossiblyUser", "pbablePage", "pableTag", "possibleCollection", "PossibleTag", "PossibleCollection", "possiblyLine", "possiblePages", " packedCollection", "possiblyPage", "PossiblyChild", "pentialpage", "pableCollection", "pspecifiedTag", " packedPage", "packedPage", "pentialPages", "PossibleChild", "possibleUser", "packedLine", "PossibleUser"], "property": ["message", "header", "value", "Property", "title", "function", "prop", "type", "address", "class", "description", "config", "properties", "second", "frame", "string", "trace", "feature", "key", "rule", "domain", "p", "object", "rue", "expression", "attribute", "owner", "command", "field", "policy", "definition", "position", "behavior", "resource", "metadata", "integer", "location", "operator", "name", "phrase", "relation", "service", "variable"], "referer": ["relender", "relerential", "rorered", "reportrer", "Referee", "retered", "diffrer", "deferer", "refrer", "verrer", "redere", "reonder", "aferential", "refener", "printrier", "afrer", "reener", " refered", "referential", "Refere", "vererential", "refered", "vererer", "requonder", "requering", "retarer", "rorirect", "defrer", "relener", "defirect", "reportered", "refere", "aferer", " refirect", "refonder", "retrer", "relrer", "rorrer", "differer", "rederee", "refering", "refarer", "afener", "fener", "frer", "requerer", "rerier", "rorerer", "reere", "reterer", "reender", "printerer", "refirect", "reering", "rangeender", "reeree", "differing", "ferer", "reerer", "reered", "refender", "diffonder", " refrer", "refrier", "reerential", "redrer", "rangerer", "relering", "rearer", "rederer", "reportarer", "Refrer", "rangeerer", "reporterer", "Referer", "defered", "verrier", "relerer", "fering", "printrer", "printerential", "referee", "rerer", "requrer", "rangeener"], "e": ["r", "f", "err", "oe", "error", "m", "echo", "t", "se", "eg", "ae", "x", "de", "n", "ception", "a", "p", "h", "eeee", "er", "eu", "ge", "E", "te", "ie", "g", "es", "me", "event", "eur", "o", "ee"]}}
{"id1": "20310134", "id2": "3409084", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "label": 0, "substitutes": {"copyFile": [" cpStream", " cpDirectory", " duplicateFile", " CopyDirectory", " cpFile", " CopyFile", " copyfile", " Copyfile", " duplicateDirectory", " duplicateStream", " copyStream", " CopyStream", " cpfile", " duplicatefile", " copyDirectory"], "in": ["b", "In", "is", "init", "on", "input", "rin", "id", "it", "r", "ain", "IN", "inn", "l", "inf", "as", "ins", "source", "inc", "from", "en", "ic", "up", "io", "el", "ind", "old", "din", "mm", "isin", "cin", "i", "gin", "ini"], "out": ["b", "ex", "at", "OUT", "net", "ou", "it", "err", "output", "nt", "t", "help", "l", "s", "gt", "c", "Out", "n", "null", "os", "p", "to", "io", "op", "ne", "outs", "msg", "w", "po", "g", "log", "serv", "v", "o", "ot"], "inChannel": ["oinApplication", "outchannel", " inApplication", "sinButton", "intButton", " inchannel", " inRoom", "insidePanel", "intChannel", " inClient", "inputPanel", " inListener", "oinChannel", " inCase", "cinListener", "inConnection", "inListener", "inputChannel", " inChan", "outConnection", "insideChannel", " inConnection", "sinRoom", "inApplication", " inButton", "dinCommand", "oinchannel", "inCase", "inClient", " inPanel", "cinButton", "inButton", "inCommand", "dinButton", "outApplication", "oinConnection", "inRoom", "insideCommand", "sinCase", "sinChannel", "cinChannel", "sinClient", "intCommand", "intChan", "cinClient", "cinCase", "inchannel", "inChan", "dinChannel", "sinListener", "cinRoom", "inPanel", " inCommand", "inputCommand", "dinChan"], "outChannel": ["outchannel", "outputCh", "fullChan", " outCategory", " outChan", "outCategory", "fullChannel", "cosChan", "OUTCan", "outerConnection", "inCh", "outputchannel", "outerChan", "cosChannel", " outConnection", "cosCategory", " outUser", "outConnection", "inCategory", " outCh", "outMember", " outCan", "OUTCategory", " outchannel", "fullCan", "OUTChan", "outputChan", "noteChan", "outUser", "noteMember", "noteChannel", "noteCategory", "outputChannel", "inMember", "outCh", "OUTChannel", "outCan", "outerChannel", "outerUser", "outputUser", "inchannel", "inChan", "outChan", "fullCategory", "cosMember", "outputConnection"]}}
{"id1": "5399593", "id2": "22875895", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void readVersion() {\n        URL url = ClassLoader.getSystemResource(\"version\");\n        if (url == null) {\n            return;\n        }\n        BufferedReader reader = null;\n        String line = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Version=\")) {\n                    version = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Revision=\")) {\n                    revision = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Date=\")) {\n                    String sSec = (line.split(\"=\"))[1];\n                    Long lSec = Long.valueOf(sSec);\n                    compileDate = new Date(lSec);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"encrypt": ["decrypt", "encrypted", "enccode", "encode", "ecrypt", "ecrypted", "decode", "enode", "ecode", "eccode", "enrypted", "deccode", "decrypted", "enrypt"], "plaintext": ["plainth", "plainText", "preText", "preword", "pretext", " Plainpassword", " Plaintext", "plainpassword", "mainword", "plaincontext", "aintext", " Plaininput", "plainword", "mainText", " plainword", "aininput", " plainth", " plaincontext", " plaininput", "maincontext", "plaininput", "precontext", " plainText", " plainpassword", "maintext", "ainth", "ainpassword", " Plainth"], "UnsupportedEncodingException": ["UnsupportedEncodedError", "UnsupportedEncodedEx", "UnsupportedCompodingError", "UnsupportedEncryptionError", "UnsupportedEncoderException", "UnsupportedEncodedException", "UnsupportedEncryptionEx", "UnsupportedCompoderEx", "UnsupportedEncoderError", "UnsupportedEncoderEx", "UnsupportedEncodingError", "UnsupportedCompoderException", "UnsupportedEncodingEx", "UnsupportedCompoderError", "UnsupportedEncryptionException", "UnsupportedCompodingException", "UnsupportedCompodingEx"], "md": ["ad", "nd", " mc", "cd", "dr", "gm", "del", "ms", " MD", "mt", "red", "MD", "m", "mp", "pm", "nt", "grad", "der", "mk", "add", "exec", " ma", "hd", " dd", "mo", "mc", "df", " mo", "dd", "cmd", "pd", "def", " cmd", "det", "ind", "mod", "sha", "mm", "ld", "med", "bd", "od", "mn", "mb", "mand", "d", " Md", "sd", " m", "mg", " mm", "sm", "dm"], "raw": ["known", "message", "read", "bytes", "RAW", "empty", "full", "was", "draw", "out", "input", "all", "strip", "des", "clean", "core", "load", "bare", "row", "n", "orig", " Raw", "serial", "hook", "sh", "valid", "Raw", "json", "unsigned", "clear", "hex", "aw", " RAW", "buf", "custom", "rendered", "available", "pack", "mem", "data", "cooked"], "hash": ["message", "cloth", "check", "hat", "zh", "id", "search", "component", "ssh", "unknown", "ash", "hed", "ashes", "ASH", "mac", "html", "key", "mask", "h", "dump", "password", "sh", "tr", "result", "shadow", "height", "ashed", "hidden", "sha", "has", "hex", "bh", "Hash", "total", "sum", "code", "proof", "name", "tag"]}}
{"id1": "1421557", "id2": "2668634", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeStringToFile", "encodeFileToFiles", "encodeStringAsDisk", "encodeFileFromStream", "encodeFileFromDisk", "encodeStringAsFile", "encodeFileAsFiles", "encodeFiletoFile", "encodeFiletoFiles", "encodeStringToStream", "encodeFileAsFile", "encodeFileAsDisk", "encodeFileAsStream", "encodeFileFromFile", "encodeStringAsStream", "encodeStringToDisk", "encodeFiletoDisk", "encodeFiletoStream", "encodeStringToFiles", "encodeFileToStream", "encodeStringAsFiles", "encodeFileToDisk"], "infile": ["InFile", "inputfile", "outbase", "inbase", " inFile", "inFile", "outpath", "Inbase", "outFile", "Inpath", " infilename", "Infile", "outfilename", "infilename", "inpath", "inputpath", "inputfilename", "inputFile", " inpath", " inbase"], "outfile": ["inname", "newfile", " outname", "newname", "newfilename", "newFile", "inFile", "tofile", "todir", "fromfp", " outfilename", "infp", "outFile", "fromfile", "outdir", "indir", "fromdir", "tofp", "toFile", "outfp", " outFile", "outfilename", "infilename", "fromFile", "outname"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "image", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ro", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "null", "fn", "os", "en", "cn", "to", "flush", "up", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "can", "aos", "o", "res", "outer", "inner", "ot"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "queue", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "length", "black", "stack", "temp", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", "commit", "ccess", "cess", "value", "accept", "fail", "growth", "warning", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "ith", "successful", "good", "please", "ceed", "town", "result", "valid", " Success", "successfully", " okay", " failure", "ratulations", "photo", "sufficient", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "19738435", "id2": "20920051", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["read", "transform", "match", "format", "file", "request", "construct", "parser", "se", "link", "load", "proc", "arse", "pair", "layer", "handle", "xml", "document", "json", "slice", "build", "process", "shape", "resource", "create", "replace", "service"], "url": ["ls", "path", "dl", "http", "URL", "input", "id", "sql", "open", "address", "file", "abs", "l", "ur", "link", "string", "str", "parser", "gl", "client", "browser", "https", "web", "nl", "term", "loc", "page", "q", "host", "u", "uri", "util", "char", "github", "xml", "document", "el", "ref", "impl", "build", "Url", "conn", "ssl", "resource", "location", "base", "name", "ll", "mount", "sl", "localhost"], "target": ["path", "group", "collection", "template", "component", "type", "context", "output", "project", "nt", "instance", "t", "Target", "record", "top", "root", "container", "term", "source", "scope", "object", "graph", "to", "pattern", "layout", "tree", "owner", "result", "report", "parent", "resource", "metadata", "model", "arget", "name", "node", "other", "local", "table"], "parseURL": ["parseUrl", "parseSR", "arseSR", "arsePage", "buildUrl", " parseUrl", "parsePage", "arseURL", "buildURL", " parseSR", "arseUrl", "buildSR", " parsePage", "buildPage"], "connection": ["generation", "creator", "Connection", "application", "open", "context", "database", "ion", "description", "session", "link", "network", "client", "directory", "entry", "connected", "c", "character", "still", "created", "uri", "established", "cone", "nc", "document", "command", "result", "socket", "position", "writer", "conn", "con", "condition", "resource", "communication", "response", "connect", "channel", "relation"], "charset": ["charasset", "chresect", "CHARSets", "charsets", "chearsect", "charsheet", "cheresset", "chararsset", "chagnheet", "chresets", "chasset", "charaset", "chacterset", "charsect", "CHarset", "chasheet", "chaset", "CHarsets", "charsset", "chatsets", "CHARSet", "chagnset", "chearsset", "chARSets", "chatset", "CHARSat", "cheresets", "chararset", "chactersET", "charsET", "charasheet", "chactersat", "CHARSetter", "chactersetter", "chactersets", "chactersheet", "chereset", "chatsect", "CHarsat", "chearsets", "chresset", "chearset", "chactersset", "charsat", "CHarsetter", "chagnET", "charasET", "chreset", "chARSetter", "chararsET", "charsetter", "chARSet", "cheresect", "chARSat", "chactersect", "chasET", "chararsheet", "chatsset", "chagnet"], "reader": ["read", "message", "iter", "driver", "Reader", "input", "r", "red", "context", "file", "parser", "client", "loader", "entry", "builder", "rar", "stream", "row", "source", "uri", "processor", "layer", "runner", "upper", "io", "document", "handler", "ner", "writer", "reading", "iterator", "buffer", "event", "resource", "inner", "data", "readable"]}}
{"id1": "5676111", "id2": "23517481", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"get": [" fetch", "init", " recover", " finish", "download", "info", "sync", " put", " copy", "Get", "zip", "exec", "run", " delete", " reload", "gc", "dump", "delete", "upload", " download", "Download", "GET", "export", "print", "execute", " construct", "call"], "cnt": ["Cct", "Ccount", "ncht", "acNT", "cnc", "unclen", " cNT", " cht", "nnc", "Cnc", "clen", "cct", "uncnt", "Cnt", "ccount", " cnc", "nccount", "ncnt", " clen", "cNT", "uncNT", "CNT", "ncct", "acnc", "uncnc", "aclen", "nnt", " cct", "Cht", "nct", "acnt", " ccount", "nNT", "cht"], "url": ["ls", "path", "dl", "cert", "http", "URL", "fs", "open", "f", "r", "l", "ur", "gl", "str", "fl", "https", "link", "client", "google", "browser", "web", "nl", "loc", "null", "hl", "host", "mount", "cp", "uri", "addr", "handle", "char", "xml", "www", "el", "socket", "ref", "ret", "mail", "Url", "build", "con", "ssl", "ul", "bel", "base", "rel", "ll", "pl", "sl"], "conn": ["obj", "com", "Conn", "ctx", "net", "cert", "init", "yn", "open", "comm", "nt", "col", "l", "exec", "client", "ens", "gn", "org", "cb", "nl", "c", "loc", "os", "cp", "nec", "cn", "en", "cmd", "ct", "act", "coll", "addr", "resp", "cm", "nc", "ch", "access", "conv", "enc", "dial", "ca", "serv", "con", "jp", "connection", "cont", "co", "syn", "cons", "cur", "rel", "connect", "ns", "pas"], "is": ["nis", "iter", "init", "us", "isl", "vis", "it", "fs", "ib", "ys", "iso", "ms", "dis", "abs", "IS", "bis", "ist", "isc", "lis", "ends", "ri", "ists", "ins", "rs", "iss", "os", "ris", "ic", "in", "isf", "Is", "bs", "sys", "icks", "isi", "imp", "im", "its", "has", "isin", "ios", "ais", "sim", "ps", "i", "si", "mis", "isa", "iris", "sit", "es", "ip"], "filename": ["ren", "path", "title", "sql", "f", "ename", "subject", "file", "fp", "mson", "journal", "Filename", "sbm", "string", "str", "LCS", "nm", "til", "family", "fn", "txt", "source", "lua", "username", "fil", "nu", "river", "ame", "kl", "FILE", "FIL", "stem", "continental", "latest", "name", "prefix", "println", "knife"], "fos": ["flos", " foses", "vres", " foes", "fres", "boes", "boss", "los", "Foes", "foses", "loes", "Foss", "foss", " fows", "Foses", "bos", "Fows", "floes", "floss", "Fres", "Faos", " foss", "laos", "vaos", "voses", "foes", "bows", "faos", "vos", "loss", "fows", "flaos", "Fos", " faos", " fres"], "buffer": ["library", "message", "block", "bytes", "iter", "template", "display", "note", "cache", "binary", "output", "database", "paste", "frame", "bone", "append", "queue", "memory", "window", "Buffer", "page", "source", "scroll", "batch", "char", "document", "attribute", "command", "bar", "result", "sequence", "view", "length", "text", "stack", "temp", "buf", "event", "history", "total", "print", "available", "base", "sample", "buff", "data", "mem", "phrase", "comment", "button", "table", "variable"]}}
{"id1": "18011804", "id2": "13439950", "code1": "    public FileChooserTestFrame() throws HeadlessException, MalformedURLException {\n        super();\n        addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent aEvent) {\n                System.exit(0);\n            }\n        });\n        Dimension dim = getToolkit().getScreenSize();\n        Rectangle abounds = getBounds();\n        setLocation((dim.width - abounds.width) / 2, (dim.height - abounds.height) / 2);\n        setVisible(true);\n        URL url = new URL(\"ftp://cendantstp/\");\n        char[] password = \"spnr\".toCharArray();\n        PasswordAuthentication passwordAuthentication = new PasswordAuthentication(\"spnr\", password);\n        FTPRemoteFileSystemView remoteFileSystemView = new FTPRemoteFileSystemView(url, passwordAuthentication);\n        JFileChooser fileChooser = new InsightRemoteFileChooser(remoteFileSystemView);\n        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);\n        fileChooser.setMultiSelectionEnabled(true);\n        File[] selectedFiles = null;\n        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {\n            selectedFiles = fileChooser.getSelectedFiles();\n            for (int i = 0; i < selectedFiles.length; i++) {\n                if (selectedFiles[i] instanceof FTPFileFile) {\n                    FTPFileFile ftpFile = (FTPFileFile) selectedFiles[i];\n                    logger.fine(ftpFile.getName());\n                    logger.fine(ftpFile.getPath());\n                } else {\n                    logger.fine(selectedFiles[i].toString());\n                    logger.fine(selectedFiles[i].getAbsolutePath());\n                }\n            }\n        }\n        remoteFileSystemView.disconnect();\n        try {\n            if (null != selectedFiles) {\n                FTPClient ftpClient = new FTPClient();\n                InetAddress inetAddress = InetAddress.getByName(url.getHost());\n                ftpClient.connect(inetAddress);\n                if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {\n                    throw new FTPBrowseException(ftpClient.getReplyString());\n                }\n                if (null != passwordAuthentication) {\n                    ftpClient.login(passwordAuthentication.getUserName(), new StringBuffer().append(passwordAuthentication.getPassword()).toString());\n                }\n                for (int i = 0; i < selectedFiles.length; i++) {\n                    FTPFileFile file = (FTPFileFile) selectedFiles[i];\n                    logger.fine(file.getPath());\n                    FileOutputStream fos = new FileOutputStream(new File(\"d:/junk/ftp/test.txt\"));\n                    logger.fine(\"\" + ftpClient.retrieveFile(file.getPath().replaceAll(\"\\\\\\\\\", \"/\"), fos));\n                    fos.close();\n                }\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.exit(0);\n    }\n", "code2": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"HeadlessException": ["HeadlevelEvent", "Headlesslyception", " HeadlesslyError", " HeadlessError", " Headlesslyception", "HeadLessException", " Headlessception", " HeadlessEvent", "HeadLessError", " HeadlesslyException", "HeadlevelException", "HeadlesslyEvent", "HeadLessception", "HeadlesslyError", "Headlessception", "HeadlevelError", "HeadlessError", "HeadLessEvent", "HeadlesslyException", "Headlevelception", "HeadlessEvent", " HeadlesslyEvent"], "MalformedURLException": ["MalformedURLAxression", "MalformedURLEexression", "MalformedURLExpion", "MalformedURLEssion", "MalformedURLAxion", "MalformedURLAexption", "MalformedURLExion", "MalformedURLEssception", "MalformedURLExpception", "MalformedURLExption", "MalformedURLEexion", "MalformedURLEssption", "MalformedURLExression", "MalformedURLEexption", "MalformedURLAxption", "MalformedURLEexception", "MalformedURLAexression", "MalformedURLEssression", "MalformedURLAexception", "MalformedURLAexion", "MalformedURLExpression", "MalformedURLAxception", "MalformedURLExpption"], "aEvent": ["iFolder", " anCommand", " anFolder", " aEvents", " oEvents", " anEvents", " aCommand", " oEvent", " aFolder", "iEvent", "iEvents", " oCommand", " oFolder", " anEvent", "iCommand"], "dim": ["tm", "ram", "dr", "mid", "Rect", "vis", "wid", "gm", "du", "dir", "dem", " Dim", "size", "lim", "details", "py", "def", "iam", "ality", "sam", "height", "div", "cam", "mod", "spec", "coord", "im", "mm", "dimension", "shape", " dimension", "mb", "Dim", "d", "sum", "sd", "mem", "dom", "px", "db", "di", "ims", "dm", "region"], "abounds": ["Abounds", "amborts", "absorders", "amborders", "abbles", "bbles", "aports", "abbqs", "raborders", "absounds", " aborders", "aporders", " ABodies", " ABqs", "abbounds", "abbodies", "ambounds", "absounces", "aborders", "absensions", "abodies", "rabounds", "bounds", "abounding", "rabounces", "aborts", " abensions", "apounds", "apbles", "ambbles", "borders", "abounces", " abounces", "borts", "abensions", "Abodies", " ABounds", "rabensions", "abqs", "abbounding", "Abounding", " ABounding", "Abqs"], "url": ["ls", "path", "dl", "http", "URL", "lr", "r", "address", "f", "api", "abs", "l", "ur", "link", "str", "https", "browser", "parser", "client", "web", "absolute", "nl", "usb", "window", "html", "loc", "term", "domain", "host", "u", "uri", "addr", "github", "www", "socket", "ref", "mail", "Url", "ssl", "connection", "resource", "server", "location", "base", "bel", "ll", "hub", "sl", "localhost"], "password": ["user", "sword", "words", "pass", "Password", "address", "database", "login", "session", "description", "encrypted", "directory", "padding", "wordpress", "key", "word", "random", "pattern", "username", "attribute", "token", "command", "shadow", "power", "definition", "crypt", "reset", "security", "hash", "profile", "language", "phrase", "prefix", "hello", "secret"], "passwordAuthentication": ["passwordauthentiction", " passwordAuthentiction", "passwordAuthication", "passwordauthenticator", "passwordAuthenticator", " passwordAuthentification", " passwordAuthification", "passwordAuthicator", "passwordAuthentification", " passwordAuthiction", "passwordAuthicating", " passwordAuthicator", "passwordauthentication", "passwordAuthentiction", "passwordAuthiction", "passwordCommunication", "passwordAuthification", " passwordAuthenticator", " passwordAuthenticating", "passwordAuthentications", " passwordAuthicating", "passwordCommuniction", "passwordauthentification", "passwordCommunification", "passwordCommunicating", " passwordAuthications", "passwordCommunications", "passwordAuthenticating", "passwordauthentications", " passwordAuthentications", "passwordauthenticating", "passwordAuthications", "passwordCommunicator", " passwordAuthication"], "remoteFileSystemView": ["remoteFileTreeview", "remoteFileListDisplay", "remoteFileSystemContext", "remoteFileListView", "remoteFileListModel", "remoteFileystemView", "remoteFilesystemview", "remoteFileSystemModel", "remoteFileListview", "remoteFileystemResponse", "remoteFileListContext", "remoteFileSystemResponse", "remoteFileTreeView", "remoteFileSystemDisplay", "remoteFileListResponse", "remoteFileystemDisplay", "remoteFilesSystemModel", "remotePlaceSystemView", "remoteFilesystemDisplay", "remoteFilesSystemview", "remoteFileSystemview", "remoteFileTreeModel", "remoteFileTreeContext", "remotePlaceSystemDisplay", "remoteFilesystemView", "remoteFilesSystemContext", "remotePlaceSystemview", "remoteFilesystemModel", "remoteFilesystemResponse", "remotePlaceSystemModel", "remoteFilesSystemView"], "fileChooser": ["fileChoressor", "resourceChoicker", " fileCompose", "fileComposer", "fileChooder", "resourceComposer", "fileSeoder", "filechoorer", "fileCompose", "fileClorer", "filechoicker", "fileChosen", "fileSeicker", "channelChoicker", " fileChoicker", "channelChoerer", "fileChoer", "fileSelecter", "fileChoicker", "fileChoosen", "fileSelecticker", "channelchoerer", "resourceChoer", "channelchoicker", "fileCompicker", "fileSelectressor", "fileChoorer", "channelChoorer", "fileChose", "channelChooser", "fileClicker", "fileChoser", "fileChoerer", "fileSelectoder", "channelchoorer", " fileChose", "filechooser", "resourceCompose", "fileSeose", "fileCompressor", "fileCloser", " fileChoressor", " fileComposer", "fileSeerer", "channelchooser", "fileCompoder", " fileChosen", " fileSelectoser", "fileSeressor", "fileSelectoser", " fileChoose", "fileSeoser", " fileCompoder", " fileChoser", "fileClerer", " fileSelectressor", " fileChoer", "fileComposen", "fileChicker", "resourceComper", " fileSelecter", " fileSelecticker", "resourceCompicker", "resourceChooser", "fileComper", " fileChicker", " fileCompressor", "fileSeorer", " fileChoosen", " fileChooder", "filechoerer", "fileSelectose", "fileChoose", "resourceChoose"], "selectedFiles": ["pickedFeatures", " selectedOps", "namedPhones", " selectedBooks", "selectedOps", "fetchedBytes", "verifiedBooks", " selectedItems", " selectedResources", "pickedItems", "selectedThese", "linkedFile", "namedFile", "linkedfiles", "coloredFiles", "selectedFile", "selectedPhones", "printedPhones", "selectedBytes", "identifiedOps", "linkedResources", "namedOps", "coloredThese", "electedItems", "pickedBooks", "checkedfiles", "reviewedBooks", "selectedResources", "pressedFile", "fetchedThese", " selectediles", "selectedItems", "pressedItems", "fetchedfiles", "pressedPhones", "identifiedItems", "lectedFile", "pressediles", "printedFiles", "checkedBooks", "printedOps", "electedFeatures", "verifiedFiles", "selectedfiles", "pressedOps", "selectedThings", "lectedResources", "reviewedFile", "namedFiles", "fetchedItems", "verifiedItems", "lectedBooks", "pressedThese", "coloredBytes", "selectedBooks", "coloredThings", "printedFile", "checkedItems", "lectedFiles", " selectedFile", "checkedFiles", "lectedfiles", "lectediles", "fetchedThings", "identifiedBooks", "pressedBytes", "selectediles", "verifiedFeatures", "pickedFiles", "pressedFiles", "reviewedFiles", "pressedfiles", "electedBooks", "pressedThings", "fetchedFiles", "fetchedBooks", "identifiedFiles", "linkedFiles", "electedFiles", "selectedFeatures", " selectedfiles", "pressedBooks", "lectedItems"], "i": ["ami", "ij", "ex", "is", "init", "my", "us", "gi", "it", "id", "xi", "mu", "qi", "info", "ci", "li", "err", "\u0438", "I", "m", "t", "s", "ai", "ix", "iq", "hi", "ki", "x", "bi", "key", "ri", "ii", "u", "multi", "mi", "uri", "ic", "in", "batch", "index", "io", "y", "sequence", "exp", "phi", "iu", "sim", "status", "ji", "chain", "me", "si", "history", "print", "v", "ei", "pi", "ti", "cli", "j", "ui", "di", "ini", "ip"], "ftpFile": [" fttpFile", "ftrFILE", "ftpingFile", "fttpFILE", "iftpFile", "ftpifile", " ftpChat", "ftapiFile", "ftPChain", "ftpiChain", " ftpChain", "ftpChat", "ftpingFILE", "iftpComment", "ftPComment", "fttpfile", "ftPAction", "ftpAction", " ftPFile", "ftapiFolder", "ftPFolder", "ftrResource", "ftpChain", " fttpFILE", "ftPFile", "ftpiFile", " ftPChat", "iftapiFolder", "ftapiComment", "iftpAction", " ftpfile", " fttpfile", "fttpFile", "ftpingfile", " ftPfile", "ftpFolder", "fttpResource", " fttpResource", "ftpaFile", "ftapiAction", " ftpFILE", "ftpFILE", "ftpaComment", "ftpaFolder", "fttpChain", "ftpingResource", "iftapiAction", "ftrfile", "ftpComment", "iftpFolder", "iftapiComment", "ftpiChat", " ftPChain", "iftapiFile", "fttpChat", "ftrFile", "ftPfile", "ftpResource", " ftpResource", "ftpfile", "ftPChat", "ftpaAction"], "ftpClient": ["fttpConnection", "fttConnection", "ftcpProxy", "ftcpConnection", "fttProxy", "ftcServer", "fttpclient", "aftcpConnection", "aftpConnection", "aftcpProxy", " fttServer", " fttclient", " ftpConnection", "fttClient", "ftcpClient", "ftcpServer", "fttclient", "aftcpClient", "fttpProxy", "ftpServer", " ftpclient", " ftpServer", " fttClient", "fttServer", "aftpClient", "ftpConnection", " fttConnection", "aftpProxy", "ftcclient", "ftpProxy", "aftpclient", "ftcClient", "ftcpclient", "ftcConnection", "fttpClient", "aftcpclient", "ftpclient"], "inetAddress": ["ptonAdd", "physAddress", "netaddress", "networkHost", "etAddress", "ptonaddress", "physAdd", "ptonAddress", "physHost", "inetClient", "netAdd", "inetAdd", "networkClient", "netClient", "inetHost", "networkAddress", "etaddress", "inetaddress", "physClient", "netAddress", "networkAdd", "netHost", "etAdd"]}}
{"id1": "949327", "id2": "23370621", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"f": ["b", "path", "it", "ft", "fs", "fed", "info", "filename", "r", "file", "fp", "bf", "fd", "tf", "fc", "elf", "t", "m", "dir", "l", "fo", "test", "c", "fx", "fn", "n", "q", "df", "p", "h", "rf", "def", "fac", "fi", "fw", "lf", "y", "F", "w", "exp", "fab", "form", "ret", "g", "e", "fax", "sf", "fm", "d", "fb", "cf", "v", "o", "fa", "base", "name", "j", "fr"], "in": ["In", "ex", "iter", "is", "at", "init", "on", "make", "thin", "input", "rin", "it", "al", "all", "r", "lo", "info", "m", "ma", "IN", "inn", "reader", "t", "add", "l", "inf", "bin", "ai", "again", " IN", "ins", "n", "from", "inc", "en", "ac", "h", "ic", "up", "er", "io", "ind", "oin", "im", "din", "mm", "isin", "by", "get", "log", "re", "nin", "cin", "con", "gin", " din", "inner", "o", "pi", "local"], "cbuf": ["rbfg", "sbuff", "CBuf", "cbuff", "gbuff", "bcfg", "CBbf", "bcuff", "cbuffy", "sbather", "cfbf", "cbbuf", "cdbuf", "sbuf", "cduffy", "CBuffy", "gbuf", "nbuff", "cfuf", "nbfg", "cbbf", "cdoff", "rbuffy", "rbbuf", "abbdf", "cboff", "cduff", "bcoff", "abbbuf", "rbuf", "CBbuf", "gbbf", "rbather", "cbather", "rboff", "cbdf", "gbf", "sbbuf", "cff", "nbuf", "cfuff", "rbuff", "nbbuf", "bcuf", "cduf", "bcdf", "CBf", "bcbuf", "cbf", "bcather", "abbfg", "rbdf", "cbfg", "abbuf", "CBuff"], "read": ["fail", " Read", "find", "ok", "give", "current", "add", "saw", "se", "ai", "feed", "fill", "test", "ext", "think", "orig", "pe", "trust", "est", "set", "text", "report", "get", "log", "connect", "ip", "ready", "dev", "is", "value", "wait", "shift", "bind", "input", "write", "open", "r", "select", "slow", "x", "key", "run", "row", "end", "stream", "READ", "close", "handle", "default", "reading", "chain", "ke", "raw", "play", "scan", "readable", "rate", "range", "iter", "check", "Reader", "parse", "k", "error", "core", "count", "link", "send", "reads", "load", "record", "n", "ed", "burst", "io", "ind", "length", "ret", "re", "buffer", "depth", "print", "pack", "poll", "data", "ead", "index", "it", "Read", "query", "mix", "sync", "reach", "roll", "reader", "pre", "ink", "need", "rank", "q", "ignore", "miss", "height", "old", "view", "allow", "clear", "ly", "seek", "hold", "start", "mem", "skip", "hello", "ank"], "totRead": ["totaConnect", "totRun", "ltotFill", "retotRead", "toteFill", "totaAdd", "letrotRead", "ttotRead", "notalWrite", " totalWrite", "tobyWrite", "toiotRead", "tiotPrint", "tacotCheck", "tiatFill", "toteReader", "tiotBreak", "notalPrint", "tcotRead", "ptotWrite", "tOTWrite", "totaRead", "tcotDisplay", "trotSee", "toticWrite", "toteWrite", "tiatRead", "tiotWrit", "atotaRead", "tottedPrint", "ttotAdd", "tobyCheck", "letotFind", "totalLoad", "totSend", " totFind", "tiotHave", "notPrint", "totVal", "ptOTFind", "tiatBreak", "toteRun", "ttottNeed", "ltotBuild", "retottWrit", "totaCheck", "tacotRead", "tiatVal", " totWrite", "totalNeed", "tootCheck", "ltotLoad", "retotWrit", "tiotVal", "toiotSend", "ttotWrite", "atotaFill", "totNeed", "tacotConnect", "totaFill", "notaLoad", "trotRead", " totBuild", "tottRead", "tootSend", "tiotFill", "notNeed", "retottPrint", "totaPrint", "tOTFind", "tokFind", "totalLength", "ptOTLoad", "ltotaBuild", "tokRead", "notCheck", "tokWrite", "letrotFind", "notaReader", "totaDisplay", "tottAdd", "totFill", "toteNeed", "ttottWrite", "notalLoad", "tottWrit", "tottFind", "totLoad", "ltotaRead", " totLength", "notaWrite", "retotPrint", " toteWrite", "toteFind", "tiatBuild", "tokLoad", "ptOTWrite", "totaBuild", "tottReader", "totLength", "tcotCheck", "totaHave", "totalFind", "retottRead", "tottRun", "toticRead", "toticRun", "totWrit", "totalPrint", "tiotSend", "toticFind", "trotFind", "tiatSend", "toteRead", "tcotVal", "totDisplay", " totalBuild", "totPrint", "totaLoad", "totSee", "tcotSend", "ptotFind", "totalBuild", "totCheck", "notaRead", "notWrite", "taotConnect", "toiotVal", "retotReader", "tootConnect", "tfatRead", "tiotReader", "tootVal", "toteLoad", "totaLength", "totAdd", "tOTNeed", "ttotNeed", "tOTLoad", "totalCheck", " toteFind", "totalWrite", "ptotLoad", "taotDisplay", "totHave", "totedHave", "tacotDisplay", "trotWrite", "tiatLoad", "totWrite", "tobyLoad", "totaNeed", " totalRead", " toteRead", "tottedWrit", "letrotWrite", "tottedReader", "totedFill", "tobyRead", "tfatReader", "ltotRead", "atotFill", "ptOTRead", "notLoad", "letotRead", "tottWrite", "taotCheck", "letotSee", "notRead", "tootDisplay", "tfatWrite", "tootRead", "tcotBreak", "ttottAdd", "tiotRead", "ltotaFill", "ttottRead", "totaWrite", "tobyPrint", "tottedRead", "notalNeed", "totConnect", "tootBreak", "retottReader", "toteBuild", "ltotaLoad", "atotaPrint", "totBreak", "totaReader", "totedPrint", "toiotBreak", "toteLength", " totRun", "letrotSee", "tfatLoad", "totFind", "tobyNeed", "notReader", "totaSee", "atotPrint", "notalRead", "taotRead", "tottNeed", "atotRead", "totaFind", "letotWrite", " totalLength", "ptotRead", "tottPrint", "tOTRead", "totalRead", "atotaHave", "toteAdd", "tcotConnect", "totBuild", "totalSee", "totReader", "notalCheck", "atotHave", "totedRead", " toteRun"], "out": ["b", "obj", "ex", "at", "or", "net", "OUT", "ou", "write", "r", "output", "t", "s", "oss", "c", "Out", "n", "end", "os", "to", "up", "io", "sys", "outs", "w", "ch", "writer", "conv", "OU", "g", "log", "con", "co", "v", "aos", "o", "auto", "res", "we"], "i": ["b", "my", "dr", "xi", "info", "I", "any", "php", "t", "ai", "ix", "iq", "hi", "ri", "p", "mi", "set", "phi", "iu", "e", "integer", "v", "ei", "o", "status", "ip", "ij", "is", "init", "id", "r", "ion", "s", "oi", "ki", "c", "x", "ii", "multi", "ic", "ico", "mm", "sim", "um", "chain", "zi", "ti", "point", "ui", "ini", "qi", "\u0438", "ci", "li", "m", "iy", "this", "io", "ind", "im", "ie", "g", "ice", "print", "cli", "j", "index", "di", "ims", "ia", " I", "ami", "us", "gi", "it", "iii", "ski", "l", "client", "bi", "PI", "q", "uri", "you", "to", "y", "ity", "ji", "me", "si", "pi"]}}
{"id1": "3731077", "id2": "23152865", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    protected JavaFileObject open(String className) throws IOException {\n        JavaFileObject fo = getClassFileObject(className);\n        if (fo != null) return fo;\n        String cn = className;\n        int lastDot;\n        while ((lastDot = cn.lastIndexOf(\".\")) != -1) {\n            cn = cn.substring(0, lastDot) + \"$\" + cn.substring(lastDot + 1);\n            fo = getClassFileObject(cn);\n            if (fo != null) return fo;\n        }\n        if (!className.endsWith(\".class\")) return null;\n        if (fileManager instanceof StandardJavaFileManager) {\n            StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;\n            fo = sfm.getJavaFileObjects(className).iterator().next();\n            if (fo != null && fo.getLastModified() != 0) {\n                return fo;\n            }\n        }\n        if (className.matches(\"^[A-Za-z]+:.*\")) {\n            try {\n                final URI uri = new URI(className);\n                final URL url = uri.toURL();\n                final URLConnection conn = url.openConnection();\n                return new JavaFileObject() {\n\n                    public Kind getKind() {\n                        return JavaFileObject.Kind.CLASS;\n                    }\n\n                    public boolean isNameCompatible(String simpleName, Kind kind) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public NestingKind getNestingKind() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Modifier getAccessLevel() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public URI toUri() {\n                        return uri;\n                    }\n\n                    public String getName() {\n                        return url.toString();\n                    }\n\n                    public InputStream openInputStream() throws IOException {\n                        return conn.getInputStream();\n                    }\n\n                    public OutputStream openOutputStream() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Writer openWriter() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public long getLastModified() {\n                        return conn.getLastModified();\n                    }\n\n                    public boolean delete() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            } catch (URISyntaxException ignore) {\n            } catch (IOException ignore) {\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"copyFile": [" cpDirectory", " cpFiles", "copyFiles", " cpFile", "CopyDirectory", "CopyFile", "downloadfile", "downloadDirectory", "CopyFiles", "downloadFile", " cpfile", "downloadFiles", "copyDirectory", "Copyfile", "copyfile"], "from": ["path", "range", "From", "at", "or", "input", "with", "url", "query", "info", "f", "file", "config", "bean", "star", "add", "s", "se", "str", "link", "before", "what", "string", "original", "as", "html", "org", "origin", "term", "without", "source", "a", "orig", "pro", "por", "part", "old", "st", "view", "ol", "form", "rom", "by", "so", "of", "local", "start", "base", "data", "name", "db", "vol", "fr", "reset", "un"], "to": ["dest", "pt", "th", "full", "or", "template", "tt", "on", "it", "f", "that", "output", "two", "nt", "toc", "file", "html", "t", "bo", "pretty", "oto", "To", "top", "org", "too", "ta", "eto", "size", "etc", "one", "null", "tu", "this", "tom", "TO", "tree", "token", "st", "target", "te", "phi", "none", "po", "parent", "by", "no", "temp", "must", "co", "into", "total", "o", "auto", "base", "name", "table"], "parentDir": ["ParentFile", " parentFile", "netFolder", "rootFolder", "masterDir", "masterFile", "Parentdir", "parentDirectory", " parentDirectory", "parentdir", "rootdir", "netDir", "ParentDir", "masterDirectory", "parentFolder", "ParentDirectory", "masterFolder", "ParentFolder", "parentFile", " parentdir", "rootFile", " parentFolder", "netdir", "rootDir", "netFile"], "in": ["In", "is", "init", "sin", "net", "on", "conf", "input", "rin", "it", "win", "id", "al", "all", "update", "ain", "ma", "IN", "config", "inn", "irc", "inside", "inf", "bin", "ri", "vin", "ir", " IN", "ins", "one", "source", "mc", "inc", "mi", "en", "ini", "up", "xml", "ind", "din", "form", "mm", "isin", "min", "get", "re", "cin", "con", "i", "gin", "raw", "inner", "print", "o", "local", "doc"], "out": ["b", "obj", "css", "ex", "at", "or", "net", "OUT", "ou", "on", "it", "all", "write", "err", "output", "nt", "ion", "file", "ln", "list", "t", "cos", "oss", "client", "again", "gt", "c", "Out", "n", "one", "null", "os", "go", "cn", "gc", "cmd", "io", "ne", "sys", "op", "outs", "conv", "g", "na", "no", "nin", "con", "i", "co", "can", "aos", "o", "v", "outer", "res", "ot", "auto", "vol", "ro", "ns"], "ic": ["ics", "it", "tc", "aic", "ci", "sic", "icon", "mic", "fc", "pc", "bc", "rc", "isc", "ix", "cc", "ik", "c", "nic", "ins", "inc", "ac", "icc", "ric", "wic", "arc", "cus", "ican", "ico", "tic", "cu", "iu", "vc", "iac", "cin", "i", "co", "eric", "IC", "ot", "pic", "irc", "ip", "icy"], "oc": ["ucc", "aco", "ocr", "alloc", "tc", "ci", "aic", "oe", "oco", "toc", "mic", "pc", "cos", "ocon", "OC", "c", "ict", "nic", "roc", "ac", "gc", "oly", "arc", "ric", "og", "unc", "cus", "voc", "oci", "ico", "mot", "nc", "soc", "oca", "cu", "ox", "vc", "ec", "yo", "co", "cot", "o", "anc", "ot", "osc", "pic", "irc", "oct"]}}
{"id1": "23273706", "id2": "4750967", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getApptreeInfo", "getProjectNodeList", "getProjectListList", "getProjectTreeInfo", "getProjecttreeInfo", "getProjectListData", "getAppTreeData", "getApptreedata", "getAppTreeInfo", "getApptreeData", "getProjecttreedata", "getProjectListdata", "getProjectTreeList", "getApptreeList", "getProjectListInfo", "getProjecttreeData", "getAppTreeList", "getProjectNodeInfo", "getProjecttreeList", "getAppTreedata", "getProjectNodedata", "getProjectNodeData", "getProjectTreedata"], "treeData": ["reeList", "treeValid", "TreeData", "tableValid", "reeDat", "tableInfo", "cacheData", "listDat", "listData", "TreeMap", " treeInfo", "treeMap", " treePart", "reeData", "towerData", "statusData", "tableData", "treeDat", "treeList", "cachePart", "TreeInfo", "listPart", "towerDat", " treeDat", " treeValid", "tableMap", " treeMap", "reeMap", "treeInfo", "tableDat", "cacheDat", "reeInfo", "statusMap", "towerValid", "treePart", "tableList", "statusDat", " treeList"], "filename": ["path", "KEY", "generation", "title", "URL", "fs", "url", "sql", "ename", "output", "save", "ames", "file", "fp", "FN", "fps", "FS", "Filename", "string", "original", "directory", "uno", "root", "key", "fn", "source", "txt", "png", "jpg", "uri", "lua", "nil", "username", "fil", "json", "folder", "river", "URI", "ername", "FILE", "temp", "FIL", "fax", "metadata", "location", "latest", "name", "SourceFile", "prefix", "println", "local", "localhost"], "urlString": ["lService", "urlService", "uristring", "urlSite", "UrlString", "lString", "uriSite", "URLString", " urlService", " urlstring", "uriSingle", "lstring", "UrlSingle", "urlstring", "uriString", "URLSingle", "Urlstring", "callStr", "URLstring", "callstring", "callService", "callString", "UrlSite", "urlSingle", " urlStr", "lStr", "urlStr", "URLSite"], "urldata": ["udlenatum", "urrdatum", "udldescription", " urldedata", "udlenata", "urldedata", " urldATA", "urrdescription", " urldatum", "urldeatum", " urldeata", "urledata", "urldatum", "udlenescription", "urldeATA", "udldatum", "uriledata", "urledatum", "urlenATA", "urldeata", "uriledATA", "urleddata", "udlenATA", "urrdATA", "urrdata", " urldeATA", "udldATA", "urlfatum", "urileddata", "urlfescription", "urlfata", " urlddata", "udldata", " urldeatum", "urlenata", "urldATA", "urlenatum", "urlenescription", "urldescription", "urledATA", "urlddata", "uriledatum", "urlfATA"], "factory": ["votype", " fFactory", "fixture", "FFactory", "facter", "facixture", "affFactory", "efacet", "Facter", "efFactory", "Factory", "vFactory", "fault", "frozen", "fFactory", "Fixture", "Frozen", "affotype", "facacter", " fixture", "fotype", "affactory", "efactory", "facault", "facactory", "Facet", "vactory", "vacter", " frozen", "Fotype", "Fault", " fault", "efrozen", "affacter", "facet", " facet", " facter"], "parser": ["Reader", "jack", "parse", "apache", "fascist", "file", "instance", "fp", "reader", "arser", "php", "au", "walker", "loader", "builder", "sup", "x", " df", "actory", "p", "df", "Parser", "processor", "manager", "util", "expression", "er", "xml", " parse", "io", "power", "command", "policy", "writer", "pdf", "conv", " parsing", "sf", "dom", "utils", "bank", " p"], "u": ["U", "us", "ou", "fu", "uf", "it", "uu", "mu", "url", "r", "su", "au", "l", "ur", "ut", "ue", "tu", "p", "uri", "h", "util", "io", "eu", "nu", "lu", "uid", "cu", "iu", "ua", "hu", "ul", "o", "ru", "ui", "uv", "un"], "is": ["us", "isl", "it", "fs", "ib", "dis", "iso", "ms", "ys", "info", "abs", "IS", "bis", "ist", "isc", "ai", "oss", "lis", "ri", "ar", "ir", "ists", "ins", "iss", "ris", "ic", "in", "are", "Is", "il", "ires", "io", "obs", "sys", "rys", "isi", "ost", "im", "its", "has", "iu", "ios", "ais", "sis", "si", "mis", "isa", "iris", "ui", "es", "ims"], "os": ["ls", "oos", "OS", "dos", "osa", "css", "or", "us", "oses", "out", "fs", "des", "ys", "ms", "oes", "ows", "s", "cos", "oss", "pos", "ens", "as", "Os", "bos", "ops", "osi", "bs", "ost", "io", "sys", "uts", "socket", "ios", "es", "ox", "so", "ss", "ros", "oa", "et", "aos", "o", "ot", "mos", "obs"], "iBufSize": ["iBbufLen", "iBufCount", "iBufSIZE", "iRufLength", "iLbufCount", "iBuffsize", "iRufSIZE", "iBphSize", "iBuffLen", "iBbufCount", "iLufsize", "iBuffSize", "iRbufLength", "iLufLen", "iRbufSize", "iLbufsize", "iBbufsize", "iBulLen", "iBufLength", "iRbufSIZE", "iRufCount", "iLufCount", "iLufSize", "iBuffLength", "iBbufSize", "iBulCount", "iBufLen", "iBphSIZE", "iRufSize", "iBbufLength", "iLbufSize", "iBulSize", "iBuffSIZE", "iLbufLen", "iBphCount", "iBbufSIZE", "iRbufCount", "iBulsize", "iBuffCount", "iBufsize", "iBphLength"], "inBuf": [" inRbuf", " inRuc", "inBufferuff", "inBuc", "InBuf", "inBiguc", "InChbuf", "InBuff", "inBufferBuff", "inBbuf", "inBufferuf", "inRuff", "inRuf", "inLbuf", "outBuf", "inBBuff", "outBul", "inLuf", " inBbuf", "inBlul", "inBlbuf", "outRBuff", "inChuf", " inRbuff", "outBbuf", "inChbuf", "InChBuff", "inBufferbuf", "outRuf", "inBiguf", "inRuc", "inRBuff", "inBuff", "outRul", "InChuf", "outBBuff", "InBBuff", "inBufferul", "inChBuff", "InBbuf", "inRbuf", "inBigbuff", "inRbuff", " inBuc", "inBul", "inChuff", "inLbuff", "InChuff", "inBlBuff", "inRul", "outRbuf", "inLuc", "inBigbuf", " inRuf", "inBluf", "inBbuff", " inBbuff"], "iNumRead": ["iNumFind", "INumRun", "iNUMRun", "inumPrint", "iLenRead", "iiNumRead", "aiNumRead", "aiNumberRead", "iNumberWrite", "iNumDef", "aiNumWrite", "INumRead", "iNumberFind", "INumNeed", "iFatFind", "iNUMNeed", "iinumDef", "InumNeed", "inumRun", "inumNeed", "iinumFind", "aiNumberFind", "inumDef", "iRemRead", "iLenRun", "INumPrint", "inumRead", "iLenPrint", "iRemWrite", "iNUMPrint", "InumPrint", "iRemFind", "iNumPrint", "iiNumDef", "iNumWrite", "InumRead", "iFatDef", "iFatRead", "iNUMRead", "iinumRead", "iiNumFind", "aiNumberWrite", "iNumberRead", "aiNumFind", "iNumRun", "iNumNeed", "iLenNeed", "inumFind", "InumRun"], "f": ["b", "fs", "file", "fd", "bf", "fp", "tf", "fc", "t", "l", "fo", "c", "n", "df", "p", "h", "fe", "af", "fac", "fi", "y", "F", "w", "g", "e", "fax", "sf", "fm", "d", "fa", "v", "cf", "o", "fr"], "inputstream": ["Inputdraw", "iterstyle", "uploadStream", "inputstyle", "uploaddraw", "uploadscreen", "inputStream", "inputscreen", "inputform", "iterscreen", "Inputstream", "iterStream", " inputStream", "Inputstyle", "uploadstream", "uploadform", " inputdraw", "Inputscreen", "InputStream", "Inputform", "iterstream", "inputdraw", "uploadstyle", " inputform"], "document": ["message", "collection", "ree", "template", "article", "ocument", "number", "apache", "Document", "information", "application", "context", "database", "media", "file", "m", "present", "browser", "directory", "html", "window", "n", "page", "df", "object", "expression", "tree", "xml", "version", "result", "command", "ml", "raw", "complete", "content", "model", "dom", "response", "language", "node", "doc"], "nodelist": ["nodedestyle", "nodesist", "nodeeman", "snodestyle", "nannodeemark", "nodeest", "nodeman", "neodeist", "nodest", "nodeety", "nodeist", "snodelist", "nondelist", " nodeseto", "nodeseto", "noyeline", "nostemark", "nosteline", " nodeto", "nODeline", "neodeman", "snodeemark", "neodelist", "nnodeety", "nostestyle", "nodedemark", "nannodeelist", "nodeto", " nodeline", "nomist", "nODelist", " nodesist", "nodemark", "nnodeist", "snodeelist", "nnodeemark", "noyelist", "nondist", "snodeline", "snodeeline", "nodeline", "noyist", "nanodemark", "nondeman", "nodedeline", "nnodeelist", "nodeselist", "nostelist", "nodestyle", "neodeeman", "nodeseline", "neodist", "noyeto", " nodeseline", "nomelist", "nodedist", "nodeemark", " nodist", "nannodeist", "nondest", "nODist", "nomeman", "nodety", "nodeestyle", "neodeelist", " nodeselist", "nodist", "nomest", "nodeelist", "neodest", "neodeest", "nodeeline", "snodemark", "nannodeety", "nanodelist", "nODeto", "nanodist", "snodeestyle", "nanodety", "nodedelist", "nodedety"], "num": ["nam", "net", "Number", "perm", "number", "all", "mu", "Num", "m", "su", "list", "current", "mult", "count", "uni", "proc", "umi", "zero", "nm", "n", "nom", "om", "multi", "NUM", "result", "nu", "UM", "set", "length", "cal", "alph", "coord", "um", "no", "dim", "mon", "con", "mn", "total", "sum", "max", "man", "mem", "np", "umer", "un"], "i": ["ami", "ij", "ex", "init", "my", "us", "gi", "it", "qi", "xi", "info", "\u0438", "ci", "li", "wi", "z", "I", "m", "l", "ai", "ix", "iq", "hi", "ri", "x", "bi", "n", "ii", "this", "them", "a", "q", "p", "mi", "multi", "major", "ic", "in", "batch", "index", "io", "y", "im", "phi", "iu", "sim", "ie", "e", "ji", "me", "history", "si", "zi", "ei", "pi", "ti", "cli", "j", "ui", "di", "ini", "ip"]}}
{"id1": "17856064", "id2": "9479502", "code1": "    public static PersistencyParameters parse(String unitName) {\n        URL[] persistenceUnits;\n        try {\n            persistenceUnits = Classpath.search(\"META-INF/\", \"persistence.xml\");\n        } catch (IOException e) {\n            throw new Error(e);\n        }\n        Set classes = new HashSet();\n        for (int i = 0; i < persistenceUnits.length; i++) {\n            URL url = persistenceUnits[i];\n            try {\n                nu.xom.Builder b = new nu.xom.Builder(false);\n                Document d = b.build(url.openStream());\n                Nodes unitNodes = d.getRootElement().query(\"//p:persistence-unit\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                for (int j = 0; j < unitNodes.size(); j++) {\n                    Node unitNode = unitNodes.get(j);\n                    Element unitElt = ((Element) unitNode);\n                    String uName = unitElt.getAttributeValue(\"name\");\n                    if (!uName.equals(unitName)) continue;\n                    {\n                        PersistencyParameters parameters = new PersistencyParameters();\n                        Nodes classNodes = unitElt.query(\"//p:property\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                        for (int k = 0; k < classNodes.size(); k++) {\n                            Node classNode = classNodes.get(k);\n                            if (!(classNode instanceof Element)) continue;\n                            Element classElt = (Element) classNode;\n                            String elementName = classElt.getAttribute(\"name\").getValue();\n                            if (elementName.equals(\"eclipselink.jdbc.url\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setJdbcUrl(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.user\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBUserName(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.password\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBPassword(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.driver\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBDriverClassName(elementValue);\n                            }\n                        }\n                        return parameters;\n                    }\n                }\n            } catch (Exception x) {\n                x.printStackTrace();\n                throw new Error(x);\n            }\n        }\n        return null;\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"parse": [" decode", " params", " from", "parser", "se", " begin", " constructor", " analyse", " class", " parser", "Parser", " par", " compile", " start", " install", " instance", " define", " parsing", " info", " schema", " imports", " scan", " ingest", " resolve", " connect", " split", " execute"], "unitName": ["unitNAME", "elementString", "uNAME", "documentName", " unitString", "unitType", "documentname", "UnitName", "unitString", "elementType", " unitNAME", "unitNames", "documentNames", "uString", "UnitNames", "UnitNAME", "uType", "unitname", " unitType", "elementNAME", "Unitname", " unitNames", "documentNAME", " unitname"], "persistenceUnits": ["persistenceUes", "persistenceUNets", "persistentUnins", "persistenceNins", "persistenceUNunits", "persistentunITS", "persistanceUnins", "persistenceUins", "persistenceunITS", "persistenceUites", "persistenceUnins", "persistentUNits", "persistanceUNes", "persistenceUNites", "persistanceUNits", "persistentUNins", "persistenceUnITS", "persistanceUnes", "persistenceUnes", "persistenceUNins", "persistentUnunits", "persistentUnITS", "persistenceNets", "persistentUnites", "persistenceUNITS", "persistenceunites", "persistanceUnits", "persistentUnets", "persistenceUets", "persistenceUnitites", "persistenceUNits", "persistenceUits", "persistenceUnites", "persistenceNes", "persistentUNets", "persistenceunits", "persistentUNites", "persistentunins", "persistentUNunits", "persistanceUNites", "persistenceUNes", "persistenceUnitITS", "persistentUnits", "persistentunits", "persistenceNits", "persistenceUnitits", "persistenceUnitins", "persistenceUnets", "persistenceUunits", "persistenceUnunits", "persistanceUNins", "persistenceunins", "persistentunites", "persistenceNites", "persistanceUnites"], "classes": [" packages", "files", "modules", "keys", "packages", "class", "parents", "checked", "types", "results", "resources", "plugins", " interfaces", " collections", " class", "codes", "Class", "tests", "units", "names", "errors", " instances", "objects", "ids", " modules", " components", "values", "classified"], "i": ["ij", "ex", "iter", "is", "init", "ims", "my", "out", "gi", "id", "qi", "xi", "it", "info", "ci", "li", "I", "m", "oi", "ai", "ix", "jo", "iq", "gu", "ki", "x", "bi", "hi", "key", "ri", "ii", "n", "p", "u", "multi", "mi", "ic", "in", "index", "io", "y", "ind", "im", "phi", "iu", "sim", "g", "e", "ie", "me", "si", "zi", "pi", "o", "ti", "ui", "di", "ini"], "url": ["obj", "ls", "dl", "http", "URL", "r", "address", "f", "li", "abs", "l", "ur", "link", "str", "browser", "web", "html", "nl", "loc", "n", "p", "u", "uri", "char", "rl", "xml", "result", "sb", "ref", "ret", "get", "Url", "ssl", "resource", "ul", "v", "bel", "location", "base", "mount", "sl"], "b": ["r", "f", "be", "bas", "db", "m", "bf", "bl", "ab", "t", "bc", "l", "rb", "cb", "builder", "c", "bi", "n", "a", "p", "h", "bs", "sb", "bh", "e", "nb", "bd", "build", "B", "bb", "Builder", "fb", "bt", "pb"], "d": ["ad", "dl", "D", "dh", "ds", "r", "f", "da", "db", "m", "fd", "dir", "t", "l", "gd", "c", "de", "dates", "n", "mind", "p", "h", "dd", "dn", "dict", "dat", "e", "od", "sd", "o", "dom", "di", "doc", "dm"], "unitNodes": [" unitNods", "unitGepaces", "moduleNobs", "unitGeoms", "unitSnanguages", " unitNamesoms", "moduleSnobs", " unitNites", "unitSnoms", "unitNamesoms", "unitSnobs", "unitNobs", "unitKeysobs", "moduleNoms", "unitnoms", "unitNanguages", "unitSows", "unitSnodes", "moduleNodes", "unitNpaces", "unitNods", " unitnoms", "moduleNanguages", "unitNamesods", "unitSods", "moduleSnanguages", " unitNamesodes", "unitNsodes", "moduleSnoms", "unitNoms", "unitNodeoms", "unitGeites", " unitNows", "unitNows", "unitNsoms", "unitNodepaces", "unitnpaces", "unitSodes", " unitnpaces", " unitNpaces", "unitnites", "unitSoms", "unitKeysodes", "unitNites", "unitNodeites", " unitnodes", " unitNamesods", "unitGeodes", "unitNodeodes", " unitnites", "unitNamesows", "moduleSnodes", "unitKeysoms", "unitKeysanguages", "unitNamesodes", " unitNamesows", " unitNoms", "unitnodes", "unitNsows", "unitNsods"], "j": ["obj", "ij", "jack", "jar", "out", "jac", "err", "z", "dj", "bj", "jo", "job", "key", "oj", "n", "q", "br", "p", "gov", "nr", "kj", "Ja", "aj", "off", "og", "jj", "ja", "el", "y", "json", "uj", "old", "ind", "im", "jc", "js", "g", "by", "ji", "J", "jp", "jl", "o", "jump", "att", "fr"], "unitNode": [" unitEntry", " unitnode", "nitEntry", "unitEntry", "nitNode", "uiToken", "utilnode", "unitToken", "unitCore", "uinode", "uEntry", "nitEdge", " unitEdge", "uCore", "uNode", " unitToken", "utilNode", "unitnode", "uiNode", " unitCore", "uEdge", "nitCore", "utilToken", "utilEdge", "uiEdge", "unitEdge"], "unitElt": ["unitsElem", "unitsElt", "unitEld", "unitOmt", "unitEls", "unitEEelt", "unitAEld", " unitEElt", " unitEEelt", " unitEEls", "unitsEelt", "unitAEelt", " unitEld", "unitNld", "unitNlem", "unitsEld", " unitEEmt", " unitEls", " unitEelt", "unitElem", "unitNlt", "unitAElem", "unitEmt", "unitOld", " unitEEld", "unitOlem", "unitEElt", "unitNelt", "unitNmt", "unitsOelt", "unitEEld", "unitEEmt", "unitsOld", "unitEEls", "unitOlt", "unitsOlem", "unitOelt", "unitAElt", "unitOls", "unitAEls", " unitEmt", "unitsOlt", "unitEelt"], "uName": ["uuKey", "unName", "cuKey", "uKey", "uData", "cuName", "nuValue", "uL", "cuL", "cuTime", "cuValue", "nuName", " uData", "cuData", "unData", "nuKey", "nuFamily", "uFamily", " uTime", " uL", "uTime", "unTime", "uValue", "uuFamily", "unL", "cuFamily", "uuName", "uuValue"], "parameters": ["temeter", "meteters", "pations", "paramations", "statParameters", "peter", "statations", "stateter", "stateters", "tematers", "parameter", "metaters", "parations", "meteter", "configeters", "paramperties", "pParameters", "paramParameters", "configperties", "configaters", "paramaters", "parParameters", "metperties", "pareters", "peters", "pareter", "configeter", "temeters", "temperties"], "classNodes": [" classNoms", "classCNNobs", "classNNNode", "classNobs", "classNamesodes", "CLASSRenobs", "CLASSNamps", "classRenamps", "classNsobs", "CLASSNotes", " classnomes", "classCNNamps", "classNamps", "CLASSRenotes", "classnomes", " classnodes", "classRenobs", "classNsotes", "conditionNNodes", "classNsodes", "classnoles", "conditionNNode", "classEoms", "classNomes", "classNotes", "classNamesoles", "conditionNodes", "CLASSRenodes", "classEodes", "classNNode", "classNamesNode", "classRenotes", "CLASSNobs", "conditionNNNode", "classNoms", "classNsamps", "classRenodes", "CLASSNodes", "classCNNotes", " classnoms", "classEomes", "classNNoles", "CLASSRenamps", "classNoles", "classnodes", "classnoms", "classNNodes", "conditionNoles", "conditionNNoles", " classNomes", "classnNode", "classCNNodes"], "k": ["ka", "alk", "ok", "uk", "km", "kt", "ake", "kid", "mk", "ku", "kw", "kh", "ik", "unk", "key", "kr", "tk", "q", "ko", "ac", "kj", "kar", "sk", "kk", "work", "acc", "ijk", "isk", "ak", "kl", "g", "ack", "kan", "an", "ks", "kind", "kn", "ck", "ek", "dk", "UK", "ikk", "wk", "ark"], "classNode": ["classifiedN", "elementN", " classEdge", "classToken", "moduleEdge", "moduleN", "titleNode", "processNode", "processElement", "classifiedElement", "clLine", "classN", "classEdge", " classDay", " classOr", "classLine", "titleToken", "titleComponent", "clComponent", "classDay", "classifiedNode", "classifiedDay", "elementLine", "classComponent", "processN", " classN", "clNode", "titleLine", "elementComponent", "processDay", "elementOr", " classElement", "classElement", "moduleOr", "elementEdge", "moduleNode", "elementNode", "clToken", "elementToken", "classOr"], "classElt": ["classExt", "classElementgt", " classYls", " classYlt", "classEgt", " classEld", "classUxt", "classYls", "classUlt", " classOld", "classOgt", "classOld", "classElem", "classEls", "classElegt", "classElementlt", " classYelt", "ClassOxt", "ClassOlt", "classNls", "classElelt", "classeld", " classEmt", "classIEmt", " classEls", "ClassElt", "classEmt", " classOmt", "classElementlem", "classSels", "classNlem", " classOlt", "classIEld", "classYlt", "classEelt", "classOelt", "classSelem", "classelt", "classSeelt", "classElementelt", "classUelt", "classNelt", " classEgt", "classOxt", " classElem", " classOgt", "classEld", "ClassOelt", "classSelt", "ClassEld", " classYlem", "classUld", "classemt", "classEleelt", "classIEgt", "ClassOld", "classOmt", "ClassExt", "ClassElem", "classYelt", " classEelt", "classegt", "classIElt", "classElelem", "classNlt", "classOlt", "ClassEgt", "classYlem", "ClassEelt"], "elementName": ["ElementName", "attributeFamily", "lementTree", " elementWord", "elementTitle", "elementTree", "memberFamily", "attributeName", "lementName", "elementWord", "entryNAME", "lementname", "elementFamily", "entryTitle", "entryName", "smartNAME", "smartLabel", "memberTime", "smartTitle", "attributeTime", "atomicName", "ElementTree", "Elementname", "elementname", "memberName", "entryLabel", " elementname", "elementLabel", "elementNAME", "atomicTitle", "atomicNAME", "memberWord", " elementTree", "elementTime", "lementFamily", " elementFamily", "ElementFamily", "attributeWord", "atomicLabel", " elementTime", "smartName"], "elementValue": ["entryVALUE", " elementValues", "entryValue", "keyvalue", "ElementName", "elementVal", "propertyVal", "lementVALUE", "elementVALUE", "attributevalue", "sequenceVALUE", "entryExample", "elementExample", "propertyValues", "ElementVALUE", "propertyVALUE", "lementTime", "keyVal", "propertyName", "sequenceExample", "attributeValue", "ElementValue", "sequenceTime", "keyValue", "propertyValue", "keyVALUE", "attributeVal", "attributeVALUE", " elementVALUE", "elementvalue", "lementValue", "lementExample", "entryTime", "sequenceValue", "ElementValues", "elementTime", "propertyvalue", "elementValues"]}}
{"id1": "949327", "id2": "364438", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"f": ["b", "path", "it", "ft", "fs", "fed", "info", "filename", "r", "file", "fp", "bf", "fd", "tf", "fc", "elf", "t", "m", "dir", "l", "fo", "test", "c", "fx", "fn", "n", "q", "df", "p", "h", "rf", "def", "fac", "fi", "fw", "lf", "y", "F", "w", "exp", "fab", "form", "ret", "g", "e", "fax", "sf", "fm", "d", "fb", "cf", "v", "o", "fa", "base", "name", "j", "fr"], "in": ["In", "ex", "iter", "is", "at", "init", "on", "make", "thin", "input", "rin", "it", "al", "all", "r", "lo", "info", "m", "ma", "IN", "inn", "reader", "t", "add", "l", "inf", "bin", "ai", "again", " IN", "ins", "n", "from", "inc", "en", "ac", "h", "ic", "up", "er", "io", "ind", "oin", "im", "din", "mm", "isin", "by", "get", "log", "re", "nin", "cin", "con", "gin", " din", "inner", "o", "pi", "local"], "cbuf": ["rbfg", "sbuff", "CBuf", "cbuff", "gbuff", "bcfg", "CBbf", "bcuff", "cbuffy", "sbather", "cfbf", "cbbuf", "cdbuf", "sbuf", "cduffy", "CBuffy", "gbuf", "nbuff", "cfuf", "nbfg", "cbbf", "cdoff", "rbuffy", "rbbuf", "abbdf", "cboff", "cduff", "bcoff", "abbbuf", "rbuf", "CBbuf", "gbbf", "rbather", "cbather", "rboff", "cbdf", "gbf", "sbbuf", "cff", "nbuf", "cfuff", "rbuff", "nbbuf", "bcuf", "cduf", "bcdf", "CBf", "bcbuf", "cbf", "bcather", "abbfg", "rbdf", "cbfg", "abbuf", "CBuff"], "read": ["fail", " Read", "find", "ok", "give", "current", "add", "saw", "se", "ai", "feed", "fill", "test", "ext", "think", "orig", "pe", "trust", "est", "set", "text", "report", "get", "log", "connect", "ip", "ready", "dev", "is", "value", "wait", "shift", "bind", "input", "write", "open", "r", "select", "slow", "x", "key", "run", "row", "end", "stream", "READ", "close", "handle", "default", "reading", "chain", "ke", "raw", "play", "scan", "readable", "rate", "range", "iter", "check", "Reader", "parse", "k", "error", "core", "count", "link", "send", "reads", "load", "record", "n", "ed", "burst", "io", "ind", "length", "ret", "re", "buffer", "depth", "print", "pack", "poll", "data", "ead", "index", "it", "Read", "query", "mix", "sync", "reach", "roll", "reader", "pre", "ink", "need", "rank", "q", "ignore", "miss", "height", "old", "view", "allow", "clear", "ly", "seek", "hold", "start", "mem", "skip", "hello", "ank"], "totRead": ["totaConnect", "totRun", "ltotFill", "retotRead", "toteFill", "totaAdd", "letrotRead", "ttotRead", "notalWrite", " totalWrite", "tobyWrite", "toiotRead", "tiotPrint", "tacotCheck", "tiatFill", "toteReader", "tiotBreak", "notalPrint", "tcotRead", "ptotWrite", "tOTWrite", "totaRead", "tcotDisplay", "trotSee", "toticWrite", "toteWrite", "tiatRead", "tiotWrit", "atotaRead", "tottedPrint", "ttotAdd", "tobyCheck", "letotFind", "totalLoad", "totSend", " totFind", "tiotHave", "notPrint", "totVal", "ptOTFind", "tiatBreak", "toteRun", "ttottNeed", "ltotBuild", "retottWrit", "totaCheck", "tacotRead", "tiatVal", " totWrite", "totalNeed", "tootCheck", "ltotLoad", "retotWrit", "tiotVal", "toiotSend", "ttotWrite", "atotaFill", "totNeed", "tacotConnect", "totaFill", "notaLoad", "trotRead", " totBuild", "tottRead", "tootSend", "tiotFill", "notNeed", "retottPrint", "totaPrint", "tOTFind", "tokFind", "totalLength", "ptOTLoad", "ltotaBuild", "tokRead", "notCheck", "tokWrite", "letrotFind", "notaReader", "totaDisplay", "tottAdd", "totFill", "toteNeed", "ttottWrite", "notalLoad", "tottWrit", "tottFind", "totLoad", "ltotaRead", " totLength", "notaWrite", "retotPrint", " toteWrite", "toteFind", "tiatBuild", "tokLoad", "ptOTWrite", "totaBuild", "tottReader", "totLength", "tcotCheck", "totaHave", "totalFind", "retottRead", "tottRun", "toticRead", "toticRun", "totWrit", "totalPrint", "tiotSend", "toticFind", "trotFind", "tiatSend", "toteRead", "tcotVal", "totDisplay", " totalBuild", "totPrint", "totaLoad", "totSee", "tcotSend", "ptotFind", "totalBuild", "totCheck", "notaRead", "notWrite", "taotConnect", "toiotVal", "retotReader", "tootConnect", "tfatRead", "tiotReader", "tootVal", "toteLoad", "totaLength", "totAdd", "tOTNeed", "ttotNeed", "tOTLoad", "totalCheck", " toteFind", "totalWrite", "ptotLoad", "taotDisplay", "totHave", "totedHave", "tacotDisplay", "trotWrite", "tiatLoad", "totWrite", "tobyLoad", "totaNeed", " totalRead", " toteRead", "tottedWrit", "letrotWrite", "tottedReader", "totedFill", "tobyRead", "tfatReader", "ltotRead", "atotFill", "ptOTRead", "notLoad", "letotRead", "tottWrite", "taotCheck", "letotSee", "notRead", "tootDisplay", "tfatWrite", "tootRead", "tcotBreak", "ttottAdd", "tiotRead", "ltotaFill", "ttottRead", "totaWrite", "tobyPrint", "tottedRead", "notalNeed", "totConnect", "tootBreak", "retottReader", "toteBuild", "ltotaLoad", "atotaPrint", "totBreak", "totaReader", "totedPrint", "toiotBreak", "toteLength", " totRun", "letrotSee", "tfatLoad", "totFind", "tobyNeed", "notReader", "totaSee", "atotPrint", "notalRead", "taotRead", "tottNeed", "atotRead", "totaFind", "letotWrite", " totalLength", "ptotRead", "tottPrint", "tOTRead", "totalRead", "atotaHave", "toteAdd", "tcotConnect", "totBuild", "totalSee", "totReader", "notalCheck", "atotHave", "totedRead", " toteRun"], "out": ["b", "obj", "ex", "at", "or", "net", "OUT", "ou", "write", "r", "output", "t", "s", "oss", "c", "Out", "n", "end", "os", "to", "up", "io", "sys", "outs", "w", "ch", "writer", "conv", "OU", "g", "log", "con", "co", "v", "aos", "o", "auto", "res", "we"], "i": ["b", "my", "dr", "xi", "info", "I", "any", "php", "t", "ai", "ix", "iq", "hi", "ri", "p", "mi", "set", "phi", "iu", "e", "integer", "v", "ei", "o", "status", "ip", "ij", "is", "init", "id", "r", "ion", "s", "oi", "ki", "c", "x", "ii", "multi", "ic", "ico", "mm", "sim", "um", "chain", "zi", "ti", "point", "ui", "ini", "qi", "\u0438", "ci", "li", "m", "iy", "this", "io", "ind", "im", "ie", "g", "ice", "print", "cli", "j", "index", "di", "ims", "ia", " I", "ami", "us", "gi", "it", "iii", "ski", "l", "client", "bi", "PI", "q", "uri", "you", "to", "y", "ity", "ji", "me", "si", "pi"]}}
{"id1": "23161545", "id2": "3252116", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomCID", "getRandomGID", "getRandomGid", "getRandUid", "getRandomUid", "getRandUUID", "getRandomUUID", "getRandomSid", "getRandUID", "getRandomCid", "getRandomCUID", "getRandGID", "getRandomUID", "getRandomCuid", "getRandomGuid", "getRandomUuid", "getRandGUID", "getRandomSID", "getRandUuid", "getRandomSuid", "getRandGuid", "getRandGid", "getRandomSUID"], "secure": ["weak", "dirty", "quiet", "http", "force", "sync", " securely", "encrypted", "sec", "sr", "protect", "stable", "pretty", "https", "safe", "google", "client", "confirmed", "strong", "prime", "trust", "sys", "sensitive", "clear", "ie", "nice", "ssl", "active", "server", "security", " Secure", "status", "Secure", "service", "secret", " insecure"], "md5": ["dig3", " md6", "MD3", "md4", "md512", "MD4", "digle", "sha512", "MD6", "mdle", "sha5", "metadata3", "md3", " md3", "metadata5", "sha2", "MD2", "md6", "MD5", "MDle", "sha6", "MD512", " md512", "md2", " md4", " mdle", "metadata2", "sha3", "dig5", " md45", "md45", "metadata45", " md2", "MD45", "dig4"], "sbValueBeforeMD5": ["sbValueBeforeMP5", "sbValueWithoutMD5", "sbValueBeforeLM2", "sbValueAfterNDson", "sbValueBeforeMD2", "sbValueBeforeMS1", "sbValueBeforeDD5", "sbValueBeforemd5", "sbValueBeforeMAC2", "sbValueBeforemd2", "sbValueBeforeMDFound", "sbValueBeforeMTson", "sbValueBeforeND5", "sbValueBeforeNDson", "sbValueWithoutDD2", "sbValueBeforeDD65", "sbValueBeforeAMDson", "sbValueAfterND4", "sbValueWithoutDD5", "sbValueAfterMD5", "sbValueWithoutDD512", "sbValueWithoutMD512", "sbValueBeforeIM1", "sbValueAfterND5", "sbValueBeforeDD2", "sbValueBeforeAMDFound", "sbValueBeforeMT2", "sbValueBeforeMS2", "sbValueBeforeMD4", "sbValueBeforeOLD5", "sbValueBeforeMPLeft", "sbValueBeforeMD3", "sbValueBeforeDS5", "sbValueBeforeMACFive", "sbValueBeforeND2", "sbValueAfterMD4", "sbValueAfterMDFive", "sbValueBeforeSMson", "sbValueBeforeOLD512", "sbValueAfterMDLeft", "sbValueBeforeIM5", "sbValueBeforeSM2", "sbValueBeforeMAC65", "sbValueBeforeOLD2", "sbValueBeforeMT5", "sbValueBeforeMOD1", "sbValueBeforeMS3", "sbValueBeforeDS512", "sbValueBeforeSM4", "sbValueBeforeIMLeft", "sbValueBeforeDD512", "sbValueBeforeMDson", "sbValueBeforeMT4", "sbValueAfterMD2", "sbValueAfterMD65", "sbValueAfterMDson", "sbValueBeforeDDFive", "sbValueBeforeMS5", "sbValueBeforeMOD2", "sbValueBeforeMDLeft", "sbValueBeforeMP1", "sbValueBeforeMOD5", "sbValueBeforeSM5", "sbValueAfterND2", "sbValueBeforeMD65", "sbValueAfterMD1", "sbValueWithoutMD2", "sbValueBeforeAMD5", "sbValueBeforeND4", "sbValueBeforeDS2", "sbValueBeforeMP2", "sbValueBeforeLM5", "sbValueBeforeMDFive", "sbValueBeforeMD1", "sbValueBeforeMOD3", "sbValueBeforeMAC5", "sbValueBeforeIM2", "sbValueBeforeLM512", "sbValueBeforeMD512", "sbValueAfterMDFound", "sbValueBeforemdFound", "sbValueAfterMD3", "sbValueBeforeAMD2", "sbValueBeforemdson"], "time": ["user", "when", "counter", "value", "TIME", "ts", "id", "runtime", "times", "etime", "current", "t", "frame", "hour", "age", "client", "top", "size", "system", "ty", "estamp", "year", "tim", "est", "work", "clock", "set", "length", "Time", "race", "ime", "duration", "timer", "history", "date", "total", "now", "start", "timeout", "name", "rate", "today"], "rand": ["inv", "nd", "ng", "range", "dr", "mid", "init", "id", "rss", "r", "red", "z", "pick", "grad", "nt", "std", "reg", "and", "roll", "seed", "rc", "rt", "gt", "rad", "pid", "random", "rank", "did", "serial", "sid", "rid", "sam", "cr", "uid", "rev", "round", "dist", "frac", "rot", "rh", "rd", "quant", "res", "sample", "hash", "gz", "Rand", "rate", "gen"], "valueBeforeMD5": ["valueBeforeMOD2", "valueAfterND7", "valueBeforeMD3", "valueAfterMD7", "valueBeforeMC5", "valueBeforeMD25", "valueAfterMD2", "valueBeforeMOD3", "valueBeforeMC7", "valueBeforeMT25", "valueBeforeMD7", "valueAfterND2", "valueBeforeMT5", "valueBeforeND3", "valueBeforeMT3", "valueAfterND5", "valueBeforeMC3", "valueBeforeMT2", "valueAfterMD3", "valueBeforeMOD7", "valueBeforeMD2", "valueBeforeMC2", "valueBeforeMC25", "valueBeforeND7", "valueBeforeND2", "valueAfterND3", "valueBeforeMOD5", "valueBeforeND5"], "array": ["external", "range", "collection", "storage", "number", "audio", "Array", "binary", "address", "ary", "list", "instance", "map", "ash", "app", "vector", "record", "our", "feature", "image", "row", "random", "av", "a", "pair", "object", "share", "arr", "batch", "angle", "expression", "area", "archive", "sh", "attribute", "length", "arrow", "RAY", "buffer", "ray", "raw", "sample", "hash", "data", "rays", "response", "angular", " Array", "atomic", "var"], "sb": ["rob", "sth", "abb", "ib", "bp", "gb", "bf", "sv", "sr", "bis", "rb", "SB", "bps", "sq", "cb", "bg", "erb", "lb", "gc", "bs", "sh", "obs", "zb", "soc", "hs", "ub", "bh", "eb", "nb", "ctrl", "bb", "bsp", "ssl", "sa", "sf", "wb", "xb", "bt", "sw", "kb", "si", "lp", "ob", "db", "sg", "pb"], "j": ["obj", "ij", "jack", "us", "it", "k", "z", "_", "m", "dj", "t", "str", "bj", "jo", "job", "ix", "key", "oj", "ju", "q", "br", "kj", "ct", "aj", "off", "att", "jit", "__", "jj", "ja", "bot", "ind", "json", "uj", "msg", "yy", "jc", "js", "g", "je", "ji", "J", "i", "jp", "jl", "v", "jump", "index"], "b": ["beta", "ba", "k", "bp", "gb", "be", "ib", "bf", "ab", "bis", "bc", "rb", "cb", "bi", "bg", "a", "br", "u", "bu", "bs", "bar", "bound", "y", "eb", "nb", "bd", "B", "bb", "mb", "fb", "xb", "d", "v", "bt", "db"], "valueAfterMD5": ["valueAftermd7", "valueAfterID5", "valueBeforeMD3", "valueAftermd5", "valueAfterMD2", "valueAftermd3", "valueBeforeMD7", "valueAfterID3", "valueAfterMD3", "valueAfterID7", "valueBeforeMD2", "valueAftermd2", "valueAfterID2", "valueAfterMD7"]}}
{"id1": "5237257", "id2": "14502142", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"download": ["init", " recover", " downloading", "write", "open", "save", " browse", " drop", " restore", "file", "paste", "load", " zip", "dump", "copy", "delete", " Download", "upload", " dump", "get", " upload", " downloaded", "Download", "export", " downloads", " seek", " checkpoint", " retrieve"], "fileName": [" fileType", " fileFilename", "resourcePath", "filename", "projectName", "fileType", "resourceTime", "FILEName", "imagePath", "fileTime", "projectPath", "FileName", "projectname", "fileFilename", "FilePath", "FileType", " filename", "FileTime", "resourceType", "FILEPath", " fileTime", "projectFilename", "resourceName", "FILEFilename", "FILEname", "imageName"], "filePath": ["resourceUrl", "languagePath", " filepath", "FileP", "resourcePath", "FILEStart", "filepath", "ileStart", "ileName", "FILEName", "FILEP", "FILEpath", "FILEUrl", "ileP", "fileStart", "FileName", "languageId", "languageName", "FilePath", "fileUrl", "FileStart", "resourcepath", "ilePath", " fileId", "FILEPath", "fileId", "resourceName", "fileP", " fileUrl", "FileId"], "in": ["In", "read", "iter", "is", "init", "or", "sin", "net", "on", "input", "rin", "it", "win", "al", "r", "f", "id", "ain", "m", "IN", "ln", "inn", "login", "l", "inside", "inf", "bin", "ai", "ar", "ins", "one", "n", "from", "inc", "en", "mi", "up", "io", "el", "ind", "st", "im", "din", "isin", "ie", "re", "nin", "cin", "con", "i", "gin", "co", "inner", "o", "pi", "local", "ini"], "out": ["obj", "user", "ex", "at", "or", "net", "OUT", "note", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "cos", "oss", "client", "gt", "boot", "Out", "n", "end", "null", "os", "ent", "p", "not", "cn", "to", "up", "io", "ne", "op", "sys", "outs", "w", "ch", "conv", "OU", "po", "na", "no", "nin", "conn", "con", "i", "co", "inner", "can", "aos", "o", "v", "outer", "name", "ns", "we"]}}
{"id1": "20267500", "id2": "1986417", "code1": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "code2": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getWavFromURL": ["getWavFromString", "getWavFromURI", "getWavfromUrl", "getWapFromURL", "getWavByString", "getWavByURI", "getWapfromString", "getWapFromURI", "getWapfromURL", "getWavByURL", "getWapFromString", "getWavfromURL", "getWapFromUrl", "getWavByUrl", "getWavFromUrl", "getWapfromURI", "getWavfromURI", "getWavfromString", "getWapfromUrl"], "urlstr": [" urlr", "dlstr", "urlname", "URLSTR", " urlstring", "dlSTR", "dlname", "UrlSTR", "Urlname", " urlSTR", "urlstring", " urlname", "Urlstring", "dlstring", "urlr", "URLstring", "URLstr", "strstr", "strr", "URLr", "Urlstr", "strSTR", "strstring", "urlSTR"], "url": ["ls", "path", "dl", "com", "http", "URL", "lr", "r", "open", "f", "address", "file", "l", "ur", "gl", "str", "https", "load", "job", "cl", "web", "nl", "loc", "q", "host", "hl", "u", "cp", "uri", "h", "char", "il", "xml", "cr", "cal", "pl", "build", "Url", "mail", "ml", "con", "ssl", "ul", "res", "base", "rel", "ll", "mount", "sl"], "ais": ["nas", "oos", "asar", "ami", "osa", "hz", "is", " ain", "aci", "opus", "us", "acs", "pa", "wi", "ias", "auc", "AI", "aida", "bis", "au", "asi", "ai", "lis", "ras", "asio", "as", "ia", "a", "ris", "ac", "osi", "asm", "aa", "asis", "aim", "iam", "sam", "pai", "aus", "audi", "ca", "ua", " arra", " ado", "sa", "aos", "ei", "aer", "ians", "isa", "ois", "ahi", "ws", "aba", "ava", "asia"], "c": ["b", "cs", "ce", "com", "cd", "tc", "f", "r", "ci", "col", "fc", "bc", "cos", "l", "rc", "cc", "cl", "cb", "dc", "n", "mc", "cp", "ac", "ct", "coll", "C", "cm", "nc", "cr", "cu", "ch", "conv", "enc", "ca", "ec", "cin", "con", "ctrl", "cont", "co", "v", "cur", "anc", "lc"], "stream": ["Stream", "read", "path", "is", "store", "out", "input", "open", "f", "context", "output", "REAM", "present", "m", "file", "reader", "t", "row", "source", "in", "pipe", "io", "iam", "sam", "result", "st", "console", "form", "enc", "port", "stack", "chain", "buffer", "cont", "content", "resource", "v", "sample", "data", "ream", "channel", "sl"]}}
{"id1": "14865947", "id2": "17158020", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"execute": [" executes", " execution", " Exec", " dispatch", " eval", "exec", "run", " evaluate", " operate", "Command", " executed", " parse", "Exec", "command", "Action", " Execution", " executable", " query", "process", " resume", " Run", " executing", " proceed", "invoke", " manage", " command", " interpret", " executions"], "event": ["ex", "ce", " invocation", "context", "xe", " EVENT", "t", "frame", "se", "ae", "de", "exc", "pe", "ed", "command", " environment", "w", "E", "te", " frame", "Ev", " Event", " events", "Event", "EE", "ev", "ee", " command"], "shell": ["b", "message", "range", "template", "hell", "grid", "query", "sql", "search", "widget", "session", "ssh", "pty", "Shell", "help", "l", "lock", "cell", "root", "system", "html", "nl", "window", "detail", "scope", "hl", "tools", "screen", "h", "scroll", "quit", "tool", "layout", "handle", "tree", "sh", "sys", "ja", "bot", "console", "body", "sol", "round", "tab", "microsoft", "sb", "js", "windows", "style", "stack", "fr", "line", "buffer", "history", "base", "cli", "theme", "kernel", "pool"], "view": ["block", "template", "review", "display", "ou", "vp", "query", "widget", "list", "browser", "VIEW", "web", "html", "window", "image", "row", "screen", "vm", "cv", "ve", "tv", "layout", "tree", "version", "eye", "document", "w", "show", "see", "report", "buffer", "v", "views", "View", "ui", "iew"], "rootFolder": [" rootDirectory", "coverDisk", "coverFolder", "parentDir", "bottomLibrary", "RootEntry", " rootEntry", " rootLibrary", "RootFolder", "RootDirectory", "parentDirectory", "rootCategory", "bottomFolder", "RootDir", "parentEntry", "rootDirectory", "RootCategory", "parentFolder", " rootArea", "bottomDisk", "coverLibrary", "parentArea", "RootArea", "rootArea", "coverDirectory", " rootCategory", "rootDir", "rootEntry", "rootDisk", "rootLibrary", " rootDisk", "parentCategory", " rootDir", "bottomDirectory"], "dialog": ["logig", " Dializ", "dialig", "logDialog", "Dialj", "dialj", "dloc", "dialOG", "choDialog", "Dialog", "DialDialog", "closer", "callDialog", "selectig", "Dialoc", "dialogs", "choog", "dliz", "dlj", "dializ", "clog", "selectoser", " Dialog", " Dialoc", "selectDialog", " Dialj", "Dializ", "Dialogs", "clDialog", "dialDialog", "selectog", "logog", "dlog", "dialoc", "DialOG", "choogs", "logoser", "choOG", "callOG", "callogs", "clig", "callog", "dialoser"], "password": ["message", "user", "path", "sword", "words", "device", "pass", "Password", "query", "wd", "address", "database", "description", "login", "paste", "request", "encrypted", "secret", "string", "directory", "padding", "entry", "key", "word", "source", "picture", "p", "table", "expression", "pattern", "username", "attribute", "command", "shadow", "PASS", "clear", "definition", "buffer", "raw", "hash", "language", "data", "response", "phrase", "comment", "hello", "prefix", "reset"], "md5": ["mt5", " md6", "mm2", "md4", "md64", "md512", "MD3", "MD4", " md2", "ma64", "m5", "MD6", "mm5", "ma7", "md3", "mt4", "mm6", "MD2", "m3", "mb512", "md6", "MD7", "MD5", "mm7", "MD64", "m4", "MD512", " md512", "mt2", "md2", " md4", "mb4", "ma5", "md7", "ma2", " md7", " md64", "m2", "mb2", "mb5", "mt3"], "md": ["nd", "pt", "cd", "dr", "dh", "mt", "red", "nt", "MD", "m", "pm", "rm", "mk", "mac", "de", "hd", " dd", "mc", "df", "pd", "cmd", "dd", "ct", "det", "msg", "ind", "mod", "pdf", "mm", "ld", "bd", "od", "dig", "mn", "mb", "metadata", "d", " Md", "sd", "hash", "mg", "ms", "sm", "dm", "magic"]}}
{"id1": "10383721", "id2": "20190303", "code1": "    @SuppressWarnings(\"unchecked\")\n    private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException {\n        String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag;\n        if (cache.containsKey(key)) {\n            return (ReaderFeed) cache.get(key);\n        }\n        List<Post> postList = new ArrayList<Post>();\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Cookie\", \"SID=\" + sid);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n        SAXBuilder builder = new SAXBuilder(false);\n        Document doc = builder.build(reader);\n        Element root = doc.getRootElement();\n        Namespace grNamespace = root.getNamespace(\"gr\");\n        Namespace namespace = root.getNamespace();\n        String newflag = root.getChildText(\"continuation\", grNamespace);\n        String title = root.getChildText(\"title\", namespace);\n        String subTitle = root.getChildText(\"subtitle\", namespace);\n        List<Element> entryList = root.getChildren(\"entry\", namespace);\n        DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n        for (Element e : entryList) {\n            Post post = new Post();\n            post.setTitle(e.getChildText(\"title\", namespace));\n            try {\n                post.setDate(sdf.parse(e.getChildText(\"published\", namespace)));\n            } catch (ParseException e1) {\n            }\n            post.setUrl(e.getChild(\"link\", namespace).getAttributeValue(\"href\"));\n            post.setSauthor(e.getChild(\"author\", namespace).getChildText(\"name\", namespace));\n            String content = e.getChildText(\"content\", namespace);\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"description\", namespace);\n            }\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"summary\", namespace);\n            }\n            post.setContent(content);\n            postList.add(post);\n        }\n        ReaderFeed readerFeed = new ReaderFeed();\n        readerFeed.setTitle(title);\n        readerFeed.setSubTitle(subTitle);\n        readerFeed.setFlag(newflag);\n        readerFeed.setPostList(postList);\n        cache.put(key, readerFeed);\n        return readerFeed;\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"processEntrys": [" processEntries", " processEntrs", "processEntrs", "processentry", "processENTrys", "processEntry", "processENTrs", "processentrys", "processentrs", "processentries", "processENTries", "processENTry", "processEntries", " processEntry"], "urlStr": ["uriDec", "pathStr", " urlRest", "urlSt", "UrlRes", "urlString", "uriBr", "uriRes", "UrlString", "uriStr", "UrlSt", "uriRest", "URLSTR", "UrlDec", "URLRest", " urlBr", "URLBr", " urlString", "UrlSTR", "UrlStr", "pathRes", " urlSTR", "pathSTR", "uriSTR", "urlRes", "URLRes", "urlSTR", "pathString", "urlRest", "urlBr", "URLSt", "urlDec", "uriSt", "URLDec", " urlRes", "URLStr"], "currentFlag": ["curStatus", "uniqueFLAG", " currentflag", "newFLAG", "reportedFLAG", "currentflag", "currentFlags", "uniqueFlag", "newFlags", "newFlag", "curFlags", "currentStatus", " currentStatus", "currentFLAG", "curflag", "reportedflag", " currentFlags", "curFlag", "reportedFlags", "uniqueFlags", "reportedStatus", "reportedFlag"], "key": ["Key", "message", "item", "KEY", "path", "template", "value", "tip", "my", "it", "keys", "search", "member", "k", "info", "filename", "pkg", "file", "task", "description", "seed", "entry", "reason", "label", "q", "sk", "pattern", "char", "default", "token", "y", "ey", "set", "step", "by", "chain", "ke", "sum", "ek", "base", "hash", "rand", "name", "column", "tag", "prefix", "index", "service"], "postList": ["feedlist", "entrylist", " postMap", "entryGroup", "postlist", " postGroup", " postlist", "feedMap", "entryMap", "feedList", "feedGroup", "postMap", "postGroup"], "url": ["b", "ls", "dl", "http", "URL", "r", "f", "open", "address", "abs", "t", "l", "ur", "link", "str", "https", "browser", "au", "loader", "web", "org", "nl", "loc", "u", "uri", "rl", "il", "document", "sb", "uc", "impl", "log", "Url", "get", "conn", "ssl", "location", "atl", "name", "ll", "sl"], "connection": ["operation", "creator", "Connection", "http", "number", "application", "open", "information", "context", "wrapper", "database", "ion", "description", "session", "reference", "opening", "network", "client", "directory", "entry", "c", "web", "character", "close", "created", "uri", "established", "to", "io", "document", " Connection", "command", "socket", "position", "statement", "writer", "conn", "con", "condition", "resource", "server", "communication", "creation", "location", "pointer", "reset", "language", "response", "connect", "channel", "relation"], "reader": ["read", "message", "iter", "driver", "Reader", "input", "r", "context", "file", "parser", "feed", "client", "loader", "entry", "rar", "stream", "row", "in", "er", "runner", "io", "document", "handler", "ner", "body", "writer", "reading", "iterator", "buffer", "resource", "inner", "data", "response", "ro"], "builder": ["b", "block", "creator", "bridge", "full", "builders", " builders", "aker", "parser", "bo", "loader", "web", "row", "hub", "good", "building", "layer", "control", "settings", "manager", "handler", "bar", "BU", "ner", "adder", "writer", "uild", "build", "Builder", "buffer", "sf", "base", "operator", "bus", "outer", "built"], "doc": ["ree", "dr", "DOC", "git", "Doc", "Document", "file", "m", "dir", "t", "md", "tx", "html", "dc", "graph", "def", "h", "pub", "og", "unit", "tree", "xml", "document", "result", "div", "json", "body", "dec", "writer", "g", "city", "study", "ml", "d", "man", "res", "dom", "data", "db"], "root": ["rt", "zero", "loc", "host", "box", "area", "oot", "xml", "element", "body", "node", "cover", "obj", "collection", "init", "or", " Root", "all", "r", "central", "self", "feature", "results", "row", "right", "primary", "scope", "os", "default", "result", "has", "local", "table", "ro", "ree", "empty", "m", "instance", "original", "record", "entry", "container", "this", "tree", "owner", "remote", "role", "rocket", "res", "mr", "base", "data", "wrap", "Root", "first", "head", "rar", "rap", "null", "rank", "roots", "unit", "er", "document", "div", "parent", "roid", "mounted", "server", "start"], "grNamespace": ["GrNameSpace", "GRnamespace", "grNsSpace", "GRnamesSpace", "GrNameset", "grNamespaces", "GRNameset", "GRNamespaces", "grnamespace", "GrNameet", "grNamepaces", "grnamesSpace", "grNameSpace", "grnamespaces", "grnameset", "GrNamesSpace", "GRnamespaces", "grNset", "grNamesSpace", "GrNamespace", "grNspace", "grNamepace", "GRNamesSpace", "grNameset", "GrNamepace", "grNameet", "GRnameset", "GRNamespace"], "namespace": ["namescore", "mspaced", "Namesspace", " namesACE", "Document", "wordsSpace", "space", "wordspace", "Entry", "namesspace", "namepaces", "memberspace", "Namesistence", "nameset", "Raw", "spaced", "masacing", "nameistence", "nsspace", "Secure", "Namespaces", "ameship", "sacing", " namesspace", "nameship", "context", "Feed", "s", " nameship", " namespaced", "nameace", "amesSpace", " namespaces", "amesistence", "termsistence", " namesistence", " nameset", "termspaced", "maspaced", "mscore", "mascore", "namesACE", "Nameset", "nspace", "namespaced", "membersspace", "nsSpace", " namesace", "amespace", "score", "Namespace", "membersace", "wordsistence", "namespaces", "namesSpace", "wordsACE", "E", "St", "New", "nspaced", "amesACE", "nameet", "termsSpace", "Ent", "termspace", "namesace", "nameSpace", "_", " namesSpace", "mspace", "termsspace", "namepace", "membership", "namesistence", "amesspace", "msacing", "membersSpace", "namesacing", "maspace", "NamesSpace"], "newflag": ["continueFlag", "continueflag", "nextFlag", "nextflags", "Newflag", "nextstatus", "newFlag", "continueflags", "continuestatus", "NewFlag", "Newstatus", "Newflags", "newflags", "nextflag", "newstatus"], "title": ["message", "header", "template", "format", "value", "tip", "type", "subject", "filename", "file", "description", "itle", "t", "summary", "Title", "published", "term", "label", "lead", "text", "desc", "displayText", "name", "prefix", "topic", "status", "phrase"], "subTitle": ["subText", "SubText", "shorttitle", "subName", "SubTitle", " subText", "SubName", "subtitle", "shortTitle", " subName", "Subtitle", " subtitle", "shortText", "shortName"], "entryList": ["ryList", "entrySet", "postlist", " entryArray", "entrylist", "EntrySet", " entryL", "entArray", "Entrylist", " entrylist", "postSet", "entL", "ryArray", "ryL", "rySet", "entList", "entryL", "entlist", "entryArray", "rylist", "EntryList"], "sdf": [" sde", "sde", "ssfx", "sDF", "psde", "ssdf", "ssfd", "Sde", " sfx", "SDF", "dsdf", "dsfd", "dsfx", "Sdef", "sfx", " sfd", "sfd", " sdef", "Sdf", "psdf", "psdef", "psDF", "ssdd", "dsdd", "sdef", " sdd", "sdd", " sDF"], "e": ["ce", "it", "r", "f", "be", "oe", "t", "l", "se", "eg", "entry", "c", "x", "de", "ue", "end", "le", "a", "p", "u", "ent", "en", "fe", "pe", "ve", "ed", "ea", "er", "eeee", "el", "element", "y", "ge", "exp", "E", "te", "ie", "es", "ef", "ec", "entity", "eb", "i", "event", "ep", "eur", "et", "v", "ei", "o", "ele", "Element", "ee"], "post": ["commit", "pt", "read", "pod", "person", "check", "put", "pp", "wp", "draw", "store", "pass", "write", "info", "save", "pre", "t", "add", "link", "after", "feed", "record", "Post", "entry", "test", "follow", "word", "row", "end", "page", "next", "p", "object", "pub", "def", "ost", "op", "mod", "POST", "set", "exp", "posts", "form", "po", "get", "log", "od", "ps", "process", "print", "man", "create", "skip", "rel", "admin", "prefix", "comment", "status", "pg", "local"], "content": ["message", "path", "header", "template", "value", "format", "media", "description", "ontent", "Content", "link", "source", "label", "object", "layout", "document", "text", "body", "entity", "code", "data", "name", "comment", "section", "status", "child"]}}
{"id1": "16378239", "id2": "20310134", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"byReference": ["forreference", "byRef", "forResource", " byResource", "byreference", "ByRef", "Byreference", "forReference", " byRef", "byResource", " byreference", "ByReference", "forRef", "ByResource"], "inputStream": [" inputSteam", "inStream", "inputReader", "inFile", " inputReader", "instream", "inSteam", "Inputstream", "readableReader", "readableStream", "InputStream", "readableSteam", "readablestream", " inputstream", "InputReader", "inputSteam", "inputFile", " inputFile", "inputstream", "InputFile", "InputSteam"], "tempFile": [" tempDir", " temporaryFile", "tempfile", " temporaryFiles", "empPath", " tempChain", "empPlace", "tempChain", "poraryfile", "empfile", "tmpfile", "TempFile", "poraryDir", " tempFiles", "tempPlace", "empDirectory", "TempDirectory", "TempDir", "poraryFile", " temporaryfile", " temporaryChain", "tmpDirectory", "TempPath", "Tempfile", "TempUrl", "TempChain", "tempUrl", "tmpPath", "poraryUrl", "tempDir", "tmpPlace", "tempPath", "poraryPlace", "poraryName", " tempfile", "tmpName", "empFile", "empName", " tempUrl", "TempFiles", "tmpFile", "tempName", "tempFiles", "tempDirectory"], "out": ["user", "ex", "net", "OUT", "us", "ou", "all", "dis", "output", "file", "t", "cos", "l", "s", "oss", "again", "as", "Out", "n", "one", "null", "ins", "source", "os", "ent", "in", "to", "lay", "up", "ao", "io", "sys", "outs", "msg", "writer", "conv", "OU", "serv", "con", "gr", "co", "sum", "v", "aos", "o", "auto"]}}
{"id1": "2511579", "id2": "16719805", "code1": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"extractZipFile": ["extractJarFile", "extactZipDir", "extractPackageFilename", "extactLogFile", "extractLogDir", "extactZipfile", "extractPackagefile", "extractLogFilename", "extractPackageDir", "extractZipDir", "extractJarDir", "extractLogFile", "extractPackageFile", "extactZipFile", "extractJarFilename", "extractLogfile", "extractZipfile", "extactZipFilename", "extactLogfile", "extactLogDir", "extractJarfile", "extractZipFilename", "extactLogFilename"], "filename": ["message", "path", "src", "title", "sql", "url", "subject", "ename", "output", "f", "description", "file", "fp", "ln", "Filename", "original", "directory", "root", "origin", "nm", "fn", "source", "txt", "uri", "username", "fil", "folder", "kl", "FILE", "location", "base", "latest", "name", "SourceFile", "prefix"], "progressText": ["progressInfo", "priorityText", " progressCheck", " progressMsg", " progressiveRect", "gradeFont", " progressInfo", "progressPrint", "gradeMath", "ProgressCheck", "progressInd", "progressRect", " progressPrint", "priorityMsg", "progresstext", "priorityLog", " progressiveText", " progressLabel", " ProgressLog", "gradeCheck", "priorityInd", "memoryText", "progressFont", "progressMath", " ProgressInfo", " progresstext", "gradeLog", " progressRect", "debugText", "progressLabel", "formPrint", "formText", " ProgressRect", "debugtext", "ProgressText", "gradeCode", "formTEXT", "memoryMsg", " progressMath", "progressMsg", "priorityFont", " progressTEXT", "ProgressCode", "ProgressLog", "gradeText", "debugTEXT", "debugPrint", " progressInd", " progressiveInfo", "priorityLabel", " progressiveLog", "memoryLabel", " progressLog", "priorityMath", "progressTEXT", "progressCheck", " progressFont", "formtext", "progressCode", "progressLog", " ProgressText", " progressCode", "memoryInd"], "destinationname": ["destinationsecret", "destinedfrom", "restinationname", "destinationno", "destensionnames", "destinedadmin", "destinationadmin", "destinationroot", "destositorysecret", "restorationno", "destensionname", "destositorynames", " destinationsecret", "Destinationnm", "restorationadmin", "destensionsecret", "destositoryname", " destificationsecret", "DestinationName", "destositoryName", " destinationroot", "destositoryfrom", "destinedName", "restorationnam", "destinationnm", "Destinationname", "restinationno", "destmentationno", "destinedname", "destinednm", "destinedno", "destinationName", "destositorynm", "destificationname", " destificationroot", "destinationnames", "destorationadmin", "restinationnam", "destinednam", "destensionroot", " destinationnames", "destorationname", "destorationnam", " destificationname", "destmentationadmin", "destificationsecret", "destositoryroot", "destificationnames", "destificationroot", "restorationname", "restinationadmin", "destmentationnam", "destinationnam", "destorationno", "destinationfrom", "Destinationfrom", "destmentationname", " destificationnames"], "buf": ["b", "bytes", "block", "hz", "prop", "uf", "mu", "cap", "comb", "pkg", "paste", "fp", "norm", "rb", "boxes", "str", "queue", "cb", "Buffer", "br", "img", "cv", "arr", "cmd", "batch", "bag", "tr", "msg", "seq", "text", "alph", "conv", "Buff", "bn", "buffer", "raw", "vec", "fb", "wb", "bt", "cont", "pack", "mem", "buff", "data", "cur", "db", "fr"], "zipinputstream": [" zipinputview", "ZipInputservice", "ziparchivemount", "zipsearchstream", "zipinitialstream", "zipinputscope", "ZipInputsteam", "zipopencontext", "Zipinputsteam", "zipInputservice", "zipinputline", "zipupstream", "zipinitstream", "zipopenstream", "ziparchiveStream", "zipupiterator", "zipupcontext", "zipactiveform", "zipactivestream", "zipInputsteam", "zipjoinstream", "zipInputStream", "zipInputview", " zipinputStream", "zipjoinStream", " zipinputcontext", " zipinputiterator", "ziparchiveview", "zinputline", " zipfeedStream", "zipopenStream", "zipactiveline", "zipactiveservice", "zipjoiniterator", "zipinitialservice", "zipinputsteam", "zipinitview", "zipoutputstream", "zipinputiterator", "Zipinputservice", " zipfeediterator", "zipinputview", "ZipInputscope", "zipfeedstream", " zipinputmount", "zoutputStream", "zipinputform", " zipopenstream", " zipopenStream", "zinputstream", "Zipinputstream", "ZipInputStream", "zipinitialStream", "zipoutputsteam", "zipfeediterator", "zipinitmount", "zipoutputiterator", "ZipinputStream", " zipinitStream", "zipoutputform", "zinputStream", "zipactivescope", "zipfeedStream", "zipInputform", "zipInputline", "zipInputscope", "zinputform", "ziparchivestream", "zipinitialscope", "zipInputstream", "zipsearchStream", "zipinputStream", "zipsearchiterator", "zipactiveStream", " zipinitview", "zoutputform", "Zipinputiterator", "zipsearchsteam", " zipinitstream", "zipupStream", "zipinitStream", " zipinitmount", "zipInputmount", "zipopeniterator", "ZipInputiterator", "zipoutputStream", " zipopencontext", " zipopeniterator", "zipinputservice", "zipoutputline", "zipInputiterator", "Zipinputscope", "zipinputcontext", "ZipInputstream", " zipfeedstream", "zipInputcontext", "zoutputstream", "zoutputline", "zipinputmount"], "zipentry": ["zcell", "zenter", "zconnection", "packageconnection", "zipenter", "zinfo", "Zipfield", "zipcard", "zipfile", "zipinfo", "zipconnection", "Zipfile", "Zipjob", "zoneentry", "zipjob", " zipfield", "zonefile", "packageentry", "zipfield", "Zipinfo", "ZipEntry", "archiveentry", " zipEntry", "zipcell", "Zipentry", "packagecard", "testjob", "testenter", " zipfile", "zcard", "packagecell", "zjob", "zoneEntry", "archivecard", " zipinfo", "archiveconnection", "testEntry", "zentry", "testentry", "Zipenter", "archivecell", "zipEntry", "zfield", "zEntry"], "entryName": ["EntryName", "elementKey", "elementTitle", "entryKey", "entryType", "entryname", " entryType", " entryPath", " entryname", "attributeName", "seaNot", "entryNAME", " entryTitle", "elementNot", " entryKey", "entryTitle", " entryCase", "entrySpec", "existentName", "Entryname", "cellPath", "sectionSpec", "seaTitle", "attributeKey", "sectionKey", "entryPath", "entryCase", "cellKey", "cellType", "attributeCase", " entryNot", "seaKey", "cellname", " entryNAME", "cellNAME", "EntryKey", "existentNAME", "attributeSpec", "cellName", "seaName", "EntryPath", "sectionName", "elementName", "sectionCase", "entryNot", "existentType", " entrySpec", "existentname"], "n": ["b", "nd", "ng", "ren", "nn", "number", "yn", "r", "k", "z", "N", "nt", "m", "ln", "t", "s", "l", "count", "nor", "gn", "x", "c", "nl", "sn", "nm", "fn", "p", "en", "cn", "num", "nan", "len", "ne", "nc", "nu", "y", "w", " len", "g", "na", "no", " N", "i", "d", "v", " m", "name", "ll", "j", " l", "ns"], "fileoutputstream": ["fileputconsole", "Fileoutputstream", "FileOutputStream", "fileOutputStream", "binarycurrentview", "fileinputform", "Fileoutputform", "fileresponseStream", "filecolumnform", "filecurrentstream", "fileoutputconsole", "fileresponsewindow", "filesystemStream", "fileoutputStream", "binaryoutputfield", " fileputsteam", "filecurrentlink", "fileresponsepipe", "fileoutputform", "fileOutputstream", "fileoutputstyle", "fileoutfield", "FileOutputstyle", "filesystemstream", "filecolumnstream", "fileputStream", "filewriteStream", "fileputsteam", "fileoutputsteam", "fileOutputpipe", "binaryoutputview", "binaryoutputlink", "fileOutputform", "fileOutputconsole", "fileoutlink", "Fileoutputstyle", "filewritepipe", " fileoutputwindow", " filewritepipe", " fileputStream", " filewritestream", "filecolumnstyle", "fileoutputview", "FileoutputStream", "fileinputstream", "fileoutputwindow", "binaryoutputstream", " fileputconsole", "filecurrentfield", "filesystemconsole", "fileputstream", " fileoutputStream", "fileputfield", "binarycurrentfield", "fileoutstream", "filecolumnStream", "fileinputstyle", "filecurrentview", "fileoutputpipe", " filewritewindow", " fileoutputsteam", "filewritestream", " fileoutputpipe", " fileoutputconsole", "fileoutputlink", "filewritewindow", "fileOutputsteam", "binarycurrentlink", " fileputstream", " filewriteStream", "fileOutputstyle", "fileputview", "FileOutputform", "FileOutputstream", "fileOutputwindow", "fileinputStream", "filesystemsteam", "binarycurrentstream", "fileresponsestream", "fileoutview", "fileputlink", "fileoutputfield"]}}
{"id1": "6613944", "id2": "21395184", "code1": "    public static String installOvalDefinitions(final String xml_location) {\n        InputStream in_stream = null;\n        try {\n            URL url = _toURL(xml_location);\n            if (url == null) {\n                in_stream = new FileInputStream(xml_location);\n            } else {\n                in_stream = url.openStream();\n            }\n        } catch (IOException ex) {\n            throw new OvalException(ex);\n        }\n        Class<OvalDefinitions> type = OvalDefinitions.class;\n        OvalDefinitions object = _unmarshalObject(type, in_stream);\n        String pid = _getDatastore().save(type, object);\n        return pid;\n    }\n", "code2": "    @Test\n    public void test30_passwordAging() throws Exception {\n        Db db = DbConnection.defaultCieDbRW();\n        try {\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"5\", 1);\n            PreparedStatement pst = db.prepareStatement(\"UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?\");\n            pst.setString(1, \"esis\");\n            db.executeUpdate(pst);\n            db.commit();\n            p_logout();\n            t30login1();\n            assertTrue(isPasswordExpired());\n            PeopleInfoLine me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().before(DateHelper.now()));\n            t30chgpasswd();\n            assertFalse(isPasswordExpired());\n            me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().after(DateHelper.now()));\n            p_logout();\n            t30login2();\n            assertFalse(isPasswordExpired());\n            t30chgpasswd2();\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"0\", 1);\n            db.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            db.rollback();\n        } finally {\n            db.safeClose();\n        }\n    }\n", "label": 0, "substitutes": {"installOvalDefinitions": [" saveOvalDeclinitions", " saveOevalDefinitions", " saveOvalDefications", " saveOevalEntaults", " saveOvaldefinitions", " saveOevalEntications", " saveOevalDefications", " saveOvalEntications", " saveOvalDeclaults", " saveOvalEntitions", " saveOevalDefaults", " saveOvaldefitions", " saveOevalEntitions", " saveOvalEntaults", " saveOvaldefaults", " saveOvalDefaults", " saveOevalDefitions", " saveOvalDefitions", " saveOvalEntinitions", " saveOvalDefinitions", " saveOvalDeclitions", " saveOvaldefications", " saveOevalEntinitions", " saveOvalDeclications"], "xml_location": [" xml_Location", "xmlContenturi", "xmlContentlocation", "xmlContentloc", "xml_position", "xml_uri", "xmlContentLocation", " xml_position", " xml_uri", "xml_Location", "xml_loc", " xml_loc"], "in_stream": ["in_buffer", "in_iter", "xml_resource", "in64Stream", "xml_store", "in_ream", "xmlptstore", "inMemresource", "inptresource", "in_path", "input_iter", "in64ream", "input_buffer", "in2resource", "in_iterator", "inptstore", " in_iterator", "in_Stream", "in_view", "xml_stream", "inMemstream", "xmlptStream", "input_stream", "in___path", " in_view", " in_Stream", "in2Stream", "in___stream", "in2stream", " in_sign", "in2store", "inptstream", "in_store", "in67sign", "in_sign", "inptStream", "xmlptresource", "in67view", "in_resource", "in___iter", "in67stream", "xmlptstream", " in_ream", "xml_Stream", "in64stream", "in___buffer", "inMemstore", "in67iterator", "input_path", "inMemStream"], "url": ["ls", "path", "dl", "cert", "http", "URL", "lr", "download", "r", "f", "address", "file", "abs", "l", "ur", "link", "gl", "str", "browser", "web", "org", "nl", "loc", "null", "host", "uri", "char", "rl", "xml", "el", "ref", "impl", "mail", "Url", "ssl", "resource", "ul", "bel", "location", "rel", "ll", "name", "mount", "service", "sl"], "type": ["check", "function", "title", "tp", "where", "ver", "ped", "info", "class", "file", "core", "t", "what", "cl", "test", "ype", "ty", "otype", "types", "oid", "pe", "tool", "ct", "ping", "tree", "Type", "y", "typ", "sche", "style", "mail", "ime", "role", "shape", "kind", "event", "module", "model", "base", "create", "TYPE", "cast"], "object": ["obj", "message", "value", "out", "id", "array", "info", "context", "class", "output", "instance", "string", "job", "entry", "system", "detail", "oid", "not", "dict", "version", "document", "result", "element", "json", "entity", "event", "resource", "objects", "o", "model", "data", "name", "node"], "pid": ["ido", "pp", "cert", "title", "prop", "pa", "id", "pm", "pkg", "pty", "pc", " pc", " persistent", "proc", "doi", "rpm", "PK", "sid", "p", "png", " PID", "pn", "pd", "oid", "bid", "uid", "vid", "port", "po", "pan", "ps", "process", "print", "park", "ids", "pic", "pg", "pr", "pet"]}}
{"id1": "838844", "id2": "7425022", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"convert": ["CONversion", "unvert", "consVERT", "ConVERT", "compvert", "Converts", "compprocess", "Converting", "consversion", "unfer", "Conprocess", "unprocess", "unverts", "CONvert", "conversion", "CONverting", "unverted", "confer", "CONfer", "Confer", "conVERT", "compverts", "Convert", "CONVERT", "CONverted", "consvert", "converts", "consverting", "converting", "compversion", "conprocess", "unversion", "converted", "Converted", "Conversion"], "src": ["SOURCE", "path", "rest", "sin", "http", "input", "url", "Source", "sc", "usr", "filename", "func", "pkg", "file", "ser", "config", "rx", "sr", "ource", "s", "rc", "buster", "ur", "str", "cc", "sq", "inst", "req", "stream", "ins", "rs", "source", "from", "txt", "host", "loc", "orig", "img", "hl", "uri", "addr", "href", "attr", "sys", "ebin", "st", "ipl", "scene", "its", "upload", "iv", "dist", "cont", "start", "cur", "rel", "RC", "SourceFile", "scan", "sit"], "dest": ["rest", "write", " Dest", " dst", " destinations", " orig", "dir", "Dest", "test", "tif", "source", "txt", "orig", "img", " destination", "est", "result", "target", "mat", "port", " Destination", "dat", "temp", "foreign", "disk", "dist", "gin", "table"], "in": ["In", "b", "ad", "is", "input", "rin", "sql", "r", "file", "m", "IN", "inn", "reader", "l", "inf", "bin", "as", "ar", "stream", "ins", "source", "from", "en", "up", "io", "el", "ind", "st", "din", "isin", "cin", "serv", "i", "d", "inner", "res"], "p": ["b", "pt", "at", "pp", "ph", "parse", "wp", "tp", "vp", "pa", "it", "dp", "r", "f", "pm", "m", "per", "fp", "pkg", "php", "pc", "t", "pre", "l", "parser", "prot", "c", "cp", "py", "pro", "pe", "pd", "h", "ping", "er", "op", "part", "j", "sp", "rep", "pers", "post", "g", "ps", "jp", "i", "d", "pi", "P", "lp", "pl", "ap", "pg", "pb"], "ds": ["cs", "eds", "ts", "tags", "gd", "ags", "ads", "hd", "uds", "pd", "bs", "outs", "eps", "ports", "ss", "edes", "workers", "DS", "nas", "cks", "ils", "amps", "des", "ats", "s", "ras", "iffs", "os", "hs", "aws", "tests", " d", " ads", "sd", "db", "scripts", "terms", "sets", "ns", "ls", "dos", "gs", "dl", "lists", "dh", "tp", "docs", "dp", "ands", "vs", "dds", "sts", "dates", "rs", "xs", "df", "dt", "mys", "posts", "its", "js", "els", "drivers", "ws", "di", "obs", "points", "ys", " os", "loads", " des", " dd", "tes", "dd", "Ds", "ods", " DS", "ps", "ks", "d", "yes", "qs"], "format": ["feat", "path", "at", "template", "title", "parse", "MAT", "id", "it", "type", "f", "mt", "output", "lat", "file", "ats", "fc", "t", "l", "pretty", "mode", "top", "feature", "size", "source", "Format", "ct", "unit", "act", "pattern", "layout", "settings", "version", "spec", "policy", "set", "sche", "mat", "style", "form", "shape", "fm", "module", "cf", "pi", "name", "tag", "status", "filter", "table", " Format"], "hasPixelData": ["hasixeldata", " hasPixelDATA", "HasPixelData", "hasFrameData", "hasFramedata", "hasPixeldata", "haspixeldata", "HaspixelDATA", "Haspixeldata", "HaspixelData", "HasPixelDATA", "hasPixelDATA", "haspixelDATA", "haspixelData", "hasixelDATA", "hasFrameDATA", "HasPixeldata", " hasPixeldata", "hasixelData"], "inflate": ["invalidate", "inFlicate", "Inflocate", "Informat", "inflocate", "inFlATE", "Inflat", "informate", "Informate", " invalidate", "invalidicate", "inFlate", "inFLate", "infolated", " inflocate", "Inflated", "informated", " invalidATE", "infolocate", "inflated", "inFLat", "invalidATE", "Informocate", "inFLocate", "incelATE", "inFlocate", " inflicate", "informocate", "Inflate", "inflATE", "incelocate", "informat", "invalidocate", "incelicate", " invalidicate", " invalidocate", "infolate", "inflicate", "inFLated", "Informated", "infolat", " inflATE", "incelate", "inflat"], "pxlen": ["phpdec", "pxden", "mmlen", "phplen", "pxln", "mxdec", "pixells", "packfun", "pxlin", "pexln", "tmplength", "mxlen", "pexfun", "cplength", "pxdec", "mmln", "tmpln", "xylength", "packdec", "xplen", "pexlen", "pixellen", "packlength", "pexlength", "tmplin", "xpden", "pexls", "pixelfun", "xyln", "packls", "packlen", "cpln", "mmlength", "mmlin", "phplength", "cpden", "xylen", "tmplen", "phpln", "pxfun", "pxlength", "xpln", "xplength", "mxln", "mxlength", "pexden", "packln", "xylin", "pixellength", "pxls", "cplen"], "out": ["inv", "obj", "user", "ex", "group", "init", "OUT", "net", "ou", "store", "err", "output", "list", "ln", "dir", "pretty", "client", "Out", "crit", "screen", "gov", "cmd", "up", "io", "sys", "outs", "msg", "writer", "log", "temp", "conn", "gr", "sum", "print", "aos", "res", "outer", "inter", "name", "prefix", "cfg"]}}
{"id1": "19934218", "id2": "5035872", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"doCrypt": [" docrypt", "Docrypt", " doHash", " doesHash", "DoCrypt", "doHash", " doDec", "DoHash", " doescrypt", "docrypt", "doDec", " doesDec", "DoDec", " doesCrypt"], "text": ["message", "path", "read", "pt", "template", "value", "format", "title", "input", "aut", "url", "binary", "subject", "select", "output", "translation", "nt", "context", "config", "t", "string", "str", "tx", "test", "x", "key", "ext", "TEXT", "term", "word", "txt", "source", "ct", "act", "pattern", "password", "document", "command", "msg", "w", "body", "form", "log", "buffer", "event", "cont", "content", "print", "code", "now", "Text", "data", "name", "comment"], "UnsupportedEncodingException": ["UnsupportedChoderError", "UnsupportedChodingException", "UnsupportedChodingEx", "UnsupportedChodingError", "UnsupportedEncryptionError", "UnsupportedEncgorithmEx", "UnsupportedChoderEx", "UnsupportedChoderException", "UnsupportedEncoderException", "UnsupportedEncryptionEx", "UnsupportedEncoderError", "UnsupportedEncoderEx", "UnsupportedEncodingError", "UnsupportedEncodingEx", "UnsupportedEncgorithmException", "UnsupportedChodingExit", "UnsupportedEncryptionExit", "UnsupportedEncodingExit", "UnsupportedEncoderExit", "UnsupportedChoderExit", "UnsupportedEncryptionException", "UnsupportedEncgorithmError", "UnsupportedEncgorithmExit"], "md": ["ad", "nd", "cd", " ms", "gm", "ms", "mt", "red", "grad", "MD", "m", "mp", "dir", "rm", "der", " maj", "mk", "add", " od", "hd", " dd", " df", "mc", "df", " rm", " mp", " mo", "ent", "dd", "cmd", "pd", " cmd", "det", " exec", "ind", " man", "sha", "mm", "ld", "bd", "od", "mn", "mb", "td", "mand", "d", " Md", "sd", " cd", "mg", " mac", "di", "sm", "dm"], "sha1hash": ["sha512cache", "SHA1hex", "shaOnehash", "SHA1key", "SHA1hash", " SHAOnesum", " SHAOneheader", "sha4cache", " SHA1sum", "sha4header", "sha1key", "ha1hash", "sha1Hash", "shaonesum", "sha1sum", "sha1hex", "ha1sum", "sha2hex", "shaOnecache", "shaOneheader", "sha512sum", "sha4sum", "sha3key", "sha1header", "sha512hash", "sha2sum", "shaonehex", " SHAOnecache", "shaonekey", " SHA1cache", "sha4hash", "shaOnesum", "sha2cache", "sha2header", "sha3hex", "shaonehash", "sha3Hash", "shaoneHash", "SHA2key", "haonehash", " SHAOnehash", "ha1cache", "haoneHash", "sha3hash", "sha2Hash", "ha1Hash", "SHA2Hash", "sha1cache", "SHA1Hash", "SHA2hex", "sha2key", " SHA1header", "sha2hash", " SHA1hash", "haonecache", "shaonecache", "haonesum", "SHA2hash", "sha512Hash"]}}
{"id1": "7633336", "id2": "345515", "code1": "    private JSONObject executeHttpGet(String uri) throws Exception {\n        HttpGet req = new HttpGet(uri);\n        HttpClient client = new DefaultHttpClient();\n        HttpResponse resLogin = client.execute(req);\n        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));\n        StringBuilder sb = new StringBuilder();\n        String s = null;\n        while ((s = r.readLine()) != null) {\n            sb.append(s);\n        }\n        return new JSONObject(sb.toString());\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"executeHttpGet": ["executeUrlGet", " executeHttpPut", " executeHTTPPut", " executeHttpPost", "executeHTTPPut", "executeHttpGET", " executeHttpGET", "executeHttpPut", "executeRemotePut", "executeHTTPGET", " executeHTTPGet", " executeHTTPGET", "executeRemoteGet", "executeHttpPost", " executeHTTPPost", "executeUrlPost", "executeRemoteGET", "executeHTTPGet", "executeRemotePost", "executeUrlGET", "executeHTTPPost", "executeUrlPut"], "uri": ["message", "path", "range", "http", "parse", "qi", "uu", "query", "url", "force", "address", "filename", "subject", "du", "description", "request", "wiki", "ku", "ur", "link", "string", "https", "queue", "original", "directory", "ri", "html", "origin", "u", "unit", "basic", "href", "password", "command", "msg", "URI", "status", "i", "resource", "server", "location", "res", "pi", "name", "prefix", "ui", "reset"], "req": ["inv", "pp", "http", "find", "query", "sql", "url", "comm", "pkg", "request", "task", "quick", "mk", "md", "quest", "job", "sq", "proc", "qt", "Request", "dq", "qq", "crit", "q", "comp", "cmd", "resp", "work", "msg", "ind", "require", "desc", "requ", "ref", "get", "ctrl", "conn", "gr", "resource", "res", "create", "j"], "client": ["net", "http", "cache", "secure", "grid", "tc", "url", "cap", "force", "ci", "Client", "ip", "api", "pb", "https", "cell", "google", "cl", "web", "c", "key", "close", "pro", "cp", "ct", "cm", "console", "ch", "city", "remote", "conn", "con", "chain", "connection", "server", "co", "response", "cli", "service", "call"], "resLogin": ["invLogin", "statsLogin", "ResConnect", "resClient", "statslogin", "reslogin", "Reslogin", " reslogin", " resClient", "invlogin", "invConnect", "statsConnect", "statsClient", "resConnect", "ResLogin", " resConnect", "ResClient"], "r": ["b", "rect", "dr", "vr", "ro", "lr", "f", "err", "rx", "reader", "sr", "rc", "rt", "rb", "ur", "rg", "rar", "rs", "kr", "rw", "br", "p", "nr", "rn", "rl", "er", "cr", "rr", "river", "R", "re", "rd", "res", "mr", "hr", "fr"], "sb": ["b", "BB", "ib", "gb", "bf", "bis", "rb", "sbm", "obb", "bj", "SB", "bps", "sq", "cb", "bg", "erb", "lb", "bs", "sam", "zb", "sp", "ub", "eb", "bh", "nb", "bn", "bd", "bb", "mb", "ssl", "sa", "sf", "stab", "xb", "bt", "sd", "kb", "wb", "lp", "sg", "sl", "pb"], "s": ["b", "ls", "gs", "is", "full", "gets", "ts", "where", "ds", "fs", "sql", "ys", "comm", "z", "ser", "sv", "t", "se", "string", "str", "less", "sts", "sq", "sn", "n", "rs", "source", "ins", "tes", "os", "h", "bs", "S", "sp", "state", "y", "sol", "hs", "st", "its", "js", "g", "ps", "i", "ches", "ss", "qs", "sample", "ws", "ms", "sl", "ns"]}}
{"id1": "13563706", "id2": "22536033", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"doGet": ["doget", "DoGET", " doGET", " doget", "handleget", "DoGet", "doGET", "handleGET", " doPut", "handlePut", "handleGet", "doPut", "Doget", "DoPut"], "request": ["setup", "message", "transform", "path", "user", "each", "http", "QUEST", "input", "query", "search", "application", "url", "address", "context", "subject", "project", "first", "reference", "current", "use", "frame", "directory", "route", "Request", "forward", "xml", "initial", "attribute", "document", "command", "version", "view", "socket", "report", "position", "get", "parent", "re", "complete", "connection", "event", "resource", "create", "order", "hello", "reset", "call"], "response": ["reply", "message", "block", "header", "ce", "collection", "format", "display", "http", "search", "write", "application", "output", "description", "frame", "network", "success", "summary", "answer", "zero", "continue", "image", "next", "exit", "ve", "resp", "tree", "version", "document", "default", "result", "foundation", "sequence", "view", "respond", "json", "console", "report", "position", "see", "fire", "render", "condition", "connection", "server", "print", "res", "security", "hash", "Response", "example", "status", "service", "relation"], "selectedPage": ["selectionItem", "electionPage", "selectionFile", " selectedFile", "lectedLine", "selectedLine", "lectedFile", "selectPage", " selectedPort", "specifiedFrame", "selectItem", "selectionPage", "electedPage", "verifiedFile", "selectedDocument", "selectedpage", "namedPort", "matchedPort", "lectedItem", " selectedFrame", "lectedPort", " selectedpage", "singlepage", "selectLine", "namedLine", "matchedpage", "electedPort", "matchedPage", "selectFile", "selectionToken", "singlePage", "singleFrame", "lectedPage", "selectionLine", " selectedRow", "selectedToken", "namedFrame", "namedKey", "specifiedDocument", "selectPort", "lectedRow", "selectPath", "selectedRow", "verifiedRow", "singlePort", "specifiedPort", "lectedDocument", "selectedPath", " selectedPath", "selectedItem", "verifiedPage", "namedPage", "matchedFrame", "lectedKey", " selectedKey", "namedToken", "verifiedpage", "electionDocument", "lectedpage", "lectedToken", "selectedFile", "specifiedPage", "electedpage", "lectedFrame", "selectedKey", "selectedPort", "electionFrame", "namedpage", "lectedPath", "selectedFrame", "electionPort", "selectionPort", " selectedLine", "electedFrame"], "page": ["group", "pp", "project", "current", "phone", "image", "next", "p", "port", "log", "line", "resource", "profile", "node", "filter", "user", "collection", "url", "age", "self", "window", "row", "proxy", "successful", "result", "site", "chain", "pointer", "point", "pool", "table", "message", "block", "application", "instance", "network", "record", "peer", "layout", "version", "Page", "phrase", "channel", "pages", "display", "cache", "number", "office", "associated", "address", "be", "force", "output", "frame", "client", "rule", "created", "menu", "object", "to", "document", "view", "policy", " Page", "position", "form", "parent", "me", "server", "language", "complete"], "portalRequest": ["portaleApply", "portalingAccess", "portalaAccess", "portalityRequest", "portsalResponse", "PortalThread", " portalApply", "portalaCall", "portsortalEvent", "portualRequest", "terminalidQuery", "portortalContext", "portalidSession", "portalContext", "portortalQuery", "portualrequest", " portalCall", "portaleResponse", "portsortalResponse", "portaleSession", "PortalContext", "portaleContext", " portaleCall", "terminalRequest", "portalrequest", "terminalQuery", "PortalQuery", "portalidResponse", "portalingRequest", "portralContext", "PortalResponse", "portpalContext", "terminalResponse", "portalThread", "portalidContext", "portortalRequest", "PortaleContext", "portpalRequest", "portralResponse", "portalidRequest", "portralQuery", "portalFrame", "PortaleThread", "portalidFrame", "portsortalRequest", "portortalThread", " portaleRequest", "portalityResponse", "portpalThread", " portaleApply", "portortalrequest", "portalerequest", "portalingApply", "portalAccess", "portalQuery", "portralSession", "portaleQuery", "portsortalrequest", " portalAccess", "PortalRequest", "terminalidResponse", "portalaRequest", " portaleAccess", "PortalFrame", "portsalrequest", "portortalResponse", "PortaleRequest", "terminalidRequest", "portaleEvent", "portaleCall", "PortaleFrame", "portalityFrame", "portalingCall", "portpalResponse", "portaleThread", "portsalRequest", "portalaApply", "portaleAccess", "PortaleResponse", "portalityContext", "portaleRequest", "portualEvent", "portalApply", "portualResponse", "portalSession", "portsalEvent", "portaleFrame", "portalEvent", "portalidQuery", "PortaleQuery", "portralRequest", "terminalSession", "portalCall", "portortalEvent", "portalResponse", "terminalidSession"], "pageProp": ["poolProp", "propertyPriv", "pagePriv", " pageComp", "propertyProp", "pagePred", "agePro", " pagePriv", "profileZip", "pageProperty", "keyProperty", "profilePred", "poolPred", "phrasePr", "pagePro", "officeProp", "pageComp", "officePriv", "pageZip", " pagePr", "imagePr", "sectionPred", "imageProp", "agePred", "officeDef", "pageDef", "agePr", "propertyDef", " pagePred", "sectionPro", "imagePred", "pagePr", "imagePro", " pagePack", "phraseProperty", "profilePro", "propertyPack", "ageProp", "keyProp", " pagePro", "poolZip", "poolPro", " pageProperty", "sectionProp", "phraseComp", "keyComp", " pageDef", "profileProp", "officePack", "sectionZip", "keyPr", "phraseProp", "pagePack"], "possiblePage": ["PossiblyPage", "PossiblePage", "piblePage", "pibleChild", "pbableCollection", " packedLine", "possiblyCollection", "possibleLine", " possibleTag", "pentialPage", "possiblyUser", "pablePage", "pableLine", "pspecifiedPage", "pspecifiedPages", "packedTag", "possiblyTag", "pbableUser", "possiblyChild", "packedCollection", "possibleChild", " possibleLine", "PossiblePages", "Possiblepage", "PossiblyCollection", " packedTag", " possibleCollection", "pentialTag", "pibleCollection", "possiblepage", "pbableChild", "pspecifiedpage", "pibleUser", "possibleTag", "PossiblyUser", "pbablePage", "pableTag", "possibleCollection", "PossibleTag", "PossibleCollection", "possiblyLine", "possiblePages", " packedCollection", "possiblyPage", "PossiblyChild", "pentialpage", "pableCollection", "pspecifiedTag", " packedPage", "packedPage", "pentialPages", "PossibleChild", "possibleUser", "packedLine", "PossibleUser"], "property": ["message", "header", "value", "Property", "title", "function", "prop", "type", "address", "class", "description", "config", "properties", "second", "frame", "string", "trace", "feature", "key", "rule", "domain", "p", "object", "rue", "expression", "attribute", "owner", "command", "field", "policy", "definition", "position", "behavior", "resource", "metadata", "integer", "location", "operator", "name", "phrase", "relation", "service", "variable"], "referer": ["relender", "relerential", "rorered", "reportrer", "Referee", "retered", "diffrer", "deferer", "refrer", "verrer", "redere", "reonder", "aferential", "refener", "printrier", "afrer", "reener", " refered", "referential", "Refere", "vererential", "refered", "vererer", "requonder", "requering", "retarer", "rorirect", "defrer", "relener", "defirect", "reportered", "refere", "aferer", " refirect", "refonder", "retrer", "relrer", "rorrer", "differer", "rederee", "refering", "refarer", "afener", "fener", "frer", "requerer", "rerier", "rorerer", "reere", "reterer", "reender", "printerer", "refirect", "reering", "rangeender", "reeree", "differing", "ferer", "reerer", "reered", "refender", "diffonder", " refrer", "refrier", "reerential", "redrer", "rangerer", "relering", "rearer", "rederer", "reportarer", "Refrer", "rangeerer", "reporterer", "Referer", "defered", "verrier", "relerer", "fering", "printrer", "printerential", "referee", "rerer", "requrer", "rangeener"], "e": ["r", "f", "err", "oe", "error", "m", "echo", "t", "se", "eg", "ae", "x", "de", "n", "ception", "a", "p", "h", "eeee", "er", "eu", "ge", "E", "te", "ie", "g", "es", "me", "event", "eur", "o", "ee"]}}
{"id1": "9413074", "id2": "350482", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"getLocation": ["newLoc", "newDescription", "getURI", " getDescription", "getLoc", "loadDescription", "GetURI", " getURL", "getlocation", " getlocation", "getDescription", "GetLocation", "GetLoc", " getLoc", "GetDescription", " getURI", "Getlocation", "getURL", "loadURI", "loadLocation", "newLocation", "newlocation", "GetURL", "loadURL"], "clazz": ["ClClass", "Claz", "Clazz", "Clos", "scaz", "scazz", "CLclass", "klClass", "CLazz", "klaz", "clamp", "claz", "clClass", "clos", "scos", "scamp", " clos", " clamp", "klclass", "klazz", " claz", "CLClass", "CLaz", "clclass", "Clclass", "Clamp"], "url": ["ls", "user", "path", "dl", "cert", "http", "URL", "lr", "sql", "r", "f", "address", "err", "abs", "l", "ur", "gl", "string", "link", "browser", "https", "str", "client", "loader", "web", "org", "nl", "loc", "this", "row", "run", "q", "host", "hl", "u", "uri", "addr", "util", "char", "rl", "handle", "xml", "result", "socket", "ref", "sb", "ret", "impl", "remote", "Url", "ml", "build", "mail", "get", "log", "ssl", "conn", "buffer", "resource", "ul", "base", "rel", "ll", "ob", "mount", "channel", "sl"], "location": ["message", "path", "operation", "library", "Location", "slot", "range", "value", "function", "title", "display", "where", "direction", "update", "type", "application", "address", "filename", "translation", "ion", "media", "description", "reference", "ocation", "l", "string", "trace", "availability", "directory", "summary", "padding", "feature", "nl", "peer", "origin", "loc", "color", "row", "family", "scope", "area", "layout", "expression", "document", "result", "command", "length", "selection", "position", "none", "behavior", "resolution", "usage", "history", "resource", "displayText", "language", "name", "comment", "relation", "local", "region"], "file": ["library", "path", "block", "user", "ory", "files", "format", "full", "out", "face", "binary", "f", "filename", "output", "fp", "dir", "checked", "image", "run", "page", "le", " File", "object", "pe", "ile", "angle", "io", "folder", "ref", "ca", "FILE", "port", "parent", "entity", "resource", "module", "name", "db", "channel", "File", "table"]}}
{"id1": "15797402", "id2": "2398448", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "label": 0, "substitutes": {"parse": ["read", "transform", "format", "write", "save", "map", "apply", "php", "use", "add", "parser", "se", "load", "patch", "p", "close", "pe", "handle", "ping", "dump", "scale", "xml", "slice", "interpret", "build", "render", "process", "shape", "resource", "print", "create", "execute", "tag", "split", "filter"], "stream": ["Stream", "read", "message", "http", "input", "url", "download", "open", "output", "sync", "file", "clean", "instance", "reader", "zip", "test", "window", "image", "source", "in", "handle", "archive", "document", "sequence", "console", "length", "form", "upload", "stack", "iterator", "chain", "buffer", "cont", "event", "content", "resource", "sample", "data", "ream", "response", "channel"], "handler": ["message", "storage", "function", "ctx", "application", "wrapper", "address", "reader", "parser", "loader", "management", "host", "h", "processor", "handle", "password", "hand", "policy", "hander", "Handler", "writer", "worker", "controller", "shape", "event", "connection", "resource", "server", "service", "pool", "callback"], "metadata": ["message", "header", "template", "dirty", "ctx", "info", "tar", "mt", "MD", "m", "unknown", "config", "properties", "adata", "md", "common", "met", "parts", "google", "management", "memory", "image", "managed", "detail", "still", "details", "dd", "manager", "handle", "basic", "general", "xml", "document", "json", "policy", "property", "definition", "pdf", "meta", "iterator", "java", "material", "td", "content", "module", "hold", "mem", "data"], "context": ["collection", "ce", "template", "ctx", "component", "sc", "options", "translation", "instance", "config", "current", "frame", "network", "cc", "system", "reason", "null", "environment", "dict", "document", "command", "state", "sequence", "set", "stack", "usage", "condition", "chain", "event", "connection", "content", "module", "resource", "location", "Context", "response", "local"], "name": ["alias", "path", "channel", "value", "title", "on", "time", "id", "all", "pass", "url", "type", "filename", "description", "file", "current", "l", "common", "string", "client", "size", "system", "nm", "key", "Name", "term", "family", "image", "source", "n", "nl", "reason", "null", "label", "lower", "len", "version", "part", "default", "named", "old", "body", "ame", "none", "no", "NAME", "names", "resource", "base", "create", "data", "comment", "prefix", "service", "local"], "out": ["external", "user", "ex", "obj", "net", "OUT", "us", "ou", "conf", "it", "all", "url", "output", "file", "col", "list", "cos", "oss", "Out", "n", "one", "null", "cn", "cmd", "in", "to", "lay", "up", "flush", "io", "sys", "outs", "writer", "conv", "OU", "po", "serv", "con", "co", "sum", "print", "aos", "v", "auto", "o", "outer", "res", "table", "gen"]}}
{"id1": "22734545", "id2": "11546108", "code1": "    public void generate(String urlString, String target) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream());\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target));\n        byte[] buf = new byte[10 * 1024];\n        int len;\n        while ((len = inputStream.read(buf, 0, buf.length)) != -1) {\n            outputStream.write(buf, 0, len);\n        }\n        inputStream.close();\n        outputStream.close();\n        urlConnection.disconnect();\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"generate": [" generateator", "generator", "generiate", "validator", "validate", "deciate", " generatece", "decator", "validiate", "validce", "decate", "generce", "decce", " generateiate", " generateate"], "urlString": [" urlRest", "UrlString", "uriRest", "lString", "lSource", " urlSource", "UrlSource", "UrlStr", "uriSource", "urlInterface", " urlInterface", "uriString", "urlSource", "UrlRest", "urlRest", " urlStr", "lStr", "urlStr", "UrlInterface", "lInterface"], "target": ["dest", "path", "template", "src", "title", "address", "filename", "output", "tmp", "project", "file", "dir", "t", "Target", "link", "trace", "summary", "top", "root", "origin", "gt", "test", "tif", "source", "host", "p", "png", "table", "to", "layout", "result", "pdf", "temp", "location", "base", "arget", "name", "bolt", "local", "localhost"], "url": ["ls", "user", "dl", "http", "URL", "r", "f", "l", "ur", "gl", "link", "https", "str", "browser", "loader", "web", "nl", "hl", "q", "u", "uri", "char", "rl", "www", "ref", "pl", "get", "Url", "ml", "build", "ssl", "ul", "bel", "base", "rel", "ll", "mount", "sl"], "urlConnection": ["webConnection", "browserConnect", "httpconnection", "handleConn", "urlConn", "webNode", " urlConnect", "UrlConn", "urlNode", "webconnection", " urlconnection", "handleConnect", "webConnect", "browserSession", "UrlSession", "handleConnection", " urlNode", "UrlConnection", "urlConnect", "Urlconnection", "browserconnection", "browserConnection", "httpConnection", "handleconnection", "httpNode", "urlSession", "urlconnection", "httpConn", "UrlConnect", "httpSession", "httpConnect"], "inputStream": ["inputThread", "readThread", " inputSteam", "acceptStyle", "acceptThread", "activeStream", "activestream", "InputView", "activeSource", "activeSteam", "acceptSteam", "outputThread", " inputView", "inputStyle", "inputSource", "innerStream", "InputThread", "readStream", "InputStream", "outputStyle", " inputStyle", " inputSource", "acceptStream", " inputstream", " inputThread", "outputSteam", "innerstream", "inputSteam", "innerSteam", "innerSource", "inputView", "readView", "inputstream", "InputSteam", "readSteam"], "outputStream": ["displayContext", "displaySteam", "writeStreamer", "OutputStack", "outputStreamer", "writeForm", "displayStream", " outputStack", "writeStream", "inputForm", "writeLink", " outputStreamer", "applicationWindow", "outputForm", "outputContext", " outputSteam", "OutputSteam", " outputContext", "OutputWindow", "OutputStream", "inputLink", "outputLink", "writeSteam", "applicationSteam", "outputSteam", "applicationStream", " outputForm", "inputSteam", "writeContext", " outputLink", " outputWindow", "outputStack", "outputWindow", "displayStreamer", "applicationStack"], "buf": ["b", "block", "bytes", "prop", "uf", "cap", "fam", "pkg", "bl", "bc", "rb", "bin", "cb", "tx", "proc", "cat", "Buffer", "loc", "br", "cv", "img", "arr", "bu", "cmd", "batch", "good", "box", "bs", "bag", "bar", "msg", "seq", "rev", "alph", "tab", "conv", "dat", "Buff", "bn", "nb", "buffer", "vec", "fb", "cur", "buff", "ob", "db", "var"], "len": ["ls", "lan", "dl", "all", "cap", "BL", "del", "z", "li", "nt", "lib", "ln", "bl", "t", "l", "gl", "str", "pos", "L", "fin", "nl", "fun", "n", "val", "El", "le", "end", "en", "lon", "coll", "il", "cmp", "el", "lf", "ind", "length", "mil", "seq", "Len", "lic", "ld", "no", "vec", "syn", "v", "elt", "ll", "rel", "lit", "ler"]}}
{"id1": "14053882", "id2": "6840241", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["decrypt", "encrypted", "encode", "Encode", "Encrypt", "decode", " encrypted", "Encryption", "encryption", " encryption", "Encrypted", " encode", "decryption", "decrypted"], "plaintext": ["plainth", "plainText", "broadText", "longText", "plainpassword", "mainpassword", " plainTEXT", "broadtext", "mainTEXT", "longth", "mainText", " plainth", "broadmessage", "longtext", "publicTEXT", " plainmessage", "longmessage", " plainText", "publictext", " plainpassword", "maintext", "plainmessage", "plainTEXT", "publicText", "publicpassword", "broadth"], "md": ["nd", "ng", " mc", "cd", "dr", "dh", "ds", "del", "mt", "grad", "nt", "MD", "m", "mp", "ma", "rm", "der", "mark", "mk", " ma", "met", "hd", " dd", "managed", "mo", "mc", "df", " mo", "dd", "cmd", "pd", "det", "sam", "ind", "mod", "sha", "mm", "ld", "med", "dig", "od", "mn", "mb", "esm", "metadata", "d", "sd", "mand", "mg", "ms", "sm", "dm"], "raw": ["known", "message", "RAW", "bytes", "extra", "full", "value", "out", "input", "all", "array", "r", "clean", "unknown", "encrypted", "original", "bare", "random", "n", "right", "row", "orig", " Raw", "hook", "good", "box", "sh", "bound", "valid", "Raw", "unsigned", "clear", "hex", "aw", " RAW", "buf", "custom", "rendered", "available", "base", "pack", "data", "strip"], "hash": ["message", "cert", "hat", "flash", "cache", "sign", "id", "search", "url", "ssh", "unknown", "ash", "hed", "ashes", "mac", "html", "key", "mask", "h", "handle", "alert", "href", "sh", "password", "tr", "shadow", "height", "json", "hidden", "ashed", "sha", "has", "hex", "Hash", "total", "sum", "print", "proof", "tag"]}}
{"id1": "2465747", "id2": "20920051", "code1": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"postRequest": ["PostCommand", "PostRequest", "postrequest", "processCommand", " postrequest", "PostQuery", " postQuery", "processRequest", "processQuery", "postCommand", "Postrequest", "postQuery", "processrequest", " postCommand"], "urlString": ["urlName", "UrlString", "uriStr", "urlRaw", "lString", "lSource", "UrlName", " urlRaw", "urlSeries", "UrlSource", "UrlStr", "uriName", "lRaw", "uriSource", "uriString", "lName", "sslSeries", "sslString", "sslRaw", "sslStr", " urlSeries", "urlSource", "lSeries", " urlStr", "lStr", "urlStr"], "data": ["message", "user", "extra", "format", "value", "store", "cache", "update", "info", "description", "session", "map", "properties", "times", "done", "params", "record", "results", "missing", "resources", "details", "p", "action", "def", "batch", "to", "settings", "dict", "default", "state", "json", "text", "DATA", "images", "post", "form", "meta", "dat", "none", "ata", "content", "metadata", "d", "resource", "hash", "response", "name", "filter", "table"], "returnData": ["saveDATA", "saveQuery", " returnLine", "ReturnString", "commentDat", "getDATA", "saveText", " returnDATA", "returnDat", "resultLine", "getString", "reportDATA", "ReturnLine", "ReturnDATA", "returnString", " returnQuery", "fullDat", "returnDATA", "fullData", "reportData", "fullLine", "returnText", "fullDATA", "commentDATA", "reportLine", "reportDat", "ReturnQuery", "getText", "ReturnText", "commentData", " returnString", "saveData", " returnText", "resultData", "commentLine", "resultString", "getData", "ReturnData", "returnLine", "resultText", "returnQuery"], "url": ["ls", "b", "dl", "http", "URL", "r", "address", "f", "open", "l", "ur", "link", "str", "https", "gl", "client", "google", "job", "org", "loader", "nl", "u", "uri", "get", "log", "Url", "re", "mail", "conn", "build", "ssl", "ul", "bel", "base", "location", "ll", "mount", "sl", "call"], "connection": ["operation", "message", "online", "channel", "creator", "Connection", "function", "cert", "number", "application", "open", "wrapper", "subject", "database", "ion", "description", "session", "use", "l", "link", "network", "https", "client", "directory", "entry", "connected", "c", "character", "container", "n", "uri", "established", "to", "cone", "manager", "general", "io", "nc", "document", "command", "socket", "position", "using", "statement", "city", "no", "conn", "con", "condition", "resource", "communication", "creation", "pointer", "response", "connect", "relation", "service"], "out": ["b", "obj", "user", "ex", "at", "net", "OUT", "ou", "all", "write", "r", "output", "ion", "list", "t", "l", "pretty", "client", "Out", "n", "null", "os", "screen", "p", "to", "flush", "up", "io", "cm", "outs", "console", "w", "ch", "writer", "conv", "OU", "g", "log", "con", "conn", "buffer", "i", "co", "print", "inner", "v", "o", "auto", "aos", "outer", "can"], "keySet": ["KeyMap", "KEYSet", "Keyset", "KeyName", "numSet", "rowList", "keysList", "KeySet", "keyset", " keySpec", "numList", "KEYList", "keysSet", "KEYMap", "KEYSpec", "keysMap", "keysName", "verList", "KEYName", " keyset", "keyName", "numName", " keyList", "keySpec", "rowSet", "verSet", "KeyList", "keyMap", " keyMap", "rowSpec", "keyList", "verset", "verMap", " keyName", "numset"], "values": ["strings", "files", "points", "actions", "modules", "lists", "vals", "gets", "value", "keys", "ves", "tags", "fs", "vs", "options", "versions", "users", "times", "properties", "forms", "params", "pins", "bes", "groups", "types", "results", "rows", "flows", "maps", "roots", "services", "events", "bs", "settings", "issues", "verts", "changes", "obs", "als", "UES", "windows", "its", "ports", "codes", "fields", "tests", "members", "pes", "names", "objects", "views", "items", "terms", "Values", "sets", "blocks", "rules"], "count": ["group", "cd", "title", "conf", "make", "find", "repeat", "OUNT", "err", "amount", "current", "and", "consider", "add", "cell", "test", "size", "continue", "next", "cloud", "ct", "batch", "cycle", "con", "sum", "contact", "name", "id", "all", "nt", "c", "num", "coll", "ask", "handle", "flag", "frequency", "valid", "state", "account", "cont", "total", "code", "now", "table", "Count", "counter", "empty", "check", "list", "country", "found", "\u00e7", "n", "loop", "unique", "ind", "sequence", "length", "const", "last", "base", "ount", "mount", "index", "child", "number", "force", "first", "currency", "ctr", "client", "cmd", "month", "hold", "create", "call"], "in": ["In", "read", "check", "is", "or", "on", "conf", "input", "it", "rin", "al", "r", "ma", "IN", "inn", "reader", "and", "l", "inside", "inf", "bin", "ins", "source", "from", "inc", "en", "mi", "ic", "io", "ind", "body", "din", "form", "isin", "re", "cin", "mn", "i", "gin", " din", "raw", "buffer", "inner", "pi", "ini"], "inputLine": ["InputData", "contextRow", "outputLINE", "textFile", "inputSet", " inputLINE", "viewLine", "InputLine", "viewline", "contextline", "outputline", "inputData", "inputline", " inputRow", "evalSet", "inputLINE", "evalLine", "viewData", "evalData", "outputLine", "InputRow", "Inputline", "textLine", " inputSet", "evalFile", " inputline", "textSet", "outputRow", "contextLINE", "inputFile", "inputRow", " inputData", "viewRow", " inputFile", "contextLine", "textData"]}}
{"id1": "16142024", "id2": "823074", "code1": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpfile", "linkBuffer", "CopyFile", "cpFilename", "cpBuffer", "linkfile", "CopyFilename", "linkFilename", "cpFile", "CopyBuffer", "copyBuffer", "linkFile", "Copyfile", "copyFilename", "copyfile"], "srcFile": ["destLine", "rcile", "sourceFiles", "selFile", " srcfile", "destfile", "Sourcefile", "rcfile", "srcile", "srcDir", " srcFiles", "rcFile", " srcile", "sourcefile", "synFile", "rcFILE", "sourceFile", "sourceLine", " srcLine", "srcFiles", " srcWeb", "Sourceile", "SourceWeb", "sourcePath", "srcPath", "synDir", "rcWeb", "srcFILE", "synFILE", " srcPath", "rcPath", "rcDir", "selFILE", "srcfile", "srcWeb", "SourceFile", "srcLine", "destFiles", "selDir"], "destDir": ["descDirectory", " destDirectory", "stDir", "DestFile", "distPath", "distDirectory", " destPath", "distdir", "destPath", "srcDir", " destdir", "destdir", "Destdir", "stCond", "DestUrl", "srcdir", "destUrl", "descDir", "distDir", "srcPath", "DestDir", " destUrl", "destDirectory", "stDirectory", "descCond", "srcUrl", "srcDirectory", "destCond", "srcCond"], "buffer": ["b", "message", "read", "block", "header", "value", "cache", "input", "binary", "output", "file", "paste", "frame", "append", "queue", "directory", "padding", "entry", "memory", "Buffer", "window", "row", "quote", "source", "word", "batch", "password", "attribute", "command", "result", "sequence", "length", "text", "chain", "buf", "raw", "pad", "resource", "available", "code", "base", "sample", "buff", "data", "phrase", "comment", "channel", "table", "variable"], "destFile": ["DestFile", "destLog", "newDir", " destPath", "destPath", "srcDir", "newFile", "DestFiles", "srcTable", " destFiles", "DestPath", "srcFiles", "srcPath", "DestDir", "newTable", "destTable", "newLog", " destTable", "srcLog", " destLog", "destFiles"], "in": ["In", "read", "iter", "is", "init", "sin", "on", "input", "rin", "it", "al", "ain", "per", "IN", "inn", "reader", "inside", "inf", "bin", "ai", "ar", "ir", "ins", "source", "inc", "from", "en", "ze", "ic", "up", "ind", "oin", "im", "din", "isin", "by", "cin", "con", "i", "gin", " din", "inner", "ini"], "out": ["b", "obj", "at", "net", "OUT", "ou", "on", "cache", "it", "write", "output", "nt", "list", "and", "t", "oss", "client", "gt", "Out", "n", "end", "os", "cn", "to", "up", "io", "op", "sys", "outs", "writer", "by", "g", "log", "con", "co", "sum", "v", "can", "o", "auto", "outer", "aos", "ot", "res"], "bytesRead": ["valuesWrite", "valuesRun", "netsRead", "bytesWrite", "bytesRun", " bytesCount", "termsWrite", "secondsLoad", "valuesRead", "tesRead", "tesWrite", "BytesLength", "secondsRead", "tesNeed", "netsWrite", "valuesNeed", "termsRead", " bytesReader", " bytesLoad", "BytesReader", "bytesNeed", "fieldsCount", "fieldsReader", "fieldsRead", "bytesReader", "bytesLoad", "netsRun", "termsRun", "tesLoad", "secondsNeed", "secondsWrite", "netsNeed", "BytesCount", " bytesLength", "fieldsLength", "bytesCount", "BytesRead", "termsNeed", " bytesNeed", " bytesWrite", "bytesLength"]}}
{"id1": "7087108", "id2": "9236363", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["doget", " handleGET", "invokeSet", " doSet", "doSet", "invokeGET", " doGET", " doget", " handleGet", " handleSet", "doGET", "invokeGet", " handleget", "invokeget"], "request": ["setup", "change", "message", "transform", "the", "http", "store", "each", "QUEST", "input", "query", "url", "application", "open", "address", "select", "subject", "relative", "project", "context", "instance", "first", "core", "reference", "construct", "frame", "quest", "client", "req", "Request", "begin", "info", "handle", "forward", "xml", "initial", "attribute", "document", "command", "version", "requ", "report", "position", "post", "get", "search", "re", "controller", "remove", "worker", " Request", "enter", "complete", "question", "raw", "server", "model", "create", "order", "hello", "index", "local", "reset", "call"], "response": ["reply", "message", "ce", "http", "out", "write", "application", "context", "output", "description", "frame", "success", "onse", "image", "next", "one", "page", "os", "resp", "xml", "default", "result", "view", "respond", "body", "report", "re", "render", "connection", "server", "print", "res", "Response", "status", "respons"], "path": ["dest", "Path", "transform", "th", "check", "template", "value", "full", "title", "where", "prop", "query", "url", "relative", "filename", "output", "select", "project", "pkg", "dir", "config", "string", "test", "PATH", "key", "system", "route", "patch", "p", "uri", "pattern", "text", "ath", "hex", "temp", "log", "chain", "print", "location", "base", "name", "prefix", "mount"], "file": ["library", "user", "check", "full", "binary", "f", "be", "output", "filename", "real", "link", "bo", "lock", "load", "job", "rule", "key", "image", "word", "run", "source", "le", "page", "null", "object", "fe", "table", "ile", "to", "handle", "tree", "document", "result", "bar", "valid", "spec", "console", "bool", "view", "report", "form", "port", "FILE", "e", "ca", "mail", "upload", "disk", "chain", "resource", "model", "base", "name", "db", "channel", "File", "local", "relation"], "in": ["In", "read", "is", "sin", "or", "on", "thin", "out", "input", "it", "rin", "al", "IN", "inn", "and", "reader", "s", "l", "bin", "again", "as", "ins", "one", "source", "inc", "mc", "en", "ic", "up", "copy", "cm", "ind", "kin", "din", "mm", "isin", "cin", "mn", "con", "i", "gin", " din", "ck", "sum", "inner", "asin", "sample", "pic", "ini"]}}
{"id1": "22977189", "id2": "18613870", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"in": ["In", "user", "read", "iter", "is", "init", "ill", "conf", "on", "input", "it", "rin", "r", "ln", "IN", "inn", "reader", "inside", "inf", "bin", "ri", "ar", "ins", "from", "inc", "ze", "ic", "are", "up", "io", "ind", "din", "get", "cin", "con", "i", "gin", "raw", "inner", "ro", "ini"], "out": ["b", "obj", "at", "full", "or", "OUT", "net", "note", "on", "cache", "bit", "it", "all", "write", "output", "tmp", "nt", "list", "rem", "l", "news", "inner", "client", "gt", "Out", "n", "end", "null", "os", "screen", "en", "not", "aos", "cmd", "to", "flush", "io", "sys", "outs", "result", "j", "set", "w", "console", "report", "v", "writer", "conv", "ret", "by", "port", "log", "conn", "con", "chain", "i", "co", "print", "can", "res", "o", "mem", "auto", "outer", "ot", "timeout", "db", "pool"], "line": ["message", "LINE", "block", "header", "match", "iter", "online", "lined", "user", "day", "error", "ln", "file", "inline", "l", "ine", "frame", "string", "eline", "cell", "link", "stroke", "lin", "entry", "character", "key", "rule", "word", "n", "row", "page", "le", "next", "Line", "char", "valid", "sequence", "text", "style", "entity", "ice", "chain", "date", "print", "code", "base", "name", "column", "point", "comment", "lane"]}}
{"id1": "21438069", "id2": "3495460", "code1": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"createNewProjectDeploymentConfig": ["createNewProjectDeploymentConfiguration", "createNewProjectDeploymentsCmd", "createNewProjectDeployationConfig", "createNewProjectDevelopmentCmd", "createNewProjectDevelopingConf", "createNewProjectDeployationConf", "createNewProjectDeployingCmd", "createNewProjectDeploymentCmd", "createNewProjectDeployationCmd", "createNewProjectDeployingConfig", "createNewProjectDevelopmentConfiguration", "createNewProjectDeployingConfiguration", "createNewProjectDeploymentsConfiguration", "createNewProjectDevelopmentConfig", "createNewProjectDevelopmentConf", "createNewProjectDevelopingConfiguration", "createNewProjectDeployationConfiguration", "createNewProjectDeploymentsConfig", "createNewProjectDevelopingConfig", "createNewProjectDeploymentConf", "createNewProjectDevelopingCmd", "createNewProjectDeploymentsConf", "createNewProjectDeployingConf"], "projectID": ["portID", "ProjectName", "ProjectID", "projectId", "projectIC", "appid", "portid", "projectComplete", "projectName", "projectType", "applicationID", "ProjectType", "portId", "ProjectComplete", "appID", "Projectid", " projectIDs", "applicationComplete", " projectIC", "projectIDs", " projectType", "ProjectIC", "applicationIDs", "projectid", "projectED", "ProjectIDs", "appName", " projectid", " projectComplete", "ProjectId", "archiveType", "archiveID", "appId", "portED", " projectName", " projectId", "ProjectED", "archiveIC", "archiveId", " projectED"], "name": ["alias", "item", "value", "format", "title", "number", "id", "search", "type", "info", "address", "filename", "class", "author", "error", "instance", "about", "common", "size", "key", "Name", "word", "term", "image", "source", "n", "family", "label", "to", "version", "initial", "username", "part", "command", "named", "unique", "old", "sequence", "property", "definition", "position", "ame", "parent", "ident", "license", "NAME", "names", "resource", "order", "alpha", "base", "data", "admin", "comment", "prefix", "local"], "description": ["message", "library", "Description", "template", "value", "display", "title", "function", "direction", "type", "des", "edition", "information", "filename", "address", "database", "media", "DES", "termination", "reference", "video", "about", "release", "cription", "summary", "directory", "exclusive", "reason", "word", "environment", "expression", "version", "password", "document", "sequence", "desc", "body", "definition", "position", "escription", "resolution", "usage", "license", "NAME", "question", "metadata", "creation", "language", "response", "comment", "phrase"], "config": ["setup", "oc", "com", "fig", "cert", "conf", "cache", "it", "apache", "tc", "sc", "component", "output", "project", "bc", "rc", "Config", "proc", "etc", "c", "loc", "p", "adj", "ac", "ct", "quit", "def", "control", "cmd", " fig", "acc", "result", "spec", "set", "desc", "ca", "g", "log", "temp", "conn", "con", "cont", "content", "cf", "cur", "np", "admin", "comment", "db", "cfg"], "connection": ["library", "operation", "generation", "channel", "ce", "collection", "Connection", "net", "function", "device", "sql", "application", "open", "subject", "context", "information", "database", "ion", "associated", "session", "reference", "link", "network", "bo", "client", "directory", "entry", "management", "system", "close", "established", "manager", "settings", "initial", "document", "command", "set", "console", "socket", "position", "writer", "engine", "city", "usage", "license", "conn", "con", "condition", "line", "resource", "server", "communication", "location", "pointer", "response", "connect", "db", "relation", "we"], "statement": ["ment", "message", "library", "storage", "template", "function", "Connection", "note", "sql", "application", "subject", "mt", "database", "shell", "session", "reference", "journal", "echo", "stat", "t", "instance", "request", "se", "network", "bo", "trace", "directory", "management", "Statement", "confirmed", "memory", "system", "unit", "processor", "expression", "tree", "document", "command", " Statement", "state", "sequence", "set", "policy", "sp", "status", "writer", "usage", "condition", "chain", "resource", "server", "execute", "response", "comment", "volume", "relation", "phrase"], "resultSet": ["resourceSet", " resultTime", "resS", "ResultSET", "resultEx", "resultS", " resultEx", "eventStream", "specSet", "resourceS", "rowS", "specInfo", "resourceEx", "eventset", "ruleSet", " resultStream", "ResultStream", "ResultEx", " resultInfo", "specSET", "specExport", "answerExport", "rowSET", "resourceset", "resultInfo", "ruleset", "resSet", "eventSet", "Resultset", "resultset", "resultSET", "answerInfo", "ResultTime", "eventTime", "resultStream", "resultExport", "rowset", "answerSET", "rowSet", "ResultSet", "resset", " resultSET", " resultS", "answerSet", "resultTime", " resultset", "ruleSET", "ResultS", " resultExport", "ruleS"], "query": ["message", "script", "check", "init", "qu", "title", "note", "parse", "where", "find", "sql", "search", "update", "select", "request", "join", "ql", "link", "string", "quest", "lock", "send", "sq", "test", "key", "quote", "how", "scope", "q", "menu", "uri", "Query", "unit", "eries", "command", "spec", "sequence", "style", "ERY", "get", "condition", "question", "content", "module", "comment", "sort", "service", "table", "call"], "msg": ["message", "ex", "gs", "title", "mag", "gor", "gm", "sql", "warn", "mu", "gem", "mt", "urg", "err", " message", "pkg", "m", "say", "error", "md", "str", "string", "meg", "html", "nm", "req", "gmail", "reason", "ext", "mess", "bg", "txt", "mor", "ung", "cmd", "og", "dm", "gen", "char", "cmp", "mun", "notice", "ge", "gp", "Msg", "text", "desc", "em", "g", "e", "log", "mail", "bug", "med", "rup", "mn", "gin", "gr", "sum", "print", "mem", "mg", "ms", "sg", "sm", "doc", "cfg"]}}
{"id1": "8917658", "id2": "20128728", "code1": "    public static void copyAll(URL url, Writer out) {\n        Reader in = null;\n        try {\n            in = new InputStreamReader(new BufferedInputStream(url.openStream()));\n            copyAll(in, out);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            close(in);\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"copyAll": ["getAll", "transferAll", "copyFrom", "cloneAll", " copyall", "CopyFrom", "Copyall", " copyMultiple", " copyFrom", "copySome", "copyFiles", "cloneall", "CopyMultiple", "transferall", "CopyAll", "getFiles", " copyFiles", "getSome", "getall", "copyMultiple", "transferFrom", " copySome", "cloneFiles", "cloneSome", "transferMultiple", "copyall"], "url": ["b", "ls", "rect", "dl", "http", "URL", "id", "sql", "address", "file", "l", "ur", "gl", "str", "link", "browser", "job", "web", "html", "nl", "dll", "lb", "uri", "pattern", "char", "xml", "el", "kl", "ret", "log", "Url", "mail", "ssl", "print", "ul", "bel", "base", "name", "ll", "mount", "sl", "un"], "out": ["b", "user", "check", "OUT", "net", "ou", "all", "it", "k", "f", "output", "nt", "file", "list", "t", "oss", "client", "gt", "Out", "n", "end", "to", "io", "outs", "set", "w", "ch", "writer", "g", "log", "gr", "v", "o", "outer", "ot"], "in": ["In", "user", "read", "iter", "is", "or", "on", "input", "rin", "it", "k", "r", "file", "ma", "IN", "m", "inn", "reader", "and", "se", "inf", "bin", "again", "as", "vin", " IN", "ins", "source", "inc", "mc", "from", "p", "serv", "en", "mi", "h", "up", "er", "io", "ind", "old", "body", "qa", "din", "isin", "re", "cin", "conn", "line", "i", "gin", "ck", " din", "sum", "inner", "con", "o", "mr", "ro"]}}
{"id1": "9826240", "id2": "3536332", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"checkHashBack": ["checkhashUp", "checkLockDown", " checkhashUp", "checkhashDown", "checkLockback", "checkClearBack", " checkHashUp", "checkHashDown", "checkhashback", " checkHashDown", "checkLockUp", "checkHashUp", "checkClearUp", "checkLockBack", "checkhashBack", "checkHashback", " checkhashDown", " checkhashBack", "checkClearDown", " checkhashback", "checkClearback", " checkHashback"], "facade": ["facage", "famificate", "latader", "glace", "formificate", "facace", "Facade", "latace", "glage", "Facader", "Facades", "funcace", "Faclegate", " facage", "facades", "latlegate", "funcage", " facaded", "Facificate", "formace", "facificate", "facader", "Facacet", "glade", "funcade", "funcader", "famacet", " facades", "Facage", "formade", "Facaded", "servades", "faclegate", "Facace", "glader", "servage", "famace", "latade", "facaded", "famade", "servade", "facacet", "formacet", "funclegate", "servaded"], "req": ["obj", "aux", "ctx", "needed", "forge", "http", "out", "Resp", "r", "err", "urg", "pkg", "request", "reg", "forced", "Requ", "params", "quest", "rb", "ctr", "queue", "tx", "sq", "proc", "qt", "rpm", "org", "etc", "Request", "qq", "wx", "q", "p", "cmd", "resp", "good", "attr", "rec", "work", "compl", "msg", "require", "uj", "desc", "body", "requ", "e", "wcs", "rh", "jp", "gr", "res", "cur", "qs", "mr", "data", "required"], "txtTransactionID": ["txtOrderKey", "xtTransactionKey", "xtTransactionID", "textTxID", "txtTransactionName", "txtTxId", "txtTxName", "textTransactionId", "textTransactionName", "xtTxID", "textTxId", "xtTransactionId", "txtOrderID", "xtTxName", "txtTXId", "txtTxID", "xtTxId", "txtTransKey", "txtTransId", "xtTxKey", "txtTransID", "textTxName", "txtTXName", "txtOrderName", "txtTransactionKey", "txtOrderId", "xtTransactionName", "txtTXID", "txtTransName", "txtTransactionId", "textTransactionID", "txtTxKey"], "txtOrderTotal": ["xtOrderTotal", "txtOrdComplete", "strOrderComplete", "txtOrdBase", "txtArticleTotal", "txtJobId", "strOrderTotal", "txtTransactionTotal", "txtTradeBase", "strTransactionBase", "txtOrderBase", "strTransactionComplete", "txtArticleInfo", "txtArticleId", "txtOrderComplete", "xtOrdSum", "txtJobTotal", "strTransactionTotal", "txtArticleSum", "txtTransactionComplete", "txtTradeComplete", "txtTransactionBase", "txtOrdSum", "xtOrderInfo", "strOrderBase", "txtOrderSum", "txtOrdInfo", "xtOrdInfo", "txtOrderInfo", "txtJobInfo", "txtOrdId", "xtOrderId", "txtTradeTotal", "txtOrderId", "txtJobSum", "xtOrderSum", "xtOrdTotal", "xtOrdId", "txtOrdTotal"], "txtShopId": ["textStoreid", "txtStreetID", "txtShopAid", "xtSiteid", "textShopById", "txtForgeAid", "xtShopId", "textStoreById", "xtSiteAid", "txtShopID", "txtStoreId", "xtShopID", "txtServerID", "textStoreId", "txtSiteID", "txtForgeid", "txtForgeID", "txtShopById", "txtServerid", "txtStoreById", "txtStreetid", "txtStoreID", "textShopId", "textShopID", "txtServerAid", "txtSiteAid", "txtShopid", "xtSiteID", "txtStreetById", "txtStreetId", "txtSiteById", "txtServerId", "xtShopid", "xtShopAid", "txtSiteId", "textStoreID", "txtStoreid", "textShopid", "txtForgeId", "xtSiteId", "txtSiteid"], "txtArtCurrency": ["txtArticleCourrencies", "txtArtConurrency", "txtArtColategories", "txtArticleCourrency", "txtArticleCocurrency", "txtArtCocurrency", "txtArtConategories", "txtArtCulture", "txtArtCoategories", "txtArtConulture", "txtArtConurrencies", "txtArticleCurrency", "txtArticleCcurrency", "txtArtCurrencies", "txtArtConcurrency", "txtArticleConcurrency", "txtArtCategories", "txtArtCcurrency", "txtArticleCategories", "txtArticleConurrency", "txtArtCoulture", "txtArtColurrency", "txtArticleConategories", "txtArtCourrency", "txtArticleCurrencies", "txtArticleCulture", "txtArtCourrencies", "txtArticleCoulture", "txtArtColcurrency"], "txtHashBack": ["txtRawBack", "textHashBACK", "xtHashFront", "txtHelpBack", "textHashback", "txtLockFront", "txtClearback", "xtStockBack", "txthashBACK", "textHashBack", "txtStockFront", "xtHashBack", "texthashBACK", "txthashBack", "txthashback", "xtStockFront", "txtStockback", "txtHelpFront", "xtStockBACK", "txtLockBACK", "texthashFront", "xtHashBACK", "txtFilterBACK", "textHashFront", "txtRawValue", "txtHashFront", "txtHashBACK", "textHashValue", "txtRawBACK", "txtHelpBACK", "xtStockback", "txtHelpback", "txtLockback", "txtFilterFront", "txthashFront", "txthashValue", "txtHashValue", "txtStockBACK", "txtClearBACK", "texthashBack", "txtFilterBack", "txtRawback", "txtClearBack", "texthashback", "txtStockBack", "txtLockBack", "txtClearFront", "xtHashback", "txtHashback", "txtFilterback", "texthashValue"], "hashSeed": ["hashFeed", "hashSeee", "hashAseed", "hashSliper", "hashSeeeds", " hashSeeds", " hashSee", "hoSeed", "hashSetter", "hashSiper", " hashSeiper", "hashAseder", "hashSourceep", "hashSourceetter", " hashSeeed", " hashSeeeds", "hashFep", "hoAseder", "hashSep", "hoAseed", "hashAsetter", "hoSetter", "hashSee", "hashSleed", "hashAsep", "hoSeder", "hashSleeds", "hashSlee", "hashSeeds", "hashSourceeder", "hashSeiper", " hashSeee", "hashSeeed", "hashSourceeed", " hashSiper", "hashFeder", "hoAsetter", "hoSep", "hoAsep", "hashFetter", "hashSeder"], "securityValue": [" securityVal", " securityValues", "securityVal", "securityData", " securityData", "securityValues", "secValues", "secValue", "secVal", "secData", "SecurityValues", "SecurityData", "SecurityVal", "SecurityValue"], "digest": ["dest", "Digester", " digEST", "Diger", "contests", "digEST", "digester", "dested", "dependested", "equet", "dependest", " diget", " digse", "diggest", "der", "Digests", "digested", "dependester", "diget", "Digest", "diger", "dester", "macgest", "digests", "dse", "macested", "Digse", " diger", "Diggest", "Diget", "dependgest", " digests", "contest", "equse", "contested", "dEST", "equester", "DigEST", "Digested", "macest", "contse", " digester", "equest", "digse", "macester", " digested"], "array": ["range", "collection", "number", "audio", "Array", "binary", "list", "instance", "map", "ash", "ashes", "string", "vector", "record", "our", "iq", "ar", "row", "av", "a", "pair", "object", "share", "arr", "batch", "angle", "area", "archive", "attribute", "bar", "view", "length", "sha", "stage", "arrow", "RAY", "ray", "buffer", "shape", "raw", "export", "max", "v", "now", "rays", " Array", "response", "angular"], "sb": ["orb", "ls", "rub", "rob", "abb", "ib", "gb", "shell", "bf", "sv", "bis", "abs", "rb", "sbm", "obb", "bj", "SB", "cb", "sq", "bps", "sn", "bg", "erb", "lb", "gc", "bs", "obs", "sam", "zb", "soc", "gob", "bh", "eb", "nb", "ctrl", "bb", "bsp", "ssl", "sa", "sf", "stab", "wb", "bt", "esm", "kb", "lp", "ob", "sg", "pb"], "j": ["obj", "ij", "it", "k", "z", "_", "dj", "bj", "jo", "job", "ix", "x", "key", "oj", "n", "jet", "from", "q", "br", "kj", "aj", "jit", "ody", "jj", "ja", "el", "bot", "ind", "json", "uj", "msg", "yy", "jc", "state", "js", "g", "ji", "J", "i", "jp", "gr", "jl", "v", "jump", "att"], "b": ["beta", "BB", "bit", "ba", "k", "bp", "gb", "be", "binary", "ib", "bf", "ab", "bis", "bc", "rb", "cb", "bi", "bg", "br", "h", "bu", "bs", "bound", "bar", "eb", "nb", "bd", "B", "bb", "mb", "fb", "bt", "v", "base", "db"], "hash": ["message", "block", "hz", "check", "header", "value", "format", "title", "flash", "cache", "where", "search", "url", "address", "ash", "ashes", "ASH", "buster", "string", "ah", "oh", "test", "html", "key", "h", "handle", "href", "password", "version", "result", "height", "uh", "json", "sha", "report", "hex", "bh", "crypt", "Hash", "rh", "ssl", "total", "sum", "sample", "response", "data", "tag", "filter"]}}
{"id1": "8000624", "id2": "20735941", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": ["CopyInt", " copiesFrom", " CopyFrom", " CopyInt", "CopyFrom", " copyInt", " copiesTo", " copyFrom", " copyTo", " copiesInt"], "dest": ["path", "th", "rest", "src", "it", "usr", "filename", "output", "tmp", "dir", "Dest", "origin", "cat", "image", "loc", "fn", "source", "null", "txt", "orig", "p", "them", "img", "nom", "opt", "pipe", "copy", "est", "result", "sp", "st", "w", "target", "temp", "cont", "d", "v", "mem", "name"], "in": ["In", "read", "iter", "is", "sin", "init", "net", "on", "thin", "input", "rin", "al", "it", "win", "r", "file", "ain", "IN", "per", "inn", "reader", "m", "t", "l", "inside", "ire", "inf", "bin", "ai", "client", " input", "ir", "ar", "image", "ins", "one", "source", "inc", "from", "en", "ac", "mi", "up", "ind", "din", "isin", "min", "by", "re", "nin", "cin", "con", "i", "gin", " din", "internal", "inner", "o", "login", "local", "ini"], "out": ["b", "obj", "user", "ex", "at", "full", "net", "OUT", "note", "ou", "it", "all", "write", "dis", "output", "oe", "nt", "list", "ln", "t", "cos", "oss", "client", "gt", "boot", "Out", "n", "one", "null", "end", "fn", "os", "en", "not", "cn", "to", "flush", "up", "batch", "io", "ne", "op", "outs", "w", "writer", "conv", "by", "e", "na", "con", "loss", "co", "inner", "v", "aos", "o", "outer", "can", "other", "ot", "res", "ns"], "c": ["cs", "ce", "cd", "conf", "cap", "sc", "k", "f", "z", "cut", "current", "t", "count", "rc", "bc", "l", "cc", "cb", "cl", "character", "cat", "n", "cp", "ac", "u", "ct", "gc", "unc", "arc", "char", "C", "cm", "nc", "cr", "ch", "cod", "uc", "ca", "e", "g", "ec", "con", "i", "cont", "d", "v", "code", "cf", "lc"]}}
{"id1": "14473711", "id2": "20929570", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "label": 1, "substitutes": {"str2md5": ["str_md6", "str_md7", "str2md7", "str_md5", "str2md6", "str2dig5", "str2MD5", "str_mdest", "str2dig7", "str2MDest", "str2sha6", "str2dig6", "str2digest", "str2sha5", "str2sha7", "str2mdest", "str2MD7", "str_MDest", "str2MD6", "str_MD7", "str_MD5", "str2shaest", "str_MD6"], "str": ["b", "obj", "dr", "out", "input", "url", "r", "f", "t", "s", "Str", "string", "ctr", "sts", "c", "n", "rs", "txt", "br", "p", "arr", "in", "char", "tr", "sp", "msg", "cr", "st", "text", "exp", "STR", "ch", "wr", "enc", "hex", "wcs", "piece", "cont", "print", "v", "cur", "res", "data", "name", "vol", "fr", "oct"], "alga": ["alxa", " alxa", "alba", "balga", " algas", "balGa", " Alba", "palha", " calGa", "palba", "agga", "alGa", " calba", "algas", " ala", "balba", "bala", "agxa", " Alga", "agba", "palga", " alba", " AlGa", " alha", "aga", "alha", "palGa", " alGa", "balxa", " calga", " Algas", "ala", "balha", " calgas"], "digesta": [" digella", "digosi", "diveste", "divresso", "digeste", "digested", "divista", "designesta", "designosi", "igesta", "igista", " digosi", "digista", "designeste", "divesta", " digeste", " digista", "designested", "igresso", "digella", "igella", "divested", "digresso", " digresso", "divella", " digested", "divosi"]}}
{"id1": "20190303", "id2": "12034046", "code1": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    private InputStream openRemoteStream(String remoteURL, String pathSuffix) {\n        URL url;\n        InputStream in = null;\n        try {\n            url = new URL(remoteURL + pathSuffix);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            in = connection.getInputStream();\n        } catch (Exception e) {\n        }\n        return in;\n    }\n", "label": 0, "substitutes": {"test01_ok_failed_500_no_logo": ["test01_ok_failed_500_no_og", "test01_ok_failed_500_No_Log", "test01_ok_failed_500_No_log", "test01_ok_failed_500_noTLog", "test01_ok_failed_500_No_lim", "test01_ok_failed_500_no___og", "test01_ok_failed_500_no_lim", "test01_ok_failed_500_no___log", "test01_ok_failed_500_no_Log", "test01_ok_failed_500_no___Log", "test01_ok_failed_500_No_og", "test01_ok_failed_500_noTlim", "test01_ok_failed_500_noTlog", "test01_ok_failed_500_noTog", "test01_ok_failed_500_no_log", "test01_ok_failed_500_no___lim"], "client": ["collection", "template", "cert", "http", "cache", "secure", "tc", "url", "force", "api", "Client", "wrapper", "context", "session", "config", "https", "cell", "google", "cl", "loader", "system", "c", "pool", "window", "close", "cmd", "control", "manager", "cm", "handler", "console", "city", "remote", "conn", "con", "ssl", "connection", "server", "co", "contact", "resource", "cli", "connect", "prefix", "channel", "service", "local", "call"], "post": ["put", "read", "pod", "http", "wp", "parse", "url", "write", "save", "request", "and", "pre", "add", "send", "feed", "Post", "test", "submit", "row", "p", "dd", "copy", "ost", "op", "valid", "mod", "POST", "json", "set", "body", "posts", "form", "upload", "get", "ps", " Post", "create"], "response": ["reply", "message", "user", "block", "value", "http", "info", "application", "output", "description", "network", "feed", "pos", "answer", "onse", "entry", "next", "given", "resp", "tree", "xml", "version", "document", "result", "json", "soc", "respond", "body", "view", "get", "remote", "re", "connection", "server", "res", "sample", "Response", "data", "example", "status", "service", "respons"]}}
{"id1": "5125848", "id2": "7458833", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"combineJs": ["Combinejs", "combinatejs", "combINELink", "CombineJS", "Combosejs", "combinateLink", "combosejs", "ComboseJS", "comboseJS", "combINEJs", "CombineJs", "comboseLink", "combineJS", "combINEJS", "combINEjs", "combinateJs", "ComboseJs", "combineLink", "ComboseLink", "combinejs", "CombineLink", "combinateJS", "comboseJs"], "base": ["b", "template", "id", " based", "address", "api", "relative", "bas", "file", "Base", "root", "absolute", "origin", "domain", "source", "from", " Base", "host", "bottom", "page", " basis", "uri", "bid", " bases", "bound", "site", "re", "ase", "buffer", "server", "based", "start", "data", "prefix", "db", "local", "reset"], "linkJs": ["Linkjs", "LinkTags", "inkLinks", "linkLinks", "linkedScript", "inkJS", "inkjs", "inkScript", "linkjs", "linkedJS", "LinkJs", "linkedJs", "LinkJS", " linkScript", "inkTags", "linkedLinks", " linkTags", " linkjs", "inkJs", "linkJS", " linkJS", "linkTags", "linkScript", " linkLinks"], "newFiles": ["nextFiles", "newDocuments", "linkLinks", " newfiles", "linkDocuments", "nextLinks", "newLinks", "newfiles", "linkfiles", " newLinks", " newDocuments", "nextfiles", "linkFiles", "nextDocuments"], "dir": ["dl", "dep", "dr", "cd", "out", "DIR", "id", "fs", "wd", "tar", "vol", "tmp", "lib", "pkg", "file", "fd", "mk", "zip", "md", "done", "lock", "DB", "directory", "root", "Dir", "ir", "loc", "created", "dd", "def", "good", "manager", "area", "addr", "sys", "div", "mod", "folder", "desc", " Dir", "ref", "temp", "disk", " d", "module", "d", "local", "auto", "rel", "db", "di", "diff", " directory", "doc", "dm"], "name": [" manager", " tmp", " self", " err", " vm", " prefix", " log", " os", " scanner", " browser", " report", " b", " cleaner", " loader", " parser", " dummy", " rebuild", " start", " logger", " names", " karma", " filename", " bar", " info", " msg", " res", " str", " db", " foo"], "minDir": ["smallDir", " minTier", "thinJar", " minPref", " minJar", "smallLoc", "skinDb", "miniTrans", "MinFile", " minTrans", "smallDb", "thinTrans", "minPref", " minFile", "thinDir", "smalldir", " minDar", "minutePref", "smallNet", "sortPref", "minuteRel", "MinNet", "mainDb", "sortDar", "minTrans", "miniTier", "minRel", "minuteDir", "minDar", "sortDir", "minTier", "maindir", "skinLoc", "mainDir", "MinDir", "minuteDar", "minLoc", "sortRel", "thinTier", "smallFile", "minJar", "mindir", "skinDir", "minNet", "mainLoc", "minFile", " minRel", "skindir", "miniDir", "miniJar", " minNet", "minDb"], "combineFile": ["combINESet", "cominateEmail", "coordINESet", "coordINEFile", "combineEmail", "comboiceEmail", "comboseFile", "coordINEWriter", "coordineSet", "comboseWriter", "coordinefile", "combinfile", "comboseSet", "combinatefile", "coordineWriter", "cominatefile", "combinefile", "comineFile", "comboicefile", "combinerMessage", "combinateMessage", "combinateEmail", "combinerFile", "comineEmail", "comineMessage", "cominefile", "combinateFile", "cominateFile", "combinSet", "combinerEmail", "coordineFile", "combINEfile", "combineSet", "combosefile", "combINEWriter", "combinerfile", "coordINEfile", "combinWriter", "cominateMessage", "combineMessage", "comboiceFile", "comboiceMessage", "combINEFile", "combinFile"], "concatFile": ["comcFilename", "convertFilename", "convertTable", "comcatFilename", "concatfile", "comcatFile", "covertFile", "comcatDir", "cocatTable", "cocatfile", "comcDir", "concDir", "concapfile", "conatFiles", "conCatFile", "concapTable", "concatDir", "convertDir", "convertfile", "concatFiles", "covertTable", "concapFiles", "conatFile", "comcFile", "convertFiles", "cocatFile", "conatTable", "concFile", "covertfile", "concatFilename", "convertFile", "covertFiles", "cocatFiles", "conCatFilename", "conatfile", "conCatDir", "concatTable", "concapFile", "concFilename"], "combineWriter": ["combenWriter", "declineReader", "combieFile", "CombineWrite", "combinateReader", "combineCounter", "declinateWrite", "comboseFile", "Combinewriter", "comboseWriter", "combineReader", "combinatewriter", "comboseWrite", "combinateWrite", "combinewriter", "combinateWriter", "combineWrite", "comboseReader", "combieWriter", "declinateReader", "comboseCounter", "ComboseCounter", "combinateCounter", "declinateWriter", "Combosewriter", "declineWriter", "CombineCounter", "combinateFile", "combieReader", "declineWrite", "combieWrite", "combenCounter", "CombineWriter", "ComboseWrite", "combosewriter", "declineFile", "declinateFile", "combenwriter", "combenWrite", "ComboseWriter"], "concatWriter": ["concatWrite", "concatsWrite", "comcatFile", "convertWrite", "coatWrite", "conatWrite", "cocatWrite", "conatReader", "comcatWriter", "concatReader", "coatFile", "comcatReader", "cocatWriter", "conatFile", "concatsFile", "comvertWriter", "comvertReader", "coatWriter", "cocatReader", "cocatFile", "convertReader", "concatsReader", "comcatWrite", "conatWriter", "concatsWriter", "comvertFile", "coatReader", "convertFile", "comvertWrite", "convertWriter"], "fails": ["frils", "fils", "Fails", "mailed", "ifailed", "Failing", "ifailing", "lailing", "frails", " failed", "Failed", "malls", "focks", "lailed", "lails", " failing", "mailing", " falls", "mails", "facocks", "lils", "ifails", "Fils", "falls", "mocks", " focks", "frailed", "facails", "facailed", "frailing", "failed", "facailing", "failing", "lalls", "ifocks"], "link": ["match", "script", "check", "links", "display", "open", "address", "li", "ln", "task", "map", "mark", "ink", "l", "add", "inline", "load", "push", "linked", "self", "c", "follow", "loc", "source", "close", "share", "set", "embed", "Link", "log", "remote", "line", "code", "skip", "node", "relation", "child"], "path": ["alias", "Path", "match", "template", "format", "src", "full", "prop", "id", "input", "relative", "file", "join", "string", "str", "root", "PATH", "key", "entry", "image", "loc", "route", "source", "p", "uri", "pattern", "href", "text", "style", "ref", "ath", "hex", "kind", "resource", "location", "data", "prefix"], "url": ["ls", "http", "URL", "lr", "id", "r", "address", "li", "request", "abs", "l", "ur", "str", "string", "browser", "gl", "web", "html", "nl", "loc", "this", "null", "source", "hl", "host", "uri", "addr", "char", "il", "href", "ref", "get", "mail", "Url", "build", "ssl", "resource", "ul", "location", "rel", "ll", "mount", "sl"], "inputStream": ["inputSet", " inputSteam", "inStream", "InputTime", "InputSet", "instream", "Inputstream", "inputStyle", "inSet", " inputSet", "inTime", "InputStream", "outputStyle", " inputStyle", "inputTime", "outputstream", " inputstream", "outputSteam", "inputSteam", " inputTime", "inputstream", "InputSteam", "InputStyle"], "jsFile": [" jsfile", "jsFilename", "jsTable", "javascriptTable", "cssFilename", "JsFilename", "javascriptFile", "jsfile", "javascriptfile", "cssfile", "jFile", "javascriptPath", "javascriptFilename", " jsName", "cssFile", " jsFilename", " jsTable", "jName", "jPath", "cssTable", "cssPath", "javascriptName", "jsPath", "JsPath", "jsName", "JsFile", "Jsfile", "jFilename", " jsPath"], "fileName": ["getHash", " fileHash", "Filename", "filePath", "getName", "FilePath", "fileHash", "FileName", "getPath", "filename", " filePath", "FileHash", " filename", "getname"], "outputStream": [" outputStyle", "writeStream", "inputForm", "writeSet", " outputSet", "inputStyle", "outputForm", " outputSteam", "OutputSteam", "outputStyle", "OutputSet", "OutputStyle", "OutputStream", "writestream", "outputstream", "writeSteam", "outputSet", "outputSteam", "inputSteam", " outputForm", "inputstream", "Outputstream", " outputstream", "OutputForm"], "first": ["front", "prev", "all", "then", "open", "false", "real", "quick", "current", "same", "second", "natural", "send", "third", "success", "true", "top", "self", "continue", "next", "primary", "First", "sort", "master", "initial", "default", "valid", "unique", "ind", "st", "last", "seconds", "fast", "stack", "must", "only", "start", "fourth", "latest", "now", "each", "index", "important"], "reader": ["read", "driver", "rer", "Reader", "http", "input", "ocr", "r", "wrapper", "context", "file", "core", "rator", "rc", "parser", "loader", "builder", "rar", "stream", "row", "this", "layer", "er", "runner", "rl", "io", "handler", "ner", "rr", "writer", "iterator", "buffer", "resource", "inner", "mr", "data", "ro"], "jsCompressor": ["jscompiler", "jsBuffoser", "jscompressor", "jsReposer", "jsCompiler", "jscompression", "cssComposer", "cssRepression", "jsRepiler", "cssRepressor", "jsRepressor", "jsBuffression", "jsRepression", "cssReposer", "cssRepiler", "cssCompression", "cssCompressor", "jsBuffiler", "cssCompiler", "jsBuffressor", "jsComposer", "jscomposer", "jsCompression"], "s": ["ls", "cs", "gs", "words", "is", "full", "eds", "ts", "ds", "tags", "fs", "ats", "t", "l", "less", "ens", "parts", "ings", "tes", "xs", "details", "os", "ies", "S", "y", "hs", "pers", "ps", "lines", "ss", "ers", "qs", "ids", "ms", "es", "ns"], "s1": ["ps0", "es2", "ys1", "ys0", "ps1", " s81", "s0", "ls3", "s81", "id2", "ls0", "ys3", "s9", "pers0", "es1", "pers1", "id9", " s0", "id1", "idFirst", "ls1", "esFirst", "s3", "ls81", "ys81", " s3", "sFirst", "es9"], "i": ["is", "us", "ati", "id", "it", "ci", "li", "ion", "I", "oi", "ai", "iat", "ri", "bi", "ii", "p", "mi", "ifier", "ic", "io", "y", "im", "ch", "ity", "iu", "ori", "ie", "um", "v", "pi", "o", "iti", "j", "ui", "di", "ig", "ip", "ia"], "s2": ["tesTwo", "gstwo", "S2", "es2", "tes02", "esTwo", "sTwo", "tes2", "ms2", "s22", "SSecond", "z02", "ztwo", "es1", "sSecond", "gsSecond", "ss02", "ss22", "ms02", "s02", "tes1", "Stwo", "msTwo", "S02", "ss2", "zSecond", "gs2", "stwo", "gs02", "ssTwo", "es02", "z2", "ms22"], "i1": ["it0", "i4", "it2", "it1", "it01", "e1", "e2", "a1", "a2", "p01", "o4", "o0", "e4", "i2", "aOne", "itOne", "i01", "oOne", "iOne", "i0", "p4", "pOne", "p2", "o1", "eOne", "p0", "p1", "it4", "a01"]}}
{"id1": "11032546", "id2": "11645260", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"testCopyUnknownSize": [" testCopyDifferentsize", " testCopyKnownShape", " testcopyUnknownSize", " testCopyKnownsize", " testCopyKnownSize", " testCopyunknownLength", " testcopyUnknownShape", " testcopyKnownShape", " testcopyUnknownsize", " testCopyUnknownShape", " testCopyDifferentShape", " testCopyunknownsize", " testcopyKnownLength", " testCopyunknownSize", " testCopyKnownLength", " testCopyUnknownsize", " testcopyKnownsize", " testCopyunknownShape", " testcopyUnknownLength", " testcopyKnownSize", " testCopyUnknownLength", " testCopyDifferentSize", " testCopyDifferentLength"], "in": ["inv", "In", "is", "sin", "on", "input", "it", "rin", "al", "r", "ain", "file", "IN", "inn", "l", "inside", "inf", "bin", "ins", "source", "from", "null", "en", "up", "copy", "ind", "din", "mm", "isin", "log", "cin", "con", "i", "gin", "inner", "data"], "out": ["inv", "b", "user", "ex", "obj", "check", "at", "or", "OUT", "net", "ou", "on", "all", "it", "err", "output", "list", "t", "client", "gt", "Out", "n", "one", "null", "end", "a", "os", " OUT", "cmd", "to", "up", "io", "outs", "result", " Out", "OU", "by", "log", "con", "gr", "co", "sum", "aos", "res", "auto", "o", "data"], "cpySize": ["cdyCount", "Cplysize", "cplyLength", "Cpysize", " cplyCount", " cpysize", "cpeSize", " cpyCount", "cdysize", " cplysize", "cfiLength", "cpesize", "CpyLength", "CplySize", "CplyCount", "cpyCount", "cpeCount", " cplySize", "cpeLength", "cfiSize", "cfisize", "CplyLength", "cpyLength", "CpySize", "cpysize", "cdyLength", "cplysize", "cplyCount", "cfiCount", " cplyLength", "cplySize", " cpyLength", "CpyCount", "cdySize"], "outArray": [" outString", "outStream", "listArea", "inArray", "outString", "listArray", "OUTObject", "OUTarray", " outarray", "outObject", "listImpl", "inString", "outImpl", "nearray", "outarray", "inImpl", "inArea", "listString", " outArea", " outStream", "neArray", "OUTArray", " outObject", " outImpl", "neObject", "outArea", "neStream", "OUTStream"]}}
{"id1": "2834524", "id2": "4599372", "code1": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"write": ["commit", "read", "check", "rite", "update", "save", "download", "file", "apply", "Write", "zip", "add", "link", "println", "append", "lock", " rewrite", "next", "end", "flush", "handle", "dump", " overwrite", "export", "print", "create", "filter", "service"], "jarOut": ["JarIn", "JarStore", "browserout", "browserOut", "pkgIn", "pkgOut", "jamNet", "browserIn", " jarIn", "jarout", "Jarout", "jarIn", "browserOutput", " jarGen", "jarGen", "jamIn", " jarOutput", "javaOut", "jarStore", "pkgNet", "jarOutput", "jarNet", "pkgOver", " jarStore", "JarOutput", "jamOut", " jarout", "JarNet", "jarOver", "javaGen", "javaIn", "JarOver", "javaStore", "javaOutput", "jamOver", "JarGen", "javaout", "JarOut"], "allEntries": ["allENTies", " allentrys", "allEntryrys", "allEnies", " allEntarts", "allEnarts", "allentarts", "allentlections", "allentries", "allEntryies", " allenties", " allEnties", " allEntlections", "allEntrys", "allenties", "allEnties", "allENTries", " allEntrys", "allEnries", "allents", "allEntarts", "allENTlections", "allEntlections", "allEnts", " allEnts", " allents", " allentries", "allentrys", "allEnrys", "allEntryries", "allENTrys"], "iterator": ["inator", "iter", "range", "collection", "creator", "liner", "counter", "iver", "pie", "number", "ski", "immigration", "versions", "tmp", "database", "list", "instance", "reader", "current", "starter", "Iterator", "trace", "walker", "vector", "loader", "size", "builder", "continue", "stream", "next", "ator", "former", "rows", "menu", "internet", "ter", "copy", "issues", "loop", "runner", "sequence", "set", "iner", "river", "writer", "finder", "members", "i", "timer", "pee", "integer", "ippy", "inner", "pointer", "operator", "sample", "outer", "series", "values", "table"], "jar": ["library", "Jar", "pod", "cert", "parse", "gem", "tar", "binary", "war", "be", "class", "lib", "pkg", "file", "dir", "zip", "zone", "jo", "browser", "job", "entry", "bare", "rar", "cp", "batch", "char", "archive", "bag", "jj", "sp", "folder", "json", "tab", "car", "java", "jp", "module", "resource", "cf", "pack", "j", "vol", "magic"], "jarEntries": ["jarentents", "jarEents", "jarEntrys", " jarContries", "JarEntires", "jarEntents", "jarEntrs", "jarMatires", " jarentents", "Jarentrs", "jarEnries", " jarEnties", "JarEntrs", "jarEntires", " jarenties", " jarEntarts", "jarEnrys", "jarMatries", "jarEnents", " jarContrys", "jarentires", " jarContents", "jarIntries", "jarEies", " jarEntents", "jarIntires", "jarEries", "jarAddries", "jarEntities", "jarContities", "jarentarts", "Jarentries", "Jarenties", " jarentries", "jarAddies", "jarEarts", "JarEnties", "jarEnities", "Jarentires", "jarentrs", "jarEntarts", "jarInties", "jarenties", "jarentries", "jarIntrs", "jarMaties", "jarEnties", "jarContents", " jarEntrys", "jarContrys", "JarEntries", " jarContities", "jarContries", "jarMatrs", "jarAddarts", "jarAddents", " jarentarts", " jarEntities"], "o1": ["co1", "a0", "o2", " o10", " o6", "co11", "o5", "e0", "e1", " o5", "e2", "oo10", "ico2", "a1", "a2", "eone", "oa6", "oa11", "icoone", "o11", " o2", " o0", "o0", "oa2", " o512", "oa10", "os2", "o6", "os5", "oo1", " oOne", "co2", "e512", "ico1", "o8", "aOne", " oone", "o10", "os512", "oone", "oa8", "oo8", " o11", "os1", "co6", "oa1", "oOne", "e5", "ico512", "o512", "eOne", " o8"], "entryStream": ["inputStreamer", "resultSteam", " entryPoint", "rowStream", "rowPoint", "EntryStream", "enterStream", "enterForm", "resultPage", "rowSteam", "inputStream", "EntryStreamer", "inputForm", " entryPage", " entrySteam", "entryForm", "enterSteam", "entryPage", "resultPoint", "rowPage", "entrySteam", "enterStreamer", "EntryForm", "resultStream", "entryPoint", "inputSteam", "entryStreamer", "EntrySteam"]}}
{"id1": "7425022", "id2": "22264586", "code1": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"transferWSDL": ["transferWSML", "transferWSDML", "transferWSDDL", "transferSWsdl", "transferSWSDDL", "transferSWSDL", "transferWsdML", "transferWSSL", "transferSWsdDL", "transferWSSDL", "transferSWsdL", "transferSWSDML", "transferSWSDl", "transferWSSML", "transferWsdDL", "transferWsdl", "transferWSDl", "transferWSMl", "transferWSSl", "transferSWsdML", "transferWSMDL", "transferWsdL", "transferWSMML"], "wsdlURL": ["wsdlUrl", "WsdlURL", "wslUrl", "wsdlUR", "wsdUR", "wslURI", "wsqlURL", "awsdlurl", "wsDLUR", "wsdlURI", "wsqlurl", "wslurl", "wsDLUrl", "WsdlUR", "awsdlURL", "WsqlURL", "wsdURL", "WsdlUrl", "wslURL", "WsqlURI", "awsdlUR", "awsdlUrl", "wsDLurl", "WsqlUR", "wsqlUR", "awslUR", "WsqlUrl", "awslURL", "wsDLURL", "wsdlurl", "WsdlURI", "wsdURI", "wslUR", "wsqlUrl", "wsdUrl", "wsqlURI", "awslUrl", "awslurl"], "userPassword": ["userpassword", "usePass", "UserPass", "usernameToken", "usePassword", "clientPassword", "useSecret", "UserToken", "userSecret", "Userpassword", "clientToken", "UserPassword", "userSalt", " userpassword", "usepassword", "UserSalt", " userSalt", "userToken", "userInformation", "usernamePassword", " userToken", "userPass", "usernameSalt", "clientInformation", " userSecret", "UserInformation", "usernamePass", "clientPass", " userPass", "usernameInformation", "UserSecret"], "filePath": ["Filepath", "resourceRef", " fileName", " filepath", " fileRef", "resourcePath", "fileName", "FilePath", "resourceName", "FileRef", "filepath", "fileRef", "resourcepath", "FileName"], "endpoint": ["ndPoint", "adp", "endger", "EndPO", "Endger", "endPO", "ndpoint", " endPO", " endger", "adPoint", "endpoints", "ENDPO", "ENDpoint", "EndPoint", "Endpoint", "ndp", "endp", "adpoint", "ENDger", "ndpoints", "adpoints", " endPoint", "ENDPoint", "Endpoints", "Endp", "endPoint"], "conn": ["obj", "ce", "init", "Conn", "ctx", "cert", "http", "conf", "on", "auth", "url", "open", "comm", "subject", "nt", "pkg", "add", "exec", "ann", "client", "ens", "cb", "org", "proc", "req", "fin", "gn", "loc", "txt", "os", "ait", "gate", "cp", "en", "cn", "ct", "cmd", "resp", "addr", "act", "ell", "canon", "pas", "nc", "attach", "msg", "desc", "ch", "conv", "enc", "dial", "get", "con", "jp", "ssl", "connection", "cont", "nw", "res", "cur", "ws", "connect", "att", "pg", "cfg", "call"], "is": ["nis", "ess", "\u00eds", "gs", "us", "isl", "where", "fs", "info", "ys", "iso", "I", "abs", "IS", "bis", "s", "ist", "isc", " Is", "oss", "lis", "inst", "ri", "ISS", "ists", "does", "ins", "still", "iss", "xs", "os", "rs", "ous", "ris", " are", " seems", "in", "are", "isf", "Is", "bs", "est", "sys", "obs", "icks", "isi", "im", "its", "has", "isin", "ios", "ais", "ress", "serv", "ison", "ice", "i", "sis", "si", "ches", "ism", "isa", "ois", "ish", "iris", "ms", " IS", "es", "ims", "ip"], "isr": ["isw", "itsrc", "owser", "owsp", "isrc", "owsr", "iser", " iser", "isR", "isrt", "isp", "itsR", " isp", "esrt", "issw", "eser", " isrc", "itsr", " isrt", "issrc", " isw", "esr", "issr", "issR", "esp", "itsw", "owsrt", " isR"], "sw": ["sword", "igm", "tw", "sc", "ew", "war", "wn", "ser", "wa", "ow", "sv", "sr", "sem", "wh", "wx", "sn", "rew", "rw", "SW", "rs", "Sw", "hw", "sk", "sh", "sam", "sp", "iw", "she", "nex", "w", "ch", "wr", "sb", "fr", "writer", "aw", "sf", "nw", "amp", "ws", "wo", "sm", "we"], "buf": ["b", "bytes", "uf", "mu", "cap", "fam", "err", "pkg", "col", "bl", "rb", "ctr", "cb", "cat", "nm", "Buffer", "row", "next", "txt", "br", "orig", "cv", "img", "arr", "cp", "box", "good", "batch", "fac", "char", "bag", "bound", "bar", "msg", "seq", "tab", "conv", "bh", "temp", "Buff", "buffer", "wb", "vec", "cf", "cur", "mem", "buff", "cast", "db"], "read": ["iter", "check", "gets", "wait", "input", "Read", "find", "write", "warn", "open", "ok", "give", "tell", "reader", "current", "add", "count", "str", "reads", "load", "send", "need", "before", "size", "word", "run", "n", "end", "stream", "q", "READ", "close", "in", "have", "handle", "len", "char", "tail", "old", "ind", "set", "w", "length", "text", "get", "buffer", "seek", "hold", "print", "cur", "start", "skip", "mem", "readable", "each", "index", "ready"], "outputDir": [" outputLen", "createDir", "coinDest", " outputSp", "writeFile", "writedir", " outputDirectory", "writeDef", " outputDest", " OutputDirectory", "documentdir", "documentDirectory", "outputDef", "inputDir", "coinFile", " outputdir", " OutputSp", "outputLen", "outputdir", " outputDef", "documentSp", "createDest", "outputDirectory", "coinLen", "coinDir", "outputDest", "documentDir", "outputFile", "outputSp", "createLen", " OutputDir", "inputDef", " outputFile", "createFile", "inputFile", "inputdir", "writeDir", " Outputdir"], "file": ["library", "message", "path", "template", "format", "out", "type", "f", "filename", "class", "output", "fp", "task", "tf", "link", "pool", "web", "image", "page", "le", "p", "object", "ile", "to", "handle", "tree", "xml", "work", "el", "spec", "w", "FILE", "con", "resource", "print", "base", "data", "name", "node", "channel", "File", "local", "table"], "fos": [" fjson", "inew", "bops", "bOs", "ojson", "owe", "fwe", " foes", "boes", "Foes", " fops", "fops", "bos", " fOs", "ijson", "onew", "iwe", "foes", " fnew", "FOs", "Fops", "fjson", "fnew", " fwe", "Fos", "fOs"]}}
{"id1": "17583193", "id2": "7103223", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    public void testPost() throws Exception {\n        HttpPost request = new HttpPost(baseUri + \"/echo\");\n        request.setEntity(new StringEntity(\"test\"));\n        HttpResponse response = client.execute(request);\n        assertEquals(200, response.getStatusLine().getStatusCode());\n        assertEquals(\"test\", TestUtil.getResponseAsString(response));\n    }\n", "label": 0, "substitutes": {"populateRecord": ["populatesRecord", " populateData", "populatedrecord", " populatesData", "populateRec", " populatesRecord", "populatesrecord", " populatesrecord", "populaterecord", "popupdaterecord", "populateData", " populateRec", "popupdateRecord", "populatedRecord", "popupdateRec", "popupdateData", " populaterecord", "populatedRec", "populatesRec", "populatedData", " populatesRec", "populatesData"], "attrIDs": ["sortID", "attributeIDs", "arrids", "immIDS", "rmIDS", "attById", "attIDS", "adjUES", "errUES", "attFiles", "rmById", "aaaIDS", "attrIDS", "addrIDS", "aaaENTS", "attributeids", "attrID", "addrUES", "permID", "attrFS", "sortids", "immID", "urgLS", "attFS", "sortFiles", "attrEMS", "filterIDS", "attID", "adjIDS", "errIDS", "attributeEMS", "attributeID", "immEMS", "immIDs", "arrIDs", "attEMS", "attributeIDS", "urgENTS", "sortIDS", "urgIDS", "attributeFS", "permFS", "errIDs", "cmpIDS", "arrIDS", "permIDS", "filterKids", "attrLS", "attributeById", "permIDs", "cmpIDs", "addrKids", "attrById", "filterIDs", "adjIDs", "attributeFiles", "addrIDs", "attributeKids", "sortKids", "attrKids", "attrUES", "aaaIDs", "arrKids", "aaaLS", "rmIDs", "urgIDs", "attrENTS", "rmID", "attrFiles", "addrids", "attributeLS", "attIDs", "attributeENTS", "attrids", "filterids"], "i": ["my", "xi", "info", "f", "err", "I", "any", "ai", "ix", "iq", "hi", "ri", "p", "mi", "u", "phi", "iu", "e", "v", "ei", "o", "name", "status", "ip", "ij", "is", "init", "z", "ki", "c", "x", "ii", "multi", "ic", "in", "sim", "chain", "zi", "iti", "ti", "ui", "ini", "iter", "qi", "\u0438", "ci", "li", "wi", "m", "list", "ir", "n", "io", "ind", "im", "ie", "g", "print", "base", "cli", "index", "di", "ims", "ia", "ami", "ni", "us", "gi", "it", "l", "ik", "bi", "q", "uri", "h", "er", "eu", "y", "ity", "ori", "parent", "ji", "me", "si", "d", "pi"], "sortIDs": ["sortID", "syncBytes", "successEMS", "sortTags", "orderIDs", "ortBS", "servEMS", "relationIDS", "altIDs", " sortensions", " sortIDES", "orderDOS", "ordIDS", "ortVs", " sortKids", "successDOS", "ortBs", "relationMembers", "shareUES", "servKids", "sortMS", "sortBS", " sortID", "successUES", "attrIDS", "sortMembers", "attrID", "sortDocuments", " sortBs", "sortids", "SortLS", "shareKids", "sortFiles", "attrEMS", "filterIDS", "sortEMS", "saveLS", " sortTags", "ordids", "relationensions", "saveIDES", "relationIDs", "sortDetails", "ortids", "filterDocuments", "SortMembers", " sortFiles", "ortIDs", "orderKids", "parseIDs", "SortEMS", "updateIDs", "sortIE", "SortIE", "updateIDS", "SortIDs", " sortDocuments", "successIDs", "altKids", " sortBS", "sortensions", "servids", " sortVs", "sortDOS", "servMembers", "servResults", " sortMS", " sortMembers", "ortID", "syncIDs", "altIDS", "syncIDS", "sortIDS", "servIDs", "sortBs", "ortIDS", "saveIE", "saveResults", "successIDS", "ortResults", "parseIDES", "successKids", "saveKids", "filterKids", "attrLS", "attrIE", "sortUES", "servBS", "updateEMS", "ortDocuments", "successTags", "sortBytes", "filterIDES", "ortDetails", "ordEMS", "altIDES", "servDetails", "filterIDs", "servensions", "filterBs", "servIDS", "saveMS", " sortids", "ordIDs", "altEMS", "sortKids", "attrMS", "shareDOS", "SortIDS", "saveIDs", "saveIDS", " sortDetails", "servVs", "servTags", "syncEMS", "attrKids", " sortIDS", "orderUES", "servFiles", "servID", "attrFiles", "altBytes", "sortVs", "parseKids", "sortIDES", "successIDES", "sortResults", "sortLS", "parseIDS", " sortBytes", "updateMembers", "shareIDs", "attrids", " sortEMS", " sortResults"], "j": ["b", "obj", "ij", "pt", "beta", "out", "jac", "it", "k", "r", "err", "z", "m", "dj", "l", "bo", "bj", "ix", "jo", "job", "pr", "c", "x", "oj", "n", "next", "jet", "q", "br", "adj", "kj", "aj", "jit", "er", "jj", "ja", "el", "tr", "y", "json", "uj", "ind", "jc", "js", "g", "e", "by", "ji", "J", "je", "jp", "jl", "d", "v", "other", "rel", "jump", "fr"], "temp": ["tm", "read", "template", "ptr", "tt", "perm", "thread", "wait", " tmp", "tc", "Temp", " Temp", "tmp", "tem", "mp", "rem", "current", "pre", "t", "cum", "fake", "test", "term", "alt", "txt", "EMP", "orig", "prime", "tim", "mod", "unt", "set", "length", "buffer", "porary", "mem", "tty", "emp", "variable"]}}
{"id1": "23666973", "id2": "20991673", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["loadStreamSimple", "openResourceSimple", "loadStreamRaw", "openSteamRAW", "openFileRaw", "openSteamRaw", "openSteamInternal", "loadSteamInternal", "openResourceRaw", "openResourceRAW", "openStreamInternal", "loadSteamRaw", "openSteamSimple", "openStreamRAW", "loadSteamSimple", "loadSteamRAW", "openResourceInternal", "openFileSimple", "loadStreamInternal", "openFileRAW", "openFileInternal", "openStreamSimple", "loadStreamRAW"], "filename": ["message", "path", "ren", "bol", "src", "title", "sql", "download", "f", "ename", "subject", "file", "fp", "description", "bf", "journal", "mson", "reference", "Filename", "string", "original", "directory", "LCS", "nm", "word", "til", "fn", "missing", "txt", "source", "png", "jpg", "uri", "lua", "nil", "username", "document", "initial", "fil", "sequence", "length", "mpeg", "river", "ame", "wikipedia", "kl", "upload", "FILE", "java", "metadata", "stem", "location", "name", "prefix", "whatever", "println"], "stream": ["transform", "draw", "where", "find", "then", "file", "feed", "test", "next", "source", "still", "set", "body", "socket", "port", "engine", "stack", "get", "upload", "temp", "log", "history", "resource", "sw", "response", "status", "filter", "pod", "collection", "input", "open", "wrapper", "context", "zip", "trace", "proc", "window", "row", "pipe", "valid", "result", "conv", "chain", "shape", "cont", "sample", "ream", "local", "pool", "table", "Stream", "message", "read", "iter", "check", "rest", "clean", "list", "instance", "link", "load", "peer", "loop", "console", "length", "iterator", "buffer", "ssl", "export", "poll", "mount", "channel", "sl", "http", "store", "download", "output", "sync", "present", " Stream", "reader", "head", "back", "dd", "control", "old", "view", "form", "impl", "parent", "event", "content"], "url": ["ls", "b", "external", "path", "dl", "http", "URL", "lr", "r", "pkg", "file", "l", "ur", "gl", "link", "fl", "browser", "str", "job", "web", "nl", "loc", "hl", "mount", "uri", "char", "rl", "cal", "kl", "impl", "mail", "Url", "build", "mb", "ssl", "resource", "ul", "bel", "rel", "ll", "pl", "sl", "call"], "cl": ["Cl", "dl", "com", "ctx", "tc", "sc", "comm", "class", "fc", "gl", "fl", "load", "cc", "loader", "ocl", "c", "dll", "acl", "hl", "CL", "ct", "decl", "rl", "cm", "sh", "el", "cr", "scl", "lf", "cle", "kl", "impl", "log", "ctrl", "ssl", "ck", "cf", "lp", "ll", "pl", "lc"], "cn": ["css", "ern", "nn", "san", "cap", "yn", "wn", "hn", "bean", "unn", "ocon", "csv", "CN", "uan", "cdn", "gn", "arn", "nic", "tn", "fn", "tun", "atten", "pn", "cv", "gc", "rn", "ct", "unc", "nan", "dn", "cm", "nc", "tan", "jc", "non", "sen", "aren", "pan", "bn", "cin", "mn", "conn", "oul", "can", "cf", "CNN", "avan", "crow", "enn", "ns", "osen"]}}
{"id1": "19747399", "id2": "7764011", "code1": "    @Before\n    public void setUp() throws Exception {\n        connectionDigestHandler = new ConnectionDigestHandlerDefaultImpl();\n        URL url = null;\n        try {\n            url = new URL(\"http://dev2dev.bea.com.cn/bbs/servlet/D2DServlet/download/64104-35000-204984-2890/webwork2guide.pdf\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n        try {\n            uc = url.openConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "label": 0, "substitutes": {"setUp": ["setup", "setUP", " setup", "settingUP", "settingUp", "settingDown", "startUp", "startUP", " setDown", "setDown", "startDown", "startup", "settingup", " setUP"], "connectionDigestHandler": ["connectionDigestsHandler", "connectionSequestingHandler", "connectionDigestingReader", "connectionDigestedHandler", "connectionDigestsFilter", "connectionDigestsManager", "connectionSequestingManager", "connectionSequestManager", "connectionDigestedFilter", "connectionDigestingHandler", "connectionDigestingManager", "connectionSequestingFilter", "connectionSequestHandler", "connectionDigestFilter", "connectionSequestingReader", "connectionDigestedManager", "connectionDigestedReader", "connectionSequestFilter", "connectionDigestReader", "connectionDigestingFilter", "connectionDigestsReader", "connectionDigestManager", "connectionSequestReader"], "url": ["b", "obj", "ls", "path", "dl", "cert", "http", "URL", "out", "lr", "id", "open", "address", "context", "r", "db", "file", "config", "l", "ur", "link", "gl", "https", "str", "browser", "loader", "web", "html", "nl", "loc", "null", "page", "host", "p", "u", "github", "il", "xml", "result", "el", "ret", "impl", "mail", "Url", "ml", "pl", "conn", "ssl", "resource", "location", "base", "bel", "name", "rel", "ll", "mount", "ob", "sl"], "uc": ["ucc", "oc", "uu", "tc", "sc", "ocr", "rc", "orc", "cl", "ocl", "c", "dc", "cas", "mc", "os", "cp", "ac", "gc", "u", "unc", "nc", "UC", "access", "ec", "con", "ssl", "res", "lc"]}}
{"id1": "21979717", "id2": "20939940", "code1": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"upload": [" go", "save", " confirm", " restore", " commit", " sort", " load", " login", " input", "submit", " update", " delete", " reload", " work", " insert", " install", " change", " press", "ction", " dump", " dispose", " move", " paste", " file", "execute", " store", " take"], "fileResult": ["FILEStatus", "fileRequest", "FileResults", "FILEReturn", "reportResult", "reportRequest", "fileStatus", "fileResults", "reportStatus", "FileResult", "fileReturn", "FILEResult", " fileStatus", " fileReturn", "FileReturn", "reportResults", "FileStatus", "FILEResults", " fileResults", "FileRequest", " fileRequest"], "in": ["In", "is", "init", "on", "input", "rin", "it", "win", "r", "file", "IN", "inn", "l", "inside", "inf", "bin", "lock", " IN", "ins", "n", "inc", "from", "p", "en", "up", "io", "ind", "st", "body", "din", "isin", "get", "cin", "conn", "i", "gin", " din", "inner", "doc", "un"], "url": ["ls", "dl", "net", "http", "URL", "r", "open", "f", "file", "abs", "l", "ur", "gl", "str", "https", "browser", "client", "web", "nl", "arl", "gc", "char", "xml", "www", "console", "ref", "conv", "get", "log", "Url", "conn", "ssl", "ul", "bel", "atl", "name", "ll", "pl", "channel", "sl"], "con": ["com", "Conn", "cert", "http", "conf", "ver", "coin", "open", "comm", "func", "ion", "ln", "ain", "Con", "bean", "fc", "cond", "pc", "cos", "col", "pos", "client", "cl", "cat", "c", "gate", "cp", "en", "cn", "cmd", "don", "canon", "fac", "act", "cm", "soc", "const", "cal", "CON", "conv", "dial", "re", "sub", "ctrl", "conn", "connection", "cont", "co", "ran", "pen", "cons", "cf", "cur", "can", "syn", "create", "connect", "un", "call"], "out": ["b", "obj", "ex", "at", "or", "OUT", "net", "ou", "conf", "output", "ion", "t", "cos", "oss", "pos", "client", "Out", "n", "this", "null", "os", "en", "to", "io", "ne", "sys", "outs", "w", "conv", "OU", "po", "conn", "i", "co", "sum", "aos", "can", "o", "auto", "outer", "vol", "un"], "in2": ["IN2", "IN3", "inner3", "din2", "inner02", "out1", "win1", "out02", "out4", "out2", "inner2", "out3", "in1", "IN02", " in1", "din1", "in4", "win2", "din4", "inner1", "IN1", "in3", " in3", "win3", " in4", "in02"], "buf": ["bytes", "block", "uf", "cap", "tmp", "cfg", "pkg", "rb", "str", "queue", "cb", "cat", "Buffer", "br", "orig", "cv", "img", "arr", "cp", "cmd", "box", "batch", "bag", "bar", "cam", "seq", "tab", "conv", "fg", "aka", "Buff", "log", "buffer", "vec", "emb", "cf", "cur", "mem", "buff", "data", "db", "var", "pb"], "bytesRead": ["secondsread", "tesCount", "bytesWrite", "bytesRun", " bytesCount", "BytesWritten", "tesWrite", "cellsRun", "secondsRead", " bytesread", "rowsread", " bytesRun", " bytesLoad", "bytesNeed", "rowsLoad", "tesWritten", "bytesLoad", "cellsLoad", " bytesWrite", "rowsRun", "rowsNeed", "rowsRead", "rowsWrite", "secondsNeed", "secondsWrite", " bytesWritten", "BytesCount", "bytesCount", "bytesread", "BytesRead", "cellsWrite", "cellsRead", " bytesNeed", "bytesWritten", "BytesWrite", "tesRead"]}}
{"id1": "16572931", "id2": "8625346", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"unJar": ["UnJar", "removeJar", "unPath", "UnExt", "removeExt", " unExt", "UnPath", "removeZip", "removePath", "unExt", "unZip", " unZip", " unPath", "UnZip"], "jarPath": ["javaPath", "jarUrl", " jarFile", "bareName", "jarpath", "browserUrl", "jarName", "javaBase", "carpath", "jobPath", "javapath", "javaFull", "jarBase", "browserName", "browserpath", "javaLocation", " jarInfo", "reportpath", " jarUrl", " jarHome", "jarLocation", "browserInfo", "bareFull", "jobpath", "bareHost", "carBase", "jName", " jarName", "browserHome", "relHome", "jFull", "jPath", "jarFile", " jarLocation", "relInfo", "javaUrl", " jarBase", "jarHome", "pkgInfo", "javaName", "barePath", "jarHost", "pkgpath", "reportPath", "javaHost", "jarInfo", "pkgName", " jarpath", "browserPath", "carPath", "javaFile", "reportName", "carName", "relpath", "reportUrl", "jHost", "jobFile", "jobLocation", "pkgPath", "javaInfo", "jarFull"], "jarEntry": ["sessionentry", "jitEntry", "jitEnter", " jarEnter", "reportEntry", "jobPost", "certEntry", "sessionEntry", "javaPost", "jItem", "jarName", "certentry", "reportEnt", "sessionName", "certName", "browserentry", "springentry", "browserPost", "browserEnter", "jentry", "javaItem", "browserName", "springItem", " jarInfo", "JarPost", "certEnt", "reportPost", "browserInfo", "jarPost", "jarEnt", "jitInfo", "JarEntry", " jarentry", "jobEntry", " jarName", " jarEnt", "jarEnter", "springEntry", "javaEntry", "jEntry", "sessionEnt", "JarEnt", "javaentry", "browserEntry", "jobEnt", "jarentry", "browserEnt", "jarInfo", "jarItem", "javaEnt", "Jarentry", "reportentry", "jitEnt", "jEnt", "springEnt"], "path": ["transform", "full", "title", "where", "distance", "file", "dir", "test", "PATH", "loc", "host", "p", "method", "set", "text", "room", "phi", "port", "log", "temp", "history", "name", "Path", "value", "format", "input", "id", "url", "home", "select", "context", "walk", "join", "zip", "trace", "self", "x", "key", "right", "pattern", "ref", "ath", "hex", "point", "order", "message", "check", "empty", "at", "with", "api", "core", "here", "string", "this", "tree", "folder", "print", "location", "base", "data", "mount", "index", "template", "it", "address", "relative", "output", "pkg", "left", "client", "root", "route", "near", "cmd", "to", "position", "min", "parent", "module", "partial", "pi", "prefix"], "relPath": ["elEntry", " relName", " relText", "Relpath", " relEntry", "RELName", "relName", "RelPath", "RelName", "relPort", " relPort", " relpath", "RelEntry", "RELPort", "elName", "relText", "RelPort", "RELPath", "RELText", "elPath", "elpath", "RelText", "relEntry", "relpath"], "jar": ["Jar", "cert", "zo", "war", "tar", "be", "lib", "pkg", "star", "zip", "se", "ctr", "jo", "job", "ar", "bare", "rar", "jet", "le", "cp", "comp", "good", "jit", "og", "batch", "archive", "bag", "jj", "ja", "bar", "sp", "jc", "tab", "ie", "deb", "sea", "car", "java", "jp", "pack", "j", "vol"], "ze": ["zing", "ce", "zo", "zie", "be", "za", "z", "oe", "zip", "sle", "se", "jo", "ae", "zed", "le", "ve", "pe", "ene", "sk", "cz", "ea", "ne", "ge", "aze", "enz", "she", "te", "zy", "ie", "je", "e", "ez", "ZE", "so", "ke", "Ze", "zi", "zes", "zer", "ee", "sl"], "bin": ["b", "pin", "sin", "obin", "thin", "win", "binary", "lib", "ln", "bl", "abin", "bian", "fin", "bi", "dll", " Bin", "bg", "jin", "png", "ic", "in", "bu", "box", "sam", "ebin", "kin", "din", "pan", "cin", "con", "gin", "spin", "skin", "pic", "buff", "bed", "bm", "db", "di", "bat"]}}
{"id1": "1769771", "id2": "11933797", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " CopyFiles", " CopyFile", "CopyFile", "CopyStream", " copyLine", "copyLine", "CopyFiles", " CopyLine", " copyStream", " copyFiles", " CopyStream", "copyStream", "CopyLine"], "in": ["b", "In", "is", "init", "on", "input", "rin", "r", "IN", "inn", "l", "inf", "bin", " input", "ins", "source", "inc", "from", "en", "ic", "up", "io", "el", "ind", "old", "din", "mm", "isin", "cin", "i", "gin", "inner", "ini"], "out": ["b", "ex", "at", "OUT", "net", "ou", "it", "update", "err", "output", "nt", "file", "t", "help", "l", "s", "gt", "c", "Out", "n", "os", "p", "to", "up", "io", "op", "outs", "msg", "w", "po", "log", "serv", "v", "res", "o", "ot"], "inChannel": ["outchannel", "sinButton", " inRoom", " inchannel", "insideCategory", "intChannel", " inClient", " inCategory", "dinchannel", " inScope", "insideScope", " inCase", "dinConnection", "inConnection", "cinCommand", "inScope", "insideChannel", "innCase", " inChan", "outConnection", "ainCategory", " inConnection", "sinRoom", "inCategory", "innClient", "innButton", " inButton", "Inchannel", "inCase", "inClient", "inButton", "inCommand", "inRoom", "innChannel", "intchannel", "sinCase", "sinChannel", "ainScope", "insideClient", "sinClient", "cinChannel", "ainClient", "ainChannel", "intCommand", "intChan", "sinCommand", "inchannel", "inChan", "InChan", "dinChannel", "InCommand", "cinRoom", "outChan", " inCommand", "InChannel", "dinChan"], "outChannel": ["outchannel", "outputCh", "cnChan", "aosMember", "blockChan", " outChan", " outMany", "blockGate", "aosChannel", "neChan", "inCh", "outputchannel", "neChannel", "neSection", " outManager", " outCh", "outMember", "parentGate", " outchannel", " outGate", "parentChan", "aosSection", "blockChannel", "parentMany", "outputChan", "cnChannel", "outSection", "blockMany", "aosChan", "outMany", "outputManager", "outputChannel", "inMember", "parentChannel", "outCh", "neMember", "outManager", "outGate", "inchannel", "inChan", "inSection", "cnManager", "outChan"]}}
{"id1": "12197169", "id2": "11562173", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 0, "substitutes": {"read": ["init", " recover", " Read", "Read", "find", "download", "open", "reader", " request", "load", " reopen", "record", "stream", "next", "run", "close", " reads", "gc", " replay", " reader", "reading", "log", " download", "start", "connect", " seek", " ingest", "hello", " retrieve"], "in": ["In", "when", "message", "check", "is", "at", "or", "ill", "on", "conf", "out", "ing", "input", "it", "all", "url", "info", "r", "f", "with", "update", "al", "file", "IN", "inn", "reader", "and", "add", "l", "inf", "bin", "record", "again", "entry", "as", "stream", "ins", "run", "source", "from", "inc", "er", "io", "via", "body", "din", "isin", "by", "get", "log", "re", "cin", "con", " din", "inner", "during", "o", "name", "index", "ro"], "line": ["message", "path", "block", "liner", "LINE", "lo", "url", "file", "ln", "stroke", "l", "ine", "frame", "link", "eline", "cell", "string", "record", "inline", "se", "lin", "entry", "word", "stream", "row", "detail", "page", "le", "Line", "char", "part", "sequence", "text", "body", "e", "log", "chain", "piece", "code", "sample", "data", "comment", "point", "lane"], "i": ["iter", "is", "id", "qi", "xi", "ci", "li", "f", "z", "I", "m", "t", "l", "oi", "ai", "ix", "hi", "x", "bi", "c", "ii", "n", "p", "mi", "multi", "u", "to", "index", "y", "sequence", "ind", "im", "phi", "conv", "sim", "ori", "me", "si", "d", "zi", "ei", "pi", "base", "o", "ti", "cli", "v", "j", "di"], "logDatum": ["logDummy", "logBump", "Logdatum", "logdum", " logBummy", "logdata", "logDoictionary", "LogDatum", "logRump", " logDummy", "logBictionary", "logBummy", "logTratum", "logdatum", "logBatum", "logRummy", "logRictionary", "logTrummy", "logTrum", "logDoummy", "LogDummy", "logDump", "LogData", "logDoatum", "Logdummy", "logDum", "logDoump", "logDictionary", " logBictionary", "Logdum", " logBump", " logBatum", " logDictionary", "LogDum", "Logdata", " logDump", "logRatum", "logdummy", "logData", "logTrata"]}}
{"id1": "23398710", "id2": "20306677", "code1": "    public String getUser() {\n        try {\n            HttpGet get = new HttpGet(\"http://api.linkedin.com/v1/people/~\");\n            consumer.sign(get);\n            HttpClient client = new DefaultHttpClient();\n            HttpResponse response = client.execute(get);\n            if (response != null) {\n                int statusCode = response.getStatusLine().getStatusCode();\n                if (statusCode != 200) {\n                    this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n                }\n                StringBuffer sBuf = new StringBuffer();\n                String linea;\n                BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), \"UTF-8\"));\n                while ((linea = reader.readLine()) != null) {\n                    sBuf.append(linea);\n                }\n                reader.close();\n                response.getEntity().consumeContent();\n                get.abort();\n                String salida = sBuf.toString();\n                String user_firstname = salida.split(\"</first-name>\")[0].split(\"<first-name>\")[1];\n                String user_lastname = salida.split(\"</last-name>\")[0].split(\"<last-name>\")[1];\n                return user_firstname + \" \" + user_lastname;\n            }\n        } catch (UnsupportedEncodingException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (IOException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthMessageSignerException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthExpectationFailedException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthCommunicationException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        }\n        return null;\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"getUser": ["createuser", "setuser", "getAccount", " getAccount", "createUser", " getNick", " getuser", "getNick", "createNick", "getuser", "setNick", "createAccount", "setUser", "setAccount"], "get": ["message", "put", "read", "pull", "check", "getting", "gets", "http", "parse", "cache", "find", "query", "url", "gm", "open", "download", "force", "give", "request", "Get", "pre", "exec", "send", "self", "this", "q", "uri", "handle", "github", "util", "ge", "set", "body", "show", "post", "delete", "g", "build", "remote", "entity", "e", "GET", "connection", "resource", "print", "got", "start", "create", "play", "service", "call"], "client": ["collection", "net", "http", "cache", "secure", "tc", "query", "ip", "api", "Client", "context", "wrapper", "request", "network", "https", "google", "cl", "c", "this", "control", "io", "cm", "console", "city", "remote", "con", "conn", "connection", "server", "co", "contact", "resource", "create", "cli", "connect", "service", "call"], "response": ["reply", "message", "channel", "ce", "block", "collection", "function", "value", "http", "cache", "application", "open", "wrapper", "output", "description", "request", "session", "send", "network", "trace", "pos", "success", "entry", "onse", "answer", "window", "image", "next", "one", "still", "given", "page", "source", "close", "exit", "successful", "ve", "resp", "service", "xml", "version", "document", "result", "site", "json", "respond", "body", "report", "see", "remote", "e", "connection", "event", "server", "yes", "res", "example", "Response", "data", "status", "es", "reset"], "statusCode": [" statusLength", " statusLine", "statuscode", "messageCode", "magicCode", "StatusLength", "StatusCode", " statuscode", "magiccode", "statusName", "StatusTree", "postLine", " statusTree", "StatusCount", " statusName", " statusCount", "statusLength", "statusLine", "postName", "messageTree", "statusTree", "messageLength", "magicLine", "postcode", "postCode", "statusCount", "messageCount", "magicName"], "sBuf": ["sOBuf", "sBlfg", " sBbuf", "sOBbuf", "sABbuff", " sBdf", "sBdf", " sOBbuff", " sOBob", "sBbuff", " sOBdf", "sBbuf", "sBluf", "sBuffbuf", "sOBdf", "sBufffg", "sBuffuf", " sBob", "sABbuf", "sBfg", "sABuf", "sBuffbuff", "sBlbuf", "sOBbuff", "sABob", " sOBuf", " sBbuff", "sOBob", "sBuffdf", " sOBbuf", "sBob", " sBfg"], "linea": ["inea", "linkea", " lineA", "lineas", " linee", "linee", "linke", " LINEA", "linealpha", "LineA", "lina", "ineea", " lineea", "ineae", "linkA", "lineea", "linja", " LINEalpha", "linae", "lineja", " LINEea", "linas", " LINEa", "linA", "linka", "Lineea", "Linealpha", " linealpha", "Linea", "linkae", " lineas", "line", "ineja", "linkas", "lineae", "lineA", "linkja"], "reader": ["read", "iter", "driver", "collection", "Reader", "input", "then", "r", "wrapper", "older", "file", "per", "ser", "rx", "parser", "loader", "entry", "roller", "builder", "image", "stream", "row", "rar", "source", "dd", "handle", "er", "rl", "runner", "upper", "handler", "field", "ner", "body", "writer", "reading", "iterator", "buffer", "resource", "inner", "data", "ro"], "salida": ["slista", "altido", "slanca", "alista", "Salanca", "saliga", "Salardo", " salido", "talardo", "talaria", "slido", "salaria", "talida", " saliga", "salido", "alida", "taliga", "altida", "sqlida", "Salida", "alanca", "altanca", "salardo", "talanca", "sqlanca", "altista", "slida", " salaria", "salanca", "sqlardo", "Saliga", "sqlido", "salista", "alido", "Salaria", "talido", "Salido"], "user_firstname": ["user_mostn", "user_fullname", "user_firstn", "user_Firstuser", "user_mostame", "user_fullame", "user_mostname", "user__lastame", "user_firstuser", "user_lastmin", "user_fullmin", "user_fulln", "user_lastuser", "user_lastno", "user_Firstname", "user_lastame", "user__firstno", "user_firstmin", "user_fulluser", "user__lastno", "user__lastname", "user_Firstame", "user__firstame", "user_fullno", "user_Firstmin", "user_firstame", "user_lastn", "user__lastn", "user_firstno", "user__firstname", "user__firstn", "user_mostno"], "user_lastname": ["user_secondName", "user_lastName", "user_longame", "user_fullname", "user_fullName", "user_fullame", "user_lastnames", "user_firstnames", "user_longno", "user_lastno", "user_lastame", "user_firstName", "user_longname", "user_secondname", "user_secondno", "user_longnames", "user_fullno", "user_firstame", "user_longName", "user_fullnames", "user_secondame"]}}
{"id1": "10266116", "id2": "5989666", "code1": "    public InputStream retrieveStream(String url) {\n        HttpGet getRequest = new HttpGet(url);\n        try {\n            HttpResponse getResponse = getClient().execute(getRequest);\n            final int statusCode = getResponse.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n                Log.w(getClass().getSimpleName(), \"Error \" + statusCode + \" for URL \" + url);\n                return null;\n            }\n            HttpEntity getResponseEntity = getResponse.getEntity();\n            return getResponseEntity.getContent();\n        } catch (Exception e) {\n            getRequest.abort();\n            Log.w(getClass().getSimpleName(), \"Error for URL \" + url, e);\n        }\n        return null;\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"retrieveStream": ["retetchSteam", " RetrievedSteam", "retireForm", "retrievedSteam", " RetrieveForm", " RetrieveFile", "retrieveForm", " RetrievedStream", "retetchFile", "retireFile", "retrievedStream", "retrievedFile", "retetchStream", "retireSteam", "retrievedForm", "retireStream", "retetchForm", "retrieveFile", " RetrieveSteam", " RetrievedFile", " RetrievedForm", "retrieveSteam", " RetrieveStream"], "url": ["ls", "path", "dl", "full", "http", "URL", "id", "address", "err", "file", "request", "l", "ur", "string", "str", "https", "load", "job", "web", "html", "term", "domain", "page", "q", "host", "hl", "uri", "cmd", "addr", "pattern", "util", "href", "xml", "ref", "impl", "remote", "Url", "pl", "log", "ssl", "resource", "server", "ul", "location", "base", "name", "ll", "rel", "mount", "channel"], "getRequest": ["giveMessage", " getCommand", " getMethod", " getAttempt", "getMethod", "createResponse", "makeRequest", "getAttempt", "createRequest", "getCommand", "giveRequest", "findCustomer", "giveCommand", "httprequest", "createMethod", "getQuery", "getMessage", "makeCustomer", "getrequest", "getCustomer", "createrequest", "httpResponse", " getCustomer", "GetMessage", "makeResponse", " getMessage", "GetRequest", " getQuery", "GetCommand", "httpMethod", "findResponse", "httpRequest", "makeAttempt", "findAttempt", "GetQuery", "giveQuery", " getrequest", "findRequest"], "getResponse": [" getResp", "deleteResponse", "getResp", "GetBody", "checkRes", "checkRequest", "deleteResp", "checkResponse", " getresponse", "GetResponse", "giveresponse", " getSolution", "getBody", " getApplication", "httpSolution", " getRes", "getRes", "giveApplication", " getBody", "httpResponse", "GetRes", "checkBody", "deleteSolution", "Getresponse", "getSolution", "getApplication", "GetRequest", "httpRequest", "deleteRequest", "httpResp", "giveRequest", "getresponse", "GetApplication", "giveResponse"], "statusCode": ["versioncode", "statusCo", " statusLength", "statusStatus", " statusType", "useCode", "impactcode", "StatusStatus", "impactCode", "versionCode", "statuscode", "useType", "StatusCode", " statuscode", "versionCo", "sequenceStatus", "StatusCount", "statusLength", "sequenceCode", " statusCount", "successCode", "sequenceCount", "versionLength", "statusNumber", "usecode", "statusType", "impactLength", "successType", " statusCo", "statusCount", " statusNumber", "sequenceNumber", "StatusNumber", "successcode", " statusStatus", "impactCo"], "getResponseEntity": [" getResponseElement", "getResponseUnit", "getBlockObject", "getresponseElement", "getBlockElement", "getResultEntry", "getResponseElement", " getResponseObject", "GetresponseEntity", "getResultEntity", "getRespEntity", "GetResponseUnit", "getReturnElement", "getResultObject", "getRespEntry", " getReturnEntity", "GetResponseEntry", " getResponseEnt", "getresponseEntity", "getResponseEnt", "getReturnEnt", "getResponseEntry", "getresponseUnit", "getResponseObject", "GetresponseUnit", "getResultUnit", "getReturnObject", "getresponseEnt", "getresponseEntry", " getReturnObject", "getresponseObject", "GetresponseObject", "getBlockEnt", "GetResponseObject", "getReturnEntity", "GetresponseEntry", "GetResponseEntity", " getReturnEnt", "getBlockEntity", "getRespObject", " getReturnElement", "getRespUnit"]}}
{"id1": "15241397", "id2": "5414088", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["doget", "DoGET", " doGET", " doget", "handleget", "DoGet", "doGET", "handleGET", " doPut", "handlePut", "handleGet", "doPut", "Doget", "DoPut"], "request": ["setup", "message", "transform", "user", "the", "http", "each", "QUEST", "input", "query", "application", "address", "context", "first", "reference", "current", "frame", "quest", "client", "req", "Request", "in", "forward", "initial", "attribute", "document", "command", "position", "report", "get", "re", "question", "complete", "connection", "server", "create", "start", "hello", "reset"], "response": ["reply", "message", "block", "ce", "http", "write", "application", "context", "output", "description", "session", "frame", "network", "send", "success", "answer", "onse", "image", "next", "page", "object", "exit", "ve", "resp", "xml", "version", "document", "result", "site", "json", "sequence", "respond", "body", "view", "console", "report", "position", "form", "fire", "connection", "content", "server", "print", "resource", "res", "Response", "status", "service", "reset"], "rewrittenQueryString": ["rewrittenqueryString", "rewrittenQuestionString", "rewrittenHeaderStream", "rewwrittenqueryStr", "rewrittenquerystring", "rewrittenRequestStr", "rewrittenURLStr", "rewrittenQuString", "rewrittenQuStr", "rewwrittenqueryString", "rewrittenHeaderString", "rewartedQueryStream", "rewrittenCurrentString", "rewwrittenQueryQuery", "rewrittenHeaderstring", "rewwrittenqueryQuery", "rewrittenRequestQuery", "rewrittenURLStream", "rewliedQueryStream", "rewwrittenQuerystring", "rewrittenCurrentQuery", "rewrittenQueryStream", "rewrittenQuerystring", "rewliedQueryStr", "rewartedQueryStr", "rewrittenQuStream", "rewartedHeaderstring", "rewrittenQuestionStr", "rewrittenqueryStream", "rewrittenURLString", "rewliedQueryString", "rewrittenRequeststring", "rewartedQuerystring", "rewartedQueryString", "rewrittenQustring", "rewartedHeaderStream", "rewrittenRequestString", "rewrittenCurrentstring", "rewwrittenquerystring", "rewrittenHeaderStr", "rewwrittenQueryString", "rewrittenQueryQuery", "rewrittenCurrentStr", "rewrittenqueryStr", "rewrittenqueryQuery", "rewartedHeaderString", "rewliedqueryString", "rewartedHeaderStr", "rewliedqueryStr", "rewwrittenQueryStr", "rewliedqueryStream", "rewrittenQueryStr", "rewrittenQuestionStream", "rewrittenURLstring"], "rewrittenUrl": ["rewrapedPort", "rewartedURL", "RewwrittenURL", "rewittenLink", "rewrapedUrl", "rewrapedURL", "rewadjustedURL", "rewartedurl", "rewrownURL", "rewwrittenLink", "rewriterUrl", "rewrownUrl", "RewrittenURL", "rewadjustedPort", "RewrittenUrl", "Rewrittenurl", "RewwrittenLink", "rewedString", "rewroteUr", "RewwrittenPosition", "rewittenURL", "rewrittenurl", "rewrittenString", "rewartedUrl", "RewrittenLink", "RewrittenPort", "rewwrittenString", "rewriteURL", "rewrittenURL", "rewroteLink", "rewrittenUr", "rewrownPosition", "rewrapedUr", "rewriteUr", "rewwrittenUr", "RewrittenPosition", "rewriteurl", "rewrittenLink", "rewittenurl", "rewittenUrl", "RewrittenString", "Rewwrittenurl", "rewriterURL", "RewwrittenPort", "rewedUrl", "rewwrittenPosition", "rewwrittenPort", "rewriddenURL", "RewwrittenString", "rewrownUr", "rewartedPosition", "RewwrittenUrl", "rewwrittenurl", "rewroteurl", "rewrittenPort", "rewedUr", "rewriterString", "rewriteUrl", "rewadjustedUr", "rewadjustedUrl", "rewroteUrl", "rewriddenPosition", "rewedURL", "rewriddenUr", "rewartedUr", "rewriterUr", "rewriddenUrl", "RewwrittenUr", "rewwrittenUrl", "rewrittenPosition", "rewrotePosition", "RewrittenUr", "rewroteURL", "rewwrittenURL"], "httpURLConnection": ["httpHTTPConfiguration", "ttpUrlConnect", "httpMLApplication", "ttpURLApplication", "httpSRApplication", "httpSRConnection", "httpURLConnect", "httpHTTPConnect", "httpMLconnection", "httpRLConnect", "httpURLConfiguration", "ttpUrlconnection", "HttpHTTPConnect", "HttpURLConnection", "httpMLConnect", "httpSRControl", "httpUrlconnection", "ttpURLConnect", "ttpURLconnection", "HttpHTTPApplication", "httpRLconnection", "HttpURLconnection", "ttpUrlControl", "httpHTTPConnection", "httpMLConnection", " httpURLConnect", "ttpUrlConnection", "HttpURLApplication", " httpUrlconnection", " httpUrlApplication", "ttpUrlApplication", "httpUrlControl", "HttpURLConnect", "HttpHTTPconnection", "httpSRConnect", " httpUrlConnect", "httpUrlApplication", "httpHTTPConn", "httpUrlConfiguration", "httpHTTPControl", "httpSRconnection", "httpUrlConnection", "HttpUrlConnection", "httpUrlConn", "ttpURLConnection", "httpRLApplication", "ttpURLControl", "HttpUrlConnect", "httpFileConnect", "httpURLApplication", " httpURLconnection", " httpURLApplication", "HttpHTTPConfiguration", "HttpUrlconnection", "httpSRConfiguration", "httpRLConnection", "httpFileConnection", "ttpURLConn", " httpUrlConnection", "HttpURLConfiguration", "httpURLControl", "httpURLconnection", "HttpHTTPConnection", "ttpUrlConn", "httpFileConn", "httpFileApplication", "httpHTTPconnection", "httpUrlConnect", "httpHTTPApplication", "httpURLConn"], "header": ["headers", "user", "block", "check", "dr", "init", "format", "title", "device", "shift", "heading", "component", "query", "info", "wrapper", "address", "argument", "core", "head", "zone", "client", "padding", "feature", "rule", "peer", "term", "detail", "page", "Header", "h", "ter", "layer", "handle", "er", "version", "attribute", "part", "field", "token", "handler", "state", "policy", "hidden", "option", "meta", "port", "line", "buffer", "event", "metadata", "holder", "hash", "operator", "column", "comment", "section", "status", "filter", "tag", "prefix", "relation", "variable"], "value": ["message", "VALUE", "format", "save", "Value", "address", "des", "instance", "description", "current", "sv", "zone", "string", "vector", "python", "record", "entry", "test", "job", "key", "email", "ue", "val", "label", "pair", "unit", "expression", "version", "password", "attribute", "default", "field", "element", "json", "sequence", "text", "property", "see", "server", "content", "v", "create", "sample", "language", "data", "example", "comment", "hash", "hello", "name", "values"], "inputStream": ["inputThread", "errorSteam", " inputSteam", "InputLoop", "InputView", "outputThread", " inputView", "outputLoop", " inputLoop", "InputThread", "inputWindow", "InputStream", "errorstream", "outputstream", " inputstream", "outputWindow", " inputThread", "inputLoop", "outputSteam", "errorWindow", "inputView", "inputSteam", "outputView", "inputstream", " inputWindow", "errorStream"], "outputStream": ["displaySteam", "responseForm", "responseLength", "displayStream", " outputView", "responseSteam", "outputForm", " outputSteam", "OutputSteam", "OutputStream", "displaystream", "outputstream", " outputLength", "outputSteam", "displayView", "responseStream", " outputForm", "inputView", "inputSteam", "outputLength", "OutputLength", "outputView", "inputstream", " outputstream", "OutputForm"]}}
{"id1": "21063400", "id2": "3184073", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"doImageProcess": [" doImagesProcess", "doItemImageWork", "doImagesProcess", "doMediaWork", "doMediaprocess", "doMediaProcess", " doImagesWork", "doImageWork", "doItemImageSort", " doImageprocess", "doItemImageprocess", "doImagesSort", "doImageprocess", "doImagesprocess", " doImageWork", "doMediaSort", " doImagesSort", "doItemImageProcess", "doImageSort", "doImagesWork", " doImagesprocess", " doImageSort"], "request": ["message", "template", "QUEST", "input", "query", "application", "address", "context", "select", "session", "reference", "frame", "quest", "client", "image", "Request", "version", "attribute", "document", "command", "view", "re", "question", "server", "resource", "model", "start"], "response": ["reply", "message", "user", "block", "collection", "format", "display", "http", "cache", "search", "write", "application", "query", "output", "description", "relation", "list", "frame", "network", "success", "answer", "onse", "entry", "window", "image", "next", "one", "page", "continue", "detail", "exit", "ve", "resp", "tree", "xml", "version", "document", "result", "site", "json", "view", "respond", "console", "sequence", "report", "position", "parent", "re", "fire", "connection", "content", "server", "print", "res", "model", "hash", "Response", "status", "reset"], "imgSize": [" imgName", "propError", "imgOwner", "imagError", " imgShape", " imgType", "imgError", "appShape", "imageSIZE", "imgName", "imagName", "certName", "imageInfo", "divSIZE", "imageStyle", "appsize", "divsize", "dimSize", "imgShape", "imageType", "appType", "divSize", "certSIZE", "certSize", "imgInfo", "imgType", "imgScale", "imagSize", "augShape", "imageSize", " imgStyle", "imgSIZE", " imgScale", "appSize", " imgOwner", "imagsize", "augsize", "augOwner", "appInfo", "imgStyle", "dimSIZE", "certScale", "imageScale", " imgSIZE", " imgInfo", " imgsize", " imgError", "appStyle", "propsize", "propName", "propSize", "dimsize", "augSize", "imgsize", "imageName", "appOwner"], "imageInputStream": ["imageInputPath", "photoInputstream", " imageStreamStream", "imageIntStream", "imageIntstream", " imageInputPath", "imageInputView", "imageInView", "photoInputSteam", "imageInStream", " imageStreamPath", "imageRawView", "imageRawStream", "fileInputStream", "imageRawstream", "imageOutputForm", "photoInputStream", "imageByteSteam", "mediaInputStream", "imageInterfaceView", "imageOutputReader", "imageOutputstream", " imageStreamSteam", "photoIntstream", "imageInputForm", "imageStreamStream", "imageInterfacestream", "fileInputstream", " imageInputSteam", "fileRawSteam", "imageInputstream", "imageByteForm", "fileRawStream", "imageInterfaceStream", "imageIntPath", "imageStreamSteam", "imageInSteam", "imageRawSteam", "fileInputView", "imageInputReader", "fileRawstream", "imageInterfaceSteam", "photoIntStream", "imageOutputStream", "imageByteReader", "imageOutputSteam", "fileInputSteam", "fileRawView", "imageIntSteam", "mediaInputForm", "imageStreamPath", "mediaInputReader", "imageInstream", "imageInputSteam", "mediaInputSteam", "photoIntSteam", "imageByteStream"], "imageBytes": ["imgParts", "imgBytes", " imageParts", "pictureBytes", "issueParts", "photoByte", "photoBytes", "pictureGs", " imageSeries", "audioBytes", " imageGs", "photoKeys", "imageParts", "imageBs", "photoGs", "imageGs", "imgSeries", "photoParts", "imageKeys", "imageByte", "audioParts", " imageByte", "imgGs", "issueKeys", " imageBs", "imageSeries", "audioBs", "issueBytes", "imgKeys", "pictureByte", "audioSeries", "imgBs", "issueGs", "pictureParts"]}}
{"id1": "5148212", "id2": "9398454", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"copyFile": ["copImage", "copyImage", " copyfile", "cloneImage", " copyImage", "cloneFile", "clonefile", "copFile", "copfile", "copyfile"], "src": ["obj", "ls", "path", "iter", "rest", "init", "input", "sc", "Source", "usr", "url", "filename", "urg", "pkg", "file", "ser", "sec", "sr", "ource", "rc", "ur", "str", "sur", "sq", "inst", "req", "loc", "ins", "rs", "source", "from", "inc", "txt", "img", "ost", "attr", "sys", "st", "ipl", "usc", "iv", "ie", "ident", "sf", "syn", "start", "cur", "rel", "lit", "sit"], "dest": ["path", "usr", "file", "dir", "mk", "test", "origin", "de", "loc", "source", "orig", "way", "est", "sp", "spec", "port", "temp", "dist", "nw", "v", "fr", "obj", "des", "tif", "end", "comp", "good", "tom", "result", "desc", "target", "cont", "sit", "nd", "iter", "rest", "sup", "req", "this", "them", "img", "gov", "fe", "decl", "tr", "st", "coord", "dat", "ident", "deg", "trans", "data", "lit", "vol", "doc", "prop", "comb", "output", "Dest", "gt", "etc", "cat", "crit", "null", "nom", "ord", "to", "opt", "master", "delete", "min", "parent", "foreign", "d"], "bufSize": ["bufferSIZE", "fontsize", "fontSIZE", "boxSize", "bufCount", "buffersize", "BufferLen", "bufferCount", "ufSIZE", "ufSize", "BufferSize", "BufferCount", "queueLen", "bufferLength", "bufferSize", "bufInfo", " bufSIZE", "boxSIZE", "bufsize", "bufferLen", " bufsize", "fontSize", "ufInfo", "ufsize", "queueSize", "fontInfo", "bufSIZE", "queueLength", "boxsize", "bufLen", " bufInfo", "bufLength", "queueCount", "BufferLength"], "force": ["external", "ce", "dirty", "forge", "fail", "Force", "secure", "ace", "update", "write", " confirm", "func", "raise", "enable", "sync", "error", "open", "forced", "apply", "use", "always", "seed", "frame", "append", "send", "rule", "reason", "fx", "quote", "vert", "cp", "cmd", "flag", "flush", "handle", "forcing", "default", " override", "ignore", " enforce", "ghost", "require", "allow", "fast", "pdf", "form", "e", "remote", "only", "print", "yes", "start", "auto", "replace", "like"], "f": ["b", "xf", "conf", "uf", "fs", "r", "file", "bf", "fp", "dir", "fc", "elf", "m", "t", "s", "l", "fo", "inf", "c", "df", "p", "h", "rf", "ct", "fac", "fi", "part", "lf", "F", "w", "exp", "ef", "g", "e", "of", "sf", "fm", "d", "cf", "v", "fr"], "buffer": ["message", "iter", "block", "library", "template", "parse", "cache", "number", "write", "binary", "database", "paste", "stroke", "frame", "append", "queue", "memory", "window", "word", "row", "Buffer", "batch", "char", "index", "password", "document", "attribute", "command", "bar", "result", "sequence", "length", "text", "stack", "temp", "line", "shape", "buf", "history", "print", "base", "sample", "buff", "phrase", "filter", "table", "variable"], "read": ["iter", "range", "check", "gets", "parse", " Read", "bind", "it", "Read", "find", "write", "input", "open", "query", "select", "info", "give", "reader", "t", "add", "count", "str", "send", "load", "reads", "need", "record", "feed", "size", "fill", "before", "key", "word", "run", "stream", "end", "q", "READ", "en", "pe", "len", "char", "valid", "height", "ind", "w", "length", "im", "allow", "reading", "get", "log", "take", "shape", "ke", "raw", "hello", "seek", "i", "print", "start", "mem", "skip", "readable", "like", "time", "index", "ip"], "in": ["In", "ex", "iter", "is", "init", "or", "net", "on", "input", "rin", "it", "al", "ain", "ma", "IN", "per", "inn", "ln", "m", "l", "inside", "inf", "bin", "irm", "client", "ar", "ir", "image", "ins", "source", "inc", "from", "mi", "en", "ic", "to", "up", "io", "ind", "oin", "im", "din", "mm", "isin", "ie", "by", "get", "cin", "con", "i", "gin", "internal", "inner", "local", "ini"], "out": ["b", "obj", "user", "ex", "at", "full", "or", "net", "OUT", "note", "ou", "on", "cache", "it", "write", "output", "nt", "oe", "file", "ion", "list", "ln", "t", "cos", "oss", "bin", "client", "Out", "n", "end", "one", "os", "not", "cn", "to", "flush", "up", "io", "ne", "sys", "outs", "writer", "conv", "OU", "parent", "conn", "con", "co", "inner", "v", "aos", "o", "outer", "can", "print", "ot"]}}
{"id1": "12306305", "id2": "536614", "code1": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"doCopyFile": [" doCopFiles", "doCopfile", "doMoveByte", "doCopyfile", "doCopFiles", "docopyFiles", " doCopByte", "doMoveFile", " doCopfile", " doCopyfile", "doCopyFiles", "doCopByte", "doCopyByte", " doCopyFiles", "docopyFile", " doCopFile", "doMovefile", " doCopyByte", "doMoveFiles", "docopyByte", "docopyfile", "doCopFile"], "srcFile": ["srcPage", " srcFILE", "rbFile", "srcModel", "destFilename", " srcPage", "destLine", "rcile", "rcPage", " srcDir", "selFile", "selPage", "destPage", " srcfile", "destfile", "srcDir", "rcfile", "rcFilename", "srcile", "destModel", "rcFile", " srcModel", " srcile", "locPage", "sourcefile", "rcFILE", "sourceFile", "sourceDir", "sourceLine", " srcLine", "srcFilename", "selFilename", "rbFilename", "srcPath", "srcFILE", "selfile", "rbPath", "locFilename", "locModel", "rcLine", " srcPath", "rcPath", "rcDir", "srcfile", "rbFILE", " srcFilename", "srcLine", "locFile", "destile"], "destFile": ["DestPage", "srcPage", " destDirectory", "descPage", " destGrid", "DestFile", "memFILE", "origFILE", "memfile", "destFilename", "critFile", "descGrid", "litFile", "foreignDir", "DestDirectory", "declFile", "destPage", "foreignFILE", "destfile", "srcDir", "destOnly", "DestFilename", " destFilename", "critDir", "memFile", " destFILE", "distFilename", " destfile", "DestFiles", "destGrid", "destFILE", " destFiles", "srcFilename", "srcFiles", "descDir", "origDir", "litMail", "distfile", "litfile", "Destfile", "memFiles", " destPage", "declfile", "distDir", " destDir", "DestMail", "litFILE", "srcFILE", "DestDir", "critGrid", "foreignOnly", "srcGrid", "origOnly", "srcOnly", "destDirectory", "destDir", "origFile", "DestFILE", "critfile", "srcDirectory", "distFile", "srcfile", "descFile", "declFILE", "destFiles", "foreignFile", "DestGrid", "declMail", "destMail"], "preserveFileDate": ["preserveFiledate", "preserveFilenameDate", "preservesfileDuration", "preservesfileDay", "preserveLotDate", "preserveFileDuration", "preservesFileTime", "preserveFilesSize", "preservefileDay", "preserveFilenameTime", "preserveLotDay", "preserveFilesDay", "preservefileTime", "presoreLotdate", "preserveFileDay", "preserveLotSize", "preserveFilesdate", "preservesfileDate", "preservesFileDay", "preserveFilenameDuration", "preservesFileDate", "preserveLineDate", "preserveFilesDate", "preserveFilenameDay", "preservesFileDuration", "preserveFileTime", "presoreFileSize", "preserveSetDate", "presoreFiledate", "preserveLineSize", "presoreFileDay", "preserveLotdate", "preserveLinedate", "presoreLotSize", "preservefileDuration", "preserveLineDay", "preserveSetDay", "preservefileDate", "preservesfileTime", "preserveSetTime", "preserveFileSize", "presoreLotDate", "preserveSetDuration", "presoreLotDay", "presoreFileDate"], "input": ["read", "iter", "init", "accept", "parse", "http", "it", "audio", "info", "open", "context", "request", "current", "reader", "Input", "add", "exec", "feed", "before", "client", "entry", "focus", "image", "stream", "source", "from", "q", "in", "pattern", "up", "archive", "xml", "initial", "io", "op", "command", "json", " Input", "hidden", "upload", "get", "buffer", "raw", "history", "internal", "inner", "alpha", "partial", "auto", "start", "installed", "index", "local", "ip"], "output": ["put", "message", "block", "ilo", "group", "format", "net", "display", "ou", "out", "write", "open", "cut", "file", "icon", "network", "success", "client", "web", "image", "stream", "next", "page", "exit", "result", "console", "hidden", "text", "body", "writer", "port", "remote", "buffer", "connection", "module", "four", "print", "auto", "outer", "latest", "response", "o", "data", "section", "channel", "generated", "Output"]}}
{"id1": "16556717", "id2": "11645260", "code1": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getSHADigest": ["getSHADegse", "getSHADDigest", "getSHAdegester", "getSHAdigests", "getSHADdigester", "getSHADegest", "getSHADdigse", "getSHADigester", "getSHADDigester", "getSHADdigest", "getSHADegests", "getSHADdigests", "getSHADigests", "getSHAdegests", "getSHADDigse", "getSHADegester", "getSHADDigests", "getSHAdegest", "getSHAdigse", "getSHAdigester", "getSHAdigest", "getSHAdegse", "getSHADigse"], "password": ["message", "user", "sword", "words", "auth", "value", "pass", "id", "Password", "input", "wd", "address", "database", "login", "description", "session", " Password", "string", "padding", "email", "key", "word", "pattern", "username", "token", "command", "w", "text", "reset", "hash", "data", "name", "response", "phrase", "prefix", "secret"], "digest": ["dest", "decest", "decgest", "Digester", "Dighash", " digEST", "digEST", "digester", "dested", "hashEST", "hashested", " digse", "diggest", "mentEST", "mentester", "decEST", "digested", "Digist", "Digest", "igse", "mentest", "ighash", "digist", "dighash", "Digse", "digment", "Diggest", " dighash", "mentgest", "decester", "dEST", " digist", "igEST", " digment", "dist", "DigEST", "Digested", "hashment", "digse", "igest", "hashest", " digested", "Digment"], "sha": ["shi", "lambda", "SHA", "ppa", "ka", "pa", "git", "tar", "api", "da", "func", "shell", "wal", "iso", "ma", "ssh", "wa", "mac", "md", "shared", "ah", "sq", "hi", "ta", "asha", "acl", "a", "go", "ha", "ao", "addr", "ya", "sh", "sam", "HA", "sche", "qa", "phi", "has", "ca", "po", "na", "no", "access", "ssl", "sa", "si", "sum", "ho", "pi", "auto", "hash", "alpha"], "pwhash": ["pwhat", "pWHat", " psway", "pshashed", "pthhash", "pshash", "pswhash", "pswat", " pswhash", "pshhash", " pswashed", "pWHashed", "pthash", "pwhhash", "pwhashed", "pWHash", "psway", " pswat", "pWHhash", "pswashed", " pwhhash", "pWHay", "pwhay", "pthashed", " pwhat", " pwhay", "pswash", " pwhashed", " pswash", "pshay", "pthat"]}}
{"id1": "22411381", "id2": "9846843", "code1": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 0, "substitutes": {"stop": ["check", " stopping", "update", "save", "Stop", "proc", "run", " stops", "end", "ops", "close", "exit", "quit", " Stop", "runner", "work", "st", "kill", "step", "worker", "pause", "process", " stopped", "start", "execute", "poll", " halt", "status", "service"], "task": ["transform", "item", "Task", "article", " Task", "tc", "project", "t", "app", "rake", "test", "worker", "node", "service", "dev", "tip", "thread", "tg", "that", "description", "trace", "job", "self", "key", "ask", "command", "token", "target", "question", "total", "scan", "tag", "point", "table", "setup", "message", "function", "unknown", "request", "session", "config", "kick", "trigger", "link", "what", "term", "this", "action", "work", "problem", "remote", "trial", "piece", "index", "component", "query", "type", "asks", "rule", "word", "null", "cmd", "unit", "to", "master", "msg", "form", "remove", "process", "event", "module", "activity"], "con": ["com", "Conn", "ctx", "conf", "cache", "nn", "out", "tc", "sql", "sc", "win", "comm", "context", "ain", "ln", "Con", "fc", "current", "cond", "bc", "rc", "client", "cc", "un", "c", "dc", "fn", "mc", "gate", "en", "cp", "cn", "gc", "ct", "ic", "don", "coll", "cm", "nc", "console", "socket", "CON", "conv", "log", "cin", "conn", "connection", "co", "ran", "pen", "cons", "cf", "cur", "can", "anc", "connect", "db", "pool", " conn"], "s": ["ls", "cs", "ess", "gs", "is", "us", "ts", "ds", "fs", "search", "comm", "m", "sv", " ts", "less", "sq", "sts", "c", "ins", "rs", "single", "iss", "xs", "os", "p", "h", "bs", " ss", "ses", "sys", "S", "sol", "hs", "set", "sb", "js", "g", "sub", "ps", "serv", "sing", "ssl", "ss", "sa", "stats", "res", "ws", "ms", "sg", "sl", "ns"], "result": ["bridge", "make", "out", "f", "err", "current", "rc", "se", "test", "source", "ter", "mate", "set", "successfully", "ch", "report", "conn", "connection", "resource", "response", "status", "relation", "fr", "obj", "Result", "all", "r", "description", "ser", "RESULTS", "release", "success", "proc", "results", "stream", "row", "successful", "valid", "json", "sen", "raw", "table", "message", "block", "list", "record", "page", "gc", "sequence", "dat", "ret", "re", "buffer", "res", "data", "we", "cache", "output", "su", "first", "currency", "done", "true", "answer", "created", "runner", "ge", "server", "cur", "complete"], "url": ["ls", "user", "path", "dl", "http", "URL", "lr", "id", "r", "address", "api", "l", "gl", "link", "job", "web", "html", "nl", "key", "term", "null", "host", "uri", "addr", "rl", "href", "json", "ref", "sb", "ret", "remote", "Url", "log", "build", "resource", "server", "base", "rel", "mount"], "i": ["ami", "ij", "iter", "is", "http", "gi", "it", "qi", "xi", "ib", "ci", "li", "I", "bis", "t", "l", "oi", "ai", "hi", "ri", "ki", "bi", "ir", "ii", "p", "mi", "ic", "in", "il", "io", "fi", "isi", "im", "phi", "iu", "ori", "si", "pi", "o", "inter", "cli", "ui", "di", "ini", "ip"], "b": ["bit", "ib", "bp", "gb", "be", "f", "lib", "binary", "z", "bf", "bl", "ab", "bis", "bc", "l", "rb", "bo", "bin", "cb", "bi", "bg", "br", "bu", "bs", "bound", "bar", "y", "sb", "bh", "eb", "nb", "B", "mb", "big", "fb", "base", "buff", "ob", "db", "pb"], "bb": ["ad", "BB", "berry", "ib", "gb", "bf", "bl", "ab", "bc", "rb", "obb", "bj", "bank", "cb", "ogg", "bg", "nob", "bar", "sb", "eb", "ld", "nb", "bd", "gg", "deb", "bn", "mb", "bread", "fb", "bt", "kb", "ble", "buff", "bm", "ob", "db"], "ll": ["ls", " LL", "lv", "dl", "lr", "tl", "wn", "nt", "ln", "bl", "lex", "l", "fl", "gn", "nl", "dll", "le", "lam", "ell", "arr", "resp", "coll", "len", "wl", "lf", "sol", "LL", "ly", "ld", "oll", "ble", "elt", "gz", " l", "lc"], "k": ["ka", "alk", "km", "uk", "kt", "ku", "t", "mk", "kick", "kw", "kh", "ik", "ki", "K", "key", "n", "kr", "tk", "p", "ko", "kar", "kj", "sk", "kk", "ak", "kl", "g", "kan", "aka", "ks", "kn", "ke", "ck", "ek", "dk", "ikk", "wk", "j", "VK"], "s2": ["ts2", " s6", "ls52", "ts02", "ps1", "ats2", "ss6", "ts1", "ses12", "ps02", "is52", "ats52", "ps4", "ses6", "ps2", "is2", " s1", "ds02", "ses02", "s52", "des4", "lstwo", "atstwo", "s1", "ats02", "ss02", "des02", " s02", "ds4", "ds2", "des2", "s02", "ls02", "ss12", "ts4", "ses2", " s4", "ss2", " s12", "s4", "is02", "s12", "stwo", "istwo", "s6", "ls2"]}}
{"id1": "15797402", "id2": "14773780", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "label": 0, "substitutes": {"parse": ["read", "transform", "format", "write", "save", "map", "apply", "php", "use", "add", "parser", "se", "load", "patch", "p", "close", "pe", "handle", "ping", "dump", "scale", "xml", "slice", "interpret", "build", "render", "process", "shape", "resource", "print", "create", "execute", "tag", "split", "filter"], "stream": ["Stream", "read", "message", "http", "input", "url", "download", "open", "output", "sync", "file", "clean", "instance", "reader", "zip", "test", "window", "image", "source", "in", "handle", "archive", "document", "sequence", "console", "length", "form", "upload", "stack", "iterator", "chain", "buffer", "cont", "event", "content", "resource", "sample", "data", "ream", "response", "channel"], "handler": ["message", "storage", "function", "ctx", "application", "wrapper", "address", "reader", "parser", "loader", "management", "host", "h", "processor", "handle", "password", "hand", "policy", "hander", "Handler", "writer", "worker", "controller", "shape", "event", "connection", "resource", "server", "service", "pool", "callback"], "metadata": ["message", "header", "template", "dirty", "ctx", "info", "tar", "mt", "MD", "m", "unknown", "config", "properties", "adata", "md", "common", "met", "parts", "google", "management", "memory", "image", "managed", "detail", "still", "details", "dd", "manager", "handle", "basic", "general", "xml", "document", "json", "policy", "property", "definition", "pdf", "meta", "iterator", "java", "material", "td", "content", "module", "hold", "mem", "data"], "context": ["collection", "ce", "template", "ctx", "component", "sc", "options", "translation", "instance", "config", "current", "frame", "network", "cc", "system", "reason", "null", "environment", "dict", "document", "command", "state", "sequence", "set", "stack", "usage", "condition", "chain", "event", "connection", "content", "module", "resource", "location", "Context", "response", "local"], "name": ["alias", "path", "channel", "value", "title", "on", "time", "id", "all", "pass", "url", "type", "filename", "description", "file", "current", "l", "common", "string", "client", "size", "system", "nm", "key", "Name", "term", "family", "image", "source", "n", "nl", "reason", "null", "label", "lower", "len", "version", "part", "default", "named", "old", "body", "ame", "none", "no", "NAME", "names", "resource", "base", "create", "data", "comment", "prefix", "service", "local"], "out": ["external", "user", "ex", "obj", "net", "OUT", "us", "ou", "conf", "it", "all", "url", "output", "file", "col", "list", "cos", "oss", "Out", "n", "one", "null", "cn", "cmd", "in", "to", "lay", "up", "flush", "io", "sys", "outs", "writer", "conv", "OU", "po", "serv", "con", "co", "sum", "print", "aos", "v", "auto", "o", "outer", "res", "table", "gen"]}}
{"id1": "810342", "id2": "932225", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doDatecheck", "doLicenseCheck", "doDateFix", "DoVersionFix", "doVersionFix", "doVersioncheck", "DoVersioncheck", "doVersionsFix", "DoDatecheck", "DoVersionUpdate", "doVersionUpdate", "doDateUpdate", "DoDateCheck", "doDateCheck", "doVersionsCheck", "DoDateUpdate", "doLicensecheck", "DoDateFix", "doVersionscheck", "doVersionsUpdate", "doLicenseUpdate", "doLicenseFix", "DoVersionCheck"], "view": ["block", "check", "review", "display", "http", "out", "input", "update", "query", "subject", "widget", "open", "context", "blade", "wrapper", "file", "help", "browser", "cell", "VIEW", "client", "web", "html", "self", "window", "image", "row", "this", "page", "q", "hl", "host", "cv", "table", "manager", "tv", "layout", "util", "index", "tree", "component", "document", "eye", "console", "show", "report", "form", "see", "engine", "get", "controller", "buffer", "server", "print", "v", "model", "views", "View", "iew", "doc", "call"], "url": ["b", "ls", "path", "dl", "http", "URL", "lr", "id", "r", "address", "f", "file", "l", "ur", "gl", "link", "str", "browser", "string", "client", "web", "html", "nl", "org", "loc", "null", "hl", "lb", "host", "mount", "uri", "char", "rl", "github", "json", "socket", "Url", "log", "ssl", "date", "oul", "ul", "v", "bel", "location", "language", "rel", "ll", "pl", "sl"], "in": ["In", "b", "is", "sin", "init", "out", "input", "rin", "info", "f", "ln", "ain", "IN", "file", "inn", "reader", "l", "inf", "vin", " IN", "stream", "ins", "n", "source", "inc", "kin", "body", "mat", "din", "isin", "cin", "mn", "i", "gin", " din", "asin", "inner"], "bin": ["b", "sin", "obin", "thin", "out", "cache", "rin", "win", "binary", "lib", "ln", "file", "bl", "inn", "reader", "cos", "rb", "abin", "loader", "bi", " Bin", "bg", "pipe", "len", "sam", " bins", "ebin", "din", "stock", "by", "nb", "bn", "mon", "cin", "con", "conn", "buffer", "gin", " din", "spin", "ran", "inner", "mem", "buff", "bed", "bur", "local"], "line": ["ls", "LINE", "path", "block", "range", "liner", "iter", "channel", "store", "lo", "err", "ln", "file", "col", "inline", "frame", "ine", "l", "string", "eline", "cell", "load", "link", "se", "record", "lin", "entry", "job", "trace", "cat", "word", "row", "section", "page", "le", "one", "cmd", "Line", "char", "part", "el", "field", "state", "text", "body", "style", "port", "log", "no", " Line", "ice", "lines", "chain", "print", "level", "ide", "base", "sample", "code", "column", "point", "comment", "lane"], "version": ["match", "value", "format", "title", "number", "ver", "update", "type", "info", "iso", "versions", "translation", "project", "ion", "description", "vers", "video", "string", "release", "browser", "python", "client", "test", "feature", "virtual", "key", "image", "VERSION", "software", "serial", "major", "Version", "scale", "command", "spec", "sequence", "river", "position", "form", "usage", "license", "VER", "date", "vision", "resource", "v", "hash", "latest", "language", "name", "tag", "volume", "status", "index"], "build": ["b", "dev", "develop", "match", "th", "full", "install", "fail", "make", "where", "ver", "update", "binary", "be", "lib", "project", "ward", "Build", "use", "add", "boost", "link", "release", "load", "builder", "test", "bor", "struct", "unit", "building", "util", "work", "old", "last", "round", "style", "uild", "bug", "log", "dist", "date", "hold", "print", "hash", "ble", "other", "ship", "tag", "db", "latest", "built", "arch"]}}
{"id1": "11153282", "id2": "937612", "code1": "    public static boolean existsURL(String urlStr) {\n        try {\n            URL url = ProxyURLFactory.createHttpUrl(urlStr);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.connect();\n            int responseCode = con.getResponseCode();\n            con.disconnect();\n            return !(responseCode == HttpURLConnection.HTTP_NOT_FOUND);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public String new2Password(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            String clearPassword = passwd;\n            md.update(clearPassword.getBytes());\n            byte[] digestedPassword = md.digest();\n            return new String(digestedPassword);\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 doesn't exist\");\n            System.out.println(e.toString());\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"existsURL": ["exitsUR", "exitsHTTP", " existUR", "existURL", "existHTTP", " existUrl", " existURL", "exitsUrl", " existsHTTP", "existUrl", "existingUR", "existsHTTP", "existingURL", "existingUrl", "existsUrl", " existsUrl", "existUR", "existingHTTP", " existHTTP", "existsUR", " existsUR", "exitsURL"], "urlStr": [" urlObj", "urlSt", "urlString", "uriObj", "uriStr", "UrlSt", " urlSpec", " urlWr", "URLString", "UrlObj", "uriSpec", " urlString", "URLSpec", "UrlStr", "UrlSpec", "URLWr", "urlSpec", "uriWr", "uriString", "urlWr", " urlSt", "urlObj", "uriSt", "URLStr"], "url": ["ls", "b", "dl", "http", "URL", "r", "file", "abs", "l", "ur", "link", "str", "https", "sur", "job", "org", "nl", "arl", "loc", "this", "null", "acl", "lb", "p", "mount", "uri", "gc", "char", "rl", "il", "log", "Url", "build", "conn", "ssl", "ul", "bel", "base", "name", "ll", "pl", "sl", "arch"], "con": ["cs", "user", "com", "Conn", "conf", "on", "open", "comm", "ln", "col", "Con", "ain", "fc", "cond", "bc", "cos", "client", "proc", "c", "fin", "fn", "n", "close", "cp", "en", "cn", "num", "coll", "canon", "cm", "nc", "rec", "compl", "soc", "ch", "conv", "CON", "dial", "re", "sub", "ctrl", "conn", "connection", "cont", "co", "ran", "pen", "cons", "res", "cur", "cf", "can", "syn", "inner", "connect", "un"], "responseCode": [" responseCount", "replycode", "answerMap", "responsecode", "answerType", "replyCode", "conditionCode", "replyMessage", "Responsecode", "responseMap", "conditionMap", " responsecode", "ResponseCount", "conditionZone", " responseMessage", " responseMap", " responseType", " responseZone", "responseZone", "conditionType", "answerCode", "replyCount", "ResponseMessage", "responseCount", "ResponseCode", "answerZone", "responseMessage", "responseType"]}}
{"id1": "5676111", "id2": "3053403", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "label": 0, "substitutes": {"get": [" fetch", "init", " recover", " finish", "download", "info", "sync", " put", " copy", "Get", "zip", "exec", "run", " delete", " reload", "gc", "dump", "delete", "upload", " download", "Download", "GET", "export", "print", "execute", " construct", "call"], "cnt": ["Cct", "Ccount", "ncht", "acNT", "cnc", "unclen", " cNT", " cht", "nnc", "Cnc", "clen", "cct", "uncnt", "Cnt", "ccount", " cnc", "nccount", "ncnt", " clen", "cNT", "uncNT", "CNT", "ncct", "acnc", "uncnc", "aclen", "nnt", " cct", "Cht", "nct", "acnt", " ccount", "nNT", "cht"], "url": ["ls", "path", "dl", "cert", "http", "URL", "fs", "open", "f", "r", "l", "ur", "gl", "str", "fl", "https", "link", "client", "google", "browser", "web", "nl", "loc", "null", "hl", "host", "mount", "cp", "uri", "addr", "handle", "char", "xml", "www", "el", "socket", "ref", "ret", "mail", "Url", "build", "con", "ssl", "ul", "bel", "base", "rel", "ll", "pl", "sl"], "conn": ["obj", "com", "Conn", "ctx", "net", "cert", "init", "yn", "open", "comm", "nt", "col", "l", "exec", "client", "ens", "gn", "org", "cb", "nl", "c", "loc", "os", "cp", "nec", "cn", "en", "cmd", "ct", "act", "coll", "addr", "resp", "cm", "nc", "ch", "access", "conv", "enc", "dial", "ca", "serv", "con", "jp", "connection", "cont", "co", "syn", "cons", "cur", "rel", "connect", "ns", "pas"], "is": ["nis", "iter", "init", "us", "isl", "vis", "it", "fs", "ib", "ys", "iso", "ms", "dis", "abs", "IS", "bis", "ist", "isc", "lis", "ends", "ri", "ists", "ins", "rs", "iss", "os", "ris", "ic", "in", "isf", "Is", "bs", "sys", "icks", "isi", "imp", "im", "its", "has", "isin", "ios", "ais", "sim", "ps", "i", "si", "mis", "isa", "iris", "sit", "es", "ip"], "filename": ["ren", "path", "title", "sql", "f", "ename", "subject", "file", "fp", "mson", "journal", "Filename", "sbm", "string", "str", "LCS", "nm", "til", "family", "fn", "txt", "source", "lua", "username", "fil", "nu", "river", "ame", "kl", "FILE", "FIL", "stem", "continental", "latest", "name", "prefix", "println", "knife"], "fos": ["flos", " foses", "vres", " foes", "fres", "boes", "boss", "los", "Foes", "foses", "loes", "Foss", "foss", " fows", "Foses", "bos", "Fows", "floes", "floss", "Fres", "Faos", " foss", "laos", "vaos", "voses", "foes", "bows", "faos", "vos", "loss", "fows", "flaos", "Fos", " faos", " fres"], "buffer": ["library", "message", "block", "bytes", "iter", "template", "display", "note", "cache", "binary", "output", "database", "paste", "frame", "bone", "append", "queue", "memory", "window", "Buffer", "page", "source", "scroll", "batch", "char", "document", "attribute", "command", "bar", "result", "sequence", "view", "length", "text", "stack", "temp", "buf", "event", "history", "total", "print", "available", "base", "sample", "buff", "data", "mem", "phrase", "comment", "button", "table", "variable"]}}
{"id1": "11962480", "id2": "15472181", "code1": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "code2": "    private InputStream getInputStream(String item) {\n        InputStream is = null;\n        URLConnection urlc = null;\n        try {\n            URL url = new URL(item);\n            urlc = url.openConnection();\n            is = urlc.getInputStream();\n            current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() + url.getFile();\n        } catch (Exception ee) {\n            System.err.println(ee);\n        }\n        int i = 0;\n        udp_port = -1;\n        udp_baddress = null;\n        while (urlc != null) {\n            String s = urlc.getHeaderField(i);\n            String t = urlc.getHeaderFieldKey(i);\n            if (s == null) {\n                break;\n            }\n            i++;\n            if (\"udp-port\".equals(t)) {\n                try {\n                    udp_port = Integer.parseInt(s);\n                } catch (Exception e) {\n                }\n            } else if (\"udp-broadcast-address\".equals(t)) {\n                udp_baddress = s;\n            }\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"read": ["library", "empty", "init", "parse", "store", " Read", "Read", "update", "write", "download", "open", "find", "file", "config", "loads", "construct", "reads", "load", "READ", "copy", "define", "delete", "reading", "seek", "create", "readable", "index"], "skeletonFilename": ["skelFilename", "Skelfilename", "sootFile", "SkeletonBas", "saltURL", "skeletonfilename", "saneFile", "skelFile", "saneFilename", " skelFile", "saltSourceFile", "SkeletonFile", "sootTitle", "sootFilename", "SkeletonTitle", "skeletonTitle", "skelfilename", "siteBas", "skeletonFile", "satelliteString", "sadeResource", "skelBas", "saneResource", "saltFilename", "soleFile", "satelliteFile", "skeletonURL", "sadeFile", " skeletonFile", "siteFilename", "skelTitle", "SkeletonFormat", "skelFormat", " skelSourceFile", "SkelBas", " skeletonURL", " skelURL", "SkeletonString", "SkeletonResource", "soleFilename", "skelResource", "soleFormat", " skelFilename", "saltFile", "SkeletonFilename", "SkelString", "skeletonResource", "sanefilename", "skelString", "satelliteFilename", "SkelFilename", "soleTitle", "skelSourceFile", "SkelTitle", "Skeletonfilename", "skelURL", "SkelFormat", "sootFormat", "skeletonFormat", "siteFile", "siteString", "skeletonBas", "skeletonString", "SkelFile", "sadeFilename", "SkelResource", " skeletonSourceFile", "sadefilename", "satelliteBas", "skeletonSourceFile"], "loader": ["library", "loaded", "loading", "lr", "wrapper", "context", "class", "lib", "older", "loads", "l", "parser", "program", "load", "cl", "builder", "system", "container", "label", "hl", "acl", "er", "upper", "loop", "owner", "handler", "folder", "license", "Loader", "finder", "resource", "module", "inner", "later", "language", "kernel", "pool"], "url": ["b", "ls", "user", "path", "dl", "http", "URL", "lr", "open", "address", "f", "file", "l", "ur", "link", "load", "browser", "job", "client", "builder", "entry", "nl", "web", "org", "key", "loc", "html", "lb", "host", "uri", "manager", "util", "github", "rl", "result", "ref", "impl", "mail", "Url", "build", "resource", "server", "location", "base", "rel", "name", "mount", "channel", "sl"], "line": ["LINE", "message", "block", "online", "liner", "channel", "value", "lo", " message", "ln", "file", "inline", "l", "ine", "link", "string", " chunk", "eline", "cell", "frame", "job", "L", "entry", "lin", "nl", "rule", "continue", "word", "row", "page", "le", " error", "next", "label", "cmd", "Line", " inline", " block", "area", "normal", " linen", " row", "field", "part", "sequence", " LINE", "text", "body", "side", " frame", " headline", "e", " blank", " comment", " equation", "log", " entry", "ice", "buffer", "chain", "zone", "lines", "print", "level", " lineage", "sample", "column", " sequence", "point", "lane", "comment", " code"], "section": ["ment", "library", "user", "block", "group", "script", "header", "channel", "article", "format", "function", "storage", "number", "member", "description", "session", "termination", "list", "journal", "second", "division", "se", "network", "string", "job", "summary", "entry", "character", "system", "key", "row", "null", "page", "setting", "unit", "area", "part", "field", "ner", "state", "sector", "sequence", "set", "length", "sections", "option", "writer", "room", "position", "statement", "side", "tab", "buffer", "connection", "event", "Section", "language", "comment", "prefix", "tag", "table", "sect", "region", "variable"], "reader": ["iter", "driver", "Reader", " Reader", "input", "r", "context", "older", "file", "ser", "rx", "parser", "entry", "roller", "builder", "anger", "stream", "row", "rar", "layer", "rl", "runner", "upper", "er", "handler", "ner", "rr", "length", "writer", "reading", "iterator", "buffer", "rot", "inner", "mr", "cur", "oder", "ro", "reverse"]}}
{"id1": "21363911", "id2": "12389873", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 1, "substitutes": {"testTransactions": ["testTransacts", "testTactions", " testtransaction", " testtransacts", " testtransactions", " testtransitions", "testTaction", "testTransitions", "testTacts", "testtransaction", "testtransitions", "testtransactions", "testTransaction", "testTitions", " testTransacts", " testTransaction", "testtransacts", " testTransitions"], "con": ["com", "conf", "on", "tc", "fc", "pc", "rc", "sur", "ens", "ct", "util", "nc", "ch", "enc", "dial", "conn", "connection", "co", "connect", "gen", "win", "sc", "open", "ain", "Con", "xc", "fl", "cc", "c", "cn", "dn", "ic", "act", "coll", "rec", "CON", "conv", "cont", "anc", "db", "un", "ren", "pt", "ctx", "ln", "config", "bo", "mc", "gate", "en", "cv", "gc", "console", "cal", "bn", "re", "ctrl", "cons", "cf", "res", "pl", "cache", "bc", "client", "fn", "go", "cp", "ac", "don", "cm", "po", "ran", "pen", "can", "cur"], "st": ["obj", "pt", "sl", "sta", "put", "th", "rest", "sth", "nd", "irst", "stop", "tt", "ts", "ste", "it", "ft", "sc", "mt", "std", "nt", "ln", "ust", "stan", "stat", "t", "s", "ist", "l", "rt", "str", "bo", "ut", "cl", "sts", "stra", "sn", "inst", "ST", "sty", "h", "ct", "stre", "ost", "est", "sp", "cr", "sol", "const", "wt", "St", "sb", "statement", "step", "ld", "stage", " superst", "must", "art", "so", "co", "bt", "sw", "et", "start", "ast", "fr"], "rs": ["cs", "dr", "ts", "ds", "usr", "rm", "pc", "rc", "rt", "rings", "ags", "ri", "rets", "ins", "Rs", "bs", "rl", "arts", "icks", "ress", "rd", "ss", "ros", "ges", "rots", "pres", "rus", "rss", "r", "irms", "ats", "RS", "s", "aps", "ras", "hs", "ems", "ns", "ls", "gs", "ics", "ubs", "vs", "vers", "times", "dds", "cases", "sts", "xs", "sys", "rys", "its", "js", "re", "els", "res", "mr", "ws", "ims", "arms", "vr", "ys", "ows", "ues", "rx", "sr", "abs", "rows", "ars", "ris", "ires", "rr", "acks", "rates", "ps", "ks", "stats", "qs", "rel", "ms", "hr"]}}
{"id1": "20519261", "id2": "5951961", "code1": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"readReferenceText": ["getreferenceText", "readLinkMessage", "readRefMessage", "readreferenceText", "readRefText", "getreferenceMessage", "readreferenceForm", "readReferencetext", "readLinkText", "getReferencetext", "readreferenceMessage", "readRefForm", "getreferenceForm", "readReferenceMessage", "getReferenceForm", "readreferencetext", "readLinktext", "readLinkForm", "getreferencetext", "getReferenceMessage", "getReferenceText", "readReferenceForm", "readReftext"], "ident": ["feat", "person", "match", "urn", "id", "sql", "filename", "context", "instance", "unknown", "Ident", "common", "string", "inst", "term", "word", "row", "loc", "prim", "ent", "addr", "tim", " identify", "util", "det", "password", "spec", "mod", "ind", "imp", "idents", "text", "coord", " identifier", "hex", "log", "intent", "event", "location", "local", "IDENT", "via"], "name": ["alias", "path", "format", "title", "id", "search", "type", "filename", "file", "string", "str", "nm", "key", "Name", "word", "n", "family", "source", "label", "version", "named", "text", "ame", "NAME", "me", "names", "resource", "location", "base", "mem", "data", "comment", "prefix"], "url": ["ls", "b", "dl", "http", "URL", "lr", "r", "li", "file", "l", "ur", "gl", "link", "browser", "web", "html", "nl", "loc", "hl", "lb", "mount", "uri", "ref", "mail", "Url", "log", "ssl", "resource", "ul", "bel", "location", "base", "rel", "ll", "pl", "sl"], "in": ["In", "iter", "is", "dr", "on", "out", "input", "rin", "info", "r", "f", "file", "IN", "inn", "reader", "l", "str", "inf", "bin", "irm", "ri", "stream", "ins", "n", "inc", "from", "null", "ic", "ind", "body", "din", "cin", "mn", "i", " din", "inner", "data"], "isr": ["isrs", " ispr", "ISrs", "ISer", "aisrc", "osr", "isrc", "osrs", "ISrc", "iser", "ospr", " iser", "ispr", "oser", "isser", " isrc", "aiser", " isrs", "issrs", "aisrs", "aisr", "issr", "isspr", "ISr"], "br": ["b", "bro", "dr", "bridge", "vr", "lr", "r", "bp", "be", "bf", "bl", "sr", "bc", "rb", "browser", "pr", "bi", "ber", "nr", "bs", "shr", "BR", "tr", "cr", "wr", "bh", "Br", "bd", "buf", "yr", "gr", "bt", "mr", "bm", "hr", "fr", "adr"], "buffer": ["message", "library", "block", "channel", "iter", "collection", "template", "bridge", "cache", "binary", "output", "database", "join", "bone", "append", "bo", "trace", "queue", "builder", "memory", "Buffer", "window", "quote", "row", "null", "screen", "menu", "batch", "document", "bar", "command", "sequence", "console", "length", "black", "sb", "temp", "buf", "escape", "total", "print", "base", "buff", "profile", "bm", "ob", "comment", "phrase", "button", "pool", "table"], "line": ["message", "LINE", "block", "header", "liner", "online", "range", "lined", "iter", "where", "number", "ln", "inline", "l", "ine", "frame", "string", "eline", "cell", "zone", "stroke", "lock", "link", "entry", "lin", "nl", "email", "row", "next", "page", "source", "detail", "le", "label", "Line", "len", "char", "ne", "sequence", "text", "body", "length", "position", "log", "no", "chain", "lines", "stay", "print", "code", "sample", "comment", "point", "member"]}}
{"id1": "5683576", "id2": "13666876", "code1": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"shorten": [" shortens", " shortense", "shortener", " Shorten", "Shortener", " Shortener", "shortens", "Shortense", "Shortens", " Shortense", " Shortens", "Shorten", "shortense", " shortener"], "url": ["ls", "b", "message", "path", "user", "dl", "format", "http", "URL", "id", "api", "address", "l", "link", "string", "str", "web", "html", "key", "domain", "page", "host", "p", "pattern", "version", "username", "password", "document", "json", "ret", "log", "Url", "ul", "location", "base", "name", "ll", "sl"], "qparams": ["qpackages", "qudetails", "qpins", "qvargs", "qualparam", "sqoptions", "iqoptions", "sqblocks", "quargs", "iqmarks", "qsparam", "qupins", "qqparam", "quoptions", "iqParameters", "sqpackages", "qqargs", "quparam", "sqdetails", " qdetails", "qupackages", "iqblocks", " qargs", "sqnames", "qsfields", "iqpins", "qoptions", "qualpackages", "sqparts", "sqparam", "sqargs", "qmarks", "QParameters", "dqmarks", "dqparams", "qqfields", "Qpins", "iqparam", "iqparams", "qunames", "quparams", "qmembers", "dqmembers", "qnames", "iqterms", "qvparams", "qparts", "qargs", "qvfields", "qvparam", "qqparams", "quams", "qfields", "iqnames", "sqterms", "Qparams", "qdetails", "quterms", "sqparams", "qumarks", "qsargs", "sqams", "iqmembers", "qualparts", " qams", "qumembers", "qterms", "qams", "qublocks", "qsparams", "quparts", "qualparams", "dqparam", "qblocks", "sqParameters", "qparam", "sqpins", "qParameters", "Qparam"], "params": ["headers", "pres", "gs", "ams", "cms", "Par", "ctx", " parameters", "conf", "AMS", "Parameters", "atos", "keys", "api", "options", "param", "config", "properties", "parser", "parts", "caps", "types", "rs", "details", "cp", "settings", "spec", "json", "eters", "mm", "parent", "ps", "stats", "pps", "names", "pi", "data", "terms", "changes"], "httpclient": ["httpconnection", "httpscli", "Httpconnection", "httpsclient", "httpsClient", "httpcache", "Httpcli", " httpcli", " httpClient", "httpscache", "HttpClient", " httpconnection", "Httpmanager", "httpClient", "Httpcache", "httpsconnection", "Httpclient", "httpmanager", "httpsmanager", " httpmanager", "httpcli", " httpcache"], "uri": ["ugi", "path", "range", "storage", "http", "qi", "query", "subject", "address", "filename", "database", "api", "du", "description", "wiki", "uni", "ur", "doi", "ri", "html", "origin", "term", "domain", "source", "u", " URI", "unit", "nu", "folder", "URI", "universal", "remote", "i", "iri", "resource", "location", "base", "pi", "prefix", "ui", "via"], "httpget": ["httpscall", "ttpsearch", "httGet", "httpscreate", "HTTPGet", "ttpget", "httquery", "httget", "httrequest", "HTTPsearch", "ttprequest", "hoverGet", "httpcall", "httpquery", "httpGet", "hoverquery", " httppull", "httpsget", " httpcreate", "ttpGet", "httprequest", "httpcreate", "HTTPget", "ttpquery", " httpcall", "httpspull", "hoverrequest", "httpsearch", "httcreate", "httcall", "httppull", " httpGet", " httpsearch", "httpull", "hoverget"], "response": ["reply", "message", "block", "http", "out", "application", "output", "description", "request", "frame", "success", "summary", "answer", "onse", "entry", "image", "one", "page", "still", "given", "object", "close", "successful", "resp", "document", "result", "json", "sequence", "respond", "body", "report", "connection", "content", "yes", "Response", "status"], "entity": ["obj", "person", "ce", "empty", "info", "output", "oe", "error", "icon", "encrypted", "client", "Entity", "entry", "email", "existent", "peer", "image", "le", "ent", "object", "om", "pe", "good", "eme", "document", "el", "result", "existing", "json", "valid", "body", "ity", "em", "enc", "e", "tex", "orm", "event", "resource", "content", "node", "status", "member", "ee", "activity"], "instream": ["intform", "outStream", "intstream", " inStream", "inStream", "INform", "imloader", "intcase", "inloader", "imcase", "inputform", "imform", "outstream", "inform", "intloader", "inputloader", "outconsole", "INstream", "INStream", " inconsole", "outform", "INconsole", " inform", "inputstream", "inconsole", "inputcase", "imstream", "incase"], "f": ["full", "ph", "conf", "uf", "fs", "fd", "bf", "fp", "tf", "t", "l", "fo", "c", "ff", "fx", "Factory", "df", "p", "af", "rf", "ct", "fac", "fi", "lf", "F", "w", "fab", "fg", "foreign", "e", "of", "sf", "fm", "cf", "v", "fr", "alf"], "jp": ["obj", "parse", "wp", "tp", "vp", "dp", "bp", "pkg", "fps", "fp", "mp", "dj", "hp", "jo", "bj", "iat", "prot", "xp", "p", "cp", "adj", "kj", "Ja", "JP", "jas", "peg", "op", "jj", "ja", "gp", "sp", "pai", "ijk", "uj", "jc", "eps", "js", "ps", "conn", "java", "jl", "np", "lp", "jump", "j", "jen", "fr", "pb", "pas"], "responseObj": ["ResponseCtrl", "ResponseBody", "ResponseOb", " responseObject", "requestObject", "responseCtrl", "ResponseObject", " responseCtrl", "replyVal", "replyBody", " responseVal", "ResponseObj", "replyObject", " responseBody", "responseOb", "responseBody", "requestOb", "responseObject", " responseOb", "replyObj", "requestCtrl", "ResponseVal", "requestObj", "responseVal"], "token": ["when", "channel", "template", "value", "atom", "function", "parse", "KEN", "note", "number", "ski", "tick", "type", "ok", "error", "list", "session", "kt", "task", "current", "lex", "t", "stat", "trigger", "browser", "before", "zero", "key", "word", "next", "txt", "p", "object", "Token", "table", "oken", "to", "tree", "initial", "document", "field", "state", "typ", "json", "element", "notice", "step", "no", "topic", "kn", "event", "complete", "total", "buffer", "reset", "span", "start", "operator", "pointer", "data", "name", "node", "tag", "j", "local", "relation", "normal", "variable"], "fieldname": ["fieldtype", "FIELDtype", "columnid", "ieldname", "FIELDval", "ieldName", " fieldtype", " fieldName", "fieldlen", " fieldlen", "Fieldval", "FIELDname", "ieldtype", "Fieldname", "fieldval", "keykey", "cellkey", "Fieldkey", "FIELDlen", "cellid", "FieldName", "columnName", "fieldName", " fieldkey", "fieldkey", "keyname", "FIELDName", "cellname", "keyName", "columnname", "fieldid", "cellName", "keyval", "columnkey", "FIELDkey", "ieldlen", " fieldid"]}}
{"id1": "8452134", "id2": "20210699", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"exists": ["exist", "exies", "Exies", "comists", "exits", "xits", "existies", " exits", "Exists", "Exinates", "extist", "extception", "comception", "xists", " exies", "Exits", "existinates", "extists", "existists", "exception", " exinates", "extits", "comits", "existits", "xist", "comist", "exinates", "xception"], "fileToCheck": ["fileToTest", "filetoWatch", "pathToWatch", "pathToSee", "file2Check", "filenameTOTest", "pathTOSee", "fileTocheck", "fileTOcheck", "filenameTOCheck", "fileToSee", "file2check", "pathToTest", "file2Test", "fileTOWatch", "pathTOTest", "fileTOTest", "filenameToCheck", "pathTOCheck", "filetoSee", "filenameToTest", "pathTOWatch", "pathToCheck", "filetoTest", "fileToWatch", "fileTOSee", "filetoCheck", "fileTOCheck", "filenameTOcheck", "filenameTocheck"], "ftp": ["rotm", "aptcp", "iftp", "ftchange", "ftphp", "ffc", "rotchange", "aptl", "ffv", "lattp", "ftt", "ffcp", "aftp", "ctcp", " ftt", " ftm", "ftc", " ftps", "rotpl", " ftv", "fabc", "rotl", "ldp", "latphp", "ftr", "ftcp", "rotps", "ffcache", "afttp", "ffp", "fabphp", " ftpl", "ffr", "ftcache", "ftl", "ctps", "ldphp", "aftchange", "ftps", "ftpl", "fabph", "aftcp", "aftr", " ftc", " ftr", "ldph", "aftc", "ctp", " ftphp", "ffphp", "cttp", "iftcache", "rotp", "rottp", "latp", "aftl", "aftv", " ftcp", "latcache", " fttp", "aftt", "ftm", "ifttp", "iftphp", "aftm", "rotcp", " ftph", "ldc", "fabp", "aptp", " ftl", " ftchange", "fft", "aftpl", "ftv", "fttp", "fftp", "ftph", "apttp"], "found": ["loaded", "full", "needed", "out", "id", "find", "search", "finished", "printed", "enabled", "fd", "done", "count", "killed", "checked", " Found", "Found", "success", "results", "expected", "affected", "started", "tested", "created", "successful", "good", "fixed", "sent", "ed", "index", "seen", "valid", "result", "successfully", "filled", "finder", "initialized", "failed", "matched", "Find", "d", "installed", "elt", "identified", "built"], "reply": ["message", "match", "check", "conf", "force", "shell", "error", "sync", "echo", "Reply", "count", "back", "repl", "link", "push", "success", "record", "answer", "onse", "nl", "continue", "zero", "next", "txt", "close", "mi", "py", "flag", "len", "ping", "cor", "result", "msg", "state", "notice", "embed", "report", "post", "ret", "nb", "ply", " Reply", "print", "code", "pop", "base", "response", "replace", "comment", "status", "index", "vote", "strip"]}}
{"id1": "771802", "id2": "1188100", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createOutputSteam", " createInputSteam", "createInputStream", " createInputstream", "createOutputstream", " createOutSteam", "createInputSteam", " createInputFile", " createFileFile", " createFilestream", " createFileStream", "createOutputFile", " createOutputstream", " createFileSteam", " createOutstream", " createOutStream", " createOutFile", "createInputstream", " createInputStream", " createOutputFile", "createInputFile", "createOutputSteam"], "inFile": [" inPort", "inDir", "ninfile", "ninPath", "inPath", "dinPath", "ninFilename", "inputDir", "outfile", "infile", " inFilename", " inDir", " infile", " inPath", "ninFile", "dinDir", "dinFile", "dinPort", "inPort", "inputPort", "outFilename", "inputFile", "inFilename", "inputPath", "outPath"], "outFile": ["exPlace", "newfile", "outPlace", "exfile", "exFile", "outputfile", "outputPlace", "newPlace", "newFile", "tofile", "outfile", "outPort", "infile", "toFilename", "outputFilename", "newFilename", "toFile", "inPort", "outputFile", "OutFile", "OutFilename", "exFilename", "toPort", "inFilename", "outFilename", "Outfile", "OutPort"], "k_blockSize": ["k2byteCount", "k_blockName", "k4blockName", "k2byteSize", "k4blockCount", "k_BlockLength", "k4BlockStyle", "k_BlockSize", "k2blockSize", "k_byteStyle", "k_byteName", "k_byteLength", "k2blockCount", "k_BlockName", "k_blockStyle", "k4blockSize", "k_byteCount", "k_byteTime", "k4BlockCount", "k_blockTime", "k_batchLength", "k_batchSize", "k_batchCount", "k_blockCount", "k_BlockCount", "k_BlockStyle", "k_byteSize", "k2blockTime", "k_batchTime", "k2byteLength", "k4BlockSize", "k4BlockName", "k_BlockTime", "k4blockStyle", "k2blockLength", "k2byteTime", "k_blockLength"], "byteCount": ["charLength", "byteCode", "wordSize", " byteCounter", "linePtr", "bitCode", "bytePtr", "charcount", "wordCode", "bbCount", "wordN", "charCount", "lineLength", "bitCounter", "bbSize", "bytecount", "bitCount", " byteCheck", "bbCode", "byteN", "blockLength", "blockCounter", "byteCheck", "byteLength", "linecount", "bitSize", "charPtr", "blockCount", " byteLength", "bitLength", " bytecount", "byteSize", "bbN", " bytePtr", "bitN", "bitCheck", "lineCount", "blockCheck", "byteCounter", "wordCount"], "buf": ["b", "bytes", "block", "ctx", "uf", "cap", "pkg", "bl", "bc", "rb", "ctr", "str", "queue", "cb", "proc", "tx", "cat", "Buffer", "bg", "txt", "cv", "img", "arr", "cmd", "batch", "bag", "msg", "seq", "exp", "alph", "conv", "fg", "Buff", "bn", "buffer", "raw", "vec", "cur", "mem", "buff", "cast", "db", "doc", "pb"], "ofp": ["owld", "owlpa", "OFd", "Ofd", "OFP", "Ofl", "OFp", "ofpa", "Ofpa", "ofP", "Ofp", " ofl", "ofd", "OFl", " ofd", "owlP", "owlp", "OfP", "ofl", " ofpa", " ofP"], "zos": ["css", "rose", "hz", "gs", "webkit", "zers", "init", "zo", "zh", "zzle", "rss", "za", "z", "std", "zu", "tis", "zip", "hess", "los", "sbm", "cos", "oss", "psy", "python", "nz", "bes", "zen", "sch", "os", "LOS", "enos", "zona", "ze", "osi", "jas", "cz", "bs", "settings", "zl", "zb", "zin", "socket", "zy", "ossus", "js", "ez", "ps", "zag", "sis", "rez", "eros", "south", "jp", "zi", "zes", "esa", "zer", "ws", "zon", "amia", "es", "zik"], "osw": ["isw", "ossW", "osswd", "osws", "oswx", "aosw", "osipace", " osW", "cosws", "osew", "owa", "syswd", "oswd", "ow", "osrw", "sysrw", "osssw", "aoswa", "ossrw", "aosW", " osew", "osd", "aosrw", "osiwa", "issw", "oswa", "ossw", " osd", "aosew", "cosw", "aospace", "oW", "osiW", "aosws", " oswx", "opace", "cosd", "cosew", " ossw", "iswx", "ospace", " osws", "osswx", "aoswd", "aosd", "osiw", "osW", "sysW", "isW", "sysw"], "bw": ["bwk", " bwl", "abwy", "besw", " bex", "pbz", "pbew", "rbws", "bew", "bend", "bbex", "pbwy", "rbz", "obsw", "abew", "wbend", " bsw", "bbwp", " bwt", "obz", "obwl", " bz", "nbew", "obwk", "bbz", "bwe", "wbx", " bend", "bewl", "bem", "bwb", "wbw", "bex", "obwb", "bz", "nbwy", "bbwt", "bbem", "bwt", "bbend", "bx", "rbex", "pbw", "bewk", "bwp", "wbz", "nbw", "sbwb", "nbwe", "pbwt", "sbz", "bsw", "wbwt", " bwp", "wbem", "sbw", "bbx", "bbws", "bbw", "abwe", "rbw", " bx", "bws", " bwk", "abw", "pbwe", " bem", "pbwb", "obwt", "obw", "wbwp", "bwl", "bwy", "sbwt", " bws"], "zot": ["zoonet", "zeronet", "zipot", "zeriat", " zote", "zhot", "zo", "zonet", "Zot", "zor", "zeror", " zott", "zerhot", "zoot", "zero", "zoor", " ziot", " zo", "Zote", " ziat", " zor", " zonet", "Zott", "zeriot", "zerote", "ziot", "zerott", "zoo", "ziphot", "zipiot", "zote", " zhot", "zerot", "Zit", "zipiat", "zott", "zerit", "ziat"], "ifp": [" ifP", "Ifjp", " ifth", "ihp", "iftp", "Ifp", "isjp", "iwr", "ifth", "isP", "isth", " iftp", "ifd", "isp", " ifd", "ifjp", "iwtp", "ihr", " ifjp", "ifr", "iwp", "ifP", "IfP", "iwd", " ifr", "ihtp", "Ifth", "ihd"], "zis": [" zisc", "izis", "izi", "zoinit", "ezi", "zoisa", "izisa", "zois", "zeris", "zipIS", "ziis", "zipic", "zic", "ezis", " zIS", "ziinit", "iziss", "zinit", "ezisc", " zi", "izisc", "zipis", "ziisa", "zisc", "zeric", "zerIS", "ziiss", "zisa", "zi", " ziss", "zIS", "eziss", "zoiss", " zic", "ziss", "izinit"], "isr": ["isalpr", "isrs", "siscr", "isscr", "sisrc", "sisr", "iospr", "isrc", "ispr", "sisrs", "isalr", "isalsr", "itssr", " isrc", "itsr", " isrs", "iscr", "iosstr", "iossr", "issrs", "iosr", "issrc", " iscr", "isalstr", "isstr", "issr", "itspr", "itsstr"], "br": ["b", "bro", "dr", "ptr", "vr", "lr", "ba", "bp", "r", "bf", "bl", "obl", "sr", "rb", "str", "ctr", "bj", "Fr", "pr", "bi", "ber", "kr", "shr", "BR", "tr", "cr", "wr", "js", "bh", "Br", "bd", "bn", "yr", "gr", "bt", "mr", "rel", "bm", "hr", "fr", " Br"], "zit": ["zist", "lexist", " zop", "zeop", "zlit", "ziIt", "zipist", "czit", " zite", "izit", "ziplit", "lexIt", "zipit", "izip", "ezIT", "ziit", "zip", "iziti", " zIT", "zite", "czot", "ezite", "ziist", "zeip", "ozip", " zlit", "zipIt", "zop", "ziti", "zIt", "ozunit", "ozit", "zunit", "izunit", "czunit", " zip", "ezlit", "ezit", "zeot", "zipIT", "czop", "czip", "cziti", "zeit", "lexit", "zIT", "oziti", "ziIT", "zipite", "lexIT"]}}
{"id1": "14390569", "id2": "7425022", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"title": ["setup", "message", "header", "tip", "template", "heading", "type", "subject", "filename", " Title", "description", "holiday", "itle", "help", "t", "string", "summary", "padding", "parts", "Title", "html", "size", "hd", "term", "label", "lead", "details", "TIT", "layout", "password", "notice", "msg", "text", "question", "content", "metadata", "start", "hash", "name", "theme", "prefix"], "imageURL": ["mediaID", "ImageUrl", "imageString", "photoURI", "ImageURI", " imageString", "mediaURL", "imageURI", "photoID", "ImageURL", " imageURI", "ImageUR", "imageID", "photoUrl", "fileURL", "ImageID", "photoURL", "fileUrl", "photoString", "fileString", "imageUR", "mediaURI", " imageUR", "imageUrl", "photoUR", "fileURI", " imageUrl", "mediaUrl"], "jd": ["qd", "qbd", "jjd", "zad", "gd", "ujd", "Jc", "zsd", "qp", "djsd", "jdm", "jdo", "gbd", "JD", "qdo", "Jmd", "kbd", "jsd", "Jds", "gds", "jdt", " jdo", "ijd", "jsds", " jc", "djc", "javapd", "jjbd", "djd", "jad", "djad", "jsdm", "ajdm", "Jp", "kdt", "ujdt", "jjp", "ujmd", "jobd", "javad", "simd", "ajpd", "ujD", " jdt", "ajds", "ajd", "kds", " jad", "simdt", "kd", "zd", "jobdt", " jD", "ijD", "jmd", "jds", "simD", "javadm", "simmd", "djdo", "jD", "djds", "Jdt", "jsD", "Jd", "Jdo", "jspd", "jobdo", "Jbd", " jds", "kdo", "jpd", "jc", "jbd", "ijds", " jsd", "javads", "Jad", "jjD", "qD", "qds", "gdo", "ujad"], "jl": ["ij", "lv", "dl", "bol", " li", "isl", "jac", "li", "ln", "dj", "bj", "gn", "nl", "dll", "jin", "txt", "jet", "kj", "ell", "elle", "kel", "ibl", "abl", "Label", "rl", "il", "jj", "ja", "ijk", "igl", "elly", "lu", "uj", "yl", "mil", "jc", "jah", "kl", "js", "ji", " ol", "J", "kn", "dyl", "syn", "lp", "elt", "j"], "icon": ["ex", "iban", "icons", "ion", " fruit", " canvas", " ion", "ocon", " screen", "lock", " widget", "ICO", "iao", " Icon", "image", "nic", "fn", " ancestor", "Icon", "label", "cil", "png", "cn", "gc", "ic", "ico", "addon", " lang", "jc", "conv", " tip", "icol", "chron", "con", "conn", "\u4e2d", "fa", "eric", "pen", " captcha", "syn", "font", "pic", " intent", " conn"], "chooser": ["compose", "boose", "boosen", "Chooder", "Choose", "CHOose", "choerer", "composen", "compicer", " chooder", "composer", "choicer", "Choosen", "boerer", "Choicer", "pooder", "CHOoser", "poicer", "comperer", "CHOosen", "poose", "choose", "Chooser", "CHOicer", "booser", "pooser", " choicer", " choosen", " choose", "choosen", " choerer", "chooder"], "jp": ["ij", " sip", " np", "bp", " pl", " cp", " ja", "bj", " joint", " ap", " je", "jin", "p", " mp", "kj", "JP", "ja", "sp", " dj", " gp", "jc", "js", " pic", "btn", " ip", " sp", "np", "j", "pic"], "jb": ["qbd", "kjcb", "jcb", "kjb", "kjbd", "Jcb", " jcb", "qb", "Jbd", " jbd", "jbd", "Jb", "qcb"], "e": ["or", "it", "f", "m", "t", "s", "c", "n", "a", "p", "u", "en", "ed", "er", "w", "E", "te", "ie", "g", "es", "re", "event", "d", "v", "o", "Event", "ev", "ee"], "returnVal": [" returnVol", "responseValid", "getVAL", "returnValue", "getVol", "returnValid", " returnval", "getVal", "ReturnValue", "Returnval", "retValue", "retVAL", "returnVAL", " returnValid", " returnValue", " returnVAL", "returnval", "responseVol", "retval", "returnVol", "getValid", "responseVal", "ReturnVal", "responseVAL", "ReturnVAL", "retVal"], "file": ["library", "path", "user", "place", "channel", "full", "format", "foo", "or", "http", "type", "info", "open", "f", "be", "filename", "class", "fs", "core", "fp", "dir", "real", "stat", "link", "rule", "image", "word", "run", "page", "null", "source", "le", "h", "fe", "ile", "to", "handle", "angle", "tree", "il", "io", "document", "work", "valid", "body", "target", "report", "drop", "port", "FILE", "get", "status", "buffer", "resource", "model", "base", "create", "name", "db", "relation", "File", "local", "table"], "fileName": ["FILEExt", "taskFace", "filePath", "taskname", " fileSystem", "fileClass", "FileSystem", "FILENames", "imageFace", "entityName", "filename", "fileFace", " filePath", "taskPath", "ileName", "handleNAME", "fileSystem", "FILEName", "fileExt", "Filename", "FILENAME", "entitySet", "imagePath", "ilename", "fileNames", "ileClass", "FILESystem", "taskName", "handlename", "FileName", "fileSet", "imageNAME", "handleClass", "FilePath", "handleName", "FileExt", "ileNAME", " fileExt", "FileNAME", "imagename", " filename", " fileNames", " fileClass", "FileNames", "FileSet", "FILEPath", "FileFace", "entityPath", "entityNAME", " fileNAME", "FILESet", "fileNAME", "imageName"], "ext": ["external", "aux", "ex", "pat", "lib", "dir", "xt", "lex", "t", "sem", "exe", "Ext", "ix", "prot", "test", "req", "word", "end", "txt", "xp", "vert", "exc", "ord", "def", "cmd", "ct", "off", "len", "ag", "part", "ind", "typ", "exp", "desc", "enc", "cod", "hex", "ec", "cont", "eur", "EXT", "fr"], "i": ["is", "init", "gi", "qi", "id", "xi", "it", "info", "ci", "li", "I", "m", "di", "ai", "hi", "bi", "ii", "mi", "fi", "y", "phi", "iu", "status", "ori", "si", "print", "ei", "pi", "ti", "cli", "j", "ui", "index", "ini"], "doIt": ["didIs", "odoWhich", "donIt", "doneit", "doWhich", "diWhich", "diit", " doIs", " doYou", "doIT", "diHe", " doit", "waIt", "doit", "didYou", "waIT", "didIt", " doIT", "donYou", "doIs", "doneIT", "donIs", "waIs", "doneIt", "diIt", " doWhich", "donIT", " doHe", "odoIt", "doYou", "odoit", "odoHe", "didit", "doHe", "donit", "odoIT"], "src": ["rob", "gs", "rest", "init", "ptr", "http", "input", "sc", "url", "usr", "r", "tmp", "ser", "sec", "rx", "sr", "ource", "rc", "rt", "rb", "ctr", "https", "proc", "sq", "inst", "crop", "loc", "ins", "rs", "source", "from", "lb", "comp", "rl", "copy", "sh", "sys", "st", "sb", "conv", "impl", "sub", "trans", "ources", "ssl", "cont", "syn", "inner", "start", "rel", "sl"], "dest": ["iter", "rest", "gest", "out", "des", "usr", "comb", "output", "tmp", "dir", "Dest", "pot", "https", "slave", "proc", "origin", "cat", "loc", "source", "nom", "orig", "cp", "decl", "pipe", "way", "master", "est", "sys", "sp", "st", "desc", "coord", "target", "port", "foreign", "dat", "temp", "trans", "dist", "cont", "nw", "can", "mem", "rel", "local", "pas"]}}
{"id1": "7891509", "id2": "12766394", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 0, "substitutes": {"pageAddress": ["pageaddress", "pageAdd", "PageAdd", "pageUrl", " pageUrl", "Pageaddress", "PageName", "serverName", "pageName", "serverUrl", " pageaddress", "PageAddress", " pageName", "resourceaddress", "PageUrl", "serveraddress", "serverAddress", "resourceName", " pageAdd", "resourceAdd", "resourceAddress"], "url": ["ls", "sl", "dl", "cert", "http", "URL", "r", "address", "api", "file", "l", "ur", "link", "str", "https", "browser", "gl", "client", "google", "web", "nl", "key", "window", "acl", "p", "mount", "uri", "char", "github", "sb", "ret", "mail", "Url", "build", "ssl", "resource", "ul", "bel", "base", "rel", "ll", "pl", "www"], "in": ["In", "b", "read", "check", "is", "init", "ill", "conf", "on", "out", "input", "rin", "it", "al", "all", "r", "ma", "IN", "inn", "reader", "and", "l", "inside", "inf", "bin", "again", "vin", "ins", "one", "n", "inc", "from", "mc", "en", "ic", "copy", "io", "ind", "oin", "din", "isin", "by", "re", "nin", "cin", "mn", "i", "gin", " din", "sum", "inner"], "inputLine": [" inputEntry", "InputLINE", "outputLINE", "submitLine", "focusRow", " inputL", "focusLine", " inputLINE", "responseBlock", "outputBlock", "submitLINE", "enumRow", "InputLine", "outputline", " inputRow", "inputline", "inputLINE", "inputEntry", "inputBlock", " inputNet", "outputLine", "submitBlock", "inputNet", "InputEntry", "responseline", "focusL", "inputL", " inputline", "responseLine", " inputBlock", "enumL", "InputBlock", "enumLine", "enumNet", "responseLINE", "focusNet", "inputRow", "submitEntry"]}}
{"id1": "14450108", "id2": "11645260", "code1": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"connect": ["setup", "read", "init", "secure", "bind", "write", "download", "open", "select", "sync", "login", "ssh", "config", "join", "construct", "network", "client", "connected", "close", "Connect", "ping", "initial", "attach", "set", "establish", "dial", "log", "remote", "build", "conn", "con", "process", "connection", "pen", "create", "reset"], "ftpe": ["etpy", " ftme", "etp", "aftpe", "attp", "iftse", "iftp", " ftse", " ftpy", "ftcle", "etse", "iftple", "oftpe", "aftcle", "aptpe", "aftple", "ftple", "aftpy", "aptp", "attple", "aftp", "ftpy", "oftple", "etpe", "iftpa", "ftse", "aptcle", "oftme", "ftpa", "oftse", "aptse", "attpe", "iftcle", "ftme", "attpa", "aftme", " ftple", "iftpe", "aftse", "aftpa"], "ftp": ["iftp", "ttpn", "ftphp", "ffc", "threadc", "ftt", "iftr", "ttport", "aftping", "ffcp", "ttp", "aftp", " ftt", "ctcp", "htttp", "ftc", "fty", "ottt", "topr", "aftP", "fabc", "iftpp", " ftpn", "toppe", "aftpe", " fty", "ftr", "ftcp", "threadp", "topp", "ftpn", "ftpp", "oftping", "afttp", "ffp", "ffr", "rotk", "fabpi", "raftp", " ftpp", "aftcp", "ifty", "aftr", "threadtp", "httpe", " ftc", "ftping", " ftr", "fabr", "iftd", "aftc", "ftd", "ctp", "ffping", "raftt", " ftpi", "raftpat", "cttp", "iftcp", "aftphp", " ftd", "rotp", "ttc", "aftpat", "iftk", "oftt", "ftP", "toptp", "oftp", "ftpat", "ftk", "oftr", " ftP", "aftpn", "aftpp", "aftk", "ottpat", " ftcp", "raftphp", "aftport", " fttp", "iftt", "aftd", "aftt", "rotr", "afty", "ifttp", "http", "ottp", "ttP", "ctr", "threadpe", "aftpi", "httr", "ottphp", "fabp", "ttpe", " ftport", "ftpi", "ftport", "ttr", "fft", "fttp", "fftp", "iftpe", "rotpe"], "path": ["dest", "Path", "full", "cert", "prop", "url", "wd", "context", "filename", "pkg", "dir", "str", "directory", "root", "PATH", "c", "host", "p", "cp", "cmd", "pattern", "copy", "ref", "port", "ath", "chain", "name", "prefix"], "currentDir": ["reportedPos", "currentDirectory", "currentDIR", "activePath", "activeFile", "currentPos", " currentDirectory", "CurrentDir", "activeDir", "reportedDir", "reportedFile", "CurrentDirectory", " currentDIR", "currentPath", " currentPath", "activePos", "tempDir", " currentFile", " currentPos", "tempPath", "currentFile", "tempDIR", "activeDIR", "reportedDirectory", "reportedDIR", "CurrentPos", "activeDirectory", "tempDirectory"], "reply": ["message", "match", "time", "query", "write", "info", "err", "shell", "error", "sync", "pty", "echo", "consider", "Reply", "back", "repl", "send", "record", "answer", "onse", "zero", "continue", "reason", "next", "proxy", "close", "nr", "mi", "flag", "trust", "result", "notice", "state", "respond", "report", "ch", "post", "ret", "nb", "re", "ply", " Reply", "print", "code", "transfer", "pop", "timeout", "response", "replace", "status", "reset", "vote", "call"]}}
{"id1": "6988216", "id2": "8132219", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" testQueryQ", " executeBasicContent", " executeSimpleQ", " executeBasicQuery", " testQueryQuery", " executeSimpleQuestion", " executeSimpleContent", " testRawQ", " testRawQuery", " testBasicContent", " testSimpleQuestion", " testRawContent", " testQueryQuestion", " executeBasicQuestion", " testBasicQ", " testBasicQuestion", " testSimpleContent", " testBasicQuery", " testSimpleQ", " executeBasicQ", " executeSimpleQuery", " testRawQuestion", " testQueryContent"], "dummySource": ["datalSource", "dummiesSource", "dumpSource", "determinedSource", "dummSource", "daummyStore", "datumResource", "dummiesInput", "udummyFile", "determinedContent", "daatumSource", "udeterminedContent", "daummyResource", "udeterminedFile", "daatumStore", "determinedFile", " duffyContent", "dancySource", "datumStore", "dancyContent", "dumpStore", " duffyInput", "dummyResource", "dummyInput", "dummyFile", "dumpInput", "daatumResource", "dancyInput", " duffySourceFile", "datumSource", "datumInput", "dummSourceFile", "dummySourceFile", "duffyContent", "dancyParent", "duffySource", "daatumInput", "udummySource", "udummyParent", "dumpResource", "dummInput", " duffySource", "dummyStore", " dummyInput", "determinedParent", "dummyParent", "daummyInput", "datalParent", "udeterminedParent", "dancyFile", "udeterminedSource", "duffySourceFile", "udummyContent", "daummySource", "dummiesStore", "datalFile", "dummContent", "datalContent", " dummySourceFile", "dummiesResource", "dancySourceFile", "duffyInput"], "os": ["oos", "dos", "OS", "css", "is", "or", "oses", "ts", "out", "ui", "ds", "fs", "dis", "ys", "oids", "ms", "oes", "ows", "des", "ats", "cos", "los", "ols", "s", "oss", "pos", "ens", "oS", "Os", "bos", "ops", "om", "osi", "bs", "ose", "asis", "ost", "io", "sys", "uts", "ants", "windows", "socket", "js", "ios", "es", "ox", "ori", "conn", "si", "ros", "oa", "et", "aos", "ors", "o", "ot", "mos", "obs", "ims"], "dummyContent": ["dumpingContent", "dummyMedia", "deltaContent", "dynamicTemplate", "dynamicCode", " dummiesCode", "dummyTemplate", "determinedContent", "dummyText", " dummyContents", "determinedInt", "deltaInt", "dummiesCode", "deltaMedia", "DumpMedia", "dumpingCode", "dummyContents", "DumpContent", "DummyMedia", "dumpText", "dynamicContents", "DummyInt", "dynamicContent", "dummyCode", "dumpingContents", "dummiesContents", "dumpingTemplate", "deltaText", " dummyCode", "dummiesTemplate", " dummiesContent", "DummyContent", " dummyTemplate", " dummiesTemplate", "dumpInt", "dummiesContent", " dummiesContents", "dumpMedia", "determinedText", "DummyText", "DumpText", "DumpInt", "dummyInt", "determinedMedia", "dumpContent"], "source": ["user", "SOURCE", "sin", "template", "src", "store", "ace", "search", "sql", "Source", "space", "instance", "ser", "join", "core", "sr", "ource", "s", "use", "se", "seed", "google", "image", "from", "scope", "proxy", "uri", "in", "sys", "result", "site", "sp", "spec", "status", "ie", "pse", "series", "sf", "resource", "inner", "server", "sample", "relation", "service", "table"], "content": ["message", "path", "header", "script", "template", "article", "value", "title", "format", "cache", "application", "context", "output", "description", "ontent", "config", "editor", "current", "Content", "quest", "summary", "tx", "html", "key", "ext", "txt", "action", "expression", "layout", "tree", " contents", "xml", "document", "version", "result", "command", "json", "sequence", "text", "body", "license", "cont", "resource", "code", "example", "data", "response", "node", "comment", "section", "status", "activity"], "qResult": ["iqRes", "queryResponse", "iqResult", "iqResponse", "Qresult", "dqresult", "queryResult", "qresult", "QView", " qResponse", " qReport", " qresult", " qRes", "qView", "dqView", "queryReport", "qReport", "qResults", "QRes", "dqResult", "queryRes", "queryResults", "QResult", "iqResults", "dqRes", "qResponse", " qResults", "qRes", "iqReport", " qView"], "results": [" Results", "actions", "chains", "ands", "ms", "versions", "products", "users", "times", "hips", "thumbnails", "s", "forms", "RESULTS", "lections", "reports", "rows", "xes", "resources", "children", "details", "roads", "orders", "photos", "events", "settings", "olds", "Contents", "result", "features", "posts", "its", "missions", "ults", "tests", "relations", "members", "runs", "assets", "res", "objects", "items", "views", "data", "archives", "ries", "Results", "terms", "values", "ULTS", "pages", "blocks"], "it": ["MIT", "iz", "iter", "read", "pit", "is", "at", "init", "out", "id", "info", "ci", "li", "m", "rit", "hit", "stat", "t", "exec", "It", "they", "ait", "p", "h", "ic", "in", "he", "op", "st", "its", "mit", "i", "IT", "ite", "ul", "v", "et", "lit", "ip"], "rSrc": ["rSRC", "rSysrc", "rSecs", "rSysRC", "rSlrs", "rSyssrc", "rSourcers", "crDesrc", "rSrs", "crSsrc", "rSource", "rDesrc", " rSrs", " rSsrc", "crSrs", "rSysource", "rSourcesrc", "rDessrc", "rSeRC", "rSlcs", "rSlrc", "crSrc", "crDesRC", "crDessrc", "crSRC", "rSers", "rSerc", " rSRC", "rSsrc", "rDesrs", " rScs", " rSource", "rSourceRC", "rScs", "crDesrs", "rSourcerc", "rSlRC", "rDesRC"], "rSrcIn": ["rSetrcOut", "rSRCIN", "rSldCon", "rSetsrcIN", "rSRCin", "rSRCCon", "rSldin", "rSrsInput", "rSldOut", "rSrcInput", "rSetrcIN", "rSrsIn", "rSsrcOut", "rSncOut", "rSrsIN", "rSetrcin", "rSetsrcOut", "rSsrcIN", "rSncIn", "rSsrcin", "rSrcOut", "rSldIN", "rSetsrcIn", "rSldInput", "rSncin", "rSsrcInput", "rSrcin", "rSncCon", "rSsrcIn", "rSRCOut", "rSrcCon", "rSetrcIn", "rSRCIn", "rSrcIN", "rSetsrcin", "rSldIn", "rSrsOut"], "actualOut": ["finalout", " actualEnd", "ualBytes", " actualout", "actualout", "ualout", "realIn", "actuallyOut", "finalIn", "realIs", "actualBytes", "UALBytes", "finalOut", "actualEnd", "actuallyIn", "ualIn", "actualIs", "UALIn", "realOut", "virtualIn", " actualCopy", "ualOut", "virtualOut", " actualIs", "actualIn", "actuallyIs", "actuallyCopy", "actualCopy", "realCopy", "UALEnd", " actualBytes", " actualIn", "UALOut", "ualEnd"]}}
{"id1": "338852", "id2": "400275", "code1": "    public static void sort(float norm_abst[]) {\n        float temp;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                if (norm_abst[j] > norm_abst[j + 1]) {\n                    temp = norm_abst[j];\n                    norm_abst[j] = norm_abst[j + 1];\n                    norm_abst[j + 1] = temp;\n                }\n            }\n        }\n        printFixed(norm_abst[0]);\n        print(\" \");\n        printFixed(norm_abst[1]);\n        print(\" \");\n        printFixed(norm_abst[2]);\n        print(\" \");\n        printFixed(norm_abst[3]);\n        print(\" \");\n        printFixed(norm_abst[4]);\n        print(\" \");\n        printFixed(norm_abst[5]);\n        print(\" \");\n        printFixed(norm_abst[6]);\n        print(\" \");\n        printFixed(norm_abst[7]);\n        print(\"\\n\");\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"sort": ["init", "format", "display", "update", "func", "Sort", "list", "stat", "test", "printf", "fun", "run", "rank", " compare", "ort", "cmp", "round", "position", "rint", "min", " sorted", " shuffle", "process", " Sort", "replace", "order", "println", "reverse"], "norm_abst": ["norm_avste", "norm_edsts", "norm_apst", "norm______abstr", "norm_afbr", "norm_abstr", "norm___apst", "norm___obsts", "norm______abbstream", "norm_afcr", "norm______abbst", "norm_absst", "norm_afist", "norm_abdr", "norm_pubsts", "norm___abst", "norm_apbr", "norm_abist", "norm_pubbr", "norm_obST", "norm_obist", "norm_ubste", "norm_obstr", "norm_ubld", "norm_ebst", "norm______abst", "norm_abssts", "norm_afbl", "norm_appst", "norm_labst", "norm_avst", "norm_abbstream", "norm_habst", "norm_abstall", "norm_obsty", "norm_avdr", "norm_appstall", "norm___abbr", "norm___abdr", "norm_abST", "norm_rabcr", "norm_absld", "norm_afsty", "norm_obsts", "norm_rabnd", "norm_obst", "norm_abstream", "norm_absbr", "norm_ubist", "norm______abstream", "norm_abbr", "norm_labck", "norm_habrest", "norm_absct", "norm_apdr", "norm_pubdr", "norm___afstr", "norm_ebstall", "norm___abnt", "norm_afnt", "norm_appsty", "norm___apbr", "norm_rabct", "norm_labist", "norm_ebsty", "norm_apste", "norm_abbl", "norm_abbstr", "norm_appist", "norm_absste", "norm_abct", "norm_ebist", "norm_afct", "norm___afbr", "norm___apdr", "norm_rabst", "norm_obbl", "norm___apsts", "norm_rabST", "norm_abck", "norm_abrest", "norm_abnt", "norm_ubstall", "norm_acsts", "norm_abld", "norm_absist", "norm_ubrest", "norm___obst", "norm_apsts", "norm_avsts", "norm_pubst", "norm___obstr", "norm_obct", "norm_avnt", "norm_acstr", "norm___absts", "norm_abscr", "norm_afST", "norm_afstr", "norm_abcr", "norm_acst", "norm_afnd", "norm_ubsty", "norm_labste", "norm_absck", "norm_absstr", "norm_rabbl", "norm_ubct", "norm_afst", "norm______abbstr", "norm_absnd", "norm_absts", "norm_edct", "norm_ubbr", "norm_ubstr", "norm_habstr", "norm_abste", "norm_avbr", "norm_obstream", "norm_absrest", "norm_abbst", "norm_absnt", "norm_avstr", "norm_obbr", "norm_edst", "norm___abstr", "norm_obld", "norm_abnd", "norm___afst", "norm_ubst", "norm_apist", "norm_absstream", "norm___afnt", "norm_labct", "norm_rabck", "norm_absty"], "temp": ["pt", "iter", "ptr", "mint", " temperature", "tc", " tmp", "cap", "Temp", "f", "tmp", "tem", "mp", "tf", "current", "pre", "t", "cum", "fake", "test", "term", "alt", "txt", "orig", "p", "cp", "prime", "Temperature", "tim", "unit", "late", "tr", "perature", "mod", "unt", "cu", "ret", "po", "dat", "deg", "buffer", "total", "print", "v", "base", "partial", "emp", "variable"], "i": ["ami", "ij", "is", "init", "ims", "us", "gi", "it", "qi", "xi", "id", "ci", "li", "wi", "ai", "ix", "jo", "iq", "hi", "ri", "x", "bi", "ar", "ir", "ii", "mi", "ic", "index", "io", "ind", " ii", "im", "iu", "ie", "g", "ret", "ji", "me", "si", "zi", "v", "pi", "ti", "ui", "di", "ini", "ip", "ia"], "j": ["b", "obj", "ij", "ng", "user", "note", "on", "jac", "prop", "it", "k", "err", "z", "ion", "m", "dj", "kid", "s", "str", "bj", "jo", "job", "kh", "pr", "oj", "next", "jet", "q", "br", "adj", "kj", "h", "aj", "off", "og", "jas", "bs", "jit", "er", "jj", "tr", " dj", "ijk", "y", "json", "uj", "ja", "ge", "jc", "exp", "xy", "last", "js", "g", "je", "get", "ji", "J", "e", "sp", "jp", "jl", "d", "v", "o", "other", "jump", "fr"]}}
{"id1": "13024538", "id2": "6987642", "code1": "    public static String getHash(String uri) throws NoSuchAlgorithmException {\n        MessageDigest mDigest = MessageDigest.getInstance(\"MD5\");\n        mDigest.update(uri.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getHash": ["createhash", "GetHash", "createKey", "createSum", " gethash", "createHash", "getKey", " getSum", "Gethash", "gethash", "GetSum", "getSum", " getKey", "GetKey"], "uri": ["message", "path", "http", "ou", "qi", "uu", "url", "subject", "filename", "address", "du", "file", "su", "dir", "description", "wiki", "ur", "uni", "link", "ri", "html", "this", "source", "har", "q", "u", " URI", "unit", "io", "password", "msg", "course", "requ", "URI", "iu", "remote", " ur", "resource", "name", "ui", "via"], "mDigest": [" mDigake", "mDigests", "mDigake", "mDake", " mDiger", "mDefer", "dDigUse", "mDigUse", "mModse", "mDigester", "hdigests", "mdigests", "hDiget", "hdiget", " mDake", " mDer", "mDigse", "mdigest", "hdigest", "ddigest", "hDigest", "mDesignests", "hDigests", "mDesignest", "mDiger", "mDet", "mDse", "mModake", "mDer", " mDest", " mDigse", "ddigUse", "dDigest", "mDiget", "mdigester", "mdigUse", "mDest", "mCritester", "mModer", "mDefake", "dDigester", " mDse", "mCritest", "mDefest", "mDesignester", "hDigester", "mDester", "mDesignet", "hdigester", "mdiget", "mDests", "mDefse", "mCritUse", "mModest", "ddigester"], "d": ["b", "nd", "cd", "D", "dh", "ds", "with", "des", "da", "m", "t", "done", "l", "md", "s", "c", "de", "n", "df", "p", "h", "def", "dd", "pd", "ed", "dict", "dot", "j", "ind", "dec", "dat", "g", "ld", "bd", " D", "dig", "dim", "dist", "td", "sd", "v", "data", "db", "diff", "dm"], "hash": ["message", "user", "block", "header", "check", "hz", "transform", "cache", "shift", "search", "array", "address", "output", "ssh", "map", "ash", "echo", "always", "ah", "summary", "oh", "test", "html", "memory", "window", "key", "random", "host", "h", "esh", "used", "archive", "dump", "password", "sh", "bar", "shadow", "report", "hex", "bh", "build", "Hash", "shape", "buffer", "total", "sum", "print", "now", "tag", "filter", "square", "reset"], "i": ["ex", "is", "ims", "init", "my", "us", "gi", "qi", "it", "xi", "ski", "\u0438", "ci", "li", "ms", "err", "I", "m", "ai", "ix", "gu", "hi", "x", "bi", "ri", "ii", "q", "a", "u", "multi", "mi", "ic", "in", "index", "io", "fi", "y", "ind", "im", "phi", "sim", "ie", "ji", "si", "yi", "zi", "v", "pi", "ei", "span", "ti", "cli", "point", "j", "ui", "di", "ini", "ip"]}}
{"id1": "442381", "id2": "10212189", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doBuildUpdate", " doApplicationInfo", "doFeaturecheck", "doApplicationQuery", "doVersioncheck", " doApplicationTest", " doVersionsTest", "doImageInfo", " doVersioncheck", "doFeatureCheck", "doBuildCheck", "doBuildcheck", "doFeatureQuery", " doVersionTest", " doVersionInfo", " doApplicationCheck", "doVersionUpdate", "doImageTest", " doVersionsCheck", "doVersionQuery", "doVersionInfo", "doFeatureTest", "doApplicationTest", "doVersionsTest", "doFeatureUpdate", " doVersionUpdate", " doApplicationQuery", "doVersionTest", "doFeatureInfo", "doImageCheck", "doVersionscheck", "doVersionsUpdate", "doImageQuery", " doVersionQuery", " doVersionsUpdate", " doVersionscheck", "doBuildTest", "doApplicationInfo", "doApplicationCheck", "doVersionsCheck"], "view": ["block", "check", "review", "display", "http", "input", "component", "query", "update", "subject", "widget", "context", "project", "file", "lock", "browser", "cell", "VIEW", "client", "virtual", "html", "self", "window", "image", "row", "this", "page", "q", "vm", "cv", "h", "box", "manager", "tv", "layout", "index", "tree", "version", "document", "eye", "show", "report", "form", "see", "port", "engine", "controller", "ml", "buffer", "server", "print", "v", "model", "views", "View", "iew", "pool", "call"], "url": ["b", "dl", "http", "URL", "r", "address", "f", "file", "l", "ur", "gl", "link", "str", "browser", "client", "job", "html", "nl", "loc", "domain", "hl", "lb", "host", "mount", "uri", "char", "rl", "ref", "get", "mail", "Url", "log", "build", "ssl", "oul", "ul", "v", "bel", "rel", "ll", "pl", "sl"], "in": ["In", "is", "sin", "init", "on", "out", "input", "rin", "info", "f", "ln", "ain", "IN", "inn", "reader", "l", "inf", "vin", " IN", "stream", "ins", "n", "source", "inc", "from", "body", "mat", "din", "isin", "cin", "mn", "i", "gin", " din", "asin", "inner", "can"], "bin": ["b", "sin", "init", "obin", "thin", "out", "cache", "rin", "all", "win", "binary", "lib", "ln", "file", "bl", "session", "inn", "reader", "cos", "brain", "rb", "abin", "cb", "bi", " Bin", "ins", "bg", "jin", "len", "sam", " bins", "ebin", "body", "din", "conv", "stock", "by", "nb", "bn", "re", "mon", "cin", "con", "buffer", "gin", " din", "spin", "ran", "inner", "buff", "bed", "db", "bur", "local"], "line": ["LINE", "message", "block", "range", "liner", "channel", "iter", "parse", "lo", "lane", "err", "ln", "file", "cat", "inline", "l", "ine", "frame", "string", "eline", "cell", "tile", "link", "record", "trace", "lin", "entry", "job", "key", "rule", "word", "stream", "row", "section", "page", "le", "next", "detail", "cmd", "Line", " block", "char", "part", "field", "sequence", "style", "port", "log", "ice", "chain", "lines", "zone", "stay", "print", "code", "base", "sample", "column", "comment", "point", "status"], "develBuild": ["deVELBuild", "DeVELbuild", "duVELBuild", "devBoot", "duffbuild", "depobuild", "develBuilt", "deeltaRelease", "duVELbuild", "deffBuild", "deffBuilder", "develRelease", "duvelbuild", "desVELLoad", "desVELbuild", "duvelBoot", "deployBoot", "devLog", "deeltaLoad", "DevelBuilt", "duvelBuild", "DeVELBuild", "depoBuild", "duffBuild", "deVELLoad", "deVELBoot", "deVELBuilt", "devbuild", "duvelBuilder", "deeltaBuild", "develBuilder", "duvelBuilt", "DevelLog", "deVELbuild", "deffbuild", "desvelbuild", "Develbuild", "desvelBuild", "deployLoad", "duffBuilt", "deployBuilt", "depoBuilt", "develLog", "depoLog", "duVELBuilder", "deploybuild", "develBoot", "desVELBuild", "devBuild", "deVELBuilder", "DeVELLog", "deVELRelease", "deployRelease", "duVELBoot", "deployBuilder", "desvelRelease", "devBuilder", "deployBuild", "DevelBuild", "deffBuilt", "DeVELBuilt", "deVELLog", "desvelLoad", "duffBuilder", "develLoad", "devBuilt", "desVELRelease", "deeltabuild", "develbuild"], "stableBuild": ["secureCraft", "stableBind", "stableCraft", " stableBuilder", " stablebuild", "activeMake", "devMake", "confirmedLong", "stableLong", "stablebuild", " unstableBuild", " unstableCraft", "stableMake", " unstableBuilder", " unstableLong", "securebuild", " stableBoot", " unstableBoot", " stableCraft", "devbuild", " stableLong", "devBind", "confirmedBuild", " stableBind", " stableMake", "secureBuilder", " unstableBind", "devBuild", "confirmedBoot", "stableBoot", "confirmedbuild", "secureBuild", " unstablebuild", "devBuilder", "stableBuilder", "activeBuilder", "activeBuild", "activebuild"]}}
{"id1": "2221297", "id2": "9450274", "code1": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    public void seeURLConnection() throws Exception {\n        URL url = new URL(\"http://wantmeet.iptime.org\");\n        URLConnection uc = url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n        String s = null;\n        StringBuffer sb = new StringBuffer();\n        while ((s = br.readLine()) != null) {\n            sb.append(s);\n        }\n        br.close();\n        log.debug(\"sb=[\" + sb.toString() + \"]\");\n    }\n", "label": 1, "substitutes": {"getURLContent": ["getHTMLData", "getURLValue", "getUrlContents", " getURLData", "getURLData", " getUrlContent", "getURIValue", "getURIContents", "getHTMLContents", " getURLContents", " getUrlData", "getURIData", " getURLValue", "getURIContent", " getUrlValue", " getUrlContents", "getUrlValue", "getURLContents", "getHTMLValue", "getHTMLContent", "getUrlContent", "getUrlData"], "urlToSearchString": ["urlForFindURL", "urlToFindStr", "urlToLookContent", "urlForSearchSite", "urlToLookString", "urlToFindURL", "urlTosearchString", "urlToTestSite", "urlToLookStr", "urlToTestURL", "urlToTestStr", "urlToFindContent", "urlForSearchString", "urlTosearchSite", "urlToSearchURL", "urlForSearchURL", "urlForFindStr", "urlTosearchStr", "urlToTestString", "urlToFindSite", "urlTosearchURL", "urlForSearchContent", "urlToFindString", "urlToSearchSite", "urlToSearchStr", "urlTosearchContent", "urlToSearchContent", "urlForFindString", "urlForFindSite", "urlForSearchStr", "urlForFindContent"], "url": ["ls", "dl", "cert", "http", "URL", "out", "r", "f", "open", "l", "ur", "link", "str", "https", "gl", "client", "google", "job", "web", "org", "nl", "loc", "hl", "lb", "host", "uri", "cmd", "el", "ol", "ret", "ld", "build", "Url", "con", "ssl", "ul", "bel", "rel", "ll", "mount", "sl"], "conn": ["inv", "obj", "Conn", "Connection", "ctx", "cert", "open", "comm", "nt", "oss", "client", "cb", "gn", "loc", "os", "gate", "cp", "cn", "ct", "cmd", "resp", "addr", "nc", "lang", "sys", "iw", "socket", "ch", "conv", "enc", "serv", "con", "jp", "connection", "res", "cur", "connect", "db", "ns", "pas"], "encoding": ["enending", "incoded", "cryption", "ecoding", "enoding", "encoded", "ecoder", "encoder", "cication", "encending", "coder", "ecmentation", "engoding", "enoder", "Encoder", "engoder", "coded", "decoder", "Encoding", "enryption", "decryption", "engmentation", "decending", "encaming", "encmentation", "increoder", "increoded", "increication", "Encending", "enaming", "Encryption", "decoding", "caming", "encication", "encryption", "incoding", "incication", "enmentation", "increoding", "coding", "ecaming", "incoder", "ecryption", "engryption"], "br": ["b", "bro", "rob", "dr", "bridge", "vr", "lr", "bp", "gb", "r", "bf", "bl", "sr", "bc", "rb", "ctr", "browser", "cb", "pr", "bi", "ber", "bg", "bs", "BR", "tr", "cr", "bh", "Br", "nb", "bn", "bd", "bb", "jp", "buf", "fb", "bt", "mr", "ob", "hr", "fr"], "sb": ["b", "orb", "rob", "sth", "ib", "bp", "gb", "shell", "sync", "bf", "sv", "bis", "rb", "obb", "bj", "SB", "cb", "sq", "bg", "erb", "lb", "gc", "bs", "sh", "sam", "zb", "sp", "ub", "gob", "eb", "bh", "nb", "bn", "bd", "bb", "bsp", "mb", "ssl", "sa", "sf", "xb", "sd", "bt", "kb", "lp", "db", "sg", "pb"], "line": ["message", "LINE", "range", "header", "liner", "block", "check", "online", "iter", "number", "lane", "ln", "file", "stroke", "l", "ine", "frame", "string", "eline", "cell", "link", "inline", "record", "lin", "entry", "rule", "word", "row", "page", "source", "Line", "len", "valid", "sequence", "text", "body", "e", "log", "entity", "ice", "chain", "print", "code", "sample", "comment", "point", "phrase", "ip"]}}
{"id1": "21092340", "id2": "3187685", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addInHarive", "addToExFile", "addToArchFile", "addInArchiver", "addInArchive", "addToHarive", "addToZipFile", "addToExive", "addInArchZip", "addInArchFile", "addToZipive", "addToZipiver", "addInHariver", "addToExZip", "addToZipZip", "addToHarZip", "addToArchZip", "addInHarZip", "addToArchiver", "addToExiver", "addToHarFile", "addToHariver", "addInHarFile"], "pod": ["ad", "message", "check", "device", "wp", "component", "pick", "project", "pkg", "task", "pc", "zone", "job", "proc", "top", "Pod", "p", "cp", "ods", "archive", "op", "spec", "policy", "body", "report", "post", "ack", "od", "disk", "pad", "module", "start", "pack", "poll", "volume", "point", "table"], "podArchiveOutputStream": ["podArchiveEntryPoint", "podArchiverOutputSync", "podArchiveOutputPoint", "podArchiverInputForm", "podArchiverInputSync", "podArchiveOutputForm", "podArchiveInputForm", "podArchiverOutputPoint", "podArchiveOutputMap", "podArchiverOutputMap", "podArchiveEntrySteam", "podArchiveOutputContext", "podArchiveStreamMap", "podArchiveOutStream", "podArchiverInputContext", "podArchiveoutputStream", "podArchiverInputSteam", "podArchiveResourceSteam", "podArchiveMainForm", "podArchiveOutputstream", "podArchiveResourcestream", "podArchiveStreamStream", "podArchiveOUForm", "podArchiveOutputSteam", "podArchiveoutputSteam", "podArchiveInputStream", "podArchiveInputPoint", "podArchiveoutputForm", "podArchiveOUSync", "podArchiverInputMap", "podArchiverInputstream", "podArchiveInputStreamer", "podArchiverOutputForm", "podArchiveStreamForm", "podArchiveInputSteam", "podArchiveMainStreamer", "podArchiverOutputStreamer", "podArchiveStreamSync", "podArchiveMainStream", "podArchiveOutContext", "podArchiverOutputstream", "podArchiveInputstream", "podArchiveOUStream", "podArchiveInputContext", "podArchiveOUMap", "podArchiverOutputSteam", "podArchiveResourceContext", "podArchiveInputMap", "podArchiveEntryStream", "podArchiveOutPoint", "podArchiveoutputStreamer", "podArchiveResourceStream", "podArchiverInputStream", "podArchiveMainSteam", "podArchiveOutstream", "podArchiverInputPoint", "podArchiveOutputSync", "podArchiveOutSteam", "podArchiverOutputStream", "podArchiveInputSync", "podArchiveOutputStreamer", "podArchiverOutputContext", "podArchiverInputStreamer"], "filename": ["message", "path", "title", "url", "binary", "subject", "ename", "output", "FN", "file", "description", "fp", "Filename", "string", "release", "original", "directory", "nm", "key", "family", "fn", "txt", "p", "png", "jpg", "uri", "nil", "archive", "version", "username", "fil", "folder", "ame", "kl", "upload", "FILE", "NAME", "names", "resource", "location", "stem", "latest", "name", "prefix", "println"], "source": ["SOURCE", "template", "supp", "src", "store", "input", "component", "sql", "Source", "info", "address", "select", "force", "shell", "context", "file", "ser", "ource", "seed", "use", "proc", "loader", "image", "stream", "from", "copy", "password", "spec", "sequence", "view", "body", "style", "get", "iterator", "series", "resource", "inner", "start", "sample", "service"], "entry": ["obj", "ment", "ce", "or", "sheet", "ace", "component", "query", "card", "tmp", "nt", "file", "task", "quick", "zip", "se", "link", "cell", "record", "Entry", "job", "system", "key", "word", "row", "ent", "good", "char", "archive", "attribute", "cue", "element", "set", "ie", "log", "line", "enter", "connection", "resource", "data", "ry", "comment", "channel", "book"]}}
{"id1": "14188043", "id2": "18962382", "code1": "    public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException {\n        AQUtility.debug(\"net\", urlPath);\n        URL url = new URL(urlPath);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setConnectTimeout(NET_TIMEOUT);\n        int code = connection.getResponseCode();\n        if (code == 307 && retry) {\n            String redirect = connection.getHeaderField(\"Location\");\n            return openHttpResult(redirect, false);\n        }\n        if (code == -1 && retry) {\n            return openHttpResult(urlPath, false);\n        }\n        AQUtility.debug(\"response\", code);\n        if (code == -1 || code < 200 || code >= 300) {\n            throw new IOException();\n        }\n        byte[] result = AQUtility.toBytes(connection.getInputStream());\n        return result;\n    }\n", "code2": "    protected void connect() throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + account.getServer());\n        client = new FTPClient();\n        client.connect(account.getServer());\n        if (client.login(account.getId(), account.getPassword()) == false) {\n            logger.info(\"Fail to login with id=\" + account.getId());\n            throw new LoginFailException(account.getId(), account.getPassword());\n        }\n    }\n", "label": 0, "substitutes": {"openHttpResult": ["openHttpMessage", "getHttpRes", "openQueryRes", "openQueryResult", "getHttpResult", "OpenHTTPResponse", "openQueryResults", "OpenHTTPMessage", "getHTTPResponse", "openUrlResponse", "OpenHttpRes", "openhttpResult", "openHttpResults", "openHttpRes", "openHTTPResults", "openHTTPResponse", "OpenHTTPResult", "getHTTPRes", "openHTTPRes", "openHTTPResult", "openQueryResponse", "getHttpResults", "openhttpRes", "OpenHTTPRes", "openhttpResults", "OpenHttpResponse", "openUrlRes", "OpenHttpMessage", "getHttpResponse", "OpenHttpResults", "openUrlResult", "openHttpResponse", "openHTTPMessage", "getHTTPResults", "openUrlResults", "OpenHttpResult", "getHTTPResult", "OpenHTTPResults", "openUrlMessage", "openhttpMessage", "openhttpResponse"], "urlPath": ["urlName", "UrlFile", "xmlFile", "pathStr", "URLPath", "nlP", "urlString", "nlpath", "UrlString", " urlP", "dlStr", "UrlPath", " urlDir", "URLCh", "pathFile", "xmlStr", "urlP", "dlPath", "UrlName", "xmlPath", "URLDir", "urlDir", "urlFile", "URLString", "pathPath", "dlFile", "UrlP", " urlString", "Urlpath", "URLName", "urlCh", " urlCh", "nlFile", "UrlId", "UrlDir", "URLId", " urlId", " urlpath", "urlStr", " urlFile", "nlPath", " urlName", "UrlCh", "pathpath", "dlpath", "xmlpath", "urlId", "urlpath"], "retry": ["rettry", "redric", "retric", "attrain", "Retrying", "retrain", "retried", "pretried", "attry", "redrier", "terried", "terry", "tric", " retrying", "rery", "Retry", "retrying", "terrain", "rerying", "attrying", " rettry", "Retri", "attried", "pretric", "trier", "redwrite", "retwrite", "redry", "pretrain", "pretrier", "retri", "Rettry", "reri", "terrying", "pretrying", "twrite", "pretry", " retri", "retrier", "pretwrite"], "url": ["ls", "user", "sl", "dl", "http", "URL", "r", "open", "li", "file", "l", "ur", "link", "str", "https", "job", "loader", "web", "org", "nl", "loc", "uri", "char", "rl", "il", "get", "log", "Url", "pl", "conn", "ssl", "ul", "location", "base", "ll", "mount", "service", "www"], "connection": ["operation", "message", "online", "generation", "creator", "Connection", "http", "number", "application", "open", "subject", "context", "translation", "database", "ion", "description", "session", "l", "link", "network", "client", "directory", "entry", "connected", "c", "character", "builder", "close", "created", "uri", "established", "computer", "to", "cone", "io", "nc", "command", "set", "socket", "position", "using", "statement", "writer", "city", "usage", "controller", "conn", "con", "condition", "resource", "server", "communication", "creation", "pointer", "create", "response", "connect", "channel", "relation"], "code": ["change", "message", "check", "ce", "cd", "number", "component", "time", "id", "type", "force", "error", "currency", "sec", "coe", "zip", "count", "zone", "ode", "coded", "se", "rc", "success", "cc", "mode", "test", "size", "c", "zero", "entry", "rate", "x", "one", "page", "a", "go", "close", "xxx", "ord", "ct", "num", "cycle", "Code", "ne", "nc", "state", "sequence", "length", "desc", "ch", "dec", "cod", "ie", "codes", "e", "controller", "cont", "co", "level", "now", "create", "cast", "name", "status", "cause", "xx", "call"], "redirect": ["redistant", "regir", "promir", "redir", "promirect", "promistant", "Redirect", "predir", "regirection", "Redirection", "Redistant", "predirect", " redir", "predistant", "Redir", "Reduction", "predirection", "reduction", "redirection", "promirection", "regirect", " reduction", " redirection", "reguction"], "result": ["message", "transform", "Result", "match", "cert", "value", "out", "r", "output", "description", "request", "currency", "params", "success", "proc", "true", "test", "answer", "feature", "meg", "memory", "results", "reason", "root", "mask", "password", "command", "sequence", "length", "report", "ret", "process", "buffer", "date", "total", "res", "profile", "other", "data", "comment", "complete", "table", "cup", "vector"]}}
{"id1": "19849797", "id2": "15799935", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpStream", "transferFiles", " cpFiles", "transferfile", "copyFiles", "transferFile", " cpFile", " copyfile", "transferStream", " copyFiles", " copyStream", " cpfile", "copyStream", "copyfile"], "sourceFile": ["srcPage", "ourcePath", " sourceTable", "ourcefile", " sourcefile", "srcTable", "sourcefile", "ourceField", "sourceLine", "ourceTable", "sourceTable", "sourceField", " sourceLine", "srcPath", " sourcePage", "ourceFile", " sourceField", "ourcePage", "sourcePage", "srcFile", "ourceLine", "srcfile", "srcField", "srcLine", "sourcePath", " sourcePath"], "destFile": ["DestFile", "restPlace", "destFilename", "declFolder", "optEntity", " destPath", "DestFilename", "declFile", "optFilename", "destEntity", "destPath", "srcDir", "restFiles", " destPlace", "optPath", "DestFiles", "declEntity", "srcEntity", " destFiles", "DestPath", "datFiles", "srcFiles", "restFile", "srcFolder", "optDir", "optFolder", "restFilename", "srcPath", " destDir", "DestDir", "datFile", "destFolder", "destDir", "srcFile", "destPlace", "optFile", "datFilename", "destFiles", "declDir", "datPlace", " destFilename"], "source": ["SOURCE", "match", "iter", "ce", "check", "init", "src", "parse", "store", "note", "component", "input", "search", "query", "Source", "force", "subject", "update", "shell", "reader", "ource", "use", "se", "back", "cause", "load", "before", "send", "slave", "standard", "origin", "score", "image", "stream", "missing", "scope", "from", "proxy", "in", "char", "copy", "scale", "attribute", "owner", "result", "spec", "sequence", "console", "body", "target", "style", "show", "ie", "none", "parent", "OURCE", "iterator", "series", "resource", "inner", "start", "sample", "pose", "create", "comment", "channel", "index", "service", "local", "table"], "destination": ["descation", "decinated", " destinated", "descinator", "Destinator", "Destificate", " destinator", "termininated", "destinated", "Destinate", "restinator", "restinated", "terminination", "decination", "Destinated", "Destment", "terminined", "descinate", "separment", "nonination", "veration", "separation", " destificate", "descination", "separinated", " destation", "verinated", "destinator", "termininate", "destation", "verificate", "destificate", " destined", "destinate", "noninator", "destment", "restination", " destinate", "noninate", "destined", "Destation", " destment", "separination", "decinate", "decined", "Destination", "noninated", "verination", "restinate"]}}
{"id1": "6742637", "id2": "22441244", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "label": 0, "substitutes": {"findExtensions": [" findEXTras", "findAppions", "findAppensions", "findEXTras", " findEXTensions", "findextensions", "findExtension", "findEXTions", "findAppension", "findextions", "findextras", "findextension", "findEXTension", " findEXTension", " findExtension", " findExtions", "findEXTensions", "findExtras", " findEXTions", " findExtras", "findExtions", "findAppras"], "url": ["ls", "path", "dl", "cert", "http", "URL", "parse", "lr", "address", "filename", "file", "config", "norm", "abs", "l", "ur", "gl", "string", "link", "browser", "str", "https", "cl", "loader", "email", "web", "nl", "req", "key", "loc", "val", "row", "lim", "domain", "hl", "host", "uri", "addr", "util", "char", "rl", "xml", "el", "ch", "ref", "sb", "pl", "mail", "Url", "ssl", "resource", "server", "ul", "location", "rel", "ll", "name", "mount", "sl"], "extensions": ["appendends", "expension", "extances", "xtends", "extperties", "dimends", "Extences", "exended", "expperties", "dimended", "xtensions", "expends", " extension", "extension", "expences", "exances", "Extensions", "appendperties", "exensions", "xtances", "expended", "Extension", "exends", "appendensions", "extended", "xtperties", "extences", "expensions", "Extends", "dimances", "appendended", "dimensions", " extences", "xtended"], "res": ["range", "pres", "rest", "us", "ver", "r", "vers", "ser", "rem", "Res", "reg", "abs", "rt", "proc", "req", "RES", "ber", "ins", "rs", "mer", "er", "sys", "rys", "pers", "ch", "ref", "resolution", "re", "ress", "ps", "rez", "gr", "rex", "ers", "cons", "mr", "rel", "ry", "ms", "vol", "es", "ro", "reset"], "prop": ["feat", "pt", "rop", "conf", "cap", "pred", "tmp", "cfg", "pkg", "mp", "col", "properties", "add", "plot", "kw", "pos", "proc", "prot", "etc", "key", "ext", "term", "priv", "val", "pid", "p", "cp", "pro", "comp", "cmd", "def", "att", "op", "attr", "exp", "property", "desc", "tab", "po", "bug", "ps", "jp", "buf", "np", "rel", "Prop", "pic", "pr", "pb"], "msg": ["message", "Message", "gs", "gm", "mt", "err", "urg", "pkg", "m", "md", "str", "string", "utt", "hog", "reason", "mess", "bg", "txt", "nom", "ug", "gov", "cmd", "good", "og", "char", "cmp", "mun", "notice", "Msg", "text", "body", "uint", "desc", "kg", "g", "log", "med", "mn", "print", "ms", "sg", "sm", "cfg"]}}
{"id1": "5951610", "id2": "22135199", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": ["testNetworkURL", "testApplicationHTTP", "testApplicationHTML", "testNetHTTP", "TestNetHTML", "TestNetworkHTML", "TestNetworkURL", "TestNetURL", "TestNetworkHTTP", "testNetworkHTML", "testNetHTML", "testNetURL", "TestNetHTTP", "testApplicationURL"], "url": ["ls", "b", "obj", "path", "pull", "dl", "cert", "http", "URL", "lr", "all", "r", "address", "m", "bl", "norm", "t", "l", "ur", "link", "gl", "back", "str", "https", "fl", "cl", "email", "web", "org", "nl", "html", "ocl", "term", "loc", "blog", "hl", "acl", "lb", "host", "u", "uri", "util", "github", "rl", "il", "www", "el", "console", "lt", "ref", "ret", "pl", "mail", "Url", "ml", "log", "impl", "get", "conn", "ssl", "resource", "print", "ul", "location", "base", "rel", "ll", "mount", "channel", "sl"], "urlConnection": ["mlConnection", "lsConnect", "fileConnection", "browserConnector", "methodConnect", "consoleConn", "httpListener", "httpConnector", "sslConnect", "lrResponse", "emailConnect", "methodConnector", "urlInfo", "nameConn", "methodConn", "browserConnection", "mlConn", "nameConnector", "dbConnection", "urlListener", "consoleConnection", "resourceConn", " urlSet", "resourceConnector", " urlPosition", "browserConnect", "utilService", "emailConnection", "lrConn", "implConn", "mlCon", "lsConnector", "consoleCon", "emailConn", "utilListener", " urlDiscussion", " urlMachine", "urlSet", "emailConnector", "nameConnect", "resourceResponse", "urlConnect", "httpService", "managerInfo", "managerConnect", "dbConnect", "dbPosition", "httpSet", " urlHandler", "resourceConnection", "sslConnector", "managerConnector", "httpConnect", "nameConnection", " urlCon", "dbConn", "lsConnection", "utilConnection", "utilConn", "lrConnector", "utilSet", "implConnection", "railConnection", " urlConnector", "implConnect", "httpInfo", "fileDiscussion", " urlResponse", " urlInfo", "sslConn", "urlMachine", "lsConn", "railConnect", "mlMachine", " urlListener", "httpHandler", "urlHandler", "urlResponse", "railListener", "urlPosition", "urlService", "railHandler", "urlConn", "utilConnect", "browserConn", "sslDiscussion", " urlConnect", "lrConnection", "implConnector", " urlService", "sslPosition", "methodConnection", "sslConnection", "utilConnector", "urlCon", "managerConnection", "urlConnector", "urlDiscussion", "fileConnect", "fileConn", "httpConnection", "consoleMachine", "httpConn", " urlConn"], "rd": ["nd", "nder", "rob", "rer", "dr", "erd", "ptr", "ped", "lr", "rus", "r", "usr", "red", "grad", "std", "ined", "ered", "fd", "rm", "rx", "dir", "rc", "rt", "rb", "repl", "RD", "gd", "rg", "ri", "rown", "rs", "rw", "ord", "rn", "dd", "rid", "rax", "drm", "rl", "rend", "ded", "ind", "rr", "xd", "wr", "rod", "din", "dra", "ld", "ird", "bd", "dig", "art", "rh", "rez", "ck", "d", "mr", "rand", "ra", "hr", "fr", "adr"], "line": ["LINE", "message", "block", "iter", "liner", "LIN", "online", "check", "range", "where", "number", "time", "lo", "error", "file", "ln", "load", "inline", "l", "frame", "ine", "string", "eline", "zone", "link", "record", "cl", "email", "lin", "entry", "nl", "continue", "cell", "next", "row", "page", "le", "Line", "len", "pipe", "loop", "part", " LINE", "length", "set", "side", "status", "port", "none", "log", "lock", "ice", "buffer", "lines", "stay", "edge", "node", "point", "comment", "channel", "column"]}}
{"id1": "189963", "id2": "3958807", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrites", "readAndRepWrite", "readAndResWrite", "readAndRewend", "readAndResend", "readAndrewrite", "readAndrewWrite", "readAndResrite", "readAndRewrites", "readAndrewrites", "readAndReprite", "readAndrewend", "readAndRewWrite", "readAndRepend", "readAndReprites"], "inFile": ["InFile", "inputFilename", "docFile", "docFILE", "iFILE", "iFilename", "INTime", "inFILE", "InFilename", "initPlace", "initFilename", "inputPlace", "docTime", "inFace", "outfile", "infile", "iFile", " inFilename", "initFile", "inPlace", "INPlace", "docFilename", " infile", "inTime", "Infile", "initFace", "INFace", "iTime", "INFilename", "INFile", "INFILE", "inputFile", "inputFace", "inFilename", "outFilename"], "outFile": ["reportFile", " outFilename", "checkFilename", "outFILE", "inFILE", "toFILE", "reportFILE", "tofile", "nameFilename", "outfile", "infile", " outFILE", "reportfile", "reportFilename", "toFilename", "namefile", "nameFile", "toFile", "checkFile", " outfile", "checkFILE", "inFilename", "outFilename", "nameFILE", "checkfile"], "iis": [" iris", "iiIs", "liris", "iIS", "eis", "aiis", "Iiss", "liisc", "Ii", "liIs", "liis", "eIS", "iiisc", "ii", " iiss", "iiss", "iiis", "iiris", " iIs", "iIs", " iIS", "diIs", " ii", "iisc", "IIs", "eIs", "aiIS", "dii", "aiIs", "diis", " iisc", "iris", "Iis", "diiss"], "dcmParser": ["dgrParser", " dpmListener", "dpcReader", "dpmAssistant", "DpmReader", "dcrparser", "dcommReader", " dpmarser", "dcmListener", "dmoduleReader", "dmoduleAssistant", " dpmStatement", "dpmLoader", "dmmParser", " dcmarser", " dpmparser", "dcommListener", "deromParser", "dpmBuilder", "dromparser", "dcmAdapter", "dcrParser", "dfmParser", "dpmStatement", "dmmmReader", " dcmLoader", "dcomReader", "dcmBuilder", "dromAssistant", "DpmAdapter", "dcrBuilder", "dpmPrivate", " dcmPar", "dcomBuilder", "dcrReader", " dpmReader", "dcommAssistant", " dpmLoader", " dcmStatement", " dcmAssistant", "dmmarser", "dmmparser", "DcmBuilder", "dpmarser", "dgrStatement", " dcmBuilder", "dmmmparser", "dcmparser", "dcfStatement", "dromReader", "dcmAssistant", "decmParser", " dcmListener", "deromarser", "Dpmparser", "decmReader", "DcmParser", "dpmAdapter", " dpmParser", "dcmStatement", "dgrReader", " dpmPar", "DpmPar", "dmReader", "decmarser", "dpcAssistant", "DpmBuilder", "dmmReader", "decmparser", "drumParser", "dromarser", " dpmBuilder", " dcmPrivate", "dpcParser", " dpmAssistant", "dcmLoader", "DcmReader", "dromParser", "dmmmParser", " dcmparser", "dmmAdapter", "DpmParser", "drumReader", "dfmReader", "dpmReader", "dgrPar", "dcmReader", "dcfReader", "deromReader", "Dcmparser", "deromparser", "dcommParser", "dmparser", "drumPar", " dcmReader", "dcmarser", "dmarser", "dcmPrivate", "dpmparser", "dcmPar", "dmParser", "dmmmAdapter", "dpcPrivate", "dcfPar", "dromListener", "dcomParser", "dmodulePrivate", "DcmAdapter", "drumBuilder", "dfmBuilder", "dfmLoader", "dpmListener", "dcomLoader", "dpmPar", "dmoduleParser", "dpmParser", "dcfParser", "DcmPar", " dpmPrivate"], "ds": ["ls", "cs", "dos", "dl", "gs", "eds", "dh", "ils", "fs", "des", "vs", "ys", "da", "der", "sv", "s", "gd", "dds", "sets", " des", "as", "ads", "hd", "dq", "rs", "uds", "tes", "xs", "df", "os", "details", "ins", "pd", "dd", "services", "in", "bs", "Ds", "ods", "sys", "obs", "outs", "dt", "hs", "pers", " DS", "eps", "its", "js", "dat", "bd", "ps", "dx", "ks", "ss", "drivers", "sd", "d", "aos", "qs", "data", "ws", "DS", "db", "es", "ims", "ns"], "pdReader": ["ddHelper", "ddParser", "pdLoader", "xdHelper", "pdParser", "tdWriter", "xdLoader", "tdRead", "ddLoader", "vdLoader", "pdRead", "dpCar", "dpLoader", "ddWriter", "ddReader", "pdCar", "ddRunner", "dpRunner", "pedReader", "tdParser", "hdParser", "tdReader", "pedLoader", "pedCar", "hdRead", "pdRunner", "vdHelper", "xdReader", "pdHelper", "hdWriter", "ddRead", "xdWriter", "dpReader", "vdReader", "pedRunner", "hdReader", "ddCar", "vdWriter"], "out": ["over", "full", "on", " err", "err", "t", "str", "ins", "p", "ent", "outs", "ch", "writer", "log", "conn", "con", "co", "sum", "sw", "v", "o", "auto", "name", "status", "gen", "inv", "obj", "ex", "ou", "all", "id", "nt", "s", "cb", "c", "end", "txt", "os", "nr", "cn", "in", "desc", "conv", "serv", "raw", "inner", "outer", "pool", "cfg", "at", "net", "tmp", "list", "pos", "Out", "n", "en", "up", "io", "sys", "w", "js", "aos", "res", "data", "we", "OUT", "cache", "it", "output", "oss", "client", "gt", "one", "null", "screen", "go", "cmd", "to", "opt", "flush", "msg", "gr", "inter"], "dcmEncParam": ["dcmEnPar", "dcmEnVal", "dcmencCmd", "dcmEncVal", "dcmEnParam", "dcmencParam", "dcmEscPar", "dmmencParam", "dcmDecParam", "dmmEncCmd", "dcmEncCmd", "dcmencNum", "dmmEncMsg", "dmmencNum", "dmmEncPar", "dcmEncPar", "dcmEscNum", "dmmEnPar", "dcmDecCmd", "dcmEncMsg", "dcmEnNum", "dmmEnNum", "dcmEscVal", "dcmDecMsg", "dcmEscParam", "dmmEncParam", "dmmencCmd", "dmmEnParam", "dmmEncNum", "dcmEncNum", "dcmDecNum", "dcmencPar", "dcmencMsg", "dmmEncVal", "dmmencMsg"], "pdWriter": ["dpEditor", "PDReader", "tdWriter", "dpWriter", "pidWrite", "PDWriter", "pdwriter", "pidWriter", "PDWrite", "tdWriting", "tdReader", "PDEditor", "pidwriter", "pidWriting", "dpWrite", "tdwriter", "pcWriter", "pcWrite", "pdWrite", "pdWriting", "pcwriter", "tdWrite", "pdEditor", "pcWriting", "dpReader", "tdEditor"]}}
{"id1": "4602568", "id2": "5441579", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 0, "substitutes": {"storeImage": ["StorePicture", "saveImage", " storeFile", "savePicture", "StoreFile", " storePicture", "StoreImages", " storeImages", "saveFile", "saveImages", "storeImages", "StoreImage", "storeFile", "storePicture"], "inStream": [" inForm", "inView", "fileFile", "cinStream", "cinView", " inFile", "fileStream", "inputStream", "inFile", "inSteam", "outFile", "fileForm", "cinFile", " inSteam", "cinSteam", "inForm", "outForm", "inputView", "inputSteam", "inputFile", "outSteam", " inView", "fileSteam"], "fileName": [" fileType", "filePath", "resourcePath", "filename", "imageInfo", " filePath", "fileType", "resourceTime", "FILEName", "FileInfo", "Filename", "imageType", "imagePath", "fileTime", "FileName", "FilePath", "FILEInfo", "FileType", " fileInfo", " filename", "fileInfo", "imagename", "FileTime", "resourceType", "FILEPath", "resourceName", "FILEname", "imageName", "imageTime"], "resize": [" ressize", "Resize", " resized", "ressize", "renizes", "resized", "Resized", "rensize", "renize", " resizes", "resizes", "Ressize", "renized", "Resizes"], "rightNow": [" rightToday", "rightCurrent", "rightThen", "rightFuture", "rNOW", "rightToday", "rNow", " rightFuture", "westServer", "correctNow", "westFuture", "westCurrent", "westNOW", "RightCurrent", "correctFuture", "RightFuture", "correctToday", "RightToday", "rToday", " rightCurrent", " rightThen", "correctNOW", " RightNOW", "rServer", " rightServer", "westToday", " RightCurrent", "rightServer", "rightNOW", "RightNow", " RightNow", " RightThen", "westThen", "westNow", " rightNOW"], "dayNamedFolderName": ["dayNamedFolderNames", "dayNamedFileName", "dayNamedfolder1", "dayNamedFoldername", "dayNamingFilePath", "dayNamingFileSize", "dayNamedThemename", "dayNamedAreaNames", "dayNamedfoldername", "dayNamedfolderNames", "dayNamedArea1", "dayNamedDirectoryNames", "dayNamedDirectory1", "dayNamedFileNames", "dayNamedThemePath", "dayNamedFolderPath", "dayNamingFileName", "dayNamingFoldername", "dayNamedAreaName", "dayNamedThemeName", "dayNamedFileSize", "dayNamedDirectoryname", "dayNamedfolderPath", "dayNamedFolder1", "dayNamedDirectoryName", "dayNamingDirectoryName", "dayNamedFilename", "dayNamingFileNames", "dayNamingFolderNames", "dayNamedThemeSize", "dayNamingFolderPath", "dayNamedFolderSize", "dayNamingFilename", "dayNamingFolderSize", "dayNamedAreaname", "dayNamedFilePath", "dayNamingDirectoryNames", "dayNamingFolder1", "dayNamedThemeNames", "dayNamedfolderName", "dayNamingFolderName", "dayNamingDirectory1", "dayNamingDirectoryname"], "uploadDirRoot": ["saveDirRoot", " uploadRelBase", "uploadNetBase", " uploadRelroot", "uploadNetRoot", " uploadDirroot", "uploadNetroot", "uploadDbCover", "uploadNetCover", "uploaddirroot", "uploadDirBase", "uploaddirBase", "uploadUrlRoot", "uploadRelRoot", "uploaddirRoot", "uploadUrlParent", "uploadDirroot", "uploadRelroot", " uploadDirBase", "UploadDbCover", "uploadFolderRoot", "uploadDbBase", "uploadDirPath", "saveDirroot", "saveDbroot", "UploadDirRoot", "uploadDirectoryParent", "uploadFolderBase", "UploadDbBase", "saveDirParent", "uploadUrlPath", "uploadDbRoot", "uploadFolderPath", " uploadDirPath", "uploadFolderroot", "uploadDirectoryroot", "saveDbParent", "UploadDbRoot", "uploadDirParent", "UploadDirroot", "uploadRelBase", " uploadRelPath", "UploadDirCover", "UploadDbroot", "uploadRelPath", "uploaddirCover", " uploadRelRoot", "uploadDbParent", "uploadUrlroot", "uploadDirCover", "uploadDirectoryRoot", "uploadUrlBase", "saveDbRoot", "UploadDirBase", "uploadDbroot"], "file": ["channel", "full", "type", "open", "f", "force", "class", "project", "task", "dir", "t", "link", "top", "key", "image", "run", "page", "source", "null", "h", "ile", "to", "handle", "up", "tree", "il", "op", "work", "el", "folder", "port", "FILE", "parent", "get", "no", "entity", "resource", "local", "base", "name", "node", "time", "File", "pool", "table"], "extension": ["EXTended", "xtend", "expension", "exendant", "exention", "dimendant", "expention", "extention", "exension", "xtention", "EXTend", "xtension", "extend", "exensions", "expend", "expended", "expendant", "dimention", "extendant", "extended", "dimension", "EXTension", "expensions", "EXTention", "dimensions", "extensions", "xtended"], "outFileName": ["outImagename", " outLinePath", "outImageName", "OUTLogname", " outFilename", "Outfilename", "OUTFilename", "outFieldPath", " outLogVersion", "outLogname", "outLineKey", "outFileNames", "OUTFieldPath", "outFilenamePath", "inFileType", "OutFileKey", "outFilenameSize", " outFileInfo", "OUTLogKey", "OUTFieldname", "outFieldType", "outLineInfo", "infileSize", "OutFilename", "outImagePath", " outLogname", "OUTFieldName", "outFileSize", "OUTFileName", "outFilenamename", "outfileSize", "outFilenameInfo", "infileName", "outFileInfo", "outImageInfo", "outImageNames", "outfileKey", "outDirname", "outFilesPath", "outLinePath", "outFilenameName", " outFileNames", "outFilesName", "outFilesname", "outFilename", "OUTLogName", "inFilename", "OutfileKey", "outfileVersion", "outfilePath", "outLineName", "OutFilePath", "outFilenameVersion", " outLineNames", " outLineName", "outfileName", " outLineInfo", "outfilename", "infileType", "outFieldSize", "outLogVersion", "inFileName", "outFileVersion", "outFieldname", "outFilenameNames", "outLogName", " outFilePath", "OutfileName", "OutFileName", "outLinename", " outLogName", "outDirName", "outFilePath", "inFileSize", "outfileNames", "outLogKey", "outFilenameKey", "outDirPath", "outLogPath", " outFileVersion", "outLogNames", "OUTFileKey", "OUTLogPath", "outLineNames", "infilename", "outFilenameType", "outImageKey", " outLogNames", "OutfilePath", "outfileType", "OUTFilePath", "outFieldName", "outFileType", "outFileKey"], "outPathAndName": ["outPathAndPath", "outPathButTime", "outPathButLike", "outTimeButTime", "outPathAndLike", "outLocationandName", "outLocationAndNames", "outPathAndKey", "outTimeButName", "outPathANDTime", "outPathAndTime", "outTimeAndName", "outLocationAndKey", "outPortAndPath", "outPathOrKey", "outPathAndSize", "outPathOrNames", "outPathANDName", "outPathANDPath", "outLocationandNames", "outPortButPath", "outPortAndKey", "outLocationandKey", "outPathandName", "outPortAndName", "outPathAndNames", "outPathOrName", "outPathandSize", "outPathOrPath", "outTimeButPath", "outPathOrTime", "outLocationAndName", "outPortButName", "outPathandNames", "outPathButName", "outTimeAndTime", "outLocationandSize", "outPathandPath", "outPathOrSize", "outTimeAndPath", "outPathButKey", "outTimeButLike", "outPathANDLike", "outPathOrLike", "outLocationAndSize", "outTimeAndLike", "outPortButKey", "outPathButPath", "outPathandKey"], "uploadedFile": ["presentedFILE", " uploadededF", "uploadredGlobal", " UploadmedFile", "presentedField", "uploadtedFile", "uploadpedFile", "uploadpedF", "presenttedField", "uploadedFILE", " uploadedifiedFile", "uploadiedFile", " UploadedFile", "uploaderField", " UploadmedFormat", "uploadashedFile", "uploadedUnit", "uploadashedfile", "uploadmedFormat", "uploadiedLine", "uploadtedFILE", "uploaderFile", "uploadmedGlobal", "uploadifiedUnit", "uploadededFormat", "uploadedF", "uploadifiedLine", " uploadededUnit", "uploadededFile", "uploaderfile", "uploadmedPlace", "uploadredPlace", "uploaderFILE", "uploadpedLine", "uploadedLine", " UploadedFormat", " UploadmedGlobal", "uploadashedFILE", " uploadedifiedLine", "presenttedFILE", "presenttedFile", "uploadredFormat", "uploadedField", "uploadifiedF", "uploadedFormat", "uploadashedField", "presentedfile", "uploadededPlace", "uploadiedF", "uploadedGlobal", " uploadededLine", " UploadedPlace", "uploadedfile", " UploadedGlobal", "uploadifiedFile", "uploadmedFile", " UploadmedPlace", "uploadedPlace", "uploadededGlobal", "presenttedfile", " uploadedifiedUnit", "uploadiedUnit", " uploadedifiedF", "uploadtedfile", "uploadpedUnit", "presentedFile", "uploadredFile", "uploadtedField", " uploadededFile"], "outStream": ["inView", "oView", "oStream", "oFile", "_", "inFile", "inSteam", " outView", "outFile", "outView", " outFile", "outSteam", "oSteam", " outSteam"]}}
{"id1": "13720140", "id2": "22411381", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"modifyProperty": ["ModifyAttribute", "ModifiesAttribute", "modateProp", "modateAttribute", "modifiesProperty", "ModifiesProp", "ModifyValue", "modureValue", "modureProp", "modifyAttribute", "modateProperty", "modifyProp", "modifiesAttribute", "modateValue", "modifiesProp", "modureProperty", "modifiesValue", "ModifyProp", "ModifiesProperty", "ModifyProperty", "ModifiesValue", "modifyValue", "modureAttribute"], "valueID": [" valueIDs", "versionUID", "propertyId", "versionid", "valueMD", " valueMD", "valueid", "versionMD", "versionIDs", "VALUEId", "propertyID", " valueid", "versionID", "valueUID", "valueId", " valueUID", "propertyIDs", " valueId", "versionId", "propertyid", "valueIDs", "VALUEID", "VALUEMD", "VALUEUID"], "value": ["message", "VALUE", "function", "format", "input", "update", "type", "application", "Value", "save", "address", "output", "instance", "description", "current", "string", "vector", "padding", "entry", "key", "memory", "val", "label", "expression", "version", "password", "default", "attribute", "field", "variable", "state", "text", "get", "buffer", "content", "v", "code", "example", "data", "name", "comment", "hello", "values"], "userID": ["ownerID", "usernameURL", "UserID", "userName", "userType", "usernameId", "UserName", "UserType", " userURL", "UserId", " userId", "UserURL", "usernameID", "userURL", "usernameName", "ownerType", "ownerName", "ownerId", " userName", "userId", " userType"], "property": ["setup", "alias", "message", "item", "Property", "function", "display", "title", "prop", "type", "associated", "address", "translation", "project", "media", "description", "relation", "config", "properties", "second", "feature", "key", "ty", "term", "this", "label", "pair", "p", "object", "pe", "to", "expression", "method", "attribute", "field", "command", "state", "policy", "style", "position", "option", "license", "prototype", "resource", "metadata", "module", "print", "operator", "profile", "data", "name", "language", "prefix", "section", "claim", "table"], "newValue": ["newResult", "uniqueValue", "NewValue", "newValues", "uniqueVersion", "oldValue", "newName", "NEWvalue", "NEWValue", "oldResult", "newVersion", "oldVersion", "NEWResult", "newMessage", " newName", " newvalue", "uniqueName", "Newvalue", "oldMessage", "uniqueMessage", " newResult", " newVersion", " newString", "newString", "oldString", " newMessage", "NewString", "oldValues", " newValues", "NEWString", "NewValues", "oldName", "oldvalue", "newvalue"], "crypt": ["cs", "pt", "check", "auth", "init", "cert", "ocr", "coin", "comm", "sync", "nt", "core", "cook", "col", "rem", "mac", "cos", "ctr", "cc", "prot", "go", "cp", "gc", "ct", "cmd", "coll", "trust", "rypt", "dict", "bec", "cm", "password", "cmp", "sys", "cr", "ch", "dec", "enc", "hex", "roy", "conv", "cy", "rh", "ssl", "rot", "cont", "Crypt", "reset", "cry", "cot", "code", "mem", "hash", "cur", "sm", "arch", "CR", "magic"], "digest": ["dest", "Digge", "mdEST", "Digester", "hexEST", " digEST", "hexester", "digester", "digEST", " Digest", "Digert", "dested", "mdestamp", "diggest", "mdester", "Digests", "mdests", "hashge", " Digester", "mdest", " Digert", "digested", "Digest", "mdge", " digestamp", "dester", "digert", "hashests", "digests", "Digestamp", "Diggest", "mdgest", " DigEST", "dEST", "digge", "hexest", "DigEST", "hashgest", "mdested", "Digested", "digestamp", "hashest", " digested", "hexert"], "hexString": ["hexArray", "exString", " hexstring", "shortBuffer", "formStr", "hashString", " hexBytes", "exstring", "shortStr", "hexBuffer", " hexBuffer", "hexBytes", "hashStr", "exArray", " hexStr", "exBytes", "formString", "shortstring", "formBytes", "hexstring", "hexStr", "exBuffer", "hashstring", "formBuffer", "hashArray", "exStr", " hexArray", "shortString"], "i": ["ex", "is", "init", "us", "gi", "id", "it", "qi", "number", "info", "\u0438", "ci", "li", "ms", "I", "m", "ai", "ix", "gu", "ki", "x", "bi", "hi", "ii", "a", "q", "u", "multi", "mi", "uri", "ic", "major", "index", "io", "y", "ind", "slice", "im", "phi", "sim", "ie", "e", "ji", "chain", "si", "v", "span", "pi", "o", "ei", "ti", "cli", "point", "j", "ui", "di", "ini", "ip"]}}
{"id1": "13666876", "id2": "19335986", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"transformSingleFile": ["transformOnefile", "processSingleFiles", "transformsingleSourceFile", "transformOneSourceFile", "transformsingleFiles", "transformMultiModel", "TransformSingleRecord", "transformSingleRecord", "TransformSimpleModel", "transformSingleFiles", "processsingleFile", "transformsinglefile", "TransformSimpleRecord", "TransformSinglePage", "transformsingleRecord", "processsingleSourceFile", "transformMultiSourceFile", "transformOneFiles", "TransformSimpleFile", "TransformSingleFile", "processsingleFiles", "processsinglefile", "transformSingleSourceFile", "TransformSimplePage", "processSingleFile", "transformsingleFile", "transformMultiFile", "transformSinglePage", "transformMultiRecord", "transformMultiPage", "processSingleSourceFile", "transformSimplePage", "transformSinglefile", "transformSimpleModel", "transformMultiFiles", "transformsinglePage", "TransformSingleModel", "transformSimpleFile", "transformOneFile", "transformSingleModel", "transformSimpleRecord", "processSinglefile", "transformMultifile", "transformsingleModel"], "xed": ["uxented", "xied", "txeds", "XED", "Xeds", "rxED", "pxeded", "passED", "exeded", "uxED", "txED", "pxED", " xED", "rxeds", "uxed", "Xer", "wxED", "pxed", "txed", "passed", " xented", "xEd", " xred", "Xeded", "uxied", "wxEd", "exeds", "Xed", "rxed", "wxed", "passEd", "wxied", "txer", "xeded", " xied", "pxeds", "exed", "xented", "wxented", "xred", " xEd", "xer", "passred", "wxred", "rxer", "xED", "xeds", "exED"], "node": ["range", "day", "Node", "note", "component", "array", "map", "and", "seed", "link", "ode", "load", "directory", "our", "job", "entry", "feature", "de", "word", "image", "n", "right", "row", "one", "object", "station", "tree", "hand", "set", "view", "scene", "post", "stage", "remote", "no", "entity", "parent", "line", "process", "edge", "event", "resource", "create", "name", "channel", "index"], "dob": ["drob", "drab", "diab", "doy", " doy", " dobb", "drobb", "diobb", "Doy", "adob", "dab", "diod", "dobb", "Dab", "dobar", "dod", "adab", " dod", " dab", " dobar", "adobar", "diob", "drod", "Dob", "Dobar", "adoy"], "mySrc": [" mySfc", "mySourceRC", "mySRC", "mySourcerc", "mySingRC", "myDessrc", "mySelsrc", "myAssrc", "myAsrc", "MySsrc", "MySRC", "myDesRC", "myAsRC", "myInsRC", "mySsrc", "myInsfc", "mySingfc", "mySelources", "myInsrc", "mySourcesrc", "mySelRC", "myAsource", "myInssrc", "mySource", "MySource", "mySingsrc", "MySources", " mySRC", "MySrc", "mySingrc", " mySsrc", "mySourceource", "mySfc", "myDesrc", "myDesources", "mySelrc", "mySources"], "mySrcF": ["mySourceO", "myMrcF", "mySufO", "mySsrcO", "mySRCC", "myMrcO", "mySsrcI", "mySufV", "mySourceFP", "mySrcV", "mySsrcP", "myMourceO", "mySufFP", "mySrtI", "myMrcV", "mySrtP", "myMourceFP", "mySufF", "mySrcFP", "mySrcI", "mySsrcC", "mySrcP", "mySsrcFP", "mySrcC", "mySrtC", "mySourceF", "mySsrcV", "mySRCI", "mySrcO", "mySRCF", "myMrcFP", "mySsrcF", "mySourceV", "mySRCP", "myMourceV", "mySrtF", "myMourceF"], "myOutF": ["myOutFs", "mysOutFL", "MyInFs", "myInL", "myOutFile", "myObjV", " myOutFile", " myOutE", "MyOutV", "myObjF", "myOffFile", "myObjFs", "MyInV", "myOutL", "myNetE", "myArtW", "myOutputE", " myoutL", "mysOutW", "myCoW", "myOutputC", "myNetF", "MyOutFile", "myOutputFs", "myOutE", " myoutF", "myArtL", " myoutC", "myCoFL", "myCoL", "mysOutF", "myoutC", "mysNetL", "myInFs", "myOutW", "MyOutFs", "myInV", "MyInFile", "myOutputF", "myNetDF", "myOffE", "mysNetW", " myNetFile", " myoutV", "myArtFL", "myOutputFile", "myArtF", "myNetFile", " myOutC", " myOutV", "myoutF", "MyOutF", "myoutV", "myOffF", " myNetE", " myOutL", "myOutV", "myOutC", "myInFile", "mysNetF", "myOutputV", "myNetW", "myNetFL", "MyInF", "mysOutL", "myoutL", "myOutputL", "myNetL", "myInF", "myInC", "myOutDF", "myObjFile", "myOutputDF", "myOutFL", "mysNetFL", " myNetDF", "myCoF", " myNetF", "myOffDF", " myOutDF"], "co": ["cs", "obj", "aco", "com", "ce", "oc", "cache", "ace", "lo", "CO", "ci", "col", "fc", "cos", "xc", "fo", "cc", "cl", "c", "loc", "mo", "cop", "ko", "cv", "roc", "gc", "go", "coll", "copy", "flo", "ico", "cm", "nc", "io", " Co", "soc", "cal", "coord", "cu", "ror", "Co", "cod", "po", "cho", "ca", "no", "ctrl", "con", "so", "ck", "yes", "can", "ho", "o", "cover", "wo", "ro", "lc"], "x3dvFile": ["x3cdVPath", "x3dvsFilename", "x3pdbFilename", "x3pdvFile", "x3dvString", "x3cdVFile", "x3dVFilename", "x3pdvFilename", "x3dvsFile", "x3pdvfile", "x3cdVFilename", "x3pdvString", "x3dvPath", "x3dtFile", "x3dVPath", "x3dbString", "x3pdbfile", "x3dVfile", "x3dbFile", "x3cdvFile", "x3pdbFile", "x3pdbString", "x3dbfile", "x3cdvPath", "x3cdvFilename", "x3dVString", "x3dtString", "x3dbFilename", "x3dvsPath", "x3davFile", "x3dtFilename", "x3davPath", "x3dtfile", "x3dVFile", "x3dvFilename", "x3davFilename", "x3dvfile"], "fis": ["fileis", "fliz", " fisi", " fie", " fiz", "bis", "bie", "fiz", "fileires", "bisi", "fileiz", "frisi", "fiss", "friss", "fliss", "fileiss", "fris", "frie", "flires", " fiss", "fires", "biss", "fie", "fisi", "flis", " fires"], "gzos": ["zos", "zipos", "gtoes", "zo", "sslaos", "gsnos", "ggos", "gznos", "gaos", "zoss", "ssloss", "gsos", "gtnos", "zipops", "ggoes", "zipnos", "ggies", "ziposs", "sslos", "gzoes", "go", "zops", "zaos", "zies", "gzaos", "gzops", "gzies", "gtos", "gtops", "gsops", "gos", "zoes", "gzoss", "gties", "goss", "ggops", "gtoss", "gzo", "sslo", "gsoss"], "buf": ["b", "block", "bytes", "uf", "cap", "mu", "pkg", "rb", "cb", "cat", "Buffer", "br", "orig", "cv", "img", "arr", "box", "cmd", "batch", "good", "bag", "bar", "cam", "seq", "tab", "ref", "conv", "aka", "Buff", "buffer", "raw", "vec", "fb", "wb", "max", "emb", "cf", "cur", "mem", "buff", "bus", "cast", "font", "var"], "ret": ["obj", "aux", "iter", "cert", "ptr", "out", "ft", "r", "red", "err", "mt", "nt", "rt", "back", "repl", "ctr", "gt", "test", "arg", "rets", "continue", "ext", "RET", "val", "alt", "end", "Ret", "pret", " Ret", "ter", "def", "cmd", "len", "tr", "ref", "deg", "re", "cont", "print", "v", "res", "et", "inter", "ry", "elt", "att"]}}
{"id1": "21921000", "id2": "189963", "code1": "    @Override\n    public void parse() throws IOException {\n        URL url = new URL((new DataUrlResolver()).getDataUrl(DomainName.CROATIA));\n        URLConnection con = url.openConnection();\n        BufferedReader bStream = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String str;\n        bStream.readLine();\n        while ((str = bStream.readLine()) != null) {\n            String[] tokens = str.split(\"(\\\\s+)\");\n            String charCode = tokens[0].replaceAll(\"([0-9+])\", \"\");\n            Float value = Float.parseFloat(tokens[2].trim().replace(\",\", \".\"));\n            CurrencyUnit unit = new CurrencyUnit(charCode, value, DEFAULT_MULTIPLIER);\n            this.set.add(unit);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"parse": ["read", "init", "install", "save", " dissect", "apply", "construct", " eval", " merge", "se", "run", "next", " evaluate", "close", " parser", "handle", "build", "fork", " solve", "process", "start", "execute", "scan", " scan", " ingest"], "url": ["ls", "b", "dl", "cert", "http", "URL", "lr", "r", "f", "open", "abs", "l", "ur", "link", "https", "sur", "au", "client", "cl", "job", "web", "nl", "loc", "hl", "lb", "mount", "cm", "ret", "log", "Url", "mail", "build", "conn", "ssl", "ul", "bel", "ll", "pl", "sl", "un"], "con": ["com", "Conn", "conf", "ver", "sc", "ln", "ain", "Con", "login", "fc", "bc", "sur", "client", "cl", "cc", "un", "c", "mc", " Con", "cp", "cn", "cm", "nc", "soc", "conv", "CON", "dial", "re", "cin", "conn", "connection", "co", "ran", "pen", "cons", "cf", "cur", "can", "connect", " conn"], "bStream": ["rbSteam", "bbStream", "rbStream", "fChannel", " bstream", "fStream", "bSteam", " bChannel", "bbSteam", "fRead", "rbRead", "bbRead", "rstream", " bRead", "rbStreamer", " bReader", "rSteam", "bstream", "bReader", "rbstream", "rbChannel", "rStreamer", "rStream", "bStreamer", "vReader", "vStream", "bChannel", "bRead", "bbReader", "fStreamer", " bStreamer", " bSteam", "vSteam", "vRead"], "str": ["b", "obj", "cs", "pt", "out", "input", "it", "r", "comm", "err", "z", "list", "t", "s", "l", "Str", "string", "ctr", "pos", "pr", "c", "req", "n", "txt", "source", "br", "p", "arr", "char", "tr", "sp", "msg", "cr", "st", "spec", "console", "text", "STR", "dec", "g", "e", "line", "i", "cont", "gr", "print", "res", "cur", "comment", "j", "vol", "fr"], "tokens": ["pokens", "toksets", "todkens", "tkents", "tokskens", "takents", "Tokets", "todens", "stokkens", "Tokeds", "stodkens", "pokents", "toksTokens", "todets", "takets", "tolkens", "toksents", "Tokents", "pokkens", "tobkens", "tolens", "tobens", "pobTokens", "pobens", "tolences", "stodens", "todTokens", "Toksents", "pobents", "stodences", "pokTokens", "tkeds", "stokets", "tkens", "stokences", "tokseds", "Toksens", "Toksets", "todences", "tokents", "stodets", "tokTokens", "tokkens", "pobkens", "takens", "tokets", "toksences", "takeds", "tobTokens", "tobents", "Tokens", "Tokseds", "tokeds", "tkets", "stokens", "toksens", "tokences", "tolets", "todents"], "charCode": ["charFore", "characterFore", "cellcode", "characterName", "charName", " charcode", "CharCode", "characterType", "CharName", "CharFore", "charType", "cellType", "charcode", "charactercode", " charType", "cellName", "characterCode", "CharacterName", "cellCode", "CharacterFore", "CharacterCode", " charName"], "value": ["VALUE", "dollar", "format", "function", "number", "type", "Value", "address", "instance", "description", "currency", "current", "zone", "feature", "system", "score", "key", "val", "family", "serial", "category", "price", "percent", "money", "scale", "version", "default", "average", "result", "sequence", "property", "pain", "position", "step", "hello", "total", "sum", "max", "v", "sample", "language", "data"], "unit": ["block", "group", "format", "note", "number", "component", "it", "type", "class", "unknown", "nit", "currency", "dir", "uni", "string", "stable", "term", "crit", "category", "u", "num", "money", "layout", "util", "io", "scale", "nu", "command", "Unit", "set", "unsigned", "units", "dimension", "chain", "sum", "base", "name", "volume", "prefix", "relation", "un", "variable"]}}
{"id1": "14785308", "id2": "10715601", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"sha1": ["md256", "md1", "SHA1", "a3", "SHA256", "SHA2", "md3", "sha256", "md2", "SHA3", "a256", "sha2", "a1", "a2", "sha3"], "text": ["message", "path", "read", "pt", "template", "value", "title", "out", "input", "aut", "url", "subject", "select", "output", "translation", "nt", "context", "t", "string", "str", "tx", "test", "x", "ext", "TEXT", "word", "term", "txt", "source", "q", "ct", "act", "pattern", "password", "document", "command", "msg", "w", "body", "form", "buffer", "cont", "event", "content", "print", "code", "now", "Text", "data", "name", "prefix", "comment"], "UnsupportedEncodingException": ["UnsupportedChoderError", "UnsupportedChodingElement", "UnsupportedChodingException", "UnsupportedChoderElement", "UnsupportedEncodingElement", "UnsupportedChodingEx", "UnsupportedChodingError", "UnsupportedEncgorithmEx", "UnsupportedChoderEx", "UnsupportedChoderException", "UnsupportedEncoderException", "UnsupportedEncoderError", "UnsupportedEncgorithmElement", "UnsupportedEncoderEx", "UnsupportedEncodingError", "UnsupportedEncodingEx", "UnsupportedEncgorithmException", "UnsupportedEncoderElement", "UnsupportedEncgorithmError"], "md": ["ad", "nd", " mc", "cd", "mond", " ms", "dh", "mt", "ms", "red", "grad", "MD", "m", "mp", "pkg", "rm", "dir", "der", "bf", "mk", "t", "add", "ctr", "hd", " dd", " df", "mc", "df", " rm", " mo", "h", "dd", "cmd", "pd", " sd", " cmd", "det", "ind", "mod", " man", "sha", "mm", "ld", "bd", "od", "mn", "mb", "td", "mand", "d", " Md", "sd", " cd", "mg", " mm", "di", "dm"], "sha1hash": ["sha5result", "haonesum", "ha1result", "aonesum", "ha1hash", "sha1Hash", "sha3sha", "shaonesum", "sha5hex", "sha81hash", "sha1sha", " SHA1href", "a1hash", "sha1hex", "sha1sum", "ha1sum", "aonehash", " SHA81hex", "sha2sha", "sha81href", "sha3result", " SHA1hex", "aoneHash", "haoneresult", "sha81hex", "sha3href", " SHA1Hash", " SHA81href", "sha1result", "sha5sha", "sha2sum", " SHA81hash", "shaoneresult", "a1sum", "sha3hex", "sha5sum", "shaonehash", "sha3Hash", "shaoneHash", "a1Hash", "haonehash", "sha3hash", "sha2Hash", "a1sha", "aonesha", "sha81Hash", "sha5Hash", " SHA1hash", "sha2hash", "sha5hash", "sha3sum", "sha5href", " SHA81Hash", "shaonesha", "haonesha", "sha1href", "ha1sha"]}}
{"id1": "18374598", "id2": "21033686", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    public File read() throws IOException {\n        URLConnection conn = url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.connect();\n        int length = conn.getContentLength();\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        if (tempDir == null) {\n            tempDir = \".\";\n        }\n        File tempFile = new File(tempDir + \"/\" + new GUID() + \".dat\");\n        tempFile.deleteOnExit();\n        InputStream in = null;\n        OutputStream out = null;\n        ProgressMonitor monitor = new ProgressMonitor(parentComponent, \"Downloading \" + url, null, 0, length);\n        try {\n            in = conn.getInputStream();\n            out = new BufferedOutputStream(new FileOutputStream(tempFile));\n            int buflen = 1024 * 30;\n            int bytesRead = 0;\n            byte[] buf = new byte[buflen];\n            ;\n            long start = System.currentTimeMillis();\n            for (int nRead = in.read(buf); nRead != -1; nRead = in.read(buf)) {\n                if (monitor.isCanceled()) {\n                    return null;\n                }\n                bytesRead += nRead;\n                out.write(buf, 0, nRead);\n                monitor.setProgress(bytesRead);\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            monitor.close();\n        }\n        return tempFile;\n    }\n", "label": 0, "substitutes": {"download": ["read", "pull", "check", "install", "update", "url", "save", "open", "filename", "file", "link", "load", "loader", "submit", "delete", " Download", "upload", "dial", "get", " downloaded", "Download", "GET", " downloads", "create", "sample", "poll", "data", "connect"], "a": ["b", "sta", "path", "at", "era", "title", "eta", "all", "pa", "al", "url", "array", "r", "address", "la", "ma", "any", "ab", "t", "s", "ga", "l", "app", "au", "ai", "as", "ae", "ta", "A", "apa", "html", "ar", "arg", "c", "from", "go", "u", "ac", "h", "ao", "area", "aa", "attribute", "part", "el", "va", "ca", "na", "an", "aaa", "i", "ata", "sa", "aw", "oa", "d", "v", "aos", "o", "base", "am", "data", "name", "ap", "att", "alpha", "ia"], "p": ["b", "pt", "pat", "pp", "wp", "perm", "tp", "prop", "pa", "vp", "ip", "bp", "pkg", "m", "pc", "t", "pre", "l", "pos", "x", "c", "pid", "q", "pro", "h", "pe", "cp", "ping", "op", "part", "j", "power", "par", "pers", "rep", "g", "ps", "i", "jp", "pad", "d", "pard", "pi", "P", " pe", "np", "lp", "pl", "ap", "pg", "pr", "pb"], "td": ["ad", "nd", "pt", "cd", "dl", "th", "ptr", "ts", "dh", "tp", "tc", "ds", "tmp", "nt", "fd", "tf", "fc", "pc", "t", "md", "tif", "dc", "hd", " TD", "df", "pd", "dd", "ct", "cz", " sd", "det", "tr", "dt", "div", "lf", "dial", "ld", "deb", "bd", "od", "tap", "d", "cot", "sd", "TD", "ot", "db", "pb"], "f": ["b", "xf", "uf", "ft", "fs", "func", "file", "fd", "bf", "fp", "fc", "tf", "t", "l", "fl", "fo", "c", "fin", "ff", "fx", "fn", "df", "af", "h", "fe", "rf", "fi", "fw", "lf", "F", "w", "form", "g", "e", "i", "sf", "d", "fb", "cf", "v", "o", "fm", "fa", "j", "fr", "alf"], "total": ["template", "full", "net", "eta", "equal", "note", "number", "all", "info", "open", "nt", "current", "t", "count", "done", "stable", "Total", "ta", "otal", "le", "percent", "num", "to", "len", "scale", "initial", "sys", "valid", "unique", "sequence", "length", "last", "meta", "none", "trans", "buffer", "active", "max", "sum", "available", "base", "start", "complete", "table", "normal"], "progress": ["payment", "ptr", "portion", "display", "offset", "wait", "priority", "update", "finished", "grade", "speed", "address", "distance", "current", "debug", "count", "done", "t", "performance", "age", "success", "summary", "memory", "continue", "pro", "percent", "scroll", "scale", "bar", "result", "state", "Progress", "length", "report", "pdf", "status", "step", "usage", "process", "dist", "history", "depth", "print", "resource", "poll", "complete", "important"], "in": ["In", "iter", "is", "init", "on", "input", "it", "rin", "win", "IN", "inn", "and", "l", "inside", "inf", "bin", "ai", "ar", "ins", "from", "inc", "en", "ze", "ic", "to", "io", "ind", "oin", "im", "din", "mm", "by", "get", "cin", "con", "i", "inner", "o", "ini"], "out": ["b", "obj", "put", "ex", "at", "net", "OUT", "ou", "on", "cache", "it", "write", "err", "output", "nt", "list", "t", "s", "l", "oss", "lock", "pos", "client", "cb", "c", "Out", "end", "null", "ins", "os", "cn", "to", "io", "ne", "sys", "outs", "w", "ch", "writer", "OU", "g", "by", "log", "con", "conn", "co", "can", "aos", "o", "outer", "auto", "res", "v", "vol", "pool"], "buf": ["b", "bytes", "block", "uf", "mu", "cap", "pkg", "bl", "norm", "rb", "bin", "cb", "cat", "window", "Buffer", "next", "row", "br", "orig", "cv", "img", "arr", "cp", "cmd", "box", "batch", "bag", "bar", "msg", "seq", "tab", "conv", "aka", "Buff", "buffer", "wb", "vec", "buff", "data", "bed", "ob", "db", "obs", "pb"], "n": ["b", "ren", "ng", "note", "on", "nn", "number", "yn", "wn", "z", "N", "nt", "m", "ln", "norm", "count", "t", "l", "nor", "gn", "x", "sn", "nl", "nm", "c", "fn", "nr", "cn", "en", "num", "dn", "nan", "len", "ne", "nc", "y", "w", "none", "g", "min", "no", "an", "na", "nb", "i", "names", "max", "d", "nw", "v", "o", "np", "j", "ns"], "percentage": ["parager", "percentager", "parility", "scaleage", "parAGE", "CENTategy", "percentAGE", "propage", "Percentage", "centility", "centager", "Percentade", "Percentile", "taxension", "taxance", "centage", "Percentity", "Percentategy", "quantance", "percentity", "oppade", "centile", "percentategy", "centade", "percentume", "Percentant", "taxility", "parance", "propile", "scaleility", "percentant", "oppant", "centity", "quantage", "CENTage", "oppage", "centAGE", "propity", "propade", "percentility", "CENTade", "Percentume", "taxage", "parage", "centategy", "scaleAGE", "CENTume", "quantility", "percentension", "oppility", "scaleager", "percentile", "percentance", "percentade", "centume", "Percentility", "quantension", "parension"], "tmpPercentage": ["tmpIntade", " tmpPercentency", " tmppercenture", "tmpIntage", "tmpPropency", " tmpPercentane", "tmpPercentade", "tmpMagnages", " tmpPercentages", " tmppercentage", " tmpPercentade", " tmppercentane", "tmppercentages", "tmpPropance", " tmpIntance", "tmpPlusure", " tmpPercentate", " tmpIntency", "tmpPercentance", "tmpPercentency", "tmpPropage", "tmpMagnade", "tmpPercentages", " tmpIntade", "tmpPercenture", "tmppercentate", "tmpPercentate", "tmpIntency", "tmpPercentane", "tmpPlusade", "tmpIntance", " tmpIntage", "tmppercentade", " tmppercentade", "tmpMagnate", "tmpMagnage", "tmpPlusage", "tmpPlusane", " tmpPercenture", " tmppercentate", "tmpPropade", " tmppercentages", "tmppercenture", "tmppercentane", "tmppercentage", " tmpPercentance"], "size": ["bytes", "empty", "SIZE", "storage", "needed", "small", "space", "ize", "count", "s", "l", "send", "sn", "c", "loc", "ze", "num", "ose", "area", "len", "used", "scale", "sp", "notice", "Size", "length", "set", "body", "see", "position", "g", "e", "capacity", "loss", "max", "sd", "sum", "code", "sw", "now", "name"], "checksum": ["actionsumm", "hssum", "hassum", "hsul", "ckscan", "hasam", "actionsul", "ksam", "cksul", "actionsum", "hsum", "cksum", "timesave", " checksul", "cksave", "actionssum", "hasum", "checksul", "readsum", "timessum", "checkscan", "kssum", "hascan", "ksum", "checkssum", " checkssum", "readssum", "ckssum", "hsumm", "timesum", "timesul", "cksam", "checksave", "kscan", " checksumm", "checksam", "checksumm", "readsave", "readsul"]}}
{"id1": "4686922", "id2": "13886238", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceTofile", "extractResource2File", "extractResourceAsStream", "extractResourceFromFiles", "extractResourceAsFiles", "extractResourceAsFile", "extractResourcesTofile", "extractResources2Stream", "extractResourcesToStream", "extractResourceToStream", "extractResource2Stream", "extractResourceFromStream", "extractResource2Files", "extractResources2file", "extractResources2Files", "extractResourcesToFiles", "extractResourcesToFile", "extractResourceAsfile", "extractResources2File", "extractResourceToFiles", "extractResourceFromFile", "extractResourceFromfile", "extractResource2file"], "resourcePath": ["Resourcepath", "resourceUrl", "ResourceIn", " resourceName", "attributeUrl", "ResourceName", "attributeName", "templateName", " resourcepath", "ResourceUrl", "attributeLocation", "ResourceLocation", "uriPath", "uriName", "ResourcePath", "uriUrl", "resourcepath", "resourceIn", "uriLocation", "templatePath", "resourceName", "resourceLocation", "attributePath", "templateIn", "templatepath", " resourceIn"], "dest": ["rest", "src", "prop", "des", "comb", "home", "output", "tmp", "dir", "Dest", "etc", "self", "origin", "cat", "loc", "this", "source", "null", "nom", "orig", "end", "img", "gov", "good", "to", "decl", "opt", "result", "sp", "w", "coord", "target", "desc", "dat", "parent", "temp", "trans", "dist", "cont", "mem", "lit"], "in": ["In", "iter", "is", "init", "or", "sin", "conf", "on", "input", "rin", "it", "al", "id", "r", "f", "all", "file", "ln", "IN", "m", "inn", "l", "inside", "inf", "bin", "ins", "source", "from", "inc", "mc", "mi", "up", "ne", "ind", "din", "isin", "none", "no", "re", "cin", "con", "i", "gin", " din", "resource", "raw", "inner", "local", "ini"], "out": ["b", "obj", "at", "OUT", "net", "note", "ou", "cache", "on", "it", "write", "f", "output", "tmp", "nt", "col", "t", "cos", "stable", "oss", "client", "again", "Out", "n", "null", "os", "en", "exit", "cn", "to", "io", "ne", "sys", "outs", "w", " Out", "ch", "writer", "conv", "na", "no", "con", "i", "co", "print", "v", "res", "o", "can", "aos", "outer", "ot", "inner", "pool"]}}
{"id1": "8973505", "id2": "812803", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"writeFileType": ["writeContenttype", "writefileInfo", "writeContentType", "readfileInfo", "writefileName", "writeContentInfo", "readfileName", "writefileType", "writePageType", "writeFileInfo", "readFiletype", "writeFileName", "writePagetype", "writePageInfo", "readFileName", "writefiletype", "writeFiletype", "readFileType", "writePageName", "readFileInfo", "readfiletype", "readfileType", "writeContentName"], "uriFile": ["urifile", "filenamefile", "fileFile", "filenameFiles", "iriFile", "URIFiles", "iriFILE", "uriData", "URIFile", "fileFiles", "rangeFILE", "URIData", "filenameFile", "filefile", "fileFilename", "uriFiles", "iriData", "URIFilename", "irifile", "URIfile", "URIFILE", "rangeData", "filenameFilename", "rangefile", "uriFilename", "rangeFile", "uriFILE"], "outputfile": ["inputfile", "OutputFile", "OutputFILE", "inputport", "outf", "outbase", "outputbase", "outfile", " outputbase", "Outputfile", "outFile", "imagefile", "outputf", "imageport", "inputbase", "imageFile", "Outputport", "outputFile", "outputport", "inputFILE", " outputf", " outputFile", "inputFile", "imageFILE", "inputf", "outputFILE"], "num": ["nam", "check", "Number", "number", "all", "Num", "m", "current", "mult", "done", "count", "add", "zero", "nm", "x", "n", "random", "nom", "end", "multi", "NUM", "cmp", "alph", "um", "nb", "no", "mon", "con", "total", "max", "np", "index", "required"], "writer": ["external", "creator", "widget", "file", "player", "test", "riter", "width", "caster", "worker", "timer", "connection", "resource", "wire", "service", "variable", "commit", "format", "write", "wrapper", "writers", "written", "window", "ender", "stream", "director", "linger", "will", "layer", "ner", "writing", "inner", "utils", "table", "wright", "read", "Reader", "storage", "function", "link", "network", "record", "entry", "memory", "term", "writ", "processor", "manager", "owner", "console", "w", "Writer", "iterator", "buffer", "data", "comment", "maker", "driver", "liner", "author", "editor", "journal", "client", "loader", "builder", "thus", "ener", "to", "flush", "er", "runner", "document", "handler", "RW", "usher", "event", "server", "operator"], "uri": ["sofar", "uu", "filename", "file", "wiki", "uni", "https", "queue", "directory", "uno", "umi", "ri", "origin", "hi", "verb", "image", "domain", "source", "mi", "rid", "obo", "phi", "i", "connection", "resource", "ei", "ip", "user", "id", "subject", "du", "description", "ource", "browser", "doi", "details", "multi", " URI", "username", "result", "uid", "URI", "ref", "hyper", "chain", "inner", "ui", "via", "range", "qi", "ur", "link", "ir", "bid", "href", "folder", "remote", "iterator", "location", "phrase", "channel", "ugi", "ni", "qu", "http", "query", "address", "reference", "unit", "basic", "copy", "general", "form", "iri", "pi", "prefix"], "counter": ["message", "creator", "cms", "number", "card", "context", "amount", "instance", "currency", "editor", "norm", "count", "common", "ctr", "browser", "walker", "loader", "entry", "system", "TER", "continue", "memory", "container", "key", "random", "term", "mer", "scope", "nr", "ter", "processor", "manager", "coll", "money", "ier", "loop", "frequency", "another", "sequence", "clock", "const", "Counter", "conv", "ounter", "controller", "finder", "iterator", "meter", "cookie", "buffer", "timer", "order", "total", "inner", "pointer", "mr", "outer", "machine", "phrase", "cover", "time", "index", "book", "mill"], "reader": ["read", "driver", "iter", "liner", "Reader", "input", "r", "address", "context", "older", "file", "editor", "rx", "journal", "parser", "player", "loader", "entry", "roller", "builder", "rar", "row", "dd", "method", "processor", "layer", "rl", "er", "runner", "upper", "document", "handler", "ner", "yer", "redo", "iterator", "buffer", "timer", "resource", "server", "inner", "ro"], "url": ["dl", "http", "URL", "r", "address", "open", "li", "l", "ur", "link", "str", "gl", "browser", "https", "client", "google", "web", "nl", "loc", "hl", "github", "char", "il", "www", "ref", "get", "mail", "Url", "re", "build", "ssl", "resource", "bel", "base", "location", "rel", "ll", "name", "mount", "sl"], "myConnection": ["thisLink", "thisConnection", "newConnection", " myConnect", "MyLink", "myconnection", "myLink", " myconnection", " myConn", "myConnector", " myLink", "thisConnect", " myConnector", "Myconnection", "newLink", "myConn", "newConn", "MyConnector", "myConnect", "yourConnector", "MyConnection", "yourconnection", "newConnect", "yourConnection", "yourLink", "thisConn"], "myReader": ["yReader", " myWriter", "MyRead", "yourParser", "yourWriter", "MyParser", "yourRead", "mxReader", "mxSer", "ySer", "mxWriter", "yFr", "myWriter", "myFr", " myParser", "myRead", "MyWriter", "mxFr", " myRead", "yWriter", "yourReader", "mySer", " myFr", " mySer", "myParser", "MyReader"], "line": ["message", "LINE", "range", "block", "liner", "iter", "channel", "user", "online", "lo", "ip", "ln", "inline", "frame", "ine", "stroke", "ode", "eline", "cell", "link", "l", "trace", "email", "entry", "lin", "rule", "word", "detail", "row", "page", "le", "one", "label", "Line", "char", "part", "ole", "ge", "sequence", " LINE", "text", "body", "definition", "style", "side", "log", "no", " Line", "raw", "edge", "code", "sample", "cli", "comment", "point", "lane", "normal"], "linecount": ["linecounter", "strokenumber", "linercount", "lineconfig", "inlineconst", "linnumber", "linefound", " linecounter", "lineconsider", " lineconst", " lineconfig", "Linecount", "elineconst", "strokeconsider", "strokeamount", " linenumber", "linconsider", "Lineconfig", " linelength", "linelength", "elinecounter", " lineamount", "Linefound", "linerconfig", "lineamount", "linamount", "LineCount", " lineCount", "lineconst", " lineconsider", "elinecount", "linerfound", "inlinecount", "strokecount", " linefound", "elinelength", "linenumber", "linerCount", "lineCount", "inlinelength", "lincount", "inlinecounter"], "hasOWL": ["hasOWNR", "hasEWR", "hasOWS", "hasOWSLS", "hasEWLP", "hasOWSL", "hasOWSR", "HasOWSB", "hasSOLS", "HasOWSLP", "HasOWL", " hasOWNL", "hasROLP", "HasOWS", "hasRONL", "HasOWLP", "hasOHS", " hasEWLP", "hasOHB", "hasOHLP", " hasOWLP", "hasSOL", " hasEWR", "hasEWB", " hasOWLS", " hasOWSNL", "hasOWNNL", "hasSOR", "hasEWS", " hasOWSL", "hasSOLP", "hasEWL", "hasOWB", "hasOWSNL", " hasOWSLP", " hasOWR", "hasOWSLP", "HasOWSL", "HasOWSS", "hasROL", "hasOWSS", "hasOWNLP", " hasEWL", " hasEWLS", "hasOWNL", "hasOWSB", "hasEWLS", "hasROR", "hasOHL", "hasOWR", " hasOWSR", "hasOWLP", "HasOWB", "hasOWLS"], "hasRDFS": ["hasRDFB", "hasXDSS", "hasXDFDS", "hasSRDFB", "hasRNFDS", "hasORDSS", "hasRRICS", "hasXDSM", "hasSRDFS", "hasORDFM", "hasSRDSS", "hasRDSM", "hasRRIs", "hasRRIS", "hasSRDSB", "hasRNFS", "hasORDFs", "hasSRDSs", "hasRRIB", "hasRDSs", "hasRMLM", "hasRDSDS", "hasRMLs", "hasRNFM", "hasRdfS", "hasSRDFs", "hasXDFS", "hasXDFs", "hasRMLDS", "hasRMLS", "hasORDFDS", "hasRDFCS", "hasRDSB", "hasORDSDS", "hasRdfDS", "hasSRDFCS", "hasORDSM", "hasRDSS", "hasRdfM", "hasORDFS", "hasORDSs", "hasXDSs", "hasRDFDS", "hasRDFs", "hasRdfB", "hasRNFs", "hasXDSDS", "hasRDFM", "hasRDSCS", "hasSRDSCS", "hasRdfCS", "hasRdfs", "hasXDFM"], "hasRDF": [" hasRRDR", "hasDDF", "hasORDS", "hasRDR", "hasRADS", "hasRdf", " hasRRNF", "hsRRDI", "hsRDT", "hasRRDS", "hasRCD", "hasORDR", "hasRNF", "hasRCNF", "hasRTDF", "hasDCD", "hasRDI", "hasREDI", " hasRDS", "hasDNF", " hasDCD", "hasRRDT", "hasDdf", "hasRCCD", "hsRDS", "hasRADF", "hasREDS", "hasRDT", " hasRNF", " hasRCD", " hasRDR", "hasREDF", "hsRRDF", "hasRRdf", "hasORDF", "hasRRDI", "hsRDI", "hasRTDR", "hasRRNF", " hasRdf", "hasRTDS", "hasRRDF", " hasDdf", "hasRTNF", "hsRRDT", "hsRRDS", " hasRRDF", " hasRRDS", "hasREDT", " hasDDF", "hasRCdf", "hsRDF", "hasRRCD", "hasRRDR", "hasRADT", "hasRCDF", "hasORNF", " hasDNF", "hasRADI", "hasRDS"]}}
{"id1": "2518655", "id2": "16572931", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"fnOut": ["dnOutput", " fnIn", "bfNet", "synOut", " fnNet", "fnOr", "bfOut", "pdfIn", " fnOs", "bfOs", "fnOs", "fnNet", "pdfOs", "pdfOut", "dnOr", " fnOr", "synOutput", "dnIn", "dnOut", "synOr", "synIn", "fnIn", "fnOutput", " fnOutput", "bfIn", "pdfNet"], "writer": ["wright", "external", "commit", "driver", "creator", "format", "write", "wrapper", "widget", "writers", "file", "written", "editor", "reader", "journal", "and", "rator", "parser", "send", "walker", "client", "loader", "builder", "zero", "aster", "window", "fn", "close", "writ", "flush", "riter", "width", "runner", "master", "caster", "handler", "console", "w", "writing", "report", "Writer", "worker", "white", "buffer", "print", "inner", "auto", "operator", "outer", "her", "comment", "maker", "println", "service", "table", "variable"], "i": ["ij", "is", "ims", "init", "ogi", "us", "my", "gi", "id", "it", "xi", "qi", "ski", "\u0438", "ci", "li", "I", "m", "ma", "ai", "ix", "client", "gu", "ki", "x", "bi", "key", "c", "hi", "ii", "ri", "q", "u", "multi", "mi", "uri", "ic", "batch", "ind", "y", "im", "phi", "iu", "sim", "g", "ie", "me", "chain", "si", "v", "ei", "pi", "ti", "j", "ui", "di", "ini", "ip"], "fInput": [" fIn", "fileInput", "finput", "fileOutput", "lInput", "sfInput", "cfOutput", "linput", "sfIn", "fIn", "cfNew", "sfinput", " fNew", "fOutput", " finput", "cfinput", " fOutput", "fileinput", "fileIn", "lNew", "fNew", "sfOutput", "cfInput", "lOutput"], "in": ["In", "pin", "check", "is", "sin", "or", "conf", "out", "thin", "input", "rin", "al", "all", "info", "r", "it", "ln", "ma", "IN", "inn", "t", "inside", "inf", "bin", "again", "client", "vin", "ins", "n", "inc", "en", "ind", "kin", "din", "conv", "isin", "re", "cin", "serv", "con", "gin", " din", "inner", "ini"]}}
{"id1": "5760649", "id2": "18504192", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "label": 1, "substitutes": {"createFile": ["saveFiles", "saveStream", "uploadFile", "createStream", "savefile", "uploadFiles", " createStream", "createfile", "saveFile", " createfile", "uploadStream", " createFiles", "uploadfile", "createFiles"], "src": ["dest", "obj", "SOURCE", "rect", "is", "input", "url", "sc", "ser", "fp", "config", "rx", "sec", "sr", "abs", "fc", "rc", "str", "ctr", "sq", "inst", "stream", "loc", "rs", "source", "from", "txt", "uri", "pour", "comp", "sys", "ipl", "st", "sb", "resource", "res", "start", "cur", "SourceFile", "sit"], "filename": ["ren", "path", "title", "subject", "ename", "output", "FN", "file", "fp", "ln", "bf", "Filename", "string", "nl", "nm", "fn", "family", "txt", "n", "png", "xxx", "jpg", "nil", "username", "fil", "kl", "FILE", "v", "stem", "location", "name", "prefix", "SourceFile", "println"], "fis": [" fIS", "sfiss", "afiss", "sfios", "afis", "Fios", "bfiss", "fios", " fisi", "Fis", "ffis", "sfis", " fios", "afios", "fiss", "ffIS", "Fisi", "ffisi", "fais", " fais", "fIS", "ffos", " fiss", "bfis", "afais", "bfios", "FIS", "fisi", "sfais", "Fos", "bfos", "Fiss"], "fos": ["flos", " foses", " foes", "fios", "wOS", "Fis", "boes", "wios", "bis", "tis", "boss", "toss", "wis", "Foes", "foses", "tios", "wor", "foss", "Foss", "bos", "fOS", "floss", "vOS", " foss", "wos", "vor", "voses", "tos", "foes", "woss", "vos", "woses", " fOS", "flis", "flios", "Fos"]}}
{"id1": "21152728", "id2": "1235538", "code1": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"authenticate": ["Authenticate", "authenticated", " authentate", "validate", " authenticated", "authentate", "Authentate", " authenticator", "validicator", "validicated", "Authenticated", "Authenticator", "authenticator", "validicate"], "module": ["ule", "message", "library", "group", "device", "modules", "function", "Module", "component", "address", "project", "file", "instance", "config", "m", " MODULE", "network", "directory", "mode", "entry", "system", "domain", "proxy", "scope", "object", "vm", "manager", "util", "cm", "attribute", "command", "msg", "mod", "course", "option", "js", "remote", "role", "connection", "resource", "model", "security", "profile", "data", "node", "member", "service", "table"], "rand": ["dev", "nd", "ng", "range", "dr", "init", "gram", "out", "r", "err", "grad", "nt", "reg", "rx", "reader", "and", "mk", "seed", "rc", "rt", "cos", "pos", "gt", "rad", "random", "rw", "from", "go", "serial", "in", "sys", "cr", "round", "get", "crypt", "cin", "rd", "rot", "max", "res", "mr", "start", "gz", "Rand", "ro", "gen"], "challenge": ["promche", " challenges", "engeure", " challche", "challenges", "promchant", "engeape", "chape", "promenge", "chonge", "engeonge", "challote", " challchant", "scheenge", "challchant", "promenged", "engeenge", "quchall", "messote", "challure", "quenge", "scheonge", "quote", " Challche", " Challenge", "chenge", "scheure", "messenge", "challonge", "challchall", "challape", "challche", "scheape", "quenged", "promchall", "challenged", " Challenges", "promote", " Challchant", "promenges", "messchall", "messenged", "chure"], "b64": ["B58", "b4", "B4", "rb60", " b128", "rb128", "b128", "bb128", "base64", " b62", "bb64", "B128", "b60", "b58", "mb58", "mb4", "base58", "base60", "b62", "bb60", "B62", " b4", "mb62", "mb64", "base128", "rb64", " b58", "B64"], "reply": ["message", "review", "voice", "http", "out", "query", "info", "address", "err", "shell", "sync", "error", "request", "pty", "echo", "Reply", "inline", "frame", "back", "repl", "link", "send", "answer", "route", "detail", "quote", "next", "proxy", "cmd", "resp", "in", "part", "command", "result", "notice", "respond", "body", "ror", "report", "related", "ret", "remote", "re", "ply", "buffer", "delay", "server", "transfer", "res", "base", "sample", "poll", "comment", "prefix", "relation", "reset", "reverse"], "user": ["person", "message", "item", "confirmed", "device", "human", "id", "query", "type", "url", "usr", "force", "author", "users", "file", "per", "ser", "plugin", "core", "error", "use", "string", "browser", "client", "test", "system", "student", "USER", "key", "word", "term", "row", "rule", "User", "proxy", "host", "manager", "method", "char", "er", "used", "username", "owner", "password", "token", "part", "command", "valid", "result", "uid", "usa", "form", "ername", "port", "by", "parent", "remote", "me", "account", "server", "name", "admin", "nick"], "response": ["message", "bytes", "value", "out", "query", "application", "output", "error", "description", "request", "string", "success", "answer", "onse", "entry", "image", "next", "resp", "version", "password", "username", "result", "token", "command", "text", "remote", "connection", "server", "reset", "code", "res", "Response", "example", "data", "status", "secret"], "secrets": ["escets", " secources", " secuds", "privards", "escures", "Secources", "privrets", "Secures", "privures", "scources", "secients", "scuds", "privets", "escrets", "Secients", "scures", "Secets", "scients", "screts", "secards", "secets", "secuds", "Secuds", " secures", " secients", "secures", "Secrets", "escards", "secources", "Secards"], "md4": ["nd5", " md6", "nd64", "dd5", "MD44", "md64", "dd44", "MD4", "nd4", "MD6", "dd4", "sha5", "sha2", " md44", "MD2", "md6", "MD5", "nd44", "MD64", "md5", "sha6", "md2", " md5", "md44", "sha44", "sha4", " md2", "dd64"], "line": ["LINE", "message", "range", "iter", "header", "block", "online", "liner", "store", "out", "lo", "shell", "file", "ln", "login", "inline", "frame", "ine", "link", "string", "eline", "cell", "lock", "queue", "record", "email", "entry", "job", "lin", "word", "row", "detail", "page", "le", "label", "Line", "handle", "char", "msg", "ole", "sequence", "text", "body", "log", "mail", "chain", "ice", "lines", "buffer", "print", "code", "level", "comment", "l", "ip"], "passwd": ["paswd", "Passwd", " passw", "asscode", "wdcode", "Passpass", "passw", "Passwords", "asswd", "assword", "assw", "Passw", "wdw", "asswords", "passcode", "passpass", "wdword", "pasword", "pasw", "password", " passpass", " passwords", "passwords", "wdwd", "asspass", "pascode"], "hash": ["inv", "match", "message", "check", "auth", "hat", "flash", "search", "ash", "hed", "mac", "ashes", "md", "string", "str", "test", "html", "key", "score", "h", "handle", "password", "handler", "token", "shadow", "result", "style", "sha", "has", "hex", "dig", "Hash", "total", "sum", "print", "proof", "data", "her", "tag", "square"]}}
{"id1": "6963063", "id2": "665420", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"mas": ["mus", "oos", "stro", "pres", "eas", "ams", "ims", "lists", "mares", "marks", "phis", "vs", "ms", "ames", "Mas", "bas", "ma", "vers", "wal", "ias", "lands", "ums", "asks", "ales", "tis", "mast", "boxes", "ares", "ras", "as", "sts", "ists", "cas", "mails", "mers", "dal", "rums", "stal", "ints", "amas", "ris", "mons", "jas", "bs", "MAS", "asis", "mes", "als", "phas", "mont", "rices", "aus", "makes", "masters", "pse", "mon", "alis", "sa", "mis", "aos", "nets", "men", "mos", "finals", "sels", "las", "mad", "pas"], "sort": ["store", "orting", "it", "search", "save", "rol", "weight", "lib", "Sort", "tmp", "su", "first", "dir", "rm", "use", "ist", "l", "s", "send", "lock", "pos", "sup", "orted", "test", "score", "val", "alt", "rank", "label", "share", "ord", "lower", "ort", "scale", "cmp", "default", "tr", "late", "ind", "desc", "status", "port", "min", "trans", "orts", "ORT", "sum", "start", "order", "index", "alpha", "orter"], "j": ["obj", "ij", "is", "at", "it", "k", "z", "m", "dj", "lock", "bj", "jo", "job", "pr", "x", "oj", "n", "q", "br", "nr", "adj", "kj", "aj", "jit", "jas", "jj", "ja", "ind", "json", "uj", "ge", "im", "jc", "js", "ie", "g", "ji", "J", "jp", "jl", "v", "other", "jump", "fr", "ia"], "i": ["xi", "info", "I", "php", "asi", "ai", "ix", "iq", "hi", "ri", "origin", "mi", "phi", "iu", "port", "fire", "ei", "status", "ip", "ij", "is", "init", "id", "oi", "ki", "ii", "multi", "ic", "in", "sim", "chain", "zi", "iti", "ti", "ish", "ui", "ini", "iter", "qi", "\u0438", "ci", "li", "wi", "m", "iy", "gu", "ir", "io", "fi", "ind", "im", "ie", "g", "ret", "cli", "di", "ia", "ami", "ni", "gi", "it", "iii", "iso", "bi", "uri", "ori", "ji", "me", "si", "iri", "yi", "pi"]}}
{"id1": "22135199", "id2": "6501291", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": [" testCodingFullFile", " testCodingemptyFiles", " testCodingFullfile", " testCachingEmptyfile", " testCachingemptyStream", " testCodingEmptyFiles", " testCodingEmptyStream", " testCodingFullFiles", " testCachingEmptyFile", " testCachingEmptyStream", " testCodingemptyFile", " testCachingemptyFiles", " testCodingSizeFiles", " testCodingSizeFile", " testCachingemptyfile", " testCodingFullStream", " testCachingemptyFile", " testCachingEmptyFiles", " testCodingemptyfile", " testCodingSizeStream", " testCodingemptyStream", " testCodingEmptyfile", " testCodingSizefile"], "baos": ["boo", "boOS", "tao", "Baos", "booss", " baoss", "aoos", "aoOS", " baoS", "baoS", "taoS", " bao", "aoOs", "taOs", "Bao", "caoS", "baOs", "aoo", "baoss", "cao", "caos", "caOs", " baOs", "taos", "BaOs", "boos", "bao", "baOS", "Baoss", "boOs", " baOS"], "channel": ["message", "block", "cache", "out", "component", "input", "application", "context", "file", "session", "network", "queue", "client", "system", "c", "container", "window", "stream", "batch", "io", "cm", "password", "handler", "command", "caster", "console", "socket", "ch", "room", "controller", "con", "chain", "buffer", "connection", "server", "resource", "can", "Channel", "service", "chan"], "params": ["headers", "Par", "ams", "cms", "ctx", " parameters", "conf", "AMS", "Parameters", "phys", "tags", "options", "param", "fps", "config", "properties", "pretty", "parts", "pins", "caps", "proc", "types", "rs", "ops", "details", "p", "radius", "services", "settings", "password", "sys", "cmp", "limits", "spec", "json", "par", "mm", "units", "ps", "pps", "names", "pi", "data", "name", "pool"], "outbuf": ["inrb", "outbuff", "outrb", " outbuff", "outBuffer", "inBuffer", "inbuffer", "outputbuffer", " outBuffer", " outrb", "outputbuff", "Outbuffer", "Outbuff", " outbuffer", "OutBuffer", "inbuf", "Outbuf", "outputrb", "outbuffer", "outputbuf", "inbuff"], "metrics": ["metths", "monrors", " metcs", "mutrices", "mtrices", "mutrics", "mutcs", "metcs", "monrix", "matrics", "matrors", "matric", "mtths", "mutths", "metrix", "metrors", "Metrics", " metths", "monric", "metric", "monrics", "Metrix", "mtcs", "Metric", "metrices", "mtrics", " metrices", "Metrors", "matrix"], "encoder": ["ecoding", "Encuter", "enoding", "encoded", "encramer", "ecoder", "enrier", "ecrier", "execoder", "Encramer", "Encoder", "enoder", " encressor", "executer", "enramer", "Encoding", " encoding", "enressor", "encoding", "enoded", "eniever", "encrier", "execoding", " encramer", "Enciever", "execrier", "Encrier", " encuter", "eciever", "ecoded", "ecressor", "enciever", "ecramer", " encrier", " encoded", "encuter", "encressor"], "tmpFile": ["fakeFilename", "tempfile", "testFile", "imgKey", "tmpKey", "fakeFile", " tmpfile", "imgFILE", "fakeFiles", "tmpFiles", "tmpFILE", "tmpfile", "mpFilename", " tmpName", " tmpFILE", "testName", "tempFilename", " tmpFilename", "fakefile", "txtPath", " tmpPath", " tmpKey", "txtFile", "tempFile", "tmpPath", "tmpFilename", " tmpFiles", "tempPath", "testFilename", "tempKey", "tmpName", "testfile", "imgfile", "imgFile", "mpfile", "mpFile", "txtfile", "mpName", "tempFiles", "tempFILE"], "fout": ["fOut", "fullOUT", "dfOUT", "fouts", "wao", "lbal", "lout", "sfao", "lOUT", "wout", "wOut", "vao", "foutput", "fullbal", "wouts", "dfout", "fulloutput", "sfOut", "fbal", "dfoutput", "loutput", "vOut", "vouts", "fullout", "sfouts", "sfout", "fao", "dfbal", "vout", "fOUT"], "wrtout": ["wttout", "wgtout", "wdrgen", "wdrout", "wltgen", "Wrdio", "wltout", "wrcw", "Wrdn", "hwrcw", "wttio", "wrtio", "wrcex", "wwtout", "wltwriter", "Wrdwriter", "wrtex", "wrdgen", "wgtw", "ewrtout", "wrdn", "ewrtgen", "wwtw", "wrdin", "ewrtin", "wRTn", "hwrtwriter", "wdrwriter", "wrtgen", "hwrcout", "Wrtn", "wttwriter", "wgtwriter", "hwrtex", "ewltin", "ewltwriter", "Wrtio", "wwtwriter", "wrdio", "wltin", "ewltgen", "wrdwriter", "wttn", "wrtin", "wwtex", "ewltout", "wrcout", "wrcwriter", "wRTout", "hwrcex", "Wrdout", "wrtn", "Wrtwriter", "wRTio", "wgtex", "hwrtw", "Wrtout", "wRTwriter", "wrtw", "wdrin", "wrdout", "ewrtwriter", "wrtwriter", "hwrtout", "hwrcwriter"], "fchannel": ["fconsole", "flconsole", "fChannel", " fchan", "fnet", "fcchannel", "Fconsole", "Fchannel", " fcontroller", "wcontroller", "flchannel", "fcchan", "FChannel", " fconnection", "fconnection", " fconsole", "fcontroller", "fcconnection", "wconnection", "fccontroller", " fnet", "wchan", " fChannel", "fchan", "wchannel", "Fnet", "flnet", "flChannel"], "s": ["b", "ls", "gs", "is", "gets", "ts", "ds", "r", "f", "m", "sv", "t", "csv", "str", "string", "sq", "c", "n", "rs", "a", "p", "h", "S", "w", "js", "g", "e", "i", "ss", "v", "qs", "ws", "j", "sg", "ns"]}}
{"id1": "23161545", "id2": "21425787", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomCID", "getRandomGID", "getRandomGid", "getRandUid", "getRandomUid", "getRandUUID", "getRandomUUID", "getRandomSid", "getRandUID", "getRandomCid", "getRandomCUID", "getRandGID", "getRandomUID", "getRandomCuid", "getRandomGuid", "getRandomUuid", "getRandGUID", "getRandomSID", "getRandUuid", "getRandomSuid", "getRandGuid", "getRandGid", "getRandomSUID"], "secure": ["weak", "dirty", "quiet", "http", "force", "sync", " securely", "encrypted", "sec", "sr", "protect", "stable", "pretty", "https", "safe", "google", "client", "confirmed", "strong", "prime", "trust", "sys", "sensitive", "clear", "ie", "nice", "ssl", "active", "server", "security", " Secure", "status", "Secure", "service", "secret", " insecure"], "md5": ["dig3", " md6", "MD3", "md4", "md512", "MD4", "digle", "sha512", "MD6", "mdle", "sha5", "metadata3", "md3", " md3", "metadata5", "sha2", "MD2", "md6", "MD5", "MDle", "sha6", "MD512", " md512", "md2", " md4", " mdle", "metadata2", "sha3", "dig5", " md45", "md45", "metadata45", " md2", "MD45", "dig4"], "sbValueBeforeMD5": ["sbValueBeforeMP5", "sbValueWithoutMD5", "sbValueBeforeLM2", "sbValueAfterNDson", "sbValueBeforeMD2", "sbValueBeforeMS1", "sbValueBeforeDD5", "sbValueBeforemd5", "sbValueBeforeMAC2", "sbValueBeforemd2", "sbValueBeforeMDFound", "sbValueBeforeMTson", "sbValueBeforeND5", "sbValueBeforeNDson", "sbValueWithoutDD2", "sbValueBeforeDD65", "sbValueBeforeAMDson", "sbValueAfterND4", "sbValueWithoutDD5", "sbValueAfterMD5", "sbValueWithoutDD512", "sbValueWithoutMD512", "sbValueBeforeIM1", "sbValueAfterND5", "sbValueBeforeDD2", "sbValueBeforeAMDFound", "sbValueBeforeMT2", "sbValueBeforeMS2", "sbValueBeforeMD4", "sbValueBeforeOLD5", "sbValueBeforeMPLeft", "sbValueBeforeMD3", "sbValueBeforeDS5", "sbValueBeforeMACFive", "sbValueBeforeND2", "sbValueAfterMD4", "sbValueAfterMDFive", "sbValueBeforeSMson", "sbValueBeforeOLD512", "sbValueAfterMDLeft", "sbValueBeforeIM5", "sbValueBeforeSM2", "sbValueBeforeMAC65", "sbValueBeforeOLD2", "sbValueBeforeMT5", "sbValueBeforeMOD1", "sbValueBeforeMS3", "sbValueBeforeDS512", "sbValueBeforeSM4", "sbValueBeforeIMLeft", "sbValueBeforeDD512", "sbValueBeforeMDson", "sbValueBeforeMT4", "sbValueAfterMD2", "sbValueAfterMD65", "sbValueAfterMDson", "sbValueBeforeDDFive", "sbValueBeforeMS5", "sbValueBeforeMOD2", "sbValueBeforeMDLeft", "sbValueBeforeMP1", "sbValueBeforeMOD5", "sbValueBeforeSM5", "sbValueAfterND2", "sbValueBeforeMD65", "sbValueAfterMD1", "sbValueWithoutMD2", "sbValueBeforeAMD5", "sbValueBeforeND4", "sbValueBeforeDS2", "sbValueBeforeMP2", "sbValueBeforeLM5", "sbValueBeforeMDFive", "sbValueBeforeMD1", "sbValueBeforeMOD3", "sbValueBeforeMAC5", "sbValueBeforeIM2", "sbValueBeforeLM512", "sbValueBeforeMD512", "sbValueAfterMDFound", "sbValueBeforemdFound", "sbValueAfterMD3", "sbValueBeforeAMD2", "sbValueBeforemdson"], "time": ["user", "when", "counter", "value", "TIME", "ts", "id", "runtime", "times", "etime", "current", "t", "frame", "hour", "age", "client", "top", "size", "system", "ty", "estamp", "year", "tim", "est", "work", "clock", "set", "length", "Time", "race", "ime", "duration", "timer", "history", "date", "total", "now", "start", "timeout", "name", "rate", "today"], "rand": ["inv", "nd", "ng", "range", "dr", "mid", "init", "id", "rss", "r", "red", "z", "pick", "grad", "nt", "std", "reg", "and", "roll", "seed", "rc", "rt", "gt", "rad", "pid", "random", "rank", "did", "serial", "sid", "rid", "sam", "cr", "uid", "rev", "round", "dist", "frac", "rot", "rh", "rd", "quant", "res", "sample", "hash", "gz", "Rand", "rate", "gen"], "valueBeforeMD5": ["valueBeforeMOD2", "valueAfterND7", "valueBeforeMD3", "valueAfterMD7", "valueBeforeMC5", "valueBeforeMD25", "valueAfterMD2", "valueBeforeMOD3", "valueBeforeMC7", "valueBeforeMT25", "valueBeforeMD7", "valueAfterND2", "valueBeforeMT5", "valueBeforeND3", "valueBeforeMT3", "valueAfterND5", "valueBeforeMC3", "valueBeforeMT2", "valueAfterMD3", "valueBeforeMOD7", "valueBeforeMD2", "valueBeforeMC2", "valueBeforeMC25", "valueBeforeND7", "valueBeforeND2", "valueAfterND3", "valueBeforeMOD5", "valueBeforeND5"], "array": ["external", "range", "collection", "storage", "number", "audio", "Array", "binary", "address", "ary", "list", "instance", "map", "ash", "app", "vector", "record", "our", "feature", "image", "row", "random", "av", "a", "pair", "object", "share", "arr", "batch", "angle", "expression", "area", "archive", "sh", "attribute", "length", "arrow", "RAY", "buffer", "ray", "raw", "sample", "hash", "data", "rays", "response", "angular", " Array", "atomic", "var"], "sb": ["rob", "sth", "abb", "ib", "bp", "gb", "bf", "sv", "sr", "bis", "rb", "SB", "bps", "sq", "cb", "bg", "erb", "lb", "gc", "bs", "sh", "obs", "zb", "soc", "hs", "ub", "bh", "eb", "nb", "ctrl", "bb", "bsp", "ssl", "sa", "sf", "wb", "xb", "bt", "sw", "kb", "si", "lp", "ob", "db", "sg", "pb"], "j": ["obj", "ij", "jack", "us", "it", "k", "z", "_", "m", "dj", "t", "str", "bj", "jo", "job", "ix", "key", "oj", "ju", "q", "br", "kj", "ct", "aj", "off", "att", "jit", "__", "jj", "ja", "bot", "ind", "json", "uj", "msg", "yy", "jc", "js", "g", "je", "ji", "J", "i", "jp", "jl", "v", "jump", "index"], "b": ["beta", "ba", "k", "bp", "gb", "be", "ib", "bf", "ab", "bis", "bc", "rb", "cb", "bi", "bg", "a", "br", "u", "bu", "bs", "bar", "bound", "y", "eb", "nb", "bd", "B", "bb", "mb", "fb", "xb", "d", "v", "bt", "db"], "valueAfterMD5": ["valueAftermd7", "valueAfterID5", "valueBeforeMD3", "valueAftermd5", "valueAfterMD2", "valueAftermd3", "valueBeforeMD7", "valueAfterID3", "valueAfterMD3", "valueAfterID7", "valueBeforeMD2", "valueAftermd2", "valueAfterID2", "valueAfterMD7"]}}
{"id1": "1769771", "id2": "6188784", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " CopyFiles", " CopyFile", "CopyFile", "CopyStream", " copyLine", "copyLine", "CopyFiles", " CopyLine", " copyStream", " copyFiles", " CopyStream", "copyStream", "CopyLine"], "in": ["b", "In", "is", "init", "on", "input", "rin", "r", "IN", "inn", "l", "inf", "bin", " input", "ins", "source", "inc", "from", "en", "ic", "up", "io", "el", "ind", "old", "din", "mm", "isin", "cin", "i", "gin", "inner", "ini"], "out": ["b", "ex", "at", "OUT", "net", "ou", "it", "update", "err", "output", "nt", "file", "t", "help", "l", "s", "gt", "c", "Out", "n", "os", "p", "to", "up", "io", "op", "outs", "msg", "w", "po", "log", "serv", "v", "res", "o", "ot"], "inChannel": ["outchannel", "sinButton", " inRoom", " inchannel", "insideCategory", "intChannel", " inClient", " inCategory", "dinchannel", " inScope", "insideScope", " inCase", "dinConnection", "inConnection", "cinCommand", "inScope", "insideChannel", "innCase", " inChan", "outConnection", "ainCategory", " inConnection", "sinRoom", "inCategory", "innClient", "innButton", " inButton", "Inchannel", "inCase", "inClient", "inButton", "inCommand", "inRoom", "innChannel", "intchannel", "sinCase", "sinChannel", "ainScope", "insideClient", "sinClient", "cinChannel", "ainClient", "ainChannel", "intCommand", "intChan", "sinCommand", "inchannel", "inChan", "InChan", "dinChannel", "InCommand", "cinRoom", "outChan", " inCommand", "InChannel", "dinChan"], "outChannel": ["outchannel", "outputCh", "cnChan", "aosMember", "blockChan", " outChan", " outMany", "blockGate", "aosChannel", "neChan", "inCh", "outputchannel", "neChannel", "neSection", " outManager", " outCh", "outMember", "parentGate", " outchannel", " outGate", "parentChan", "aosSection", "blockChannel", "parentMany", "outputChan", "cnChannel", "outSection", "blockMany", "aosChan", "outMany", "outputManager", "outputChannel", "inMember", "parentChannel", "outCh", "neMember", "outManager", "outGate", "inchannel", "inChan", "inSection", "cnManager", "outChan"]}}
{"id1": "1180878", "id2": "1473212", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"fetchURLData": ["fectURLStream", "fectURLFrame", "fetchGETdata", "fetchURLStream", "fetchUrlFrame", "fetchStringFrame", "fetchStringdata", "fetchStringStream", "fetchUrldata", "fectUrlFrame", "fetchUrlData", "fetchURLFrame", "fetchGETData", "fectUrlStream", "fectUrldata", "fectUrlData", "fetchUrlStream", "fetchURLdata", "fectURLdata", "fetchGETFrame", "fectURLData", "fetchGETStream", "fetchStringData"], "url": ["ls", "b", "path", "dl", "full", "http", "URL", "sql", "address", "file", "l", "ur", "link", "string", "https", "gl", "cl", "web", "html", "nl", "loc", "domain", "lim", "null", "host", "uri", "pattern", "xml", "default", "el", "ref", "pl", "log", "Url", "mail", "ssl", "resource", "ul", "print", "location", "base", "name", "ll", "rel", "mount", "sl"], "proxyHost": ["slavehost", "proxyAddress", "roxyHost", "Proxyhost", "roxyOver", "proxyName", "ProxyLabel", "serverhost", "ProxyPort", "proxyUrl", "serverPort", " proxyAddress", " proxyhost", "proxyhost", "roxyLabel", "serverName", "proxyOver", "slaveOver", "ProxyName", "roxyhost", "proxyCheck", "slaveLabel", " proxyName", "roxyCheck", " proxyOver", "ProxyUrl", "slaveCheck", "slaveUrl", "roxyAddress", "roxyUrl", " proxyCheck", "proxyLabel", "serverHost", "slaveHost", "slaveAddress", "ProxyHost"], "proxyPort": ["proxyAddress", "Proxyport", "proxyport", "serverPORT", "ProxyPORT", "ProxyPort", "serverPort", "aliasHost", "aliasport", " proxyAddress", "aliasPort", "serverport", "proxyPORT", " proxyPORT", " proxyport", "aliasAddress", "serverAddress", "serverHost", "ProxyHost"], "con": ["cs", "ex", "com", "Conn", "conf", "cgi", "ver", "open", "comm", "func", "ain", "ln", "Con", "col", "fc", "cond", "pc", "bc", "cos", "ocon", "xc", "bo", "lock", "cc", "client", "proc", "cat", "c", "fin", "mo", "mc", "go", "gate", "en", "cp", "cn", "close", "cmd", "don", "cone", "canon", "fac", "act", "rec", "nc", "const", "cal", "non", "conv", "CON", "po", "dial", "sub", "pan", "trans", "ctrl", "conn", "connection", "cont", "co", "ran", "pen", "cons", "can", "cur", "syn", "cf", "connect", "cover", "un", "call"], "is": ["cs", "iter", "init", "gets", "us", "isl", "was", "ts", "fs", "dis", "ys", "iso", "abs", "bis", "IS", "ist", "isp", "isc", "s", "oss", "lis", "as", "ri", "ists", "ins", "rs", "iss", "xs", "os", "bits", "ris", "in", "are", "isf", "Is", "bs", "sys", "isi", "im", "eps", "its", "has", "isin", "ios", "ais", "ps", "i", "sis", "si", "mis", "ains", "isa", "ois", "iris", "ms", "es", "ims", "ip"], "u": ["user", " nu", "U", "us", "ou", "fu", "uf", "uu", "mu", "su", "au", "ur", "ut", "uni", "yu", "c", "ue", "tu", "uri", "bu", "ud", "pu", "up", "eu", "nu", "lu", "uj", "uid", "cu", "iu", "g", "i", "ul", "hu", "o", "ru", "ui", "uv", "un"], "proxy": ["alias", "library", "pin", "aco", "friend", "http", "cache", " prox", "address", "translation", "project", "map", "echo", "pre", "zip", "phone", "link", "bo", "browser", "https", "client", "slave", "web", "Proxy", "x", "cas", "domain", "null", "host", "go", "pro", "py", "cp", "pe", "prime", "cone", "pipe", "ping", "version", "password", "via", "gp", "shadow", "token", "policy", "embed", " proxies", "xy", "socket", "roxy", "PRO", "po", "port", "pse", "jp", "ssl", "connection", "server", "base", "pi", "profile", "timeout", "pointer", "XY", "pool", "ip"], "baos": ["BAOs", "naows", "aoOS", "aoos", " baoss", "vaOS", "bais", "naos", "poOs", "BAos", " baoS", "baoS", " baows", " bao", " bais", "aooS", "baows", "aois", "poos", "BAose", "vaoS", "BAo", "baOs", " baose", "baoss", "vaos", "poose", " baOs", "naoss", "nao", "vais", "BAows", "poo", "bao", "baOS", "baose", "BAoss", " baOS"]}}
{"id1": "6159896", "id2": "23517481", "code1": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"md5": [" MD2", "MD5", " MD4", " md4", " MD3", " md3", "md3", " MD5", "md4", "MD3", "md2", "MD4", "MD2", " md2"], "str": ["obj", "out", "input", "r", "m", "t", "s", "Str", "string", "ctr", "c", "n", "this", "txt", "a", "br", "p", "arr", "in", "char", "sp", "msg", "cr", "st", "spec", "text", "w", "STR", "wr", "enc", "print", "data", "name", "vol", "doc", "oct"], "md": ["ad", "amd", "cd", "dr", "wd", "mt", "red", "grad", "MD", "m", "pm", "dir", "rm", "der", "mk", "add", "mac", "de", "hd", "mc", "df", "dn", "dd", "pd", "cmd", "det", "cm", "msg", "mod", "ind", "pdf", "mm", "ld", "bd", "od", "mn", "mb", "d", "sd", " Md", "mg", "ms", "di", "sm", "dm"], "b": ["bit", "ba", "binary", "ib", "gb", "be", "m", "ab", "bl", "bf", "bis", "bc", "s", "rb", "bo", "cb", "c", "bi", "bg", "a", "br", "p", "bu", "bs", "y", "body", "bh", "eb", "nb", "B", "bb", "mb", "buf", "buffer", "fb", "d", "bt", "wb", "base", "ob", "db", "pb"], "sb": ["sth", "src", "abb", "sc", "ib", "bp", "gb", "shell", "sv", "bc", "rb", "sbm", "bj", "SB", "cb", "sq", "sn", "tn", "bg", "erb", "lb", "gc", "bs", "sh", "sam", "zb", "sp", "soc", "scl", "ub", "gob", "bh", "eb", "nb", "bb", "bsp", "mb", "ssl", "wb", "sf", "sa", "xb", "bt", "sw", "kb", "stab", "si", "lp", "ws", "ob", "db", "sg", "pb"], "i": ["ij", "ex", "iter", "is", "init", "my", "us", "gi", "it", "id", "xi", "qi", "ci", "li", "f", "I", "m", "asi", "di", "ai", "ix", "iq", "ri", "x", "bi", "n", "ii", "a", "u", "mi", "multi", "uri", "ic", "in", "batch", "y", "ind", "im", "phi", "iu", "sim", "ie", "e", "ji", "me", "si", "print", "ei", "o", "pi", "span", "ti", "point", "j", "ui", "index", "ini", "ip"], "v": ["lv", "value", "vp", "ver", "vi", "it", "vis", "k", "vs", "vv", "f", "m", "sv", "nv", "t", "l", "s", "vector", "vd", "c", "x", "uv", "val", "av", "n", "q", "vm", "qv", "u", "cv", "ve", "V", "tv", "version", "va", "w", "rev", "conv", "iv", "g", "vc", "vt", "d", "pi", "j", "ev", "var"], "cc": ["cs", "ce", "cd", "tc", "sc", "card", "ci", "fc", "bc", "cell", "cb", "cl", "c", " CC", "mc", "cv", "ac", "gc", "ct", "cn", "icc", "CCC", "cp", "cycle", "char", "kk", "CC", "C", "cm", "acc", "nc", "cmp", "cu", "cod", "ca", "cci", "vc", "uc", "cy", "cca", "ctrl", "cont", "ck", "co", "cf", "code", "xx", "lc"], "returnString": ["ReturnNow", "ReturnStr", "returnNow", "newNow", "ReturnString", "runNumber", "newText", "ReturnList", "runList", "runStr", "returnText", " returnList", "returnStr", "ReturnText", " returnStr", "runString", "newString", " returnNow", " returnNumber", " returnText", "returnNumber", "ReturnNumber", "newStr", "returnList"]}}
{"id1": "15241397", "id2": "2465747", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 0, "substitutes": {"doGet": ["doget", "DoGET", " doGET", " doget", "handleget", "DoGet", "doGET", "handleGET", " doPut", "handlePut", "handleGet", "doPut", "Doget", "DoPut"], "request": ["setup", "message", "transform", "user", "the", "http", "each", "QUEST", "input", "query", "application", "address", "context", "first", "reference", "current", "frame", "quest", "client", "req", "Request", "in", "forward", "initial", "attribute", "document", "command", "position", "report", "get", "re", "question", "complete", "connection", "server", "create", "start", "hello", "reset"], "response": ["reply", "message", "block", "ce", "http", "write", "application", "context", "output", "description", "session", "frame", "network", "send", "success", "answer", "onse", "image", "next", "page", "object", "exit", "ve", "resp", "xml", "version", "document", "result", "site", "json", "sequence", "respond", "body", "view", "console", "report", "position", "form", "fire", "connection", "content", "server", "print", "resource", "res", "Response", "status", "service", "reset"], "rewrittenQueryString": ["rewrittenqueryString", "rewrittenQuestionString", "rewrittenHeaderStream", "rewwrittenqueryStr", "rewrittenquerystring", "rewrittenRequestStr", "rewrittenURLStr", "rewrittenQuString", "rewrittenQuStr", "rewwrittenqueryString", "rewrittenHeaderString", "rewartedQueryStream", "rewrittenCurrentString", "rewwrittenQueryQuery", "rewrittenHeaderstring", "rewwrittenqueryQuery", "rewrittenRequestQuery", "rewrittenURLStream", "rewliedQueryStream", "rewwrittenQuerystring", "rewrittenCurrentQuery", "rewrittenQueryStream", "rewrittenQuerystring", "rewliedQueryStr", "rewartedQueryStr", "rewrittenQuStream", "rewartedHeaderstring", "rewrittenQuestionStr", "rewrittenqueryStream", "rewrittenURLString", "rewliedQueryString", "rewrittenRequeststring", "rewartedQuerystring", "rewartedQueryString", "rewrittenQustring", "rewartedHeaderStream", "rewrittenRequestString", "rewrittenCurrentstring", "rewwrittenquerystring", "rewrittenHeaderStr", "rewwrittenQueryString", "rewrittenQueryQuery", "rewrittenCurrentStr", "rewrittenqueryStr", "rewrittenqueryQuery", "rewartedHeaderString", "rewliedqueryString", "rewartedHeaderStr", "rewliedqueryStr", "rewwrittenQueryStr", "rewliedqueryStream", "rewrittenQueryStr", "rewrittenQuestionStream", "rewrittenURLstring"], "rewrittenUrl": ["rewrapedPort", "rewartedURL", "RewwrittenURL", "rewittenLink", "rewrapedUrl", "rewrapedURL", "rewadjustedURL", "rewartedurl", "rewrownURL", "rewwrittenLink", "rewriterUrl", "rewrownUrl", "RewrittenURL", "rewadjustedPort", "RewrittenUrl", "Rewrittenurl", "RewwrittenLink", "rewedString", "rewroteUr", "RewwrittenPosition", "rewittenURL", "rewrittenurl", "rewrittenString", "rewartedUrl", "RewrittenLink", "RewrittenPort", "rewwrittenString", "rewriteURL", "rewrittenURL", "rewroteLink", "rewrittenUr", "rewrownPosition", "rewrapedUr", "rewriteUr", "rewwrittenUr", "RewrittenPosition", "rewriteurl", "rewrittenLink", "rewittenurl", "rewittenUrl", "RewrittenString", "Rewwrittenurl", "rewriterURL", "RewwrittenPort", "rewedUrl", "rewwrittenPosition", "rewwrittenPort", "rewriddenURL", "RewwrittenString", "rewrownUr", "rewartedPosition", "RewwrittenUrl", "rewwrittenurl", "rewroteurl", "rewrittenPort", "rewedUr", "rewriterString", "rewriteUrl", "rewadjustedUr", "rewadjustedUrl", "rewroteUrl", "rewriddenPosition", "rewedURL", "rewriddenUr", "rewartedUr", "rewriterUr", "rewriddenUrl", "RewwrittenUr", "rewwrittenUrl", "rewrittenPosition", "rewrotePosition", "RewrittenUr", "rewroteURL", "rewwrittenURL"], "httpURLConnection": ["httpHTTPConfiguration", "ttpUrlConnect", "httpMLApplication", "ttpURLApplication", "httpSRApplication", "httpSRConnection", "httpURLConnect", "httpHTTPConnect", "httpMLconnection", "httpRLConnect", "httpURLConfiguration", "ttpUrlconnection", "HttpHTTPConnect", "HttpURLConnection", "httpMLConnect", "httpSRControl", "httpUrlconnection", "ttpURLConnect", "ttpURLconnection", "HttpHTTPApplication", "httpRLconnection", "HttpURLconnection", "ttpUrlControl", "httpHTTPConnection", "httpMLConnection", " httpURLConnect", "ttpUrlConnection", "HttpURLApplication", " httpUrlconnection", " httpUrlApplication", "ttpUrlApplication", "httpUrlControl", "HttpURLConnect", "HttpHTTPconnection", "httpSRConnect", " httpUrlConnect", "httpUrlApplication", "httpHTTPConn", "httpUrlConfiguration", "httpHTTPControl", "httpSRconnection", "httpUrlConnection", "HttpUrlConnection", "httpUrlConn", "ttpURLConnection", "httpRLApplication", "ttpURLControl", "HttpUrlConnect", "httpFileConnect", "httpURLApplication", " httpURLconnection", " httpURLApplication", "HttpHTTPConfiguration", "HttpUrlconnection", "httpSRConfiguration", "httpRLConnection", "httpFileConnection", "ttpURLConn", " httpUrlConnection", "HttpURLConfiguration", "httpURLControl", "httpURLconnection", "HttpHTTPConnection", "ttpUrlConn", "httpFileConn", "httpFileApplication", "httpHTTPconnection", "httpUrlConnect", "httpHTTPApplication", "httpURLConn"], "header": ["headers", "user", "block", "check", "dr", "init", "format", "title", "device", "shift", "heading", "component", "query", "info", "wrapper", "address", "argument", "core", "head", "zone", "client", "padding", "feature", "rule", "peer", "term", "detail", "page", "Header", "h", "ter", "layer", "handle", "er", "version", "attribute", "part", "field", "token", "handler", "state", "policy", "hidden", "option", "meta", "port", "line", "buffer", "event", "metadata", "holder", "hash", "operator", "column", "comment", "section", "status", "filter", "tag", "prefix", "relation", "variable"], "value": ["message", "VALUE", "format", "save", "Value", "address", "des", "instance", "description", "current", "sv", "zone", "string", "vector", "python", "record", "entry", "test", "job", "key", "email", "ue", "val", "label", "pair", "unit", "expression", "version", "password", "attribute", "default", "field", "element", "json", "sequence", "text", "property", "see", "server", "content", "v", "create", "sample", "language", "data", "example", "comment", "hash", "hello", "name", "values"], "inputStream": ["inputThread", "errorSteam", " inputSteam", "InputLoop", "InputView", "outputThread", " inputView", "outputLoop", " inputLoop", "InputThread", "inputWindow", "InputStream", "errorstream", "outputstream", " inputstream", "outputWindow", " inputThread", "inputLoop", "outputSteam", "errorWindow", "inputView", "inputSteam", "outputView", "inputstream", " inputWindow", "errorStream"], "outputStream": ["displaySteam", "responseForm", "responseLength", "displayStream", " outputView", "responseSteam", "outputForm", " outputSteam", "OutputSteam", "OutputStream", "displaystream", "outputstream", " outputLength", "outputSteam", "displayView", "responseStream", " outputForm", "inputView", "inputSteam", "outputLength", "OutputLength", "outputView", "inputstream", " outputstream", "OutputForm"]}}
{"id1": "10728243", "id2": "22035737", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    private static void loadMappings(Configuration cfg) {\n        try {\n            Enumeration en = LoadingUtils.getResources(MAPPINGS_FILE);\n            while (en.hasMoreElements()) {\n                URL url = (URL) en.nextElement();\n                logger.info(\"Found mapping module \" + url.toExternalForm());\n                InputStream inputStream = null;\n                try {\n                    inputStream = url.openStream();\n                    HibConfiguration hm = loadModuleMappings(inputStream);\n                    configureModuleMappings(cfg, hm.getSessionFactory());\n                } catch (IOException e) {\n                    logger.warn(\"Could not load mappings file \\\"\" + url.toExternalForm() + \"\\\"\", e);\n                } catch (JAXBException e) {\n                    logger.warn(\"Unable to instantiate JAXBContext \", e);\n                } finally {\n                    try {\n                        if (inputStream != null) inputStream.close();\n                    } catch (IOException e) {\n                        logger.debug(e);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            logger.warn(\"Could not find any mappings file hibernate.mappings.xml\", e);\n        }\n    }\n", "label": 0, "substitutes": {"scramble411": ["scramlepassword", "scramlePassword", "scrambledBasic", "scrambledPassword", "scramblepassword", "scramle ", "scamblesBasic", "scamble ", "scramblePassword", "scrambledpassword", "scramblespassword", "scrambled ", "scamblepassword", "scamblesPassword", "scrambleBasic", "scamblePassword", "scramble ", "scambleBasic", "scrambles ", "scramblesPassword", "scramleBasic", "scramblesBasic", "scambles ", "scamblespassword"], "password": ["remember", "message", "user", "sword", "words", "auth", "pass", "Password", "wd", "address", "database", "description", "secret", "string", "padding", "email", "key", "word", "primary", "pattern", "username", "attribute", "shadow", "token", "text", "crypt", "hash", "profile", "data", "phrase", "prefix", "hello", "reset"], "seed": ["setup", "template", "Salt", "offset", "sudo", "sql", "mix", "ser", "secret", "se", "feed", "vector", "padding", "test", "entry", "key", "needs", "random", " seeded", "source", "df", "derived", "prime", " seeds", "initial", "shadow", "sex", "sequence", "eed", "eder", "start", "sample", "rand", "create", "hash", "example", "phrase", "index", "reset"], "md": ["ad", "nd", "pt", "amd", "cd", "dr", "dh", "gm", "mt", "grad", "red", "nt", "MD", "m", "mp", "pkg", "rm", "pm", "der", "ma", "mk", "exec", "ann", "rpm", "de", "hd", "managed", "mind", "mc", "df", "img", "multi", "pd", "cmd", "dd", "def", "ct", "addr", "det", "cm", "msg", "ind", "mod", "desc", "sha", "pdf", "mm", "ld", "med", "bd", "od", "dig", "mn", "mb", "rd", "esm", "td", "metadata", "sd", "d", "mand", "mg", "ms", "di", "sm", "dm"], "passwordHashStage1": ["passwordHashSHA0", "passwordHashPhaseOne", "passwordhashStage2", "passwordHashstage01", "passwordHashStage5", "passwordHashSHA2", "passwordHashstage2", "passwordhashstage1", "passwordHashstage0", "passwordHashStageOne", "passwordHashPage2", "passwordHashStage0", "passwordHashPhase0", "passwordHashSHA01", "passwordHashstage1", "passwordHashPage0", "passwordHashPhase2", "passwordHashPhase1", "passwordhashStageOne", "passwordhashStage0", "passwordhashStage1", "passwordHashPage5", "passwordhashstage2", "passwordHashstageOne", "passwordHashPage1", "passwordHashstage5", "passwordhashstage0", "passwordHashSHA1", "passwordHashStage01", "passwordhashstageOne"], "passwordHashStage2": ["passwordSaltStage62", "passwordHashStyle62", "passwordHashScene3", "passwordSaltStage2", "passwordHashstage2", "passwordHashStyle3", "passwordHashstageTwo", "passwordHashPhase4", "passwordHashVersionTwo", "passwordHashStyle2", "passwordHashstage1", "passwordHashStage4", "passwordHashStage3", "passwordHashPhase2", "passwordHashPhase1", "passwordHashVersion1", "passwordHashStageTwo", "passwordHashPhaseTwo", "passwordHashVersion4", "passwordSaltStage3", "passwordSaltStageTwo", "passwordHashStage62", "passwordHashScene62", "passwordHashSceneTwo", "passwordHashStyleTwo", "passwordHashVersion2", "passwordHashstage4", "passwordHashScene2"], "toBeXord": ["toBeYor", "tobeYor", "toBeXor", "tobeXor", "tobeYords", "toBeZords", "tobeXold", "toBeTxond", "toBeZor", "toBEXorg", "toBeXLor", "toBEXord", "toBeXond", "toBeZXold", "toBEXor", "toBeZXord", "toBeXords", "toBeYords", "toBexorg", "toBeXLord", "toBeTxords", "toBeZXords", "toBexor", "toBeYord", "toBeYod", "toBeYold", "toBexord", "toBeXorg", "toBEXords", "toBeZord", "tobeXords", "toBeXLords", "tobeYold", "toBeXold", "toBEXod", "toBeTxord", "toBexond", "toBeXLod", "toBEXond", "tobeYord", "toBeYorg", "toBeTxorg", "tobeXorg", "toBeZorg", "tobeXord", "tobeYorg", "toBexords", "toBeXod", "toBeZXor"], "numToXor": ["num2Xors", "numToRestor", "numToRestore", "num2Xor", "num2Xore", "num2Restore", "numToXors", "numToxord", "numtoYOR", "numToZors", "numtoYors", "numToYor", "numToxors", "numtoXord", "num2Restors", "numToYors", "num2Restor", "numToYOR", "numtoYor", "numToxOR", "numToZOR", "num2RestOR", "numToZord", "numtoXOR", "numToXord", "numtoXor", "numToxore", "numtoYord", "numToYord", "numToXOR", "numToZore", "numToXore", "numToRestors", "numToZor", "numtoXors", "numToRestOR", "numToxor", "num2XOR"], "i": ["ex", "is", "init", "ni", "us", "gi", "it", "qi", "xi", "k", "info", "ci", "li", "ms", "z", "I", "m", "\u0438", "t", "s", "ai", "ix", "ri", "x", "bi", "n", "ii", "multi", "u", "mi", "uri", "ic", "in", "batch", "io", "fi", "y", "ind", "set", "sequence", "im", "phi", "sim", "g", "e", "ie", "ji", "si", "span", "ei", "pi", "zi", "o", "ti", "cli", "j", "ui", "di", "ini", "ip"]}}
{"id1": "3430784", "id2": "5299276", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeBody": ["decprocessBody", "decodeHeader", "decprocessHeader", " DecodeForm", " DecodesContent", "decodedForm", "decprocessForm", "decprocessContent", " DecodesForm", "decodeContent", " DecodesBody", "decodedContent", " DecodesHeader", "decodesHeader", " DecodeContent", "decodesContent", "decodedBody", " DecodeHeader", "decodesForm", "decodesBody", "decodeForm", " DecodeBody", "decodedHeader"], "in": ["b", "In", "on", "info", "file", "IN", "inn", "pc", "add", "inf", "ai", "ins", "source", "inc", "xml", "oin", "body", "mat", "get", "cin", "con", "conn", "i", "v", "ex", "is", "init", "or", "input", "rin", "al", "sql", "all", "r", "ain", "ma", "c", "vin", "act", "mm", "isin", "serv", "cont", "asin", "inner", "iter", "check", "k", "m", "inside", "load", "req", "n", "en", "up", "ind", "din", "nin", "gin", "data", "doc", "it", "reader", "l", "bin", "from", "q", "ac", "h", "to", "form", "content", "pi"], "contentTransferEncoding": ["contentTransferCollasting", "contentTransferEncode", "contentTransferFormoder", "contentTransferEncoded", "contentTransferChoding", "contentTransferEncation", "contentTransferencling", "contentTransferencacing", "contentRequestencoded", "contentTransferFormoding", "contentTransferencication", "contentTransferCollation", "contentTransferChapping", "contentTransferEncapping", "contentTransferEnoder", "contentTypeEncapping", "contentInfoencacing", "contentTypeEnapping", "contentTransferEnling", "contentTransferFormType", "contentTransferChoded", "contentTransferEnType", "contentTransferEnode", "contentTransferColloding", "contentTransferEnasting", "contentRequestEncasting", "contentTransferEnation", "contentTransferEvoded", "contentTransferAuthoding", "contentInfoencling", "contentTransferAuthoder", "contentRequestEnasting", "contentInfoEncoding", "contentTransferEncacing", "contentTransferencType", "contentTransferencoded", "contentRequestEncation", "contentTransferEncType", "contentRequestEnation", "contentRequestEncoding", "contentTransferEnoding", "contentTransferEnoded", "contentTransferSeapping", "contentRequestEncType", "contentInfoencoder", "contentTypeEnode", "contentTransferSeoded", "contentTransferSeoding", "contentRequestencoding", "contentTransferencoding", "contentTransferEvoder", "contentTransferChode", "contentTypeEncoded", "contentTransferAuthType", "contentTypeEncode", "contentTransferEnacing", "contentInfoEncling", "contentRequestEnoding", "contentRequestEncoded", "contentTransferEncling", "contentTransferEncasting", "contentRequestencication", "contentRequestEncication", "contentTypeEncoding", "contentTransferEvication", "contentTypeEnoding", "contentTransferEnication", "contentRequestEnoded", "contentTransferEncication", "contentInfoencoding", "contentInfoEncacing", "contentRequestEncoder", "contentRequestEnoder", "contentRequestencoder", "contentTransferAuthoded", "contentTypeEnoded", "contentTransferEnapping", "contentTransferColloder", "contentTransferSeode", "contentInfoEncoder", "contentTransferEvoding", "contentTransferencoder", "contentRequestEnType", "contentTransferFormling", "contentTransferEncoder"], "tempBody": ["tabFoot", "tempFoot", "tabReturn", " temporaryBox", "tabBox", "tempReturn", "tmpHead", "TempFile", " temporaryFoot", "TempHead", "tempBox", "TempBody", " tempbody", "temBody", "tempbody", "tabBody", "tempFile", "tempHead", " temporaryReturn", "temFoot", " temporaryBody", "tmpBody", "temBox", "temReturn", "temFile", "temHead", "Tempbody", "tembody", " tempBox", " tempFile", "tmpbody", " tempHead", "tmpBox"], "out": ["inv", "obj", "user", "ex", "is", "OUT", "net", "ou", "it", "all", "output", "m", "t", "l", "cos", "oss", "client", "Out", "n", "null", "one", "os", "ent", "cn", "gc", "to", "up", "io", "sys", "outs", "writer", "conv", "OU", "log", "cin", "con", "co", "sum", "inner", "v", "aos", "o", "outer", "auto", "res"]}}
{"id1": "6371607", "id2": "3731077", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"removeRealm": ["remrealms", "removeRealM", "removeRealmo", "removeSchems", "removeSchem", "removerealms", "removePerarm", "remRealM", "removeRealms", "remRealmo", "remrealarm", "removePerms", "removeRealarm", "remrealmo", "removerealm", "removeAlmo", "remRealm", "removerealM", "removeAlms", "removePerm", "remRealms", "removeAlm", "remrealM", "removePerM", "removePermo", "removerealarm", "removeScheM", "remrealm", "removerealmo", "removeSchemo", "removeAlarm", "remRealarm"], "realmIds": ["realmidsList", "realmidsParts", "realmsByIdNames", "realmIdParts", "realmsByIdList", "realmsByIdls", "realmIdls", "realmidsls", "realmIdids", "realmByIdParts", "realmByIds", "realmByIdls", "realmsIdNames", "realmIdNames", "realmsByIdids", "realmPathParts", "realmsIds", "realmidss", "realmidsNames", "realmsByIds", "realmIdList", "realmsIdls", "realmIDls", "realmIDNames", "realmPathids", "realmByIdids", "realmsByIdParts", "realmsIdList", "realmsIdids", "realmPathls", "realmIDs", "realmidsids", "realmsIdParts", "realmIDList", "realmByIdList", "realmPaths", "realmByIdNames"], "psImpl": ["psInstance", "psExpl", "epsImpl", "psStack", "psimpl", "epsimpl", "pseInstance", "pseEl", "PSimpl", "epsExpl", " psObj", "ppsInstance", "pseImpl", "ppsStack", "PSExpl", " psStack", "ppsEl", " psInstance", "PSEl", "pseStack", " psEl", " psExpl", "PSObj", "psObj", "ppsExpl", "ppsimpl", "ppsImpl", "PSImpl", "epsObj", "psEl", " psimpl"], "iter": ["inv", "iz", "liter", "ptr", "cer", "it", "ver", "vis", "ip", "Iter", "li", "older", "vers", "ser", "per", "walker", "fer", "ir", "former", "loc", "ator", "lim", "oper", " iv", "ait", "nr", "ter", "coll", "ider", "er", "upper", " iterator", "loop", "ger", "valid", "ner", "ind", "iner", "its", "iv", "hex", "ori", "gener", "iterator", "i", "iller", "outer", "inter", "her", "ev", "ipper", "gen"], "realmId": ["realgmId", "realomInd", "balmid", "balgmId", "RealmPath", "realmiId", "balgmid", "realgmIs", "realmiIs", "reallemid", "realomId", "realmeId", "realnPath", "balgmID", "balmID", "palmid", "pallemID", "realmReference", "realomReference", "palmID", "trvId", "RealmById", "realnById", "realmiid", "palmId", "realgRef", "realMId", "pallemId", "palmInt", "RealMRef", "realvmIs", "realmanReference", "realvmId", "RealMId", "trmReference", "realmeInt", "realmiID", "realvmid", "realgmid", "realMPath", "realvInd", "realmeID", "RealmRef", "trmID", "trvID", "realmRef", "trvInd", "reallemID", "realgId", "RealMPath", "realomID", "realvReference", "RealMById", "realvID", "realvmID", "realnRef", "realmiInt", "realMRef", "realgmID", "reallemInt", "reallemId", "realmIs", "realmeid", "trvReference", "trmId", "pallemInt", "trmInd", "realmanId", "realMById", "balgmIs", "realmInd", "realnId", "realmanInd", "balmIs", "realmID", "realmid", "RealmId", "pallemid", "realgById", "realmInt", "realvId", "balmId", "realmPath", "realmanID", "realgPath", "realmById"]}}
{"id1": "13207437", "id2": "614099", "code1": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"sendRequestObjectResponse": [" sendRequestHttpResponse", " sendRequestHttpresponse", " sendRequestStringResponse", " sendRequestStringBlock", " sendGetObjectBlock", " sendGetObjBlock", " sendRequestStringRes", " sendRequestHttpBlock", " sendRequestObjResponse", " sendRequestObjectresponse", " sendGetObjRes", " sendGetObjectresponse", " sendGetObjectResponse", " sendRequestObjresponse", " sendRequestObjectBlock", " sendGetObjectRes", " sendRequestHttpRes", " sendRequestObjRes", " sendRequestStringresponse", " sendGetObjResponse", " sendRequestObjectRes", " sendRequestObjBlock", " sendGetObjresponse"], "servletName": ["servterInfo", "servletname", "servletsName", " servletname", "servletValue", "servletNAME", "servLETNAME", "servletInfo", "servleNAME", "servterKey", " servleCode", "servLETNames", "servletsNames", "servtname", "servtName", " servletKey", "servLETName", "servlerNames", "servtNAME", "servlername", " servletInfo", "servletsname", " servleKey", "servletNames", " servletsNames", "servleValue", " servletValue", " servletsKey", " servleName", "servleName", "servletKey", "servlename", "servleInfo", " servlename", " servletsname", "servLETname", "servterValue", "servleKey", " servleValue", " servleInfo", "servletsInfo", "servLETKey", " servletNAME", "servlerKey", "servletsKey", "servtCode", "servletCode", " servletsName", "servLETCode", "servleCode", " servletNames", "servletsValue", "servlerName", "servterName", " servletCode", " servleNAME"], "request": ["reply", "message", "QUEST", "input", "id", "query", "argument", "param", "session", "task", "quest", " input", "req", "key", "Request", "q", "object", "method", "command", "result", "json", " Request", " req", "server", "resource", "model", "base", "response"], "osRoot": ["sysHome", "sysroot", " osHome", "sysRoot", " osroot", "sysPath", "OSroot", "osroot", "OSHome", "OSRoot", "osHome", "OSPath", "osPath", " osPath"], "fname": ["fullpath", "Fname", "fullname", "fName", "fullName", "Fpath", "Fversion", "fpath", " fpath", " fName", " fversion", "fullversion", "fversion", "FName"], "retobj": [" retobject", "Retobj", "resultobject", " retObj", "resultObj", "Retjs", "Retobject", "resultjs", "retjs", "RetObj", " retjs", "retobject", "resultobj", "retObj"], "myurl": ["myemail", "MyUrl", "myURL", "Myurl", "yemail", "mysURL", "serverurl", "serveremail", "yurl", "yUrl", "serverll", "myUrl", "Myuri", "mysUrl", "meurl", "yll", "serverUrl", "mxport", "mysuri", "Myport", "myuri", "myll", "mxURL", "mysurl", "MyURL", "mosurl", " myemail", "meUrl", "mosport", "mosUrl", "mxUrl", "meuri", "mxurl", "mosURL", " myUrl", " myll", "meURL"], "myport": ["mipport", "mypport", " myports", "someport", "meeport", "mylength", "memberport", "mepport", "miports", " mywidth", "miwidth", "miPORT", "mylimit", "milimit", "mineport", "mysport", "yourport", "somepport", "myports", "myPORT", "somePort", " mypport", "minefloat", "serverPort", "myort", "mewidth", "mysPORT", "serverport", "mywidth", "yourPORT", " myfloat", "minePORT", "tyPort", "Mylength", "mysPort", "mePORT", " mylimit", " mymobile", "miparent", "serverPORT", "somePORT", "memberPORT", "meport", "miport", "minetag", "Myport", "mimobile", "mifloat", "miPort", " myeport", "meports", " mytag", "memobile", "myparent", "myPort", "yourfloat", "tyort", "memberpport", " mylength", " myparent", "typort", "mymobile", "mieport", " myort", "memberPort", "MyPORT", "myeport", "yourpport", "yourPort", "Mypport", " myPort", "myslimit", "tyfloat", "myfloat", "mytag", "mitag", "yourort", "serverlength", "meparent", "MyPort", " myPORT"], "codebase": ["codBase", "xyBase", "codbuffer", "Codebasic", " codeBase", "codeb", "codebased", "coeb", " codebasic", "chebase", "Codebased", "tebase", "coebase", "codebas", "chebased", "CodeBase", "Codebase", "xybased", "Codeb", "coebuffer", "codebuffer", "chebas", " codebas", " codebased", "codebasic", "tebas", "codbase", "cheBase", "codeBase", "Codebuffer", "coeBase", "xybasic", "xybase", "tebased", "teBase", "codb"], "serverURL": ["serverUR", "serUrl", "ServerURI", "ServerURL", "consoleALL", "serALL", "erverRL", " serverER", "serverurl", "serverER", "verURL", "serurl", " serverRL", "ServerUrl", "erverURL", "serviceUrl", "serverRL", " serverUrl", "erverHTML", " serverurl", "clientUrl", "verFILE", "Serverurl", "clientALL", " serverURI", "clientUR", "serverALL", "serverUrl", " serverALL", "serverHTML", " serverUR", "erverEL", "ServerEL", "verurl", "consoleURI", "serviceURL", "erverUrl", "serUR", "serviceurl", "serviceALL", "erverOUT", "consoleOUT", "consoleURL", " serverOUT", "serviceRL", "erverurl", "serverOUT", " serverHTML", "verER", "erverUR", " serverEL", "erverER", "serverFILE", "ServerUR", "serverEL", "serviceEL", "clientURL", "serURL", "erverURI", " serverFILE", "serHTML", "erverALL", "erverFILE", "serverURI"], "ipdig": [" ipd", "hexmd", "ippder", " sipdig", "ipplug", " ipplug", "hipbd", "icdig", "hexDig", " ipdel", "ippbd", "ippcd", "ipder", "ipd", "hipcd", " ipmd", "ipcd", " sipd", " ipbd", "hexdig", "ipdel", "ippmd", " ipDig", " sipcd", "ipmd", "hipdel", "iccd", "hipd", " ipcd", "icplug", "hexder", "hipDig", " sipDig", "icdel", "ippDig", "ipDig", " ipder", "ippd", "hipdig", "ipbd", "ippdig", "hipplug"], "url": ["ls", "dl", "http", "URL", "uf", "uu", "open", "r", " URL", "l", "ur", "gl", "au", "https", "browser", "str", "loader", "org", "ocl", "nl", "web", "row", "uri", "gc", "util", "rl", "il", "www", "el", "impl", "deb", "Url", "log", "conn", "ssl", "ul", "ll", "ob", "mount", "sl"], "urlconn": ["webann", "Urlconn", "lconn", "urlConn", "urlann", "browserConn", "UrlConn", "urlcert", "lcon", "lcert", "webcon", " urljs", " urlcon", "lConn", "urlcon", "urljs", "Urlann", "browsercert", "Urlcon", "browserconn", "webConn", "httpcon", "webconn", "Urljs", "webcert", "httpConn", " urlann", "httpconn", " urlConn", "browsercon", "httpjs"]}}
{"id1": "7087108", "id2": "15409512", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"doGet": ["doget", " handleGET", "invokeSet", " doSet", "doSet", "invokeGET", " doGET", " doget", " handleGet", " handleSet", "doGET", "invokeGet", " handleget", "invokeget"], "request": ["setup", "change", "message", "transform", "the", "http", "store", "each", "QUEST", "input", "query", "url", "application", "open", "address", "select", "subject", "relative", "project", "context", "instance", "first", "core", "reference", "construct", "frame", "quest", "client", "req", "Request", "begin", "info", "handle", "forward", "xml", "initial", "attribute", "document", "command", "version", "requ", "report", "position", "post", "get", "search", "re", "controller", "remove", "worker", " Request", "enter", "complete", "question", "raw", "server", "model", "create", "order", "hello", "index", "local", "reset", "call"], "response": ["reply", "message", "ce", "http", "out", "write", "application", "context", "output", "description", "frame", "success", "onse", "image", "next", "one", "page", "os", "resp", "xml", "default", "result", "view", "respond", "body", "report", "re", "render", "connection", "server", "print", "res", "Response", "status", "respons"], "path": ["dest", "Path", "transform", "th", "check", "template", "value", "full", "title", "where", "prop", "query", "url", "relative", "filename", "output", "select", "project", "pkg", "dir", "config", "string", "test", "PATH", "key", "system", "route", "patch", "p", "uri", "pattern", "text", "ath", "hex", "temp", "log", "chain", "print", "location", "base", "name", "prefix", "mount"], "file": ["library", "user", "check", "full", "binary", "f", "be", "output", "filename", "real", "link", "bo", "lock", "load", "job", "rule", "key", "image", "word", "run", "source", "le", "page", "null", "object", "fe", "table", "ile", "to", "handle", "tree", "document", "result", "bar", "valid", "spec", "console", "bool", "view", "report", "form", "port", "FILE", "e", "ca", "mail", "upload", "disk", "chain", "resource", "model", "base", "name", "db", "channel", "File", "local", "relation"], "in": ["In", "read", "is", "sin", "or", "on", "thin", "out", "input", "it", "rin", "al", "IN", "inn", "and", "reader", "s", "l", "bin", "again", "as", "ins", "one", "source", "inc", "mc", "en", "ic", "up", "copy", "cm", "ind", "kin", "din", "mm", "isin", "cin", "mn", "con", "i", "gin", " din", "ck", "sum", "inner", "asin", "sample", "pic", "ini"]}}
{"id1": "20623709", "id2": "6470716", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"split": ["Split", "read", "format", "parse", "write", "open", "sync", "map", "join", "use", "count", "append", "lock", "share", "unit", "batch", "copy", "scale", "part", "slice", "upload", "disk", "process", "align", "seek", "transfer", "scan"], "targetDirectory": ["localDirectory", "basedirectory", "TargetMemory", "baseMemory", "Targetdirectory", "localFile", "targetFile", "TargetDir", " targetMemory", "targetDir", "TargetFolder", "targetFolder", "TargetLocation", " targetFolder", "targetLocation", "baseDirect", "testDirectory", "targetMemory", "targetDirect", " targetFile", "localDir", "baseFile", " targetDir", " targetLocation", "baseDirectory", "targetdirectory", "testDir", " targetDirect", "testDirect", "TargetDirect", "TargetDirectory", "localdirectory", "baseDir", "baseFolder", "testLocation", " targetdirectory"], "prefix": ["alias", "path", "pres", "template", "format", " suffix", "title", "type", "filename", "pkg", "pre", "ix", "directory", "padding", "root", "zero", "size", "key", "fixes", "this", "p", "FIX", "uri", "fixed", "pattern", "version", "password", "fix", "username", "command", "PRE", "Pref", "status", "base", "pi", "name", "division", "tag", "index", "localhost"], "maxUnitBases": ["maxUnityBias", "maxUnitReplases", "maxUnitReplages", "maxUnityAliias", "maxUnityLounds", "maxUnitbases", "maxUnitChias", "maxUnitChicas", "maxUnitChounds", "maxUnitLages", "maxUnitLounds", "maxUnitChases", "maxUnitReplicas", "maxUnitAliases", "maxUnitLicas", "maxUnitBades", "maxUnityBicas", "maxUnitBounds", "maxUnityLages", "maxUnitbades", "maxUnitAliias", "maxUnityLicas", "maxUnitbias", "maxUnitChades", "maxUnitBicas", "maxUnitbounds", "maxUnityBades", "maxUnityBases", "maxUnityAliades", "maxUnitBages", "maxUnityBages", "maxUnitLases", "maxUnityBounds", "maxUnitAliades", "maxUnitBias", "maxUnitAliounds", "maxUnitChages", "maxUnitReplounds", "maxUnityAliounds", "maxUnityLases", "maxUnityAliases"], "maxUnitEntries": ["maxUnitErrys", "maxUnitIntegries", "maxUnityentires", "maxunitEntrys", "maxUnityEntries", "maxUnityentries", "maxUnityentrys", "maxUnitentires", "maxUnitEntryrys", "maxUnitEntryriers", "maxUnitentrs", "maxUnitIntegrys", "maxUnitIntegriers", "maxUnityEntrys", "maxUnitIntegires", "maxunitEntires", "maxUnitEntriers", "maxUnityEntrs", "maxUnitentrys", "maxUnitEntrys", "maxunitEntries", "maxUnitErries", "maxUnityentrs", "maxUnitEntryries", "maxUnitentries", "maxUnitErires", "maxUnitErrs", "maxUnitEntrs", "maxUnitEntryires", "maxUnityEntires", "maxUnitEntires", "maxunitEntrs"], "fis": ["Fii", "fic", "vis", " fii", "vi", " fic", "Fis", "ifii", "ifis", "Fic", "vic", "fiss", "ific", "fi", "viss", "ifci", " fiss", " fi", "Fci", "fii", "Fi", "Fiss"], "fci": [" fico", "cfco", " fini", "mco", "fic", " fii", " fic", " fcu", "Fis", "fcu", "cfai", "Fini", "cfico", "mci", "cfci", "Fic", "tii", "Fico", "tcu", "fai", "mii", "Fai", "Fco", " fai", "fini", "tci", "cfini", "mcu", "tco", "cfic", "cfis", "Fci", "fii", "fico"], "fos": ["flos", "yos", "waos", "flOS", "fios", "fbos", "wios", " fios", "Foss", "foss", "FOS", "yios", "fOS", " fbos", "floss", "Faos", " foss", "wos", "faos", "yaos", " fOS", "flaos", "wbos", "Fos", " faos", "ybos"], "fco": [" fso", "Fso", "pci", "Fdo", "tdo", "pcos", "Foco", " fcos", "tcos", " fdo", "Fcon", "cco", "fcos", "pco", "fcon", "fso", "Fcos", "Fco", "ccon", "cso", "foco", "fdo", "pso", "tco", "cdo", " fcon", " foco", "Fci", "toco"], "buffer": ["message", "library", "block", "match", "read", "channel", "template", "function", "bridge", "iter", "note", "cache", "binary", "address", "database", "append", "queue", "record", "padding", "entry", "memory", "Buffer", "window", "row", "limit", "source", "filter", "batch", "flush", "char", "document", "result", "command", "sequence", "length", "black", "position", "callback", "stack", "temp", "pause", "buf", "event", "complete", "order", "reset", "print", "holder", "sample", "buff", "data", "timeout", "comment", "phrase", "index", "button", "table"], "currentBasesCount": ["currentbasesCode", "currentbasesCount", "currentbasesLength", "currentBasedLength", "currentBasesLength", "currentBadesCount", "currentBaseLength", "currentBaseCode", "currentbaseCode", "currentBaseCount", "currentBasedCode", "currentBadesCode", "currentbaseCount", "currentBadesLength", "currentbaseLength", "currentBasedCount", "currentBasesCode"], "currentEntriesCount": ["currentEntriesCode", "currentEntiesFlag", "currentEntrsCount", "currentEntriesFlag", "currentEntrsCode", "currentEntiesCount", "currentEntrysFlag", "currentEntrysCode", "currentEntrysCount", "currentEntiesCode", "currentEntrsFlag"], "targetCount": ["TargetAmount", "targetAmount", "argetCount", " targetInfo", " targetAmount", " targetNum", "TargetNum", "targetInfo", "argetAmount", "argetInfo", "targetNum", "argetNum", "TargetInfo", "TargetCount"], "fastaChannel": [" fastoQueue", "fastaiStream", "fastityStream", " fastaStream", "fastaStream", "fastaProvider", "fastoChannel", "fastoQueue", "fastaiQueue", " fastaProvider", " fastaChan", " fastaConnection", "fastoStream", "fastoButton", " fastoStream", "fastoChan", " fastaButton", "fastityChan", "fastaButton", "fastpaButton", "fastoConnection", "fastpaChannel", "fastpaConnection", "fastaiChannel", "fastaQueue", "fastityChannel", " fastoChan", "fastoProvider", " fastaQueue", "fastityQueue", " fastoChannel", "fastaChan", "fastaiChan", "fastaConnection", "fastpaProvider"], "totalSeqCount": ["totalSeQCount", "totalSeqSize", "totalSeqCounter", "totalSeqsCount", "totalSeQCode", "totalSegCounter", "totalSeqCode", "totalSeqsCounter", "totalSegCount", "totalSeQCounter", "totalSegCode", "totalSeqsSize", "totalSeqsCode", "totalSeQSize", "totalSegSize"], "totalResiduesCount": ["totalResiduesCode", "totalResidusCount", "totalResIdueFlag", "totalResidueCount", "totalResidusCode", "totalResIduesCount", "totalResidueFlag", "totalResIduesFlag", "totalResiduationsFlag", "totalResIduesCode", "totalResIdueCount", "totalResIdueCode", "totalResiduesFlag", "totalResidusFlag", "totalResidueCode", "totalResiduationsCount", "totalResiduationsCode"], "prevTime": ["parTime", " previousT", "parThread", "prevThread", "parT", " prevThread", "prevT", " prevT", " previousTime", " previousThread"], "fastaFileSize": ["fastaFileOwner", "fastoFileSIZE", "fastaFilesHeight", "fastaChainOwner", "fastAFileName", "fastATableLength", "fastaReaderLength", "fastafileOwner", "fastoFileSize", "fastaChainLength", "fastoTableSize", "fastaChainSIZE", "fastaReaderSize", "fastaChainSize", "fastaTableOwner", "fastaFileSIZE", "fastaReaderName", "fastaFileHeight", "fastAFileSize", "fastAFileLength", "fastATableHeight", "fastoFileOwner", "fastaTableSize", "fastATableName", "fastaFileLength", "fastAFileHeight", "fastaFilesLength", "fastafileSize", "fastoFileLength", "fastaFilesSize", "fastaTableLength", "fastafileSIZE", "fastoTableOwner", "fastaTableName", "fastaReaderHeight", "fastafileLength", "fastoTableLength", "fastATableSize", "fastaFilesName", "fastoTableSIZE", "fastaFileName", "fastaTableHeight", "fastaTableSIZE"], "fastaFileReadOffset": ["fastaChainCurrentOffset", "fastaFileViewPos", "fastaFileReadoffset", "fastaFileCurrentLocation", "fastaChainReadoffset", "fastaPageReadOrder", "fastaFileReadOrder", "fastaFileReadPosition", "fastaFileReadLocation", "fastaFileInputoffset", "fastaFileInputLength", "fastaFilesLoadAmount", "fastaFilereadOffset", "fastaPageLoadOrder", "fastaChainReadLocation", "fastaFileCurrentOffset", "fastaChainReadPosition", "fastaFileWriteOrder", "fastaPageReadOffset", "fastaFileWriteLength", "fastaPageLoadOffset", "fastaFileReadPos", "fastaFileCurrentoffset", "fastaFileReadLength", "fastaChainReadOffset", "fastaFileReaderLocation", "fastaFilesLoadOrder", "fastaFilereadAmount", "fastaFilereadOrder", "fastaFileInputLocation", "fastaFileCurrentPosition", "fastaChainCurrentPosition", "fastaChainCurrentoffset", "fastaFileLoadOrder", "fastaFileReaderoffset", "fastaPageReadPos", "fastaFileInputOffset", "fastaPageLoadAmount", "fastaFileLoadLength", "fastaPageLoadPos", "fastaFilesLoadLength", "fastaFileViewOffset", "fastaFileReaderPosition", "fastaFileReaderOffset", "fastaFileLoadAmount", "fastaPageReadAmount", "fastaFileLoadOffset", "fastaChainCurrentLocation", "fastaFileWriteOffset", "fastaFileInputPosition", "fastaFileReadAmount", "fastaFileViewOrder", "fastaFileLoadPos", "fastaFilesLoadOffset", "fastaFilesReadAmount", "fastaFileInputAmount", "fastaFilesReadLength", "fastaFileInputOrder", "fastaFileWriteAmount", "fastaFilereadPos", "fastaFileViewAmount", "fastaFilesReadOffset", "fastaFilesReadOrder"], "partitionStartOffset": ["partitonStartingOffset", "partitionStartingOffset", "partitonStartPosition", "partitionStartPosition", "partitonStartPoint", "partitionStartOff", "partitionStartingOff", "partitionEndPosition", "partitonStartOff", "partitionDataOff", "partitonStartOffset", "partitionDataPoint", "partitionDataOffset", "partitionEndOff", "partitionStartingPosition", "partitonStartingPosition", "partitonStartingOff", "partitonStartingPoint", "partitionStartPoint", "partitionDataPosition", "partitionEndPoint", "partitionStartingPoint"], "bufferSize": ["bufferSIZE", "tableSize", "tableName", "bufCode", "BufferSize", "bufferName", "buffSIZE", " bufferLength", "bufferLength", "tableLength", "bufferCode", "BufferSIZE", "sequenceLength", "bufSize", "sequenceCode", " bufferCode", "buffLength", "buffName", "buffSize", "bufSIZE", "sequenceSIZE", "sequenceSize", "tableSIZE", " bufferSIZE", "BufferName", "bufLength", "BufferLength"], "fastaBuffer": ["FastmaStore", "fastoBuff", "fastoCounter", "fastasRequest", "FastaRequest", "fastaBuilder", "fastsaBuffer", "fastmaCache", "fastuBuff", "fastasBuilder", "fastmaBuff", "fastasCache", "wildaBuff", "wildaRequest", "FastaBuff", "fastaBuff", " fastoQueue", "fasteBuffer", "fastmaBuilder", "fastcaCache", " fastaBuilder", "fasteMemory", "fastcaRequest", "FastaStore", " fastoBuffer", "fastuMemory", "fastaRequest", "fastasBuff", "fastuDB", "fastaCounter", "fastasStore", "fastsaQueue", "fastaMemory", "wildanRequest", " fastoBuff", "fastalBuff", "FastaBuffer", "fastaStore", "wildaCache", "fastaDB", "wildanBuff", "fastasCounter", "fastmaRequest", "fastoQueue", "fastmaStore", " fastaCounter", "fastoRequest", "fastoStore", "fasteBuff", " fastaMemory", "wildanCache", " fastaDB", "fastmaChannel", "fastmaQueue", " fastaQueue", " fastaCache", "fastasQueue", "fastcaBuff", "fastalCounter", "fastanBuffer", " fastoCounter", "fastsaBuff", "fastanRequest", "fasteDB", "fastanCache", "fastalBuffer", "FastmaBuff", "fastanBuff", "fastaCache", "fastmaBuffer", "fastoBuffer", "FastmaBuffer", "fastasBuffer", "wildaBuffer", "fastalQueue", "wildanBuffer", " fastaBuff", "fastsaChannel", "fastaQueue", "fastcaBuffer", "FastmaRequest", "fastuBuffer"], "fastaReadState": ["fastaReadType", "fastoReadState", "fastaCurrentSTATE", "fastaReaderState", "fastaLoadSTATE", "fastaLoadType", "fastaReadSTATE", "fastaReaderStatus", "fastaReaderSTATE", "fastoReadType", "fastaReaderType", "fastoReaderType", "fastaCurrentState", "fastoReadSTATE", "fastaCurrentStatus", "fastoReaderSTATE", "fastaLoadState", "fastaReadStatus", "fastoReaderStatus", "fastaLoadStatus", "fastoReaderState", "fastaCurrentType", "fastoReadStatus"], "nBytes": ["nrItems", "nobytes", "nrBytes", "numBlocks", "noNs", "nWords", " nKeys", "NItems", "numbytes", "noBlocks", "numNs", "nsbytes", "nsWords", "nNs", "nParts", "numBytes", "nKeys", "nBlocks", "NBytes", "nbytes", "noBytes", "nItems", " nNs", "NWords", "Nbytes", "NKeys", " nBlocks", " nbytes", "nsBytes", " nItems", "nsParts", "nrKeys", "NParts", " nWords", "nrbytes", " nParts"]}}
{"id1": "17522011", "id2": "5607440", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"read": ["transform", "iter", "check", "format", "parse", "input", "Read", "find", "write", "open", "download", "info", "walk", "select", "sync", "file", "config", "reader", "php", "link", "reads", "load", "test", "req", "word", "stream", "run", "READ", "close", "handle", "view", "text", "show", "report", "reading", "get", "build", "process", "rd", "raw", "resource", "content", "print", "create", "it", "readable", "hello", "reflect", "required"], "classLoader": ["thisloader", "Classloader", "moduleLoader", "ClassLoading", "moduleloader", "classLoading", "moduleReader", "thisLoader", "ClassLoader", " classManager", "classloader", "ClassReader", "thisReader", " classReader", "ClassManager", "moduleLoading", "ClassPath", " classloader", "fileManager", "fileLoader", " classPath", "thisPath", "fileReader", "classPath", "classManager", "classReader", "fileLoading", " classLoading"], "name": ["alias", "message", "path", "title", "id", "search", "type", "filename", "file", "m", "description", "current", "l", "common", "string", "root", "size", "nm", "key", "Name", "word", "family", "n", "missing", "label", "null", "source", "password", "part", "named", "old", "ame", "ref", "parent", "NAME", "names", "resource", "base", "prefix", "order", "local"], "all": ["collection", "multiple", "empty", "full", "many", "force", "optional", "list", "first", "any", "enabled", "and", "m", "required", "always", "also", "n", "null", "multi", "global", "both", "loop", "All", "attribute", "default", "valid", "ALL", "none", "only", "allowed", "active", "total", "oll", "latest", "each", "local"], "sm": ["tm", "imm", "igm", "arms", "SM", "sy", "Sm", "gm", "wm", "mt", "km", "tem", "shell", "m", "pm", "ym", "rm", "sem", "md", "sbm", "mg", "sym", "rpm", "nm", "asm", "sk", "cm", "sam", "sp", "mm", "sim", "hm", "mn", "mb", "hem", "esm", "sf", "ism", "arm", "model", "mem", "bm", "mph", "ms", "dm"], "enu": ["Enui", "enuu", "annu", "attenfu", "EnU", "deniu", "attenuu", "Enpu", " enfu", "Enu", "ennu", "denfu", "erpu", "eniu", " eniu", "attenu", "erui", "enus", "anu", " enui", "anus", "erU", " enU", " enus", "Ennu", " ennu", " encu", "encu", "enfu", " enuu", "enU", " enpu", "denuu", "ancu", "Enus", "denu", "atteniu", "eru", "enui", "enpu", "Encu"], "url": ["ls", "b", "user", "path", "dl", "cert", "net", "http", "URL", "r", "f", "open", "db", "pkg", "bl", "add", "l", "ur", "link", "gl", "browser", "job", "web", "nl", "key", "arl", "mount", "uri", "char", "rl", "il", "sp", "ol", "sb", "ref", "log", "Url", "build", "resource", "v", "bel", "base", "ll", "ob", "pl", "rel", "sl"], "is": ["ls", "mus", "nis", "iter", "init", "mos", "rest", "isl", "was", "out", "vis", "it", "fs", "dis", "vs", "iso", "abs", "bis", "tis", "IS", "isc", "oss", "lis", "ri", "ir", "ins", "iss", "bits", "os", "ris", "mi", "gc", "in", "act", "bs", "isf", "Is", "are", "ires", "sys", "obs", "isi", "im", "its", "has", "js", "isin", "sim", "ais", "ios", "ps", "i", "sis", "mis", "ism", "isa", "ois", "iris", "ms", "es", "ims", "ip"], "s": ["ls", "cs", "b", "css", "gs", "gets", "ts", "ds", "fs", "sql", "ves", "f", "m", "join", "ats", "sv", "abs", "prints", "l", "csv", "t", "string", "str", "less", "ols", "ags", "parts", "sts", "ings", "c", "ists", "results", "n", "tes", "rs", "os", "p", "h", "arts", "ies", "S", "y", "uts", "set", "hs", "sol", "its", "js", "conv", "g", "sb", "ps", "stats", "ss", "v", "qs", "ains", "ries", "ws", "ms", "es", "ns"]}}
{"id1": "886783", "id2": "6625074", "code1": "    private static void doGet(LNISoapServlet lni, String itemHandle, String packager, String output, String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {\n        String itemURI = doLookup(lni, itemHandle, null);\n        URL url = LNIClientUtils.makeDAVURL(endpoint, itemURI, packager);\n        System.err.println(\"DEBUG: GET from URL: \" + url.toString());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setDoInput(true);\n        fixBasicAuth(url, conn);\n        conn.connect();\n        int status = conn.getResponseCode();\n        if (status < 200 || status >= 300) {\n            die(status, \"HTTP error, status=\" + String.valueOf(status) + \", message=\" + conn.getResponseMessage());\n        }\n        InputStream in = conn.getInputStream();\n        OutputStream out = new FileOutputStream(output);\n        copyStream(in, out);\n        in.close();\n        out.close();\n        System.err.println(\"DEBUG: Created local file \" + output);\n        System.err.println(\"RESULT: Status=\" + String.valueOf(conn.getResponseCode()) + \" \" + conn.getResponseMessage());\n    }\n", "code2": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"doGet": ["doget", "DoGET", " doGET", " doget", "handleget", "DoGet", "doGET", "handleGET", " doPut", "handlePut", "handleGet", "doPut", "Doget", "DoPut"], "lni": [" lini", "Lnis", "slti", "slne", "Lti", "lne", " lti", "rnis", "rni", " lnis", "lini", "lti", "Lini", "rne", "lnis", "rti", "Lni", "Lne", "slini", " lne", "slni"], "itemHandle": ["ItemH", "ItemHandle", " itemID", "itHand", "itemID", "issueHandle", "issuehandle", "itemhandle", "ItemID", "ithandle", "itHandle", "itemHand", "itemH", "Itemhandle", "issueID", " itemHand", " itemH", " itemhandle", "itID", "ItemHand", "issueH"], "packager": ["packsaler", "packagers", " packagger", "packageaging", " packagers", "packsager", " packaging", "packsagger", "packsaging", "packageagger", "packenger", "facagger", " packaler", " packenger", "packaler", "packagger", "packaging", "packageager", "packsenger", "facaler", "facenger", "facager", "packageagers", "packsagers"], "output": ["put", "message", "path", "ilo", "format", "value", "display", "ou", "input", "write", "filename", "error", "file", "written", "current", "string", "client", "directory", "absolute", "region", "key", "source", "page", "label", "PUT", "unit", "handle", "xml", "username", "hidden", "text", "target", "port", "OU", "log", "temp", "buffer", "connection", "resource", "print", "location", "o", "outer", "response", "data", "name", "prefix", "column", "generated", "Output"], "endpoint": ["ndPoint", "beginpoint", "ndpt", "beginPoint", "ndpoint", "endspt", "endsPoint", "beginpt", "endpoints", "endspoint", "Endpt", "EndPoint", "Endpoint", "endspoints", "ndpoints", "beginpoints", "Endpoints", "endpt", "endPoint"], "ProtocolException": ["PrototypeWarning", "ProtilingException", "protocolException", "protocolError", "ProticationWarning", "proticationException", "PrototypeError", "ProticationException", "protocolWarning", "ProticationError", "ProtocolWarning", "ProtilingWarning", "PrototypeException", "proticationWarning", "proticationError", "ProtilingError", "ProtocolError"], "IOException": ["RuntimeException", " IOGroup", "NetworkException", " IOOver", "IOGroup", "NetworkOver", "NetworkGroup", "RuntimeGroup", "IOOver", "RuntimeOver"], "FileNotFoundException": ["FileAlreadyPresentError", "FileNotPresentException", "FileNotFoundWarning", "FileAlreadyPresentException", "FileAlreadyFound ", "FileAlreadyPresent ", "FileAlreadyFoundWarning", "FileNotPresentWarning", "FileNotFound ", "FileAlreadyPresentWarning", "FileAlreadyFoundException", "FileNotPresentError", "FileNotFoundError", "FileNotPresent ", "FileAlreadyFoundError"], "itemURI": ["resourceuri", " itemID", "itemURL", "itemID", "resourceID", "ItemID", "resourceURI", " itemRI", "Itemuri", "ItemURI", "itemRI", "storeuri", "ItemRI", "resourceURL", " itemuri", "storeRI", "storeURL", "ItemURL", " itemURL", "itemuri", "storeURI"], "url": ["ls", "path", "dl", "http", "URL", "sql", "r", "f", "abs", "l", "ur", "parser", "str", "fl", "browser", "client", "web", "html", "nl", "org", "key", "term", "loc", "this", "domain", "null", "q", "host", "uri", "gc", "cmd", "handle", "char", "rl", "il", "xml", "el", "sb", "ref", "kl", "impl", "build", "Url", "re", "pl", "get", "con", "ssl", "log", "server", "ul", "bel", "location", "base", "res", "name", "ll", "mount", "sl", "un"], "conn": ["obj", "auth", "Conn", "net", "init", "cert", "ctx", "conf", "wp", "yn", "open", "comm", "err", "subject", "that", "nt", "sync", "stat", "exec", "ann", "cell", "client", "cb", "org", "c", "req", "fin", "ns", "close", "cp", "en", "cn", "ct", "cmd", "resp", "canon", "addr", "act", "gen", "pas", "nc", "sys", "compl", "msg", "iw", "typ", "desc", "socket", "ch", "conv", "enc", "ctrl", "con", "jp", "ssl", "connection", "cont", "syn", "res", "cur", "ws", "connect", "db", "att", "pg", "cfg", "call"], "status": [" Status", "ex", "pres", "US", "is", "format", "http", "cgi", "wait", "number", "id", "progress", "sc", "fs", "iso", "z", "login", "ser", "wa", "current", "stat", "use", "s", "sem", "str", "success", "size", "html", "x", "score", "uses", "source", "resp", "atus", "compliance", "xml", "Status", "version", "compl", "result", "sex", "state", "json", "st", "msg", "spec", "access", "ret", "es", "e", "re", "stats", "ssl", "server", "d", "code", "res", "esp", "sw", "response", "name", "prefix", "index", "service", "STAT", "magic"], "in": ["In", "read", "iter", "is", "sin", "dr", "init", "on", "input", "rin", "it", "id", "r", "ln", "IN", "inn", "inside", "str", "inf", "bin", "ai", "irm", "ins", "source", "from", "inc", "en", "up", "xml", "ind", "old", "st", "body", "im", "din", "mm", "isin", "min", "re", "cin", "mn", "i", "gin", " din", "cont", "inner", "ini"], "out": ["inv", "ex", "check", "at", "net", "OUT", "ou", "all", "it", "err", "nt", "list", "t", "cos", "oss", "gt", "Out", "n", "null", "os", "ent", "en", "cn", "good", "to", "cmd", "io", "ne", "sys", "outs", "set", "ch", "writer", "conv", "OU", "g", "cont", "co", "sum", "inner", "v", "res", "o", "aos", "outer", "vol"]}}
{"id1": "2009072", "id2": "7372311", "code1": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 0, "substitutes": {"openInput": ["createOutput", " openOutput", "OpenRead", "openinput", "Openinput", " openinput", "createRead", "OpenOutput", "OpenInput", "createInput", " openRead", "openOutput", "createinput", "openRead"], "path": ["pt", "Path", "rect", "transform", "message", "pat", "full", "template", "com", "cert", "prop", "component", "progress", "query", "f", "context", " PATH", "pkg", "request", " expansion", "app", "tx", "test", "PATH", "self", "entry", "route", "patch", "platform", "txt", "cp", "cmd", "pattern", "part", "msg", "text", "w", " oath", "exp", "desc", "form", "ref", "ath", "mat", " pat", "log", "conn", " remainder", "pointer", "name", "phrase", "mount", "fr", "doc"], "len": ["ls", "lan", "li", "nt", "ln", "t", "count", "l", "pos", "L", "size", "nl", " clen", "fin", "loc", "n", "lim", "en", "h", "lon", "il", "el", "lf", "length", "mil", "seq", "Length", "Len", "dec", "enc", "ld", " length", "lp", "ll", "pl", " l", "sl", "un"], "p": ["b", "pp", "wp", "vp", "pa", "f", "pkg", "m", "param", "fp", "pre", "t", "s", "l", "pr", "c", "pid", "n", "press", "q", "cp", "u", "h", "pattern", "part", "sp", "ps", "jp", "d", "v", "P", "np", "lp", "prefix", "j", "ap", "pb"], "url": ["b", "ls", "user", "cert", "http", "URL", "out", "r", "f", "l", "ur", "gl", "link", "str", "browser", "client", "job", "web", "html", "nl", "window", "loc", "null", "hl", "uri", "char", "ref", "ret", "mail", "Url", "log", "build", "ssl", "server", "ul", "bel", "base", "ll", "mount", "sl"], "result": ["Result", "message", "cert", "value", "uu", "open", "r", "output", "database", "instance", "request", "currency", "current", "surface", "product", "success", "proc", "true", "answer", "feature", "results", "stream", "pair", "successful", "mate", "sequence", "report", "ret", "process", "event", "res", "profile", "response", "comment", "relation", "table", "cup", "region", "pak"]}}
{"id1": "947406", "id2": "823074", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["ls", "init", "download", "save", "Cop", "sync", "paste", "map", " cp", "csv", "link", "load", " replicate", "printf", "cat", "clone", " cop", "move", "cp", "gc", "Copy", "slice", "delete", "upload", "transfer", "create", " Copy", "println"], "src": ["ls", "init", "input", "sc", "Source", "usr", "url", "subject", "tmp", "pkg", "ser", "config", "sec", "rx", "sr", "rc", "ctr", "sq", "inst", "req", "fx", "ins", "rs", "source", "from", "orig", "img", "bs", "rl", "sys", "st", "sb", "iv", "dist", "sf", "start", "cur", "rel", "sit", "obs"], "dest": ["rest", "id", "usr", "del", "home", "tmp", "des", "dir", "Dest", "https", "test", "origin", "req", "loc", "end", "source", "nom", "orig", "pub", "good", "decl", "master", "est", "mod", "st", "desc", "target", "mm", "temp", "deg", "trans", "dist", "cont", "d", "nw", "pas"], "in": ["In", "read", "user", "iter", "pin", "is", "sin", "or", "init", "net", "on", "input", "rin", "it", "win", "al", "info", "r", "all", "ain", "ma", "IN", "ln", "inn", "m", "file", "l", "inside", "inf", "bin", "ai", "ar", "ins", "inc", "mc", "from", "en", "ac", "mi", "act", "ini", "up", "ind", "st", "oin", "din", "mm", "isin", "min", "ie", "cin", "con", "conn", "i", "gin", "ck", "co", "raw", "inner", "o", "local", "doc"], "out": ["obj", "user", "ex", "at", "net", "OUT", "note", "ou", "on", "it", "write", "output", "oe", "nt", "file", "list", "rem", "t", "cos", "oss", "bin", "client", "gt", "Out", "null", "one", "os", "en", "not", "cn", "cmd", "to", "flush", "up", "io", "ne", "sys", "outs", "writer", "conv", "mit", "no", "nin", "con", "conn", "co", "sum", "inner", "can", "aos", "o", "outer", "res", "ot", "ns"], "buf": ["b", "block", "bytes", "prop", "uf", "mu", "cap", "pkg", "col", "bl", "bc", "rb", "queue", "cb", "cat", "Buffer", "font", "br", "cv", "img", "cmd", "box", "batch", "bs", "good", "len", "bag", "bar", "msg", "cam", "seq", "tab", "ref", "conv", "bh", "aka", "Buff", "log", "buffer", "mb", "vec", "pad", "fb", "cf", "cur", "mem", "buff", "bus", "db", "gen"], "n": ["b", "ren", "ni", "on", "nn", "number", "yn", "k", "z", "N", "nt", "m", "ln", "t", "l", "nor", "gn", "nm", "nl", "sn", "en", "cn", "num", "nan", "len", "ne", "nc", "acc", "nu", "y", "na", "no", "an", "nb", "mn", "i", "names", "nos", "d", "syn", "v", "span", "max", "ll", "j", " l", "ns", "un"]}}
{"id1": "23273706", "id2": "8778962", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getApptreeInfo", "getProjectNodeList", "getProjectListList", "getProjectTreeInfo", "getProjecttreeInfo", "getProjectListData", "getAppTreeData", "getApptreedata", "getAppTreeInfo", "getApptreeData", "getProjecttreedata", "getProjectListdata", "getProjectTreeList", "getApptreeList", "getProjectListInfo", "getProjecttreeData", "getAppTreeList", "getProjectNodeInfo", "getProjecttreeList", "getAppTreedata", "getProjectNodedata", "getProjectNodeData", "getProjectTreedata"], "treeData": ["reeList", "treeValid", "TreeData", "tableValid", "reeDat", "tableInfo", "cacheData", "listDat", "listData", "TreeMap", " treeInfo", "treeMap", " treePart", "reeData", "towerData", "statusData", "tableData", "treeDat", "treeList", "cachePart", "TreeInfo", "listPart", "towerDat", " treeDat", " treeValid", "tableMap", " treeMap", "reeMap", "treeInfo", "tableDat", "cacheDat", "reeInfo", "statusMap", "towerValid", "treePart", "tableList", "statusDat", " treeList"], "filename": ["path", "KEY", "generation", "title", "URL", "fs", "url", "sql", "ename", "output", "save", "ames", "file", "fp", "FN", "fps", "FS", "Filename", "string", "original", "directory", "uno", "root", "key", "fn", "source", "txt", "png", "jpg", "uri", "lua", "nil", "username", "fil", "json", "folder", "river", "URI", "ername", "FILE", "temp", "FIL", "fax", "metadata", "location", "latest", "name", "SourceFile", "prefix", "println", "local", "localhost"], "urlString": ["lService", "urlService", "uristring", "urlSite", "UrlString", "lString", "uriSite", "URLString", " urlService", " urlstring", "uriSingle", "lstring", "UrlSingle", "urlstring", "uriString", "URLSingle", "Urlstring", "callStr", "URLstring", "callstring", "callService", "callString", "UrlSite", "urlSingle", " urlStr", "lStr", "urlStr", "URLSite"], "urldata": ["udlenatum", "urrdatum", "udldescription", " urldedata", "udlenata", "urldedata", " urldATA", "urrdescription", " urldatum", "urldeatum", " urldeata", "urledata", "urldatum", "udlenescription", "urldeATA", "udldatum", "uriledata", "urledatum", "urlenATA", "urldeata", "uriledATA", "urleddata", "udlenATA", "urrdATA", "urrdata", " urldeATA", "udldATA", "urlfatum", "urileddata", "urlfescription", "urlfata", " urlddata", "udldata", " urldeatum", "urlenata", "urldATA", "urlenatum", "urlenescription", "urldescription", "urledATA", "urlddata", "uriledatum", "urlfATA"], "factory": ["votype", " fFactory", "fixture", "FFactory", "facter", "facixture", "affFactory", "efacet", "Facter", "efFactory", "Factory", "vFactory", "fault", "frozen", "fFactory", "Fixture", "Frozen", "affotype", "facacter", " fixture", "fotype", "affactory", "efactory", "facault", "facactory", "Facet", "vactory", "vacter", " frozen", "Fotype", "Fault", " fault", "efrozen", "affacter", "facet", " facet", " facter"], "parser": ["Reader", "jack", "parse", "apache", "fascist", "file", "instance", "fp", "reader", "arser", "php", "au", "walker", "loader", "builder", "sup", "x", " df", "actory", "p", "df", "Parser", "processor", "manager", "util", "expression", "er", "xml", " parse", "io", "power", "command", "policy", "writer", "pdf", "conv", " parsing", "sf", "dom", "utils", "bank", " p"], "u": ["U", "us", "ou", "fu", "uf", "it", "uu", "mu", "url", "r", "su", "au", "l", "ur", "ut", "ue", "tu", "p", "uri", "h", "util", "io", "eu", "nu", "lu", "uid", "cu", "iu", "ua", "hu", "ul", "o", "ru", "ui", "uv", "un"], "is": ["us", "isl", "it", "fs", "ib", "dis", "iso", "ms", "ys", "info", "abs", "IS", "bis", "ist", "isc", "ai", "oss", "lis", "ri", "ar", "ir", "ists", "ins", "iss", "ris", "ic", "in", "are", "Is", "il", "ires", "io", "obs", "sys", "rys", "isi", "ost", "im", "its", "has", "iu", "ios", "ais", "sis", "si", "mis", "isa", "iris", "ui", "es", "ims"], "os": ["ls", "oos", "OS", "dos", "osa", "css", "or", "us", "oses", "out", "fs", "des", "ys", "ms", "oes", "ows", "s", "cos", "oss", "pos", "ens", "as", "Os", "bos", "ops", "osi", "bs", "ost", "io", "sys", "uts", "socket", "ios", "es", "ox", "so", "ss", "ros", "oa", "et", "aos", "o", "ot", "mos", "obs"], "iBufSize": ["iBbufLen", "iBufCount", "iBufSIZE", "iRufLength", "iLbufCount", "iBuffsize", "iRufSIZE", "iBphSize", "iBuffLen", "iBbufCount", "iLufsize", "iBuffSize", "iRbufLength", "iLufLen", "iRbufSize", "iLbufsize", "iBbufsize", "iBulLen", "iBufLength", "iRbufSIZE", "iRufCount", "iLufCount", "iLufSize", "iBuffLength", "iBbufSize", "iBulCount", "iBufLen", "iBphSIZE", "iRufSize", "iBbufLength", "iLbufSize", "iBulSize", "iBuffSIZE", "iLbufLen", "iBphCount", "iBbufSIZE", "iRbufCount", "iBulsize", "iBuffCount", "iBufsize", "iBphLength"], "inBuf": [" inRbuf", " inRuc", "inBufferuff", "inBuc", "InBuf", "inBiguc", "InChbuf", "InBuff", "inBufferBuff", "inBbuf", "inBufferuf", "inRuff", "inRuf", "inLbuf", "outBuf", "inBBuff", "outBul", "inLuf", " inBbuf", "inBlul", "inBlbuf", "outRBuff", "inChuf", " inRbuff", "outBbuf", "inChbuf", "InChBuff", "inBufferbuf", "outRuf", "inBiguf", "inRuc", "inRBuff", "inBuff", "outRul", "InChuf", "outBBuff", "InBBuff", "inBufferul", "inChBuff", "InBbuf", "inRbuf", "inBigbuff", "inRbuff", " inBuc", "inBul", "inChuff", "inLbuff", "InChuff", "inBlBuff", "inRul", "outRbuf", "inLuc", "inBigbuf", " inRuf", "inBluf", "inBbuff", " inBbuff"], "iNumRead": ["iNumFind", "INumRun", "iNUMRun", "inumPrint", "iLenRead", "iiNumRead", "aiNumRead", "aiNumberRead", "iNumberWrite", "iNumDef", "aiNumWrite", "INumRead", "iNumberFind", "INumNeed", "iFatFind", "iNUMNeed", "iinumDef", "InumNeed", "inumRun", "inumNeed", "iinumFind", "aiNumberFind", "inumDef", "iRemRead", "iLenRun", "INumPrint", "inumRead", "iLenPrint", "iRemWrite", "iNUMPrint", "InumPrint", "iRemFind", "iNumPrint", "iiNumDef", "iNumWrite", "InumRead", "iFatDef", "iFatRead", "iNUMRead", "iinumRead", "iiNumFind", "aiNumberWrite", "iNumberRead", "aiNumFind", "iNumRun", "iNumNeed", "iLenNeed", "inumFind", "InumRun"], "f": ["b", "fs", "file", "fd", "bf", "fp", "tf", "fc", "t", "l", "fo", "c", "n", "df", "p", "h", "fe", "af", "fac", "fi", "y", "F", "w", "g", "e", "fax", "sf", "fm", "d", "fa", "v", "cf", "o", "fr"], "inputstream": ["Inputdraw", "iterstyle", "uploadStream", "inputstyle", "uploaddraw", "uploadscreen", "inputStream", "inputscreen", "inputform", "iterscreen", "Inputstream", "iterStream", " inputStream", "Inputstyle", "uploadstream", "uploadform", " inputdraw", "Inputscreen", "InputStream", "Inputform", "iterstream", "inputdraw", "uploadstyle", " inputform"], "document": ["message", "collection", "ree", "template", "article", "ocument", "number", "apache", "Document", "information", "application", "context", "database", "media", "file", "m", "present", "browser", "directory", "html", "window", "n", "page", "df", "object", "expression", "tree", "xml", "version", "result", "command", "ml", "raw", "complete", "content", "model", "dom", "response", "language", "node", "doc"], "nodelist": ["nodedestyle", "nodesist", "nodeeman", "snodestyle", "nannodeemark", "nodeest", "nodeman", "neodeist", "nodest", "nodeety", "nodeist", "snodelist", "nondelist", " nodeseto", "nodeseto", "noyeline", "nostemark", "nosteline", " nodeto", "nODeline", "neodeman", "snodeemark", "neodelist", "nnodeety", "nostestyle", "nodedemark", "nannodeelist", "nodeto", " nodeline", "nomist", "nODelist", " nodesist", "nodemark", "nnodeist", "snodeelist", "nnodeemark", "noyelist", "nondist", "snodeline", "snodeeline", "nodeline", "noyist", "nanodemark", "nondeman", "nodedeline", "nnodeelist", "nodeselist", "nostelist", "nodestyle", "neodeeman", "nodeseline", "neodist", "noyeto", " nodeseline", "nomelist", "nodedist", "nodeemark", " nodist", "nannodeist", "nondest", "nODist", "nomeman", "nodety", "nodeestyle", "neodeelist", " nodeselist", "nodist", "nomest", "nodeelist", "neodest", "neodeest", "nodeeline", "snodemark", "nannodeety", "nanodelist", "nODeto", "nanodist", "snodeestyle", "nanodety", "nodedelist", "nodedety"], "num": ["nam", "net", "Number", "perm", "number", "all", "mu", "Num", "m", "su", "list", "current", "mult", "count", "uni", "proc", "umi", "zero", "nm", "n", "nom", "om", "multi", "NUM", "result", "nu", "UM", "set", "length", "cal", "alph", "coord", "um", "no", "dim", "mon", "con", "mn", "total", "sum", "max", "man", "mem", "np", "umer", "un"], "i": ["ami", "ij", "ex", "init", "my", "us", "gi", "it", "qi", "xi", "info", "\u0438", "ci", "li", "wi", "z", "I", "m", "l", "ai", "ix", "iq", "hi", "ri", "x", "bi", "n", "ii", "this", "them", "a", "q", "p", "mi", "multi", "major", "ic", "in", "batch", "index", "io", "y", "im", "phi", "iu", "sim", "ie", "e", "ji", "me", "history", "si", "zi", "ei", "pi", "ti", "cli", "j", "ui", "di", "ini", "ip"]}}
{"id1": "21316706", "id2": "17207832", "code1": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "code2": "    @Test\n    public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception {\n        Exception e = new UnsuccessfulResponseException(resp);\n        expect(mockBackend.execute(host, req, ctx)).andThrow(e);\n        replay(mockBackend);\n        HttpResponse result = impl.execute(host, req, ctx);\n        verify(mockBackend);\n        assertSame(resp, result);\n    }\n", "label": 0, "substitutes": {"openConnection": [" obtainconnection", " obtainConnect", " openConnect", " openChannel", " obtainConnection", "openChannel", " openconnection", "doConnection", "doConnect", " obtainChannel", "doconnection", "doChannel", "openConnect", "openconnection"], "url": ["ls", "b", "path", "http", "URL", "parse", "all", "id", "r", "address", "file", "config", "l", "ur", "link", "string", "str", "browser", "job", "web", "key", "loc", "domain", "q", "host", "uri", "addr", "util", "char", "xml", "el", "access", "ret", "build", "Url", "log", "mail", "re", "ssl", "server", "ul", "location", "name", "ll", "mount", "sl", "un"], "proxy": ["library", "http", "cache", "force", "address", "project", "zone", "link", "browser", "client", "slave", "Proxy", "cas", "one", "pro", "uri", "pe", "manager", "pipe", "ping", "version", "password", "token", "shadow", "policy", "property", "socket", "report", "roxy", "port", "po", "none", "pse", "ssl", "connection", "server", "module", "resource", "pointer", "profile", "timeout", "service", "via"]}}
{"id1": "873012", "id2": "13207437", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "label": 0, "substitutes": {"url": ["b", "ls", "external", "path", "dl", "http", "URL", "sql", "r", "address", "file", "config", "l", "ur", "gl", "string", "str", "link", "browser", "job", "cl", "web", "html", "nl", "key", "term", "loc", "domain", "page", "q", "uri", "pattern", "util", "char", "rl", "xml", "default", "el", "ref", "get", "log", "Url", "pl", "ld", "impl", "ssl", "resource", "location", "base", "bel", "name", "ll", "mount", "sl", "un"], "in": ["In", "read", "online", "check", "is", "init", "on", "out", "input", "rin", "al", "update", "f", "login", "ln", "IN", "ma", "inn", "reader", "m", "s", "l", "ai", "bin", "again", "include", "c", "vin", "ins", "n", "source", "from", "mc", "null", "en", "mi", "oin", "body", "din", "isin", "min", "nin", "cin", "serv", "con", "i", "gin", " din", "line", "inner", "o", "name"]}}
{"id1": "7468819", "id2": "9236363", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"run": ["launch", "block", "wait", "thread", "func", "task", "exec", "test", "submit", "go", "unit", "running", "Run", "runner", "loop", "work", "process", "runs", " Run", "start", "execute", "invoke", "poll", "profile", "begin", "hello", "call"], "con": ["com", "sin", "Conn", "acon", "conf", "url", "win", "open", "comm", "ain", "ln", "Con", "clean", "fc", "construct", "pc", "cos", "rc", "xc", "cc", "cl", "client", "c", "fin", "cp", "en", "cn", "ct", "cmd", "gc", "don", "cone", "canon", "act", "cm", "nc", "const", "cal", "ch", "conv", "CON", "dial", "re", "ctrl", "conn", "connection", "cont", "co", "ran", "syn", "cons", "cf", "cur", "can", "pen", "create", "res", "connect", "mos", "bur", "un"], "encodedPassword": ["decachedpassword", "decodedPass", "encryptedpassword", "decodedPassword", "encodingData", "encressedUser", "decodedResponse", "encryptedPass", "encuredResponse", "encodedUser", "encachedPassword", "enccodedpassword", "encodedPass", "encodingPass", "enccodedData", "enccodedPass", "decodedData", "encuredPassword", "enccodedPassword", "encuredpassword", "decodingPass", "encachedUser", "encachedResponse", "decachedPassword", "encodedpassword", "encodingPassword", "encodedResponse", "encachedpassword", "encressedResponse", "decodedpassword", "decodedUser", "encodedData", "encressedpassword", "decodingPassword", "encodingpassword", "decodingpassword", "encressedPassword", "decodingData", "decachedResponse", "encryptedData", "encryptedPassword", "encuredUser", "decachedUser"], "encoder": ["ecoding", "enoding", "encoded", "ecoder", "encoser", "encater", "Encoder", "decoser", "enoder", "decoder", "Encoding", "decater", "ecODE", " encoding", "encoding", "enoded", "enODE", " encater", "Encoser", "decoding", "Encater", "encODE", "ecoded", "decoded", "decODE", " encoser"], "is": ["nis", "isl", "was", "it", "fs", "ib", "ys", "iso", "ms", "IS", "ist", "s", "isc", "se", "ai", "lis", "as", "ri", "ir", "ists", "ins", "rs", "iss", "os", "ris", "ic", "in", "are", "isf", "Is", "bs", "il", "sys", "isi", "im", "its", "isin", "ios", "ais", "i", "sis", "si", "asin", "isa", "iris", "sit", "es"], "rd": ["nd", "rect", "rob", "ren", "cd", "nder", "dr", "erd", "r", "red", "rx", "sr", "reader", "RD", "rt", "rb", "rc", "rg", "ri", "rar", "rs", "rw", "rn", "dd", "rid", "rl", "cr", "rr", "ind", "xd", "rod", "din", "ld", "bd", "rh", "d", "ra", "rand", "mr", "ru", "hr", "fr"], "line": ["LINE", "message", "block", "header", "liner", "lo", "ln", "file", "inline", "l", "ine", "frame", "se", "string", "cell", "eline", "link", "stroke", "record", "lin", "entry", "nl", "word", "row", "detail", "page", "le", "label", "Line", "command", "sequence", " LINE", "log", "re", "chain", "ice", "print", "code", "base", "sample", "name", "column", "point", "phrase", "lane", "comment"], "response": ["reply", "message", "library", "collection", "template", "value", "display", "format", "sheet", "application", "array", "relative", "output", "database", "description", "request", "list", "frame", "csv", "network", "trace", "pos", "summary", "vector", "answer", "onse", "continue", "results", "memory", "detail", "next", "page", "image", "this", "resp", "table", "tree", "xml", "document", "command", "sequence", "json", "view", "console", "report", "position", "buffer", "connection", "server", "print", "model", "res", "Response", "data", "relation", "service", "reset", "respons"], "lastIteraction": [" lastiterations", "lastInteration", "lastIterations", "lastIterate", "lastInterations", " lastIterate", "lastIteration", "lastInterate", " lastiteration", "lastInterated", " lastIteration", "lastIterated", " lastRelate", " lastRelated", " lastiterated", " lastInterate", " lastRelations", " lastiterate", " lastInterated", " lastInteration", " lastIterated", " lastInterations", " lastRelation", " lastIterations"], "result": ["message", "Result", "value", "cache", "out", "query", "url", "r", "err", "request", "current", "string", "str", "success", "answer", "results", "reason", "page", "json", "report", "ret", "buffer", "content", "res", "data", "status"], "e": ["b", "ex", "or", "note", "r", "f", "err", "be", "error", "oe", "m", "xe", "t", "s", "l", "ate", "se", "ine", "eg", "ae", "x", "c", "ue", "n", "le", "a", "p", "exc", "u", "h", "pe", "ent", "en", "ze", "er", "eeee", "ne", "eu", "E", "te", "ie", "g", "es", "re", "ec", "me", "i", "ep", "d", "v", "ei", "o", "ev", "ee"]}}
{"id1": "6840241", "id2": "11645260", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["read", "opy", "write", "save", "clip", "sync", "map", "link", "load", "size", "system", "cat", "clone", "move", "cop", "close", "share", "cp", "gc", "Copy", "slice", "delete", "transfer", "print", "create", "replace", "cover", "call"], "source": ["SOURCE", "iter", "ce", "template", "src", "store", "cache", "input", "sql", "Source", "info", "subject", "select", "wrapper", "shell", "context", "session", "reader", "sr", "ource", "inside", "se", "size", "origin", "image", "stream", "ins", "from", "scope", "master", "sp", "site", "state", "spec", "body", "style", "ie", "parent", "pse", "si", "resource", "inner", "start", "sample", "base", "status", "local", "table"], "sink": ["Sender", "asource", "ssource", "Sue", "Source", "Sink", "sinker", "Sinker", "asink", "sue", "ssinker", "ssink", "slource", "asender", " sinker", "slue", " sue", "slender", "slink", "ssender", "asinker", " sender", "sender"]}}
{"id1": "6009527", "id2": "1188100", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadAttachention", "doFinishLoadAssention", "doFinishLoadAttachachment", "doFinishLoadAttention", "doFinishLoadAssachment", "doFinishShowAttached", "doFinishShowDetached", "doFinishShowDetachment", "doFinishShowAttachment", "doFinishLoadDetention", "doFinishLoadAttached", "doFinishLoadDetached", "doFinishLoadAssached", "doFinishLoadDetachment", "doFinishShowAttention", "doFinishLoadAttachached", "doFinishShowDetention"], "attachmentId": ["detachedid", "ATTachmentKey", "attgmentKey", "attachmentName", "atutationName", "attachmentid", "attociationid", "detachedKey", "attentionById", "attachmentKey", "attociationKey", "detachedId", "attentionId", "attagramKey", "detachmentid", "attentionName", "attgmentid", "attutationId", "ATTachmentid", "detachmentKey", "attachedById", "atachmentId", "attagramId", "ATTociationKey", "attagramById", "attagramid", "ATTociationById", "atutationId", "attachedid", "atachmentById", "attociationId", "ATTachmentId", "attachedKey", "attociationById", "atachmentName", "attociationID", "attutationName", "attutationID", "attachmentById", "attachedId", "ATTociationId", "attachmentID", "ATTachmentById", "attentionID", "detachmentId", "atutationById", "attociationName", "attgmentId", "atutationID", "ATTociationid", "attutationById", "atachmentID"], "attachment": ["detached", "contached", "addociation", "ATTention", "attachachment", "attached", "attment", "detment", "attachaching", " attached", "contachment", "assaching", "attaching", "addached", "assachment", "ATTached", "assached", "detachment", "detacher", "attachociation", "ATTacher", "attachacher", "attention", "attociation", "addaching", "contacher", "association", "attachached", "addachment", " attment", "assacher", "attacher", "ATTachment", "attachention", " attacher", "contment", "assention"], "attachmentUri": ["attentionUrid", "attentionUri", "attentionUtpi", "attachmentuRI", "attachableOuri", "attachmentOri", "attachableOURI", "attachmentOURI", "attachmentUtri", "attachableUURI", "attentionUpi", "attachmenturi", "attachmentOpi", "attachableOri", "attachmenturid", "attachmentUtrid", "attachmentUtRI", "attachmentUnri", "attachmentURI", "attachableUuri", "attachmentUpi", "attachmentTpi", "attentionUtrid", "attachableOpi", "attachmentTuri", "attachmentUURI", "attentionURI", "attachmentUnpi", "attachmentUtpi", "attentionUtRI", "attachableUri", "attachmentupi", "attachmentUnuri", "attachmentTri", "attachmentUuri", "attachmentUrid", "attachmentOuri", "attachmentTURI", "attentionUtri", "attachableUpi", "attachmentUnURI"], "contentUri": ["ContentUris", "contentUtres", "ContentUsrid", "ContentUsuri", "contentuuri", "ContentUsris", "contentUsris", "contentURRI", "messageUtri", "contentURri", "resourceURres", "contenturi", "contentUtri", "contentUtric", "contentuRI", "contentUsuri", "contentUnrid", "contentURuri", "contentUruri", "resourceURI", "contentUriri", "contentSiri", "contentUrri", "contentUrric", "contentSric", "messageUri", "contentUrid", "contentUtrid", "messageUtiri", "contentURres", "contentURI", "ContentUuri", "messageUturi", "contentUturi", "contentures", "contentUris", "resourceUri", "contentUnuri", "resourceURRI", "contentUnris", "contentSuri", "contentUtiri", "resourceURuri", "contentUric", "contentUtRI", "contentUsrid", "resourceURri", "messageUric", "resourceUuri", "resourceUres", "ContentUri", "messageUiri", "messageUuri", "contentSri", "contentUsri", "contentUuri", "contentUnri", "contentUiri", "messageUtric", "contentUres", "ContentUsri", "ContentUrid", "contentUtris"], "file": ["user", "path", "message", "header", "template", "init", "files", "format", "type", "save", "f", "filename", "output", "media", "fp", "dir", "zip", "link", "rule", "image", "source", "le", "page", "picture", "from", "h", "ile", "to", "angle", "tree", "il", "document", "work", "result", "folder", "ca", "FILE", "port", "upload", "entity", "disk", "line", "buffer", "sf", "resource", "content", "local", "base", "create", "play", "name", "db", "channel", "File", "pool", "table"], "in": ["In", "read", "is", "on", "input", "rin", "it", "sql", "al", "ain", "IN", "inn", "and", "l", "inside", "inf", "bin", "ar", " IN", "ins", "source", "from", "inc", "en", "mi", "ic", "up", "io", "ind", "body", "din", "isin", "cin", "con", "i", "gin", " din", "inner", "play", "ini"], "out": ["b", "obj", "put", "ex", "check", "net", "OUT", "ou", "it", "all", "write", "output", "nt", "stable", "oss", "client", "Out", "n", "null", "os", "screen", "to", "flush", "ao", "io", "sys", "outs", "w", "writer", "conv", "OU", "g", "serv", "con", "i", "co", "print", "can", "aos", "auto", "o", "v", "res", "outer"], "intent": ["inv", "activate", "ment", "init", "device", "voice", "automatic", "spirit", "query", "widget", "context", "agent", "express", "verbal", "concept", "ink", "animate", "intention", "wordpress", "entry", "continue", "window", "term", "inst", "venture", "q", "ent", "action", "Activity", "ic", "act", "skill", "method", "alert", "ence", "xml", "initial", "asso", " Intent", "json", "text", "ant", "statement", "prom", "ident", "entity", "condition", "event", "displayText", "communication", "man", "phrase", "complete", "activation", "service", "activity"]}}
{"id1": "18374598", "id2": "22338097", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"download": ["read", "pull", "check", "install", "update", "url", "save", "open", "filename", "file", "link", "load", "loader", "submit", "delete", " Download", "upload", "dial", "get", " downloaded", "Download", "GET", " downloads", "create", "sample", "poll", "data", "connect"], "a": ["b", "sta", "path", "at", "era", "title", "eta", "all", "pa", "al", "url", "array", "r", "address", "la", "ma", "any", "ab", "t", "s", "ga", "l", "app", "au", "ai", "as", "ae", "ta", "A", "apa", "html", "ar", "arg", "c", "from", "go", "u", "ac", "h", "ao", "area", "aa", "attribute", "part", "el", "va", "ca", "na", "an", "aaa", "i", "ata", "sa", "aw", "oa", "d", "v", "aos", "o", "base", "am", "data", "name", "ap", "att", "alpha", "ia"], "p": ["b", "pt", "pat", "pp", "wp", "perm", "tp", "prop", "pa", "vp", "ip", "bp", "pkg", "m", "pc", "t", "pre", "l", "pos", "x", "c", "pid", "q", "pro", "h", "pe", "cp", "ping", "op", "part", "j", "power", "par", "pers", "rep", "g", "ps", "i", "jp", "pad", "d", "pard", "pi", "P", " pe", "np", "lp", "pl", "ap", "pg", "pr", "pb"], "td": ["ad", "nd", "pt", "cd", "dl", "th", "ptr", "ts", "dh", "tp", "tc", "ds", "tmp", "nt", "fd", "tf", "fc", "pc", "t", "md", "tif", "dc", "hd", " TD", "df", "pd", "dd", "ct", "cz", " sd", "det", "tr", "dt", "div", "lf", "dial", "ld", "deb", "bd", "od", "tap", "d", "cot", "sd", "TD", "ot", "db", "pb"], "f": ["b", "xf", "uf", "ft", "fs", "func", "file", "fd", "bf", "fp", "fc", "tf", "t", "l", "fl", "fo", "c", "fin", "ff", "fx", "fn", "df", "af", "h", "fe", "rf", "fi", "fw", "lf", "F", "w", "form", "g", "e", "i", "sf", "d", "fb", "cf", "v", "o", "fm", "fa", "j", "fr", "alf"], "total": ["template", "full", "net", "eta", "equal", "note", "number", "all", "info", "open", "nt", "current", "t", "count", "done", "stable", "Total", "ta", "otal", "le", "percent", "num", "to", "len", "scale", "initial", "sys", "valid", "unique", "sequence", "length", "last", "meta", "none", "trans", "buffer", "active", "max", "sum", "available", "base", "start", "complete", "table", "normal"], "progress": ["payment", "ptr", "portion", "display", "offset", "wait", "priority", "update", "finished", "grade", "speed", "address", "distance", "current", "debug", "count", "done", "t", "performance", "age", "success", "summary", "memory", "continue", "pro", "percent", "scroll", "scale", "bar", "result", "state", "Progress", "length", "report", "pdf", "status", "step", "usage", "process", "dist", "history", "depth", "print", "resource", "poll", "complete", "important"], "in": ["In", "iter", "is", "init", "on", "input", "it", "rin", "win", "IN", "inn", "and", "l", "inside", "inf", "bin", "ai", "ar", "ins", "from", "inc", "en", "ze", "ic", "to", "io", "ind", "oin", "im", "din", "mm", "by", "get", "cin", "con", "i", "inner", "o", "ini"], "out": ["b", "obj", "put", "ex", "at", "net", "OUT", "ou", "on", "cache", "it", "write", "err", "output", "nt", "list", "t", "s", "l", "oss", "lock", "pos", "client", "cb", "c", "Out", "end", "null", "ins", "os", "cn", "to", "io", "ne", "sys", "outs", "w", "ch", "writer", "OU", "g", "by", "log", "con", "conn", "co", "can", "aos", "o", "outer", "auto", "res", "v", "vol", "pool"], "buf": ["b", "bytes", "block", "uf", "mu", "cap", "pkg", "bl", "norm", "rb", "bin", "cb", "cat", "window", "Buffer", "next", "row", "br", "orig", "cv", "img", "arr", "cp", "cmd", "box", "batch", "bag", "bar", "msg", "seq", "tab", "conv", "aka", "Buff", "buffer", "wb", "vec", "buff", "data", "bed", "ob", "db", "obs", "pb"], "n": ["b", "ren", "ng", "note", "on", "nn", "number", "yn", "wn", "z", "N", "nt", "m", "ln", "norm", "count", "t", "l", "nor", "gn", "x", "sn", "nl", "nm", "c", "fn", "nr", "cn", "en", "num", "dn", "nan", "len", "ne", "nc", "y", "w", "none", "g", "min", "no", "an", "na", "nb", "i", "names", "max", "d", "nw", "v", "o", "np", "j", "ns"], "percentage": ["parager", "percentager", "parility", "scaleage", "parAGE", "CENTategy", "percentAGE", "propage", "Percentage", "centility", "centager", "Percentade", "Percentile", "taxension", "taxance", "centage", "Percentity", "Percentategy", "quantance", "percentity", "oppade", "centile", "percentategy", "centade", "percentume", "Percentant", "taxility", "parance", "propile", "scaleility", "percentant", "oppant", "centity", "quantage", "CENTage", "oppage", "centAGE", "propity", "propade", "percentility", "CENTade", "Percentume", "taxage", "parage", "centategy", "scaleAGE", "CENTume", "quantility", "percentension", "oppility", "scaleager", "percentile", "percentance", "percentade", "centume", "Percentility", "quantension", "parension"], "tmpPercentage": ["tmpIntade", " tmpPercentency", " tmppercenture", "tmpIntage", "tmpPropency", " tmpPercentane", "tmpPercentade", "tmpMagnages", " tmpPercentages", " tmppercentage", " tmpPercentade", " tmppercentane", "tmppercentages", "tmpPropance", " tmpIntance", "tmpPlusure", " tmpPercentate", " tmpIntency", "tmpPercentance", "tmpPercentency", "tmpPropage", "tmpMagnade", "tmpPercentages", " tmpIntade", "tmpPercenture", "tmppercentate", "tmpPercentate", "tmpIntency", "tmpPercentane", "tmpPlusade", "tmpIntance", " tmpIntage", "tmppercentade", " tmppercentade", "tmpMagnate", "tmpMagnage", "tmpPlusage", "tmpPlusane", " tmpPercenture", " tmppercentate", "tmpPropade", " tmppercentages", "tmppercenture", "tmppercentane", "tmppercentage", " tmpPercentance"], "size": ["bytes", "empty", "SIZE", "storage", "needed", "small", "space", "ize", "count", "s", "l", "send", "sn", "c", "loc", "ze", "num", "ose", "area", "len", "used", "scale", "sp", "notice", "Size", "length", "set", "body", "see", "position", "g", "e", "capacity", "loss", "max", "sd", "sum", "code", "sw", "now", "name"], "checksum": ["actionsumm", "hssum", "hassum", "hsul", "ckscan", "hasam", "actionsul", "ksam", "cksul", "actionsum", "hsum", "cksum", "timesave", " checksul", "cksave", "actionssum", "hasum", "checksul", "readsum", "timessum", "checkscan", "kssum", "hascan", "ksum", "checkssum", " checkssum", "readssum", "ckssum", "hsumm", "timesum", "timesul", "cksam", "checksave", "kscan", " checksumm", "checksam", "checksumm", "readsave", "readsul"]}}
{"id1": "659316", "id2": "22993368", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"argv": ["Args", "argm", " argvs", "Argv", "callV", "ArgV", "suppv", "argV", " argm", "argc", "argsV", "argp", "suppV", "callvs", " argp", "suppvs", "Argm", "argsm", "suppp", " argV", "argss", " argc", "argvs", "argsc", "callp", "Argc", "callv", "argsv"], "sources": ["seodes", " sodes", "tocks", "inources", "stources", "sults", "inets", "stets", " sors", "siders", "stors", "inults", "seources", "servors", " sults", " sures", "tiders", "soots", "servets", "sliders", "seets", "seults", "slocks", "sors", " socks", " sets", "tources", "inodes", "sodes", "toots", " soots", "slources", "sloots", "socks", "servures", "stures", "servources", " siders", "sets", "sures"], "targets": ["Topches", "Targes", " tangens", "tokgers", "toksets", "toolsankets", " tangets", "Topends", "targches", "tasses", "tankets", " tangends", "targetets", "targetgers", "tassends", "toolsarggers", "topends", " targes", "tankgers", "tokes", "tangens", "targsets", "targends", "Targches", "tassets", "toolsankens", "Targends", "toolsanksets", "topets", "tanges", "targens", " tanges", "topes", "Targets", "targgers", "tokens", "targes", "tankens", "topches", "toolsargsets", "tangches", "tokets", "tassches", "tangets", "topens", " targends", " targens", "targetens", "tangends", "targetsets", "Topes", "toolsankgers", "toolsargens", "tokends", "toolsargets", "tanksets", "Topets"], "srclen": ["srccen", "srccog", " srplength", " srclade", "rsccue", "srplen", "srklen", "srccue", "srclade", "rsclog", "rsclen", " srpln", "srklogn", "srplength", "srselog", " srcln", "srclength", "srCLn", "srselength", "srcln", "srclogn", "srpln", "srklog", "rsccogn", " srclength", " srplen", "rsccog", "srselogn", "srccogn", "srseln", "srCLade", "srselen", "srselade", "srCLength", "srclog", "srCLen", "srplade", " srplade", "srklue", "rsccen", "srselue", "rsclogn", "srclue", "rsclue"], "source": ["SOURCE", "match", "iter", "template", "src", "store", "cache", "secure", "input", "search", "query", "Source", "info", "force", "select", "context", "wrapper", "file", "ser", "reader", "ource", "s", "link", "trace", "standard", "root", "system", "score", "this", "scope", "from", "null", "copy", "scale", "sys", "sp", "site", "sequence", "console", "set", "style", "parent", "get", "me", "buffer", "escape", "resource", "internal", "inner", "start", "create", "scan", "status", "service", "local"], "tgt": ["itht", "Targ", "stgt", "ngn", " tpt", "tegt", "tetarget", " tgn", "ngt", "tpt", "wtarget", "ttarget", "npt", "targ", "itarget", "Target", " tht", "Tgt", "starget", "Tht", "tept", " targ", "tearget", "warg", "tht", "tearg", "nht", "itgt", "teht", "ittarget", " ttarget", "sttarget", "tgn", "wgt", "warget", "starg", "itarg", "tegn"], "target": ["dest", "match", "path", "template", "out", "wrapper", "output", "tmp", "Target", "stable", "trace", "link", "ARGET", "top", "gt", "peer", "next", "null", "proxy", "mask", "touch", "table", "to", "secondary", "trap", "manager", "copy", "sys", "owner", "handler", "socket", "writer", "parent", "goal", "buffer", "resource", "internal", "pointer", "base", "inter", "arget", "rel", "bolt", "channel", "member", "local", "localhost", "child"], "deletes": ["lelets", "duletes", "desletes", "duels", "Deels", "seels", "Deles", "deleted", "Deleted", "deels", "desges", "deves", "dges", "dellets", "Deletes", "desves", "deslets", "duges", "seletes", "delves", "delletes", "delets", "dules", "leletes", "dletes", "dlets", "leets", "seleted", "deges", "leves", "deets", "deles", "duleted", "desleted", "desets", "dulets", "dleted", "seles"], "del": ["ls", "inv", "dl", "dr", "let", "tl", "dis", "des", "err", "rol", "nt", "col", "bl", "rem", "dem", "l", "md", "se", "cl", " dele", "de", "nl", "le", "pel", "def", "Del", "len", "rl", "ne", "tr", "el", "compl", "vet", "dec", "delete", "kl", "re", "sel", "els", "syn", "cel", "ele", "elt", "ll", "rel", "pl"]}}
{"id1": "16590954", "id2": "5148212", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"createJAR": ["saveIJARS", "createPHAP", "createJART", "createJARS", "saveJARS", "createIJARS", "createPHARS", "createIJAP", "createJAP", "createIJAR", "createIJART", "createGARS", "createPHART", "createGAP", "saveJART", "saveIJART", "saveIJAR", "saveIJAP", "createGAR", "saveJAR", "saveJAP", "createGART", "createPHAR"], "fileString": ["pathStr", "messageString", "messageText", "pathstring", "messageStr", "FileString", "ileName", "fileRest", "ileStr", " fileText", "FileStr", "FileName", " fileName", "ileRest", "filestring", "pathString", "fileText", "FileText", "messageName", "fileStr", "ileString", "ilestring", "fileName", " filestring", " fileRest", "Filestring", " fileStr", "FileRest"], "ext": ["external", "ex", "path", "rest", "pat", "suff", "format", "type", "xt", "t", "exe", "Ext", "str", "append", "ix", "prot", "req", "end", "xp", "txt", "cmd", "ort", "off", "char", "ind", "typ", "except", "exp", "text", "desc", "enc", "js", "e", "tex", "ime", "cont", "name", "gz", "EXT", "fr"], "file": ["message", "path", "user", "foo", "format", "http", "store", "cache", "time", "input", "url", "type", "open", "f", "info", "class", "output", "doc", "force", "list", "fp", "t", "link", "lock", "memory", "image", "run", "this", "source", "le", "from", " File", "page", "null", "h", "ile", "to", "handle", "tree", "io", "document", "work", "default", "report", "port", "FILE", "parent", "log", "get", "mail", "disk", "line", "buffer", "resource", "module", "local", "base", "model", "data", "name", "db", "channel", "File", "pool", "table"], "i": ["ami", "is", "ati", "gi", "id", "xi", "ci", "f", "li", "I", "m", "t", "s", "di", "ai", "ri", "x", "bi", "ir", "c", "n", "ii", "p", "mi", "ini", "ind", "phi", "si", "v", "o", "pi", "j", "ui", "index", " j", "ip"], "dir": ["path", " folder", "DIR", "direction", "id", "url", "wd", "home", "del", "lib", "tmp", "project", "pkg", "dy", "star", "direct", "done", "directory", "root", "org", "Dir", "ir", "loc", "uri", "dd", "addr", "part", "div", "ind", "folder", "mod", " Dir", "disk", " d", "dist", "d", "rel", "db", "vol", " directory"], "jarFile": ["jarName", "tarFilename", "jarfile", "jFile", "pkgFile", "jarFilename", "tarEmail", " jarField", "JarField", "pkgFILE", "jName", " jarName", "jfile", "jarField", " jarFILE", "javafile", " jarFilename", " jarEmail", "tarfile", "javaName", "JarFile", "Jarfile", "JarFilename", "jarEmail", "JarEmail", "tarFile", "pkgField", "javaFile", "jarFILE", "JarFILE", "javaFilename", "jFilename", " jarfile"], "fstrm": ["fstrdm", "ftrms", "fcrm", " fdrm", "fbsprms", "fdrcm", "fdrum", "ftrum", "ftrdm", "fbsprp", "fstrms", "fbstrdm", "fstrcm", " fdrcm", "fbstrms", "ftrcm", "fsprms", "fstrp", "fsprp", "fcrms", "fslum", "fbsprdm", "fdrm", "fbsprm", "fcrdm", " fdrmed", "ftrmed", "fslcm", "fstrmed", "fbstrp", "fcrp", "fsprdm", " fstrmed", "fbstrm", "fsprm", " fstrcm", " fstrum", "fslmed", " fdrum", "fstrum", "fdrmed", "fslm", "ftrp", "ftrm"], "in": ["In", "read", "iter", "pin", "is", "sin", "init", "input", "rin", "it", "r", "f", "m", "IN", "inn", "add", "inside", "inf", "bin", "ai", " IN", "ins", "inc", "from", "en", "ic", "up", "io", "ind", "oin", "im", "din", "mm", "isin", "re", "cin", "gin", " din", "inner", "pi", "o"], "out": ["inv", "obj", "ex", "at", "OUT", "net", "ou", "it", "output", "m", "t", "s", "cos", "client", "c", "Out", "n", "null", "os", "p", "cn", "gc", "to", "io", "cm", "outs", "w", "ch", "writer", "conv", "OU", "serv", "conn", "cont", "co", "inner", "v", "aos", "o", "outer", "channel"], "temp": ["dest", "tm", "pt", "TM", "path", "template", "full", "mint", "tt", "cache", "thread", "wrap", " tmp", "tc", "tar", "Temp", " Temp", "tmp", "tem", "output", "mt", "mp", "m", "current", "t", "mk", "zip", "directory", "tx", "fake", "pool", "memory", "term", "null", "EMP", "orig", "p", "cp", "to", " temporary", "util", "copy", "tree", "document", "mod", "Tem", "mm", "parent", "buffer", "cont", "porary", "stem", "res", "mem", "name", "emp", "local"], "fstrm2": ["fstrM2", "fstrmm2", "fStrm2", "fstrp2", "fStrtm2", "fstrtm2", "fStrm7", "fstrcm2", "fStrm1", "fstrcm7", "fstrp1", "fstrcm1", "fStrtm1", "fStrp7", "fStrp1", "fstrmm1", "fstrM7", "fstrm7", "fstrM1", "fstrtm1", "fstrp7", "fStrp2", "fstrm1"], "ostrm": [" ostm", "astm", "ostRM", "ortlamm", "osRM", " ostrem", "osrm", "ortRM", "astrm", " ostRM", "ortrom", "ostnm", "osnm", " ostlamm", "ostlamm", "istnm", "osmr", "ortrm", "astrem", "istmr", "astRM", " ostrom", "osrem", "istRM", "ostm", " ostnm", "istm", "astrom", "ostrom", "astlamm", "ostmr", "istrem", "istrm", "oslamm", "ostrem", "astmr", "osm"], "docFile": ["documentFile", "DocDir", "documentLine", "Docfile", "DocFiles", "docLine", "manFile", " docfile", "docPath", " docPath", "docfile", " docDir", " docLine", " docFiles", "DocPath", "manfile", "manDir", "docFiles", "manPath", "documentDir", "DocFile", "documentFiles", "DocLine", "docDir"]}}
{"id1": "8164056", "id2": "9081749", "code1": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"encode": ["genode", "enoder", "Encode", " encoder", "genenc", " enccode", "enenc", "enode", "genoder", "Enenc", "gencode", " encenc", "Enoder", "Enode"], "str": ["b", "obj", "strings", "input", "it", "r", "comm", "m", "t", "Str", "string", "ctr", "c", "n", "this", "txt", "br", "p", "arr", "coll", "char", "tr", "sp", "msg", "spec", "st", "text", "w", "STR", "wr", "conv", "enc", "e", "print", "v", "res", "data", "name", "oct"], "buf": ["b", "aux", "agg", "obj", "iter", "block", "foo", "uf", "mu", "cap", "bp", "tmp", "output", "pkg", "bc", "rb", "bo", "queue", "cb", "proc", "printf", "que", "Buffer", "next", "bg", "txt", "av", "br", "cv", "cmd", "box", "batch", "hung", "bag", "bound", "bar", "msg", "bh", "Buff", "bn", "temp", "buffer", "cf", "cur", "aer", "buff", "np", "ob", "db", "var", "pool", "pb"], "md5": ["dd45", " Md3", "dig3", "dd5", " MD3", "MD3", " md12", "mdlet", "dig2", " mdct", " mdlet", " md3", "md3", " md8", "dig8", "MD2", "MD5", "dd8", " MDlet", "MD12", "md2", "md12", "dig45", " Mdct", "dig5", " Mdlet", "dd3", " MD5", " md45", "md45", " Md5", "md8", "dig12", " MDct", " md2", "mdct"], "bytes": ["b", "pieces", "gs", "words", "files", "gets", "clips", "vals", " slices", " tmp", "sites", "binary", "vs", "gb", "iers", "tmp", "fps", "bis", "ashes", "cb", "parts", "bes", "bps", "pointers", "ings", " b", "tes", "fixes", "xs", "bits", " pixels", "services", "bs", "Bytes", "classes", "outs", "frames", " buffers", "steps", "xy", "its", "seconds", "js", "bles", "ios", "names", " chunks", "terms", "es", "values", "pages", "blocks"], "i": ["b", "ij", "ex", "is", "init", "us", "gi", "qi", "ski", "id", "it", "xi", "\u0438", "ci", "li", "info", "I", "m", "di", "ai", "ix", "gu", "ki", "x", "c", "key", "hi", "bi", "n", "ii", "a", "q", "multi", "u", "mi", "uri", "ic", "in", "batch", "major", "io", "y", "ind", "json", "im", "phi", "iu", "sim", "ie", "conv", "ji", "chain", "me", "si", "v", "pi", "ti", "cli", "point", "j", "ui", "index", "ini", "ip"], "s": ["b", "ls", "gs", "is", "gets", "ts", "ds", "fs", "sql", "r", "f", "z", "join", "sv", "abs", "t", "l", "se", "string", "sq", "n", "rs", "txt", "single", "os", "p", "h", "S", "sp", "spec", "y", "sol", "hs", "set", "sb", "js", "conv", "g", "ps", "ss", "sf", "sw", "v", "j", "sl", "ns"]}}
{"id1": "6403868", "id2": "9846843", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractunInstallItems", "extractuninstallItems", "extractUninstallItems", "extractUnInstallFile", "extractuninstallFile", "extractUnInstallItems", "extractunInstallFiles", "extractUnpackItems", "extractUnpackFile", "extractUninstallFile", "extractuninstallFiles", "extractUnpackFiles", "extractUnInstallFiles", "extractunInstallFile"], "_destPath": ["_srcPath", "_destTh", "_privTh", "_srcKey", "_destKey", "_tempDir", "_tempPath", "_privPoint", "_combPath", "_srcPoint", "_DestDir", "_combDir", "_destDir", "_destPoint", "_srcDir", "_privPath", "_tempFormat", "_privDir", "_restPoint", "_destFormat", "_DestPoint", "_sourcePath", "_DestTh", "_restDir", "_restKey", "_sourceDir", "_DestPath", "_restPath", "_combFormat", "_DestKey", "_sourceFormat", "_tempTh", "_tempPoint"], "upgrade": [" upcheck", "ungrad", "equcp", "downgrades", "exchange", "upcheck", " upgrades", " upgrad", " upate", "ungrade", "exgrade", " upcp", "upchange", "upate", "downgrade", "equgrad", "upgrad", "equate", "upgrades", "uncp", "excheck", "exgrades", " upchange", "upcp", "downchange", "downcheck", "unate", "equgrade"], "lastVer": ["lastVers", "lastVersion", " lastver", " lastServ", "oldver", " lastVersion", "Lastver", "lastver", "latestVers", "nextVers", "LastVersion", "oldVers", "latestRes", "oldVersion", "nextVer", "latestVer", "lastRes", "LastVer", "nextServ", "oldVer", "lastServ", " lastVers", "LastVers", "nextRes", "latestServ", " lastRes"], "oldlog": ["oldog", "olderog", "OLDLog", "oldererr", "Oldpath", " olderr", "oldpath", "olderr", "olderlog", "OLDog", "OLDerr", "OLDlog", "oldLog", "Oldog", "Oldlog", "OLDpath", " oldpath", "olderpath", "OldLog", " oldog", " oldLog", "olderLog"], "destPath": ["destFont", " destTh", " destNode", "originPoint", "estRef", "destLog", "foreignDir", "DestDirectory", "declPath", "destRoot", " destPort", " destHost", "DestPath", "privRoot", "identPoint", "originPath", "potStream", "descPos", "DestDir", "altName", "destDirectory", "estDir", "srcDirectory", "declFull", "potPath", " destDirectory", "foreignStream", "destRef", "restPath", "foreignPath", "descDisk", "descNet", "srcDir", " destKey", "gestDisk", "DestPod", "locPath", "destNode", "sortPath", "foreignPod", "originPort", "locNet", "destTh", "gestNode", "privPos", "sortDir", "DestParent", "descPath", "descKey", "destDir", "DestFull", "privDir", "declFont", "destPort", "declDir", "sortFull", "descTime", "restPoint", "DestRef", "altHost", "altDir", "DestPort", "altParent", "destName", "DestStream", "originTh", "locTime", " destPoint", "destFull", "destStream", "locDisk", "estPos", "potDir", "DestName", "srcPath", "DestFont", "srcPort", "altPath", "estPath", "srcFile", "potPod", "destNet", " destParent", "estName", " destLog", "destHost", "estKey", "DestLog", "DestFile", "identPath", "gestName", "altPoint", "sortFont", "altNode", " destFile", "identPort", "descName", "destKey", "destPos", "destDisk", "destTime", " destRoot", "DestPoint", "DestRoot", "restFile", "identTh", "gestNet", "gestTime", "destPod", "gestPath", "gestHost", "destPoint", " destDir", " destName", " destPos", "restDir", "destFile", "destParent", "privPath", "DestPos", "srcLog", " destRef"], "lastVerPath": ["highestVerpath", "lastverVal", " lastVerName", " lastVerForm", " lastVersLog", "lastVERpath", "lastVerCh", "lastVersCh", "lastVersPath", "lastverForm", " lastVersFile", "lastVersLog", "lastverFile", "lastverName", "lastVerName", "lastVerDir", "lastVERForm", " lastVerpath", " lastverForm", " lastVerLog", "lastVersionCh", " lastVerCh", " lastverDir", "lastVERDir", "lastverDir", "lastVERVal", "lastVERFile", "lastverCh", "lastVerForm", "lastRespath", " lastverPath", "highestVERPath", "highestVerPath", "lastVersFile", "lastVerpath", "lastResDir", "lastverpath", " lastVerFile", "lastVersName", "highestVERFile", "lastResPath", "lastVERPath", " lastVersCh", "lastVersionPath", "lastResForm", "lastverPath", "highestVerFile", "highestVERVal", " lastverpath", "lastVerFile", " lastVersPath", " lastVerDir", "highestVerVal", "lastVersionFile", "lastVerLog", "highestVERpath", "lastVerVal", "lastverLog", "lastVerspath", "lastVersVal", "lastVersionpath"], "bkdir": ["bkjgroup", "bckDIR", "BkDir", "bakfolder", "bkdi", "Bckdir", "blkjdir", "bqdi", " bkkDir", "bkkdir", "bckDir", " bkkfolder", "bkDir", "bqfd", "blkjdi", "bkfolder", "bckdi", "BckDir", "bkpath", "bkkrel", "bkgdir", "bckdir", "bakrel", "blkjgroup", "bkgDir", "Bkdir", " bkkrel", "bkjdir", "bukdi", "bkrel", " bkfolder", " bkDir", "bkgroup", "blkgroup", "blkdi", "BckDIR", "bkjdi", "Bkpath", " bkrel", "blkfd", "bukpath", "bkDIR", "bukDir", " bkkdir", "bkgrel", "bukgroup", " bkdi", " bakdir", "Bckpath", "bukfd", "blkdir", "bckpath", "bkkpath", "bkgfolder", " bakDir", "bkkdi", "BkDIR", "bukdir", "bkjfd", "bkkfolder", "bakdi", "bqdir", " bakdi", "bqgroup", "blkjfd", "bukDIR", " bakfolder", "bkkDir", "bckfolder", "bakDir", "bakdir", "bkkDIR", "bkfd"], "oldClassCopied": ["oldclassCopied", "oldclassCopaced", "oldclasscopified", "oldclasscopie", "oldClassColies", "oldClassChried", "oldClassCopyies", "oldClasscopified", "oldClassCopies", "oldClassCopiated", "oldDirReplied", "oldClassCopyified", "oldDirCopiated", "oldDirRepliated", "oldDirReplried", "oldclassCopified", "oldclassCopie", "oldClassColied", "oldClassCopyied", "oldClassCopaced", "oldclasscopies", "oldClassCopyie", "oldDirCopies", "oldClasscopie", "oldClassChies", "oldDirReplies", "oldClassReplified", "oldClassCopified", "oldClasscopried", "oldClasscopiated", "oldClasscopies", "oldClassReplies", "oldClasscopied", "oldclassCopies", "oldClassColified", "oldClassCopie", "oldDirCopied", "oldClassColaced", "oldClassRepliated", "oldClassChiated", "oldClassReplaced", "oldclasscopied", "oldClassReplied", "oldClassReplried", "oldClassChied", "oldClassCopried", "oldDirCopried"], "ls": ["cs", "lv", "gs", "dl", "LS", "ics", "lists", "ts", "ils", "tl", "ds", "fs", "vs", "la", "lc", "ln", "ats", "abs", "acts", "los", "ols", "l", "less", "lis", "ists", "rs", "xs", "ars", "lbs", "bs", "rl", "lf", "irs", "lt", "its", "es", "ps", "ks", "els", "les", "lines", "qs", "ws", "ms", "sels", "las", "ns"], "i": ["b", "ami", "ij", "is", "ims", "init", "us", "gi", "id", "qi", "xi", "ski", "it", "ci", "li", "I", "m", "l", "oi", "ix", "iq", "gu", "ki", "x", "bi", "hi", "key", "ii", "ri", "a", "multi", "mi", "u", "ic", "batch", "index", "io", "eu", "y", "im", "phi", "sim", "ji", "fire", "me", "chain", "si", "zi", "ei", "pi", "ti", "cli", "j", "ui", "di", "ini", "ip"]}}
{"id1": "18544890", "id2": "13063241", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"get": ["put", "read", "match", "range", "pull", "getting", "gets", "cache", "draw", "all", "query", "search", "download", "info", "api", "list", "Get", "game", "run", "show", "post", "stats", "GET", "print", "create", "call"], "url": ["path", "rect", "dl", "http", "URL", "id", "api", "address", "file", "game", "l", "ur", "string", "link", "str", "web", "html", "nl", "domain", "hl", "lb", "host", "q", "uri", "addr", "rl", "xml", "ref", "ret", "pl", "mail", "Url", "build", "ssl", "ul", "location", "base", "ll", "mount", "hub", "sl"], "lat": ["feat", "pt", "rect", "sta", "at", "wp", "grid", "Lat", "kt", "ats", "rt", "str", "pos", " latitude", "apt", "top", "sq", "x", "loc", "alt", "ct", "addr", "area", "height", "y", "st", "coord", "mat", "xy", "west", "south", "dist", "sat", "att", "ip"], "lon": ["ng", "on", "mag", "ino", "elong", "ong", "low", "ln", "las", "los", "l", "phy", "pos", "top", "lin", "x", "loc", "n", "fn", "vert", "lay", "lbs", "len", "lang", "lf", "lu", "lt", "west", "itude", "geon", "location", "lol", "ll", "zon", "local", "land"], "count": ["Count", "range", "th", "counter", "more", "cache", "number", "id", "search", "amount", "nt", "list", "current", "cond", "top", "size", "c", "found", "score", "n", "limit", "page", "ct", "num", "scroll", "batch", "frequency", "length", "last", "nb", "total", "sum", "max", "code", "start", "ount", "index", "call"], "req": ["inv", "aux", "pull", "friend", "rest", "init", "cert", "forge", "http", "cgi", "conf", "fail", "htt", "sql", "r", "comm", "err", "usr", "urg", "search", "pkg", "request", "quick", "reg", "rx", "forced", "dj", "mk", "sem", "Requ", "repl", "quest", "https", "send", "client", "proc", "sq", "tx", "qt", "wx", "org", "peer", "qq", "Request", "crit", "next", "q", "comp", "cmd", "resp", "compl", "ind", "require", "uj", "desc", "typ", "rr", "requ", "sub", "ps", "jp", "dist", "rd", "gr", "res", "cur", "rel", "pr", "j", "hr", "fr", "pas"], "gl": ["ls", "gs", "dl", "tl", "gold", "gm", "gb", "wal", "list", "bl", "tf", "l", "Gl", "fl", "ogl", "gn", "cl", "gel", "nl", "lor", "balls", "hl", "acl", "gc", "ibl", "GL", "abl", "rl", "illas", "il", "gall", "ger", "igl", "als", "wl", "gif", "console", "spring", "vl", "g", "pl", "ml", "gr", "jl", "bel", "lol", "rel", "ll", "bal", "gz", "sl"], "br": ["b", "bro", "dr", "vr", "lr", "bp", "r", "be", "FR", "bl", "sr", "rb", "str", "browser", "pr", "bi", "ber", "bg", "kr", "arr", "shr", "er", "BR", "tr", "sp", "el", "cr", "ch", "wr", "bh", "Br", "buf", "yr", "gr", "bt", "mr", "bm", "hr", "fr"], "line": ["message", "LINE", "range", "header", "block", "liner", "iter", "check", "display", "user", "note", "channel", "lo", "error", "ln", "file", "stroke", "l", "frame", "ine", "string", "eline", "cell", "str", "link", "inline", "trace", "lin", "entry", "rule", "train", "word", "stream", "n", "row", "page", "le", "label", "Line", "el", "msg", "valid", "sequence", "console", "text", "body", "style", "e", "log", "chain", "stay", "edge", "print", "code", "sample", "comment", "phrase", "lane", "point"]}}
{"id1": "3584508", "id2": "11484416", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "label": 1, "substitutes": {"copyResource": [" copiedFile", " copiedAddress", " copiedUrl", " copyUrl", "downloadAddress", "downloadResource", "downloadFile", "copyUrl", " copiedResource", "downloadUrl", "copyAddress", " copyFile", " copyAddress", "copyFile"], "url": ["ls", "path", "dl", "cert", "http", "URL", "r", "f", "address", "file", "l", "ur", "gl", "string", "fl", "https", "browser", "str", "cl", "link", "web", "html", "nl", "loc", "source", "null", "hl", "host", "uri", "util", "github", "rl", "char", "el", "gif", "ref", "ret", "mail", "Url", "re", "ml", "mb", "ssl", "resource", "ul", "base", "rel", "ll", "mount", "service", "sl"], "input": ["read", "user", "iter", "pull", "empty", "init", "accept", "http", "parse", "it", "audio", "info", "open", "context", "select", "file", "unknown", "config", "ain", "reader", "request", "Input", "add", "exec", "inside", "feed", "before", "focus", "image", "missing", "stream", "source", "null", "acl", "PUT", "eval", "in", "act", "up", "op", "initial", "state", "text", "qa", "form", "access", "upload", "get", "enter", "raw", "cont", "ssl", "active", "sum", "inner", "can", "start", "base", "index", "local", "ip"], "output": ["put", "beta", "online", "ilo", "group", "format", "net", "display", "ou", "out", "secure", "component", "update", "write", "file", "icon", "current", "network", "success", "client", "web", "continue", "image", "next", "null", "object", "exit", "secondary", "you", "ne", "console", "text", "bool", "hidden", "position", "unsigned", "remote", "entity", "connection", "four", "print", "auto", "outer", "o", "response", "other", "table", "Output"], "b": ["obj", "block", "bit", "ba", "ib", "k", "f", "be", "gb", "bp", "binary", "z", "m", "bf", "ab", "t", "bc", "l", "rb", "cb", "c", "bi", "r", "br", "bits", "p", "u", "bs", "char", "j", "y", "body", "sb", "eb", "by", "nb", "g", "B", "bb", "mb", "i", "wb", "fb", "d", "v", "base", "ble", "buff", "ob", "db"]}}
{"id1": "14650352", "id2": "22410173", "code1": "    boolean checkIfUserExists(String username) throws IOException {\n        try {\n            URL url = new URL(WS_URL + \"/user/\" + URLEncoder.encode(username, \"UTF-8\") + \"/profile.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            InputStream is = conn.getInputStream();\n            is.close();\n            return true;\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"checkIfUserExists": ["checkIfUserPersEx", "checkIfFileExist", "checkIfUserPersist", "checkIfUserListed", "checkIfUserExist", "checkIfUserLEx", "checkIfUserExisted", "checkIfUserPersists", "checkIfUserPersisted", "checkIfFileExEx", "checkIfFileExists", "checkIfUserExEx", "checkIfUserList", "checkIfUserLists", "checkIfFileExisted"], "username": ["person", "user", "message", "path", "ugi", "auth", "title", "human", "input", "subject", "filename", "ename", "description", "login", "config", "unknown", "phone", "string", "email", "key", "john", "term", "rue", "password", "owner", "token", "result", "attribute", "pai", "text", "uid", "ame", "ername", "aka", "remote", "account", "profile", "name", "prefix", "whatever", "hello"], "url": ["ls", "b", "user", "dl", "http", "URL", "open", "f", "r", "pkg", "file", "abs", "l", "ur", "str", "https", "job", "org", "ocl", "nl", "web", "loc", "lb", "uri", "gc", "char", "il", "el", "ol", "ref", "ld", "get", "Url", "re", "log", "ml", "build", "ssl", "ul", "bel", "atl", "ll", "sl"], "conn": ["inv", "init", "Conn", "net", "ctx", "nn", "yn", "open", "comm", "nt", "exec", "client", "cb", "gn", "c", "fin", "tn", "close", "cp", "cn", "ct", "cmd", "resp", "act", "coll", "nc", "sys", "soc", "ch", "conv", "enc", "dial", "con", "jp", "ssl", "connection", "cont", "syn", "cons", "res", "cur", "ws", "connect", "rel", "pas"], "is": ["cs", "css", "nis", "us", "isl", "fs", "dis", "ys", "IS", "bis", "tis", "isc", "lis", "nic", "ins", "iss", "xs", "ris", "ic", "in", "are", "bs", "Is", "isf", "sys", "isi", "set", "im", "its", "has", "js", "ios", "ais", "ps", "i", "sis", "si", "mis", "isa", "iris", "ms", "ip", "pas"]}}
{"id1": "6341264", "id2": "9033639", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getJarEnt", "getZipFile", "getJarFile", " getFileResource", "getJavaEnt", "getJavaFile", "getServerItem", "getFileEntry", " getJarInfo", " getFileEntry", "getJarInfo", "getServerEntry", "getServerInfo", " getZipItem", "getJarResource", "getFileResource", "getZipEnt", "getServerResource", " getJarResource", " getJarItem", " getZipEntry", "getModuleItem", "getModuleEntry", " getJarFile", "getJarItem", "getZipItem", "getJavaItem", "getResourceInfo", "getResourceItem", "getModuleFile", "getResourceResource", " getJarEnt", "getModuleEnt", "getFileInfo", " getFileInfo", "getResourceEntry", "getJavaEntry", " getFileItem", "getFileItem", " getZipEnt", "getZipEntry", " getZipFile"], "jarName": ["Jarname", "sessionKey", "sessionName", "JarLocal", "jarLocal", "binaryKey", " jarname", "jarname", "binaryName", "binaryname", "JarN", "jarN", "jobname", " jarKey", "sessionname", " jarLocal", "jarKey", "jobLocal", "jobN", "JarName", "jobName", " jarN"], "entry": ["path", "jar", "input", "query", "search", "address", "description", "file", "zip", "string", "cell", "Entry", "key", "word", "row", "ent", "uri", "quit", "er", "archive", "xml", "command", "element", "field", "text", "delete", "ie", "e", "log", "enter", "resource", "server", "print", "data", "ry", "name", "comment", "index"], "port": ["pt", "path", "value", "format", "offset", "priority", "it", "type", "PORT", "address", "project", "pc", "count", "string", "pos", "age", "Port", "key", "row", "limit", "page", "host", "p", "ort", "width", "version", "length", "socket", "position", "ports", "eport", "remote", "connection", "export", "server", "start", "point", "index", "localhost", "ip"], "b": ["bit", "ba", "ib", "r", "gb", "be", "f", "bp", "db", "bas", "bf", "ab", "bl", "s", "l", "bin", "cb", "bi", "c", "a", "br", "p", "bits", "u", "h", "bs", "y", "sb", "eb", "e", "nb", "B", "bb", "i", "buf", "wb", "buffer", "fb", "mb", "bt", "v", "emb", "base", "d", "buff", "xb", "ob", "j", "pb"], "codebase": ["Codease", "Codefile", "corefile", " codeBase", "codebased", "codefile", "chebase", "Codebased", "codebas", "corespace", "CodeBase", "Codebase", " codease", "linkBase", "Codebas", "cebased", " codebased", "codease", " codebas", "corebase", "cheBase", "coreBase", "linkbas", "codeBase", "cebase", "cease", "chefile", "codespace", "ceBase", "Codespace", "linkbase", "chespace"], "protocol": ["protol", "pronocol", "protos", "protication", "scheocol", "proavior", "proticle", "proos", "patol", "perticle", "patos", "proicle", "pertocol", "phyility", "scheication", "pronicle", "cryptix", "protavior", "pronotype", "prool", "patocol", "cryptocol", "pronavior", "protix", "cryptol", "protility", "pertavior", "scheility", "phyix", "cryptos", "prototype", "patotype", "scheix", "cryptotype", "phyication", "pertotype", "cryptility", "proocol", "phyocol", "cryptication", "prootype"], "x": ["xf", "ex", "xi", "z", "xxxxxxxx", "rx", "t", " cx", "xc", "ix", "tx", "wx", "xes", "n", "xp", "xs", "p", "ax", "nex", "y", "w", "inx", "ux", "xy", "xd", "xa", "ox", "dx", "i", "max", "px", "X", "index", "xx", "mx"], "s2": ["ss4", "pslt", "es2", "ts2", "sv2", "ts02", "ps1", "sv02", "sv1", "ps02", "ps2", " slt", " stwo", " s1", "ts3", "xlt", "es1", "s1", "ss02", "ss3", " s02", "s02", "ts4", "x1", "ss2", "s3", "s4", "slt", "stwo", "x02", "es02", "estwo", "svtwo"], "x2": ["ax02", "ex3", "ex02", " x1", "rx2", "ex1", "rx1", "ax1", "ix1", "x3", "ex2", " x02", "ax2", "ix02", "x1", "ix2", "x02", "rx02", " x3", "ax3"], "downloadHost": ["DownloadHost", "dumpUrl", "dumphost", " downloadDomain", "transferPort", "archiveHost", "downloadHead", "downloadhost", "dumpPath", "Downloadhost", "dumpNode", "transferUrl", "DownloadHead", "DownloadUrl", " downloadPath", "downloadPath", " downloadhost", " downloadNode", "transferHost", "DownloadNode", "archiveUrl", "downloadDomain", "downloadPort", "transferhost", " downloadHead", "DownloadDomain", "DownloadPort", "dumpHost", " downloadPort", " downloadUrl", "DownloadPath", "downloadNode", "archivehost", "archiveHead", "downloadUrl", "dumpDomain"], "url": ["ls", "obj", "dl", "jar", "http", "URL", "lr", "download", "open", "file", "zip", "l", "ur", "gl", "str", "link", "browser", "web", "nl", "arl", "loc", "hl", "lb", "uri", "rl", "il", "www", "el", "json", "mil", "sb", "ref", "ret", "pl", "mail", "Url", "ml", "build", "serv", "log", "ssl", "ul", "bel", "base", "atl", "rel", "ll", "ob", "mount", "name", "sl", "call"], "jurl": ["jpgl", "jsjob", "jarUrl", "JUrl", "jkl", "jpsl", "jpUrl", "jarurl", "jsgl", "jjUrl", " jgl", "jckl", "jjURL", " jsl", "Jkl", "jarkl", "jsll", "jjjob", "jname", "jcname", "Jname", " jURL", "jjob", "jcurl", "jarname", "jsURL", "jpurl", "jjurl", "Jurl", "zll", "jURL", "jsl", "zgl", "jsUrl", "jll", "jcUrl", " jUrl", "zUrl", "zurl", "jssl", "jgl", "jUrl", " jll", " jjob", "jsurl"], "je": ["vre", "zo", "oe", "sec", "dj", "zip", "exe", "se", "jo", "bj", "ae", "jet", "ze", "ve", "pe", "ffe", "ne", "ja", "jj", "ge", "nex", "te", "js", "ie", "ese", "e", "zy", "jp", "jl", "ei", "ele", "elt", "j", "jen", "ee", "pet", " Je"], "is": ["nis", "\u00eds", "isl", "fs", "ib", "iso", "IS", "s", "tis", "isc", "ist", "ai", "lis", "ri", "bi", "ists", "ir", "ii", "ins", "iss", "os", "bits", "mi", "ris", "in", "bs", "Is", "atis", "il", "ires", "isi", "im", "its", "sb", "js", "ios", "isin", "ais", "es", "i", "sis", "si", "isa", "ois", "obs"], "bis": ["ls", "rots", "nis", "bytes", "gs", "fs", "binary", "vs", "tis", "oi", "sbm", "oss", "onis", "abin", "lis", "pins", "bes", "ri", "cb", "bi", "bps", "ins", "bos", "uds", "rs", "bits", "os", "ris", "bs", "ubis", "ses", "isi", "ibe", "xy", "its", "sb", "conv", "isin", "bh", "rison", "ais", "ios", "es", "serv", "bb", "uffy", "aos", "res", "buff", "bil", "ob", "obs", "fr", "ns"], "size": ["message", "iz", "range", "storage", "SIZE", "empty", "zie", "sy", "number", "time", "type", "small", "space", "ize", "sv", "use", "count", "news", "se", "send", "mode", "score", "sn", "n", "nr", "year", "ze", "num", "unit", "scroll", "ose", "area", "settings", "len", "scale", "notice", "sex", "Size", "length", "body", "capacity", "re", "shape", "si", "max", "sum", "pi", "now", "sample", "name", "status", "index"], "rb": ["rob", "ptr", "ring", "lr", "rss", "bp", "gb", "RB", "r", "err", "rm", "rc", "rt", "bone", "buster", "ctr", "cb", "rg", "ri", "rar", "rs", "rw", "erb", "br", "lb", "nr", "ord", "rf", "rid", "num", "cr", "umb", "rod", "sb", "ref", "ruby", "eb", "nb", "bb", "rd", "buf", "wb", "rab", "fb", "rex", "xb", "kb", "mr", "ru", "db", "ob", "ro", "pb"], "chunk": ["ichunk", "cunks", "Chunk", " chord", " chulk", "chedunk", "cunk", "chunks", "cpunk", "charump", "Chunks", "chump", "choint", "chulk", "chedunks", "ichulk", "charunk", "echbyte", " chump", "chedump", "chord", " chbyte", "echunk", "charbyte", "chork", "tchow", "tchork", "cork", " choint", "chedoint", "echord", "tchunk", "tchunks", "echunks", "charoint", "cpow", "cow", "cpunks", "ichunks", "chow", "cpork", " chunks", "charunks", "charord", "Chulk", "chbyte"]}}
{"id1": "14882263", "id2": "12417893", "code1": "    private void UploadActionPerformed(ActionEvent evt) {\n        JFileChooser chooser = new JFileChooser();\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(\"*.jpg\", \"jpg\");\n        chooser.setFileFilter(filter);\n        File dir = new File(System.getProperty(\"user.home\"));\n        chooser.setCurrentDirectory(dir);\n        Component parent = null;\n        int returnVal = chooser.showOpenDialog(parent);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            UserStatus.setText(\"Bitte warten\");\n        }\n        try {\n            Pic.setVisible(false);\n            FTPClient client = new FTPClient();\n            client.connect(\"showus.de\");\n            client.login(\"web2\", \"kcinnay88\");\n            client.enterLocalActiveMode();\n            client.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            int reply = client.getReplyCode();\n            System.out.println(\"Connect returned: \" + reply);\n            FileInputStream in = new FileInputStream(chooser.getSelectedFile().getAbsolutePath());\n            System.out.println(\"Uploading File\");\n            client.storeFile(\"/html/Applet/user/\" + Config.id + \".jpg\", in);\n            client.logout();\n            in.close();\n            System.out.println(\"done\");\n            UserStatus.setText(\"Upload fertig, Bild wird aktuallisiert\");\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            UserStatus.setText(\"Fehler beim Upload\");\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"UploadActionPerformed": [" uploadActionOcclected", " uploadActionOccceived", " uploadEventPerceived", " uploadActionReuted", " uploadActionPerformed", " uploadActionOccuted", " uploadEventOccformed", " uploadActionRelected", " uploadActionPerceived", " uploadEventOccuted", " uploadActionPeruted", " uploadActionReceived", " uploadEventPerformed", " uploadActionPerlected", " uploadActionReformed", " uploadActionOccformed", " uploadEventOccceived", " uploadEventPerlected", " uploadEventPeruted", " uploadEventOcclected"], "evt": [" EVt", "evtm", " EVtm", " evte", " EVtd", " emt", " EVte", "evte", " evtd", " emtd", "evtd", " emtm", " emte", " evtm"], "chooser": ["compener", "choener", "compose", "boose", "boosen", "roer", "Choose", "CHOose", " choener", "composen", "rooser", "chose", "choser", "chener", "roicer", "composer", "roose", "CHOener", " choer", "Choener", "chosen", "choicer", " choicker", "Choicker", "Choicer", "Choosen", "choicker", "CHOoser", "CHOicker", "chicker", "CHOosen", "choose", "boicker", "Chooser", "booser", " choicer", " choosen", "Choer", "choer", " choose", "choosen"], "filter": ["transform", "match", "range", "check", "format", "function", "Filter", "find", "type", "search", "query", "f", "filename", "file", "list", "map", "apply", "use", "test", "feature", "term", "mask", "pattern", "util", "xml", "handler", "fil", "spec", "folder", "policy", "set", "ref", "finder", "only", "sf", "profile", "sort", "service", "table"], "dir": ["path", "dl", "dep", "out", "DIR", "id", "wd", "home", "tmp", "lib", "pkg", "file", "fd", "pos", "directory", "root", "Dir", "ir", "window", "loc", "ext", "def", "manager", "div", "ind", "folder", "set", "desc", " Dir", "ref", "dat", "dial", "log", "dist", "d", "res", "base", "data", "rel", "name", "db", "doc"], "parent": ["obj", "group", "ctx", "out", "component", "context", "widget", "tmp", "m", "instance", "config", "parents", "pos", "root", "self", "window", "pid", "container", "this", "page", "null", "p", "close", "cp", "Parent", "manager", "tree", "owner", "part", "sp", "div", "state", "form", "g", "e", "gr", "server", "holder", "pool", "child"], "returnVal": ["resultval", "returnValue", "resultVal", "resultVAL", "ReturnValue", "Returnval", "retValue", "retVAL", "submitValue", "returnVAL", " returnValue", "submitVal", " returnVAL", " returnType", "submitType", "acceptVal", "acceptType", "resultValue", "returnval", "returnType", "submitVAL", "retval", "acceptVAL", "acceptValue", "ReturnVal", "ReturnVAL", "retVal"], "client": ["obj", "collection", "ce", "template", "net", "http", "cgi", "cache", "secure", "out", "url", "force", "api", "Client", "context", "lib", "wrapper", "file", "core", "config", "and", "phone", "cell", "browser", "cl", "google", "web", "system", "c", "key", "connected", "window", "proxy", "acl", "close", "cmd", "manager", "pattern", "util", "io", "default", "console", "cod", "dial", "remote", "controller", "con", "chain", "conn", "ssl", "connection", "co", "server", "contact", "resource", "create", "rand", "response", "cli", "connect", "bolt", "channel", "service", "local", "call"], "reply": ["match", "script", "voice", " replied", "query", "write", "shell", "echo", "consider", "Reply", "back", "repl", "nz", "answer", "zero", "continue", "route", "next", "proxy", "close", "exit", "py", "nr", "cmd", "trust", "command", "result", "state", "notice", "bill", "respond", "body", "embed", "report", "intern", "nb", "ply", "connection", "print", "poll", "response", "connect", "comment", "vote", "call"], "in": ["In", "ex", "is", "out", "input", "it", "rin", "sql", "f", "file", "ma", "IN", "login", "inn", "reader", "add", "s", "ai", "bin", " IN", "ins", "from", "inc", "mc", "p", "mi", "en", "ic", "io", "ind", "body", "din", "by", "cin", "serv", "conn", "i", "gin", " din", "sum", "inner", "o", "pi", "ini"]}}
{"id1": "20717531", "id2": "13565787", "code1": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 1, "substitutes": {"encrypt": ["decrypt", "encrypted", "encipher", "decipher", "uncrypted", "Encrypt", "Encryption", "uncryption", "uncrypt", "encryption", "Encrypted", "decryption", "decrypted", "uncipher", "Encipher"], "plainText": ["realSource", "ainDelete", " plainTextColor", "formText", " plainOutput", "ainData", "plainDelete", "realtext", "leadTEXT", "realTEXT", "broadTEXT", "publictext", "formtext", "ainWord", " plainName", "publicData", "publicText", " plainPath", "leadtext", "plainTextColor", "tableUrl", "floatDelete", "plainSource", "broadText", "ainTextColor", "ainText", "plainPassword", "longText", "hardtext", "broadPassword", "ainTEXT", "longTextColor", "ainString", " plainTEXT", "leadPath", "plainData", "longTEXT", "plainName", "longSource", "plainConfig", "hardTEXT", " plaintext", "broadDelete", "longtext", "plainPath", "ainOutput", "ainUrl", "floatTEXT", "cleanTEXT", "tableTEXT", "cleanText", "realText", "ainPath", " plainConfig", "plaintext", "ainPassword", "plainTEXT", "longString", "plainOutput", " plainData", "hardWord", "ainConfig", "tableConfig", "plainUrl", "ainName", "plainString", " plainSource", " plainString", "aintext", "hardText", "cleanName", "formTEXT", "floatPassword", "leadText", "cleantext", "formWord", "publicOutput", "tableText", "floatText", "plainWord", " plainUrl"], "text": ["read", "path", "message", "template", "format", "net", "title", "tt", "input", "all", "aut", "write", "binary", "select", "output", "translation", "nt", "quick", "t", "left", "ut", "tx", "cat", "ext", "word", "TEXT", "quote", "image", "txt", "source", "end", "struct", "ct", "act", "ind", "view", "writer", "log", "process", "buffer", "cont", "math", "content", "sum", "print", "event", "start", "Text", "prefix", "comment"], "i": ["my", "xi", "f", "I", "t", "asi", "uni", "ai", "ix", "hi", "ri", "p", "mi", "u", "phi", "iu", "v", "ei", "o", "ip", "is", "init", "cgi", "id", "z", "oi", "ki", "x", "ii", "multi", "ic", "in", "sim", "chain", "zi", "ti", "point", "ui", "ini", "iter", "qi", "\u0438", "ci", "li", "m", "iy", "gu", "n", "io", "im", "g", "print", "cli", "j", "index", "di", "ims", "ami", "ni", "us", "gi", "it", "ski", "bi", "q", "uri", "eu", "y", "ity", "ori", "ji", "si", "yi", "pi", "ms"], "mDigest": ["mHashum", "mHashested", "mdigse", "mExecum", " mDigger", "mDigester", "mMDse", "MDigse", "mDher", "mFindse", " mDigum", " mDigher", "mDose", "MDigest", "mFindgest", "mHashger", "mMacse", "mMacested", "mDigse", "mdigest", "mDigested", "mdigher", "mFindest", " mDher", "mdigested", "Mdiggest", " mDigester", " mHashested", " mHashest", "mDse", "mDigher", "mDiger", "mMDer", " mDest", " mDigse", "mdigum", "mDoested", "Mdiger", "mFinder", "mExecest", "mdigester", "mDested", "mExecger", " mHashger", " mDigested", "mDest", "mDigger", "mExecested", "mHashest", " mHashum", "mdigger", " mDested", " mDse", "MDiggest", "mdiger", "mDoest", "mMacester", "mdiggest", "mDester", " mDester", "Mdigse", "mMDest", "mMDgest", "MDiger", "mMacest", "Mdigest", "mDiggest", "mDoher", "mDigum"], "d": ["b", "nd", "cd", "D", "dh", "ds", "with", "r", "f", "da", "m", "fd", "t", "s", "l", "md", "done", "x", "de", "dc", "c", "n", "a", "df", "p", "u", "h", "dd", "pd", "ed", "dict", "dot", "j", "y", "w", "dec", "dat", "g", "ld", "e", "bd", " D", "dx", "sd", "v", "db", "di", "diff"], "hash": ["message", "block", "header", "check", "hz", "flash", "dh", "shift", "cache", "all", "id", "search", "array", "save", "ssh", "ash", "always", "checked", "ah", "summary", "oh", "test", "html", "our", "key", "random", "radius", "h", "handle", "dict", "href", "password", "sh", "tr", "shadow", "div", "style", "report", "sha", "hex", "Hash", "rh", "buffer", "total", "sum", "print", "code", "her", "tag", "filter", "square", "table"]}}
{"id1": "7981642", "id2": "8921716", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"update": ["commit", "reply", "change", "put", "place", "Update", "check", "auth", "init", "read", "store", "register", "input", "write", "save", "login", "config", "apply", "add", "append", "UPDATE", "feed", "load", "alter", "test", "printf", "move", "touch", "up", "handle", "username", "mod", "set", "text", "edit", "post", "delete", "upload", "insert", "updated", "remove", "escape", "create", "pack", "data", "replace", "sample"], "mail": ["message", "iter", "dl", "com", "Email", "cert", "net", "http", "tp", "id", "grid", "url", "ip", "eth", "del", "address", "mobile", "pkg", "m", "file", "dir", "ln", "zip", "md", "link", "test", "virtual", "gmail", "n", "domain", "mails", "alt", "label", "host", "Mail", "dn", "cmd", "addr", "username", "el", "msg", "old", "imp", "im", "mm", "port", "dial", "pl", "log", "enter", "server", "hold", "print", "mem", "name", "mount", "mun", "local", "dm", "mill"], "email": ["external", "message", "ilo", "Email", "template", "atom", "note", "number", "url", "sql", "address", "del", "file", "ln", "m", "echo", "zip", "phone", "link", "cdn", "html", "nl", "nm", "virtual", "image", "test", "n", "domain", "ns", "label", "detail", "host", "object", "dn", "cn", "uri", "addr", "il", "xml", "password", "username", "el", "text", "e", "log", "entity", "line", "enter", "date", "server", "et", "sample", "example", "name", "IL", "ip"], "pwd": ["pressw", "Pws", "pressws", " pword", "Pw", " pow", "psow", "pswd", "Pfx", "Pgen", "dpw", "dpgen", "pfx", " pw", "psw", " ppriv", "psfx", "ppriv", "pws", "Pword", "Pow", "pw", "Pwd", "dpwd", "dpword", "presspriv", "presswd", " pfx", "pow", "pword", " pgen", " pws", "Ppriv", "pgen"], "firstname": ["smallNAME", "firstName", " firstrun", " firstName", "firstnames", " firstNAME", "firstrun", "firstparent", "firstNAME", " firstparent", "smallrun", "FirstName", "lastnames", "lastNAME", "lastName", "Firstparent", "lastrun", "smallname", " firstnames", "Firstnames", "smallName", "Firstname", "lastparent", "FirstNAME"], "lastname": ["firstName", "longnum", "longname", "givenname", "firstnum", "fullName", "lastame", " lasttype", "givenName", "fullname", "lasttype", "lastName", " lastnum", " lastame", "longName", "giventype", "firstame", "fullame", "lastnum", "longame", " lastName", "firsttype", "givennum"], "connection": ["collection", "creator", "Connection", "application", "context", "database", "onet", "ion", "description", "session", "link", "network", "directory", "client", "entry", "system", "connected", "management", "c", "cone", "document", "nc", "command", "handler", "engine", "city", "conn", "con", "condition", "event", "resource", "communication", "response", "connect", "relation", "pool"], "attrs": ["atrys", "addrs", "latributes", "atras", " attras", "avrs", "attrd", "atrd", "attachRs", "attsrics", "adrs", "atries", "attRs", " attRs", " attries", "attributes", "latrs", "addrd", "addras", "avras", "atters", " attrd", "attrics", "addributes", "atrs", "actrs", "adributes", "attters", " attds", " attns", "attrys", "attds", "attps", "adras", "actters", "actributes", "atributes", "atds", "atRs", "attachrs", "latters", "actrys", "latrys", "atps", "attsries", "addRs", "attsrs", "adns", "atns", "attachras", "attsributes", " attps", "avrics", "avributes", "attras", "attsras", "attries", " attributes", "atrics", "attachributes", "attsds", "attns", "attsps"], "sha": ["shi", "lambda", "SHA", "ppa", " SHA", "ka", "pa", "git", "tar", "iso", "da", "func", "shell", "ma", "ssh", "wa", "mac", "cos", "md", "shared", "sq", "hi", "asha", "a", "acl", "go", "h", "comp", "ha", "ya", "sh", "sam", "HA", "sche", "has", "ca", "ksh", "no", "mb", "sa", "total", "sum", "alpha", "auto", "mem", "sm"], "digest": ["dest", "Digge", "mdEST", "dighest", " digEST", "digEST", "mdse", "dested", "dge", "Digests", "mdests", "redest", "mdhest", "digested", "mdest", "Digest", "divest", "divEST", "digests", "Digse", " digests", "redests", "redge", "dests", "redested", "digge", "divse", "DigEST", "Digested", "mdested", "divhest", "digse", "Dighest", " digested"], "hash": ["message", "check", "auth", "format", "flash", "cache", "input", "search", "ash", "mac", "ashes", "md", "ASH", "html", "key", "score", "h", "ha", "trust", "handle", "dump", "password", "sh", "result", "shadow", "has", "hex", "bh", "dig", "Hash", "rh", "total", "sum", "print", "proof", "base", "tag", "each", "filter"], "ctx": ["obj", "Conn", "tc", "gm", "sc", "context", "tmp", "nt", "pkg", "mk", "bc", " cx", "rc", "ctr", "xc", "kw", "tz", "tx", " context", "sq", "cb", "x", "wx", "dc", "loc", "txt", "tk", "mc", "cp", "cv", "gc", "ct", "cm", "cmp", "nc", "cu", "kl", "conv", "ca", "ctrl", "conn", "con", "jp", "ck", "co", "cf", "Context", "np", "pg", "lc"], "newName": ["newKey", "currentKey", "newname", "currentname", "oldname", "currentName", "finalHome", " newKey", " newname", "NewNAME", "currentNAME", " newNAME", "finalName", " newNames", "newNAME", "newHome", "NewName", "Newname", "finalNames", "newNames", "finalname", "oldNames", "oldHome", "NewKey", " newHome"], "oldName": ["olderPref", "newname", "olderKey", "oldername", " oldKey", " oldPref", "newOr", "oldname", "smallOr", "recentOr", "olderName", "prevName", "oldAnd", "recentName", "prevKey", "smallAnd", "prevPref", "newAnd", "oldPref", "recentAnd", "smallname", "oldOr", "smallName", "prevname", "recentname", " oldname", "oldKey"]}}
{"id1": "19113613", "id2": "19096138", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["pixel", "init", "opy", "write", "download", "save", "clip", "Cop", "sync", "paste", "core", "map", "php", "same", "zip", "cos", "link", "cat", "crop", "clone", "move", "proxy", "cop", "cp", "share", "gc", "py", "to", "Copy", "cross", "slice", "delete", "co", "transfer", "create", "replace", "split", "ip"], "in": ["In", "inv", "iter", "check", "is", "init", "sin", "net", "on", "input", "rin", "it", "id", "all", "info", "IN", "inn", "l", "inside", "inf", "bin", "ai", "ar", "ir", "ins", "from", "inc", "en", "mi", "ic", "act", "up", "el", "ind", "y", "old", "din", "isin", "ie", "by", "re", "cin", "con", "i", "gin", "inner", "o", "local", "ini"], "out": ["b", "obj", "ex", "at", "over", "OUT", "net", "on", "ou", "cache", "all", "it", "store", "write", "ver", "err", "output", "tmp", "nt", "ion", "t", "l", "oss", "client", "gt", "Out", "n", "one", "null", "end", "os", "p", "ent", "not", "this", "en", "to", "io", "op", "sys", "outs", "result", "y", "set", "w", "ch", "port", "OU", "log", "con", "conn", "co", "inner", "v", "aos", "o", "res", "base", "can", "ot", "outer", "local"], "source": ["SOURCE", "range", "ce", "template", "format", "src", "title", "sin", "store", "input", "search", "query", "Source", "sql", "subject", "select", "shell", "space", "ource", "s", "use", "cause", "se", "string", "system", "origin", "key", "this", "scope", "from", "lower", "unit", "attribute", "sp", "site", "sequence", "style", "position", "ie", "parent", "finder", "si", "resource", "inner", "start", "base", "language", "scan", "prefix", "status", "index", "service", "local", "relation"], "target": ["dest", "alias", "match", "template", "query", "url", "output", "translation", "that", "join", "t", "Target", "link", "ARGET", "top", "gt", "arg", "test", "key", "term", "origin", "tif", "root", "scope", "null", "to", "pattern", "tree", "token", "style", "step", "parent", "goal", "resource", "module", "print", "location", "base", "arget", "other", "rel", "point", "bolt", "local", "table"], "files": ["headers", "ls", "models", "pieces", "iles", "states", "faces", "modules", "actions", "books", "fs", "facts", "packages", "users", "banks", "thumbnails", "reports", "parts", "jobs", "balls", "resources", "tools", "details", "services", "events", "issues", "features", "images", "lets", "ports", "styles", "uploads", "plates", "members", "les", "lines", "assets", "objects", "items", "workers", "values", "pages"], "file": ["library", "item", "path", "block", "user", "full", "foo", "f", "filename", "be", "fp", "dir", "current", "tile", "job", "entry", "feature", "key", "rule", "image", "word", "row", "le", "page", "label", "ve", "fe", "pe", "ile", "tree", "document", "work", "el", "field", "folder", "port", "FILE", "e", "parent", "line", "event", "resource", "print", "model", "base", "play", "data", "name", "node", "relation", "File", "local", "table", "child"], "inCh": ["outCod", "rinCod", "cinCr", " inChan", " inCl", "rinCl", "incCh", "cinch", "cinCh", " inch", "cinSam", "cinCor", "incCor", "inch", "dinCh", "inCl", "InCl", "inCod", "InCh", "outch", "rinChan", "InCod", "inSam", " inCod", "incCr", "dinCor", "cinChan", "rinCh", "InChan", "inChan", "dinCr", "outChan", "inCor", "incSam", "dinSam", "inCr", "cinCod"], "outCh": ["outCod", "outputCh", " outChan", "newGr", " outCol", "newCol", "newCh", "newch", " outGr", "outGr", "inCol", "outputChan", "inch", " outch", "outch", "newChan", "outCol", "outputGr", "inChan", "outputCod", "outChan", " outCod", "newCod"]}}
{"id1": "8625346", "id2": "4798332", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeStringToFile", "encodeFileToFiles", "encodeStringAsDisk", "encodeFileFromStream", "encodeFileFromDisk", "encodeStringAsFile", "encodeFileAsFiles", "encodeFiletoFile", "encodeFiletoFiles", "encodeStringToStream", "encodeFileAsFile", "encodeFileAsDisk", "encodeFileAsStream", "encodeFileFromFile", "encodeStringAsStream", "encodeStringToDisk", "encodeFiletoDisk", "encodeFiletoStream", "encodeStringToFiles", "encodeFileToStream", "encodeStringAsFiles", "encodeFileToDisk"], "infile": ["InFile", "inputfile", "outbase", "inbase", " inFile", "inFile", "outpath", "Inbase", "outFile", "Inpath", " infilename", "Infile", "outfilename", "infilename", "inpath", "inputpath", "inputfilename", "inputFile", " inpath", " inbase"], "outfile": ["inname", "newfile", " outname", "newname", "newfilename", "newFile", "inFile", "tofile", "todir", "fromfp", " outfilename", "infp", "outFile", "fromfile", "outdir", "indir", "fromdir", "tofp", "toFile", "outfp", " outFile", "outfilename", "infilename", "fromFile", "outname"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "image", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ro", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "null", "fn", "os", "en", "cn", "to", "flush", "up", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "can", "aos", "o", "res", "outer", "inner", "ot"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "queue", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "length", "black", "stack", "temp", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", "commit", "ccess", "cess", "value", "accept", "fail", "growth", "warning", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "ith", "successful", "good", "please", "ceed", "town", "result", "valid", " Success", "successfully", " okay", " failure", "ratulations", "photo", "sufficient", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "2461169", "id2": "21488868", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFileString", "decodeFileAsfile", "decodeStringToString", "decodeFile2String", "decodeFileAsFile", "decodeFileFileFile", "decodeFileAsString", "decodeString2Files", "decodeFileToFiles", "decodeFile2Files", "decodeFileFilefile", "decodeFile2file", "decodeStringTofile", "decodeString2file", "decodeStringToFile", "decodeFileToString", "decodeString2File", "decodeStringToFiles", "decodeFile2File", "decodeFileFileFiles", "decodeString2String", "decodeFileTofile", "decodeFileAsFiles"], "infile": ["InFile", "inputfile", "inname", "frombase", "isinfolder", "Infilename", "outbase", "inbase", "inFile", "isinname", "Inbase", "infolder", "outFile", "fromfilename", "fromfile", "Infile", "isinFile", "inputname", "outfilename", "infilename", "outfolder", "fromFile", "inputFile", "inputfolder", "isinfile", "outname"], "outfile": ["inname", " outname", "Outfilename", "outFILE", "inFILE", "inFile", "tofile", "todir", " outFILE", "otfile", "outFile", "outdir", "Outdir", "indir", "outname", "otFile", "toFile", " outFile", "otname", "outfilename", "OutFile", "infilename", "otFILE", "tofilename", "Outfile"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "fn", "null", "os", "en", "cn", "to", "flush", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "aos", "res", "o", "auto", "can", "outer", "ot", "inner"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "black", "stack", "temp", "shape", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "shift", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", " succeed", "exist", "ccess", "commit", "cess", "value", "accept", "fail", "growth", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "scope", "successful", "good", "please", "ceed", "town", "result", "valid", "successfully", " okay", " failure", "ratulations", " succeeds", "sufficient", "photo", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "9109613", "id2": "16623181", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fileCopy": ["fileUpload", " filecopy", "filecopy", "FileCopy", "doCopy", " fileCop", " fileUpload", "doUpload", "Filecopy", "fileCop", "FileCop", "docopy", "doCop", "FileUpload"], "from_name": ["fromptadmin", "from_world", " from_admin", " from_type", " from_names", " from_user", "fromptnames", " from_client", "from_client", "from__size", "from_names", "from_admin", "from_type", "to_world", " from_base", "to_case", " from_size", "from__name", "from_value", " from_no", " from__size", "from_no", "from_user", "from__names", " from__name", "from_size", "fromptname", "from_base", " from__names", "from_case", " from_value"], "to_name": ["intoNamecode", "toNamepath", "to_path", " to_Name", "toNamename", "intoNamepath", "to_names", "to_long", "intoNamenames", "into_num", " to_long", "into_names", "to_code", "toNamenames", " to_names", "to_num", "to_Name", "toNamecode", "into_name", "into_path", "intoNamename", "into_code"], "fromFile": [" fromLine", "toField", "onFile", "sentPage", " fromfile", " fromGlobal", "tofile", " fromTime", " fromPage", "entryFile", "onfile", "FromFILE", " fromFILE", "startFilename", "boundPlace", "orFile", "givenfile", " fromPlace", "newfile", "FromDo", " fromFiles", "smallPlace", "newFile", "fromLine", "smallFiles", "fromFilename", "fromField", "formFilename", "newGlobal", " fromDo", "Fromfile", "sentFile", "fromFiles", "newPage", "orTime", "entryName", "givenFile", "normalLine", "orPage", "formfile", "sentfile", "startfile", "fromfile", "normalFile", "boundFILE", "oldfile", "boundFile", "normalField", "smallFile", "FromFile", "fromDo", "oldFile", "FromLine", "formFile", "normalPage", "fromPage", "sentField", "fromGlobal", "toPage", "normalfile", "startName", "entryFilename", "onFILE", "fromName", "formName", "entryfile", "fromTime", "orLine", "givenGlobal", "oldDo", "startFile", "fromFILE", "boundFiles", "smallFILE", "fromPlace", "normalTime", "givenPage", "oldLine"], "toFile": ["ToTable", "toTable", "TOFile", "toSourceFile", "TOfile", "ToModel", "targetFile", "twoFiles", "fromTable", "tofile", "templateFile", "toFilename", "templateModel", "toProcess", "intoFiles", " toTime", "byfile", "toTime", "intoPort", "templateTable", "ToFile", " toPort", "intoMessage", "thatFile", "etoMessage", " toPlace", "toFiles", "twoPort", "thatDefault", " toFilename", "bySourceFile", "newfile", "toName", "targetDo", "newFile", "TOPath", " toTable", "twofile", "thatFILE", "toPlace", "twoFile", "toModel", "byPlace", "ToFILE", " toDefault", " toDo", "fromFiles", "targetFILE", " toPath", "etoDefault", "etoName", "fromPort", "etofile", "toPath", "TOSourceFile", "templateFILE", "ToFiles", "intoName", "targetPlace", "etoProcess", "TOTime", " tofile", "toDo", "targetTable", " toFiles", "toPort", "toMessage", "intoTable", " toFILE", "intoFile", "twoTime", "TOFiles", "TOPort", "newPlace", "Tofile", "newSourceFile", "toFILE", "twoPath", "fromMessage", "twoSourceFile", "fromName", "thatfile", " toSourceFile", "targetModel", "etoFile", "toDefault", "ToFilename", "TOPlace", "fromProcess", "intoProcess", "byFile", "etoFILE"], "parent": ["path", "tip", "my", "where", "prop", "id", "component", "tar", "home", "filename", "mt", "tmp", "file", "ma", "m", "parents", "instance", "per", "params", "central", "pos", "directory", "root", "origin", "peer", "mother", "pid", "rule", "family", "this", "source", "null", "page", "host", "p", "def", "Parent", "unit", "global", "layout", "up", "tree", "master", "owner", "sp", "paren", "spec", "folder", "exp", "uid", "desc", "position", "snap", "form", "port", "temp", "remote", "shape", "chain", "event", "module", "server", "man", "holder", "pi", "timeout", "name", "prefix", "point", "pool", "ip", "child"], "dir": ["dev", "path", "iter", "dep", "cd", "dr", "dl", "init", "or", "out", "DIR", "ds", "wd", "vol", "del", "red", "tmp", "file", "fd", "cond", "direct", "md", "str", "directory", "fin", "Dir", "ir", "dc", "loc", "crit", "dd", "def", "good", "coll", "addr", "det", "dict", "odd", "rec", "tr", "div", "mod", "folder", "ind", "dim", "dist", "cont", "module", "d", "cur", "rel", "db", "di"], "from": ["user", "From", "ce", "com", "check", "or", "empty", "init", "on", "store", "out", "input", "query", "with", "false", "clean", "and", "left", "back", "link", "before", "pos", "client", "entry", "origin", "c", "window", "fun", "stream", "term", "source", "orig", "ent", "en", "in", "sent", "initial", "bound", "old", "st", "set", "style", "form", "by", "min", "no", "con", "only", "so", "inner", "local", "start", "ra", "create", "base", "vol", "fr", "reset", "normal"], "to": ["or", "title", "on", "ts", "out", "lo", "with", "write", "tg", "output", "that", "two", "toc", "t", "done", "news", "about", "pretty", "client", "To", "top", "tto", "too", "ta", "eto", "test", "this", "null", "go", "tom", "TO", "tree", "please", "token", "target", "te", "writer", "po", "by", "no", "phi", "ato", "so", "co", "total", "into", "can", "o", "pi", "auto", "base", "tty", "table"], "buffer": ["message", "block", "template", "device", "parse", "cache", "number", "binary", "database", "paste", "stroke", "frame", "append", "queue", "entry", "character", "memory", "window", "Buffer", "row", "word", "page", "batch", "char", "initial", "document", "attribute", "command", "bar", "result", "sequence", "length", "stack", "temp", "buf", "event", "available", "base", "sample", "buff", "phrase", "comment", "button", "table", "variable"], "bytes_read": ["Bytes_have", "bytes_q", "Bytes_read", "bytes5need", "bytes5read", "bytes2read", "Bytes_q", "bytes__read", "bytes_have", "bytes__find", "bytes2need", "bytes5Read", "bytes_write", "Bytes_need", "bytes_find", "bytes2Read", "Bytes_Read", "bytes_Read", "bytes__write", "Bytes_write", "bytes_need", "bytes5write", "bytes__q", "Bytes_find", "bytes2write"]}}
{"id1": "6009527", "id2": "536614", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadAttachention", "doFinishLoadAssention", "doFinishLoadAttachachment", "doFinishLoadAttention", "doFinishLoadAssachment", "doFinishShowAttached", "doFinishShowDetached", "doFinishShowDetachment", "doFinishShowAttachment", "doFinishLoadDetention", "doFinishLoadAttached", "doFinishLoadDetached", "doFinishLoadAssached", "doFinishLoadDetachment", "doFinishShowAttention", "doFinishLoadAttachached", "doFinishShowDetention"], "attachmentId": ["detachedid", "ATTachmentKey", "attgmentKey", "attachmentName", "atutationName", "attachmentid", "attociationid", "detachedKey", "attentionById", "attachmentKey", "attociationKey", "detachedId", "attentionId", "attagramKey", "detachmentid", "attentionName", "attgmentid", "attutationId", "ATTachmentid", "detachmentKey", "attachedById", "atachmentId", "attagramId", "ATTociationKey", "attagramById", "attagramid", "ATTociationById", "atutationId", "attachedid", "atachmentById", "attociationId", "ATTachmentId", "attachedKey", "attociationById", "atachmentName", "attociationID", "attutationName", "attutationID", "attachmentById", "attachedId", "ATTociationId", "attachmentID", "ATTachmentById", "attentionID", "detachmentId", "atutationById", "attociationName", "attgmentId", "atutationID", "ATTociationid", "attutationById", "atachmentID"], "attachment": ["detached", "contached", "addociation", "ATTention", "attachachment", "attached", "attment", "detment", "attachaching", " attached", "contachment", "assaching", "attaching", "addached", "assachment", "ATTached", "assached", "detachment", "detacher", "attachociation", "ATTacher", "attachacher", "attention", "attociation", "addaching", "contacher", "association", "attachached", "addachment", " attment", "assacher", "attacher", "ATTachment", "attachention", " attacher", "contment", "assention"], "attachmentUri": ["attentionUrid", "attentionUri", "attentionUtpi", "attachmentuRI", "attachableOuri", "attachmentOri", "attachableOURI", "attachmentOURI", "attachmentUtri", "attachableUURI", "attentionUpi", "attachmenturi", "attachmentOpi", "attachableOri", "attachmenturid", "attachmentUtrid", "attachmentUtRI", "attachmentUnri", "attachmentURI", "attachableUuri", "attachmentUpi", "attachmentTpi", "attentionUtrid", "attachableOpi", "attachmentTuri", "attachmentUURI", "attentionURI", "attachmentUnpi", "attachmentUtpi", "attentionUtRI", "attachableUri", "attachmentupi", "attachmentUnuri", "attachmentTri", "attachmentUuri", "attachmentUrid", "attachmentOuri", "attachmentTURI", "attentionUtri", "attachableUpi", "attachmentUnURI"], "contentUri": ["ContentUris", "contentUtres", "ContentUsrid", "ContentUsuri", "contentuuri", "ContentUsris", "contentUsris", "contentURRI", "messageUtri", "contentURri", "resourceURres", "contenturi", "contentUtri", "contentUtric", "contentuRI", "contentUsuri", "contentUnrid", "contentURuri", "contentUruri", "resourceURI", "contentUriri", "contentSiri", "contentUrri", "contentUrric", "contentSric", "messageUri", "contentUrid", "contentUtrid", "messageUtiri", "contentURres", "contentURI", "ContentUuri", "messageUturi", "contentUturi", "contentures", "contentUris", "resourceUri", "contentUnuri", "resourceURRI", "contentUnris", "contentSuri", "contentUtiri", "resourceURuri", "contentUric", "contentUtRI", "contentUsrid", "resourceURri", "messageUric", "resourceUuri", "resourceUres", "ContentUri", "messageUiri", "messageUuri", "contentSri", "contentUsri", "contentUuri", "contentUnri", "contentUiri", "messageUtric", "contentUres", "ContentUsri", "ContentUrid", "contentUtris"], "file": ["user", "path", "message", "header", "template", "init", "files", "format", "type", "save", "f", "filename", "output", "media", "fp", "dir", "zip", "link", "rule", "image", "source", "le", "page", "picture", "from", "h", "ile", "to", "angle", "tree", "il", "document", "work", "result", "folder", "ca", "FILE", "port", "upload", "entity", "disk", "line", "buffer", "sf", "resource", "content", "local", "base", "create", "play", "name", "db", "channel", "File", "pool", "table"], "in": ["In", "read", "is", "on", "input", "rin", "it", "sql", "al", "ain", "IN", "inn", "and", "l", "inside", "inf", "bin", "ar", " IN", "ins", "source", "from", "inc", "en", "mi", "ic", "up", "io", "ind", "body", "din", "isin", "cin", "con", "i", "gin", " din", "inner", "play", "ini"], "out": ["b", "obj", "put", "ex", "check", "net", "OUT", "ou", "it", "all", "write", "output", "nt", "stable", "oss", "client", "Out", "n", "null", "os", "screen", "to", "flush", "ao", "io", "sys", "outs", "w", "writer", "conv", "OU", "g", "serv", "con", "i", "co", "print", "can", "aos", "auto", "o", "v", "res", "outer"], "intent": ["inv", "activate", "ment", "init", "device", "voice", "automatic", "spirit", "query", "widget", "context", "agent", "express", "verbal", "concept", "ink", "animate", "intention", "wordpress", "entry", "continue", "window", "term", "inst", "venture", "q", "ent", "action", "Activity", "ic", "act", "skill", "method", "alert", "ence", "xml", "initial", "asso", " Intent", "json", "text", "ant", "statement", "prom", "ident", "entity", "condition", "event", "displayText", "communication", "man", "phrase", "complete", "activation", "service", "activity"]}}
{"id1": "1954410", "id2": "16804988", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "label": 0, "substitutes": {"doExecute": ["DoExecExec", "doExecExec", "doEditutes", "doEditute", "doEditExec", "DoExecute", "DoExecutes", "doCommExec", "doExecutes", "doCommutes", "doExecit", "doCommute", "doEditit", "doCommit", "DoExecit"], "mapping": [" mapped", "Mapper", " mappings", "smapper", "smappings", "Mappings", "mappings", "mapper", "smapped", " mapper", "mapped", "Mapped", "smapping", "Mapping"], "form": ["path", "template", "format", " Form", "type", "subject", "f", " FORM", "m", "session", "map", "config", "fc", "app", "forms", "self", "Form", "FORM", " forms", "owner", "sam", "command", "view", "formed", "parent", "raw", "orm"], "request": ["project", "current", "se", "quest", "host", "xml", "report", "post", "upload", "resource", "sw", "user", "Exception", "input", "url", "open", "context", "Upload", "window", "Request", "command", "question", "cont", "order", "message", "application", "instance", "session", "req", "container", "this", "def", "version", "initial", "w", "remote", "template", "http", "store", "QUEST", "query", "address", "_", "first", "reference", "frame", "client", "true", "document", "view", "allow", "parent", "impl", "server", "model", "create", "reset"], "response": ["reply", "message", "ce", "write", "application", "output", "session", "frame", "send", "success", "resp", "xml", "document", "sp", "result", "view", "respond", "report", "re", "connection", "server", "content", "print", "res", "Response", "status"], "errors": [" status", " manager", " messages", " requests", " changes", " logs", " mess", " messenger", " elements", " state", " flash", "Mess", " flashes", " moves", " warnings", " sessions", " error", " statements", " updates", " fails", " storage", " Messages", " states", "ages", " problems", " success", " managers", " steps"], "isMultipart": ["isMultiipare", "isMultifarts", "isMultospare", "isMultipare", "isMultifare", "isMultiIPare", "isMultIPod", "isMultiarts", "isMultiIParts", "isMultiplart", "isMultospart", "isMultiIPart", "isMultiipart", "isMultiipain", "isMultipain", "isMultiplod", "isMultiparts", "isMultIParts", "isMultosparts", "isMultifain", "isMultiipade", "isMultiiparts", "isMultIPart", "isMultiplade", "isMultiart", "isMultIPare", "isMultipade", "isMultIPain", "isMultIPade", "isMultiIPade", "isMultiade", "isMultospain", "isMultipod", "isMultiod", "isMultiipod", "isMultiIPain", "isMultiIPod", "isMultifart", "isMultiplarts"], "mailInstance": [" MailBuilder", " mailinstance", " mailInst", "mailInst", " mailBuilder", " Mailinstance", "flexinstance", " mailance", " MailInstance", " MailInst", "emailInst", "emailBuilder", "emailance", "flexInst", "flexance", "mailinstance", "emailinstance", "emailInstance", "mailance", "mailBuilder", "flexInstance"], "fields": ["headers", "models", "states", "faces", "files", "strings", "links", "modules", "lists", "keys", "tags", "packages", "lights", "users", "properties", "prints", "days", "packs", "forms", "comments", "boxes", "reports", "parts", "groups", "types", "checks", "dates", "balls", "rows", "phones", "plugins", "details", "bits", "locks", "orders", "services", "classes", "field", "frames", "features", "levels", "images", "posts", "sections", "ports", "atts", "relations", "members", "tests", "holders", "lines", "names", "drivers", "objects", "views", "qs", "workers", "flags", "terms", "pages", "rules"], "attachments": ["achensions", "attachitions", "Attachions", "payitions", "acheements", "Attachensions", " attachresses", "achements", "payments", "attments", "attachances", "attensions", "attMENTS", "achions", "acheances", " attachions", "AttachMENTS", " attachitions", "achments", "Attachresses", "attachensions", "achitions", "Attachments", "achMENTS", "attachions", " attachances", "attitions", "acheitions", "attachresses", "achresses", "attachMENTS", "attachements", "Attachitions", " attachements", "payances", "payements"], "items": ["files", "actions", "links", "Items", "keys", "packages", " results", "cases", "reports", "parts", "apps", "groups", "results", "rows", "resources", "phones", " Items", " files", " samples", "orders", "services", "photos", "events", "issues", "ips", "images", "its", "members", "tests", " inputs", "names", "lines", " images", "objects", "qs", "archives", "ids", "pages"], "iter": ["read", "init", "each", "store", "it", "Iter", "li", "altern", "older", "list", "ser", "dir", "reader", "orient", "Iterator", "walker", "test", "tif", "loc", "former", "ator", "oper", "ait", "ter", "coll", "er", "upper", "loop", "cmp", "tr", "result", "ner", "ind", "el", "set", "iner", "its", "writer", "gener", "re", "iterator", "i", "ite", "inner", "inter", "outer", "order", "maker", "ipper"], "item": ["group", "on", "info", "file", "add", "app", "cell", "ix", "image", "area", "xml", "attribute", "element", "spec", "related", "step", "entity", "resource", "other", "name", "status", "ip", "obj", "change", "ex", "or", "url", "zip", "job", "key", "row", "single", "Item", "details", "layer", "json", "mm", "raw", "inner", "order", "att", "local", "instance", "stat", "link", "anything", "record", "entry", "page", "addr", "up", "attr", "initial", "el", "data", "claim", "match", "atom", "template", "store", "it", "type", "rule", "word", "detail", "one", "object", "unit", "er", "event", "internal", "module", "member"], "aux": ["ex", "extra", "foo", "net", "us", "fu", "uf", "mu", "fam", "du", "vers", "AU", "abs", "au", "fuck", "ix", "tx", "ras", "etc", "fx", "uds", "av", "lim", "aff", "af", "fat", "off", "area", "ax", "used", "aim", "eu", "airs", "imp", "aus", "cu", "ux", "ox", "fax", "aw", "pad", "max", "aos", "auto", "buff", "ups", "uff", "pet"], "part": ["person", "group", "half", "and", "add", "parts", "pair", "p", "sp", "tab", "step", "worker", "temp", "admin", "section", "relation", "pod", "format", "PART", "card", "wrapper", "join", "Part", "job", "patch", "primary", "comp", "layer", "mod", "photo", "art", "inner", "sample", "point", "local", "message", "pt", "block", "api", "tmp", "list", "zone", "pos", "top", "html", "peer", "version", "work", "piece", "print", "base", "pet", "component", "pkg", "pre", "party", "tx", "word", "detail", " Part", "object", "bound", "par", " parts", "parent", "pad", "partial", "start", "prefix", "split", "member"], "baos": ["boo", "vaols", "kais", "boOS", "waos", "pooses", "tais", "tao", "booss", "waoss", "bais", "poOS", "baols", "bioses", "pois", "booses", "waols", "poos", "waOs", "caOS", "taops", "taOs", "vaOs", "baOs", "taoss", "caols", "caos", "baoss", "cao", "bio", "biOS", "vaos", "caOs", "poops", "baops", "kaos", "bios", "vaoss", "taos", "baoses", "poo", "boos", "bao", "baOS", "pooss", "boOs", "kaoss", "caoss", "kaops"], "body": ["message", "header", "template", "format", "display", "title", "note", "pass", "binary", "subject", "output", "shell", "ODY", "description", "file", "t", "head", "send", "summary", "size", "html", "detail", "null", "scroll", "layout", "tail", "tree", "ody", "loop", "default", "json", "bill", "text", "business", "report", "post", "port", "log", "mail", "buffer", "content", "foot", "base", "data", "name", "rel", "comment", "plain", "Body"], "preferencesInstance": ["preffiesImpl", "prefancesObj", "prefferencesObj", "prefancesImpl", "prefferencesinstance", "prefiesImpl", "preferencesinstance", "preferencesImpl", "preffiesObj", "prefutesObj", "preferencesObj", "preffiesInstance", "prefutesinstance", "preffiesinstance", "prefferencesInstance", "prefutesImpl", "prefiesinstance", "prefferencesImpl", "prefancesInstance", "prefiesObj", "prefutesInstance", "prefancesinstance", "prefiesInstance"]}}
{"id1": "11477906", "id2": "13499897", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["readdefaultSetting", "loadFAULTValues", "loaddefaultSettings", "loaddefaultsettings", "loaddefaultSetting", "readDefaultValues", "readdefaultValues", "loadDefaultSetting", "readdefaultsettings", "loaddefaultValues", "readDefaultSetting", "readDefaultsettings", "loadDefaultsettings", "readdefaultSettings", "loadFAULTsettings", "readDefaultSettings", "loadDefaultValues", "loadFAULTSetting", "loadFAULTSettings"], "configFileName": ["conffileName", "configStreamName", "confFilenamePath", "conffilePath", "confFileNames", "confFilenameName", "confFilename", "configfileName", "configfileNames", "configStreamname", "confFilenamename", "configFILEPath", "confFilenameLocation", "configPagename", "configFilenameLocation", "configFilename", "configStreamPath", "configFILELocation", "configFILEName", "configPageName", "configPagePath", "confFileLocation", "confFileName", "configPageNames", "configFileLocation", "configfilename", "configFilenamename", "confFilePath", "conffilename", "configFILEname", "conffileNames", "configFileNames", "configFilenamePath", "configStreamLocation", "configFilenameNames", "configFilenameName", "configfilePath", "configFilePath"], "in": ["In", "ls", "user", "ad", "check", "is", "init", "or", "on", "input", "rin", "it", "al", "id", "info", "m", "ain", "IN", "ma", "inn", "t", "l", "inf", "bin", "ai", "ar", "ins", "run", "source", "from", "mc", "n", "en", "mi", "ze", "ini", "up", "ind", "im", "din", "isin", "e", "re", "cin", "con", "i", "gin", " din", "inner", "o", "ro", "doc"], "out": ["over", "update", "file", "t", "de", "ins", "ent", "not", "ne", "outs", "writer", "OU", "port", "log", "con", "co", "v", "o", "auto", "ot", "obj", "user", "ex", "init", "or", "ou", "all", "des", "nt", "ion", "os", "cn", "handle", "conv", "raw", "read", "check", "at", "net", "ing", "m", "une", "Out", "n", "en", "gc", "off", "are", "up", "io", "sys", "ind", "w", "aos", "res", "OUT", "store", "cache", "it", "output", "oss", "client", "gt", "null", "to", "copy", "ge", "po", "server", "can"]}}
{"id1": "14188043", "id2": "3197876", "code1": "    public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException {\n        AQUtility.debug(\"net\", urlPath);\n        URL url = new URL(urlPath);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setConnectTimeout(NET_TIMEOUT);\n        int code = connection.getResponseCode();\n        if (code == 307 && retry) {\n            String redirect = connection.getHeaderField(\"Location\");\n            return openHttpResult(redirect, false);\n        }\n        if (code == -1 && retry) {\n            return openHttpResult(urlPath, false);\n        }\n        AQUtility.debug(\"response\", code);\n        if (code == -1 || code < 200 || code >= 300) {\n            throw new IOException();\n        }\n        byte[] result = AQUtility.toBytes(connection.getInputStream());\n        return result;\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"openHttpResult": ["openHttpMessage", "getHttpRes", "openQueryRes", "openQueryResult", "getHttpResult", "OpenHTTPResponse", "openQueryResults", "OpenHTTPMessage", "getHTTPResponse", "openUrlResponse", "OpenHttpRes", "openhttpResult", "openHttpResults", "openHttpRes", "openHTTPResults", "openHTTPResponse", "OpenHTTPResult", "getHTTPRes", "openHTTPRes", "openHTTPResult", "openQueryResponse", "getHttpResults", "openhttpRes", "OpenHTTPRes", "openhttpResults", "OpenHttpResponse", "openUrlRes", "OpenHttpMessage", "getHttpResponse", "OpenHttpResults", "openUrlResult", "openHttpResponse", "openHTTPMessage", "getHTTPResults", "openUrlResults", "OpenHttpResult", "getHTTPResult", "OpenHTTPResults", "openUrlMessage", "openhttpMessage", "openhttpResponse"], "urlPath": ["urlName", "UrlFile", "xmlFile", "pathStr", "URLPath", "nlP", "urlString", "nlpath", "UrlString", " urlP", "dlStr", "UrlPath", " urlDir", "URLCh", "pathFile", "xmlStr", "urlP", "dlPath", "UrlName", "xmlPath", "URLDir", "urlDir", "urlFile", "URLString", "pathPath", "dlFile", "UrlP", " urlString", "Urlpath", "URLName", "urlCh", " urlCh", "nlFile", "UrlId", "UrlDir", "URLId", " urlId", " urlpath", "urlStr", " urlFile", "nlPath", " urlName", "UrlCh", "pathpath", "dlpath", "xmlpath", "urlId", "urlpath"], "retry": ["rettry", "redric", "retric", "attrain", "Retrying", "retrain", "retried", "pretried", "attry", "redrier", "terried", "terry", "tric", " retrying", "rery", "Retry", "retrying", "terrain", "rerying", "attrying", " rettry", "Retri", "attried", "pretric", "trier", "redwrite", "retwrite", "redry", "pretrain", "pretrier", "retri", "Rettry", "reri", "terrying", "pretrying", "twrite", "pretry", " retri", "retrier", "pretwrite"], "url": ["ls", "user", "sl", "dl", "http", "URL", "r", "open", "li", "file", "l", "ur", "link", "str", "https", "job", "loader", "web", "org", "nl", "loc", "uri", "char", "rl", "il", "get", "log", "Url", "pl", "conn", "ssl", "ul", "location", "base", "ll", "mount", "service", "www"], "connection": ["operation", "message", "online", "generation", "creator", "Connection", "http", "number", "application", "open", "subject", "context", "translation", "database", "ion", "description", "session", "l", "link", "network", "client", "directory", "entry", "connected", "c", "character", "builder", "close", "created", "uri", "established", "computer", "to", "cone", "io", "nc", "command", "set", "socket", "position", "using", "statement", "writer", "city", "usage", "controller", "conn", "con", "condition", "resource", "server", "communication", "creation", "pointer", "create", "response", "connect", "channel", "relation"], "code": ["change", "message", "check", "ce", "cd", "number", "component", "time", "id", "type", "force", "error", "currency", "sec", "coe", "zip", "count", "zone", "ode", "coded", "se", "rc", "success", "cc", "mode", "test", "size", "c", "zero", "entry", "rate", "x", "one", "page", "a", "go", "close", "xxx", "ord", "ct", "num", "cycle", "Code", "ne", "nc", "state", "sequence", "length", "desc", "ch", "dec", "cod", "ie", "codes", "e", "controller", "cont", "co", "level", "now", "create", "cast", "name", "status", "cause", "xx", "call"], "redirect": ["redistant", "regir", "promir", "redir", "promirect", "promistant", "Redirect", "predir", "regirection", "Redirection", "Redistant", "predirect", " redir", "predistant", "Redir", "Reduction", "predirection", "reduction", "redirection", "promirection", "regirect", " reduction", " redirection", "reguction"], "result": ["message", "transform", "Result", "match", "cert", "value", "out", "r", "output", "description", "request", "currency", "params", "success", "proc", "true", "test", "answer", "feature", "meg", "memory", "results", "reason", "root", "mask", "password", "command", "sequence", "length", "report", "ret", "process", "buffer", "date", "total", "res", "profile", "other", "data", "comment", "complete", "table", "cup", "vector"]}}
{"id1": "17202158", "id2": "8328527", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["readLineID", "readObjectID", "readLineNames", "readZoneIDS", "findZoneID", "readLineIDs", "readLocalIDS", "findZoneIDs", "readLineIDS", "findLocalNames", "findLocalIDS", "readObjectIDs", "readLocalID", "readLocalNames", "readObjectNames", "findZoneNames", "readZoneID", "readObjectIDS", "findLocalID", "readLocalIDs", "findZoneIDS", "findLocalIDs", "readZoneNames"], "zoneFileName": ["zoneDirName", "zoneFilenameSpec", "zoneFolderPath", "zonefileSpec", " zoneFileChain", "zoneFilesPath", "zoneFileFilename", "zoneFILEChain", "ZoneFileFilename", "ZoneFileSpec", "zonefileNames", "zoneFolderFilename", "zoneFileChain", " zonefileName", "zoneDirPath", " zoneFilePath", " zoneFileNames", "zonefileSource", "ZoneFilePath", "ZonefileType", " zonefileChain", "zonefileType", "ZonefileSpec", "zoneFolderName", "zoneFolderType", "zonefileFilename", "zonefilePath", "ZonefileSource", "zoneFILEType", "zoneFilePath", "zoneFILEPath", "zoneFILENames", "zoneDirSource", "zoneFILEName", "ZonefileFilename", "zoneFileType", "zonefileChain", "zoneFilenameName", "zoneFileSource", "zoneFileSpec", "ZoneFileName", " zonefilePath", "zoneFileNames", "zoneFilenamePath", "zoneFilenameSource", "zoneFilesChain", "ZoneFileType", "zoneFilesName", "zoneFilesNames", "ZonefilePath", "zonefileName", "ZoneFileSource", "zoneDirSpec", " zonefileNames", "zoneFILEFilename", "ZonefileName"], "zoneids": ["tzIDs", "zonelines", "zoneoids", "zIDs", "zoneIDs", "znames", "ziplines", " zonenaires", "zipnames", " zoneoids", " zonenames", "zaoids", "zaIDs", "zids", "zonenames", "tzids", " zoneuploads", "zcodes", " zonelines", "zipids", "elementuploads", "zonenaires", "zoneuploads", "zaids", "elementids", "zuploads", "zipIDs", " zoneIDs", " zonecodes", "zlines", "tzoids", "elementlines", "elementcodes", "zonecodes", "zanaires", "tznaires"], "url": ["ls", "user", "dl", "http", "URL", "lr", "open", "r", "f", "file", "l", "ur", "str", "browser", "cl", "loader", "web", "nl", "loc", "this", "q", "lb", "uri", "char", "rl", "result", "ref", "ret", "log", "Url", "build", "ssl", "resource", "ul", "bel", "base", "name", "ll", "rel", "mount", "sl"], "lnr": ["lendr", "lenr", "linr", "lndr", "lnR", "nlR", "cncr", "lenn", "lnp", "linrar", "lncr", "nlp", "olnn", "nldr", "lnn", "cnp", "olnR", "nlrar", "lenR", "nlr", "nlcr", "cnr", "lnrar", "olnr", "lincr", "linp", "cnrar", "nln", "olndr"], "line": ["message", "LINE", "block", "header", "liner", "range", "online", "day", "net", "display", "number", "ln", "file", "stroke", "frame", "ine", "l", "string", "eline", "cell", "link", "inline", "lin", "entry", "nl", "continue", "word", "stream", "row", "next", "page", "le", "section", "Line", "char", "part", "ge", "sequence", "text", "style", "e", "log", "chain", "print", "code", "sample", "comment", "phrase", "lane", "point", "normal"]}}
{"id1": "21979717", "id2": "8754809", "code1": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 0, "substitutes": {"upload": [" go", "save", " confirm", " restore", " commit", " sort", " load", " login", " input", "submit", " update", " delete", " reload", " work", " insert", " install", " change", " press", "ction", " dump", " dispose", " move", " paste", " file", "execute", " store", " take"], "fileResult": ["FILEStatus", "fileRequest", "FileResults", "FILEReturn", "reportResult", "reportRequest", "fileStatus", "fileResults", "reportStatus", "FileResult", "fileReturn", "FILEResult", " fileStatus", " fileReturn", "FileReturn", "reportResults", "FileStatus", "FILEResults", " fileResults", "FileRequest", " fileRequest"], "in": ["In", "is", "init", "on", "input", "rin", "it", "win", "r", "file", "IN", "inn", "l", "inside", "inf", "bin", "lock", " IN", "ins", "n", "inc", "from", "p", "en", "up", "io", "ind", "st", "body", "din", "isin", "get", "cin", "conn", "i", "gin", " din", "inner", "doc", "un"], "url": ["ls", "dl", "net", "http", "URL", "r", "open", "f", "file", "abs", "l", "ur", "gl", "str", "https", "browser", "client", "web", "nl", "arl", "gc", "char", "xml", "www", "console", "ref", "conv", "get", "log", "Url", "conn", "ssl", "ul", "bel", "atl", "name", "ll", "pl", "channel", "sl"], "con": ["com", "Conn", "cert", "http", "conf", "ver", "coin", "open", "comm", "func", "ion", "ln", "ain", "Con", "bean", "fc", "cond", "pc", "cos", "col", "pos", "client", "cl", "cat", "c", "gate", "cp", "en", "cn", "cmd", "don", "canon", "fac", "act", "cm", "soc", "const", "cal", "CON", "conv", "dial", "re", "sub", "ctrl", "conn", "connection", "cont", "co", "ran", "pen", "cons", "cf", "cur", "can", "syn", "create", "connect", "un", "call"], "out": ["b", "obj", "ex", "at", "or", "OUT", "net", "ou", "conf", "output", "ion", "t", "cos", "oss", "pos", "client", "Out", "n", "this", "null", "os", "en", "to", "io", "ne", "sys", "outs", "w", "conv", "OU", "po", "conn", "i", "co", "sum", "aos", "can", "o", "auto", "outer", "vol", "un"], "in2": ["IN2", "IN3", "inner3", "din2", "inner02", "out1", "win1", "out02", "out4", "out2", "inner2", "out3", "in1", "IN02", " in1", "din1", "in4", "win2", "din4", "inner1", "IN1", "in3", " in3", "win3", " in4", "in02"], "buf": ["bytes", "block", "uf", "cap", "tmp", "cfg", "pkg", "rb", "str", "queue", "cb", "cat", "Buffer", "br", "orig", "cv", "img", "arr", "cp", "cmd", "box", "batch", "bag", "bar", "cam", "seq", "tab", "conv", "fg", "aka", "Buff", "log", "buffer", "vec", "emb", "cf", "cur", "mem", "buff", "data", "db", "var", "pb"], "bytesRead": ["secondsread", "tesCount", "bytesWrite", "bytesRun", " bytesCount", "BytesWritten", "tesWrite", "cellsRun", "secondsRead", " bytesread", "rowsread", " bytesRun", " bytesLoad", "bytesNeed", "rowsLoad", "tesWritten", "bytesLoad", "cellsLoad", " bytesWrite", "rowsRun", "rowsNeed", "rowsRead", "rowsWrite", "secondsNeed", "secondsWrite", " bytesWritten", "BytesCount", "bytesCount", "bytesread", "BytesRead", "cellsWrite", "cellsRead", " bytesNeed", "bytesWritten", "BytesWrite", "tesRead"]}}
{"id1": "1122585", "id2": "18358467", "code1": "    private String copyImageFile(String urlString, String filePath) {\n        FileOutputStream destination = null;\n        File destination_file = null;\n        String inLine;\n        String dest_name = \"\";\n        byte[] buffer;\n        int bytes_read;\n        int last_offset = 0;\n        int offset = 0;\n        InputStream imageFile = null;\n        try {\n            URL url = new URL(urlString);\n            imageFile = url.openStream();\n            dest_name = url.getFile();\n            offset = 0;\n            last_offset = 0;\n            offset = dest_name.indexOf('/', offset + 1);\n            while (offset > -1) {\n                last_offset = offset + 1;\n                offset = dest_name.indexOf('/', offset + 1);\n            }\n            dest_name = filePath + File.separator + dest_name.substring(last_offset);\n            destination_file = new File(dest_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    if (!destination_file.canWrite()) {\n                        System.out.println(\"FileCopy: destination \" + \"file is unwriteable: \" + dest_name);\n                    }\n                    System.out.println(\"File \" + dest_name + \" already exists. File will be overwritten.\");\n                } else {\n                    System.out.println(\"FileCopy: destination \" + \"is not a file: \" + dest_name);\n                }\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                }\n                if (!parentdir.canWrite()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                }\n            }\n            destination = new FileOutputStream(dest_name);\n            buffer = new byte[1024];\n            while (true) {\n                bytes_read = imageFile.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(\"Bad URL \" + urlString);\n        } catch (IOException ex) {\n            System.out.println(\" IO error: \" + ex.getMessage());\n        } finally {\n            if (imageFile != null) {\n                try {\n                    imageFile.close();\n                } catch (IOException e) {\n                }\n            }\n            if (destination != null) {\n                try {\n                    destination.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return (dest_name);\n    }\n", "code2": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyImageFile": ["cpimagePhoto", "cpImagefile", "copyImagePhoto", "copyImagesPhoto", "cpimageHeader", "copyItemImageHeader", "copyImagefile", "cpImageHeader", "copyImagesfile", "cpImagePhoto", "copyItemImagefile", "cpimagefile", "copyItemImagePhoto", "copyimagePhoto", "cpImageFile", "copyImagesHeader", "copyimagefile", "copyimageFile", "cpimageFile", "copyImageHeader", "copyImagesFile", "copyItemImageFile", "copyimageHeader"], "urlString": [" urlRest", "urlService", "uristring", "imageString", "UrlString", "uriStr", "uriRest", " urlChain", "imageStr", " urlService", "UrlService", "uriService", "urlstring", "urlChain", "uriString", "imagestring", "linkStr", "imageRest", "UrlRest", "urlRest", "linkstring", "urlStr", "uriChain", "linkString", "linkRest", "UrlChain"], "filePath": ["Filepath", " filepath", "givenStream", "resourcePath", "filepath", "filePATH", "fileStream", "resourcePATH", "resourceStream", "FileName", "givenpath", " fileName", " FileName", "outputPATH", "givenPath", "FilePath", "givenPATH", "outputStream", "resourcepath", "fileName", "outputPath", " filePATH", " FilePATH", "outputpath", "FilePATH", " Filepath", " FilePath"], "destination": ["portinated", " destachment", "destignment", "identension", " destificate", "srcignment", "destachment", "commentificate", "identinated", "terminachment", "destinate", "terminository", " destaration", "combinator", "methodository", "delinated", "portinator", "Destination", "identination", "terminaration", "srcacement", " destacement", "identinator", "destository", "terminination", "destribution", "srcaration", "contension", "portension", "delinator", "commentination", " destignment", "combination", "Destation", "methodachment", "combinity", "Destension", "Destinator", " destinator", "destinated", "continate", "destension", "terminignment", "contination", "destinator", "Destinity", "delribution", "targetribution", "destaration", "destificate", "combation", "targetinator", "targetination", "portination", "destacement", " destinate", " destension", "portinity", "termininator", "srcination", "srcinator", "methodinator", " destribution", " destinated", "identinate", "Destinate", "delination", "portation", "destinity", "srcinate", " destository", "destation", "targetinated", "continator", "commentinate", "methodination", "srcificate", "commentacement"], "destination_file": ["destATION____no", "destination____file", "destinator_name", "destociation_dir", "destination___full", "destination_dir", "destATION_no", "destATION_name", "destination_FILE", "destATION____entity", "destination_table", "destinator_port", "destinator___name", "destination_ile", "destination_port", "destination____name", "destation_name", "destination____entity", "destination___ile", "destination___name", "destation_File", "destATION_entity", "destociation_file", "destination_File", "destination_entity", "destATION_file", "destociation_ile", "destinator_full", "destinator___ile", "destination__ile", "destination__file", "destinator_table", "destation_file", "destination_library", "destociation_library", "destinator_file", "destination_no", "destination__full", "destinator_ile", "destATION____name", "destination_full", "destinator_File", "destination__name", "destinator___file", "destinator___full", "destination____no", "destination_name", "destinator_dir", "destination___file", "destation_ile", "destinator_FILE", "destATION____file"], "inLine": [" inline", " inString", "inline", "Inline", " inliner", "binline", "Inliner", "inliner", "binLine", "InLine", "InString", "binString", "binliner", "inString"], "dest_name": ["Dest_name", "Dest_description", " dest_lock", "destJname", "destationnames", "dest_NAME", " dest_path", " dest_file", "Dest_Name", "destinationfilename", "dest_path", "img_name", "destopsan", " dest_filename", "destinalfile", "desttname", "src_file", "destinalword", "dest_term", " dest__NAME", "dest_names", "desttkey", "destDname", "dest_san", "destinalma", "Dest_san", "destDdescription", "destnfile", "dest_key", "destJterm", "destopdescription", "destJsize", "destinationfile", "dest_data", "destationName", "desttName", "destDsan", "destndescription", "destnname", " dest_call", "dest_word", "dest__ame", "dest_file", " dest_ame", "dest_Name", "dest_system", "dest_filename", "dest__NAME", "ident_entry", "Dest_system", " dest_term", "destinationname", " dest_NAME", "destinationName", "dest_size", "dest__Name", "dest_lock", "dest_description", "src_name", " dest__Name", "ident_word", "destopname", "img_Name", "decl_file", "dest_entry", "dest__filename", "destinalname", " dest_size", " dest__name", "dest_ame", "Dest_key", "Dest_file", "decl_ma", "destationcall", "img_data", "ident_name", "img_file", "destJNAME", "src_Name", "destationname", "desttsystem", "dest_ma", "src_filename", " dest_Name", "decl_word", "dest_call", "dest__name", " dest__filename", "decl_name", " dest_names"], "buffer": ["b", "read", "message", "block", "iter", "channel", "function", "device", "value", "parse", "cache", "update", "binary", "FFER", "address", "database", "paste", "frame", "append", "queue", "feed", "memory", "window", "stream", "Buffer", "row", "page", "source", "batch", "char", "password", "document", "command", "result", "bar", "sequence", "length", "text", "stack", "shape", "buf", "raw", "base", "sample", "buff", "data", "phrase", "comment", "table", "variable"], "bytes_read": ["bytes_reading", "bytes2Read", "Bytes_send", " bytes_readable", "Bytes_mix", "bytes_readable", " bytes2reading", "bytes2readable", " bytes2Read", "bytes67send", "bytes67mix", "bytes_send", " bytes_length", " bytes_write", "bytes2length", "bytes_count", " bytes_count", " bytes2readable", "Bytes_read", "bytes_length", "bytes2read", " bytes2read", "bytes_write", "bytes67read", " bytes_reading", "bytes_mix", "bytes2reading", " bytes_Read", "bytes_Read", "bytes67write", "Bytes_write"], "last_offset": ["last__offset", "last__name", "last___Offset", "last_name", "last_Offset", " last_Offset", "last___position", "last_index", "last__Offset", "Last_page", " last_index", "last_pointer", "last__index", "last_position", "last_page", " last_start", "last_flag", " last_name", "Last_Offset", "Last_flag", "last___offset", "last___pointer", "Last_position", "Last_pointer", "Last_offset", "last_start"], "offset": ["article", "OFF", "amount", "always", "inline", "after", "size", "origin", "offs", "next", "batch", "offer", "attribute", "element", "set", "unsigned", "step", "auto", "other", "name", "volume", "section", "alias", "operation", "shift", "ace", "append", "Offset", "padding", "key", "window", "end", "et", "inner", "pointer", "outer", "point", "order", "table", "slot", "empty", "error", "original", "pos", "entry", "off", "addr", "field", "length", "option", "iterator", "location", "timeout", "index", "store", "component", "type", "associated", "address", "output", "onet", "tile", "frame", "left", "alt", "mask", "scroll", "part", "bound", "position", "no", "pad", "seek", "start", "skip", "prefix", "reset"], "imageFile": ["messageReader", "photofile", "messageStream", " imagePlace", " imageReader", "mediafile", "imageReader", "pictureStream", "ImageFile", "mediaStream", "photoStream", "photoFile", "picturePlace", "pictureFile", "ImagePlace", "imagePlace", " imageSourceFile", " imageStream", "photoReader", "imagefile", "imageStream", "picturefile", "imageSourceFile", "messagefile", "Imagefile", "mediaSourceFile", "messageFile", "ImageStream", " imagefile", "ImageSourceFile", "mediaFile"], "url": ["b", "dl", "http", "URL", "open", "r", "api", "f", "address", "abs", "l", "ur", "gl", "link", "str", "browser", "google", "web", "html", "nl", "image", "hl", "q", "uri", "up", "github", "rl", "char", "gif", "get", "mail", "Url", "re", "build", "ml", "impl", "ssl", "resource", "ul", "bel", "base", "rel", "ll", "mount", "sl"], "parentdir": ["parentlib", " parentlib", "parentfolder", " parentdict", "rootfolder", "childdiv", "parentDir", "parenfolder", "rootir", "tmpdict", " parentdirectory", "Parentdir", "parenir", "rootdir", "tmpdirectory", "Parentdirectory", "ParentDir", "parentdict", "tmpDir", "childdirectory", " parentDir", "parendiv", "parentir", "childDir", "parentdiv", "childir", "rootdiv", "childfolder", "Parentdict", "parentdirectory", "childlib", "parendir", "Parentlib", "tmpdir", "childdir"]}}
{"id1": "10361370", "id2": "23677128", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "\tpublic FTPClient sample3a(String ftpserver, int ftpport, String proxyserver, int proxyport, String username, String password) throws SocketException, IOException {\n\t\tFTPHTTPClient ftpClient = new FTPHTTPClient(proxyserver, proxyport);\n\t\tftpClient.connect(ftpserver, ftpport);\n\t\tftpClient.login(username, password);\n\t\treturn ftpClient;\n\t}\n", "label": 0, "substitutes": {"hash": ["message", "match", "header", "check", "sign", "update", "array", "ash", "ashes", "test", "html", "key", "h", "filter", "handle", "version", "password", "attribute", "crypt", "Hash", "render", "sum", "print", "code", "profile", "tag", "index"], "saltBefore": ["saltStart", "sadePrevious", " sALTBefore", "SALTBefore", "sALTStart", "SaltPrevious", "sashStart", "sALTPrevious", " saltStart", "sashBefore", "sadeStart", "saveBefore", "SaltAfter", "sadeBefore", "sadeAfter", "SALTAfter", "savePrevious", "SALTPrevious", "sALTAfter", "saveAfter", "sashAfter", "SaltBefore", " sALTStart", "saltPrevious", " sALTAfter", "sALTBefore"], "content": ["message", "path", "value", "format", "title", "input", "url", "subject", "output", "translation", "media", "file", "present", "config", "any", "current", "description", "Content", "string", "str", "record", "html", "c", "reason", "image", "word", "source", "null", "txt", "object", "expression", "xml", "password", "document", "initial", "json", "sequence", "text", "body", "entity", "license", "raw", "cont", "code", "example", "data", "comment", "time"], "saltAfter": ["valtBefore", "SALTBefore", "sintafter", "sintBefore", "vintBody", "soltAfter", "vintafter", "saltafter", "valtAfter", "sadeResult", "soltBefore", "vintAfter", "sintAfter", "SALTPost", "valtBody", "vintBefore", "sALTPost", "saveBefore", "SALTResult", "sALTafter", "soltResult", "saveBody", "SaltAfter", "sadeBefore", "sadeAfter", "soltPost", "SALTAfter", "sALTAfter", "saveAfter", "SaltPost", "SaltResult", "saltResult", "sintBody", "SaltBefore", "saltPost", "valtafter", "saveafter", "sALTBody", "sALTResult", "sALTBefore", "saltBody", "sadePost"], "repeatedHashingCount": ["repeatedRashingCount", "repeatedRashingCode", "repeatedHashCount", "repeatedHASHLength", "repeatedHASHcount", "repeatedHashingLength", "repeatedHashesCode", "repeatedRashingcount", "repeatedHashCounter", "repeatedRashingCC", "repeatedHASHCounter", "repeatedHachingCode", "repeatedRashCount", "repeatedHASHCount", "repeatedHashLength", "repeatedRashesLength", "repeatedRashescount", "repeatedHashesCC", "repeatedHashCC", "repeatedHachingLength", "repeatedHashCode", "repeatedHashingCC", "repeatedHachingCC", "repeatedRashesCount", "repeatedRashesCounter", "repeatedRashingCounter", "repeatedRashingLength", "repeatedRashLength", "repeatedHachingCount", "repeatedRashCode", "repeatedHashingCode", "repeatedHashesLength", "repeatedHashesCounter", "repeatedRashCC", "repeatedHashingcount", "repeatedHashingCounter", "repeatedHashescount", "repeatedHashesCount", "repeatedHashcount"], "digest": ["Dighash", "Digum", " Digest", "digEST", "descest", "fifency", " digitude", "algEST", " Digester", "Digist", "diagnum", "dester", "fifitude", "comphash", "commested", "Digse", "designester", "designested", "algest", "descse", "Digute", " digum", "hashute", "diagnist", "fingerEST", "fingerest", "hashest", "digency", "Digester", "fingeresting", "mdse", "compute", "designesting", "mdester", "compest", "Digests", "extester", "debugest", "argested", "digested", "dert", "digitude", "fifest", " dighest", "extest", "argester", "commse", "printhest", "extse", "commest", "Digested", "dfested", "digute", "dest", "dfester", " digEST", "descity", "digester", "debugEST", "digity", "dested", "hashEST", "printest", "compEST", "printEST", "diagnests", "Digest", "diagnest", "algester", "commity", "argest", "digests", "digist", "debugency", "debugitude", " digert", " digist", " digesting", "DigEST", "mdested", "dfesting", "descested", "dighest", " digse", " Digested", "digum", "dfest", "argEST", "algested", "mdest", " Digert", "hashhash", "digert", "printesting", "dse", "dighash", " digency", " digests", "designest", "digesting", "extested", "fifEST", "fingerhest", " digester", " digity", "digse", " digested"], "digestLength": [" digestData", " digestType", "descesterLength", "digistLength", " digestLen", "digestedOffset", "digistLen", "digestedlength", "descesterlength", "digseLen", " digesterLength", "digesterlength", "digesterType", "digestLen", " digesterData", "digestlength", " digesterLen", "digestedData", "descestLen", "descestlength", "digestedType", "digesterLen", "digesterLength", "digesterData", "digistType", "digesterOffset", "descesterLen", "digestedLength", "digestData", "digistData", "digseLength", "digestedLen", "descesterOffset", "digseOffset", "digestOffset", "descestOffset", "descestLength", "digestType", " digesterType", "digselength"], "i": ["ex", "iter", "is", "init", "my", "gi", "qi", "ski", "it", "uu", "sql", "xi", "ci", "li", "err", "ms", "I", "m", "z", "di", "ai", "ix", "iq", "client", "gu", "x", "bi", "n", "ii", "q", "multi", "u", "mi", "uri", "ic", "in", "batch", "ind", "y", "im", "phi", "iu", "sim", "me", "si", "print", "v", "ei", "pi", "ti", "cli", "j", "ui", "index", "ini", "ip", "mill"]}}
{"id1": "14567939", "id2": "1097146", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"baseHash": ["BaseHash", "basehash", "BaseKey", "Basehash", "baseSign", "baseKey", "basicHash", "BaseSign", "basicKey", " baseSign", "basichash", " basehash", "basicSign", " baseKey"], "name": ["person", "user", "alias", "title", "id", "search", "info", "address", "author", "login", "current", "common", "key", "Name", "john", "run", "domain", "word", "term", "family", "n", "username", "initial", "default", "named", "ame", "parent", "ident", "NAME", "names", "account", "create", "hash", "admin", "prefix", "order", "local", "table"], "password": ["user", "message", "remember", "sword", "auth", "value", "pass", "Password", "wd", "database", "login", "description", "session", "padding", "entry", "key", "word", "picture", "username", "attribute", "token", "command", "shadow", "crypt", "reset", "hash", "phrase", "prefix", "hello", "secret", "restricted"], "digest": ["decest", "dest", " Diger", "mdEST", "Digester", "decgest", "Diger", "Digum", " Digest", "digester", "mdse", "digEST", "descgest", "dested", " Digend", "descest", "displayEST", "displayested", "diggest", "mdester", "digend", "displayest", "displayum", "digum", " Digester", "mdest", "digested", "Digest", " digend", "diger", "descester", " diger", "Digse", "Diggest", "mdgest", "displayester", "descse", "decester", "dEST", "decested", " digum", "DigEST", "mdested", "descested", "Digested", "Digend", " digester", "digse", "dgest", " digested"]}}
{"id1": "22708533", "id2": "17792212", "code1": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"insertDocumentToURL": [" copyDocumentToURI", " copyDocumentToFile", " copyDocumentToUrl", " copydocumentToURL", " copydocumenttoUrl", " copydocumentToURI", " copydocumenttoFile", " copyDocumentToURL", " copyDocumenttoURI", " copydocumenttoURL", " copydocumentToUrl", " copyDocumentAsURI", " copyDocumenttoUrl", " copyDocumentAsURL", " copydocumenttoURI", " copyDocumenttoURL", " copyDocumenttoFile", " copydocumentToFile", " copyDocumentAsFile", " copyDocumentFromURL", " copyDocumentAsUrl", " copyDocumentFromFile", " copyDocumentFromURI", " copyDocumentFromUrl"], "file": ["message", "path", "place", "check", "full", "title", "where", "input", "f", "filename", "doc", "string", "origin", "rule", "image", "source", "le", "from", "ile", "document", "default", "valid", "work", "command", "fil", "attribute", "FILE", "log", "resource", "base", "sample", "data", "name", "File", "local", "table"], "target": ["dest", "alias", "template", "component", "update", "home", "select", "project", "join", "Target", "link", "back", "ARGET", "top", "origin", "root", "arg", "window", "this", "source", "scope", "host", "to", "pattern", "layout", "result", "valid", "view", "remote", "print", "location", "base", "arget", "replace", "rel", "local", "table"], "is": ["cs", "nis", "\u00eds", "us", "ics", "isl", "it", "vis", "fs", "dis", "ys", "iso", "ms", "vs", "ci", "abs", "bis", "IS", "tis", "isc", "oss", "lis", "ri", "ir", "ists", "ins", "rs", "ns", "iss", "xs", "bits", "ris", "mi", "bs", "Is", "isf", "est", "obs", "isi", "im", "its", "has", "isin", "ios", "ais", "i", "sis", "si", "isal", "mis", "ism", "ains", "isa", "ois", "iris", "mos", "es", "ims", "ip"], "os": ["oos", "dos", "OS", "osa", "css", "us", "oses", "acs", "ts", "out", "ones", "des", "ms", "oes", "ows", "bis", "ols", "los", "cos", "oss", "pos", "oS", "Os", "bos", "ops", "ins", "tes", "osi", "ose", "bs", "asis", "ost", "io", "mot", "sys", "mes", "uts", "oin", "eps", "ios", "es", "ox", "ori", "none", "ps", "ks", "ss", "ros", "nos", "oa", "et", "aos", "o", "ot", "mos", "obs", "ns"], "url": ["ls", "user", "cert", "net", "http", "URL", "open", "f", "r", "address", "t", "l", "ur", "link", "str", "https", "client", "job", "web", "nl", "n", "domain", "host", "cp", "uri", "char", "Url", "re", "conn", "con", "ssl", "ul", "location", "rel", "ll", "name", "mount", "channel", "service"], "connection": ["generation", "Connection", "net", "number", "application", "open", "database", "ion", "description", "session", "reference", "opening", "t", "l", "link", "network", "client", "entry", "character", "c", "n", "still", "close", "uri", "established", "cone", " Connection", "document", "command", "result", "position", "using", "city", "con", "conn", "condition", "resource", "creation", "communication", "pointer", "response", "connect", "channel", "service", "relation", "closure"]}}
{"id1": "13499897", "id2": "20735941", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"CopyFile": ["DownloadDir", "Transferfile", " Copyfile", "Downloadfile", "DownloadPath", "CopyPath", "DownloadFile", "TransferDir", " CopyDir", "TransferPath", "TransferFile", " CopyPath", "Copyfile", "CopyDir"], "sourcefile": ["starturl", " sourcepath", "sourceattribute", "ourcefile", "Sourcefile", "startpath", "srckey", "ourceattribute", " sourceFile", "sourceFile", "styleattribute", "styleFile", "sourcepath", "stylekey", "startfile", "srcattribute", "startFile", "sourcekey", "ourceFile", "ourcekey", "srcFile", "Sourcepath", "srcfile", "sourceurl", " sourceurl", "SourceFile", "stylefile", "Sourceurl"], "destfile": ["DestFile", "tempfile", "sourcefilename", "resultfilename", "destpath", "tempfilename", " destFile", "tempFILE", "masterFile", "Destile", "desturl", "masterfile", "temppath", "resultFile", "masterpath", "destFILE", "srcpath", "masterFILE", "sourceFile", "sourceile", "resultfile", "sourcepath", "resultpath", " destname", "sourcename", "destport", "Destfilename", "Destfile", "tempFile", " destile", " desturl", "destfilename", " destpath", "destname", "Desturl", " destport", " destfilename", "srcFile", "srcport", "destFile", "Destpath", "srcfile", "sourceurl", "Destname", "sourceport", "destile", " destFILE"], "last": ["nd", "rest", "full", "prev", "strip", "first", "any", "and", "Last", "left", "count", "after", "since", "top", "size", "region", "right", "most", "bottom", "end", "this", "good", "master", "est", "default", "shadow", "old", "st", "length", "show", "get", "lot", "dist", "total", "max", "based", "base", "pop", "latest", "start", "recent", "index", "ast", "reverse"], "parent": ["path", "tip", "full", "where", "prop", "pa", "tar", "home", "tmp", "wrapper", "older", "instance", "per", "dir", "request", "parents", "and", "ma", "m", "params", "padding", "root", "test", "key", "mother", "pid", "family", "missing", "page", "p", "fat", "def", "Parent", "unit", "global", "up", "tree", "master", "owner", "part", "sp", "paren", "spec", "folder", "exp", "snap", "fr", "temp", "shape", "chain", "server", "holder", "point", "prefix", "pool", "ip", "child"], "f": ["b", "ft", "fs", "fed", "file", "fd", "bf", "fp", "fc", "tf", "m", "elf", "l", "fo", "fl", "c", "df", "p", "af", "h", "rf", "fe", "fac", "fi", "part", "fw", "lf", "F", "w", "fab", "fr", "g", "e", "of", "sf", "fm", "cf", "v", "local", "alf"], "srcChannel": ["subPanel", "curChan", " srcchannel", " srcCase", "subCase", "srcChan", "rcConnection", "curConnection", "curchannel", "sqchannel", " srcChain", " srcPanel", " srcChan", "sourceChan", "srcCase", "sourceButton", "instButton", "srcConnection", "sourceChannel", "ctrChan", "instchannel", "sourcechannel", "instChan", "ctrButton", "subChannel", "rcChan", "ctrChannel", "rcchannel", "rcButton", "srcchannel", " srcConnection", "curChannel", "sqChannel", "rcChain", "instChannel", "ctrChain", "sqCase", "srcButton", "srcChain", " srcButton", "rcChannel", "subchannel", "srcPanel", "sqPanel"], "dstChannel": ["dstConnection", "dltButton", " dotchannel", "cdstCh", "ddrChannel", "ddrChan", "ddrchannel", "dbrChannel", " dstchannel", " dotChannel", "distCategory", "deltChannel", "cdistCh", "dstCh", "dndButton", "dotchannel", "dotConnection", "drtCh", " dotConnection", "dltChan", "cdstCategory", "dndChan", "deltCh", "dbrConnection", "dotChan", "drtButton", "cdistChannel", "destChannel", "dblChan", "dndCh", "drtChannel", "distCh", " dstConnection", " dstChan", "dstCategory", " dotChan", "dndChannel", "dbrChan", "dstChan", "destChan", "dblChannel", "distButton", "dndCategory", "cdstChannel", "dbrchannel", "deltButton", "dblButton", "dltCh", "dotChannel", "drtCategory", "ddrConnection", "distChannel", "dblCh", "deltChan", "cdistButton", "destButton", "dstchannel", "dltChannel", "destCh", "cdistCategory", "cdstButton", "dstButton"]}}
{"id1": "494226", "id2": "88047", "code1": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"linesep": [" linespeg", "desep", "inesp", " lineset", "ineset", "lineps", "codespe", " linesip", "lineseps", " linesp", "lineep", "inesep", "codesp", "mysep", "inesel", "codeset", "despeg", "myseps", "lineseper", " linesop", " lineseper", "ineseps", "deseps", "linep", "linespeg", " linesel", "linesip", "linesel", "linepe", "linesop", "lineel", "inespe", "lineop", "codesep", "linip", "inesip", "inesop", "lineip", "codesel", "myseper", " lineseps", "linesp", "deseper", "lineset", "lineet", "lineeps", " linespe", "linespe", "myspeg"], "fos": ["fluts", "foS", "fess", "utfess", "fullos", "foss", " fows", "Foses", "hos", "pows", "utfuts", "wos", " foS", "yo", "flaos", "yos", "waos", "wOS", "fo", "Fo", "fullaos", "fortos", "fom", "floss", " foss", "bot", "utfoss", "faos", "flom", "fulloa", "nos", "eoes", " foa", "foa", "naos", "hOS", "utfos", "utfaos", "fulloS", "bo", "yoses", "pos", "fless", " fess", " fom", "fortoS", "eaos", "woes", "futs", "woss", " fOS", "hoes", "yot", "Fos", " faos", "fot", "flos", "flOS", "nows", " foes", "boses", "fortoa", "foses", "bos", "eos", "wess", "fOS", "hoss", "Fot", "foes", " fo", "po", "no", " futs", "eOS", "haos", "utfom", "fows", "fortaos", "paos"], "files": ["models", "states", "iles", "faces", "bees", "actions", "chains", "books", "sites", "fs", "users", "parents", "thumbnails", "checked", " Files", "jobs", "projects", "Files", "balls", "rows", "fixes", "flows", "roots", "events", "classes", "features", "frames", "images", "lets", "seconds", "ports", "uploads", "plates", "fields", "videos", "tests", "lines", "assets", "objects", "items", "artifacts", "archives", "workers", "ids", "ails", "scripts", "obs", "pages"], "i": ["ij", "is", "init", "us", "gi", "it", "xi", "info", "ci", "li", "I", "m", "t", "oi", "ai", "ix", "iq", "hi", "ki", "x", "bi", "ri", "n", "ii", "u", "mi", "multi", "uri", "ic", "index", "y", "im", "phi", "iu", "sim", "status", "ji", "me", "si", "ei", "pi", "ti", "cli", "point", "j", "ui", "di", "ini", "ip"], "metaprops": ["metapargs", "metiproperties", "metaproms", "metaproeps", "metiproeps", "metappros", "metapropPS", "metAProvPS", "metaprobps", "metapros", "metaprobPS", "metipproeps", "metapromps", "metapproeps", "metipproperties", "metAProeps", "metaprobgs", "metippropes", "metiprops", "metaprobeps", "metapraeps", "metaprms", "metaprps", "metAProbPS", "metaprovps", "metipprops", "metapropps", "metapropms", "metAProPS", "metaprperties", "metaproveps", "metAProbperties", "metAProvperties", "metapromeps", "metAProps", "metipropes", "metapromPS", "metaprovPS", "metaprobpes", "metaprPS", "metAProveps", "metapraps", "metapars", "metAProperties", "metapprogs", "metaprovperties", "metapprops", "metapromperties", "metaprapes", "metaprobms", "metAProvps", "metaprobperties", "metaparperties", "metaproPS", "metaproperties", "metAProbms", "metaparps", "metAProms", "metapproperties", "metapropperties", "metapropes", "metapraperties", "metAProbps", "metaprogs", "metappropes", "metaprobs"], "itsect": ["ilex", "Itsect", " itsection", "itconnect", "isections", "Itsector", "icsect", " itconnect", " itsections", "icsections", "isection", "Itsec", "icsection", "itsector", "isect", "tconnect", "iclex", "itlex", "isec", " itsector", " itsec", "entsect", "entconnect", "tsections", "tsection", "itsection", " itlex", "itsec", "itsections", "entsections", "entsection", "Itsection", "isector", "tsect"], "section": ["library", "block", "header", "group", "title", "component", "establishment", "subject", "filename", "context", "file", "session", "config", "sec", "instance", "journal", "second", "network", "string", "job", "client", "entry", "character", "test", "key", "container", "system", "row", "page", "label", "pair", "environment", "setting", "area", "element", "sector", "set", "course", "body", "definition", "sections", "option", "parent", "connection", "server", "Section", "language", "name", "tag", "member", "service", "sect"]}}
{"id1": "19322910", "id2": "344764", "code1": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "code2": "    static HttpURLConnection connect(String url, String method, String contentType, String content, int timeoutMillis) throws ProtocolException, IOException, MalformedURLException, UnsupportedEncodingException {\n        HttpURLConnection conn = (HttpURLConnection) (new URL(url).openConnection());\n        conn.setRequestMethod(method);\n        conn.setConnectTimeout(timeoutMillis);\n        byte[] bContent = null;\n        if (content != null && content.length() > 0) {\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", contentType);\n            bContent = content.getBytes(\"UTF-8\");\n            conn.setFixedLengthStreamingMode(bContent.length);\n        }\n        conn.connect();\n        if (bContent != null) {\n            OutputStream os = conn.getOutputStream();\n            os.write(bContent);\n            os.flush();\n            os.close();\n        }\n        return conn;\n    }\n", "label": 0, "substitutes": {"test_blueprintTypeByTypeID": ["test_blueprintTypeByTypeId", "test_blueprintTypeByNameType", "test_blueprintTypeByTypesID", "test_blueprintTypebytypeId", "test_blueprintTypeBytypeType", "test_blueprintTypeByTypesName", "test_blueprintTypebytypeName", "test_blueprintTypeByNameName", "test_blueprintTypeByNameID", "test_blueprintTypebyTypeType", "test_blueprintTypebytypeID", "test_blueprintTypeByTypeName", "test_blueprintTypeByTypesId", "test_blueprintTypebyTypeName", "test_blueprintTypeBytypeId", "test_blueprintTypeBytypeName", "test_blueprintTypeByTypeType", "test_blueprintTypebyTypeID", "test_blueprintTypebytypeType", "test_blueprintTypeBytypeID", "test_blueprintTypeByTypesType", "test_blueprintTypeByNameId", "test_blueprintTypebyTypeId"], "url": ["ls", "b", "user", "channel", "dl", "http", "URL", "open", "context", "l", "ur", "link", "string", "str", "browser", "https", "loader", "builder", "email", "nl", "org", "web", "row", "this", "domain", "u", "uri", "util", "rl", "document", "sb", "ref", "get", "impl", "Url", "mail", "ml", "log", "conn", "ssl", "resource", "module", "ul", "location", "base", "bel", "atl", "language", "ll", "mount", "relation", "service", "sl"], "connection": ["operation", "message", "channel", "generation", "collection", "library", "user", "Connection", "government", "function", "number", "office", "application", "open", "information", "sql", "subject", "database", "ion", "translation", "description", "session", "instance", "reference", "current", "termination", "division", "link", "network", "client", "directory", "record", "entry", "character", "system", "container", "row", "still", "object", "close", "internet", "uri", "created", "computer", "expression", "settings", "initial", "attribute", "handler", "command", "console", "position", "using", "statement", "engine", "controller", "condition", "conn", "resource", "server", "communication", "creation", "location", "pointer", "language", "response", "connect", "machine", "section", "relation", "volume"]}}
{"id1": "20247400", "id2": "755203", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"in": ["In", "check", "is", "init", "net", "on", "input", "rin", "it", "info", "file", "IN", "inn", "and", "inf", "bin", "ai", "ins", "source", "inc", "from", "ze", "up", "io", "ind", "din", "isin", "cin", "con", "i", "gin", " din", "inner"], "out": ["b", "obj", "ex", "check", "at", "or", "OUT", "net", "ou", "it", "write", "r", "err", "output", "ln", "list", "dir", "t", "str", "oss", "client", "gt", "Out", "n", "null", "ins", "os", "screen", "exit", "cmd", "to", "io", "ne", "sys", "outs", "msg", "w", "report", "writer", "OU", "log", "line", "con", "print", "o", "outer", "auto", "other", "name", "ot", "println", "we"], "buffer": ["b", "message", "match", "block", "header", "channel", "iter", "template", "function", "bridge", "display", "cache", "component", "binary", "address", "output", "database", "se", "append", "trace", "queue", "size", "memory", "Buffer", "window", "key", "limit", "source", "filter", "batch", "flush", "processor", "document", "attribute", "result", "bar", "command", "sequence", "view", "length", "position", "clear", "stack", "temp", "pause", "library", "shape", "buf", "event", "history", "total", "available", "sample", "buff", "data", "phrase", "db", "comment", "index", "table", "variable"]}}
{"id1": "8000624", "id2": "23666867", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": ["CopyInt", " copiesFrom", " CopyFrom", " CopyInt", "CopyFrom", " copyInt", " copiesTo", " copyFrom", " copyTo", " copiesInt"], "dest": ["path", "th", "rest", "src", "it", "usr", "filename", "output", "tmp", "dir", "Dest", "origin", "cat", "image", "loc", "fn", "source", "null", "txt", "orig", "p", "them", "img", "nom", "opt", "pipe", "copy", "est", "result", "sp", "st", "w", "target", "temp", "cont", "d", "v", "mem", "name"], "in": ["In", "read", "iter", "is", "sin", "init", "net", "on", "thin", "input", "rin", "al", "it", "win", "r", "file", "ain", "IN", "per", "inn", "reader", "m", "t", "l", "inside", "ire", "inf", "bin", "ai", "client", " input", "ir", "ar", "image", "ins", "one", "source", "inc", "from", "en", "ac", "mi", "up", "ind", "din", "isin", "min", "by", "re", "nin", "cin", "con", "i", "gin", " din", "internal", "inner", "o", "login", "local", "ini"], "out": ["b", "obj", "user", "ex", "at", "full", "net", "OUT", "note", "ou", "it", "all", "write", "dis", "output", "oe", "nt", "list", "ln", "t", "cos", "oss", "client", "gt", "boot", "Out", "n", "one", "null", "end", "fn", "os", "en", "not", "cn", "to", "flush", "up", "batch", "io", "ne", "op", "outs", "w", "writer", "conv", "by", "e", "na", "con", "loss", "co", "inner", "v", "aos", "o", "outer", "can", "other", "ot", "res", "ns"], "c": ["cs", "ce", "cd", "conf", "cap", "sc", "k", "f", "z", "cut", "current", "t", "count", "rc", "bc", "l", "cc", "cb", "cl", "character", "cat", "n", "cp", "ac", "u", "ct", "gc", "unc", "arc", "char", "C", "cm", "nc", "cr", "ch", "cod", "uc", "ca", "e", "g", "ec", "con", "i", "cont", "d", "v", "code", "cf", "lc"]}}
{"id1": "23273706", "id2": "2217889", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"getProjectTreeData": ["getApptreeInfo", "getProjectNodeList", "getProjectListList", "getProjectTreeInfo", "getProjecttreeInfo", "getProjectListData", "getAppTreeData", "getApptreedata", "getAppTreeInfo", "getApptreeData", "getProjecttreedata", "getProjectListdata", "getProjectTreeList", "getApptreeList", "getProjectListInfo", "getProjecttreeData", "getAppTreeList", "getProjectNodeInfo", "getProjecttreeList", "getAppTreedata", "getProjectNodedata", "getProjectNodeData", "getProjectTreedata"], "treeData": ["reeList", "treeValid", "TreeData", "tableValid", "reeDat", "tableInfo", "cacheData", "listDat", "listData", "TreeMap", " treeInfo", "treeMap", " treePart", "reeData", "towerData", "statusData", "tableData", "treeDat", "treeList", "cachePart", "TreeInfo", "listPart", "towerDat", " treeDat", " treeValid", "tableMap", " treeMap", "reeMap", "treeInfo", "tableDat", "cacheDat", "reeInfo", "statusMap", "towerValid", "treePart", "tableList", "statusDat", " treeList"], "filename": ["path", "KEY", "generation", "title", "URL", "fs", "url", "sql", "ename", "output", "save", "ames", "file", "fp", "FN", "fps", "FS", "Filename", "string", "original", "directory", "uno", "root", "key", "fn", "source", "txt", "png", "jpg", "uri", "lua", "nil", "username", "fil", "json", "folder", "river", "URI", "ername", "FILE", "temp", "FIL", "fax", "metadata", "location", "latest", "name", "SourceFile", "prefix", "println", "local", "localhost"], "urlString": ["lService", "urlService", "uristring", "urlSite", "UrlString", "lString", "uriSite", "URLString", " urlService", " urlstring", "uriSingle", "lstring", "UrlSingle", "urlstring", "uriString", "URLSingle", "Urlstring", "callStr", "URLstring", "callstring", "callService", "callString", "UrlSite", "urlSingle", " urlStr", "lStr", "urlStr", "URLSite"], "urldata": ["udlenatum", "urrdatum", "udldescription", " urldedata", "udlenata", "urldedata", " urldATA", "urrdescription", " urldatum", "urldeatum", " urldeata", "urledata", "urldatum", "udlenescription", "urldeATA", "udldatum", "uriledata", "urledatum", "urlenATA", "urldeata", "uriledATA", "urleddata", "udlenATA", "urrdATA", "urrdata", " urldeATA", "udldATA", "urlfatum", "urileddata", "urlfescription", "urlfata", " urlddata", "udldata", " urldeatum", "urlenata", "urldATA", "urlenatum", "urlenescription", "urldescription", "urledATA", "urlddata", "uriledatum", "urlfATA"], "factory": ["votype", " fFactory", "fixture", "FFactory", "facter", "facixture", "affFactory", "efacet", "Facter", "efFactory", "Factory", "vFactory", "fault", "frozen", "fFactory", "Fixture", "Frozen", "affotype", "facacter", " fixture", "fotype", "affactory", "efactory", "facault", "facactory", "Facet", "vactory", "vacter", " frozen", "Fotype", "Fault", " fault", "efrozen", "affacter", "facet", " facet", " facter"], "parser": ["Reader", "jack", "parse", "apache", "fascist", "file", "instance", "fp", "reader", "arser", "php", "au", "walker", "loader", "builder", "sup", "x", " df", "actory", "p", "df", "Parser", "processor", "manager", "util", "expression", "er", "xml", " parse", "io", "power", "command", "policy", "writer", "pdf", "conv", " parsing", "sf", "dom", "utils", "bank", " p"], "u": ["U", "us", "ou", "fu", "uf", "it", "uu", "mu", "url", "r", "su", "au", "l", "ur", "ut", "ue", "tu", "p", "uri", "h", "util", "io", "eu", "nu", "lu", "uid", "cu", "iu", "ua", "hu", "ul", "o", "ru", "ui", "uv", "un"], "is": ["us", "isl", "it", "fs", "ib", "dis", "iso", "ms", "ys", "info", "abs", "IS", "bis", "ist", "isc", "ai", "oss", "lis", "ri", "ar", "ir", "ists", "ins", "iss", "ris", "ic", "in", "are", "Is", "il", "ires", "io", "obs", "sys", "rys", "isi", "ost", "im", "its", "has", "iu", "ios", "ais", "sis", "si", "mis", "isa", "iris", "ui", "es", "ims"], "os": ["ls", "oos", "OS", "dos", "osa", "css", "or", "us", "oses", "out", "fs", "des", "ys", "ms", "oes", "ows", "s", "cos", "oss", "pos", "ens", "as", "Os", "bos", "ops", "osi", "bs", "ost", "io", "sys", "uts", "socket", "ios", "es", "ox", "so", "ss", "ros", "oa", "et", "aos", "o", "ot", "mos", "obs"], "iBufSize": ["iBbufLen", "iBufCount", "iBufSIZE", "iRufLength", "iLbufCount", "iBuffsize", "iRufSIZE", "iBphSize", "iBuffLen", "iBbufCount", "iLufsize", "iBuffSize", "iRbufLength", "iLufLen", "iRbufSize", "iLbufsize", "iBbufsize", "iBulLen", "iBufLength", "iRbufSIZE", "iRufCount", "iLufCount", "iLufSize", "iBuffLength", "iBbufSize", "iBulCount", "iBufLen", "iBphSIZE", "iRufSize", "iBbufLength", "iLbufSize", "iBulSize", "iBuffSIZE", "iLbufLen", "iBphCount", "iBbufSIZE", "iRbufCount", "iBulsize", "iBuffCount", "iBufsize", "iBphLength"], "inBuf": [" inRbuf", " inRuc", "inBufferuff", "inBuc", "InBuf", "inBiguc", "InChbuf", "InBuff", "inBufferBuff", "inBbuf", "inBufferuf", "inRuff", "inRuf", "inLbuf", "outBuf", "inBBuff", "outBul", "inLuf", " inBbuf", "inBlul", "inBlbuf", "outRBuff", "inChuf", " inRbuff", "outBbuf", "inChbuf", "InChBuff", "inBufferbuf", "outRuf", "inBiguf", "inRuc", "inRBuff", "inBuff", "outRul", "InChuf", "outBBuff", "InBBuff", "inBufferul", "inChBuff", "InBbuf", "inRbuf", "inBigbuff", "inRbuff", " inBuc", "inBul", "inChuff", "inLbuff", "InChuff", "inBlBuff", "inRul", "outRbuf", "inLuc", "inBigbuf", " inRuf", "inBluf", "inBbuff", " inBbuff"], "iNumRead": ["iNumFind", "INumRun", "iNUMRun", "inumPrint", "iLenRead", "iiNumRead", "aiNumRead", "aiNumberRead", "iNumberWrite", "iNumDef", "aiNumWrite", "INumRead", "iNumberFind", "INumNeed", "iFatFind", "iNUMNeed", "iinumDef", "InumNeed", "inumRun", "inumNeed", "iinumFind", "aiNumberFind", "inumDef", "iRemRead", "iLenRun", "INumPrint", "inumRead", "iLenPrint", "iRemWrite", "iNUMPrint", "InumPrint", "iRemFind", "iNumPrint", "iiNumDef", "iNumWrite", "InumRead", "iFatDef", "iFatRead", "iNUMRead", "iinumRead", "iiNumFind", "aiNumberWrite", "iNumberRead", "aiNumFind", "iNumRun", "iNumNeed", "iLenNeed", "inumFind", "InumRun"], "f": ["b", "fs", "file", "fd", "bf", "fp", "tf", "fc", "t", "l", "fo", "c", "n", "df", "p", "h", "fe", "af", "fac", "fi", "y", "F", "w", "g", "e", "fax", "sf", "fm", "d", "fa", "v", "cf", "o", "fr"], "inputstream": ["Inputdraw", "iterstyle", "uploadStream", "inputstyle", "uploaddraw", "uploadscreen", "inputStream", "inputscreen", "inputform", "iterscreen", "Inputstream", "iterStream", " inputStream", "Inputstyle", "uploadstream", "uploadform", " inputdraw", "Inputscreen", "InputStream", "Inputform", "iterstream", "inputdraw", "uploadstyle", " inputform"], "document": ["message", "collection", "ree", "template", "article", "ocument", "number", "apache", "Document", "information", "application", "context", "database", "media", "file", "m", "present", "browser", "directory", "html", "window", "n", "page", "df", "object", "expression", "tree", "xml", "version", "result", "command", "ml", "raw", "complete", "content", "model", "dom", "response", "language", "node", "doc"], "nodelist": ["nodedestyle", "nodesist", "nodeeman", "snodestyle", "nannodeemark", "nodeest", "nodeman", "neodeist", "nodest", "nodeety", "nodeist", "snodelist", "nondelist", " nodeseto", "nodeseto", "noyeline", "nostemark", "nosteline", " nodeto", "nODeline", "neodeman", "snodeemark", "neodelist", "nnodeety", "nostestyle", "nodedemark", "nannodeelist", "nodeto", " nodeline", "nomist", "nODelist", " nodesist", "nodemark", "nnodeist", "snodeelist", "nnodeemark", "noyelist", "nondist", "snodeline", "snodeeline", "nodeline", "noyist", "nanodemark", "nondeman", "nodedeline", "nnodeelist", "nodeselist", "nostelist", "nodestyle", "neodeeman", "nodeseline", "neodist", "noyeto", " nodeseline", "nomelist", "nodedist", "nodeemark", " nodist", "nannodeist", "nondest", "nODist", "nomeman", "nodety", "nodeestyle", "neodeelist", " nodeselist", "nodist", "nomest", "nodeelist", "neodest", "neodeest", "nodeeline", "snodemark", "nannodeety", "nanodelist", "nODeto", "nanodist", "snodeestyle", "nanodety", "nodedelist", "nodedety"], "num": ["nam", "net", "Number", "perm", "number", "all", "mu", "Num", "m", "su", "list", "current", "mult", "count", "uni", "proc", "umi", "zero", "nm", "n", "nom", "om", "multi", "NUM", "result", "nu", "UM", "set", "length", "cal", "alph", "coord", "um", "no", "dim", "mon", "con", "mn", "total", "sum", "max", "man", "mem", "np", "umer", "un"], "i": ["ami", "ij", "ex", "init", "my", "us", "gi", "it", "qi", "xi", "info", "\u0438", "ci", "li", "wi", "z", "I", "m", "l", "ai", "ix", "iq", "hi", "ri", "x", "bi", "n", "ii", "this", "them", "a", "q", "p", "mi", "multi", "major", "ic", "in", "batch", "index", "io", "y", "im", "phi", "iu", "sim", "ie", "e", "ji", "me", "history", "si", "zi", "ei", "pi", "ti", "cli", "j", "ui", "di", "ini", "ip"]}}
{"id1": "12197169", "id2": "20414923", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "label": 0, "substitutes": {"read": ["init", " recover", " Read", "Read", "find", "download", "open", "reader", " request", "load", " reopen", "record", "stream", "next", "run", "close", " reads", "gc", " replay", " reader", "reading", "log", " download", "start", "connect", " seek", " ingest", "hello", " retrieve"], "in": ["In", "when", "message", "check", "is", "at", "or", "ill", "on", "conf", "out", "ing", "input", "it", "all", "url", "info", "r", "f", "with", "update", "al", "file", "IN", "inn", "reader", "and", "add", "l", "inf", "bin", "record", "again", "entry", "as", "stream", "ins", "run", "source", "from", "inc", "er", "io", "via", "body", "din", "isin", "by", "get", "log", "re", "cin", "con", " din", "inner", "during", "o", "name", "index", "ro"], "line": ["message", "path", "block", "liner", "LINE", "lo", "url", "file", "ln", "stroke", "l", "ine", "frame", "link", "eline", "cell", "string", "record", "inline", "se", "lin", "entry", "word", "stream", "row", "detail", "page", "le", "Line", "char", "part", "sequence", "text", "body", "e", "log", "chain", "piece", "code", "sample", "data", "comment", "point", "lane"], "i": ["iter", "is", "id", "qi", "xi", "ci", "li", "f", "z", "I", "m", "t", "l", "oi", "ai", "ix", "hi", "x", "bi", "c", "ii", "n", "p", "mi", "multi", "u", "to", "index", "y", "sequence", "ind", "im", "phi", "conv", "sim", "ori", "me", "si", "d", "zi", "ei", "pi", "base", "o", "ti", "cli", "v", "j", "di"], "logDatum": ["logDummy", "logBump", "Logdatum", "logdum", " logBummy", "logdata", "logDoictionary", "LogDatum", "logRump", " logDummy", "logBictionary", "logBummy", "logTratum", "logdatum", "logBatum", "logRummy", "logRictionary", "logTrummy", "logTrum", "logDoummy", "LogDummy", "logDump", "LogData", "logDoatum", "Logdummy", "logDum", "logDoump", "logDictionary", " logBictionary", "Logdum", " logBump", " logBatum", " logDictionary", "LogDum", "Logdata", " logDump", "logRatum", "logdummy", "logData", "logTrata"]}}
{"id1": "12579075", "id2": "23585985", "code1": "    public static XMLConfigurator loadFromSystemProperty(String propertyName) throws IOException {\n        String urlStr = System.getProperty(propertyName);\n        if (urlStr == null || urlStr.length() == 0) {\n            return null;\n        }\n        InputStream in = null;\n        DOMRetriever xmlDoc = null;\n        try {\n            URL url = new URL(urlStr);\n            xmlDoc = new DOMRetriever(in = url.openStream());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (in != null) in.close();\n        }\n        return newInstance(xmlDoc);\n    }\n", "code2": "    public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException {\n        StreamSource streamSource = new StreamSource();\n        if (item.getType() == Type.JAVA_OBJECT) {\n            LOG.debug(\"Streaming Java object\");\n            Object obj = ((JavaObjectValue) item).getObject();\n            if (!(obj instanceof File)) {\n                throw new XPathException(\"Passed java object should be a File\");\n            }\n            File inputFile = (File) obj;\n            InputStream is = new FileInputStream(inputFile);\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(inputFile.toURI().toURL().toString());\n        } else if (item.getType() == Type.ANY_URI) {\n            LOG.debug(\"Streaming xs:anyURI\");\n            String url = item.getStringValue();\n            if (url.startsWith(\"/\")) {\n                url = \"xmldb:exist://\" + url;\n            }\n            InputStream is = new URL(url).openStream();\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(url);\n        } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) {\n            LOG.debug(\"Streaming element or document node\");\n            if (item instanceof NodeProxy) {\n                NodeProxy np = (NodeProxy) item;\n                String url = \"xmldb:exist://\" + np.getDocument().getBaseURI();\n                LOG.debug(\"Document detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n            Serializer serializer = context.getBroker().newSerializer();\n            NodeValue node = (NodeValue) item;\n            InputStream is = new NodeInputStream(serializer, node);\n            streamSource.setInputStream(is);\n        } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) {\n            LOG.debug(\"Streaming base64 binary\");\n            BinaryValue binary = (BinaryValue) item;\n            byte[] data = (byte[]) binary.toJavaObject(byte[].class);\n            InputStream is = new ByteArrayInputStream(data);\n            streamSource.setInputStream(is);\n            if (item instanceof Base64BinaryDocument) {\n                Base64BinaryDocument b64doc = (Base64BinaryDocument) item;\n                String url = \"xmldb:exist://\" + b64doc.getUrl();\n                LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n        } else {\n            LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType()));\n            throw new XPathException(\"wrong item type \" + Type.getTypeName(item.getType()));\n        }\n        return streamSource;\n    }\n", "label": 0, "substitutes": {"loadFromSystemProperty": ["loadFromSystemAttribute", "loadFromSysPro", "loadFromSystemProp", "loadFromSystemPro", "loadFromShellAttribute", "loadFromSysAttribute", "loadFromsystemAttribute", "loadFromSysProperty", "loadFromsystemProp", "loadFormSystemAttribute", "loadFormSysProperty", "loadFormSysPro", "loadFromShellPro", "loadFromsystemPro", "loadFromSysProp", "loadFormSystemProperty", "loadFromShellProp", "loadFormSystemProp", "loadFormSysProp", "loadFormSysAttribute", "loadFromsystemProperty", "loadFromShellProperty", "loadFormSystemPro"], "propertyName": [" propertyKey", " propertyTitle", "propertyStart", "serviceStart", "attributeName", " propertyStart", "serviceKey", "paramKey", "propname", "variablename", "attributeKey", "propertyPath", "attributename", "propertyTitle", "variableKey", "propertyname", "serviceTitle", "propKey", "propertyKey", "propPath", "propName", "paramTitle", "variableName", "paramName", "attributePath", "serviceName", "paramStart", "variablePath"], "urlStr": ["uriCh", "UrlRes", " urlRest", "urlString", "uriOr", "uriBr", "uriRes", "UrlString", "uriStr", "urlOr", "URLCh", "strRest", "uriRest", " urlWr", " urlOr", "URLString", " urlBr", " urlString", "URLBr", "strString", "strOr", "UrlSTR", "strStr", "urlCh", "UrlStr", " urlCh", " urlSTR", "uriWr", "uriSTR", "uriString", "urlRes", "urlSTR", "urlWr", "UrlRest", "urlRest", "UrlWr", "urlBr", " urlRes", "URLStr"], "in": ["In", "is", "init", "on", "out", "input", "rin", "it", "win", "login", "ln", "IN", "ma", "inn", "t", "s", "l", "inside", "bin", "again", "as", "ins", "n", "source", "inc", "mc", "from", "en", "mi", "h", "ic", "to", "up", "oin", "body", "din", "isin", "nin", "cin", "serv", "con", "i", "gin", "conn", "asin", "inner", "o", "doc"], "xmlDoc": ["xmlFile", "xfBuff", "documentFile", "apacheDocument", "apacheDoc", " xmlVal", "mlVal", "apacheRef", "xfVal", "xfDoc", " xmlTree", "apachedoc", "documentDocument", "xmldoc", "mlFile", "xmlRef", "mlDocument", "mlDoc", "mlTree", " xmlRef", " xmlFile", " xmlDocument", " xmlBuff", "xmlTree", "imageDoc", "imagedoc", "mlBuff", "xfFile", "imageDocument", "imageRef", "xmlDocument", "documentTree", " xmldoc", "xmlBuff", "documentDoc", "xmlVal"], "url": ["b", "dl", "cert", "http", "URL", "out", "r", "f", "file", "l", "ur", "link", "str", "gl", "browser", "job", "google", "web", "nl", "still", "null", "lb", "p", "u", "uri", "char", "rl", "xml", "get", "log", "Url", "re", "build", "ssl", "resource", "ul", "bel", "base", "ll", "mount", "service", "sl"]}}
{"id1": "9275622", "id2": "7458833", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpStream", " cpFiles", " duplicateFile", "copyFiles", " cpFile", " copyfile", " duplicateStream", " copyFiles", " copyStream", " duplicateFiles", " cpfile", " duplicatefile", "copyStream", "copyfile"], "_file1": ["_fileInit", "_link1", "_ile2", "_ileOne", "_FileOne", "_ile1", "_ileInit", "_files2", "_linkInit", "_FileFirst", "_fileOne", "_File1", "_files1", "_File2", "_filesFirst", "_FileInit", "_fileFirst", "_linkOne", "_link2", "_ileFirst", "_filesOne"], "_file2": ["_Fileb", "_linkTwo", "_image1", "_link1", "_FILEb", "_file02", "_File02", "_FILE1", " _FILEb", " _FILE2", "_image2", " _Filetwo", " _FILE1", " _File1", "_image02", " _fileb", "_File1", "_FILE02", " _FileTwo", "_Filetwo", "_File2", "_FILE2", " _filetwo", " _fileTwo", "_link2", "_imageb", " _file02", " _FILE02", "_fileTwo", "_filetwo", "_FileTwo", "_fileb", " _File2", "_linktwo"], "fis": ["kais", "ufi", "fois", "Fios", "fios", "kis", "Fis", "cos", " fris", "cios", " fios", " fois", "ufis", "fiss", "cfris", "fais", "cis", " fais", "qos", "fliss", "ufiss", "fris", "fi", "ufios", "cfois", "qiss", "kios", "cfiss", " fiss", " fi", "qios", "kos", "flis", "Fois", "Fris", "cfis", "qis", "fli", "flios", "Fos", "cais", "Fiss"], "fos": ["flos", "ffoes", "waos", " foes", "moes", "ffis", "hose", "wis", "sfoes", "foss", " fows", "hos", "sfoss", "floes", "floss", "hoss", "maos", "sfose", "ffos", " foss", "wos", "mows", "woes", "foes", "fose", "woss", "wows", "faos", " fose", "flis", "ffoss", "hoes", "fows", "mos", " faos", "sfos"], "canalFuente": ["canalKuperor", "canalFuenza", "canallFuje", "canalfuestro", "canalFaleree", "canalFuje", "canalUtente", "canallfuent", "canalTenenza", "canalFienza", "canallfueree", "canalfuent", "canalFuestro", "canalFient", "canalUteree", "canallfuperor", "canalKuent", "canalFalje", "canalFiperor", "canallFuenza", "canalfuenza", "canallFueree", "canalUtent", "canalKuente", "canallFuestro", "canallFuperor", "canalUtestro", "canalTenente", "canalfuje", "canalFiente", "canalFalent", "canalTenent", "canalFalperor", "canalfuente", "canallfuenza", "canalFuent", "canalfuperor", "canallfuente", "canallfuje", "canallFuente", "canallFuent", "canalFueree", "canallfuestro", "canalFuperor", "canalKuje", "canalTenperor", "canalFalente", "canalfueree", "canalFalestro"]}}
{"id1": "20073619", "id2": "10547671", "code1": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 1, "substitutes": {"getPagina": ["getPackagine", "getPaginate", "getPagarino", "getPageine", "getPackagino", "getPackagarinate", "getPagarinate", "getPackaginate", "getPaginino", "getPaginina", "getPageina", "getPagarina", "getPagarine", "getPageinate", "getPageino", "getPagino", "getPaginine", "getPagininate", "getPackagarine", "getPackagarina", "getPagine", "getPackagina", "getPackagarino"], "strurl": [" strUrl", "arrURL", "STRurl", " strURL", " strssl", "urlssl", " strrel", "sprurl", "STRstr", "strssl", "sprUrl", "urlstr", "sprURL", "STRUrl", "urlUrl", "arrurl", "strrel", "urlurl", "STRssl", "strURL", "strstr", "strUrl", "arrrel", "sprrel", "arrUrl", " strstr"], "resp": [" err", "err", " rep", "rm", "help", "pretty", "https", " enc", "summary", "lim", "respons", "acc", "respond", "body", "rev", "conn", "rex", "response", "fr", "inv", "obj", " ret", "comm", "dem", "csv", " disp", " response", "txt", "comp", "good", "conv", "serv", "changes", "dl", "rest", "perm", "Resp", " respons", "repl", "pos", "html", "req", "gov", "arr", "rend", "ja", "sol", "exp", "ret", "re", "jp", " outp", " res", "res", "Response", "cli", "neg", "output", "pkg", " Resp", "cmd", "cmp", "msg", "soc", "par", "rep", " req", " msg", "disc", "esp", "buff", "rel", "gz", "elt", "pas"], "url": ["ls", "b", "dl", "cert", "http", "URL", "id", "open", "address", "r", "f", "file", "t", "l", "ur", "gl", "link", "browser", "client", "web", "nl", "loc", "null", "host", "mount", "uri", "char", "get", "build", "Url", "ssl", "resource", "ul", "base", "ll", "pl", "service", "sl"], "in": ["In", "read", "is", "ill", "on", "out", "input", "rin", "it", "all", "r", "al", "file", "IN", "inn", "reader", "and", "inside", "inf", "bin", "again", "ins", "n", "source", "inc", "from", "mc", "ic", "er", "io", "el", "ind", "oin", "body", "din", "isin", "by", "cin", "mn", "serv", "i", "gin", " din", "sum", "inner"], "str": ["ls", "obj", "expr", "pt", "block", "dr", "r", "comm", "err", "del", "m", "list", "t", "s", "l", "bc", "Str", "string", "sts", "entry", "req", "n", "txt", "le", "br", "p", "ent", "arr", "coll", "char", "dict", "part", "tr", "sp", "msg", "cr", "st", "div", "text", "sol", "STR", "exp", "ch", "hex", "e", "line", "chain", "i", "cont", "print", "syn", "inner", "name", "comment", "j", "fr", "ns"]}}
{"id1": "4798332", "id2": "614099", "code1": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"SHA": ["SO", "SU", " MD", "MD", " signature", " sum", "ASH", " GET", "H", "SE", "PI", " Signature", " hash", "MA", "SH", "ES", "HT", "HA", "DATA", "sha", "Hash", "GET", "SA", " Sha", "AC", "HTML", "HS"], "source": ["dest", "SOURCE", "message", "template", "format", "src", "input", "search", "url", "Source", "type", "sql", "filename", "subject", "query", "info", "space", "request", "config", "ource", "seed", "s", "string", "str", "original", "origin", "score", "reason", "image", "ins", "this", "scope", "from", "object", "uri", "unit", "expression", "copy", "spec", "site", "sequence", "text", "body", "target", "style", "position", "raw", "content", "base", "sample", "data", "name", "cause", "secret"], "result": ["Result", "message", "cert", "format", "value", "cache", "out", "sign", "search", "url", "key", "r", "wrapper", "filename", "output", "description", "su", "currency", "join", "current", "csv", "product", "str", "RESULTS", "success", "summary", "true", "answer", "test", "continue", "results", "reason", "term", "found", "this", "null", "details", "br", "successful", "comp", "valid", "sequence", "text", " resulted", "report", "status", "ret", "complete", "res", "cur", "hash", "response", "data", "comment", "relation", "table", "cup"], "digest": ["decest", "Digester", " digEST", "Digum", "digEST", "digester", "mdse", "hashested", " digse", "mdester", "nest", "signest", "digum", "Digger", "decEST", "digested", "mdest", "Digest", "num", "Digse", "nested", "hashester", "hashum", "mdum", "digger", "decester", "decested", " digum", "signger", "signested", "nester", "DigEST", "Digested", "signester", " digester", "digse", "hashest", " digested", "decger"], "bytes": ["bags", "pieces", "gs", "strings", "files", "words", "gets", "clips", "keys", "binary", "gb", "loads", "s", "reports", "parts", "bps", "groups", "results", "tes", "bits", "services", "bs", "Bytes", "classes", "outs", "frames", "ips", "steps", "images", "its", "seconds", "units", "lines", "names", "latest", "es", "values", "pages", "blocks"]}}
{"id1": "7149578", "id2": "7499186", "code1": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"parseContent": ["parseHTML", "parseContents", "parserContent", " parseHTML", "readContent", "parseMedia", "readHTML", "parserContents", " parseMedia", " parseContents", "parserMedia", "parserHTML", "readMedia", "readContents"], "streamLimiter": ["streamLimititing", " streamLimititing", "streamLiting", "StreamLimiter", "streamlimitor", "streamlimiting", "streamMilliting", "streamRangeite", "streamRangeitter", "streamLimititable", "streamMillitter", "resourceLimititter", "StreamLimited", "streamLimitier", "Streamlimiter", "StreamLimitter", "streamlimite", "resourceLimititer", "Streamlimier", "resourceLimitter", " streamLimititter", "streamLockiter", "resourceLimiter", " streamLimer", "streamLitter", "streamlimier", "Streamlimitter", "Streamlimite", "streamLiter", "streamLimititer", "streamLitable", "StreamLimier", "streamLimite", "resourceLimiting", "streamMillitable", " streamLimiting", "resourceLimitable", "StreamLimitor", "streamlimer", "streamLimititter", "streamLimitter", "streamRangeiter", "streamRangeitor", "streamLimitable", "streamlimitter", "streamlimited", "streamLimited", "resourceLimititable", "streamLimitor", "streamLockited", "streamLimer", "Streamlimited", "Streamlimitor", "streamLockier", " streamLimitter", " streamLimititer", "streamlimiter", "streamLimiting", "streamLockitter", "streamLimitited", "streamMilliter", "resourceLimititing", "StreamLimite", "streamLimier"], "forcedLang": [" forcedllang", " contentLanguagelang", " contentlng", " contentLlang", " contentUig", " forcedlang", " contentUlang", " contentllang", " contentlang", " contentlig", " contentUang", " contentUng", " contentLanguageang", " contentLang", " forcedLng", " forcedlng", " contentLng", " forcedLig", " forcedLlang", " forcedlig", " contentLig", " contentLanguageng", " contentLanguageig"], "charset": ["chaptersect", "charactersSet", "charpetter", "charsiet", "scarsant", "charsum", "charpant", "capsetter", "carsetter", "charpset", "chatspace", "chrasect", "chapterspace", "CHarsSet", "chanksetter", "wharsect", "chatorspace", "chipspace", "carset", "chararset", "channelarsset", "chacterspace", "chartsset", "chasetter", "charsale", "echARSET", "chankset", "echARSet", "CHorset", "chatsiet", "chearsum", "chartspace", "Charset", "chapsum", "channelarspace", "chapsett", "chipsetter", "echarsET", "chatsum", "chararsiet", "charsetter", "chraset", "chARSett", "scartsant", "cheapset", "chearsett", "echARSpace", "chrasetter", "chararsetter", "carsale", "chanksett", "CHorsetter", "chanksen", "charsSet", "chasen", "CHapset", "scartsel", "carsal", "charactersET", "chaptersen", "chordset", "chasal", "chatorsET", "charsel", "whaptersen", "chanksiet", "charsset", "chatsetter", "chaptersett", "chrasSet", "chashesect", "scarsel", "chartsett", "carsET", "chearspace", "chactersET", "charatsetter", "chashesset", "echarsetter", "echarset", "channelarsett", "CHapspace", "whaptersect", "cherset", "chatsen", "charpel", "charatsen", "capset", "charpale", "chARSetter", "CHapsett", "channelashespace", "Charsetter", "chARSset", "charactersetter", "charsant", "characterset", "chipsant", "chashesSet", "chasheset", "CHorsect", "choset", "chosET", "chararsSet", "chacterset", "charsect", "chipsel", "chosetter", "CharsSet", "chaptersum", "CHarsett", "chashespace", "charpet", "chaset", "CHapsET", "chapspace", "chapset", "chatorsett", "chatset", "chrasET", "charsET", "chactersetter", "chapsale", "chararsen", "channelasheset", "scartset", "whaptersett", "whapterset", "scartsset", "chosSet", "chARSen", "channelashesset", "chipset", "charpET", "charsen", "CharsET", "echARSetter", "cheapsum", "capsET", "wharsen", "chARSet", "wharsett", "CHorsSet", "CHarsET", "chaptersetter", "cARSen", "chARSal", "charatsiet", "chARSpace", "charspace", "chapsSet", "chartsant", "chordsetter", "chaptersal", "carsen", "chartsel", "cARSal", "CHarset", "chashesett", "chorsSet", "charsett", "cARSetter", "channelashesett", "scarset", "chorsect", "Charsett", "charatset", "chartset", "chARSET", "chorsetter", "chapsetter", "chanksect", "cARSet", "CHarspace", "chatorset", "CHarsect", "chatsect", "scarsset", "chersetter", "chapterset", "chordsett", "charsal", "chordsET", "chearset", "channelarset", "chashesetter", "CHarsetter", "wharset", "cheapspace", "chipsset", "chapsET", "echarspace", "chorset", "chersale", "chararsET", "chersET", "chatsett", "capsale", "chARSSet", "chipsET", "cheapsett", "chactersSet"], "sourceDocument": ["srcPage", "sourceTransaction", "srcTransaction", "sourceRecord", "sourceDoc", "SourcePage", "thisDocuments", "targetDoc", "sampleMedia", "srcMedia", "SourceDoc", "SourceDocuments", "thisDocument", "resourceDocument", "srcDocument", " sourceFile", "sourceFile", "contentTransaction", " sourceDocuments", "srcRecord", "sampleRecord", " sourceDoc", "resourceRoot", "SourceDocument", "sampleDocument", " sourceRoot", "srcDocuments", "targetDocument", " sourcePage", "contentDocument", "sourcePage", "resourceDoc", "contentRecord", "contentMedia", "sampleTransaction", "srcFile", "sourceRoot", "sourceMedia", "SourceFile", "targetRoot", "thisDoc", "sourceDocuments"], "fieldValueItem": ["fieldItemInfo", "fieldValueObject", "fieldvalueIt", "fieldReferenceItem", "FIELDValueEntry", "fieldReferenceEntry", "fieldItemItems", " fieldvalueEntry", "fieldVALUEObject", "fieldsValueItemImage", "fieldInfoIt", " fieldValueItemImage", "fieldListItems", "fieldValueEntry", "fieldListInfo", "fieldVALUEResult", "FIELDValueItemImage", "fieldReferenceValue", "fieldItemEntry", "fieldVALUEItem", " fieldValueEntry", "rowValueValue", "FIELDKeyEntry", "fieldListitem", "fieldvalueItemImage", " fieldValuesInfo", "FIELDKeyValue", "fieldItemValue", "fieldListItem", "fieldValueItemImage", "FIELDKeyItem", "fieldValuesInfo", "FIELDValueItem", "fieldInfoItem", "fieldVALUEArea", " fieldValuesitem", " fieldValueItems", " fieldValuesItem", "fieldKeyValue", "fieldValuesitem", "rowValueArea", "fieldsValueItem", "fieldFieldEntry", "rowValueItem", " fieldvalueIt", "fieldValuesItem", " fieldValueInfo", "fieldValueValue", "fieldValueitem", "fieldFieldItemImage", "fieldValuesItems", "fieldValueIt", "rowValueitem", "fieldReferenceItemImage", "fieldVALUEIt", "fieldItemArea", "fieldVALUEEntry", "fieldInfoEntry", "FIELDKeyItemImage", "fieldItemResult", "fieldItemItem", "fieldValueArea", "fieldInfoItemImage", "fieldvalueItem", "fieldvalueitem", " fieldValueIt", "fieldItemObject", "fieldsValueObject", "fieldKeyItemImage", "fieldVALUEItemImage", "fieldValueInfo", "fieldKeyEntry", "fieldValueItems", " fieldValuesItems", " fieldvalueitem", " fieldvalueItemImage", "fieldFieldValue", "fieldItemitem", "fieldFieldItem", "fieldsValueResult", "fieldValueResult", " fieldValueitem", "fieldVALUEitem", "fieldItemItemImage", "fieldvalueEntry", " fieldvalueItem", "fieldKeyItem", "fieldVALUEValue", "FIELDValueValue"], "charsetWasNull": ["charsetAlreadyValid", "charsetOriginallyNull", "charsetEverUnknown", "charsetIsValid", "charsetOriginallySet", "charsetEverInvalid", "charssetWasNone", "charssetWasInvalid", "charsetEverSet", "charsetDidnull", "charsectWasNULL", "charsetWasnull", "charsetEverNone", "charsETWasNull", "charsetWereChanged", "charsETWasnull", "charsetterEverSet", "charsETWereNull", "charsetAlreadyNull", "charsetWasValid", "charsetWrittenSet", "charsetterWasUnknown", "charsetWereValid", "charsectWasnull", "charsetWrittenUnknown", "charssetPreviouslyInvalid", "charsetterWasSet", "charssetWasValid", "charsetPreviouslyNull", "charsetWasChanged", "charsetPreviouslyValid", "charsetIsnull", "charsetUsedChanged", "charsETWasValid", "charsETWereChanged", "charsetterWasNULL", "charsectWasNull", "charsetWrittenNULL", "charsectDidNull", "charsetDidNULL", "charsetPreviouslyInvalid", "charsetAlreadyInvalid", "charsetIsNULL", "charsetterEverUnknown", "charsetDidNull", "charssetWasNull", "charsetterWasNull", "charsetEverNull", "charsETWasChanged", "charsetUsedNull", "charsectDidNULL", "charsetEverNULL", "charsetAlreadyNone", "charsetIsNull", "charsectDidnull", "charsetWasInvalid", "charsetOriginallyNULL", "charsetEverValid", "charsetWerenull", "charsetOriginallyUnknown", "charsetterEverNull", "charssetPreviouslyValid", "charsETWerenull", "charsetWrittenNull", "charsetWasNULL", "charsetWereNull", "charssetPreviouslyNone", "charsetIsChanged", "charsetPreviouslyNone", "charsetterEverNULL", "charssetPreviouslyNull", "charsetWasSet", "charsetUsedValid", "charsETWereValid", "charsetWasUnknown", "charsetWasNone", "charsetUsednull", "charsetWereNULL"], "writer": ["wright", "external", "driver", "counter", "creator", "format", "wrote", "out", "update", "write", "wrapper", "output", "writers", "written", "reader", "string", "network", "walker", "loader", "builder", "window", "word", "stream", "rew", "null", "writ", "WR", "ter", "to", "riter", "master", "document", "handler", "caster", "ner", "owner", "attribute", "console", "w", "writing", "unsigned", "access", "Writer", "worker", "iterator", "buffer", "inner", "auto", "outer", "comment", "wire", "variable"], "htmlProvider": ["tmlPath", " htmlPlugin", " htmlStore", " htmlReader", "httpParser", "httpPath", "htmlHost", "cssAdapter", "htmVersion", "contentPath", "cssConsumer", "htmlVersion", "htmReader", "contentParser", "contentSource", "tmlReader", "htmlReader", "htmlAdapter", " htmlPort", "tmlAdapter", "tmlStore", "tmlPlugin", "httpSource", "htmlSource", "tmlSource", "httpProvider", "htmlPath", "webSource", "tmlParser", "contentHost", "htmPlugin", " htmlProv", "dbProv", "httpReader", " htmlPlayer", "dbParser", "htmlConsumer", "htmlPlayer", "htmlPlugin", " htmlConsumer", " htmlAdapter", "cssProv", "htmHost", "htmlStore", "htmlPort", "webProvider", "htmlProv", "cssProvider", "tmlProv", "dbStore", "tmlProvider", " htmlHost", "httpPort", "webAdapter", " htmlParser", "htmlParser", "tmlConsumer", "webPlayer", " htmlVersion", "htmProvider", "tmlPlayer", "contentProvider", " htmlSource", "dbProvider", "tmlPort", "contentVersion"], "contentType": ["messageTime", "mediaForm", "mediaType", "wordLength", "requestDiff", "mediaTime", "questTime", "keyForm", "contentTYPE", "keytype", "contentForm", "messageType", " contentTYPE", "contentTime", " contentLength", "contenttype", " contentTime", "loadType", " contentDiff", "keyTime", "requestTime", "wordTYPE", "messageLength", "mediatype", "requestLength", "wordType", "requestType", "keyType", "contentLength", "loadLength", "contentDiff", "questForm", "questType", "messageDiff", "loadTYPE", "questtype"], "contentTypeCharset": ["contentTypeChartsET", "contentTypeChothesSet", "contentTypeChARSue", "contentTypeChARSport", "contentTypeChatsets", "contentTypeCharsant", "contentTypeCharsport", "contentTypeChartset", "contentTypeCherset", "contentTypeCARSet", "contentTypeChapset", "contentTypecharsets", "contentTypeChorsetter", "contentTypeChartsett", "contentTypeChaptersen", "contentTypeCHarsetter", "contentTypeChasen", "contentTypeCasET", "contentTypecharset", "contentTypeCHatsport", "contentTypechothesant", "contentTypeChartsant", "contentTypeCarsets", "contentTypeCarsetter", "contentTypeChapsets", "contentTypeChasue", "contentTypeClarsen", "contentTypecharsett", "contentTypeCharsen", "contentTypeClarset", "contentTypeChersetter", "contentTypecharsite", "contentTypeCHatsen", "contentTypeChersen", "contentTypeChatsetter", "contentTypeClerset", "contentTypeChotheset", "contentTypeChorset", "contentTypeChARSen", "contentTypeChatset", "contentTypechothesetter", "contentTypeCHarsport", "contentTypeCaset", "contentTypeCHatset", "contentTypeClarsetter", "contentTypecharsant", "contentTypeCHarset", "contentTypeChartsSet", "contentTypeCharsite", "contentTypeChartse", "contentTypeChARSet", "contentTypeCasetter", "contentTypeChARSe", "contentTypeChatsen", "contentTypeCARSetter", "contentTypeCharsetter", "contentTypeChaset", "contentTypeChARSett", "contentTypeChartsetter", "contentTypeCarsET", "contentTypeChothesets", "contentTypeChersant", "contentTypeCharsets", "contentTypeCharsett", "contentTypeChothesite", "contentTypeChothesetter", "contentTypeCasue", "contentTypeClersetter", "contentTypeChasetter", "contentTypeCharsue", "contentTypeCharse", "contentTypeChapterset", "contentTypeClersen", "contentTypeCARSets", "contentTypeChothesET", "contentTypecharsetter", "contentTypeCarset", "contentTypeChersET", "contentTypeClarsET", "contentTypechothesSet", "contentTypeCHatsetter", "contentTypeChasET", "contentTypecharsET", "contentTypeClersET", "contentTypeChatsett", "contentTypeChersSet", "contentTypeCARSET", "contentTypecharsSet", "contentTypeChapsite", "contentTypecharse", "contentTypechotheset", "contentTypeCHarsen", "contentTypeChatsport", "contentTypeChaptersetter", "contentTypeChatsET", "contentTypeChaptersport", "contentTypechatsET", "contentTypeChatse", "contentTypeChARSetter", "contentTypeChARSET", "contentTypeCarsue", "contentTypechatsett", "contentTypeCharsSet", "contentTypeCharsET", "contentTypeChothesant", "contentTypeChapsET", "contentTypeChARSets", "contentTypeChorsET", "contentTypechatse", "contentTypeChorsue", "contentTypechatset"]}}
{"id1": "23677142", "id2": "18046717", "code1": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "code2": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "label": 0, "substitutes": {"BubbleSortShort2": ["BubbleSortInt2", "BubbleSortIntDouble", "BubbleSortStringTwo", "BubblesortShortDouble", "BubblesortInt2", "BubblesortIntTwo", "BubblesortIntDouble", "BubbleSortInt4", "BubblesortShort2", "BubblesortInt4", "BubbleSortshort2", "BubbleSortShortTwo", "BubbleSortIntTwo", "BubbleSortString4", "BubbleSortString2", "BubbleSortShortDouble", "BubblesortShortTwo", "BubbleSortshortTwo", "BubblesortShort4", "BubbleSortshort4", "BubbleSortStringDouble", "BubbleSortshortDouble", "BubbleSortShort4"], "num": ["tm", "nam", "check", "net", "note", "missing", "cache", "number", "uf", "ver", "mu", "update", "save", "info", "comm", "Num", "nt", "m", "ums", "add", "eng", "test", "zero", "nm", "n", "fn", "nom", "txt", "tu", "prim", "om", "val", "img", "pn", "en", "tim", "NUM", "cmp", "sam", "nu", "msg", "old", "coord", "mat", "im", "cal", "snap", "alph", "form", "dat", "hex", "na", "um", "bn", "dim", "mon", "get", "mn", "con", "buf", "sum", "rum", "mem", "np", "dec", "mun", "alpha"], "last_exchange": ["last_exaction", "last_elception", "last_rxvert", "last_sexaction", "last_sexamine", "last_sexactly", "last_sexchange", "last_pexchange", "last_nameception", "last_nameamine", "last_excessive", "last_nameactly", "last_pexamine", "last_execessive", "last_exerence", "last_exvert", "last_EXamine", "last_rxception", "last_Exerence", "last_exevert", "last_rxchange", "last_rxcessive", "last_Exception", "last_xerence", "last_exechange", "last_elchange", "last_Exchange", "last_sexception", "last_exeception", "last_EXaction", "last_EXchange", "last_xchange", "last_exception", "last_EXerence", "last_EXChange", "last_examine", "last_elvert", "last_elcessive", "last_pexception", "last_pexactly", "last_exChange", "last_xChange", "last_EXception", "last_namechange", "last_exactly", "last_elamine", "last_elaction", "last_xception", "last_ExChange"], "right_border": [" right_comment", "right_break", " right_order", " rightflowborder", "rightflowgap", "right_order", "rightPostindex", " right_only", "rightPostcomment", "right_only", "rightflowcomment", " right_gap", " right_index", " right_break", " rightflowgap", "rightPostgap", " rightflowcomment", " rightflowindex", "right_index", "rightflowborder", "right_comment", "rightflowindex", "rightPostborder", "right_gap"], "j": ["my", "f", "err", "ix", "jet", "p", "u", "__", "jj", "uj", "e", "get", "i", "v", "o", "other", "jump", "fr", "obj", "ij", "user", "expr", "note", "z", "dj", "kid", "job", "c", "key", "oj", "aj", "json", " J", "pr", "pt", "jac", "k", "bj", "pos", "req", "n", "br", "adj", "kj", "jit", "og", "ja", " dj", "el", "ind", " ii", "im", "js", "ret", "g", "je", "J", " n", "jp", "jl", "index", "jack", "it", "journal", "l", "jo", "q", " Dj", "er", "jc", "ji", "server", " obj", "jen"], "temp": ["read", "dep", "template", "ptr", "tt", "perm", " tmp", "tc", "Temp", " Temp", "tmp", "tem", "comb", "mp", "rem", "pre", "t", "kw", "fake", "test", "alt", "null", "txt", "orig", "tim", " temporary", "fac", "attr", "acc", "result", "mod", "unt", "cu", "em", "dat", "deg", "buffer", "porary", "base", "mem", "cum", "emp", "variable"]}}
{"id1": "21368981", "id2": "20685385", "code1": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "label": 0, "substitutes": {"create": ["activate", "launch", "read", "install", "write", "save", "api", "instance", "request", "Create", "add", "send", "release", "submit", "created", "creat", "post", "upload", "get", "build", "insert", "process", "creation", "execute", "hello"], "application": ["b", "message", "binding", "value", "apache", "component", "type", "information", "address", "api", "provided", "database", "aton", "amount", "description", "request", "app", "Application", "client", "management", "system", "entry", "object", "expression", "document", "attribute", "command", "json", "sequence", "face", "position", "usage", "content", "resource", "code", "base", "language", "data", "service"], "response": ["reply", "message", "library", "block", "collection", "value", "format", "function", "information", "api", "output", "description", "request", "add", "frame", "network", "summary", "answer", "onse", "entry", "continue", "image", "next", "detail", "page", "object", "action", "resp", "tree", "version", "document", "attribute", "command", "result", "site", "json", "sequence", "view", "respond", "default", "report", "position", "see", "me", "complete", "server", "model", "hash", "Response", "profile", "example", "status", "index", "service", "relation", "respons"], "connection": ["operation", "when", "generation", "channel", "collection", "user", "library", "Connection", "government", "function", "device", "number", "component", "query", "office", "open", "information", "subject", "translation", "database", "ion", "wrapper", "description", "session", "reference", "link", "network", "bo", "client", "directory", "entry", "connected", "c", "character", "web", "container", "builder", "n", "close", "method", "cone", "expression", "version", "attribute", "command", "set", "position", "statement", "engine", "no", "usage", "license", "conn", "con", "condition", "event", "server", "communication", "creation", "location", "pointer", "language", "connect", "machine", "volume", "relation"], "obj": ["inv", "ctx", "err", "output", "tmp", "nt", "onet", "str", "bj", "obb", "utt", "org", "oj", "txt", "tk", "os", "ent", "object", "adj", "arr", "resp", "og", "obo", "dict", "Obj", "msg", "json", "uj", "body", "ref", "js", "po", "objects", "o", "np", "data", "ob", "j", "obs"]}}
{"id1": "4686922", "id2": "6470716", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceTofile", "extractResource2File", "extractResourceAsStream", "extractResourceFromFiles", "extractResourceAsFiles", "extractResourceAsFile", "extractResourcesTofile", "extractResources2Stream", "extractResourcesToStream", "extractResourceToStream", "extractResource2Stream", "extractResourceFromStream", "extractResource2Files", "extractResources2file", "extractResources2Files", "extractResourcesToFiles", "extractResourcesToFile", "extractResourceAsfile", "extractResources2File", "extractResourceToFiles", "extractResourceFromFile", "extractResourceFromfile", "extractResource2file"], "resourcePath": ["Resourcepath", "resourceUrl", "ResourceIn", " resourceName", "attributeUrl", "ResourceName", "attributeName", "templateName", " resourcepath", "ResourceUrl", "attributeLocation", "ResourceLocation", "uriPath", "uriName", "ResourcePath", "uriUrl", "resourcepath", "resourceIn", "uriLocation", "templatePath", "resourceName", "resourceLocation", "attributePath", "templateIn", "templatepath", " resourceIn"], "dest": ["rest", "src", "prop", "des", "comb", "home", "output", "tmp", "dir", "Dest", "etc", "self", "origin", "cat", "loc", "this", "source", "null", "nom", "orig", "end", "img", "gov", "good", "to", "decl", "opt", "result", "sp", "w", "coord", "target", "desc", "dat", "parent", "temp", "trans", "dist", "cont", "mem", "lit"], "in": ["In", "iter", "is", "init", "or", "sin", "conf", "on", "input", "rin", "it", "al", "id", "r", "f", "all", "file", "ln", "IN", "m", "inn", "l", "inside", "inf", "bin", "ins", "source", "from", "inc", "mc", "mi", "up", "ne", "ind", "din", "isin", "none", "no", "re", "cin", "con", "i", "gin", " din", "resource", "raw", "inner", "local", "ini"], "out": ["b", "obj", "at", "OUT", "net", "note", "ou", "cache", "on", "it", "write", "f", "output", "tmp", "nt", "col", "t", "cos", "stable", "oss", "client", "again", "Out", "n", "null", "os", "en", "exit", "cn", "to", "io", "ne", "sys", "outs", "w", " Out", "ch", "writer", "conv", "na", "no", "con", "i", "co", "print", "v", "res", "o", "can", "aos", "outer", "ot", "inner", "pool"]}}
{"id1": "14567939", "id2": "16820041", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 1, "substitutes": {"baseHash": ["BaseHash", "basehash", "BaseKey", "Basehash", "baseSign", "baseKey", "basicHash", "BaseSign", "basicKey", " baseSign", "basichash", " basehash", "basicSign", " baseKey"], "name": ["person", "user", "alias", "title", "id", "search", "info", "address", "author", "login", "current", "common", "key", "Name", "john", "run", "domain", "word", "term", "family", "n", "username", "initial", "default", "named", "ame", "parent", "ident", "NAME", "names", "account", "create", "hash", "admin", "prefix", "order", "local", "table"], "password": ["user", "message", "remember", "sword", "auth", "value", "pass", "Password", "wd", "database", "login", "description", "session", "padding", "entry", "key", "word", "picture", "username", "attribute", "token", "command", "shadow", "crypt", "reset", "hash", "phrase", "prefix", "hello", "secret", "restricted"], "digest": ["decest", "dest", " Diger", "mdEST", "Digester", "decgest", "Diger", "Digum", " Digest", "digester", "mdse", "digEST", "descgest", "dested", " Digend", "descest", "displayEST", "displayested", "diggest", "mdester", "digend", "displayest", "displayum", "digum", " Digester", "mdest", "digested", "Digest", " digend", "diger", "descester", " diger", "Digse", "Diggest", "mdgest", "displayester", "descse", "decester", "dEST", "decested", " digum", "DigEST", "mdested", "descested", "Digested", "Digend", " digester", "digse", "dgest", " digested"]}}
{"id1": "13946197", "id2": "23677142", "code1": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"transformByMD5": [" encryptByMD4", " encryptbymd7", " encryptbyMD5", " encryptBySM7", " encryptBySMTime", " encryptBySM4", " encryptByMDTime", " encryptByMD5", " encryptByMCTime", " encryptbymd5", " encryptByMD7", " encryptbymdTime", " encryptbyMD7", " encryptBymd5", " encryptbyMD4", " encryptBymdTime", " encryptByMC4", " encryptbyMDTime", " encryptBymd4", " encryptBymd7", " encryptByMC5", " encryptBySM5", " encryptbymd4", " encryptByMC7"], "password": ["message", "user", "path", "sword", "auth", "value", "pass", "Password", "wd", "address", "filename", "database", "login", "description", " Password", "padding", "email", "entry", "key", "word", "pattern", "username", "PASS", "token", "command", "text", "w", " passwords", "account", "security", "hash", "data", "name", "phrase", "prefix", "hello", "secret"], "md5": [" MDle", "mand5", "dig3", " MD3", "MD3", "mag3", "dig2", "mdle", "MD10", " md10", "mag2", " md3", "md3", "mag5", "mdhed", "MD2", "mand2", "MD7", " MD2", " MD7", "MD5", "mand10", "mand3", "MDle", "maghed", "MDhed", " MDnt", " mdnt", "mdnt", "md2", " mdle", "md7", " md7", " mdhed", "dig5", "md10", " MD5", "MDnt", " md2"], "output": ["put", "message", "block", "collection", "display", "accept", "ou", "out", "input", "all", "write", "list", "file", "current", "echo", "csv", "answer", "web", "results", "source", "PUT", "exit", " Output", "successful", "batch", " outputs", "document", "result", "view", "hidden", "console", "text", "respond", "OU", "STDOUT", "log", "remote", "line", "buffer", "export", "four", "print", "outer", "response", "data", "column", "Output"], "bufferPass": ["BufferPass", "memoryDe", "batchPass", "bufferCat", "bufferEn", " bufferPASS", "bufEn", " bufferpass", "screenPass", "sequenceAdd", "bufpass", "batchPassword", "bufferpass", "BufferPassword", "bufferAdd", "screenPassword", "bufferDe", "Bufferpass", " bufferCat", " bufferSe", "bufPass", "sequencePass", " bufferAdd", "screenAdd", "screenAss", "bufPASS", "bufferPassword", "bufCat", "bufferAss", " bufferPassword", "memoryPass", "BufferCat", " bufferAss", "bufDe", "sequenceAss", "memoryEn", "BufferPASS", "bufferPASS", "bufferSe", "batchpass", "bufSe", " bufferDe", "memorySe", "sequencePassword", " bufferEn"], "b": ["block", "bit", "k", "ib", "gb", "be", "z", "bp", "db", "r", "m", "bis", "bc", "l", "rb", "cb", "c", "bi", "n", "bg", "a", "p", "u", "h", "batch", "bs", "bound", "bar", "y", "w", "bool", "sb", "e", "nb", "g", "B", "bb", "buffer", "mb", "i", "wb", "fb", "d", "bt", "v", "emb", "o", "base", "blue", "ob", "j"]}}
{"id1": "20855053", "id2": "9398454", "code1": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"init": ["activate", "launch", " Init", "register", "Init", "config", " abort", "construct", " dispatch", " login", " initialization", " reset", "run", "action", " initialized", " initiate", " initiation", " bind", "initialized", "start", "execute", " authorize", " deploy", " prepare", " construct", " refresh", " service", " restart"], "context": ["ex", "ctx", "component", "sc", "application", "config", "bc", "tx", "web", "self", "c", "x", " contexts", "this", "null", "txt", "exc", "h", "state", "w", "chain", "event", "res", "Context", "X"], "classLoader": ["Classloader", " classElf", "ClassLess", "ClassLoader", " classLess", " classParser", " classManager", "urlReader", "classloader", "taskElf", "classParser", "classLess", "ClassReader", "classBuilder", " classReader", "ClassElf", "ClassManager", "urlloader", "urlPath", "ClassPath", "fileParser", " classloader", "fileManager", "taskLess", "ClassBuilder", "ClassParser", "fileLoader", " classPath", "urlLoader", "taskLoader", "fileReader", " classBuilder", "classPath", "classManager", "classReader", "classElf", "taskBuilder"], "urls": ["ls", "urlists", "limls", "longports", "longists", "slies", "normports", "urlls", " urllets", "longs", "slists", "URLs", "norms", "longies", "lps", "limlets", "urps", "urlports", "limxs", "limms", "lims", "URLlets", "normies", "urs", "lxs", "limgs", "URLgs", "urlgs", "urlies", "normists", "urllets", "URLms", "limps", "urlps", "urxs", "slports", " urlms", "sls", " urlgs", "urlxs", "urlms", "lls"], "url": ["b", "ls", "user", "path", "dl", "http", "URL", "lr", "uu", "r", "f", "address", "li", "file", "l", "ur", "link", "str", "browser", "job", "email", "web", "entry", "nl", "org", "req", "loc", "row", "page", "mount", "uri", "util", "char", "rl", "el", "ref", "ret", "mail", "Url", "re", "log", "ssl", "resource", "ul", "res", "base", "location", "bel", "name", "ll", "ob", "rel", "channel", "sl"], "reader": ["read", "driver", "rer", "iter", "Reader", "range", " Reader", "input", "r", "older", "file", "per", "rx", "parser", "loader", "entry", "roller", "peer", "rar", "stream", "row", "dd", "iper", "layer", "er", "rl", "runner", "handler", "ner", "rr", "writer", "reading", "iterator", "buffer", "rot", "resource", "inner", "ro"], "className": ["classNot", "ClassName", "partValue", " classname", "classStart", "titleNot", " classFull", " ClassTitle", "moduleStart", "packagePath", " classTitle", "classLine", "cellRel", "logNAME", "playString", "ClassPath", "CLASSName", "clName", "cellName", " classBody", " classToken", "logname", " ClassNames", "classString", "moduleName", "completeName", "partName", "ClassToken", "stringType", " classNAME", "CLASSNames", "stringString", "classRel", "Classname", "titleLine", "partNAME", "packageName", "moduleString", "ClassRel", " ClassName", "clString", "CLASSFull", "ClassNot", " ClassFull", "cellString", "ClassLine", "ClassData", "classFull", "logName", "playName", "classTitle", " classString", "stringStart", "clRel", "clBody", " classType", "stringName", " classNot", " classPath", "completePath", "classNames", " classValue", "classData", " classRel", "packagename", "playBody", " classNames", "cellToken", "classToken", "moduleType", "classBody", "logValue", " classLine", "clNo", " classNo", "classname", "classNo", "partname", " classStart", "CLASSTitle", "titleString", "classValue", "ClassString", "titleName", "packageData", " classData", "completeRel", "classPath", "classType", "classNAME", "clPath", "playNo"], "clazz": ["cluster", "clade", "glass", "lazz", "lclass", "laz", "glazz", " cluster", "class", "classclass", "classazz", "shazz", "classaz", "glclass", " clace", "lass", "claz", "glaz", "glade", "shade", "gluster", "clace", "shuster", "shace", " clade", "classass", "glace", "clclass"]}}
{"id1": "822452", "id2": "15580610", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrites", "readAndRepWrite", "readAndResWrite", "readAndRewend", "readAndResend", "readAndrewrite", "readAndrewWrite", "readAndResrite", "readAndRewrites", "readAndrewrites", "readAndReprite", "readAndrewend", "readAndRewWrite", "readAndRepend", "readAndReprites"], "inFile": ["InFile", "inputFilename", "docFile", "docFILE", "iFILE", "iFilename", "INTime", "inFILE", "InFilename", "initPlace", "initFilename", "inputPlace", "docTime", "inFace", "outfile", "infile", "iFile", " inFilename", "initFile", "inPlace", "INPlace", "docFilename", " infile", "inTime", "Infile", "initFace", "INFace", "iTime", "INFilename", "INFile", "INFILE", "inputFile", "inputFace", "inFilename", "outFilename"], "outFile": ["reportFile", " outFilename", "checkFilename", "outFILE", "inFILE", "toFILE", "reportFILE", "tofile", "nameFilename", "outfile", "infile", " outFILE", "reportfile", "reportFilename", "toFilename", "namefile", "nameFile", "toFile", "checkFile", " outfile", "checkFILE", "inFilename", "outFilename", "nameFILE", "checkfile"], "iis": [" iris", "iiIs", "liris", "iIS", "eis", "aiis", "Iiss", "liisc", "Ii", "liIs", "liis", "eIS", "iiisc", "ii", " iiss", "iiss", "iiis", "iiris", " iIs", "iIs", " iIS", "diIs", " ii", "iisc", "IIs", "eIs", "aiIS", "dii", "aiIs", "diis", " iisc", "iris", "Iis", "diiss"], "dcmParser": ["dgrParser", " dpmListener", "dpcReader", "dpmAssistant", "DpmReader", "dcrparser", "dcommReader", " dpmarser", "dcmListener", "dmoduleReader", "dmoduleAssistant", " dpmStatement", "dpmLoader", "dmmParser", " dcmarser", " dpmparser", "dcommListener", "deromParser", "dpmBuilder", "dromparser", "dcmAdapter", "dcrParser", "dfmParser", "dpmStatement", "dmmmReader", " dcmLoader", "dcomReader", "dcmBuilder", "dromAssistant", "DpmAdapter", "dcrBuilder", "dpmPrivate", " dcmPar", "dcomBuilder", "dcrReader", " dpmReader", "dcommAssistant", " dpmLoader", " dcmStatement", " dcmAssistant", "dmmarser", "dmmparser", "DcmBuilder", "dpmarser", "dgrStatement", " dcmBuilder", "dmmmparser", "dcmparser", "dcfStatement", "dromReader", "dcmAssistant", "decmParser", " dcmListener", "deromarser", "Dpmparser", "decmReader", "DcmParser", "dpmAdapter", " dpmParser", "dcmStatement", "dgrReader", " dpmPar", "DpmPar", "dmReader", "decmarser", "dpcAssistant", "DpmBuilder", "dmmReader", "decmparser", "drumParser", "dromarser", " dpmBuilder", " dcmPrivate", "dpcParser", " dpmAssistant", "dcmLoader", "DcmReader", "dromParser", "dmmmParser", " dcmparser", "dmmAdapter", "DpmParser", "drumReader", "dfmReader", "dpmReader", "dgrPar", "dcmReader", "dcfReader", "deromReader", "Dcmparser", "deromparser", "dcommParser", "dmparser", "drumPar", " dcmReader", "dcmarser", "dmarser", "dcmPrivate", "dpmparser", "dcmPar", "dmParser", "dmmmAdapter", "dpcPrivate", "dcfPar", "dromListener", "dcomParser", "dmodulePrivate", "DcmAdapter", "drumBuilder", "dfmBuilder", "dfmLoader", "dpmListener", "dcomLoader", "dpmPar", "dmoduleParser", "dpmParser", "dcfParser", "DcmPar", " dpmPrivate"], "ds": ["ls", "cs", "dos", "dl", "gs", "eds", "dh", "ils", "fs", "des", "vs", "ys", "da", "der", "sv", "s", "gd", "dds", "sets", " des", "as", "ads", "hd", "dq", "rs", "uds", "tes", "xs", "df", "os", "details", "ins", "pd", "dd", "services", "in", "bs", "Ds", "ods", "sys", "obs", "outs", "dt", "hs", "pers", " DS", "eps", "its", "js", "dat", "bd", "ps", "dx", "ks", "ss", "drivers", "sd", "d", "aos", "qs", "data", "ws", "DS", "db", "es", "ims", "ns"], "pdReader": ["ddHelper", "ddParser", "pdLoader", "xdHelper", "pdParser", "tdWriter", "xdLoader", "tdRead", "ddLoader", "vdLoader", "pdRead", "dpCar", "dpLoader", "ddWriter", "ddReader", "pdCar", "ddRunner", "dpRunner", "pedReader", "tdParser", "hdParser", "tdReader", "pedLoader", "pedCar", "hdRead", "pdRunner", "vdHelper", "xdReader", "pdHelper", "hdWriter", "ddRead", "xdWriter", "dpReader", "vdReader", "pedRunner", "hdReader", "ddCar", "vdWriter"], "out": ["over", "full", "on", " err", "err", "t", "str", "ins", "p", "ent", "outs", "ch", "writer", "log", "conn", "con", "co", "sum", "sw", "v", "o", "auto", "name", "status", "gen", "inv", "obj", "ex", "ou", "all", "id", "nt", "s", "cb", "c", "end", "txt", "os", "nr", "cn", "in", "desc", "conv", "serv", "raw", "inner", "outer", "pool", "cfg", "at", "net", "tmp", "list", "pos", "Out", "n", "en", "up", "io", "sys", "w", "js", "aos", "res", "data", "we", "OUT", "cache", "it", "output", "oss", "client", "gt", "one", "null", "screen", "go", "cmd", "to", "opt", "flush", "msg", "gr", "inter"], "dcmEncParam": ["dcmEnPar", "dcmEnVal", "dcmencCmd", "dcmEncVal", "dcmEnParam", "dcmencParam", "dcmEscPar", "dmmencParam", "dcmDecParam", "dmmEncCmd", "dcmEncCmd", "dcmencNum", "dmmEncMsg", "dmmencNum", "dmmEncPar", "dcmEncPar", "dcmEscNum", "dmmEnPar", "dcmDecCmd", "dcmEncMsg", "dcmEnNum", "dmmEnNum", "dcmEscVal", "dcmDecMsg", "dcmEscParam", "dmmEncParam", "dmmencCmd", "dmmEnParam", "dmmEncNum", "dcmEncNum", "dcmDecNum", "dcmencPar", "dcmencMsg", "dmmEncVal", "dmmencMsg"], "pdWriter": ["dpEditor", "PDReader", "tdWriter", "dpWriter", "pidWrite", "PDWriter", "pdwriter", "pidWriter", "PDWrite", "tdWriting", "tdReader", "PDEditor", "pidwriter", "pidWriting", "dpWrite", "tdwriter", "pcWriter", "pcWrite", "pdWrite", "pdWriting", "pcwriter", "tdWrite", "pdEditor", "pcWriting", "dpReader", "tdEditor"]}}
{"id1": "20855053", "id2": "804637", "code1": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"init": ["activate", "launch", " Init", "register", "Init", "config", " abort", "construct", " dispatch", " login", " initialization", " reset", "run", "action", " initialized", " initiate", " initiation", " bind", "initialized", "start", "execute", " authorize", " deploy", " prepare", " construct", " refresh", " service", " restart"], "context": ["ex", "ctx", "component", "sc", "application", "config", "bc", "tx", "web", "self", "c", "x", " contexts", "this", "null", "txt", "exc", "h", "state", "w", "chain", "event", "res", "Context", "X"], "classLoader": ["Classloader", " classElf", "ClassLess", "ClassLoader", " classLess", " classParser", " classManager", "urlReader", "classloader", "taskElf", "classParser", "classLess", "ClassReader", "classBuilder", " classReader", "ClassElf", "ClassManager", "urlloader", "urlPath", "ClassPath", "fileParser", " classloader", "fileManager", "taskLess", "ClassBuilder", "ClassParser", "fileLoader", " classPath", "urlLoader", "taskLoader", "fileReader", " classBuilder", "classPath", "classManager", "classReader", "classElf", "taskBuilder"], "urls": ["ls", "urlists", "limls", "longports", "longists", "slies", "normports", "urlls", " urllets", "longs", "slists", "URLs", "norms", "longies", "lps", "limlets", "urps", "urlports", "limxs", "limms", "lims", "URLlets", "normies", "urs", "lxs", "limgs", "URLgs", "urlgs", "urlies", "normists", "urllets", "URLms", "limps", "urlps", "urxs", "slports", " urlms", "sls", " urlgs", "urlxs", "urlms", "lls"], "url": ["b", "ls", "user", "path", "dl", "http", "URL", "lr", "uu", "r", "f", "address", "li", "file", "l", "ur", "link", "str", "browser", "job", "email", "web", "entry", "nl", "org", "req", "loc", "row", "page", "mount", "uri", "util", "char", "rl", "el", "ref", "ret", "mail", "Url", "re", "log", "ssl", "resource", "ul", "res", "base", "location", "bel", "name", "ll", "ob", "rel", "channel", "sl"], "reader": ["read", "driver", "rer", "iter", "Reader", "range", " Reader", "input", "r", "older", "file", "per", "rx", "parser", "loader", "entry", "roller", "peer", "rar", "stream", "row", "dd", "iper", "layer", "er", "rl", "runner", "handler", "ner", "rr", "writer", "reading", "iterator", "buffer", "rot", "resource", "inner", "ro"], "className": ["classNot", "ClassName", "partValue", " classname", "classStart", "titleNot", " classFull", " ClassTitle", "moduleStart", "packagePath", " classTitle", "classLine", "cellRel", "logNAME", "playString", "ClassPath", "CLASSName", "clName", "cellName", " classBody", " classToken", "logname", " ClassNames", "classString", "moduleName", "completeName", "partName", "ClassToken", "stringType", " classNAME", "CLASSNames", "stringString", "classRel", "Classname", "titleLine", "partNAME", "packageName", "moduleString", "ClassRel", " ClassName", "clString", "CLASSFull", "ClassNot", " ClassFull", "cellString", "ClassLine", "ClassData", "classFull", "logName", "playName", "classTitle", " classString", "stringStart", "clRel", "clBody", " classType", "stringName", " classNot", " classPath", "completePath", "classNames", " classValue", "classData", " classRel", "packagename", "playBody", " classNames", "cellToken", "classToken", "moduleType", "classBody", "logValue", " classLine", "clNo", " classNo", "classname", "classNo", "partname", " classStart", "CLASSTitle", "titleString", "classValue", "ClassString", "titleName", "packageData", " classData", "completeRel", "classPath", "classType", "classNAME", "clPath", "playNo"], "clazz": ["cluster", "clade", "glass", "lazz", "lclass", "laz", "glazz", " cluster", "class", "classclass", "classazz", "shazz", "classaz", "glclass", " clace", "lass", "claz", "glaz", "glade", "shade", "gluster", "clace", "shuster", "shace", " clade", "classass", "glace", "clclass"]}}
{"id1": "838844", "id2": "536614", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"convert": ["CONversion", "unvert", "consVERT", "ConVERT", "compvert", "Converts", "compprocess", "Converting", "consversion", "unfer", "Conprocess", "unprocess", "unverts", "CONvert", "conversion", "CONverting", "unverted", "confer", "CONfer", "Confer", "conVERT", "compverts", "Convert", "CONVERT", "CONverted", "consvert", "converts", "consverting", "converting", "compversion", "conprocess", "unversion", "converted", "Converted", "Conversion"], "src": ["SOURCE", "path", "rest", "sin", "http", "input", "url", "Source", "sc", "usr", "filename", "func", "pkg", "file", "ser", "config", "rx", "sr", "ource", "s", "rc", "buster", "ur", "str", "cc", "sq", "inst", "req", "stream", "ins", "rs", "source", "from", "txt", "host", "loc", "orig", "img", "hl", "uri", "addr", "href", "attr", "sys", "ebin", "st", "ipl", "scene", "its", "upload", "iv", "dist", "cont", "start", "cur", "rel", "RC", "SourceFile", "scan", "sit"], "dest": ["rest", "write", " Dest", " dst", " destinations", " orig", "dir", "Dest", "test", "tif", "source", "txt", "orig", "img", " destination", "est", "result", "target", "mat", "port", " Destination", "dat", "temp", "foreign", "disk", "dist", "gin", "table"], "in": ["In", "b", "ad", "is", "input", "rin", "sql", "r", "file", "m", "IN", "inn", "reader", "l", "inf", "bin", "as", "ar", "stream", "ins", "source", "from", "en", "up", "io", "el", "ind", "st", "din", "isin", "cin", "serv", "i", "d", "inner", "res"], "p": ["b", "pt", "at", "pp", "ph", "parse", "wp", "tp", "vp", "pa", "it", "dp", "r", "f", "pm", "m", "per", "fp", "pkg", "php", "pc", "t", "pre", "l", "parser", "prot", "c", "cp", "py", "pro", "pe", "pd", "h", "ping", "er", "op", "part", "j", "sp", "rep", "pers", "post", "g", "ps", "jp", "i", "d", "pi", "P", "lp", "pl", "ap", "pg", "pb"], "ds": ["cs", "eds", "ts", "tags", "gd", "ags", "ads", "hd", "uds", "pd", "bs", "outs", "eps", "ports", "ss", "edes", "workers", "DS", "nas", "cks", "ils", "amps", "des", "ats", "s", "ras", "iffs", "os", "hs", "aws", "tests", " d", " ads", "sd", "db", "scripts", "terms", "sets", "ns", "ls", "dos", "gs", "dl", "lists", "dh", "tp", "docs", "dp", "ands", "vs", "dds", "sts", "dates", "rs", "xs", "df", "dt", "mys", "posts", "its", "js", "els", "drivers", "ws", "di", "obs", "points", "ys", " os", "loads", " des", " dd", "tes", "dd", "Ds", "ods", " DS", "ps", "ks", "d", "yes", "qs"], "format": ["feat", "path", "at", "template", "title", "parse", "MAT", "id", "it", "type", "f", "mt", "output", "lat", "file", "ats", "fc", "t", "l", "pretty", "mode", "top", "feature", "size", "source", "Format", "ct", "unit", "act", "pattern", "layout", "settings", "version", "spec", "policy", "set", "sche", "mat", "style", "form", "shape", "fm", "module", "cf", "pi", "name", "tag", "status", "filter", "table", " Format"], "hasPixelData": ["hasixeldata", " hasPixelDATA", "HasPixelData", "hasFrameData", "hasFramedata", "hasPixeldata", "haspixeldata", "HaspixelDATA", "Haspixeldata", "HaspixelData", "HasPixelDATA", "hasPixelDATA", "haspixelDATA", "haspixelData", "hasixelDATA", "hasFrameDATA", "HasPixeldata", " hasPixeldata", "hasixelData"], "inflate": ["invalidate", "inFlicate", "Inflocate", "Informat", "inflocate", "inFlATE", "Inflat", "informate", "Informate", " invalidate", "invalidicate", "inFlate", "inFLate", "infolated", " inflocate", "Inflated", "informated", " invalidATE", "infolocate", "inflated", "inFLat", "invalidATE", "Informocate", "inFLocate", "incelATE", "inFlocate", " inflicate", "informocate", "Inflate", "inflATE", "incelocate", "informat", "invalidocate", "incelicate", " invalidicate", " invalidocate", "infolate", "inflicate", "inFLated", "Informated", "infolat", " inflATE", "incelate", "inflat"], "pxlen": ["phpdec", "pxden", "mmlen", "phplen", "pxln", "mxdec", "pixells", "packfun", "pxlin", "pexln", "tmplength", "mxlen", "pexfun", "cplength", "pxdec", "mmln", "tmpln", "xylength", "packdec", "xplen", "pexlen", "pixellen", "packlength", "pexlength", "tmplin", "xpden", "pexls", "pixelfun", "xyln", "packls", "packlen", "cpln", "mmlength", "mmlin", "phplength", "cpden", "xylen", "tmplen", "phpln", "pxfun", "pxlength", "xpln", "xplength", "mxln", "mxlength", "pexden", "packln", "xylin", "pixellength", "pxls", "cplen"], "out": ["inv", "obj", "user", "ex", "group", "init", "OUT", "net", "ou", "store", "err", "output", "list", "ln", "dir", "pretty", "client", "Out", "crit", "screen", "gov", "cmd", "up", "io", "sys", "outs", "msg", "writer", "log", "temp", "conn", "gr", "sum", "print", "aos", "res", "outer", "inter", "name", "prefix", "cfg"]}}
{"id1": "2324868", "id2": "19739421", "code1": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"actionPerformed": ["actionExecuted", "actionPerceived", "actionPerform", " actionPerceived", " actionOccuted", "actionExecform", "actionExecceived", "actionExecformed", " actionPerform", " actionTransform", " actionOccform", " actionExecuted", " actionExecformed", " actionExecceived", " actionTransformed", " actionExecform", " actionPeruted", "actionPeruted", " actionTransceived", " actionOccceived", " actionOccformed", " actionTransuted"], "e": ["b", "ce", "or", "m", "t", "se", "cb", "n", "a", "events", "ed", " event", "er", "ea", "w", "E", "te", "ie", "es", "ef", "re", "ec", "event", "v", "o", "Event", "ev", "ee"], "delim": ["delam", " delimeter", " deliter", "dlim", "separiter", "Delam", " delimm", "separimeter", " delam", "delimeter", "dram", "drib", " delib", "Delim", "Delimm", "dlif", "Delib", "separif", "dliter", "delimm", "drimm", " delif", "delib", "drim", "deliter", "delif", "separim", "dlimeter"], "r": ["dr", "vr", "lr", "it", "usr", "m", "reader", "rx", "sr", "rc", "rt", "rb", "l", "rate", "ur", "rg", "pr", "c", "rar", "n", "rs", "kr", "rw", "br", "p", "nr", "rn", "rl", "er", "tr", "cr", "rr", "w", "R", "re", "rd", "d", "res", "mr", "hr", "fr"], "line": ["LINE", "user", "range", "block", "liner", "online", "check", "ste", "out", "lo", "pass", "ln", "file", "stroke", "frame", "ine", "l", "ode", "eline", "cell", "string", "link", "inline", "record", "entry", "lin", "nl", "word", "run", "detail", "row", "stream", "le", "page", "Line", "handle", "ole", "sequence", "text", "log", "mail", "ice", "chain", "lines", "raw", "base", "sample", "node", "comment", "point", "normal"], "url": ["ls", "dl", "cert", "net", "http", "URL", "open", "gb", "api", "f", "abs", "l", "ur", "link", "str", "gl", "https", "browser", "client", "web", "org", "nl", "loc", "blog", "hl", "lb", "uri", "addr", "rl", "ref", "ret", "build", "Url", "log", "ssl", "ul", "bel", "base", "rel", "ll", "hub", "sl"], "conn": ["inv", "obj", "dl", "Conn", "net", "Connection", "ctx", "cert", "secure", "yn", "open", "comm", "write", "nt", "sync", "ln", "https", "ann", "client", "cb", "cl", "org", "c", "nl", "fin", "loc", "n", "ait", "close", "cp", "nec", "cn", "ct", "cmd", "resp", "addr", "canon", "rn", "nc", "socket", "ch", "enc", "conv", "dial", "ctrl", "con", "jp", "ssl", "connection", "nw", "syn", "res", "cur", "rel", "connect", "ws", "db", "ns", "pas"], "wr": ["dr", "wy", "spr", "wrote", "vr", "wp", "tw", "write", "wm", "wn", "mt", "wi", "ln", "writers", "wa", "wer", "pr", "wx", "Wr", "tn", "fn", "rew", "kr", "rw", "writ", "WR", "rn", "ell", "resp", "pipe", "wl", "fw", "vet", "iw", "w", "wt", "writer", "kl", "Writer", "RW", "wb", "rex", "nw", "sw", "mr", "wk", "ws", "mg", "wire", "ev", "fr", "we"], "tokens": [" tOKENS", "tikENS", " tokeds", "Tokwords", "Tokers", "todonds", "toksonds", "toksets", "todkens", "tokskens", "tokwords", "Tokets", "todens", "stokkens", "tookets", "stodkens", "tikens", " tokENS", "toksers", "tikeds", "tokswords", "takaens", "takawords", "takaers", "todets", "stokonds", "tikents", " tokents", " tOKents", "tookkens", "stodonds", " tOKeds", "todENS", "stodens", "stokets", "tocens", "Toksets", "Toksens", "tOKents", "tokents", "stodets", "tocwords", "tookens", "tookonds", "Toksers", "tokers", "tokkens", "tokets", "Tokswords", "tokonds", "todeds", "tokENS", "Tokens", "tocets", "tokeds", "stokens", " tOKens", "tocers", "tOKENS", "toksens", "tOKens", "takaets", "tOKeds", "todents"], "in": ["In", "read", "iter", "is", "ill", "on", "out", "input", "it", "all", "win", "rin", "err", "ma", "IN", "inn", "reader", "l", "inf", "bin", "irm", "ar", "ins", "null", "inc", "mc", "from", "en", "ic", "io", "ind", "body", "din", "mm", "cin", "con", "mn", "i", "gin", " din", "inner", "ini"]}}
{"id1": "5759961", "id2": "16549995", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"saveUser": [" enrichuser", "saveGroup", " manipulateGroup", "saveuser", " saveuser", " manipulateAccount", " enrichAccount", " manipulateuser", " saveAccount", "saveAccount", " enrichGroup", " enrichUser", " saveGroup", " manipulateUser"], "user": ["person", "message", "item", "auth", "or", "cert", "us", "store", "human", "ver", "update", "url", "info", "usr", "force", "write", "responsible", "project", "author", "file", "login", "per", "use", "add", "actor", "load", "client", "record", "email", "test", "job", "entry", "USER", "rule", "word", "row", "this", "User", "object", "u", "char", "used", "version", "username", "password", "result", "owner", "uid", "report", "post", "by", "e", "get", "usage", "me", "account", "server", "content", "print", "v", "base", "create", "profile", "data", "name", "replace", "response", "ro", "table"], "digest": ["Digester", " digEST", "compress", "mdse", "digester", "digEST", " digress", "digress", "hashEST", "hashested", " digse", "mdester", "compest", "mdest", "digested", "Digest", "compested", "readested", "hashests", "readse", "readest", "digests", "Digse", "hashester", " digests", "readester", "DigEST", "mdested", "Digested", "compests", " digester", "hashress", "digse", "hashest", " digested"], "hash": ["block", "check", "full", "init", "cache", "number", "id", "search", "type", "ash", "hed", "ashes", "mac", "add", "count", "test", "html", "size", "key", "mask", "h", "num", "handle", "char", "version", "password", "sh", "uh", "height", "result", "sha", "has", "hex", "dig", "Hash", "rh", "max", "sum", "her", "tag", "index"], "bigInt": [" bigLong", "BigInt", "hugeint", "bigINT", "pgINT", "bigLong", "littleint", "pgint", "bigInteger", "hugeLong", "BigInteger", "bigint", " bigint", "hugeInteger", "littleInt", "pgInt", "hugeInt", "littleINT", "longINT", "longint", "BigLong", "Bigint", " bigInteger", "longInt"], "hashtext": ["hexvalue", "shatext", "Hashinfo", "hexpath", " hashread", "hashread", "hexread", "Hashfunction", "shatxt", "hashtxt", "ashtext", "Hashstr", "ashtxt", "sumstr", "ashstr", "hashinfo", " hashstr", "hextext", "hashText", "Hashtext", " hashtxt", " hashinfo", "ashText", " hashText", "sumpath", "sumText", "ashread", "hextxt", "HashText", "sumfunction", "shaText", "hashpath", "Hashpath", "hashvalue", "sumtext", "shavalue", " hashvalue", "hexText", "hashstr", "ashinfo", "hashfunction", " hashfunction"]}}
{"id1": "20028790", "id2": "12197169", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "label": 1, "substitutes": {"setBundleInfoName": ["setBundleInfTitle", "setBundleInfNames", "setBundleFileName", "setBundleFileNames", "setBundleFileLabel", "setBundleDataNames", "setBundleDataLabel", "setBundleInfLabel", "setBundleInfoLabel", "setBundleDataTitle", "setBundleFileTitle", "setBundleDataName", "setBundleInfoNames", "setBundleInfName", "setBundleInfoTitle"], "location": ["library", "path", "message", "Location", "template", "where", "address", "filename", "translation", "description", "reference", "ocation", "l", "program", "availability", "country", "directory", "loc", "color", "uri", "area", "layout", "document", "command", "position", "LOC", "remote", "history", "resource", "language", "name", "comment", "point", "local", "localhost"], "list": ["block", "dl", "collection", "net", "lists", "out", "all", "m", "map", "ist", "add", "l", "L", "missing", "detail", "n", "p", "batch", "listed", "spec", "sequence", "set", "stack", "LIST", "chain", "print", "v", "local", "level", "name", "status", "pool", "table"], "url": ["b", "dl", "http", "URL", "lr", "r", "gb", "f", "open", "abs", "l", "ur", "link", "str", "browser", "job", "google", "html", "nl", "loc", "hl", "lb", "mount", "uri", "char", "rl", "el", "sb", "ref", "mail", "Url", "build", "ssl", "ul", "bel", "base", "rel", "ll", "pl", "sl"], "br": ["b", "read", "bro", "dr", "bridge", "lr", "bp", "r", "be", "gb", "bl", "sr", "rb", "str", "browser", "pr", "nl", "ber", "next", "kr", "bs", "er", "BR", "tr", "div", "cr", "ch", "wr", "bh", "Br", "bd", "buf", "gr", "bt", "mr", "rel", "hr", "fr"], "line": ["message", "LINE", "block", "header", "liner", "online", "iter", "trace", "note", "store", "lo", "sql", "ln", "inline", "l", "ine", "frame", "string", "eline", "cell", "se", "record", "link", "lock", "entry", "lin", "nl", "rule", "word", "linux", "row", "next", "page", "source", "label", "le", "detail", "Line", "handle", "char", "part", "sequence", "text", "body", "style", "log", "chain", "buffer", "stay", "piece", "print", "code", "sample", "data", "name", "phrase", "point", "comment"], "pos1": ["position3", "index3", "positionone", " posOne", "po3", "Pos1", "posone", "position2", "pos2", "POS1", "pos3", "POS0", "position1", "position0", "pos0", "indexOne", "PosOne", "POSOne", "Pos0", " pos2", "poOne", "po1", "Pos2", "posOne", "index1", "poone", "POS2", "indexone", "positionOne", " pos0"], "bundleSymbolicName": ["bundleSyMBolicType", "bundleSymbololicNames", "bundleSymbolicalFamily", "bundleSymbolicalName", "bundleSymbularFamily", "bundleSyMBicalType", "bundleSymboryNames", "bundleSyMBicalname", "bundleSymbicalVersion", "bundleSymbololicFamily", "bundleSymbolicCode", "bundleSymbularType", "bundleSymboryname", "bundleSyMBicalVersion", "bundleSyMBolicCode", "bundleSymbicName", "bundleSymbolicalType", "bundleSymbicalFamily", "bundleSymbularname", "bundleSyMBicalNames", "bundleSymbicalName", "bundleSymbolicname", "bundleSyMBicalCode", "bundleSymbolicNames", "bundleSymbolicalNames", "bundleSymbolicVersion", "bundleSymbololicType", "bundleSymbicCode", "bundleSymboryName", "bundleSymbicalNames", "bundleSyMBicalName", "bundleSyMBolicName", "bundleSymbicNames", "bundleSyMBolicNames", "bundleSymbololicName", "bundleSymbolicType", "bundleSyMBolicVersion", "bundleSymbicalname", "bundleSymboryType", "bundleSymbicalType", "bundleSymbicalCode", "bundleSymboryCode", "bundleSymbolicFamily", "bundleSymbularName", "bundleSymbicVersion", "bundleSymboryVersion", "bundleSyMBolicname", "bundleSymbularNames"], "bundleName": ["basketname", "fasketType", "fasketname", "brundleInfo", "branchname", " banchname", "branchInfo", "balename", " banchName", "banchName", "fundlename", "bowerInfo", "bowerString", "bowerName", "basketVersion", "baleType", "bowerType", "banchname", "brundleName", "fundleName", "bachmentname", "bundleInfo", "brundlename", "banchInfo", "fundleVersion", "bundleType", "bachmentInfo", "branchName", "bundleVersion", "fasketName", "baleInfo", "basketName", "fasketVersion", "baleVersion", "bachmentName", " bundlename", "fundleType", "basketType", "banchString", " banchInfo", "bundleString", " bundleInfo", "brundleString", "bowername", "baleName", "bowerVersion", "bundlename", "branchString"], "info": ["dev", "user", "match", "iter", "block", "check", "item", "tip", "value", "http", "conf", "note", "all", "update", "query", "INFO", "information", "iso", "context", "f", "alias", "error", "instance", "tf", "fo", "inf", "job", "summary", "entry", "self", "ext", "image", "detail", "fit", "details", "def", "state", "json", "Info", "report", "te", "me", "history", "i", "event", "inner", "now", "data", "comment", "status", "index", "obj", "local"]}}
{"id1": "7911686", "id2": "20886320", "code1": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"copyFile": [" cpStream", " cpFiles", "copyFiles", " cpFile", " CopyFiles", " CopyFile", "CopyFile", "CopyStream", " Copyfile", "CopyFiles", " CopyStream", " cpfile", "copyStream", "Copyfile", "copyfile"], "source": ["SOURCE", "init", "template", "src", "store", "input", "search", "query", "Source", "subject", "iso", "file", "core", "ource", "seed", "ink", "se", "string", "origin", "image", "from", "scope", "site", "spec", "sequence", "scene", "body", "target", "style", "parent", "remote", "me", "resource", "start", "sample", "base", "status", "service"], "destination": ["identinator", "destinated", "spination", "identino", "combacement", "combinations", "spacement", "combino", "declinator", "declination", "identinations", "combinated", "declino", "destinator", "spinated", "spino", "declinations", "destacement", "combination", "declacement", "combinator", "destinations", "destino", "identination", "declinated"], "in": ["In", "read", "pin", "is", "init", "or", "sin", "net", "input", "rin", "al", "win", "it", "r", "f", "all", "login", "ain", "IN", "ma", "inn", "ln", "t", "s", "l", "exec", "inside", "ai", "bin", "client", "include", "vin", " IN", "ins", "n", "from", "inc", "en", "mi", "ini", "to", "up", "ind", "im", "din", "ca", "isin", "min", "by", "an", "re", "no", "cin", "con", "conn", "i", "gin", "co", "internal", "inner", "can", "index", "local", "doc"], "out": ["b", "obj", "user", "ex", "at", "or", "net", "OUT", "note", "ou", "on", "cache", "it", "write", "output", "nt", "file", "rem", "t", "cos", "oss", "client", "gt", "Out", "n", "null", "one", "os", "ent", "en", "not", "cn", "cmd", "to", "up", "io", "ne", "sys", "op", "outs", "result", "msg", "w", "ch", "conv", "na", "no", "serv", "conn", "con", "co", "inner", "aos", "v", "o", "outer", "can", "ot", "channel", "ns", "un"]}}
{"id1": "20717531", "id2": "23335922", "code1": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 1, "substitutes": {"encrypt": ["decrypt", "encrypted", "encipher", "decipher", "uncrypted", "Encrypt", "Encryption", "uncryption", "uncrypt", "encryption", "Encrypted", "decryption", "decrypted", "uncipher", "Encipher"], "plainText": ["realSource", "ainDelete", " plainTextColor", "formText", " plainOutput", "ainData", "plainDelete", "realtext", "leadTEXT", "realTEXT", "broadTEXT", "publictext", "formtext", "ainWord", " plainName", "publicData", "publicText", " plainPath", "leadtext", "plainTextColor", "tableUrl", "floatDelete", "plainSource", "broadText", "ainTextColor", "ainText", "plainPassword", "longText", "hardtext", "broadPassword", "ainTEXT", "longTextColor", "ainString", " plainTEXT", "leadPath", "plainData", "longTEXT", "plainName", "longSource", "plainConfig", "hardTEXT", " plaintext", "broadDelete", "longtext", "plainPath", "ainOutput", "ainUrl", "floatTEXT", "cleanTEXT", "tableTEXT", "cleanText", "realText", "ainPath", " plainConfig", "plaintext", "ainPassword", "plainTEXT", "longString", "plainOutput", " plainData", "hardWord", "ainConfig", "tableConfig", "plainUrl", "ainName", "plainString", " plainSource", " plainString", "aintext", "hardText", "cleanName", "formTEXT", "floatPassword", "leadText", "cleantext", "formWord", "publicOutput", "tableText", "floatText", "plainWord", " plainUrl"], "text": ["read", "path", "message", "template", "format", "net", "title", "tt", "input", "all", "aut", "write", "binary", "select", "output", "translation", "nt", "quick", "t", "left", "ut", "tx", "cat", "ext", "word", "TEXT", "quote", "image", "txt", "source", "end", "struct", "ct", "act", "ind", "view", "writer", "log", "process", "buffer", "cont", "math", "content", "sum", "print", "event", "start", "Text", "prefix", "comment"], "i": ["my", "xi", "f", "I", "t", "asi", "uni", "ai", "ix", "hi", "ri", "p", "mi", "u", "phi", "iu", "v", "ei", "o", "ip", "is", "init", "cgi", "id", "z", "oi", "ki", "x", "ii", "multi", "ic", "in", "sim", "chain", "zi", "ti", "point", "ui", "ini", "iter", "qi", "\u0438", "ci", "li", "m", "iy", "gu", "n", "io", "im", "g", "print", "cli", "j", "index", "di", "ims", "ami", "ni", "us", "gi", "it", "ski", "bi", "q", "uri", "eu", "y", "ity", "ori", "ji", "si", "yi", "pi", "ms"], "mDigest": ["mHashum", "mHashested", "mdigse", "mExecum", " mDigger", "mDigester", "mMDse", "MDigse", "mDher", "mFindse", " mDigum", " mDigher", "mDose", "MDigest", "mFindgest", "mHashger", "mMacse", "mMacested", "mDigse", "mdigest", "mDigested", "mdigher", "mFindest", " mDher", "mdigested", "Mdiggest", " mDigester", " mHashested", " mHashest", "mDse", "mDigher", "mDiger", "mMDer", " mDest", " mDigse", "mdigum", "mDoested", "Mdiger", "mFinder", "mExecest", "mdigester", "mDested", "mExecger", " mHashger", " mDigested", "mDest", "mDigger", "mExecested", "mHashest", " mHashum", "mdigger", " mDested", " mDse", "MDiggest", "mdiger", "mDoest", "mMacester", "mdiggest", "mDester", " mDester", "Mdigse", "mMDest", "mMDgest", "MDiger", "mMacest", "Mdigest", "mDiggest", "mDoher", "mDigum"], "d": ["b", "nd", "cd", "D", "dh", "ds", "with", "r", "f", "da", "m", "fd", "t", "s", "l", "md", "done", "x", "de", "dc", "c", "n", "a", "df", "p", "u", "h", "dd", "pd", "ed", "dict", "dot", "j", "y", "w", "dec", "dat", "g", "ld", "e", "bd", " D", "dx", "sd", "v", "db", "di", "diff"], "hash": ["message", "block", "header", "check", "hz", "flash", "dh", "shift", "cache", "all", "id", "search", "array", "save", "ssh", "ash", "always", "checked", "ah", "summary", "oh", "test", "html", "our", "key", "random", "radius", "h", "handle", "dict", "href", "password", "sh", "tr", "shadow", "div", "style", "report", "sha", "hex", "Hash", "rh", "buffer", "total", "sum", "print", "code", "her", "tag", "filter", "square", "table"]}}
{"id1": "2168610", "id2": "15810440", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"update": ["put", "equal", "draw", "out", "offset", "where", "find", "info", "grade", "current", "add", "fill", "size", "continue", "u", "batch", "set", "edit", "report", "get", "resource", "status", "commit", "change", "user", "init", "value", "id", "write", "save", "select", "login", "UPDATE", "run", "row", "num", "handle", "result", "state", "updated", "insert", "date", "now", "diff", "check", "database", "count", "send", "load", "dates", "exit", "action", "up", " UPDATE", "print", "ul", "latest", "index", "Update", "http", "component", " Update", "use", "touch", "op", "msg", "delete", "remove", "create", "call"], "o": ["obj", "ilo", "aco", "out", "lo", "k", "iso", "onet", "oco", "m", "t", "l", "bo", "fo", "c", "n", "mo", "a", "os", "p", "object", "oid", "om", "q", "h", "ao", "to", "O", "oin", "oo", "po", "e", "i", "cont", "co", "oa", "ob", "ooo"], "contact": ["message", "match", "group", "check", "aco", "pp", "format", "title", "impact", "display", "panel", "component", "responsible", "info", "force", "address", "comm", "translation", "config", "acts", "add", "phone", "l", "consider", "cell", "country", "client", "cc", "entry", "character", "international", "detail", "lead", "ACT", "details", "conduct", "close", "cp", "action", "ct", "act", "compliance", "control", "char", "Contact", "addr", "work", "company", "charge", "report", "form", "port", "mail", "controller", "trans", "fax", "cont", "connection", "content", "print", "communication", "transfer", "module", "claim", "hello", "att", "service", "CONT"], "pst": ["jply", "bpst", "jpsy", "pct", "phpstal", "pnt", "phpnt", "vply", "epnt", "pingth", "jpSt", "Prest", "pingstal", "vpct", " pnt", "preth", " pST", "post", "pest", "lST", " pstan", "ipsth", "PST", "ipth", "epct", "epstal", "pstra", "lst", "jpset", "pth", "pstal", "pingst", "jpct", "pstan", " pstra", "bpost", "jpmt", "prst", "psta", "jpster", "pect", "dct", "pmt", "epst", "prect", "ipmt", "prct", "lse", "dpct", "pse", "ply", "presta", "Pse", "pingstra", "jpst", "apost", "drest", " pster", "pingct", "tpstal", " pct", " pmt", "tpst", "ppt", " post", "tpct", "dpst", "apst", "pST", "lct", "vpset", "ipct", "preSt", "psth", "presth", " psy", "bpstan", "dpt", "Ppt", "apstan", "prST", "dpster", "pster", "ipSt", "pingsta", "perest", "dpsy", "bpSt", "jpST", " pSt", "pset", "prest", "ipsta", "psy", "phpct", "vpst", "Pct", "phpst", "apSt", "pept", "ipST", "prse", " ply", "pingSt", " psth", "Pst", "dst", "pSt", "ipst", " pstal", "tpstra", " pset"]}}
{"id1": "5125848", "id2": "755203", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"combineJs": ["Combinejs", "combinatejs", "combINELink", "CombineJS", "Combosejs", "combinateLink", "combosejs", "ComboseJS", "comboseJS", "combINEJs", "CombineJs", "comboseLink", "combineJS", "combINEJS", "combINEjs", "combinateJs", "ComboseJs", "combineLink", "ComboseLink", "combinejs", "CombineLink", "combinateJS", "comboseJs"], "base": ["b", "template", "id", " based", "address", "api", "relative", "bas", "file", "Base", "root", "absolute", "origin", "domain", "source", "from", " Base", "host", "bottom", "page", " basis", "uri", "bid", " bases", "bound", "site", "re", "ase", "buffer", "server", "based", "start", "data", "prefix", "db", "local", "reset"], "linkJs": ["Linkjs", "LinkTags", "inkLinks", "linkLinks", "linkedScript", "inkJS", "inkjs", "inkScript", "linkjs", "linkedJS", "LinkJs", "linkedJs", "LinkJS", " linkScript", "inkTags", "linkedLinks", " linkTags", " linkjs", "inkJs", "linkJS", " linkJS", "linkTags", "linkScript", " linkLinks"], "newFiles": ["nextFiles", "newDocuments", "linkLinks", " newfiles", "linkDocuments", "nextLinks", "newLinks", "newfiles", "linkfiles", " newLinks", " newDocuments", "nextfiles", "linkFiles", "nextDocuments"], "dir": ["dl", "dep", "dr", "cd", "out", "DIR", "id", "fs", "wd", "tar", "vol", "tmp", "lib", "pkg", "file", "fd", "mk", "zip", "md", "done", "lock", "DB", "directory", "root", "Dir", "ir", "loc", "created", "dd", "def", "good", "manager", "area", "addr", "sys", "div", "mod", "folder", "desc", " Dir", "ref", "temp", "disk", " d", "module", "d", "local", "auto", "rel", "db", "di", "diff", " directory", "doc", "dm"], "name": [" manager", " tmp", " self", " err", " vm", " prefix", " log", " os", " scanner", " browser", " report", " b", " cleaner", " loader", " parser", " dummy", " rebuild", " start", " logger", " names", " karma", " filename", " bar", " info", " msg", " res", " str", " db", " foo"], "minDir": ["smallDir", " minTier", "thinJar", " minPref", " minJar", "smallLoc", "skinDb", "miniTrans", "MinFile", " minTrans", "smallDb", "thinTrans", "minPref", " minFile", "thinDir", "smalldir", " minDar", "minutePref", "smallNet", "sortPref", "minuteRel", "MinNet", "mainDb", "sortDar", "minTrans", "miniTier", "minRel", "minuteDir", "minDar", "sortDir", "minTier", "maindir", "skinLoc", "mainDir", "MinDir", "minuteDar", "minLoc", "sortRel", "thinTier", "smallFile", "minJar", "mindir", "skinDir", "minNet", "mainLoc", "minFile", " minRel", "skindir", "miniDir", "miniJar", " minNet", "minDb"], "combineFile": ["combINESet", "cominateEmail", "coordINESet", "coordINEFile", "combineEmail", "comboiceEmail", "comboseFile", "coordINEWriter", "coordineSet", "comboseWriter", "coordinefile", "combinfile", "comboseSet", "combinatefile", "coordineWriter", "cominatefile", "combinefile", "comineFile", "comboicefile", "combinerMessage", "combinateMessage", "combinateEmail", "combinerFile", "comineEmail", "comineMessage", "cominefile", "combinateFile", "cominateFile", "combinSet", "combinerEmail", "coordineFile", "combINEfile", "combineSet", "combosefile", "combINEWriter", "combinerfile", "coordINEfile", "combinWriter", "cominateMessage", "combineMessage", "comboiceFile", "comboiceMessage", "combINEFile", "combinFile"], "concatFile": ["comcFilename", "convertFilename", "convertTable", "comcatFilename", "concatfile", "comcatFile", "covertFile", "comcatDir", "cocatTable", "cocatfile", "comcDir", "concDir", "concapfile", "conatFiles", "conCatFile", "concapTable", "concatDir", "convertDir", "convertfile", "concatFiles", "covertTable", "concapFiles", "conatFile", "comcFile", "convertFiles", "cocatFile", "conatTable", "concFile", "covertfile", "concatFilename", "convertFile", "covertFiles", "cocatFiles", "conCatFilename", "conatfile", "conCatDir", "concatTable", "concapFile", "concFilename"], "combineWriter": ["combenWriter", "declineReader", "combieFile", "CombineWrite", "combinateReader", "combineCounter", "declinateWrite", "comboseFile", "Combinewriter", "comboseWriter", "combineReader", "combinatewriter", "comboseWrite", "combinateWrite", "combinewriter", "combinateWriter", "combineWrite", "comboseReader", "combieWriter", "declinateReader", "comboseCounter", "ComboseCounter", "combinateCounter", "declinateWriter", "Combosewriter", "declineWriter", "CombineCounter", "combinateFile", "combieReader", "declineWrite", "combieWrite", "combenCounter", "CombineWriter", "ComboseWrite", "combosewriter", "declineFile", "declinateFile", "combenwriter", "combenWrite", "ComboseWriter"], "concatWriter": ["concatWrite", "concatsWrite", "comcatFile", "convertWrite", "coatWrite", "conatWrite", "cocatWrite", "conatReader", "comcatWriter", "concatReader", "coatFile", "comcatReader", "cocatWriter", "conatFile", "concatsFile", "comvertWriter", "comvertReader", "coatWriter", "cocatReader", "cocatFile", "convertReader", "concatsReader", "comcatWrite", "conatWriter", "concatsWriter", "comvertFile", "coatReader", "convertFile", "comvertWrite", "convertWriter"], "fails": ["frils", "fils", "Fails", "mailed", "ifailed", "Failing", "ifailing", "lailing", "frails", " failed", "Failed", "malls", "focks", "lailed", "lails", " failing", "mailing", " falls", "mails", "facocks", "lils", "ifails", "Fils", "falls", "mocks", " focks", "frailed", "facails", "facailed", "frailing", "failed", "facailing", "failing", "lalls", "ifocks"], "link": ["match", "script", "check", "links", "display", "open", "address", "li", "ln", "task", "map", "mark", "ink", "l", "add", "inline", "load", "push", "linked", "self", "c", "follow", "loc", "source", "close", "share", "set", "embed", "Link", "log", "remote", "line", "code", "skip", "node", "relation", "child"], "path": ["alias", "Path", "match", "template", "format", "src", "full", "prop", "id", "input", "relative", "file", "join", "string", "str", "root", "PATH", "key", "entry", "image", "loc", "route", "source", "p", "uri", "pattern", "href", "text", "style", "ref", "ath", "hex", "kind", "resource", "location", "data", "prefix"], "url": ["ls", "http", "URL", "lr", "id", "r", "address", "li", "request", "abs", "l", "ur", "str", "string", "browser", "gl", "web", "html", "nl", "loc", "this", "null", "source", "hl", "host", "uri", "addr", "char", "il", "href", "ref", "get", "mail", "Url", "build", "ssl", "resource", "ul", "location", "rel", "ll", "mount", "sl"], "inputStream": ["inputSet", " inputSteam", "inStream", "InputTime", "InputSet", "instream", "Inputstream", "inputStyle", "inSet", " inputSet", "inTime", "InputStream", "outputStyle", " inputStyle", "inputTime", "outputstream", " inputstream", "outputSteam", "inputSteam", " inputTime", "inputstream", "InputSteam", "InputStyle"], "jsFile": [" jsfile", "jsFilename", "jsTable", "javascriptTable", "cssFilename", "JsFilename", "javascriptFile", "jsfile", "javascriptfile", "cssfile", "jFile", "javascriptPath", "javascriptFilename", " jsName", "cssFile", " jsFilename", " jsTable", "jName", "jPath", "cssTable", "cssPath", "javascriptName", "jsPath", "JsPath", "jsName", "JsFile", "Jsfile", "jFilename", " jsPath"], "fileName": ["getHash", " fileHash", "Filename", "filePath", "getName", "FilePath", "fileHash", "FileName", "getPath", "filename", " filePath", "FileHash", " filename", "getname"], "outputStream": [" outputStyle", "writeStream", "inputForm", "writeSet", " outputSet", "inputStyle", "outputForm", " outputSteam", "OutputSteam", "outputStyle", "OutputSet", "OutputStyle", "OutputStream", "writestream", "outputstream", "writeSteam", "outputSet", "outputSteam", "inputSteam", " outputForm", "inputstream", "Outputstream", " outputstream", "OutputForm"], "first": ["front", "prev", "all", "then", "open", "false", "real", "quick", "current", "same", "second", "natural", "send", "third", "success", "true", "top", "self", "continue", "next", "primary", "First", "sort", "master", "initial", "default", "valid", "unique", "ind", "st", "last", "seconds", "fast", "stack", "must", "only", "start", "fourth", "latest", "now", "each", "index", "important"], "reader": ["read", "driver", "rer", "Reader", "http", "input", "ocr", "r", "wrapper", "context", "file", "core", "rator", "rc", "parser", "loader", "builder", "rar", "stream", "row", "this", "layer", "er", "runner", "rl", "io", "handler", "ner", "rr", "writer", "iterator", "buffer", "resource", "inner", "mr", "data", "ro"], "jsCompressor": ["jscompiler", "jsBuffoser", "jscompressor", "jsReposer", "jsCompiler", "jscompression", "cssComposer", "cssRepression", "jsRepiler", "cssRepressor", "jsRepressor", "jsBuffression", "jsRepression", "cssReposer", "cssRepiler", "cssCompression", "cssCompressor", "jsBuffiler", "cssCompiler", "jsBuffressor", "jsComposer", "jscomposer", "jsCompression"], "s": ["ls", "cs", "gs", "words", "is", "full", "eds", "ts", "ds", "tags", "fs", "ats", "t", "l", "less", "ens", "parts", "ings", "tes", "xs", "details", "os", "ies", "S", "y", "hs", "pers", "ps", "lines", "ss", "ers", "qs", "ids", "ms", "es", "ns"], "s1": ["ps0", "es2", "ys1", "ys0", "ps1", " s81", "s0", "ls3", "s81", "id2", "ls0", "ys3", "s9", "pers0", "es1", "pers1", "id9", " s0", "id1", "idFirst", "ls1", "esFirst", "s3", "ls81", "ys81", " s3", "sFirst", "es9"], "i": ["is", "us", "ati", "id", "it", "ci", "li", "ion", "I", "oi", "ai", "iat", "ri", "bi", "ii", "p", "mi", "ifier", "ic", "io", "y", "im", "ch", "ity", "iu", "ori", "ie", "um", "v", "pi", "o", "iti", "j", "ui", "di", "ig", "ip", "ia"], "s2": ["tesTwo", "gstwo", "S2", "es2", "tes02", "esTwo", "sTwo", "tes2", "ms2", "s22", "SSecond", "z02", "ztwo", "es1", "sSecond", "gsSecond", "ss02", "ss22", "ms02", "s02", "tes1", "Stwo", "msTwo", "S02", "ss2", "zSecond", "gs2", "stwo", "gs02", "ssTwo", "es02", "z2", "ms22"], "i1": ["it0", "i4", "it2", "it1", "it01", "e1", "e2", "a1", "a2", "p01", "o4", "o0", "e4", "i2", "aOne", "itOne", "i01", "oOne", "iOne", "i0", "p4", "pOne", "p2", "o1", "eOne", "p0", "p1", "it4", "a01"]}}
{"id1": "9805906", "id2": "7468827", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"dump": ["read", " dumped", "init", " describe", "display", "store", "update", "write", "save", "download", "info", "stat", "debug", "zip", "link", "send", "load", " show", " dumps", "flush", "copy", "show", " debug", "export", "print", "println", "diff", " println"], "source": ["SOURCE", "iter", "script", "template", "init", "src", "check", "store", "input", "search", "sql", "Source", "info", "select", "shell", "file", "config", "ource", "ink", "se", "origin", "image", "from", "scope", "copy", "sys", "site", "spec", "sequence", "view", "text", "style", "form", "ie", "parent", "remote", "java", "resource", "start", "sample", "service", "local"], "target": ["dest", "match", "template", "compatible", "it", "that", "output", "project", "file", "current", "t", "mac", "Target", "link", "gt", "test", "top", "arg", "tif", "term", "next", "null", "proxy", "host", "to", "pattern", "copy", "style", "delete", "goal", "base", "arget", "replace", "bolt", "local", "table"], "is": ["ls", "nis", "init", "ics", "isl", "it", "ib", "ys", "iso", "ms", "abs", "bis", "tis", "ist", "IS", "isc", "s", "oss", "ai", "lis", "ri", "ar", "ir", "ists", "ii", "ins", "iss", "xs", "bits", "ris", "ic", "in", "are", "isf", "Is", "act", "sys", "isi", "im", "its", "has", "isin", "ios", "ais", "i", "sis", "si", "isa", "ois", "iris", "mos", "es", "ims", "ip"], "os": ["ls", "cs", "dos", "oos", "css", "OS", "or", "oses", "ts", "ds", "fs", "oes", "ows", "cos", "ols", "los", "s", "oss", "pos", "oS", "Os", "bos", "osi", "bs", "ose", "ost", "io", "sys", "outs", "uts", "ants", "js", "ios", "es", "ox", "ps", "ss", "ros", "nos", "aos", "o", "ot", "mos", "obs", "ns"], "done": ["loaded", "Done", "dirty", "needed", "finished", " continued", "progress", "des", "ished", "du", "enabled", "checked", "de", "continue", "found", "gone", "given", "did", " Done", "started", "expected", "created", "die", "flag", "seen", "disabled", "ded", "valid", "set", "pleted", "desc", "filled", "failed", "only", "shown", "later", "d", "led", "made", "complete", "di"]}}
{"id1": "21063400", "id2": "23611770", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"doImageProcess": [" doImagesProcess", "doItemImageWork", "doImagesProcess", "doMediaWork", "doMediaprocess", "doMediaProcess", " doImagesWork", "doImageWork", "doItemImageSort", " doImageprocess", "doItemImageprocess", "doImagesSort", "doImageprocess", "doImagesprocess", " doImageWork", "doMediaSort", " doImagesSort", "doItemImageProcess", "doImageSort", "doImagesWork", " doImagesprocess", " doImageSort"], "request": ["message", "template", "QUEST", "input", "query", "application", "address", "context", "select", "session", "reference", "frame", "quest", "client", "image", "Request", "version", "attribute", "document", "command", "view", "re", "question", "server", "resource", "model", "start"], "response": ["reply", "message", "user", "block", "collection", "format", "display", "http", "cache", "search", "write", "application", "query", "output", "description", "relation", "list", "frame", "network", "success", "answer", "onse", "entry", "window", "image", "next", "one", "page", "continue", "detail", "exit", "ve", "resp", "tree", "xml", "version", "document", "result", "site", "json", "view", "respond", "console", "sequence", "report", "position", "parent", "re", "fire", "connection", "content", "server", "print", "res", "model", "hash", "Response", "status", "reset"], "imgSize": [" imgName", "propError", "imgOwner", "imagError", " imgShape", " imgType", "imgError", "appShape", "imageSIZE", "imgName", "imagName", "certName", "imageInfo", "divSIZE", "imageStyle", "appsize", "divsize", "dimSize", "imgShape", "imageType", "appType", "divSize", "certSIZE", "certSize", "imgInfo", "imgType", "imgScale", "imagSize", "augShape", "imageSize", " imgStyle", "imgSIZE", " imgScale", "appSize", " imgOwner", "imagsize", "augsize", "augOwner", "appInfo", "imgStyle", "dimSIZE", "certScale", "imageScale", " imgSIZE", " imgInfo", " imgsize", " imgError", "appStyle", "propsize", "propName", "propSize", "dimsize", "augSize", "imgsize", "imageName", "appOwner"], "imageInputStream": ["imageInputPath", "photoInputstream", " imageStreamStream", "imageIntStream", "imageIntstream", " imageInputPath", "imageInputView", "imageInView", "photoInputSteam", "imageInStream", " imageStreamPath", "imageRawView", "imageRawStream", "fileInputStream", "imageRawstream", "imageOutputForm", "photoInputStream", "imageByteSteam", "mediaInputStream", "imageInterfaceView", "imageOutputReader", "imageOutputstream", " imageStreamSteam", "photoIntstream", "imageInputForm", "imageStreamStream", "imageInterfacestream", "fileInputstream", " imageInputSteam", "fileRawSteam", "imageInputstream", "imageByteForm", "fileRawStream", "imageInterfaceStream", "imageIntPath", "imageStreamSteam", "imageInSteam", "imageRawSteam", "fileInputView", "imageInputReader", "fileRawstream", "imageInterfaceSteam", "photoIntStream", "imageOutputStream", "imageByteReader", "imageOutputSteam", "fileInputSteam", "fileRawView", "imageIntSteam", "mediaInputForm", "imageStreamPath", "mediaInputReader", "imageInstream", "imageInputSteam", "mediaInputSteam", "photoIntSteam", "imageByteStream"], "imageBytes": ["imgParts", "imgBytes", " imageParts", "pictureBytes", "issueParts", "photoByte", "photoBytes", "pictureGs", " imageSeries", "audioBytes", " imageGs", "photoKeys", "imageParts", "imageBs", "photoGs", "imageGs", "imgSeries", "photoParts", "imageKeys", "imageByte", "audioParts", " imageByte", "imgGs", "issueKeys", " imageBs", "imageSeries", "audioBs", "issueBytes", "imgKeys", "pictureByte", "audioSeries", "imgBs", "issueGs", "pictureParts"]}}
{"id1": "13122204", "id2": "4599372", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unzipImage", "Unzipmodel", "unzipModule", "UnarchiveModule", "uncodeImage", "uncodeModel", "UnzipImage", "unarchiveModule", "unarchiveModel", "unzipmodel", "unlateModule", "uncodemodel", "UnarchiveImage", "UnzipModel", "unarchiveImage", "unlatemodel", "uncodeModule", "unlateImage", "UnzipModule", "unarchivemodel", "UnarchiveModel", "Unarchivemodel", "unlateModel"], "filename": ["path", "title", "fle", "sql", "download", "subject", "ename", "FN", "output", "file", "fp", "ln", "mson", "journal", "Filename", "original", "directory", "origin", "nl", "nm", "til", "fn", "n", "source", "txt", "jpg", "nil", "username", "fil", "wl", "river", "kl", "dra", "FILE", "FIL", "ivo", "location", "stem", "name", "SourceFile", "println"], "tempdir": [" tempDir", "tempfile", " tempDIR", "testdir", "Tempdir", "temdirectory", "tmppath", "temfolder", "temppath", "tmpfile", "tmpdirectory", "TempDir", "tmpDir", "tempath", "Tempfile", "testDir", "tempDir", "testpath", "tmpDIR", "tempDIR", "temdir", " tempfile", "Tempdirectory", " tempdirectory", "testfolder", "tmpdir", "temDIR", "tempfolder", "temDir", "tmpfolder", "tempdirectory"], "dest": ["dev", "inv", "obj", "rest", "src", "ptr", "display", "store", "out", "write", "des", "del", "comb", "output", "tmp", "usr", "nt", "Dest", "send", "ctr", "bin", "pos", "slave", "test", "origin", "peer", "dc", "stream", "loc", "source", "nom", "null", "decl", "pipe", "tail", "master", "est", "document", "tr", "result", "default", "st", "desc", "coord", "target", "writer", "port", "foreign", "dat", "temp", "parent", "deep", "trans", "buffer", "dist", "cont", "sum", "table", "generated"], "fis": ["zos", "flos", "fatis", "li", "los", "fjs", "ifos", "ljs", "lis", "ifis", "ifi", "ifatis", "fljs", "fi", "zjs", "zi", "flis", "fli", "zatis", "flatis"], "BUFFER": [" BUMT", "BLBER", "BAFFER", "LOCKFR", "CUBER", " BUBuffer", "BLBuffer", "MAXOUNT", "BLFFER", "BUULT", "BUBER", " BUFR", "MAXFFER", "CUBuffer", "FFERBER", "BUBuffer", "CUFR", "LOCKFFER", "MAXBuffer", "BBER", "BFFER", "FFERMT", " BUBER", "BABER", "BUOUNT", "LOCKBER", "BAOUNT", "BufferBuffer", "FFERBuffer", "LOCKBuffer", "BAULT", "BUFR", "BLOUNT", "BULT", "BufferMT", " BUOUNT", "BOUNT", "BufferFFER", "BUMT", "BufferBER", "CUFFER", " BUULT", "FFERFFER", "MAXBER"], "zis": ["zos", "zeits", "zees", "xi", "xis", "zeris", "zris", "Zis", "ziis", "zip", "zeiss", "oziss", "zits", "xos", " zes", " zIS", "ziIS", "fip", "ozip", "Zos", "fiss", "zoneis", " zi", "Zi", " zos", " zits", "zies", " zip", "xiss", "fi", "Ziss", "ozi", "zoneiss", "zoneris", "zeIS", " zris", "zeos", "zi", " ziss", "zIS", "zes", "zios", "zeis", "ozis", "zoneits", "ziss"], "entry": ["match", "item", "ce", "header", "jar", "or", "zo", "card", "nt", "file", "zip", "se", "link", "cell", "jo", "record", "Entry", "system", "key", "existent", "image", "word", "row", "source", "ent", "ze", "pe", "def", "char", "way", "part", "result", "element", "ie", "je", "e", "log", "enter", "chain", "connection", "escape", "piece", "inter", "ry", "name", "comment", "index", "table", "member"], "count": ["Count", "read", "match", "counter", "check", "ce", "cache", "number", "all", "OUNT", "force", "f", "z", "amount", "nt", "core", "current", "cond", "add", "common", "ctr", "cell", "cc", "size", "c", "found", "n", "page", "cloud", "ct", "num", "batch", "len", "acc", "part", "length", "nb", "buffer", "cont", "max", "sum", "total", "code", "base", "start", "ount", "comment", "index", "child", "call"], "data": ["message", "bytes", "dl", "format", "value", "accept", "cache", " DATA", "out", "all", "output", "ATA", "done", "str", "size", "zero", "window", "image", "results", "n", "next", "p", "batch", "area", "part", "result", "valid", "text", "DATA", "mat", "dec", "step", "dat", "buffer", "ata", "raw", "content", "d", "sample", "rel", "table"], "fos": ["lios", " foses", "Fios", " foes", "fios", "los", "Foes", "lOS", "foses", " fios", "Foss", "foss", "FOS", "Foses", "fOS", " foss", "voses", "foes", "vos", "loss", "voss", "voes", " fOS", "Fos"]}}
{"id1": "12782570", "id2": "9236363", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"logging": [" logged", "Logging", "logged", "debugifying", "Logged", "debugging", " logger", " logifying", "logger", "Logifying", "debugger", "Logger", "debugged", "logifying"], "wrap": ["xf", "message", "transform", "ad", "read", "format", "parse", "store", "grow", "find", "ew", "force", "wrapper", "wra", "core", "wa", "ow", "use", "zip", "add", "link", "safe", "python", "web", "root", "wx", "x", "window", "word", "rap", "gate", "W", "box", "handle", "work", "sp", " wrapped", "w", "embed", "form", " wrapper", "build", "me", "chain", "shape", "aw", "pad", "nw", "sw", "create", "pack", "inter", "start", "ws", "wind", "wire", "pool", "reset", "we"], "buffer": ["reply", "message", "block", "header", "iter", "template", "bridge", "display", "note", "flash", "cache", "where", "store", "binary", "face", "wrapper", "output", "database", "frame", "append", "bo", "queue", "builder", "size", "memory", "Buffer", "window", "row", "word", "quote", "ve", "batch", "flag", "document", "attribute", "bar", "command", "sequence", "view", "console", "body", "report", "position", "writer", "line", "buf", "complete", "print", "base", "buff", "profile", "ob", "phrase", "comment", "table", "pb"], "encoding": ["cging", "presoding", "cryption", "enoding", "encoded", "Encaling", "octoder", "encoder", "coder", "Encoder", "enoder", "enging", "octoded", "coded", "Encoding", "enryption", "caling", "enaling", "enoded", "presoder", "Encryption", "encryption", "encaling", "presryption", "encging", "presoded", "octging", "coding", "octoding"], "getEncoding": ["getEncryption", "getUrlryption", "getencName", "GetEnName", "GetEncryption", "getEncocol", " getEnoded", "getContinryption", "getUrloding", " getEncocol", "getEncling", "getEnryption", "getUrlName", "getContinoded", " getEncryption", "GetEncoding", " getEnocol", "getEncoded", "GetEncName", " getEnryption", "getContinoding", "getencoding", "getEncName", "getEnoded", "getContinocol", "getEnName", "getencling", " getEnoding", " getEncoded", "getencryption", "GetEncling", "getUrlling", "getEnling", "GetEnoding", "getEnoding", "getEnocol", "GetEnryption", "GetEnling"], "headers": ["header", "pres", "modules", "actions", "authors", "chains", "keys", "tags", "builders", "writers", "users", "properties", "head", "params", "comments", "ters", "boxes", "reports", "pins", "heads", "caps", "groups", "checks", "rs", "ilers", "weights", "limits", "frames", "ppers", "images", "ports", "ctors", "codes", "styles", "fields", "relations", "holders", "members", "names", "drivers", "ers", "objects", "ids", "terms", "values", "blocks"], "is": ["nis", "\u00eds", "or", "us", "isl", "was", "fs", "dis", "ys", "iso", "ms", "isd", "bis", "tis", "IS", "ist", "isc", "lis", "as", "ri", "ists", "does", "ins", "iss", "os", "bits", "ris", "ic", "in", "isf", "bs", "Is", "sys", "isi", "its", "has", "isin", "ios", "ais", "i", "sis", "si", "mis", "isa", "ois", "iris", "ui", "obs", "ims", "ip"], "bos": ["cs", "oos", "dos", "bytes", "pod", "vals", "ts", "ones", "fs", "oids", "ys", "des", "ows", "bas", "bis", "banks", "los", "ols", "cos", "tis", "bo", "oss", "bin", "bes", "bi", "uds", "tes", "bits", "os", "tops", "jas", "bs", "ods", "ubis", "ses", "sys", "bot", "isi", "soc", "uts", "windows", "lets", "js", "ios", "bh", "bones", "stats", "eros", "edes", "nos", "aos", "fits", "ui", "obs", "ots", "boards"], "e": ["ex", "r", "f", "err", "error", "oe", "m", "t", "ate", "se", "ae", "x", "de", "c", "n", "le", "a", "p", "exc", "en", "ent", "ed", "eeee", "er", "ne", "ge", "E", "ie", "es", "g", "re", "me", "i", "d", "v", "o", "ev", "ee"]}}
{"id1": "11933797", "id2": "9450274", "code1": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public void seeURLConnection() throws Exception {\n        URL url = new URL(\"http://wantmeet.iptime.org\");\n        URLConnection uc = url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n        String s = null;\n        StringBuffer sb = new StringBuffer();\n        while ((s = br.readLine()) != null) {\n            sb.append(s);\n        }\n        br.close();\n        log.debug(\"sb=[\" + sb.toString() + \"]\");\n    }\n", "label": 0, "substitutes": {"CopyFile": ["copyFiles", " CopyFiles", " CopyFrom", " copyfile", " Copyfile", "copyFrom", "CopyFiles", "CopyFrom", "copyFile", " copyFiles", " copyFrom", " copyFile", "Copyfile", "copyfile"], "in": ["In", "b", "iter", "pin", "is", "input", "rin", "it", "sql", "url", "r", "k", "ma", "IN", "inn", "l", "inf", "bin", "c", "vin", "ar", "ins", "source", "from", "inc", "q", "en", "mi", "h", "act", "xml", "el", "ind", "st", "din", "mm", "isin", "cin", "me", "i", "gin", "ck", "o", "doc"], "out": ["b", "ex", "check", "at", "full", "OUT", "net", "ou", "all", "it", "output", "nt", "file", "help", "l", "t", "s", "gt", "Out", "n", "fn", "txt", "en", "cmd", "to", "up", "io", "ne", "outs", "result", "msg", "set", "w", "ch", "po", "log", "aos", "v", "o", "res", "ot", "pool"], "sourceChannel": ["sourceChuck", "fromChain", "fromChuck", "fromChan", "inChain", " sourceHandler", "srcChannel", "sourceConnection", "SourceStream", "sourceStream", "sourceChan", "sourceChain", "siteChuck", "ourceHandler", "inChuck", "inChannel", "SourceChannel", "SourceListener", "ourceStream", "ourceConnection", "sourcechannel", " sourceListener", "ourceListener", "ourceChannel", "fromChannel", "srcchannel", "siteMember", "fromMember", " sourceChan", "inMember", " sourceStream", "srcHandler", "siteChain", "sourceHandler", " sourcechannel", "sourceListener", "ourcechannel", "fromchannel", "SourceConnection", " sourceConnection", "srcListener", "Sourcechannel", "fromConnection", "sourceMember", "SourceChan", "siteChannel"], "destinationChannel": ["destensionchannel", "destinateStream", "DestinationChan", "DestensionChan", "destensionChan", "destinationConnection", "destationHandler", "destionchannel", "DestinationChannel", "destinatorchannel", "DestensionChannel", "destinateChan", "destinationHandler", "destinationStream", "destionHandler", "destionChan", "destinatorChannel", "DestinationStream", "destationContext", "destinationChan", "destinationchannel", "Destinationchannel", "DestationChan", "DestinationConnection", "DestationContext", "DestensionConnection", "destationStream", "destinatorConnection", "destationChan", "Destationchannel", "DestinationContext", "destinateContext", "destinationschannel", "destensionChannel", "destensionConnection", "destinationsChan", "destinationContext", "destensionStream", "destensionContext", "DestationHandler", "DestationChannel", "destionChannel", "destationchannel", "DestinationHandler", "destinationsHandler", "destinateChannel", "destinationsConnection", "destinationsChannel", "destinatorChan", "Destensionchannel", "DestationStream", "destationChannel"]}}
{"id1": "7044685", "id2": "4458076", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    public InputStream getInputStream() throws TGBrowserException {\n        try {\n            if (!this.isFolder()) {\n                URL url = new URL(this.url);\n                InputStream stream = url.openStream();\n                return stream;\n            }\n        } catch (Throwable throwable) {\n            throw new TGBrowserException(throwable);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"encrypt": ["encrypted", "crypt", "Encrypt", " encrypted", "crypted", "Encryption", "cryption", "encryption", " encryption", "Encrypted"], "plaintext": ["messagedata", "plainText", "messageprint", "messageText", "ainText", "plainstring", "aintext", "mainText", "ainstring", "aindata", " plaindata", "messagetext", "ainprint", " plainText", "maintext", "plainprint", " plainstring", " plainprint", "plaindata", "mainstring"], "d": ["ad", "nd", "dl", "cd", "D", "dr", "dh", " md", "ds", "f", "da", "red", "z", "m", "fd", "t", "done", "gd", "md", "debug", "l", "c", "de", "hd", "dal", "did", "end", "df", "p", "ord", "h", "pd", "dd", "ded", "y", "mod", "ind", "w", "dec", "dat", "g", "e", "ld", "bd", "od", "dig", "dx", "sd", "db", "di", "dm"]}}
{"id1": "16063533", "id2": "19147281", "code1": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"encrypt": ["decrypt", "encrypted", "encode", "ecrypt", "ecrypted", "decode", "enode", "ecode", "encryption", "enryption", "decryption", "enrypted", "ecryption", "decrypted", "enrypt"], "x": ["xf", "ex", "ctx", "xi", "f", "xxxxxxxx", "z", "xe", "rx", "xt", "s", "l", "xc", "ix", "tx", "wx", "fx", "xxxx", "xp", "xs", "p", "xxx", "xml", "y", "xy", "xd", "xa", "e", " xx", "xb", "v", "example", "X", "px", "xx"], "d": ["ad", "nd", "cd", "dl", "D", "dr", "dh", "ds", "with", "r", "f", "da", "red", "du", "m", "fd", "t", "done", "gd", "md", "c", "de", "dc", "n", "dal", "did", "df", "ord", "h", "pd", "dd", " sd", "ind", "mod", "dec", "dat", "ld", "bd", "od", "dig", "dx", "rd", "td", "sd", "db", "di", "dm"]}}
{"id1": "5138455", "id2": "732800", "code1": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"save": [" clone", " recover", "store", "write", " Save", "Save", " restore", "paste", " set", " merge", "load", "clone", " seal", "gc", "to", " insert", "dump", "copy", "Copy", " swap", " dump", "upload", " move", " upload", " paste", " persist", " append", " store"], "bytes": ["b", "pieces", "unks", "gs", "words", "gets", "was", "amps", "binary", "gb", "loads", "odes", "reads", "bps", "parts", "tes", "rs", "ces", "bits", "some", "bs", "Bytes", "classes", "ses", "ies", "ents", "steps", "its", "seconds", "bles", "aws", "trans", "lines", "raw", "terms", "es", "values", "blocks"], "outputFile": [" outputFilename", "inputFilename", "inputfile", "OutputFile", "tempfile", "OutputFILE", "outputfile", " outputDir", "inputDir", "referenceFILE", " outputFiles", "Outputfile", "OutputPath", "outFile", "outDir", "outputFilename", "tempFile", "OutputDir", "referenceFile", "tempDir", "tempPath", " outputPath", "outputFiles", "referenceFiles", "outFilename", "referenceDir", "outputDir", " outputFILE", "inputFile", "outputPath", "OutputFiles", "inputPath", "outPath", "outputFILE"], "in": ["In", "read", "iter", "is", "sin", "on", "input", "rin", "al", "it", "id", "r", "f", "m", "IN", "inn", "reader", "pre", "l", "inside", "inf", "bin", "include", "ri", "ins", "source", "from", "inc", "mc", "en", "mi", "ze", "act", "up", "io", "xml", "ind", "st", "im", "din", "mm", "isin", "by", "ie", "cin", "con", "i", "gin", " din", "raw", "inner", "print", "ini"], "out": ["b", "obj", "at", "full", "net", "OUT", "ou", "on", "cache", "it", "write", "output", "nt", "file", "t", "l", "stable", "client", "Out", "n", "end", "null", "page", "fn", "os", "screen", " OUT", "cn", "to", "io", "ne", "sys", "outs", "op", "writer", "OU", "log", "i", "co", "print", "can", "v", "o", "auto", "outer", "aos", "ot", "res"]}}
{"id1": "22418839", "id2": "7764011", "code1": "    public void handleHandshake(Packet2Handshake par1Packet2Handshake) {\n        boolean flag = true;\n        String s = par1Packet2Handshake.username;\n        if (s == null || s.trim().length() == 0) {\n            flag = false;\n        } else if (!s.equals(\"-\")) {\n            try {\n                Long.parseLong(s, 16);\n            } catch (NumberFormatException numberformatexception) {\n                flag = false;\n            }\n        }\n        if (!flag) {\n            netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { \"The server responded with an invalid server key\" });\n        } else if (par1Packet2Handshake.username.equals(\"-\")) {\n            addToSendQueue(new Packet1Login(mc.session.username, 29));\n        } else {\n            try {\n                URL url = new URL((new StringBuilder()).append(\"http://session.minecraft.net/game/joinserver.jsp?user=\").append(mc.session.username).append(\"&sessionId=\").append(mc.session.sessionId).append(\"&serverId=\").append(par1Packet2Handshake.username).toString());\n                BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s1 = bufferedreader.readLine();\n                bufferedreader.close();\n                if (s1.equalsIgnoreCase(\"ok\")) {\n                    addToSendQueue(new Packet1Login(mc.session.username, 29));\n                } else {\n                    netManager.networkShutdown(\"disconnect.loginFailedInfo\", new Object[] { s1 });\n                }\n            } catch (Exception exception) {\n                exception.printStackTrace();\n                netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { (new StringBuilder()).append(\"Internal client error: \").append(exception.toString()).toString() });\n            }\n        }\n    }\n", "code2": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "label": 0, "substitutes": {"handleHandshake": ["handleServerRequest", " handlehandRequest", "handleHandication", " handlehandication", "handleServerication", "handleServershake", "handleHealthication", "handleHealthshake", "handlehandchange", " handleHandication", "handleHandchange", " handlehandshake", " handleHandRequest", " handleHandchange", "handleHealthRequest", " handlehandchange", "handleHandRequest", "handlehandRequest", "handlehandshake", "handlehandication", "handleServerchange", "handleHealthchange"], "par1Packet2Handshake": ["par1Packet2Handleshake", "par1Packet2Hostza", "par1Packet2Handlele", "par1Packet2Handle", "par1Packet2Headshake", "par1Packet1handler", "par1Packet1Handleshake", "par1Packet2Headle", "par1Packet1handle", "par1Packet2Handler", "par1Packet2handza", "par1Packet1Handlelers", "par1Packet2Handleler", "par1Packet2Handza", "par1Packet2Handlelers", "par1Packet2handshake", "par1Packet1Handza", "par1Packet1Handlers", "par1Packet2handler", "par1Packet2Headza", "par1Packet2handle", "par1Packet1Handshake", "par1Packet2handlers", "par1Packet2Hza", "par1Packet2Hostshake", "par1Packet2Hostle", "par1Packet2Handleza", "par1Packet2Headlers", "par1Packet1Handleza", "par1Packet2Handlers", "par1Packet1Handle", "par1Packet1handza", "par1Packet2Hler", "par1Packet1handshake", "par1Packet2Hshake", "par1Packet1Handler"], "s": ["b", "ls", "gs", "is", "ts", "ds", "sql", "save", "r", "f", "su", "ats", "sv", "abs", "t", "l", "se", "str", "string", "less", "sym", "sq", "sts", "c", "x", "n", "rs", "p", "u", "h", "sh", "S", "sam", "spec", "y", "st", "hs", "w", "sb", "js", "conv", "g", "e", "its", "ps", "gins", "i", "sing", "ss", "stats", "v", "qs", "ws", "simple", "j", "sort", "sl", "ns"], "flag": ["agg", "agged", "lv", "group", "fail", "store", "f", "func", "error", "sync", "file", "and", "cond", "lock", "age", "true", "nl", "arg", "continue", "image", "run", "leaf", "limit", "lag", "lead", "cloud", "cmd", "char", "xml", "compl", "Flag", "valid", "field", "set", "bool", "status", " Flag", "ld", "bug", "log", "stage", "mail", "ground", "line", "car", "bird", "print", "level", "tag", "stay", "flags", "member", "local", "FLAG"], "url": ["ls", "user", "sl", "dl", "http", "URL", "lr", "r", "address", "li", "l", "ur", "link", "str", "https", "browser", "gl", "client", "web", "nl", "window", "acl", "uri", "char", "il", "xml", "socket", "ret", "mail", "Url", "ml", "build", "mb", "ssl", "resource", "ul", "bel", "location", "rel", "ll", "mount", "channel", "www"], "bufferedreader": ["bufferingwriter", "Bufferedrar", "Bufferredbuffer", "BufferedReader", "Bufferedbuffer", "buffererReader", "buffererwriter", "Bufferredrar", "buffledbuffer", "buffererbuffer", "Bufferedreader", "buffererreader", "bufferredreader", "bufferedReader", "buffererrar", "BufferredReader", "buffledReader", "bufferedbuffer", "buffledrar", "bufferedwriter", "buffledwriter", "Bufferedwriter", "bufferredrar", "bufferredReader", "buffledreader", "Bufferredreader", "bufferedrar", "bufferingrar", "bufferredwriter", "bufferingreader", "bufferredbuffer", "Bufferredwriter", "bufferingReader"], "s1": [" sinton", "s001", "sts1", "S2", "ps0", "sesinton", "str4", "str1", "SOne", "ps1", "str2", "s0", "ps2", "ses1", "sts2", "sOne", " s2", "psOne", " s0", "S4", " sOne", "S0", "sts001", "ses001", "s2", "ses2", " s4", "S1", "stsinton", "s4", "str0", "sinton", " s001"]}}
{"id1": "16820041", "id2": "8047989", "code1": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encodePassword": ["encodePass", "encodepassword", "enodePassword", "enccodePassword", "encodedPass", "enodePass", "enodepassword", "enccodePass", "encodedpassword", "enotePassword", "enotePass", "enccodepassword", "enotepassword"], "_originalPassword": ["_modifiedString", "_OriginalUser", "_OriginalToken", "_modifiedUser", "_originalString", " _modifiedWord", "_modifiedPassword", "_encryptedText", " _originalUser", " _originalString", "_originalText", " _OriginalToken", "_OriginalString", "_modifiedToken", " _OriginalString", "_modifiedText", " _modifiedString", " _modifiedText", "_OriginalWord", "_OriginalText", "_encryptedPassword", "_encryptedToken", "_encryptedUser", "_originalUser", "_encryptedWord", " _originalToken", " _modifiedPassword", "_originalToken", "_encryptedString", " _OriginalPassword", " _originalWord", " _OriginalUser", " _originalText", "_originalWord", "_modifiedWord", "_OriginalPassword"], "md": ["nd", "ng", " mc", "cd", "dr", "dh", "ds", "mt", "red", "grad", "nt", "MD", "m", "ma", "pm", "mp", "der", "mk", "add", "de", "hd", "managed", "mo", "mc", "df", " mo", "pd", "cmd", "dd", "def", "det", "mod", "ind", "sha", "mm", "ld", "bd", "od", "dig", "mn", "mb", "material", "mand", "d", "sd", "metadata", " Md", " m", "mg", "ms", "di", "sm", "dm", "magic"], "encodedPassword": ["acratedPassword", "encatedConnection", "encratedpassword", "encodedEmail", "acodedConnection", "ecryptedpassword", "EncodingText", "encryptedpassword", "enccodedString", "ecryptedString", "encryptedEmail", "EncodingUser", "acodedPassword", "EncodedUser", "ecodedpassword", "encodedConnection", "encryptedText", "encoderPassword", "encratedPassword", "encatedPassword", "EncodedEmail", "encryptedString", "enccodedSecret", "encachedPassword", "encodedUser", "enccodedpassword", "EncodingEmail", "encryptedSecret", "encodedString", "ecryptedSecret", "enccodedPassword", "EncodingPassword", "encatedpassword", "encodingText", "EncodedPassword", "encodedpassword", "acratedConnection", "encoderEmail", "encodingPassword", "encodingUser", "encachedpassword", "encachedString", "encressedpassword", "ecodedPassword", "encoderText", "ecodedSecret", "encachedSecret", "encodingEmail", "EncodedText", "encodedText", "encressedPassword", "acratedpassword", "acodedpassword", "encoderUser", "encressedConnection", "encratedConnection", "encryptedUser", "encodedSecret", "encryptedPassword", "ecryptedPassword", "ecodedString"]}}
{"id1": "6625074", "id2": "9096319", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"SHA1": ["sha512", "HS1", "sha1", "SHAOne", " SHA512", "HS2", "shaOne", " SHA2", "HS512", "SHA2", " SHAOne", "sha2", "SHA512", "HSOne"], "text": ["message", "path", "read", "pt", "template", "value", "title", "input", "it", "url", "output", "translation", "nt", "t", "ut", "string", "str", "tx", "test", "ext", "TEXT", "word", "txt", "source", "q", "act", "password", "document", "msg", "body", "form", "hex", "buffer", "cont", "event", "content", "sum", "print", "code", "v", "Text", "data", "name", "comment", "doc"], "sha1hash": ["sha0Hash", "SHA1hex", "ha2hash", "SHA1hash", "ha1address", "ha1hash", "sha1Hash", "shaonesum", "ha2Hash", "sha1sum", "sha1hex", "ha1sum", "sha2hex", "sha2message", "sha31hash", "sha31sum", "sha31Hash", "sha2sum", "shaonehex", "SHA1sum", "ha2address", "sha0sum", "sha31address", "sha2address", "sha0hash", "shaonehash", "sha3Hash", "SHA2sum", "haonemessage", "shaoneHash", "haonehash", "sha3hash", "sha3message", "haoneHash", "SHA2Hash", "sha2Hash", "ha1Hash", "shaonemessage", "ha1message", "SHA1Hash", "SHA2hash", "SHA2hex", "sha2hash", "sha0address", "sha3sum", "ha2sum", "haonesum", "sha1address", "sha1message"], "md": ["obj", "amd", "ad", "nd", "cd", "dr", "dh", "ds", "mt", " MD", "MD", "m", "pm", "alg", "and", "der", "rm", "mk", "hd", "mc", "df", "strong", "pd", "cmd", "dd", "det", "ind", "mod", "sha", "pdf", "mm", "ld", "bd", "od", "mn", "mand", "d", " Md", "sd", "hash", "ms", "di", "sm", "dm"]}}
{"id1": "530882", "id2": "8150996", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrites", "readAndRepWrite", "readAndResWrite", "readAndRewend", "readAndResend", "readAndrewrite", "readAndrewWrite", "readAndResrite", "readAndRewrites", "readAndrewrites", "readAndReprite", "readAndrewend", "readAndRewWrite", "readAndRepend", "readAndReprites"], "inFile": ["InFile", "inputFilename", "docFile", "docFILE", "iFILE", "iFilename", "INTime", "inFILE", "InFilename", "initPlace", "initFilename", "inputPlace", "docTime", "inFace", "outfile", "infile", "iFile", " inFilename", "initFile", "inPlace", "INPlace", "docFilename", " infile", "inTime", "Infile", "initFace", "INFace", "iTime", "INFilename", "INFile", "INFILE", "inputFile", "inputFace", "inFilename", "outFilename"], "outFile": ["reportFile", " outFilename", "checkFilename", "outFILE", "inFILE", "toFILE", "reportFILE", "tofile", "nameFilename", "outfile", "infile", " outFILE", "reportfile", "reportFilename", "toFilename", "namefile", "nameFile", "toFile", "checkFile", " outfile", "checkFILE", "inFilename", "outFilename", "nameFILE", "checkfile"], "iis": [" iris", "iiIs", "liris", "iIS", "eis", "aiis", "Iiss", "liisc", "Ii", "liIs", "liis", "eIS", "iiisc", "ii", " iiss", "iiss", "iiis", "iiris", " iIs", "iIs", " iIS", "diIs", " ii", "iisc", "IIs", "eIs", "aiIS", "dii", "aiIs", "diis", " iisc", "iris", "Iis", "diiss"], "dcmParser": ["dgrParser", " dpmListener", "dpcReader", "dpmAssistant", "DpmReader", "dcrparser", "dcommReader", " dpmarser", "dcmListener", "dmoduleReader", "dmoduleAssistant", " dpmStatement", "dpmLoader", "dmmParser", " dcmarser", " dpmparser", "dcommListener", "deromParser", "dpmBuilder", "dromparser", "dcmAdapter", "dcrParser", "dfmParser", "dpmStatement", "dmmmReader", " dcmLoader", "dcomReader", "dcmBuilder", "dromAssistant", "DpmAdapter", "dcrBuilder", "dpmPrivate", " dcmPar", "dcomBuilder", "dcrReader", " dpmReader", "dcommAssistant", " dpmLoader", " dcmStatement", " dcmAssistant", "dmmarser", "dmmparser", "DcmBuilder", "dpmarser", "dgrStatement", " dcmBuilder", "dmmmparser", "dcmparser", "dcfStatement", "dromReader", "dcmAssistant", "decmParser", " dcmListener", "deromarser", "Dpmparser", "decmReader", "DcmParser", "dpmAdapter", " dpmParser", "dcmStatement", "dgrReader", " dpmPar", "DpmPar", "dmReader", "decmarser", "dpcAssistant", "DpmBuilder", "dmmReader", "decmparser", "drumParser", "dromarser", " dpmBuilder", " dcmPrivate", "dpcParser", " dpmAssistant", "dcmLoader", "DcmReader", "dromParser", "dmmmParser", " dcmparser", "dmmAdapter", "DpmParser", "drumReader", "dfmReader", "dpmReader", "dgrPar", "dcmReader", "dcfReader", "deromReader", "Dcmparser", "deromparser", "dcommParser", "dmparser", "drumPar", " dcmReader", "dcmarser", "dmarser", "dcmPrivate", "dpmparser", "dcmPar", "dmParser", "dmmmAdapter", "dpcPrivate", "dcfPar", "dromListener", "dcomParser", "dmodulePrivate", "DcmAdapter", "drumBuilder", "dfmBuilder", "dfmLoader", "dpmListener", "dcomLoader", "dpmPar", "dmoduleParser", "dpmParser", "dcfParser", "DcmPar", " dpmPrivate"], "ds": ["ls", "cs", "dos", "dl", "gs", "eds", "dh", "ils", "fs", "des", "vs", "ys", "da", "der", "sv", "s", "gd", "dds", "sets", " des", "as", "ads", "hd", "dq", "rs", "uds", "tes", "xs", "df", "os", "details", "ins", "pd", "dd", "services", "in", "bs", "Ds", "ods", "sys", "obs", "outs", "dt", "hs", "pers", " DS", "eps", "its", "js", "dat", "bd", "ps", "dx", "ks", "ss", "drivers", "sd", "d", "aos", "qs", "data", "ws", "DS", "db", "es", "ims", "ns"], "pdReader": ["ddHelper", "ddParser", "pdLoader", "xdHelper", "pdParser", "tdWriter", "xdLoader", "tdRead", "ddLoader", "vdLoader", "pdRead", "dpCar", "dpLoader", "ddWriter", "ddReader", "pdCar", "ddRunner", "dpRunner", "pedReader", "tdParser", "hdParser", "tdReader", "pedLoader", "pedCar", "hdRead", "pdRunner", "vdHelper", "xdReader", "pdHelper", "hdWriter", "ddRead", "xdWriter", "dpReader", "vdReader", "pedRunner", "hdReader", "ddCar", "vdWriter"], "out": ["over", "full", "on", " err", "err", "t", "str", "ins", "p", "ent", "outs", "ch", "writer", "log", "conn", "con", "co", "sum", "sw", "v", "o", "auto", "name", "status", "gen", "inv", "obj", "ex", "ou", "all", "id", "nt", "s", "cb", "c", "end", "txt", "os", "nr", "cn", "in", "desc", "conv", "serv", "raw", "inner", "outer", "pool", "cfg", "at", "net", "tmp", "list", "pos", "Out", "n", "en", "up", "io", "sys", "w", "js", "aos", "res", "data", "we", "OUT", "cache", "it", "output", "oss", "client", "gt", "one", "null", "screen", "go", "cmd", "to", "opt", "flush", "msg", "gr", "inter"], "dcmEncParam": ["dcmEnPar", "dcmEnVal", "dcmencCmd", "dcmEncVal", "dcmEnParam", "dcmencParam", "dcmEscPar", "dmmencParam", "dcmDecParam", "dmmEncCmd", "dcmEncCmd", "dcmencNum", "dmmEncMsg", "dmmencNum", "dmmEncPar", "dcmEncPar", "dcmEscNum", "dmmEnPar", "dcmDecCmd", "dcmEncMsg", "dcmEnNum", "dmmEnNum", "dcmEscVal", "dcmDecMsg", "dcmEscParam", "dmmEncParam", "dmmencCmd", "dmmEnParam", "dmmEncNum", "dcmEncNum", "dcmDecNum", "dcmencPar", "dcmencMsg", "dmmEncVal", "dmmencMsg"], "pdWriter": ["dpEditor", "PDReader", "tdWriter", "dpWriter", "pidWrite", "PDWriter", "pdwriter", "pidWriter", "PDWrite", "tdWriting", "tdReader", "PDEditor", "pidwriter", "pidWriting", "dpWrite", "tdwriter", "pcWriter", "pcWrite", "pdWrite", "pdWriting", "pcwriter", "tdWrite", "pdEditor", "pcWriting", "dpReader", "tdEditor"]}}
{"id1": "14764852", "id2": "23620712", "code1": "    public HttpResponse<E> doRequest(HttpMethods method, HttpHeader[] headers, boolean auth, URI target, BlipMessagePart body) throws HttpRequestException {\n        HttpRequest<E> con = createConnection(method, target);\n        if (defaultHeaders != null) {\n            putHeaders(con, defaultHeaders);\n        }\n        if (headers != null) {\n            putHeaders(con, headers);\n        }\n        try {\n            if (auth && authStrategy != null) {\n                authStrategy.perform(con);\n            }\n            if (body != null) {\n                bodyGenerator.writeBody(con, body);\n            }\n            HttpResponse<E> res = execute(con);\n            return res;\n        } catch (IOException e) {\n            throw new HttpRequestException(\"Error executing request\", e);\n        }\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doRequest": ["runGet", "runResponse", "doGet", " doGet", "DoRequest", "runQuery", " doResponse", "DoGet", "doResponse", "DoResponse", " doQuery", "runRequest", "doQuery", "DoQuery"], "method": ["message", "path", "th", "rest", "mid", "http", "type", "url", "eth", "class", "agent", "m", "request", "pkg", "rem", "direct", "METHOD", "head", "met", "send", "period", "mode", "verb", "top", "term", "right", "Method", "nom", "end", "action", "tr", "command", "mod", "ind", "text", "property", "post", "process", "history", "module", "mount", "each", "via", "hod"], "headers": ["header", "pres", "files", "actions", "modules", "links", "authors", "keys", "tags", "options", "packages", "users", "writers", "head", "ters", "params", "boxes", "reports", "heads", "groups", "checks", "dates", "mods", "xs", "ilers", "bits", "weights", "events", "issues", "limits", "frames", "ppers", "images", "ports", "codes", "fields", "members", "holders", "names", "drivers", "ers", "rooms", "terms", "blocks"], "auth": ["read", "ht", "cert", "http", "aut", "force", "urg", "authent", "ok", "pkg", "login", "stat", "uth", "help", "mk", "cb", "priv", "hd", "acl", "cp", "ac", "pub", "img", "ic", "cmd", "act", "util", "anon", "password", "iam", "Auth", "xy", "form", "upload", "crypt", "ssl", "aud", "lit", "ip", "pas"], "target": ["dest", "message", "path", "range", "template", "src", "url", "eth", "subject", "address", "Target", "link", "client", "ARGET", "gt", "root", "top", "peer", "origin", "arg", "loc", "tx", "source", "proxy", "scope", "host", "uri", "to", "iat", "state", "resource", "location", "base", "profile", "arget", "rel", "table", "ip"], "body": ["b", "reply", "message", "bytes", "note", "out", "query", "dis", "options", "be", "subject", "shell", "ODY", "odies", "description", "any", "db", "file", "params", "se", "news", "pos", "parts", "plain", "null", "source", "object", "h", "bs", "ody", "part", "ne", "msg", "json", "bill", "text", "related", "report", "post", " Body", "bh", "by", "buffer", "content", "data", "other", "ob", "comment", "vol", "obs", "Body"], "con": ["ce", "com", "sin", "Conn", "conf", "cgi", "ver", "win", "comm", "bon", "ain", "col", "Con", "ln", "cond", "cos", "ocon", "xc", "bo", "cb", "cat", "c", "fn", "go", "gate", "en", "cp", "cn", "ct", "cmd", "cm", "rec", "nc", "compl", "cr", "cal", "cu", "ch", "dec", "conv", "ca", "dial", "dat", "CON", "pan", "uc", "mon", "trans", "conn", "ctrl", "cont", "co", "ran", "pen", "cons", "cf", "syn", "can", "cur", "connect", "bur", "un", "pas"], "res": ["inv", "cs", "obj", "ex", "rest", "us", "vals", "ts", "out", "des", "red", "nt", "rem", "reg", "Res", "news", "req", "RES", "results", "val", "rs", "respons", "resp", " Res", "ne", "result", "rep", "ret", "re", "ress", "ps", "gr", "cons", "rel", "ms", "pr", "reset", "pas"]}}
{"id1": "14878593", "id2": "11032546", "code1": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"hyperlinkUpdate": [" hyperlinkClick", "hyperLinkClick", "hyperlinkUpdated", "hyperloadUpdated", "hyperLinkUpdated", "hyperlineUpdate", "hyperLinkUpdate", "hyperLinkupdate", "hyperlinkClick", "hyperlineUpdated", " hyperLinkClick", " hyperlinkupdate", " hyperLinkUpdated", " hyperLinkupdate", " hyperLinkUpdate", "hyperlineClick", "hyperlineupdate", "hyperloadClick", "hyperloadUpdate", "hyperloadupdate", "hyperlinkupdate", " hyperlinkUpdated"], "e": ["b", "ex", "ce", "it", "r", "f", "err", "oe", "m", "t", "s", "l", "se", "eg", "ae", "c", "de", "esc", "ue", "n", "one", "a", "p", "u", "en", "h", "fe", "ent", "ve", "ea", "ed", "er", "eeee", "eu", "el", "ge", "w", "E", "ame", "te", "ie", "es", "ef", "re", "ec", "event", "d", "et", "v", "eur", "o", "Event", "ev", "ee"], "url": ["ls", "path", "http", "URL", "lr", "id", "sql", "r", "address", "f", "filename", "l", "ur", "gl", "str", "link", "browser", "string", "job", "web", "html", "nl", "term", "loc", "this", "hl", "host", "mount", "uri", "addr", "char", "rl", "el", "json", "form", "mail", "Url", "re", "log", "buffer", "ssl", "resource", "location", "bel", "base", "rel", "ll", "pl", "ob", "sl"], "stream": ["Stream", "message", "path", "iter", "read", "user", "transform", "http", "out", "secure", "input", "steam", "download", "open", "context", "REAM", "sync", "file", "present", "clean", "reader", "zip", "str", "down", "feed", "our", "pool", "window", "image", "row", "source", "in", "pipe", "console", "view", "body", "form", "enc", "upload", "stack", "iterator", "buffer", "resource", "sw", "res", "sample", "data", "ream", "mount", "channel", "sl"], "writer": ["wright", "maker", "liner", "creator", "storage", "wrote", "draw", "write", "widget", "output", "writers", "file", "written", "reader", "player", "string", "browser", "client", "loader", "builder", "window", "word", "null", "writ", "WR", "to", "manager", "riter", "er", "master", "io", "caster", "document", "ner", "console", "w", "writing", "unsigned", "Writer", "worker", "white", "buffer", "wire", "local"], "editor": ["external", "liner", "creator", "init", "or", "over", "article", "accept", "cer", "storage", "ui", "application", "options", "widget", "translation", "older", "author", "description", "instance", "paper", "reader", "core", "media", "video", "actor", "EDIT", "player", "browser", "oder", "vector", "loader", "Editor", "answer", "entry", "builder", "key", "term", "action", "area", "settings", "er", "offer", "document", "owner", "folder", "view", "definition", "edit", "option", "upload", "edited", "license", "insert", "finder", "buffer", "enter", "server", "code", "auto", "language", "order", "maker", "button"], "name": ["path", "init", "format", "title", "id", "all", "info", "type", "filename", "nl", "description", "file", "size", "string", "str", "root", "system", "nm", "key", "Name", "word", "n", "family", "source", "label", "term", "one", "null", "lower", "tree", "version", "part", "named", "length", "text", "position", "ame", "no", "NAME", "me", "names", "resource", "order", "code", "local", "base", "comment", "prefix", "alpha", "normal"], "dialog": ["doect", "redog", "doiz", "tdect", "dialg", "dialogue", "initialOG", "redect", "redg", "tdg", "dialect", "compog", "doog", "dog", "dialOG", "Dialose", "dialag", "Dialog", "Dialag", "dlOG", "conresh", "initialose", "tdiz", "conog", "initialog", "dlose", "dialogs", "choog", "choop", "dialresh", "dializ", "Dialresh", "Dialoder", "Dialop", "compresh", "dlogue", "dialch", "compch", "dlogs", "tdog", "Dialogs", "dialose", "dlop", "dialop", "Dialogue", "rediz", "Dialch", "dlog", "DialOG", "choogue", "choogs", "conoder", "dlag", "compoder", "dialoder", "initialag", "conch"]}}
{"id1": "8330057", "id2": "3184073", "code1": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 0, "substitutes": {"getHttpURL": ["getHTTPUrl", "printHTTPUrl", "getHttpAddress", "getHTTPURL", "printHttpAddress", "getHttpUrl", "printHTTPurl", "getServiceAddress", "printHTTPURL", "getHTTPurl", "printHttpurl", "printHttpURL", "getServiceurl", "getServiceURL", "getHttpurl", "gethttpURL", "getHTTPAddress", "gethttpUrl", "getServiceUrl", "printHttpUrl", "printHTTPAddress", "gethttpAddress", "gethttpurl"], "url": ["path", "full", "pp", "str", "https", "nl", "image", "loc", "domain", "source", "label", "host", "u", "method", "util", "xml", "build", "connection", "resource", "name", "format", "URL", "lr", "id", "parser", "key", "window", "default", "result", "ref", "ll", "www", "dl", "api", "ur", "link", "string", "ocl", "html", "term", "page", "img", "gc", "github", "version", "ret", "buffer", "ssl", "ul", "res", "base", "location", "data", "pl", "mount", "channel", "sl", "http", "type", "download", "address", "l", "web", "null", "uri", "document", "msg", "impl", "Url", "server", "hub"], "uc": ["BC", "ucc", "oc", "uph", "us", "uf", "uu", "tc", "sc", "ocr", "ci", "func", "auc", "kt", "fc", "pc", "bc", "uci", "rc", "ur", "ut", "asc", "cc", "cl", "orc", "utt", "c", "uds", "uca", "mc", "u", "ac", "gc", "ct", "roc", "ud", "unc", "pac", "icc", "cus", "util", "ubis", "eu", "nc", "userc", "uh", "UC", "soc", "lu", "aus", "uid", "cu", "usc", "ub", "ux", "unsigned", "um", "universal", "ctrl", "con", "ul", "cur", "anc", "ru", "ui", "uv", "lc", "uma"], "allHeaders": [" allSignERS", "allheadered", "allHeadels", "AllHoldERS", "allBuffsters", "allHeadsters", " allHeadheaders", "allheaders", "allSigners", " allHeadERS", "allBuffERS", "allHoldels", " allSignels", " allHeadels", "allFootheaders", "AllHoldered", "AllHeadERS", "allHoldsters", "allFooters", "AllHeadered", "allHolders", "allSignheaders", "allHeadered", "allheadsters", "allSignERS", "allHoldERS", "AllHeadsters", "allHeadERS", "allFootERS", "allHoldheaders", "allHoldered", "AllHoldsters", "AllHeaders", " allSignheaders", "allheadERS", " allSigners", "allBuffered", "allSignels", "allHeadheaders", "allFootels", "allBuffers", "AllHolders"], "itHeaders": ["itHeadings", "itHEADers", " itDefERS", "itHosttons", "ItHeaderings", "itHeaderlers", "itHeaderings", "itMaclers", "itHEADles", " itDefs", "itHolds", "ItHeaderers", "itHolders", " itHeads", "icHeadters", "itHoldERS", "itHEADERS", "itHeads", "itHeaderers", "itHeadtons", "icHosttons", "icHeadERS", "itHEADters", "itHeaderters", "itHeaderERS", "ItHeads", "itHeadertons", "ItHeaders", "itDefles", "icHostters", "itHEADlers", "itHEADtons", "itHEADings", "icHeadtons", "icHeaders", "itHostters", "itMacings", "icHostERS", "itHeadlers", "icHosters", " itHeadles", "ItHeaderlers", "itHeadles", "itHostERS", "ItHeadlers", " itDefers", "itHosters", "itDefers", " itDefles", "itDefERS", "itHEADs", "itDefs", "ItHeadings", "itMacers", "itMacs", "itHoldles", "itHeadters", " itHeadERS", "itHeadERS"], "e": ["ce", "r", "be", "oe", "xe", "l", "se", "eg", "entry", "ae", "de", "ue", "end", "one", "le", "ent", "ze", "pe", "ve", "ea", "ed", "er", "eu", "ne", "owner", "el", "element", "ge", "E", "te", "ie", "es", "ec", "re", "ke", "eur", "et", "ei", "ele", "ev", "ee"], "itValues": ["Itvalues", "litContents", "iVs", "litValues", "ritFrames", "ItItems", " itKeys", "itItems", "ITvalues", "atvalues", "iKeys", "ritVs", "ITVersions", "ItContents", "itVersions", "atVersions", "litVersions", "ritValues", "iFrames", "ITContents", "itFrames", "atItems", "iValues", " itVs", "itvalues", "ItValues", "itContents", "ITValues", "ItVersions", "ITItems", "itKeys", "atValues", "itVs", "litvalues", " itFrames", "ritKeys"], "in": ["In", "ad", "is", "input", "rin", "it", "r", "m", "IN", "inn", "l", "inf", "bin", "stream", "ins", "n", "this", "from", "inc", "mc", "en", "mi", "ic", "io", "ind", "din", "cin", "i", "inner", "o"], "display": ["change", "read", "flash", "draw", "store", "register", "lo", "dis", "PLAY", "download", "enable", "enabled", "description", "debug", "link", "browser", "load", "summary", "html", "color", "label", "details", "screen", "visible", "relevant", "layout", "field", "view", "embed", "style", "report", "show", "position", "clear", "Display", "render", "friendly", "hide", "print", "play", "replace", "DIS"], "reader": ["read", "driver", "iter", "Reader", "dr", "parse", "r", "older", "ser", "editor", "rx", "parser", "proc", "loader", "builder", "roller", "rar", "stream", "row", "dd", "layer", "er", "rl", "runner", "io", "upper", "handler", "ner", "rr", "body", "writer", "reading", "worker", "iterator", "buffer", "inner", "readable", "ro"], "s": ["ls", "cs", "gs", "is", "full", "gets", "ges", "acs", "ts", "ds", "ves", "fs", "vs", "ans", "ats", "sv", "prints", "l", "se", "str", "string", "less", "sts", "sq", "ends", "tes", "rs", "still", "ins", "os", "p", "h", "als", "S", "y", "fts", "hs", "its", "js", "aws", "sb", "ps", "stats", "ss", "qs", "sample", "ws", "ms", "es", "ims", "ns"], "contentType": ["filetype", "contenttype", " contentTime", "fileTypes", "Contenttype", "ContentTime", "ContentType", " contentTypes", " contenttype", "fileTime", "ContentTypes", "contentTypes", "contentTime", "fileType"], "filename": ["path", "wrote", " fn", "write", "face", "fs", "f", "output", "ename", "FN", " writer", "fp", "bf", "Filename", " path", "nm", " name", "fn", "uri", "fil", "ame", "writer", "ername", "name", " fil"]}}
{"id1": "6379126", "id2": "20232250", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "label": 0, "substitutes": {"gerarTutorialPage": [" crearTeoyPage", " crearTeutorialScreen", " crearTiaryPage", " crearTeoyServer", " crearTeutorialServer", " crearTiblPages", " crearToyScreen", " crearTutorialPages", " crearTiblScreen", " crearTeoyPages", " crearTutorialServer", " crearTiaryServer", " crearToyPage", " crearToyPages", " crearTeutorialPage", " crearTiaryScreen", " crearTeoyScreen", " crearTutorialScreen", " crearTeutorialPages", " crearTiblPage", " crearTiblServer", " crearTiaryPages", " crearToyServer", " crearTutorialPage"], "indexDir": ["scriptDIR", "scriptFolder", "htmlFolder", "htmlPath", "scriptDir", "appPath", "indexDIR", "htmlDir", "appDir", "htmlDIR", "appFolder", "indexPath", "scriptPath", "indexFolder", "appDIR"], "cssDir": ["cssDIR", "stylesdir", "statsDb", "ssdir", "ssDir", "cssdir", "stylesDirectory", "cmsDir", "cssUrl", "cssDirectory", "csUrl", "ssDb", "stylesUrl", "cssRect", "csDirectory", "icsdir", "csdir", "stylesDIR", "statsUrl", "statsDir", "ssDirectory", "icsDirectory", "stylesDir", "cmsDirectory", "cmsDIR", "cmsdir", "ssRect", "icsDir", "cssDb", "ssUrl", "csRect", "stylesDb", "ssDIR", "icsRect", "csDir"], "capDir": ["configFile", "CapFile", "CapDb", "CapDir", "capFile", "configTier", "cmpFile", "capTier", "capDb", "cmpTier", "cmpDb", "configDir", "configDb", "CapTier", "cmpDir"], "licDir": ["licDs", "vidRot", "vidDir", "liaDb", "libRot", "libDs", "vidDb", "vidDs", "licRot", "licDb", "liaDs", "libDb", "liaRot", "liaDir", "libDir"], "midDir": ["midDirectory", "mnDir", "pidDir", "pidCat", "manCat", "mnRot", "manDir", "midCat", "mnDirectory", "manDirectory", "mnCat", "pidDirectory", "manRot", "midRot", "pidRot"], "filesDir": ["framesIter", "sectionsIter", "imagesDIR", "framesJar", "framesDIR", "imagesFolder", "filesDIR", "sectionsDir", "imagesDir", "framesDir", "sectionsJar", "tagsJar", "pagesDir", "pagesFolder", "videosFix", "pagesRel", "tagsDir", "videosDIR", "framesRel", "pagesdir", "framesFolder", "filesRel", "framesFix", "videosFolder", "videosRel", "filesRect", "filesdir", "tagsIter", "tagsRect", "imagesFix", "framesRect", "filesJar", "videosdir", "sectionsRect", "filesFolder", "filesIter", "filesFix", "framesdir"], "videosDir": [" videosFile", " videosdir", "videoFolder", "imagesFolder", "videosFile", "imagesDir", "versionsDir", "videodir", "versionsFolder", "videosFolder", "imagesdir", "videoDir", "imagesFile", "versionsFile", "videosdir", " videosFolder"], "imagensDir": ["imgensFolder", "imagetsDb", "imagmesDirectory", "imagearsFolder", " imagensFolder", "imagearsDb", "imgetsDirectory", "imagmesDir", "imagensesDir", "imagotsDIR", "imgetsDir", "imgetsDIR", " imagetsIn", "imgetsFolder", "imagotsFolder", "imagensesFolder", "imagetsDirectory", " imagetsDir", " imagetsFolder", "imagmesDIR", "imagensFolder", "imgensDirectory", "imagmesFolder", "imagearsDir", "imagetsIn", "imagotsDir", "imagensDIR", " imagetsDb", "imagearsIn", "imgensDir", "imagotsDirectory", "imgensDIR", "imagensesIn", "imagensDirectory", "imagensDb", "imagetsDir", "imagensesDb", "imagetsFolder", " imagensDb", "imagensIn", " imagensIn", "imagetsDIR"], "local": ["land", "full", "install", "http", "personal", "where", "pal", "al", "home", "tmp", "lib", "present", "list", "dir", "current", "l", "back", "central", "shared", "standard", "client", "lock", "root", "self", "system", "test", "pid", "loc", "managed", "val", "single", "serial", "global", "util", "upper", "initial", "part", "valid", "state", "parent", "remote", "temp", "Local", "mail", "south", "internal", "server", "location", "base", "installed", "alpha", "western", "hid", "simple", "localhost"], "srcCss1": ["srcSssOnce", "srcSss1", "srcSCss1", "srcSss2", "srcLss1", "srcCxx10", "srcCass3", "srcCfg2", "srcSCss2", "srcCxx1", "srcCfg1", "srcLss10", "srcCSS3", "srcSCass0", "srcCcss1", "srcLssOnce", "srcLass10", "srcChessasso", "srcCass0", "srcCSS1", "srcCson2", "srcCcss0", "srcCcssOnce", "srcCfgOnce", "srcCss0", "srcCSS2", "srcSss3", "srcScss3", "srcCssOnce", "srcCassOnce", "srcCson10", "srcSCss0", "srcCson1", "srcCassasso", "srcChess0", "srcSCss3", "srcCcss2", "srcCssasso", "srcCass2", "srcCxx0", "srcCxxasso", "srcCSS0", "srcSCass3", "srcCss10", "srcLass1", "srcLassOnce", "srcLss2", "srcCcss3", "srcScssOnce", "srcSCass1", "srcScss2", "srcLass2", "srcChess10", "srcSCass2", "srcChess1", "srcCass10", "srcScss1", "srcCass1", "srcCfg3", "srcCsonOnce", "srcCcss10"], "destCss1": ["destCrss1", "destCass1", "destCxx0", "destScss0", "destSss100", "destCcss2", "destCcss100", "destChess0", "destScss2", "destCcss1", "destSss1", "destSss5", "destSssPre", "destCcss0", "destCcssPre", "destCxx2", "destChess100", "destCassPre", "destSass0", "destCrss0", "destCass2", "destCass0", "destSassPre", "destCssPre", "destSass1", "destSass100", "destCss0", "destCss100", "destCass100", "destCrss5", "destCxx1", "destCrss2", "destSss0", "destCass5", "destChess1", "destCcss5", "destChess2", "destSass2", "destScss1", "destSss2", "destCxxPre", "destScss5"], "srcCss2": ["srcSCssTwo", "srcCss52", "srcSCss1", "srcCassTwo", "srcCtxTwo", "srcCsv3", "srcCsv52", "srcSCassTwo", "srcCcss4", "srcCsv2", "srcCfg2", "srcSCss2", "srcCssTwo", "srcCfg1", "srcCass4", "srcCfg4", "srcCffee3", "srcSCss4", "srcCsv48", "srcCcss1", "srcSCass4", "srcCffee1", "srcCson2", "srcCcss8", "srcCtx4", "srcCtx2", "srcCson8", "srcCcss52", "srcCson1", "srcCsv1", "srcCcss2", "srcCcss48", "srcCass2", "srcCffee52", "srcCfg8", "srcCcss3", "srcSCass1", "srcCcssTwo", "srcCson4", "srcCss8", "srcSCass2", "srcCss48", "srcCass1", "srcCtx1", "srcCffee2"], "destCss2": ["destCass1", "destCcs3", "destCcss2", "destCss02", "destCcss1", "destCrosse2", "destSss1", "destCcs42", "destChess56", "destCcss3", "destCSS42", "destCass4", "destCass56", "destCSS02", "destCSS3", "destCrosse1", "destCSS2", "destCcs02", "destSss3", "destCss42", "destCcss4", "destCrosse4", "destCass2", "destCass3", "destSass1", "destChess3", "destSss2", "destCcs2", "destCcss56", "destSass3", "destSss56", "destCss56", "destChess1", "destChess2", "destSass56", "destSass2", "destCcss02", "destCcss42"], "srcCss3": ["srcCsv2", "srcCass4", "srcCass43", "srcScss03", "srcCess3", "srcCess6", "srcCcssthree", "srcCcss03", "srcCcssThree", "srcCcss6", "srcCcss3", "srcCassThree", "srcCcss43", "srcCass3", "srcCcssThird", "srcCss43", "srcCass03", "srcCoss6", "srcCrss1", "srcCessThree", "srcCssThird", "srcScss43", "srcCessthree", "srcCess4", "srcCsv3", "srcCxx43", "srcCSS3", "srcCssThree", "srcCssthree", "srcCossthree", "srcSss3", "srcSss43", "srcCxx03", "srcCrss3", "srcCrss2", "srcCxx3", "srcCoss3", "srcSss03", "srcCassThird", "srcCessThird", "srcCcss4", "srcCSS1", "srcCSS2", "srcScss3", "srcCsv1", "srcCss03"], "destCss3": ["destCass1", "destCass30", "destCcss2", "destCss53", "destCls83", "destCcss83", "destCfg3", "destCess83", "destCcss30", "destCcss1", "destCfg23", "destCass03", "destCcss3", "destCSS1", "destCess53", "destCss03", "destCSS3", "destCSS2", "destCls3", "destCcss03", "destCess3", "destCass3", "destCass2", "destCcss53", "destCass23", "destCss30", "destCcss23", "destCSS30", "destCls53", "destCss83", "destCss23", "destCfg03"], "srcCss4": ["srcSssFour", "srcCsv5", "srcSss2", "srcCSS4", "srcCcssFour", "srcCcss4", "srcCsv2", "srcCssFour", "srcCcss5", "srcScss5", "srcCSS5", "srcCsvFour", "srcCSS2", "srcCsv4", "srcScssFour", "srcSss5", "srcCcss2", "srcScss4", "srcScss2", "srcSss4", "srcCSSFour"]}}
{"id1": "18202328", "id2": "17792212", "code1": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"register": ["setup", "launch", "remember", "match", "auth", "install", "store", "bind", "update", "save", "login", "reg", "link", "record", "email", "submit", "Register", "hook", " Register", "handle", "password", "log", "insert", "account", "server", "create", "hello", "callback"], "session": ["person", "message", "user", "store", "cache", "input", "application", "subject", "database", "shell", "ion", "instance", "join", "task", "journal", "present", "use", "game", "second", "request", "current", "network", "lock", "browser", "client", "Session", "job", "summary", "system", "self", "window", "ession", "sid", "environment", "action", "manager", "station", "to", "settings", "global", "master", "version", "password", "document", "result", "site", "state", "view", "course", "set", "position", "sim", "parent", "remote", "usage", "condition", "process", "account", "connection", "spin", "server", "question", "play", "response", "connect", "brain", "status", "member", "local", "localhost", "activity"], "username": ["person", "user", "message", "path", "sword", "auth", "joining", "title", "human", "steam", "url", "information", "subject", "filename", "description", "login", "pty", "minecraft", "string", "uno", "email", "character", "sn", "USER", "key", "john", "term", "word", "software", "source", "User", "host", "uri", "cn", "rue", "nil", "master", "password", "owner", "token", "attribute", "artist", "minimum", "pai", "text", "uid", "taker", "ame", "wikipedia", "ername", "NAME", "monitor", "account", "approximately", "displayText", "profile", "name", "nick", "prefix", "whatever", "hello", "restricted"], "verificationKey": ["veridationKEY", "verifierPoint", "verationkey", "verifyingKeys", "verationKey", "verificationKeys", "veridationKeys", "vericationKEY", "validificationKeys", "verifyingKEY", "validificationKey", "verifyingkey", "verifyingPoint", "certicationPoint", "validificationkey", "validifyingkey", "vericationKey", "veridationkey", "certificationKEY", "certicationKEY", "validifyingKEY", "verifyingKey", "verationKEY", "validificationKEY", "vericationkey", "validifyingKeys", "certificationkey", "veridationKey", "certicationKey", "verifierKEY", "verificationKEY", "verifierKey", "certicationkey", "verifierkey", "certificationPoint", "verationKeys", "certificationKey", "verificationkey", "validifyingKey", "verificationPoint", "vericationPoint"], "salt": ["thunt", "Sunt", "Salt", "holt", "hALT", "ssALT", "halt", "sodium", "hsl", "hunt", "solt", "SALT", "sunt", "ssodium", "thalt", "Ssl", "thALT", "ssalt", "sALT", "ssl", "Sodium", "hodium", "tholt", "Solt", "sssl"], "hash": ["user", "message", "title", "flash", "cache", "search", "url", "filename", "ash", "hed", "mac", "test", "html", "key", "memory", "word", "random", "h", "handle", "href", "password", "version", "token", "shadow", "sha", "report", "hex", "build", "log", "crypt", "Hash", "rh", "sum", "sample", "name", "her", "tag", "secret"], "digest": ["decest", " Diger", "mdEST", "Digester", "Dighash", " digEST", "bighash", "Diger", "digEST", "digester", " Digest", "redester", "mder", "mdester", "Digests", "signhash", "signest", "redest", "Digit", " Digester", "decEST", "mdest", "digested", "Digest", "diger", "mdit", "digests", "bigest", " diger", "redit", "reder", "dighash", " DigEST", "decester", "signests", "decested", "digit", "bigests", "DigEST", "Digested", " digester", " digested"], "nameChars": ["nameCharats", "nameCharars", "nameChers", "nameChats", "namechARS", " nameChcs", "nameChecs", " nameCheras", "namechcs", " nameCheARS", "nameCharrs", "namechrs", " nameChears", " nameChras", "nameChrs", "nameCheats", " nameChats", "namechats", "nameCharcs", "nameCheARS", " nameChecs", " nameChers", "nameChras", "nameChARS", "nameStrARS", "nameChcs", "nameStrras", "nameStrars", "namechras", " nameChrs", "namechars", "nameChears", " nameChARS", "nameCheras", " nameCheats"], "nameChar": [" nameArc", "NameCh", "charChar", " nameCharacter", "caseCharacter", "reasonCharacter", "charFix", "namechar", "namesFix", "charchar", "reasonArc", "reasonCh", "caseChar", "casechar", "ameCh", "reasonChar", "nameschar", "ameCharacter", "ameChar", " namechar", "NameCharacter", "NameChar", "ameArc", " nameFix", "nameCh", "Namechar", "nameFix", "caseCh", "nameCharacter", "charCh", "namesChar", "namesCh", "nameArc", " nameCh"], "p": ["user", "pt", "pp", "wp", "perm", "tp", "vp", "pa", "bp", "f", "pm", "m", "per", "mp", "pkg", "fp", "php", "pc", "t", "pre", "l", "peer", "pro", "cp", "u", "pe", "er", "op", "part", "pai", "sp", "gp", "par", "pers", "ps", "jp", "i", "d", "v", "pi", "P", "np", "lp", "pl", "ap"], "player": ["person", "user", "header", "slot", "board", "vp", "steam", "PLAY", "address", "wrapper", "ser", "winner", "party", "video", "game", "actor", "program", "aster", "slave", "top", "loader", "peer", "linger", "live", "pro", "cp", "Player", "layer", "station", "er", "master", "played", "part", "pai", "handler", "field", "owner", "taker", "position", "adder", "worker", "controller", "playing", "role", "timer", "server", "league", "play", "profile", "name", "lp", "node", "admin", "member", "ler"], "c": ["cs", "cd", "conf", "tc", "sc", "r", "ci", "toc", "config", "fc", "t", "rc", "l", "cc", "cb", "etc", "dc", "mc", "cp", "u", "h", "ct", "ac", "gc", "ic", "C", "cm", "cr", "cu", "enc", "uc", "g", "conv", "ca", "con", "co", "cf", "v", "lc", "cfg"]}}
{"id1": "16931472", "id2": "9319440", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 1, "substitutes": {"handler": ["read", "transform", "init", "accept", "update", "received", "output", "request", "processing", "done", "success", "proc", "end", "action", "hook", "processor", "handle", "forward", "adapt", "Handler", "handled", "controller", "render", "Handle", "execute", "index", "callback"], "result": ["Result", "full", "make", "cache", "out", "all", "output", "list", "map", "current", "done", "product", "met", "RESULTS", "success", "found", "results", "memory", "source", "page", "details", "created", "successful", "mate", "master", "valid", "sequence", "report", "status", "ret", "buffer", "total", "res", "hash", "profile", "response", "data", "complete", "table"], "target": ["external", "transform", "info", "project", "t", "Target", "test", "arg", "next", "source", "report", "e", "history", "name", "node", "service", "alias", "format", "thread", "subject", "that", "translation", "trace", "tif", "self", "window", "primary", "proxy", "scope", "handle", "valid", "controller", "bolt", "local", "table", "dest", "iter", "task", "trigger", "link", "top", "peer", "term", "this", "page", "expected", "manager", "layout", "tree", "version", "remote", "goal", "buffer", "jp", "prototype", "base", "arget", "closure", "match", "template", "http", "component", "it", "type", "output", "pkg", "gt", "detail", "object", "tool", "cmd", "to", "master", "view", "style", "parent", "internal", "complete"], "url": ["ls", "dl", "cert", "http", "URL", "lr", "git", "address", "f", "file", "l", "ur", "link", "browser", "client", "loader", "web", "html", "nl", "loc", "hl", "uri", "char", "rl", "el", "impl", "mail", "Url", "build", "ssl", "connection", "ul", "bel", "base", "rel", "ll", "mount", "hub", "service", "sl"], "reader": ["read", "driver", "iter", "liner", "Reader", "review", "context", "older", "file", "and", "parser", "loader", "builder", "rar", "stream", "row", "linger", "uri", "layer", "rl", "er", "runner", "upper", "ner", "rr", "writer", "reading", "redo", "iterator", "buffer", "rot", "resource", "inner", "cur", "operator", "readable", "ro"], "line": ["message", "LINE", "online", "range", "liner", "block", "iter", "user", "store", "out", "lo", "ln", "file", "inline", "frame", "ine", "l", "link", "eline", "lock", "trace", "cell", "string", "email", "lin", "network", "nl", "continue", "word", "rule", "row", "detail", "source", "limit", "le", "next", "page", "section", "Line", "loop", "state", "sequence", "text", "body", "style", "port", "no", "log", "entity", "chain", "buffer", "lines", "queue", "date", "zone", "print", "level", "code", "base", "sample", "now", "node", "point", "stay", "status", "comment", "ip"], "entry": ["pixel", "match", "ex", "check", "or", "ace", "it", "search", "office", "ary", "instance", "list", "quick", "add", "se", "cell", "record", "Entry", "job", "key", "term", "row", "pair", "ent", "object", "exit", "def", "char", "part", "element", "field", "ie", "e", "deep", "enter", "escape", "inner", "ry", "comment", "member"], "fromIndex": ["leftindex", "FromAlpha", "minindex", " fromindex", "forindex", "oldInd", "fromInt", "fromLink", " fromAlpha", "normalInt", " fromInt", "normalIndex", "FromInd", " fromPosition", "fromInd", "leftPosition", "forIndex", "fromindex", "FromIndex", "oldIndex", "minInd", " fromLink", "normalindex", "oldAlpha", "minIndex", "leftInd", "leftIndex", "normalInd", "forInd", "fromPosition", "FromLink", "forPosition", "oldLink", "minInt", "fromAlpha", " fromInd"], "r": ["b", "rect", "range", "dr", "vr", "err", "m", "sr", "l", "rt", "rb", "str", "rc", "rg", "ar", "rar", "n", "rs", "kr", "q", "p", "nr", "u", "er", "cr", "rr", "w", "g", "e", "R", "re", "render", "rd", "v", "res", "mr", "rate", "fr"]}}
{"id1": "2396191", "id2": "9805906", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFormHTTPfast", "getLinksFromUrlFast", "getLinksFromURLfast", "getLinksFromUrlfast", "getLinksFromURISafe", "getLinksFromUrlSafe", "getLinksFromHTTPfast", "getLinksFromURIFast", "getLinksFormHTTPSafe", "getLinksFormURLfast", "getLinksFromHTTPFast", "getLinksFormURLSafe", "getLinksFromURIfast", "getLinksFormURLFast", "getLinksFromURLSafe", "getLinksFormHTTPFast", "getLinksFromHTTPSafe"], "p_url": ["pongurl", "primary_URL", "p64email", "ping_page", "ping_url", "p_uri", "private_html", "postonURL", "pingYlr", "p_lr", "primaryongurl", "p6html", "adminoyurl", "adminoymail", "pongURL", "pongorg", "postonorg", "primary_org", "p_json", "p_mail", "private_browser", "p___lr", "pYlr", "primaryongURL", "vp_url", "pingYpage", "pswjson", "porehtml", "vp_lr", "admin_url", "poredir", "ping_line", "private_dir", "pswurl", "p_email", "x_uri", "p_browser", "p64URL", "p3uri", "admin_dir", "pingYline", "adminoydir", "adminoyuid", "p___line", "admin_uid", "p3lr", "p_page", "x3uri", "pswlr", "pYline", "pYpage", "x3lr", "p6url", "pongemail", "x3dir", "poreurl", "porebrowser", "p___page", "poydir", "p___url", "primaryongemail", "p3url", "p_org", "p6browser", "p_link", "vp_link", "primaryongorg", "p64url", "primary_email", "private_url", "vp_json", "p_dir", "p_uid", "poyuid", "pingYurl", "x3url", "p64org", "admin_mail", "primary_url", "poyurl", "postonemail", "pswlink", "ping_lr", "x_lr", "p3dir", "poymail", "p_URL", "pYurl", "p6dir", "p_html", "postonurl", "p_line"], "x_url": ["xJweb", "xJnet", "xJurl", " x_net", " x_web", "x_ls", "x_web", " x_log", " x_cn", "x_net", " x_ls", "x_log", "x_cn", "xJlog"], "x_conn": ["p_conn", "x3nt", "p_ws", "x_connection", " x_nt", " x_client", "x_ws", "x_con", "p_con", "x_client", "x3connection", "x_nt", "p_connection", "x3client", "x3conn", " x_connection"], "x_is_reader": ["x_is_read", "x_isresreader", "x_is_writer", "x_is2reader", "x_ais_rx", "x_is_Reader", "x_is2read", "x_isresrx", "x_isresparser", "x_is_rx", "x_is2Reader", "x_ais_writer", "x_ais_parser", "x_ais_reader", "x_isreswriter", "x_is_parser", "x_is2writer"], "x_reader": ["ex_rr", "ex_reader", "x_buffer", "x_rr", "rx_writer", "x8reader", "rx_rot", "x8rot", "x8writer", "x8buffer", "rx_buffer", "rx_reader", "x_stream", "ex_stream", "ex_writer", "x_writer", "x_rot"], "x_line": ["x_____print", "ex_route", "xmystream", "x_iter", "xLEline", "xLEstream", "ex_page", "x_____match", "xmyline", "xLEiter", "ex_link", "xmypage", "ex_line", "xmyiter", "x_stream", "x_print", "x_____line", "ex_stream", " x_print", "ex_iter", "xLEpage", "x_route", "x_____page"], "e": ["ce", "ere", "r", "f", "err", "be", "oe", "EEE", "m", "xe", "t", "l", "se", "eg", "ae", "x", "de", "c", "ue", "n", "one", "end", "le", "a", "ent", "en", "u", "h", "pe", "ze", "fe", "he", "ea", "ed", "er", "eeee", "eu", "ne", "el", "element", "y", "ge", "exp", "E", "eps", "te", "ie", "es", "eb", "ec", "re", "g", "ef", "me", "event", "eur", "et", "d", "ei", "o", "ele", "ev", "ee", "we", "ye"], "x_match": ["x2member", "xi_message", "x_member", "rx_mat", " x2process", "x___fire", " x2mat", "x___member", "xi_match", "x10member", "x_mat", "x__find", "x___mat", "ex_match", "x___move", "ex_entry", "x__result", " x2match", "rx_member", "xi_fire", "xi_move", "rx_match", " x2member", "x2process", "x___match", "rx_tag", "x2mat", "x_tag", "ex_look", "x10entry", "x___tag", "x_find", "x_move", " x_find", "x67mat", "x67member", "x10match", "x_fire", "ex_member", "x_message", "x___message", "x2match", "ex_result", "x_look", "x10result", " x_mat", "x67process", " x_member", "x_entry", "x_process", "x__mat", "x__match", "x67match", " x_process"], "x_dir": ["x5file", "x5div", "x5path", "x_file", "x_path", "x5dir", "ex_div", "ex_file", "x_div", "ex_path", "ex_dir"], "x_root": ["x__root", "x7path", "inx_root", "x__path", "inx_parent", "x7target", "inx7target", "inx_path", "inx7path", "x__target", "inx_target", "x_path", "x__parent", "x_target", "x_parent", "x7parent", "inx7parent", "inx7root", "x7root"], "x_links": ["x_pages", "x__relations", "x__links", "x_relations", " x_lines", "x__lines", "x_lines", "x__pages", " x_pages", " x_relations"], "x_texts": ["x__texts", "x_lengthls", "x__textsets", "x_pathls", "x__textes", "x_textls", "x__logs", "x_loges", "x_pathsets", "x__logls", "x_logsets", "x_lengthsets", "x_logs", "x_textsets", "x_lengthes", "x_textes", "x_pathes", "x__textls", "x_lengths", "x_logls", "x_paths", "x__loges", "x__logsets"], "x_buf": ["x_pool", "ex2buf", "x7temp", "ex2bag", " x_pool", "x_temp", "x_buffer", "x_bag", "x7buff", "ex2Buff", "x___bag", " x2pool", "x7pool", "x2temp", "x_buff", " x_temp", "x2buf", "x64bag", "ex2temp", " x2buf", "x2pool", " x2temp", "ex_temp", " x_buff", "x___Buff", "x2bag", "x2uf", "ex_bag", "x7buf", "x___buf", "x_uf", " x_uf", " x2buff", "ex_buf", "x64Buff", "x2buffer", "x64temp", "x2buff", "x_Buff", "x2Buff", "x___temp", "x64buf", " x_buffer", "ex_Buff"], "x_matches": ["x_memqs", "x_morets", "x_catets", "x_formatices", "x_patters", "x_morters", "x_formatcher", "x_actches", "x_machers", "x_matets", "x_memaches", "x_masets", "x_masists", "x_morcher", "x_maschers", "x_matchchers", "x_attets", "x_matices", "x_Mataches", "x_matcher", "x_catters", "x_matists", "x_formatchers", "x_Matchers", "x_maqs", "x2patets", "x2patcher", "x_Matices", "x2patches", "x_actchers", "x_actices", "x2matets", "x_Matqs", "x_attists", "x_patcher", "x_memches", "x_matchters", "x__masists", "x_actcher", "x_catists", "x_attchers", "x__masets", "x_patches", "x_patchers", "x_formatches", "x__maschers", "x_Matcher", "x_catches", "x_matqs", "x_memchers", "x_patets", "x2matches", "x__matches", "x_matchches", "x_maaches", "x_matters", "x_catchers", "x2matters", "x_morches", "x_attches", "x2matcher", "x__matets", "x_maches", "x2patters", "x__matists", "x_Matches", "x_matchets", "x_matchers", "x_masches", "x_mataches", "x__masches", "x_matchcher", "x__matchers"], "x_page": ["x_pp", "xhomeline", " x_port", "x_port", " x_pp", " x_message", "xtline", "xturl", "xtmessage", "p_net", "xhomeport", "xhomepp", "x_message", "x_net", "xhomepage", "p_page", "xtpage", "p_line"], "x_link": ["xe_url", "x42page", " x_location", "x_ink", "xe_link", "x42location", "x_path", "xe_links", "x42path", "x_location", "xe_ink", "x42link", " x_path"], "i": ["ami", "iter", "is", "init", "ims", "us", "gi", "id", "qi", "xi", "it", "info", "ci", "li", "I", "m", "oi", "ai", "ix", "iq", "hi", "ki", "x", "bi", "key", "origin", "n", "ii", "PI", "this", "mi", "multi", "u", "ic", "in", "batch", "io", "fi", "y", "im", "phi", "sim", "ori", "ji", "fire", "me", "chain", "si", "v", "pi", "ti", "cli", "j", "ui", "di", "ini", "ip"]}}
{"id1": "8216539", "id2": "10158738", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"getFileContentAsString": ["getFileContentasStr", "getFileTextAsText", "getFileContentasText", "getFileContentasString", "getFileContentAsStr", "getFileTextAsStr", "getFileTextAsString", "getFileContentAsText"], "filePath": ["entryPATH", "Filepath", " filepath", "ileInfo", "FileDef", "filepath", "FileString", "ileName", "filePATH", " fileDef", "baseString", "FILEName", "entrypath", "FileInfo", "FILEpath", "ileDef", "basePath", "FileName", "entryPath", "fileDef", " fileName", "baseName", "basepath", "FilePath", "fileString", "FILEPATH", " fileString", "fileInfo", " fileInfo", "ilePath", "FILEPath", "fileName", "entryName", "FilePATH"], "encoding": ["unicuing", "Encordering", "encordering", "enode", "enoding", "enaching", "characterging", "characteroding", "Encging", "encaching", "ENCoding", "ENCordering", "encode", "ENCaching", "Encoding", "enuing", "characterordering", "Encuing", "unicoding", "Encaching", "characteraching", "unicode", "Encode", "encuing", "unicaching", "encging", "ENCging"], "testURL": ["testUrl", " testUR", "testingRE", " testRE", "testRE", "TestUrl", " testSR", "testingURL", "testedURL", "testSR", "TestURL", "checkSR", "checkUrl", "checkURL", "testingSR", "testedUrl", "testingUR", " testUrl", "testingUrl", "checkUR", "testedUR", "testedRE", "TestUR", "testUR", "TestSR"], "input": ["accept", "file", "current", "add", "feed", "image", "source", "PUT", "batch", "xml", "unsigned", "upload", "get", "ip", "init", "url", "open", "context", "exec", "focus", "stream", "in", "act", "command", "json", "has", "raw", "cont", "active", "inner", "sample", "read", "iter", "pull", "empty", "tmp", "list", "config", "quick", "Input", "missing", "acl", "eval", "up", "iterator", "data", "comment", "channel", "exist", "it", "audio", "address", "output", "lat", "reader", "client", "submit", "from", "q", "quit", "op", "view", "hidden", "qa", "form", "can", "start", "cur", "hello"], "sw": ["sl", "igm", "was", "tw", "sc", "ew", "wn", "ows", "wra", "su", " Sw", "wa", "ow", "sv", "sem", "wh", "sur", "kw", "sn", "rew", "SW", "Sw", "hw", "sk", "sh", "sp", "fw", "iw", "wl", "w", "wr", "sb", "enc", "aw", "ews", "sa", "sf", "nw", "ws", "wo", "sm", "we"]}}
{"id1": "6625074", "id2": "5808579", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 1, "substitutes": {"SHA1": ["sha512", "HS1", "sha1", "SHAOne", " SHA512", "HS2", "shaOne", " SHA2", "HS512", "SHA2", " SHAOne", "sha2", "SHA512", "HSOne"], "text": ["message", "path", "read", "pt", "template", "value", "title", "input", "it", "url", "output", "translation", "nt", "t", "ut", "string", "str", "tx", "test", "ext", "TEXT", "word", "txt", "source", "q", "act", "password", "document", "msg", "body", "form", "hex", "buffer", "cont", "event", "content", "sum", "print", "code", "v", "Text", "data", "name", "comment", "doc"], "sha1hash": ["sha0Hash", "SHA1hex", "ha2hash", "SHA1hash", "ha1address", "ha1hash", "sha1Hash", "shaonesum", "ha2Hash", "sha1sum", "sha1hex", "ha1sum", "sha2hex", "sha2message", "sha31hash", "sha31sum", "sha31Hash", "sha2sum", "shaonehex", "SHA1sum", "ha2address", "sha0sum", "sha31address", "sha2address", "sha0hash", "shaonehash", "sha3Hash", "SHA2sum", "haonemessage", "shaoneHash", "haonehash", "sha3hash", "sha3message", "haoneHash", "SHA2Hash", "sha2Hash", "ha1Hash", "shaonemessage", "ha1message", "SHA1Hash", "SHA2hash", "SHA2hex", "sha2hash", "sha0address", "sha3sum", "ha2sum", "haonesum", "sha1address", "sha1message"], "md": ["obj", "amd", "ad", "nd", "cd", "dr", "dh", "ds", "mt", " MD", "MD", "m", "pm", "alg", "and", "der", "rm", "mk", "hd", "mc", "df", "strong", "pd", "cmd", "dd", "det", "ind", "mod", "sha", "pdf", "mm", "ld", "bd", "od", "mn", "mand", "d", " Md", "sd", "hash", "ms", "di", "sm", "dm"]}}
{"id1": "15737836", "id2": "13783898", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"delete": ["disable", "update", "write", "destroy", "download", "del", "select", "save", "database", "clean", "add", "link", "load", "de", "move", "touch", "quit", "dump", "set", "clear", "drop", "get", "remove", "insert", "lete", "Delete", "execute", "create"], "site": ["item", "path", "group", "isite", "at", "template", "http", "store", "ste", "sites", "info", "file", "session", "config", "se", "network", "link", "test", "Site", "rule", "domain", "page", "source", "software", "environment", "ze", "unit", "station", "settings", "sys", "set", "course", "e", "remote", "pse", "chain", "server", "ite", "base", "sample", "data", "name", "node", "theme", "scan", "sit", "index", "service", "localhost"], "dbo": ["drabo", "dambo", "Dbu", "ddado", "gBO", "drabon", "dpo", "DBo", "dbon", "lbo", "debugpo", "lBo", "debugBo", " dado", " dbu", "delmu", "ddbu", "ddBO", "DBO", "pmu", "odpo", "dbu", "dBo", "gbu", "pbo", "delbo", " dBo", "dBO", "delpo", "drapo", "sdbo", "odbu", " dBO", "draBo", "dmu", "delbu", "ppo", "ddpo", " dbon", " dambo", "debugambo", "Dado", "lpo", "ddbo", "dado", "sdBO", "odbo", "gbo", "sdbu", "Dbon", "odBo", " dpo", "ddBo", "pbu", "Dmu", "Dbo", "lambo", "debugbo", "Dpo"], "connection": ["library", "binding", "generation", "operation", "collection", "creator", "Connection", "net", "function", "government", "office", "application", "open", "associated", "context", "output", "database", "ion", "subject", "information", "session", "config", "reference", "current", "link", "network", "bo", "client", "directory", "intention", "character", "connected", "c", "system", "container", "management", "created", "established", "computer", "manager", "cone", "settings", "document", "handler", "command", " Connection", "console", "socket", "position", "statement", "writer", "po", "engine", "city", "usage", "controller", "conn", "con", "condition", "chain", "resource", "server", "communication", "location", "auto", "pointer", "response", "connect", "db", "relation", "pool", "table", "closure"], "preparedStatement": ["prefixedstatement", "preformedCall", "prelatedStatement", "paredStatement", "pparedStatus", "prepletedStatement", "prearedStat", "prepferredSQL", "preachedStatement", "preparedGrant", "previsedStat", "preculatedSQL", "preparedDevice", "previsedStatement", "prepferredstatement", "perachedComment", "pparedQuery", "pparedStat", "pretparedStatus", "preppedstatement", "prelatedComment", "prelatedstatement", "prearedstatement", "PreppedQuery", "PreparedComment", "preachedAdapter", "prepparedstatement", "paredStatus", "paredStat", "preinitializedComment", "preparedQuery", "prejectedStatement", "prepletedDevice", "Prearedstatement", "prefixedCopy", " preparedCopy", " prefixedCopy", "preachedGrant", "prejectedCopy", "prepletedGrant", " preachedCall", "pparedStatement", "preformedGrant", "prefixedQuery", "postppedCall", "prejectedstatement", "prearedQuery", "preppedQuery", "paredQuery", "pretparedStatement", "preppedStatus", "prepletedComment", "premittedComment", "prepletedCall", "premedListener", "preendedstatement", "preculatedstatement", "prearedCopy", "PrearedComment", "perachedStyle", "preparedCopy", "prearedComment", "pretparedListener", " preachedGrant", "Preparedstatement", "preferredSQL", "prepletedstatement", "PreparedStatement", " preparedGrant", "preinitializedAdapter", "prelatedDevice", "preendedQuery", "prefixedStatement", "preculatedStatement", "premittedStatement", "perparedAdapter", "postppedstatement", "perparedStyle", "previsedStatus", "prepferredStatement", "PreparedDevice", "postparedCall", "preachedstatement", "preachedCall", " prefixedstatement", "previsedQuery", "perachedStatement", "prepferredQuery", "preferredQuery", "premedStatement", "preferredstatement", "preformedStatement", " preparedstatement", "postparedStatement", "preparedStatus", "prejectedQuery", "preinitializedStatement", "preferredCall", "preparedStat", "postparedstatement", "perparedComment", "prearedCall", "prearedSQL", "premittedStyle", "preppedStatement", "preparedComment", "preparedAdapter", "preachedStyle", "prearedListener", "preparableListener", "prepparedQuery", "PreppedStatement", "perparedStatement", "pretparableListener", "preparedSQL", " preachedStat", "postppedStatement", "preachedStat", "preparableStatement", "prepletedStat", " prefixedStatement", "preparableStatus", "preparedstatement", " preparedQuery", "perachedAdapter", "PreparedQuery", "preppedStat", "Preppedstatement", "prepparedCall", "prefixedCall", " prefixedQuery", "preppedCall", "preendedStatement", " preachedStatement", "preparedStyle", "PrearedDevice", "preparedListener", "pretparableStatement", "preculatedQuery", "prearedDevice", "preinitializedStyle", "PrearedStatement", "premittedAdapter", "preachedComment", "preformedStat", "prearedStatus", " preparedStat", " preparedCall", "prepparedSQL", "prearedStatement", "prepparedStatement", "premedStatus", "pretparableStatus", "preparedCall", "preferredStatement"], "resultSet": ["ResultSum", "resultSum", " resultTime", " resultHandle", "resultsUn", "resultHandle", " resultSum", "dataTime", "resultList", "resultSession", "resultsList", " resultStream", "characterSum", "rowHandle", "ResultStream", "ResultUn", "resultsSet", " resultSession", " resultSource", "characterStream", "characterSet", " resultPath", "ResultTime", "responseUn", "responseSet", "resultStream", "ResultPath", "resultUn", "dataStream", " resultList", "rowSession", "rowSet", "ResultHandle", "ResultSource", "resultsPath", "resultPath", "ResultList", "ResultSession", "dataSet", "responseStream", "ResultSet", "rowSource", "resultsStream", "resultTime", "resultSource"], "chkSql": ["chKDk", "chKDql", "chKDyl", "chKDQL", "chkInsq", "chkDQL", "chkSq", "chKSql", "chkStrql", "chkSQL", "chkStrq", "chkDql", "chkDk", "chkSyl", "chKSk", "chKSyl", "chkInsql", "chkInsQL", "chkRSQL", "chKInsql", "chKSq", "chkStrQL", "chKInsQL", "chKSQL", "chkDyl", "chKInsq", "chkRSql", "chkSk", "chkDq", "chkRSk", "chkRSyl"], "selfDefinePath": ["selfDefidePath", "selfdefinepath", "selfdefinesPattern", "selfDefiningPattern", "selfDeliningPath", "selfDefinedSet", "selfDefINESet", "selfDefineKey", "selfDeliningpath", "selfdefinePath", "selfDefinesDir", "selfDefinePattern", "selfDefinedpath", "selfDefiningpath", "selfDefinedKey", "selfDefiningPath", "selfDefINEpath", "selfdefinesDir", "selfDefiningKey", "selfDefinepath", "selfdefinesPath", "selfDefiningDir", "selfDefinesPattern", "selfDefinespath", "selfDefiningSet", "selfDelineKey", "selfDelinepath", "selfDefidepath", "selfdefinePattern", "selfDefinesPath", "selfDefinedPath", "selfDefINEKey", "selfDefineSet", "selfDefideDir", "selfDefidePattern", "selfdefinespath", "selfDefINEPath", "selfDeliningSet", "selfDelineSet", "selfDefineDir", "selfdefineDir", "selfDelinePath", "selfDeliningKey"], "sqlStr": ["qlName", "sqName", "SQLStr", "qlStr", "sqString", " sqlWr", "sqlSt", "sqSt", " sqlName", "sqlName", "sqStr", "SQLSt", " sqlstr", "sqstr", "sqlWr", "qlstr", "sqWr", " sqlSt", "SQLWr", "sqlString", "qlString", " sqlString", "sqlstr", "SQLstr"]}}
{"id1": "1371265", "id2": "20735941", "code1": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"update": ["match", "Update", "query", "write", "save", "find", "select", "join", "apply", "add", "UPDATE", "load", "feed", "row", "move", "touch", "up", "set", "edit", "delete", "upload", "insert", "updated", "process", "create", "replace", "index"], "channelPath": ["channelDir", "entrypath", "entryPath", " channelpath", "databasePath", " channelDir", "databaseDir", "databaseRef", " channelRef", "databasepath", "entryDir", "channelpath", "channelRef", "entryRef"], "dataField": [" dataTerm", "dataFIELD", "Datafield", " dataPath", "formatPath", "formatFIELD", "DataMethod", "formatField", "DataComponent", "dataComponent", "DATAFIELD", "DATAField", "contentComponent", " datafield", " dataMethod", "dataTerm", "formatTerm", "datafield", "DataField", "DATAPath", "contentField", "dataMethod", "contentfield", " dataComponent", "DATATerm", "contentMethod", "dataPath", " dataFIELD"], "fatherDocId": ["motherDocInfo", "motherdocPath", " fatherDocumentById", "fatherFileId", "fatherFileById", "motherDocId", " fatherDocumentid", "motherdocById", "fatherFileInfo", "motherDocPath", "fatherDocById", "fatherDocPath", " fatherDocumentID", "fatherdocPath", "motherDocById", "fatherdocInfo", "fatherDocInfo", "motherdocInfo", "motherdocId", "fatherFilePath", "fatherDocID", "fatherPostId", "fatherdocID", "fatherPostById", " fatherDocById", "fatherPostID", " fatherDocid", "fatherDocumentById", "fatherDocumentid", "fatherdocid", "fatherDocid", " fatherDocID", "fatherdocById", "fatherdocId", " fatherDocumentId", "fatherDocumentPath", "fatherDocumentInfo", "fatherDocumentID", "fatherDocumentId"], "sqlInitial": ["SQLInit", "SQLinitial", "qlInit", "qlInitial", " sqlInit", "sqlInit", "qlinitial", "SQLInitial", " sqlinitial", "sqlinitial"], "sqlsortURL": ["sqlsordSSL", "sqLSsortUrl", "sqlsortUR", "sqlssortURL", "sqlsorterUR", "sqLSortRL", "sqlsaltUR", "sqlsortRL", "sqlsordUrl", "sqlssortField", "sqlsourceUR", "sqlssortSSL", "sqLSortField", "sqlsaltSSL", "sqLSsortRL", "sqlsorterField", "sqlsaltURL", "sqLSsortURL", "sqlsourceField", "sqlsorterURL", "sqLSsortSSL", "sqLSortSSL", "sqLSortUR", "sqlsourceURL", "sqLSsortUR", "sqlsortField", "sqlsorterRL", "sqlsaltUrl", "sqLSsortField", "sqLSortURL", "sqlsortUrl", "sqlssortRL", "sqlsourceRL", "sqlsordUR", "sqlsortSSL", "sqlssortUR", "sqlssortUrl", "sqlsordURL", "sqLSortUrl"], "conn": ["obj", "Conn", "Connection", "ctx", "cert", "conf", "wp", "adj", "ds", "yn", "open", "comm", "wn", "cfg", "nt", "pkg", " cx", "exec", "rc", "ctr", "oss", "ann", "https", "client", "cb", "apt", "org", "cc", " con", "c", "priv", "n", " Conn", "p", "gate", "cp", "close", "dn", "ct", "cmd", "cn", "addr", "canon", "gc", "resp", "act", "nc", "lang", "sys", "sp", "socket", "ch", "enc", "js", "ca", "conv", "ec", "con", "mn", "jp", "connection", "pen", "cons", "res", "cur", "rel", "connect", "db", "pg", "pool", "ns", "pas"], "rs": ["cs", "ts", "ds", "usr", "fps", "rc", "rt", "rings", "rg", "ins", "Rs", "ears", "bs", "rl", "arts", "icks", "pers", "rd", "ros", "ers", "sels", "amps", "rss", "rus", "fs", "r", "irms", "ats", "RS", "s", "aps", "ras", "asts", "hs", "ems", "ls", "ubs", "vs", "vers", "times", "cases", "ares", "sts", "caps", "xs", "rys", "its", "js", "lines", "res", "mr", "ims", "arms", "otes", "vr", "ys", "ows", "ues", "rx", "sr", "abs", "ctr", "oms", "rows", "ars", "ris", "ires", "rr", "acks", "rates", "wcs", "ks", "stats", "qs", "hr", "pas"], "ps": ["ls", "cs", "pt", "pres", "gs", "pp", "ptr", "wp", "ts", "tp", "amps", "pa", "plays", "ds", "fs", "ys", "vs", "fps", "mp", "fp", "ats", "pc", "s", "aps", "params", "bps", "pins", "as", "ins", "ops", "ns", "p", "pd", "Ps", "bs", "ping", "ies", "als", "sp", "pots", "ips", "hs", "pers", "posts", "eps", "PS", "its", "ports", "js", "pse", "ress", "jp", "pps", "stats", "ons", "gres", "ws", "ups", "pl", "ms", "pg", "pr", "ims", "pb", "pas"], "dbo": ["doo", "dbbo", "DBO", "dBO", "cBO", " dBO", "Doo", "cba", "jBO", "dba", "dboo", "dbBO", "Dbo", " dba", "jbo", "jba", " doo", "cbo"], "url": ["ls", "external", "path", "dl", "full", "http", "URL", "lr", "id", "r", "norm", "abs", "l", "ur", "link", "string", "str", "browser", "gl", "https", "web", "html", "nl", "org", "loc", "n", "domain", "source", "hl", "host", "uri", "len", "rl", "xml", "href", "www", "el", "json", "ref", "ret", "impl", "log", "Url", "mail", "ssl", "server", "ul", "print", "location", "rel", "ll", "mount", "sl"], "st": ["pt", "nd", "sta", "ist", "rest", "irst", "stop", "tt", "ste", "ts", "it", "ft", "r", "mt", " et", "std", "nt", "ust", "kt", " ty", "t", " ST", "s", " ts", "rt", "str", "stable", "se", "ut", " std", "sts", " rest", "sn", "utt", " sto", "stat", "ST", "sty", "ct", " ut", " ss", "ost", "est", " St", " est", "sp", "lt", "St", "sb", "step", "fr", " pat", "stack", " superst", " sl", "ss", "stri", "bt", "sw", " str", " sp", "et", "start", "rand", " mt", "ast", "sl", " subst", "sm"], "sortDocId": [" sortDocumentID", " sortDocById", "sortFileid", "orderdocById", "ortDocID", "ortdocID", "sortLocOrig", "sortDOCMid", "orderDocName", "sortdocOrig", "sortDocumentId", "sortDocumentid", "sortFileID", "ortDocId", "orderDocID", "submitDocID", "orderDocId", "ortDocById", "ortDocEnd", "sortdocID", "sortDOCId", "sortdocId", "ortDocumentId", "sortDocMid", "ortDocumentEnd", "submitDOCId", "sortDirName", "sortWinID", "ortdocById", "sortDocEnd", "submitDOCById", "sortDirById", "submitDocMid", "ortDocumentID", " sortDocumentid", "sortFileId", "sortLocID", "sortFileMid", "submitDocById", "ortdocId", " sortDocumentById", "sortWinId", "sortdocEnd", "sortFileById", "sortDOCById", "ortdocOrig", "sortDOCID", "sortdocById", "sortLocId", "orderdocID", "submitDOCID", "sortDocumentEnd", "sortWinMid", "sortDocumentById", "submitDocId", "orderdocId", "ortDocumentById", "ortDocOrig", "orderDocById", " sortDocID", "sortdocName", "sortDocid", "sortDocName", " sortDocid", "sortDirID", "sortDocById", "sortWinById", "sortDocOrig", "sortLocById", " sortDocumentId", "submitDOCMid", "sortDocumentOrig", "sortdocid", "sortDOCEnd", "sortFileName", "sortDocumentID", "sortDocID", "sortDirId", "orderdocName"], "flag": ["lv", "dirty", "needed", "sun", "fail", "store", "id", "f", "func", "sync", "flat", "fd", "list", "cond", "debug", "count", "gd", "fl", "nl", "continue", "image", "limit", "lag", "cloud", "lead", "mask", "cmd", "util", "char", "used", "bag", "compl", "Flag", "sp", "ind", "set", "bool", "status", "ret", "conv", "ld", "bug", "log", "stage", "ground", "event", "band", "hold", "tag", "flags", "pic", "important", "FLAG"], "sqlsort": ["sqlssort", "qlesorter", "sqLSort", "qlesorted", "sqcsorter", "sqlsorting", "qlsorter", "sqLSorted", "sqlsorter", "sqllort", "sqlesort", "sqcsort", "qlssort", "sqLSorting", "sqlesorted", "qlesorting", "sqllorted", "sqllsort", "qlsort", "sqllorter", "qlsorted", "sqcsorting", "sqlesorting", "qlsorting", "sqlsorted", "sqLSsort", "sqcssort", "sqlesorter", "sqlessort", "sqLSorter", "qlessort", "qlesort"], "sortURL": ["saveURI", "ortBY", "scaleURI", "ortBL", "sortUID", "orderUrl", "orderUID", "sortUrl", "orderUR", " sortBY", "SortBL", "ortUrl", "saveUID", "sortOUT", "orderBL", "scaleBY", "SortURL", "ortUR", "scaleURL", "searchOUT", "orderURL", "searchUrl", "searchURI", "sortUR", " sortUR", "SortUrl", "sortBY", " sortURI", "sortURI", "searchURL", " sortBL", "sortBL", "ortURL", " sortOUT", "scaleUR", "saveURL", "SortUR", "saveOUT", "ortUID", "saveUrl", "orderURI", " sortUrl", "ortURI"], "sortflag": [" sortbug", "filterflags", "ortflags", "transformwarning", " sortFlag", " sortbutton", "sorturl", "transformflag", "ortflag", "filterbutton", "Sorturl", "ortbug", "sortwarning", "filterstatus", "ortfield", "SortFlag", "Sortfield", "transformstatus", "filterflag", "sortbug", "sortflags", "filterfield", "filterbug", "sortbutton", "sortfield", "ortFlag", "sortstatus", "Sortflag", "transformflags", "ortbutton", "ortwarning", " sortfield", "sortFlag", "filterwarning", " sorturl", "orturl", "ortstatus"]}}
{"id1": "16232202", "id2": "14567939", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "label": 1, "substitutes": {"doPost": [" dopost", "DoPost", " doPOST", "DoAdd", " doAdd", "handlePost", "dopost", "Dopost", "doAdd", "handlePOST", "handleAdd", "handlepost", "doPOST", "DoPOST"], "request": ["media", "current", "law", "quest", "directory", "pe", "xml", "attribute", "require", "report", "post", "get", "worker", "condition", "connection", "begin", "user", "collection", "the", "input", "register", "url", "open", "subject", "select", "context", "browser", "Request", "environment", "handle", "command", "result", "controller", "raw", "order", "local", "setup", "message", "application", "list", "session", "runtime", "ire", "record", "req", "have", "forward", "version", "initial", "work", "requ", "remote", "re", "print", "claim", "template", "http", "QUEST", "query", "address", "first", "reference", "frame", "client", "web", "document", "view", "position", "remove", "process", "server", "create", "complete", "reset", "call"], "response": ["reply", "message", "header", "http", "out", "application", "output", "shell", "description", "session", "video", "send", "network", "summary", "entry", "onse", "answer", "continue", "image", "next", "detail", "page", "environment", "exit", "object", "ve", "esi", "resp", "settings", "social", "version", "document", "site", "sequence", "view", "respond", "console", "report", "position", "e", "re", "render", "event", "connection", "server", "print", "res", "location", "security", "Response", "profile", "status", "service"], "cu": ["CU", "ucc", "aco", "U", "ctx", "us", "ou", "cgi", "uu", "tc", "mu", "chu", "ocr", "ci", "UD", "du", "gru", "su", "Cu", "zu", "uci", "ur", "au", "ut", "bo", "yu", "gu", "umi", "c", "ue", "ju", "cro", "tu", "cpu", "u", "cp", "cn", "hua", "pu", "unc", "cus", "util", "cul", "eu", "cm", "nu", "lu", "aus", "angu", "ub", "uc", "cci", "ua", "um", "cy", "ck", "co", "hu", "uo", "ru", "cum", "ui", "lc"], "ud": ["ad", "udd", "dl", "us", "UD", "uu", "und", "htt", "ci", "gb", "udo", "du", "su", "zu", "ow", "oud", "ku", "udi", "ut", "di", "ur", "gd", "gu", "hd", "uds", "tu", "u", "ord", "dd", "pd", "eus", "unc", "util", "cus", "ost", "eu", "uda", "urd", "uh", "unt", " du", "uid", "aus", "ub", "rod", "uc", "ld", "um", "bd", "od", "ck", "td", "d", "dk", "aud", "edu", "mud", "ui", "vd"], "returnTo": ["returnto", "endTo", "addTo", "urnTO", "renderTo", "returnTarget", "ReturnTO", "returnTO", "addTO", "ReturnTo", "render2", "Returnto", "endto", "Return2", "renderTO", "endTarget", "urnTarget", "endTO", "return2", "urn2", "addto", "addTarget", "urnTo", "urnto", "renderto"], "password": ["message", "user", "remember", "sword", "auth", "Password", "wd", "database", "description", "login", "paste", "ssh", "pty", "secret", "push", "padding", "email", "word", "trust", "pattern", "username", "attribute", "shadow", "command", "token", "default", "PASS", "definition", "crypt", "security", "profile", "phrase", "prefix", "hello", "pool", "reset"], "md": ["amd", "nd", "cd", "dh", "mt", " MD", "grad", "MD", "m", "and", "der", "mk", "mac", "hd", "mc", "df", "Cmd", "pd", "dd", "cmd", "det", "msg", "mod", "pdf", "mm", "ld", "bd", "od", "mn", "mb", "td", "d", "sd", " Md", "mg", "ms", "sm", "dm", "magic"], "hash": ["bytes", "check", "init", "flash", "where", "shift", "ash", "hed", "ashes", "mac", "str", "oh", "test", "html", "key", "hd", "h", "handle", "len", "char", "sh", "tr", "result", "height", "shadow", "sha", "has", "hex", "dig", "Hash", "rh", "raw", "sum", "ho", "rand", "data", "her"], "pass": [" def", "alias", "read", "auth", "pp", "ph", "conf", "fail", "prop", "wd", "pkg", "ass", "task", "session", "zip", "add", "push", "pos", "test", "cat", "priv", "mask", "def", "ask", "act", "handle", "PASS", "default", "Pass", "step", "ack", "ps", "conn", "pack", "tag", "pg", "pool", "secret", "pas"], "vis": ["inv", "feat", "iz", "pres", "is", "display", "ver", "san", "type", "info", "comm", "cap", "virt", "wa", "cond", "stat", "circ", "str", "gu", "key", "priv", "val", "label", "visible", "vert", "def", "ha", "att", "act", "VIS", "miss", "state", "Vis", "view", "hidden", "mod", "vid", "access", "see", "nav", "mit", "rav", "study", "tri", "serv", "v", "status", "vol", "var", "cfg"]}}
{"id1": "1421557", "id2": "2834524", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeStringToFile", "encodeFileToFiles", "encodeStringAsDisk", "encodeFileFromStream", "encodeFileFromDisk", "encodeStringAsFile", "encodeFileAsFiles", "encodeFiletoFile", "encodeFiletoFiles", "encodeStringToStream", "encodeFileAsFile", "encodeFileAsDisk", "encodeFileAsStream", "encodeFileFromFile", "encodeStringAsStream", "encodeStringToDisk", "encodeFiletoDisk", "encodeFiletoStream", "encodeStringToFiles", "encodeFileToStream", "encodeStringAsFiles", "encodeFileToDisk"], "infile": ["InFile", "inputfile", "outbase", "inbase", " inFile", "inFile", "outpath", "Inbase", "outFile", "Inpath", " infilename", "Infile", "outfilename", "infilename", "inpath", "inputpath", "inputfilename", "inputFile", " inpath", " inbase"], "outfile": ["inname", "newfile", " outname", "newname", "newfilename", "newFile", "inFile", "tofile", "todir", "fromfp", " outfilename", "infp", "outFile", "fromfile", "outdir", "indir", "fromdir", "tofp", "toFile", "outfp", " outFile", "outfilename", "infilename", "fromFile", "outname"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "image", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ro", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "null", "fn", "os", "en", "cn", "to", "flush", "up", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "can", "aos", "o", "res", "outer", "inner", "ot"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "queue", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "length", "black", "stack", "temp", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", "commit", "ccess", "cess", "value", "accept", "fail", "growth", "warning", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "ith", "successful", "good", "please", "ceed", "town", "result", "valid", " Success", "successfully", " okay", " failure", "ratulations", "photo", "sufficient", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "14783950", "id2": "755203", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressWithoutFiles", "compressByZip", "compresswithExt", "composeWithzip", "compressWithoutZip", "composeWithZip", "compresswithZip", "compressWithzip", "compressByFiles", "compresswithzip", "composeWithoutExt", "compressWithFiles", "composeWithFiles", "composeWithoutzip", "compressWithoutzip", "composeWithoutFiles", "compressByExt", "compresswithFiles", "composeWithExt", "compressWithoutExt", "composeWithoutZip", "compressByzip", "compressWithExt"], "fileList": ["pageLIST", "resourceNames", "ilelist", " FileCode", "fileIterator", "pagelist", "itemLock", "filelist", "wordLIST", " fileLock", "resourceList", " fileLIST", "tileSet", "pageCode", " FileLIST", " fileIterator", "fileNames", "fileL", "tileLIST", "fileLIST", " fileL", "itemNames", "wordSet", "wordList", "itemList", " FileSet", "pageSet", "fileSet", "pageList", " fileSet", "pageL", "ileLIST", " fileCode", " fileNames", "ileList", "fileCode", "fileLock", "wordIterator", "ileL", "tileList", " FileList", " filelist", "resourceLock", "tileIterator"], "zipFileName": [" zipFilePath", "zipFileNames", "zipilePath", "zFilename", "zipDirNames", "zipfilename", "zipDirFilename", " zipFileNames", "zFilenameFilename", "zipileName", "zipFilenamePath", " zipfileName", "zipFilenameFilename", "zipfileNames", "zipfileFilename", "zipFilenameName", "zipDirPath", "zipfileName", "zFilePath", " zipfilePath", "zFilenamename", "zipfilePath", " zipfileFilename", "zipFilename", "zipFilenameNames", " zipfileNames", "zFileFilename", " zipFileFilename", "zipFileFilename", "zipDirName", "zipilename", "zipFilePath", "zipFilenamename", "zFileName", "zFilenamePath", "zFilenameName", "zipileFilename"], "fos": ["flos", "foos", "flOS", "floos", " foos", "wOS", "los", "lOS", "Foss", "FOS", "foss", "lfOS", "fOS", "Foos", "wos", "lfis", "lfos", "Fos", "woos", "woss", "loss", "lfoos", " fOS", "flis", "loos"], "zos": ["han", "zar", "ess", "css", "hz", "zers", "webkit", "zan", "zo", "zh", "zzle", "za", "z", "zu", "hess", "los", "zip", "sbm", "oss", "less", "nz", "bes", "zero", "zen", "enos", "iners", "iaz", "os", "ze", "jas", "cz", "ses", "zb", "zin", "rys", "ippers", "enz", "js", "ossus", "ez", "ps", "zag", "sis", "eros", "rez", "ss", "zi", "zes", "zer", "Sax", "ws", "zon", "es", "zik"], "iter": ["user", "is", "liter", "ptr", "cer", "iver", "where", "vis", "it", "ver", "Iter", "li", "list", "ser", "reader", "here", "orient", "Iterator", "walker", "fer", "loader", "kit", "ir", "train", "loc", "former", "ator", "izer", "oper", "ait", "ter", "coll", "er", "loop", "tr", "ger", "valid", "ner", "el", "exp", "iner", "its", "iv", "gener", "re", "iterator", "i", "inner", "outer", "inter", "order", "maker", "ee", "ipper", "ip"], "fileName": ["filePath", " fileBody", "tableName", "fBody", "ileSource", "FileString", "filename", "fNumber", "fString", "FileCurrent", " filePath", "ileName", "fileCurrent", "tablePath", "ileCurrent", "Filename", "fName", "fieldList", " fileCurrent", "ileSet", "fileSource", "fileNames", "fileStore", "shortname", "fieldname", "ilename", "shortSource", "FileName", "getname", "fname", "fieldName", "fileSet", " fileSource", "FilePath", "tableSet", " fileSet", "ileBody", "shortStore", "getSource", "fileString", "getStore", "ileNAME", "localname", "localName", " fileString", " filename", "ilePath", " fileNames", "ileString", "fileBody", "ileList", "FileNames", "localList", "localNAME", "getName", "fSource", " fileStore", " fileNumber", "fileNAME", "fNames", "fileNumber", "ileNumber", "fieldNAME"], "ind": ["nd", "cd", "ptr", "stick", "draw", "sign", "bind", "find", "pred", "red", "cand", "roll", "inn", "Ind", "cond", "dj", "count", "seed", "md", "IND", "pos", "req", "n", "loc", "mind", "inc", "inder", "butt", "ent", "num", "att", "hend", "ded", "div", "mod", "typ", "cod", "dial", "ld", "med", "pl", "i", "kind", "td", "d", "wind", "j", "index"], "shortName": ["shortType", "ShortFilename", "ShortKey", "quickName", "recentCode", "ShortCode", "fullString", "fullName", " shortKey", "quickString", "shortname", "recentName", " shortString", "shortKey", "shortCode", "fullType", "smallCode", "fullname", " shortType", "quickKey", "shortFilename", "smallname", "ShortString", "quickname", "recentFilename", "ShortName", "smallName", "Shortname", " shortname", "ShortType", "recentname", "smallFilename", "shortString"], "fis": ["ufi", "fois", "hois", "wIs", " fIs", "ufIs", "cfi", "hris", "wi", "Fis", "pis", "sfis", " fris", "wis", "pois", "hi", "FIs", "ufis", "ufris", "ufois", "sfois", "fIs", "cfris", "fris", "fi", "cfois", "sfi", "wois", "sfIs", "Fris", "pi", "his", "pris", "cfis"], "buf": ["b", "block", "bytes", "uf", "mu", "cap", "fam", "pkg", "bl", "bc", "rb", "bin", "cb", "cat", "Buffer", "br", "orig", "cv", "img", "arr", "cmd", "box", "batch", "bag", "tr", "bar", "msg", "seq", "tab", "ref", "conv", "fg", "aka", "Buff", "temp", "buffer", "wb", "vec", "fb", "cur", "mem", "buff", "bus", "bed", "db", "var"], "bytesRead": ["postsLoad", "bytesWrite", "blocksWrite", "secondsLoad", "bytesReady", "flowsLoad", "postsReady", "BytesWritten", "BytesLength", "secondsRead", "flowsRead", "postsFind", "blocksLoad", " bytesLoad", "bytesNeed", "linesLength", "usersLoad", "flowsReady", "blocksWritten", "bytesLoad", "linesRead", "flowsFind", "linesWritten", "BytesNeed", "bytesFind", "blocksRead", "secondsWrite", "secondsWritten", " bytesWritten", " bytesLength", "usersFind", "postsRead", "BytesRead", " bytesNeed", "bytesWritten", "linesNeed", "usersReady", " bytesWrite", "bytesLength", "usersRead"]}}
{"id1": "21181542", "id2": "21488868", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"deleteRoleType": ["deleteResourceType", "deleteGroupTyp", "deleteResourceTyp", "deleteRoleTypes", "deleteResourceTypes", "deleteGroupType", "DeleteRoleTyp", "DeleteRoleType", "deleteRoleTyp", "deleteGroupTypes", "DeleteRoleTypes"], "id": ["path", "is", "mid", "aid", "Id", " pid", "iden", "it", "type", "url", "info", "ID", "ion", "instance", "and", "kid", "t", "add", "l", "link", "x", "key", "pid", " tid", "val", "end", "orig", "sid", "p", "oid", "created", "h", "def", "rid", "in", "bid", "part", "uid", "vid", "show", "ref", "edit", "ident", "no", "only", "i", "event", "hide", "d", "ide", "create", "hash", "name", "ids", "like", "node", "time", "index"], "namespaceId": ["namespaceOr", "typesACEId", "workshipID", "workspaceName", "typespaceAnd", "namespaceRef", "namespointId", " namesenceBirth", "namespointName", "namespaceAnd", "namespointid", "namesistenceOr", "namesaceID", "worksetAnd", "namesaceid", "namespacesId", "namespacesid", "namespaceLog", "nameshipID", "namesenceOr", "namesenceBirth", "typespaceId", "namesenceId", "nameshipKey", "namespacesBirth", "namespointRef", "namespaceKey", "workspaceID", "namesetId", "namesspaceid", "nameshipid", "worksetid", "namespaceid", "namesistenceIdent", "namesiteOr", "namesplaceRef", "namespacesID", "workspaceid", "worksplaceRef", "workspaceAnd", "namesistenceId", "namesplaceid", "worksplaceid", "namesiteIdent", "namesiteId", "namesspaceAnd", "namesenceID", "namespaceName", "namesistenceLog", " namespaceOr", " namesiteIdent", "namesaceKey", "namesspaceID", "namespacesKey", "namesositoryID", "typesACEID", " namesiteLog", "workshipid", "worksplaceId", "namesadeAnd", "worksetID", "workspaceId", "workshipKey", "namesositoryBirth", "nameshipId", "namespaceBirth", "namesACEID", "worksplaceName", "namespacesRef", "namespaceID", "namesplaceId", "namespointID", "workspaceRef", " namespaceID", "namesACEId", "workshipId", "namespaceIdent", "namespacesAnd", "namespacesName", "namespointAnd", "namesaceId", " namespaceBirth", "namesetid", "worksetId", " namesenceID", " namesiteId", "namesiteLog", "workspaceKey", "typespaceID", "namesetAnd", "namesetID", " namespaceLog", "namesenceLog", "namesplaceName", "namesadeID", " namespaceIdent", " namesenceId", " namesiteOr", "namesspaceId", "namesadeId", "namesACEAnd", "typesACEAnd", "namesenceIdent", "namesositoryId"], "removeReferencesInRoleTypes": ["removeReferencesInRuleTypes", "removeReferencesInRightNames", "removeReferencesFromMultipleTypes", "removeReferencesInMultipleType", "removeReferencesFromRoleFiles", "removeReferencesInRoleFiles", "removeReferencesInRightType", "removeReferencesFromMultipleType", "removeReferencesInRoleType", "removeReferencesFromMultipleFiles", "removeReferencesInRightTypes", "removeReferencesInroleFiles", "removeReferencesFromRoleType", "removeReferencesInroleType", "removeReferencesInRightFiles", "removeReferencesFromroleFiles", "removeReferencesInMultipleTypes", "removeReferencesFromRoleTypes", "removeReferencesInroleNames", "removeReferencesInRuleNames", "removeReferencesFromMultipleNames", "removeReferencesFromRoleNames", "removeReferencesInRoleNames", "removeReferencesFromroleType", "removeReferencesFromroleNames", "removeReferencesInRuleType", "removeReferencesFromroleTypes", "removeReferencesInroleTypes", "removeReferencesInRuleFiles", "removeReferencesInMultipleFiles", "removeReferencesInMultipleNames"], "permit": ["PERmitted", "Permitted", "Permiss", "permitted", "promitted", "permission", "PERmit", "proMIT", "promit", "PERMIT", " permitted", "Permission", " perMIT", "PerMIT", " permiss", "PERmiss", "PERmission", "Permit", "perMIT", "promission", "permiss"], "exist": ["alias", "remember", "there", "existence", "register", "find", "write", "save", "filename", "present", "login", "list", "know", "current", "mark", "use", "ist", "add", "same", "purpose", "include", "existent", "ext", "missing", "have", "icate", "existing", "attach", "require", "define", "respond", "see", "establish", "meet", "keep", " extant", "cont", "create", "connect", "status", "ready"], "msgBuf": ["msgBlim", "messageRbuff", " msgRuf", " msgRbuff", "messageMuff", "msgBeuf", "msgBfg", "msgPuff", "msgBsuf", "msgPbuf", "msgBsbuf", " msgMbuf", "messageRuf", "msgGlim", "msgRuff", "messageMbuf", "msgAuff", "msgBsuff", " msgMuf", "msgCfg", " msgMuff", "messagePbuf", " msgBbuf", "msgRbuff", "msgRbuf", "msgRlf", " msgBuff", "msgBebuf", "msgMuf", "msgMbuff", "msgCuf", "messageBbuf", "messageBlf", " msgCfg", "msgBuff", " msgBbuff", "msgVbuf", " msgCuf", "messageRlf", "msgRuf", "msgAbuf", "msgBsfg", "msgPuf", "msgAuf", "messageBuff", "messageRuff", "messagePuf", " msgRlim", " msgCuff", "msgVbuff", "msgGbuff", "msgCbuff", "msgBbuff", "msgPlf", " msgRbuf", "messageBuf", "msgMuff", "msgMbuf", "msgPfg", "msgGuf", " msgMbuff", "msgBefg", "messageBfg", "messageRbuf", "messagePuff", " msgBlim", "msgRlim", "messagePfg", "msgGbuf", "messageMbuff", "msgBbuf", "msgCuff", "msgBlf", "msgVuff", " msgCbuf", "msgCbuf", "messageBbuff", "msgAbuff", "messageMuf", "msgRfg", " msgBfg", "msgPbuff", "msgVuf", "msgBeuff"], "objects": ["models", "headers", "faces", "files", "points", "links", "authors", "docs", "books", "keys", "builders", "oids", "packages", "products", "versions", "articles", "parts", "apps", "jobs", "projects", "resources", "plugins", "flows", "bits", "tools", "locks", "beans", "classes", "frames", "organisms", "airs", "images", "ports", "uploads", "codes", "units", "relations", "lines", "ors", "errors", "assets", "items", "artifacts", "workers", "ids", "obs", "values", "pages", "blocks"], "sqlRightId": ["sqlrightName", "sqlrightId", " sqlrightId", "qlRightid", "qlRightId", "sqlRightid", "sqlLeftId", "sqlRightName", "qlrightid", "sqlHeadid", "qlrightId", " sqlrightRef", " sqlrightById", " sqlrightid", "sqlRightRef", "sqlLeftName", "qlrightName", "sqlHeadById", "sqlrightid", "sqlrightById", "sqlLeftid", " sqlRightid", "sqlHeadRef", "sqlHeadId", " sqlRightById", "qlRightName", "sqlrightRef", "sqlRightById", " sqlRightRef"], "sqlParent": ["invparent", "sprChild", "sysParent", "sysChild", "sqlChild", "sqlparent", "sysparent", "sysOwner", "invChild", "sqlOwner", "sprparent", "invParent", "sprParent", "invOwner", "sprOwner"], "sql": ["dl", "template", "description", "session", "ql", "md", "params", "term", "acl", "action", "cmd", "password", "sys", "SQL", "command", "spec", "json", "body", "statement", "drop", "orm", "security", "execute", "data", "comment", "db", "diff", "cfg"], "pstmt": ["wpastmk", "pctms", "pstmk", "pstartng", "pstatmm", "pstMT", "NEW", "pthmt", " pstms", "NULL", "Pstmt", "pstatStatement", "pstatem", "PstStatement", "pastmk", "pondm", "wpastm", "pthem", " pstatmt", "pstartm", "pthmp", "pndmk", "pndmt", "pstartr", "pstms", "pastm", "Exception", "wpstMT", "pStng", "pStm", "context", " pstem", "nt", "pstr", "PStm", "Pstmm", "pastMT", "pstmp", "pstatm", "postmk", "pndm", "insert", "postmt", "pStr", "pstem", "pctem", "wpstm", "Pstm", "pndMT", "pondStatement", "Pstr", "Pstatm", "PstatStatement", "PStng", "pctmt", "def", "Pstatmm", "pstm", " pstatms", "pastStatement", "pondmm", "wpastmt", "Delete", "pstng", "pstStatement", "wpstmt", "wpstmk", "pondmt", "_", "pastmm", " pstatem", "postm", "postMT", " pstmp", "Pstng", "tx", "pastmt", "pstatmp", "pStmt", "pstartmt", "pstmm", "pstatms", "pstatmt", "PStr", "pthms", "create", "pctmp", "Pstatmt", " pstatmp", "wpastMT", "PStmt"], "typeGid": ["typeRegID", "typeGuids", " typeCid", "TypeCid", " typeCids", "typeGenids", "typeRegid", "typeRegId", "typeGId", " typeGno", "TypeGID", "typeCID", "typeCno", "typeGno", "TypeCId", "typeGuID", "TypeCID", "typeGuid", " typeGids", " typeCno", "typeCId", "typeGids", "typeCids", "typeGuId", "typeGuno", "typeGenno", "typeGenid", "typeGID", "typeCid", "TypeGId", "TypeGid"], "defaultLevel": [" defaultDepth", "errorLevel", "DefaultLevel", "DefaultDepth", "errorDepth", "errorMode", "defaultDepth", " defaultlevel", "Defaultlevel", "defaultMode", " defaultMode", "DefaultMode", "errorlevel", "defaultlevel"], "success": [" succeed", "accept", "fail", "pass", "progress", "save", "warn", "info", "Success", "ok", "error", "first", "unknown", "rc", "summary", "submit", "continue", "primary", "close", "successful", "good", "result", "state", "successfully", "failed", "undo", "status"]}}
{"id1": "18891988", "id2": "7908169", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"getFile": ["GetFilename", "selectFile", "GetFile", "getString", "selectString", "selectFilename", "createFile", "createString", "createfile", "GetString", "selectfile", "createFilename", "getFilename", "Getfile", "getfile"], "serviceName": ["ServiceCode", "libraryFamily", "serviceFamily", " serviceCode", " serviceType", "serviceCode", "serverName", "ServiceName", "serviceType", " serviceNames", "ServiceNames", "libraryNames", "serverType", "serverCode", "ServiceFamily", " serviceFamily", "libraryType", "ServiceType", "libraryName", "serviceNames"], "wsdlLocation": ["wsdlLoc", "awsdlLocation", "wdlLoc", "wdlFolder", "wlLoc", "wsDLLocation", "wssdLoc", "wslLocation", "wsolURL", "awsdlocation", "wsdlFolder", "awsdLoc", "wsDLPath", "awsdlURL", "wssdFolder", "wsolLocation", "wslLoc", "awsdlLoc", "wsDLlocation", "wsdURL", "wdlLocation", "wsDLLoc", "wsollocation", "wssdPath", "wlFolder", "wsolLoc", "wdlPath", "awsolLocation", "wsdllocation", "awsdllocation", "awsolLoc", "awsdLocation", "wsDLURL", "wsdLoc", "wssdLocation", "wsdlURL", "awsolURL", "awsdURL", "wsdlPath", "wssdURL", "wslPath", "awsollocation", "wlLocation", "wsDLFolder", "wssdlocation", "wsdLocation", "wsdlocation", "wslFolder", "wlPath"], "endpoint": ["idpoints", "endline", "idline", "startline", " endline", "beginpoint", "beginword", "bindPoint", "idPoint", "bindpoint", "Endword", "beginPoint", "endport", "endword", "bindpoints", "Endport", "endpoints", "EndPoint", "Endpoint", "idpoint", "beginpoints", " endPoint", "bindport", " endpoints", "startword", "startpoint", " endport", "Endpoints", "startpoints", "startPoint", "endPoint"], "fileLocation": ["FileLoc", "FileLocation", " filelocation", "documentPosition", "filePosition", "Filelocation", "FilePosition", "documentLocation", "fileLoc", "filelocation", " fileLoc", " filePosition", "documentLoc", "documentlocation"], "tempDir": ["tempFolder", "Tempdir", "tmpUrl", " tempPath", "TempDirectory", "tmpFolder", "TempDir", " tempdir", "tmpDir", " tempFolder", "tmpDirectory", "TempPath", "tmpPath", "TempUrl", "tempUrl", "TempFolder", "tempPath", "tempdir", "tmpdir", " tempUrl", " tempDirectory", "tempDirectory"], "url": ["ls", "dl", "cert", "http", "URL", "open", "f", "r", "li", "m", "l", "ur", "link", "gl", "https", "browser", "str", "job", "sur", "web", "nl", "window", "loc", "mount", "cp", "uri", "up", "github", "char", "il", "cr", "socket", "ret", "mail", "Url", "re", "ctrl", "conn", "build", "ssl", "ul", "location", "base", "bel", "rel", "ll", "pl", "service", "sl", "un"], "WSDLFile": ["WSDLLFile", "WSDDLfile", "WSDLSType", "WSDMLfile", "WHDLfile", "WHDLFile", "WNDLfile", "WSDMLFILE", "WHDLFILE", "WNDDLfile", "WNDLFILE", "WSDELfile", "WSDLLfile", "WNDDLFILE", "WNDLFilename", "WSDQLfile", "WSDQLFILE", "WSDLLFILE", "WIDDLFile", "WSDLLFilename", "WSDDLFILE", "WSDDLString", "WIDDLfile", "WHDDLfile", "WSDLLType", "WIDLfile", "WHDDLFILE", "WIDLType", "WSDLfile", "WSDLSString", "WSDLType", "WSDLLString", "WSDDLFilename", "WSDDLType", "WSDELFILE", "WSDELFilename", "WIDDLString", "WIDLString", "WSDDLFile", "WNDDLFile", "WNDDLFilename", "WSDELFile", "WNDLFile", "WSDLSfile", "WSDLFILE", "WSDLString", "WIDDLType", "WIDLFile", "WSDMLFile", "WSDQLFile", "WHDDLFile", "WSDLFilename", "WSDLSFile"], "tmpWSDLFile": ["tmpWSDlFiles", "tmpWNDLFile", "tmpWSDLFILE", "tmpWNDLFilename", "tmpWSDDLFile", "tmpWSDLDfile", "tmpWSDLLFiles", "tmpWSDLLFile", "tmpWIDDLFilename", "tmpWIDDLfile", "tmpWSDDLFilename", "tmpWIDDLFile", "tmpWSDLFiles", "tmpWSDLDFile", "tmpWSDLDFILE", "tmpWNDDLfile", "tmpWSDlFilename", "tmpWSDDLfile", "tmpWNDLfile", "tmpWNDDLFile", "tmpWNDDLFiles", "tmpWSDLFilename", "tmpWSDLLFILE", "tmpWNDLFiles", "tmpWSDLLfile", "tmpWSDDLFiles", "tmpWNDDLFilename", "tmpWIDDLFILE", "tmpWIDLFilename", "tmpWIDLFILE", "tmpWSDLLFilename", "tmpWSDLfile", "tmpWSDlFile", "tmpWSDDLFILE", "tmpWSDlfile", "tmpWIDLfile", "tmpWSDLDFilename", "tmpWIDLFile"], "inputFile": ["inputFiles", " inputDo", "clientFILE", "inputfile", " inputFiles", "Inputfile", "InputFILE", "indexfile", "errorFile", "indexStream", "outputfile", "interfacefile", "errorfile", "tmpFILE", "inPath", "inputPlace", "tmpfile", "inputStream", "inFile", "indexFILE", "errorFILE", "indexFile", "infile", "clientPath", "interfacePlace", "tmpStream", "intfile", "InputPath", "tmpSourceFile", "inputSourceFile", "interfaceSourceFile", "interfaceFile", "InputStream", "InputFiles", "tmpPlace", "outputStream", "inDo", "outputFile", "intFiles", "inputFILE", "InputDo", " inputSourceFile", "intFile", " inputFILE", "intFILE", "inputDo", " inputPath", "InputFile", "clientFile", " inputfile", "inputPath", " inputPlace", "errorStream", "clientFiles", "outputFILE"], "tmpFile": ["inputFilename", "inputfile", "tempfile", " tmpfile", "tmpFiles", "tmpFILE", "empFilename", "empfile", "tmpfile", "mpFiles", "tempFilename", " tmpPath", "tempFile", "tmpPath", " tmpFiles", "tmpFilename", "tempPath", "inputFILE", "mpPath", "empFile", "empFILE", "mpfile", "mpFile", "tempFiles", "tempFILE"], "in": ["In", "inv", "is", "sin", "init", "input", "rin", "it", "id", "r", "ln", "file", "IN", "ain", "inn", "t", "inf", "bin", "ai", "client", "ri", "c", "ar", "ins", "n", "source", "from", "stream", "inc", "en", "mi", "ic", "io", "ind", "ch", "din", "isin", "cin", "conn", "cont", "inner", "o", "ini"], "out": ["inv", "obj", "ex", "group", "at", "net", "OUT", "ou", "cache", "conf", "all", "on", "write", "output", "tmp", "file", "t", "oss", "lock", "client", "c", "Out", "n", "this", "null", "os", "en", "to", "ao", "io", "ne", "cm", "outs", "sys", "w", "ch", "writer", "conv", "OU", "by", "log", "conn", "buffer", "connection", "co", "can", "aos", "o", "outer", "auto", "pool", "we"], "con": ["com", "Conn", "acon", "conf", "tc", "win", "func", "ln", "ain", "Con", "sec", "fc", "login", "cos", "c", "fn", "mc", "cp", "exc", "cn", "num", "cone", "cm", "nc", "soc", "const", "cal", "ch", "CON", "conv", "re", "cin", "conn", "connection", "co", "ran", "cons", "cf", "cur", "can", "ws", "connect", "un"], "fileLength": ["fileFontSize", "FILEDuration", " fileDuration", "ileLen", "channelSize", " fileSize", "channelFontSize", " fileLen", "ileSize", "FILESize", "fileSize", " fileFontSize", "objectSize", "objectLength", "FILELen", "ileLength", "channelDuration", "ileDuration", "fileDuration", "fileLen", "objectFontSize", "objectDuration", "FILELength", "channelLength"], "channelIn": ["chanIN", " channeledIn", "clientOut", "ChannelIN", "clientSet", "consoleedIn", "chanSet", "chanOut", "ChanneledIn", "clientIn", "consoleIN", "clientin", "ChannelIn", "channelin", "channelIN", "Channelin", "channeledIn", "clientIN", " channelin", "consoleOut", "consoleIn", " channelIN", "ChannelOut", "ChannelSet", "chanIn", "channelSet"], "channelOut": ["courseIn", "chanConn", " channelout", " channelConn", "ChannelConn", "channelOUT", "chanOut", "chanout", "consoleout", " channelOUT", "ChannelIn", "consoleOUT", "channelConn", "courseOUT", "consoleOut", "consoleIn", "channelout", "ChannelOut", "Channelout", "ChannelOUT", "courseOut", "chanIn", "courseout"], "tmpDocument": ["cpDoc", "npMedia", "tempDocument", "tmDocument", " tmpDoc", "tmpDocuments", "npDocument", "tmpdocument", "mkDocument", "tmpDoc", "mpDoc", "tpMedia", "mpdocument", "tpDocument", "tpFile", "cpDocument", "npDocuments", " tmpMedia", "cpdocument", "tmpMedia", "tmdocument", "tempDoc", "tmDoc", "tempdocument", "npFile", "mpDocument", " tmpDocuments", "mkDoc", "tpDocuments", " tmpdocument", "mkdocument"], "nl1": ["nel1", "NL1", "nl3", "ln1", "rn6", "nr01", "pel01", "ln2", "nel3", "nlOne", "ln6", "nr1", "NL0", "rn3", "sol1", "NL2", "ln01", "ln3", "lnOne", "rnOne", "NL9", "sol9", "ln0", "nl6", "nrOne", "nelOne", "nl01", "rn1", "sol0", "pel1", "nl9", "nl0", "nel6", "pelOne", "ln9", "nl2", "sol2"], "i": ["ami", "ij", "is", "ims", "init", "us", "gi", "it", "qi", "xi", "mu", "id", "\u0438", "ci", "li", "ms", "info", "I", "m", "k", "ai", "ix", "hi", "ri", "x", "bi", "key", "n", "ii", "a", "u", "multi", "mi", "ic", "index", "io", "y", "sim", "ie", "ori", "ji", "me", "si", "v", "span", "pi", "o", "ti", "cli", "j", "ui", "di", "ini", "ip"], "node1": ["ode0", "n1", "NodeOne", "node001", " node2", " node001", "componentOne", "layerOne", "component2", "nOne", "component0", " node91", "ode2", "n0", "ode001", "nodeOne", "Node001", "layer91", " nodeOne", "ode1", "layer1", " node0", "n91", "Node0", "node0", "layer0", "component1", "node2", "node91", "Node2", "Node1"], "tmpOut": ["tmpObj", "tempIn", "mpout", "tempout", "npIn", "TempIn", "TempObj", "TempOut", " tmpObj", "tmpIn", "tempIs", "tmpOUT", "npout", "cmpout", "empOut", "tempOUT", "mpIn", "tempOut", " tmpIn", "tmpout", "npObj", " tmpOUT", "cmpOut", "empout", " tmpout", "tempObj", "mpOut", "TempOUT", "npOut", "empIs", "tmpIs", "mpObj", " tmpIs", "cmpIn"], "retVal": ["retval", " retTrue", "returnValue", "retTrue", " retval", "RetValue", "Retval", "RetTrue", " retValue", "retValue", "returnVal", "returnTrue", "returnval", "RetVal"]}}
{"id1": "17580775", "id2": "293167", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"runInternal": ["mainInternal", "mainImpl", "processIntern", "loadInternal", "processinternal", "runinternal", "runImpl", "mainIntern", "maininternal", "processImpl", "loadinternal", "loadIntern", "loadImpl", "runIntern", "processInternal"], "connection": ["creator", "device", "current", "directory", "connected", "established", "method", "socket", "writer", "engine", "con", "condition", "resource", "connect", "relation", "operation", "collection", "open", "subject", "context", "translation", "ion", "description", "c", "close", "default", "command", "statement", "controller", "pointer", "machine", "pool", "table", "setup", "message", "generation", "Connection", "function", "application", "information", "database", "session", "encrypted", "link", "network", "bo", "entry", "character", "page", "version", "initial", "console", "creation", "channel", "government", "number", "component", "associated", "address", "reference", "client", "created", "computer", "to", "general", "document", "position", "no", "event", "server", "communication", "create", "language", "reset"], "visited": ["shownitted", "VISited", "Visitted", "visITED", "visitted", "vITED", "Visited", "Visitialized", "comed", "showniting", "VISitialized", "visiting", "vited", "vitted", "viting", "comited", "comitialized", "shownITED", "comitted", "Vised", "visitialized", "VISitted", "shownited", "VisITED", "Visiting", "VISed", "vised"], "startTimeStamp": ["startTimeMillAMP", "startTimStAMP", "startTimStamps", "startTimStamp", "startTimstAMP", "startTimeMillamp", "startTimeMillamps", "startTimeStramp", "startTimstamps", "startTimeStris", "startTimeStis", "startTimestamp", "startTimstamp", "startTimeStamps", "startTimStis", "startTimstis", "startTimestAMP", "startTimeMillis", "startTimestamps", "startTimestis", "startTimeStrAMP", "startTimeStramps", "startTimeStAMP"], "delayedProgress": ["deliverprogress", "dayedProgress", "deliverContent", "dayedprogress", "dayContent", "deliverProgress", "delayingProgress", "delayprogress", "delayedContent", "dayProgress", "delayingprogress", "delayedprogress", "dayedContent", "dayprogress", "delayingContent", "delayContent", "delayProgress"], "conn": ["obj", "ht", "dl", "Conn", "ctx", "Connection", "cert", "conf", "alloc", "open", "comm", "err", "nt", "col", "bc", "l", "exec", "cell", "client", "cb", "cc", "org", "c", "loc", "n", "txt", "mc", "cp", "adj", "cn", "hw", "cmd", "resp", "addr", "act", "ct", "cmp", "nc", "ch", "conv", "enc", "js", "con", "jp", "cont", "nw", "res", "cur", "connect", "j", "att", "pg", "cfg"], "fileName": [" fileType", "filePath", " fileValue", "displayPath", "resourcename", "resourcePath", "filename", " filePath", "fileType", "displayValue", "Filename", "displayname", "FileName", "displayName", "fileValue", "FilePath", "FileValue", "FileType", " filename", "resourceType", "resourceName"], "disp": ["defr", "dispi", "nlP", "DISpol", "dispol", "lypi", "DISp", "nlpo", "desr", " disn", "serp", "wordpat", "dispo", "laycp", "Dispat", "DISpend", "Dispo", "laypol", "nlpat", "sern", "desp", "discp", "disn", "serpi", "defP", "wordpo", "DisP", "defpi", " dispi", "lyn", "dispend", "discpend", "discpol", "wordP", "nlp", "Disp", "serpa", "disP", "lypa", "dispat", "Dispi", "desP", "disccp", "wordp", " dispa", "layp", "despi", "defp", "dispa", "disr", "Disr", "lyp", "DIScp", "laypend"], "p": ["change", "pat", "pp", "ph", "perm", "wp", "tp", "vp", "pa", "dp", "r", "f", "bp", "pkg", "m", "php", "pc", "t", "pre", "pos", "padding", "c", "pid", "n", "primary", "pro", "cp", "h", "ping", "op", "part", "sp", "par", "pers", "conv", "ps", "i", "jp", "pad", "d", "v", "pi", "P", "np", "pointer", "lp", "point", "j", "pg"], "response": ["reply", "message", "bytes", "block", "more", "value", "function", "number", "time", "type", "application", "relative", "amount", "error", "description", "relation", "request", "frame", "network", "pos", "success", "entry", "onse", "zero", "continue", "image", "next", "page", "environment", "exit", "roads", "resp", "tree", "version", "ne", "result", "json", "sequence", "length", "position", "none", "escription", "no", "remote", "duration", "total", "server", "yes", "code", "res", "example", "Response", "timeout", "status", "index", "reset", "respons"], "contentType": [" contentTy", "contentTy", " contentTypes", "commandLength", "ContentTypes", "cellLen", "ContentTy", "contentTYPE", "commandTy", "ContentType", "documentLen", "messageType", "messageTYPE", " contentLength", "commandType", "messageLen", "commandTypes", "cellType", "documentLength", "messageLength", "contentTypes", "documentTYPE", "documentType", "cellLength", "contentLength", "ContentLength", "cellTYPE"], "contentEncoding": [" contentEnryption", "contentEncryption", " contentEnoder", "contentDecoding", "contentencoring", " contentEncLength", "contentEnoded", "contentEnryption", "contentEvoded", "contentEnoring", "contentEvoder", " contentEnoring", "contentEnoder", " contentEncryption", "contentDecoring", "contentEncoded", " contentEncoder", "contentDecoder", "contentencoder", " contentEncoring", "contentEvLength", " contentEnLength", " contentEnoding", "contentDecryption", "contentEncoring", "contentEvoding", " contentEnoded", "contentEnLength", "contentEncLength", "contentDecLength", "contentDecoded", " contentEncoded", "contentencryption", "contentEncoder", "contentEnoding", "contentencoding"], "contentLen": [" contentSize", "ontentSize", "ContentNet", "componentlen", " contentlen", "componentColl", "messageColl", "messageSize", "contentColl", " contentLength", "messageLen", "contentlen", "ContentLen", "ontentNet", "ontentLength", "contentSize", "ontentLen", "messagelen", "ContentSize", "contentLength", "contentNet", "componentLen", "componentSize", "ContentLength", " contentColl", " contentNet"], "is": ["iz", "http", "id", "isd", "ize", "IS", "ist", "isc", "network", "ists", "does", "ii", "iss", "are", "Is", "version", "im", "its", "ie", "ice", "i", "ih", "ss", "ism", "pi", "es", "ims", "ip"], "url": ["ls", "path", "dl", "http", "URL", "id", "git", "address", "l", "ur", "link", "string", "https", "str", "browser", "client", "web", "html", "org", "domain", "page", "host", "uri", "pattern", "char", "xml", "version", "site", "ref", "build", "Url", "ssl", "server", "location", "base", "bel", "name", "ll", "mount", "channel", "www"], "loadNext": ["loadednext", "loadedFirst", "loadMore", " loadednext", "loadnext", " loadedMore", " loadnext", " loadMore", "loadFirst", " loadFirst", " loadedNext", "loadedNext", " loadedFirst", "loadedMore"], "itemsLoadedPartially": ["itemsLoadsPartially", "itemsLoadedPosully", "itemsLoadsPartfully", "itemsLoadedpartfully", "itemsLoadsPartully", "itemsLoadedPartfully", "itemsLoadedPartully", "itemsLoadedpartial", "itemsLoadedPosfully", "itemsLoadsPosial", "itemsLoadedOnlyial", "itemsLoadsPartial", "itemsLoadsPosially", "itemsLoadedOnlyially", "itemsLoadsPosully", "itemsLoadedPosially", "itemsLoadsPosfully", "itemsLoadedpartully", "itemsLoadedOnlyully", "itemsLoadedPosial", "itemsLoadedOnlyfully", "itemsLoadedPartial", "itemsLoadedpartially"]}}
{"id1": "2521141", "id2": "2668853", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copy": ["opy", "write", "save", "download", "clip", "select", "sync", "cut", "file", "paste", "ate", "zip", "link", "load", "crop", "clone", "source", "move", "cop", "close", "cp", "share", "archive", "io", "Copy", "set", "slice", "edit", "delete", "drop", "upload", "get", "insert", "remove", "export", "transfer", "create", "replace"], "from_name": [" from_filename", " from_case", "from_resource", " from_names", "fromamename", "from_filename", "from_names", "fromameName", "fromkcase", "fromkName", " from_resource", " from_Name", "fromkpart", " from_no", "from_info", "fromkname", "from_no", " from_info", "from_Name", "fromamefilename", "fromamekey", "from_key", " from_key", "from_case", " from_part", "from_part"], "to_name": ["tolynm", "eto_word", " to_number", "to7name", "eto_name", "to7new", "to7file", "to_word", "toNamename", "from_get", "tolyfile", "to_new", "tolyname", "tolynumber", "to_number", "to_get", "toNameget", "toNamefile", "eto_Name", "to_Name", "to_nm", "toNamenew", " to_nm", "from_new", "to7get"], "from_file": ["or_File", "or_name", "from_File", " from_type", "from_resource", " from_do", " from_File", "or_file", "from_dir", "fromlyFile", "from_do", "fromlynode", "fromsfile", "to_dir", "or_run", "from_type", "fromlyresource", " from_resource", " from_port", "from_port", " from_time", "fromsdir", " from_node", "fromlyfile", "from_time", "from_node", "from_run", "fromsname"], "to_file": ["to_drop", "to_local", "to_FILE", "TO_element", " to_create", "to_File", "toJblock", "to_block", " to_local", "toJFile", "to_run", "TO_port", "to_files", " to_base", "toJfile", "from_dir", "that_file", "to_element", "toJdrop", "TO_file", "to_dir", " to_File", "from_type", "to_create", " to_dir", "to_port", "that_File", "to_tree", "that_tree", "to_type", "TO_FILE", "TO_name", "that_link", " to_run", "to_link", "to_base", "TO_files", " to_block", " to_drop"], "parent": ["pixel", "user", "path", "block", "my", "where", "prop", "id", "pa", "tar", "home", "relative", "file", "ma", "per", "parents", "instance", "params", "directory", "client", "top", "root", "test", "peer", "mother", "pid", "rule", "family", "source", "null", "page", "p", "percent", "Parent", "unit", "global", "up", "def", "tree", "master", "cmp", "owner", "part", "default", "sp", "folder", "paren", "desc", "par", "spec", "position", "form", "port", "temp", "remote", "shape", "chain", "event", "server", "man", "base", "holder", "timeout", "name", "prefix", "comment", "point", "pool", "ip", "child"], "dir": ["path", "iter", "dep", "cd", "dr", "init", "DIR", "wd", "vol", "del", "red", "file", "fd", "cond", "md", "str", "directory", "self", "Dir", "ir", "loc", "dd", "def", "good", "coll", "addr", "cmd", "det", "dict", "rec", "part", "tr", "sp", "div", "ind", "folder", "mod", "dim", "dist", "cont", "module", "d", "cur", "rel", "db", "di", "local"], "from": ["user", "From", "check", "empty", "com", "or", "init", "on", "store", "out", "query", "with", "func", "false", "error", "file", "and", "left", "se", "back", "link", "before", "pos", "client", "entry", "window", "term", "fun", "stream", "source", "orig", "ent", "en", "in", "io", "bound", "old", "st", "set", "style", "form", "ie", "by", "no", "re", "con", "so", "inner", "local", "ra", "start", "base", "vol", "fr", "reset", "normal"], "to": ["b", "or", "tt", "ts", "out", "on", "output", "that", "nt", "two", "toc", "ma", "t", "stable", "pretty", "client", "To", "top", "tto", "too", "ta", "eto", "null", "go", "will", "TO", "please", "op", "ne", "sys", "token", "target", "te", "po", "by", "no", "e", "must", "ato", "so", "total", "co", "into", "can", "o", "pi", "auto", "base", "tty", "table"], "buffer": ["message", "block", "iter", "template", "function", "cache", "binary", "database", "paste", "stroke", "frame", "append", "queue", "entry", "character", "memory", "window", "word", "Buffer", "row", "page", "batch", "char", "password", "document", "attribute", "command", "bar", "sequence", "stack", "temp", "buf", "event", "available", "base", "sample", "buff", "phrase", "button", "table", "variable"], "bytes_read": ["bytes_range", "bytes_report", "Bytes_read", "bytesynclen", "bytes2read", "words_len", "bytes_len", " bytes2read", "bytes__read", "bytes_run", "bytes__Read", "bytes_write", "Bytes_run", " bytes_write", "bytesyncread", "bytesyncreport", "bytes2Read", " bytes_Read", "bytes__range", "bytes2range", "words_read", "words_report", "bytes_Read", "wordsynclen", "bytes__write", "Bytes_write", " bytes2range", "wordsyncreport", " bytes2write", "bytesyncwrite", "wordsyncread", "words_write", "wordsyncwrite", "bytes2write", " bytes_range", " bytes2Read"]}}
{"id1": "5760649", "id2": "11968328", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"createFile": ["saveFiles", "saveStream", "uploadFile", "createStream", "savefile", "uploadFiles", " createStream", "createfile", "saveFile", " createfile", "uploadStream", " createFiles", "uploadfile", "createFiles"], "src": ["dest", "obj", "SOURCE", "rect", "is", "input", "url", "sc", "ser", "fp", "config", "rx", "sec", "sr", "abs", "fc", "rc", "str", "ctr", "sq", "inst", "stream", "loc", "rs", "source", "from", "txt", "uri", "pour", "comp", "sys", "ipl", "st", "sb", "resource", "res", "start", "cur", "SourceFile", "sit"], "filename": ["ren", "path", "title", "subject", "ename", "output", "FN", "file", "fp", "ln", "bf", "Filename", "string", "nl", "nm", "fn", "family", "txt", "n", "png", "xxx", "jpg", "nil", "username", "fil", "kl", "FILE", "v", "stem", "location", "name", "prefix", "SourceFile", "println"], "fis": [" fIS", "sfiss", "afiss", "sfios", "afis", "Fios", "bfiss", "fios", " fisi", "Fis", "ffis", "sfis", " fios", "afios", "fiss", "ffIS", "Fisi", "ffisi", "fais", " fais", "fIS", "ffos", " fiss", "bfis", "afais", "bfios", "FIS", "fisi", "sfais", "Fos", "bfos", "Fiss"], "fos": ["flos", " foses", " foes", "fios", "wOS", "Fis", "boes", "wios", "bis", "tis", "boss", "toss", "wis", "Foes", "foses", "tios", "wor", "foss", "Foss", "bos", "fOS", "floss", "vOS", " foss", "wos", "vor", "voses", "tos", "foes", "woss", "vos", "woses", " fOS", "flis", "flios", "Fos"]}}
{"id1": "13595251", "id2": "8182932", "code1": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"descargarArchivo": [" descargarRiv", " descargarMotivo", " descargarActico", " descargarMotive", " descargoArchiv", " descargoMotivo", " descargarActiv", " descargoArchive", " descargoArchico", " descargarActivo", " descargoArchivo", " descargarMotico", " descargarRivo", " descargarActive", " descargarMotiv", " descargarArchiv", " descargarRive", " descargoMotiv", " descargarArchive", " descargarArchico", " descargoMotico", " descargarRico", " descargoMotive"], "fis": ["ffix", "dfis", "fios", "ffios", "Fis", "ffis", " fris", "ffiss", " fios", "fiix", "fiiss", "ufis", "ufris", "fiis", "fiss", "ufiss", "dfiss", "dfris", "fris", "ffos", "Fiss", "fix", " fiss", " fix", "Fris", "fiios", "ufos", "ffris", "Fos", "dfos"], "fos": ["flos", "lfoses", "waos", " foes", "fedOS", "fedos", "infOs", "fbos", "lfbos", "flbos", "foses", "foss", " fows", "infbos", " fOs", "fedbos", "fOS", " fbos", "infOS", " foss", "wos", "infos", "lfos", "woes", "lfaos", "foes", "wows", "woss", "vos", "vows", "faos", "fedOs", "woses", "voss", "voes", " fOS", "floses", "fows", "flaos", "wbos", "fOs"], "inChannel": ["outchannel", "inputGray", "innRow", "initChan", " inchannel", "innerchannel", "inRow", "inConnection", "innerButton", "inputChannel", " inChan", "InConnection", "InGray", "aiRow", "innChan", "aiChan", " inButton", "initGray", "Inchannel", "initConnection", "aiChannel", "inButton", "innerChan", "InButton", "innChannel", "inputChan", "innchannel", "inputConnection", "aichannel", "inchannel", "inChan", "InChan", "outRow", "inGray", "initChannel", "outChan", "InChannel", "innerChannel"], "outChannel": [" outButton", "outchannel", " outChan", "outStream", "inConsole", "inStream", "OUTButton", " outchannel", "OUTChan", "OUTConsole", "inButton", " outStream", "OUTchannel", "OUTChannel", "inchannel", "inChan", "outButton", "outChan", "outConsole", " outConsole", "OUTStream"]}}
{"id1": "23118425", "id2": "21827619", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"encrypt": ["decrypt", "encrypted", "encipher", "decipher", "Encrypt", "Encryption", "encryption", "enipher", "enryption", "Encrypted", "decryption", "enrypted", "decrypted", "enrypt", "Encipher"], "plaintext": ["plainth", "plainText", "broadText", " Plainpassword", " Plaintext", "plainpassword", "broadstring", "realstring", "plainstring", " PlainText", "realtext", "broadtext", "publicth", " plainth", "realtxt", "realText", " plaintxt", " plainText", "publictext", " plainpassword", "broadtxt", " plainstring", "publicText", "publicpassword", "plaintxt", " Plainth"], "md": ["ad", "nd", " mc", "cd", "dr", "dh", "ds", "del", "mt", "red", "grad", "nt", "MD", "m", "mp", "rm", "der", "mk", "hd", " dd", "managed", "mo", "mc", "df", "dd", "cmd", "pd", "good", "det", "msg", "ind", "mod", "mm", "ld", "med", "bd", "od", "deb", "dig", "mn", "mb", "esm", "material", "metadata", "d", "sd", "gr", " Md", "mg", "ms", "sm", "doc", "dm"], "raw": ["known", "message", "ng", "RAW", "bytes", "extra", "full", "draw", "out", "input", "all", "clean", "core", "unknown", "original", "html", "bare", "n", "row", "rew", "random", "orig", " Raw", "hook", "sh", "valid", "Raw", "json", "w", "unsigned", "clear", "hex", "aw", " RAW", "buf", "custom", "rendered", "available", "pack", "mem", "data", "cooked"], "hash": ["message", "cloth", "check", "id", "component", "search", "ssh", "ash", "hed", "ASH", "ashes", "mac", "html", "key", "mask", "h", "handle", "alert", "dump", "href", "password", "sh", "tr", "shadow", "height", "json", "ashed", "sha", "has", "hex", "bh", "Hash", "rh", "total", "sum", "print", "proof", "name", "tag"]}}
{"id1": "22441244", "id2": "823074", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"send": ["reply", "Send", "message", "init", "parse", "write", "save", "apply", "add", "push", "submit", "end", "sent", "msg", "set", "report", "post", "get", "mail", "build", "export", "transfer", "print", "security", "create", "execute"], "hsession": ["rsess", "HSessions", "hessions", "hhhip", "hsettings", "HSsession", "hettings", "HSess", "HSpace", "hsessions", "hspace", "hhession", "hsess", "hhsession", "hhessions", "rspace", "hession", "hhip", "rsession", " HSession", "hssession", "hship", "HShip", " HSpace", "HSession", " HSess", "hhettings", " HSsession", "HSettings", "rssession"], "session": ["message", "ess", "driver", "store", "cache", "context", "instance", "lock", "client", "Session", "job", "ession", "sid", "object", "manager", "password", "document", "state", "set", "view", "parent", "account", "connection", "event", "content", "name", "ip"], "repositoryName": ["repoositoryData", "reposoryData", "repositoryTitle", "repoositoryPath", "reposositoryname", "repositableData", "repositionPath", "repositoryNAME", "repositorNAME", "repositionNAME", "reposoryname", "reposoryNAME", "reposositoryData", "repositorName", "repoositoryTitle", "reposoryName", "repositorPath", "repoitoryname", "repositorTitle", "repoositoryname", "repositoryPath", "repoitoryTitle", "repositableName", "reposositoryNAME", "repositionTitle", "repoositoryNAME", "repoitoryData", "repositableNAME", "repositoryname", "reposositoryPath", "repositoryData", "repositablename", "repoitoryNAME", "repositionName", "repoositoryName", "reposositoryTitle", "reposositoryName", "repoitoryName", "repoitoryPath"], "ideIdint": ["ideIdentind", "IDEIdINT", "ideInfoINT", "ideIdentint", "ideIdline", "ideThind", "IDEidint", "IDEidINT", "ideIdINT", "ideIDind", "ideidint", " ideThline", "ideInfost", "ideIDline", "ideIdst", "ideIDno", "ideidst", "ideIdentline", "ideIdentno", "ideThint", "ideThline", " ideThint", " ideThind", "ideDst", "ideIDint", " ideIdind", "IDEIdst", "ideInfoint", "ideidINT", " ideIdline", "ideThno", "ideDINT", " ideThno", "ideDint", "ideIdind", " ideIdno", "ideIdno", "IDEIdint", "IDEidst"], "to": ["range", "tt", "tp", "address", "toc", "t", "about", "phone", "pos", "client", "To", "top", "too", "ta", "eto", "route", "os", "pro", "TO", "addr", "tr", "token", "site", "st", "company", "target", "po", "by", "no", "ato", "co", "contact", "o", "auto", "tel", "topic"], "cc": ["cs", "ce", "cd", "tc", "sc", "ci", "toc", "fc", "rc", "cl", "cb", "dc", "cloud", "mc", "cv", "ac", "cp", "ct", "cmd", "cn", "control", "ic", "CC", "ico", "cm", "cmp", "cr", "company", "cca", "cci", "ca", "ec", "cy", "ctrl", "cin", "ck", "co", "cf"], "bcc": ["bck", "bce", "cbcc", "cbCC", "vcy", "cbck", "sbck", " bck", "rbcm", "cbcm", "bcm", "rbCC", "vck", " bcm", "vce", "sbce", "rbce", "rbck", "vcc", "sbcc", "sbcy", "rbcy", "bCC", "rbcc", " bCC", "bcy"], "subject": ["message", "header", "template", "title", "note", "heading", "id", "face", "filename", "author", "description", "head", "html", "source", "Subject", "host", "uri", "text", "form", "mail", "content", "metadata", "security", "name", "prefix", "topic", "comment"], "body": ["b", "message", "bytes", "files", "template", "title", "note", "query", "url", "binary", "output", "shell", "ODY", "description", "any", "zip", "head", "news", "params", "back", "inline", "summary", "parts", "padding", "html", "top", "source", "null", "object", "h", "layout", "handle", "ody", "part", "default", "json", "business", "text", "bill", "report", "post", "hex", "bh", "mail", "no", "line", "buffer", "background", "content", "inner", "code", "base", "data", "name", "other", "comment", "response", "Body"], "attachments": ["attachtypes", "attachresses", "Attachments", "attachachment", "Attachresses", "Attachtypes", "atttypes", "achmentresses", "achmenttypes", "achmentments", "attments", "attresses", "Attachachment", "achmentachment"], "isHtml": ["isHap", " isHHTML", "isHHTML", " isWhtml", "IsHtml", "isChtml", "isWhhtml", "isVHTML", "isJttp", "isChip", "isVtml", " isWhip", "isWhip", " isHip", "ishttp", "isHttp", "IsHhtml", "isJhtml", "isWhHTML", "isVhtml", " isWhhtml", "isHip", "isChHTML", "isJap", "isChhtml", "ishtml", "IsHttp", "ishhtml", "isJtml", "isWhtml", " isWhHTML", "ishap", "isVip", " isHhtml", "isHhtml", "IsHap"], "charset": ["chippec", "ChARSET", "chersets", "charpetter", "ChARSet", "clarsetter", "quarsale", "CHarsets", "quatset", "quarset", "chARSets", "chippet", "chacterspace", "charsale", "Charset", "quarsec", "charsetter", "CHippets", "chablesetter", "chippets", "chableset", "chatsetter", "chippetter", "charpetic", "Charsetic", "clerset", "chARSetic", "chippET", "chablesec", "cherset", "chARSetter", "CHippett", "chablesale", "ChARSetter", "Charsetter", "charpett", "charsets", "channelsetter", "chacterset", "channelsET", "CHarsett", "quarsetter", "clersetter", "charpet", "chatset", "channelsetic", "charsET", "chactersetter", "clarspace", "clarsets", "chatsale", "charpET", "CharsET", "CHippet", "chARSet", "quatsec", "chippett", "quatsetter", "CHarsET", "ChARSetic", "charsetic", "chARSpace", "charspace", "chippale", "CHarset", "clerspace", "charsett", "chARSET", "cherspace", "chactersets", "CHippET", "charpets", "chersetter", "charsec", "clarset", "chatsec", "quatsale", "channelset", "clersets"], "headers": ["header", "files", "dr", "authors", "keys", "users", "head", "params", "comments", "ters", "heads", "types", " heads", "ilers", "details", " trailers", "limits", "ppers", "codes", "fields", "members", "relations", "names", "lines", "metadata", "ors", "ers"], "priority": ["title", "id", "grade", "context", "description", "properties", "phone", "comments", "pos", "origin", "due", "primary", "flags", "serial", " urgency", "password", "state", "policy", "company", "position", "status", "level", "security", " severity", "profile", "prefix", "order"], "email": ["external", "message", "ilo", "liner", "Email", "template", "ome", "voice", "note", "http", "all", "search", "office", "url", "address", "output", "database", "oe", "shell", "instance", "description", "echo", "link", "entry", "html", "gmail", "test", "detail", "domain", "label", "object", "die", "ell", "er", "il", "xml", "ne", "document", "initial", "result", "element", "el", "msg", "console", "company", "view", "password", "report", "em", "delete", "e", "mail", "log", "license", "line", "enter", "ssl", "event", "fax", "server", "contact", "print", "et", "model", "example", "sample", "response", "comment", "ee", "reset", "call"], "user": ["person", "match", "creator", "auth", "human", "id", "usr", "output", "author", "users", "login", "use", "actor", "browser", "client", "system", "student", "USER", "User", "from", "manager", "util", "used", "username", "owner", "result", "usa", "uid", "by", "ident", "usage", "entity", "me", "account", "connection", "profile", "name", "admin", "ip"], "identity": ["identificate", "IDENTator", "recognentity", "instifier", "identalty", "identicate", "primance", "primicate", "identance", "IDENTity", "equator", "identator", "ethnicentity", "identiciary", "entifier", "IDENTificate", "equity", "identifier", "equalty", "solidity", "presentularity", "IDENTifier", "presententity", "idITY", "entularity", "identality", "personity", "recognity", "IDENTITY", "ethnicularity", "idiciary", "instentity", "ententity", "IDENTicate", "IDENTitate", "presentitate", "primentity", "IDENTentity", "IDENTance", "idality", "equentity", "solidularity", "ethnicity", "recognance", "personicate", "instity", "solidentity", "instalty", "idularity", "recognicate", "instator", "personentity", "identitate", "IDENTality", "solidality", "identITY", "presentity", "idententity", "identularity", "entity", "IDENTalty", "personITY", "instularity", "IDENTiciary", "primity", "ethnicitate", "idity", "IDENTularity", "personificate", "personiciary", "primificate"], "_returnPath": ["_returnLocation", "_getPath", "setsavePath", "_deletePath", "setreturnTo", "_errorpath", " _returnPoint", "_errorAddress", "_resultLocation", " _errorPath", "setsavepath", "_errorName", "_deletePoint", "setreturnUrl", "_ReturnPoint", "_retPath", "_returnpath", " _returnAddress", "_returnUrl", " _errorName", "_savepath", "_replyPath", "_returnCode", "_getCode", "_retDir", "_errorPoint", "_requestName", "_errorTo", "_deletepath", "_requestAddress", "_returnDir", "_requestPath", "setreturnPath", "_errorPath", "_resultTo", " _errorPoint", "_getDir", "_ReturnPath", "_requestPoint", "_retUrl", "_getTo", "_errorLocation", "setsaveTo", "_deleteTo", "_resultPoint", "_errorUrl", "_returnTo", "setsaveUrl", "_retPoint", "_ReturnName", "_returnPoint", "_replyDir", " _errorAddress", "_savePath", "_retpath", "_saveUrl", "_retCode", "setreturnpath", "_retLocation", " _returnName", "_replyCode", "_returnName", "_returnAddress", "_ReturnAddress", "_resultPath", "_retTo", "_saveTo"], "_from": ["letto", "letabout", " _form", "remfrom", " _reset", "letsource", "_owner", "_reset", "_about", "_local", "remlocal", "longfrom", "_form", "letfrom", "\tactor", "_actor", "longsource", "\tauthor", "\tfrom", "_addr", "_author", "_source", " _source", " _about", "\tform", "remowner", "longto", " _actor", "remaddr", "longreset", " _author"], "_replyTo": ["_returnTO", "_backTO", "_backPath", "_returnFrom", "_responseLine", "_closeLine", "_replyPath", "_closeTO", "_ReplyTo", "_responseOf", "_respondTO", "_respondFrom", "_respondOnly", "_replyOnly", "_ReplyOnly", "_ReplyFrom", "_commentTO", "_commentLine", "_commentOf", "_closeTo", "_returnTo", "_replyOf", "_ReplyTO", "_commentTo", "_returnOnly", "_backFrom", "_replyFrom", "_replyLine", "_responseTo", "_responsePath", "_ReplyPath", "_responseFrom", "_replyTO", "_responseTO", "_backTo", "_respondTo", "_closeOf"], "_to": ["successto", "successtopic", "pritopic", "_ta", "successsite", "_site", "_topic", "prita", "prito", "prisite", "successta"], "_cc": [" _cs", "_cca", "_subject", " _cca", " _subject", "_cs"], "_bcc": ["_bacc", "_wck", "_bca", "_wca", "_wcc", "_rbca", "_bck", "_rca", "_rbck", "_wacc", "_rbcc", "_rcc", "_rck", "_rbacc", "_racc"]}}
{"id1": "19494842", "id2": "13333160", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 0, "substitutes": {"callService": ["callServices", " callServices", "useservice", "callservice", "useService", " callQuery", "runServices", "callQuery", "useServices", "useQuery", "runservice", "runQuery", " callservice", "runService"], "url": ["ls", "b", "dl", "http", "URL", "r", "address", "file", "l", "ur", "link", "str", "gl", "browser", "client", "google", "web", "nl", "hl", "acl", "uri", "char", "sb", "get", "Url", "conn", "ssl", "oul", "resource", "ul", "bel", "base", "ll", "pl", "channel", "service", "sl"], "in": ["In", "b", "read", "iter", "check", "is", "ill", "on", "conf", "out", "input", "rin", "it", "all", "r", "IN", "inn", "reader", "and", "l", "inf", "bin", "again", "ri", "ins", "from", "inc", "mc", "en", "ic", "er", "io", "el", "oin", "din", "isin", "cin", "mn", "con", "i", "gin", " din", "sum", "inner"], "inputLine": ["parseLINE", "InputLINE", "contextRow", "parseFile", " inputL", "helloLINE", " inputLINE", "responseRow", "InputLine", "parseRow", "contextline", "outputline", " inputRow", "inputline", "inputLINE", "contextL", "helloRow", "outputLine", "InputRow", "Inputline", "responseline", "parseLine", "inputL", " inputline", "responseLine", "outputRow", "helloFile", "responseLINE", "inputFile", "inputRow", "contextLine", "outputL", " inputFile", "helloLine"], "buf": ["inv", "aux", "block", "uf", "gor", "mu", "cap", "comm", "fam", "pkg", "mk", "rb", "queue", "cb", "nm", "Buffer", "bg", "nom", "br", "cv", "img", "bu", "cmd", "hung", "area", "bag", "bar", "cam", "vet", "msg", "alph", "tab", "conv", "bh", "Buff", "buffer", "vec", "cf", "cur", "raf", "buff", "mem", "bed", "ob", "db", "pb"], "answer": ["reply", "message", "remember", "place", "review", "value", "install", "accept", "cache", "Answer", "ver", "search", "array", "address", "argument", "say", "about", "send", "again", "entry", "sn", "onse", "continue", "image", "exit", "ve", "ask", "archive", "offer", "version", "username", "result", "command", "sequence", "report", "option", "form", "interpret", "equ", "question", "print", "poll", "response", "replace", "answered", "channel"]}}
{"id1": "2642914", "id2": "22046596", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarGzip", "addFileToTarGt", "addFileToTarGep", "addFileToTarGezip", "addFileToTarRzip", "addFileToTarBzip", "addFileToTarJzip", "addFileToTarJz", "addFileToTarGsp", "addFileToTarGet", "addFileToTarBz", "addFileToTarGsz", "addFileToTarRw", "addFileToTarRx", "addFileToTarJw", "addFileToTarGszip", "addFileToTarBx", "addFileToTarGw", "addFileToTarGp", "addFileToTarJx", "addFileToTarGez", "addFileToTarBw", "addFileToTarBp", "addFileToTarRz", "addFileToTarGx", "addFileToTarBt", "addFileToTarGst"], "taro": ["stro", "thosa", "qtolan", "tharo", "taco", "Taro", "ktarro", "toa", "tamo", "retamo", "tory", "waro", " tory", "tro", "ttara", "ttosa", "warro", " tamo", "maro", "Tro", "qtaro", "stary", "Tara", " tarro", "ktaro", " tara", "tosa", "staro", " trar", "staco", "tarro", " targo", "retara", "stargo", " toa", "mro", "tempargo", "thara", " tolan", "ttaro", "ktara", "thrar", "ktrar", "stoa", "starro", "Taco", "wargo", "Targo", " tro", "stamo", "retaro", "trary", "Tolan", "trar", "tary", "trro", " tary", "traro", "margo", "qtro", "tempro", " taco", "Tory", "thamo", "tolan", "troa", "wro", "marro", "tempamo", "Tamo", "tara", "targo", "tharro", "qtory", " tosa", "ttamo", "Tarro", "retaco", "temparo"], "path": ["Path", "ex", "th", "binding", "full", "transform", "url", "project", "file", "core", "dir", "m", "clean", "string", "parts", "root", "PATH", "c", "key", "entry", "p", "h", "pattern", "w", "text", "ref", "ath", "chain", "history", "kind", "print", "pi", "name", "mount", "local", "doc"], "base": ["b", "alias", "binding", "extra", "check", "template", "full", "relative", "bas", "file", "bf", "common", "Base", "padding", "root", "absolute", "bare", "family", "basic", "bad", "default", "part", "shadow", "parent", "build", "ase", "buffer", "pad", "server", "based", "start", "create", "name", "prefix", "db", "reset", "normal"], "f": ["b", "xf", "perm", "uf", "ft", "fs", "fed", "r", "far", "file", "fp", "bf", "fd", "tf", "fc", "elf", "t", "l", "fl", "fo", "inf", "c", "fx", "df", "p", "af", "h", "fe", "rf", "fac", "fi", "lf", "y", "F", "w", "form", "fab", "fg", "e", "g", "i", "sf", "fm", "fb", "fa", "cf", "v", "o", "d", "life", "fr", "alf"], "entryName": ["EntryName", "entryLetter", "ryLetter", "elementKey", "entryKey", "entryType", "entryname", " entryType", " entryPath", " entryLetter", "ryName", " entryname", "EntryType", "ryname", " entryKey", "Entryname", "ryType", "rowType", "rowLetter", "rowName", "entryPath", "cueKey", "elementname", "cuename", "EntryKey", "cueName", "EntryPath", "rowname", "elementName", "cueType", "elementPath"], "goIn": ["moin", "moIN", " goInput", "Goin", "moIns", "goIns", "moIn", "geInput", "poIN", "GoIn", " goIN", "goin", "GoOut", "GoIN", "goInput", "goOut", "GoIns", "poIn", "goIN", "geIns", "poin", " goIns", "poOut", " goOut", "geIn", " goin", "gein", "moInput"], "tarEntry": ["carCategory", " tarItem", "rarentry", "carEnt", "tarComponent", " tarComponent", "warEnt", "warEntry", " tarCategory", " tarentry", "tarEnt", "warComponent", "carentry", "rarEnt", " tarEnt", "warItem", "rarItem", "rarComponent", "tarItem", "tarentry", "carEntry", "rarCategory", "tarCategory", "rarEntry"], "children": ["ls", "cs", "ren", "files", "modules", "cache", "all", "many", "these", "fs", "keys", "packages", "wn", "users", "parents", "kids", "los", "hawks", "reports", "follow", "they", "groups", "balls", "jobs", "resources", "cloud", "roots", "batch", "gall", "json", "ports", "parent", "stories", "members", "ps", "ml", "names", "ul", "aos", "Children", "objects", "items", "ll", "each", "pages", "blocks"], "child": ["pixel", "block", "friend", "ph", "cache", "id", "shell", "file", "col", "fd", "Child", "count", "l", "zip", "uncle", "cell", "client", "job", "entry", "follow", "c", "key", "row", "brother", "page", "label", "q", "close", "batch", "handle", "char", "lf", "last", "ch", "cow", "parent", "background", "name", "comment", "ll", "fr"]}}
{"id1": "5620792", "id2": "7166270", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 0, "substitutes": {"SHA1": ["HS1", "sha1", "SHAOne", " SHA2", "HS2", "SHA256", "shaOne", " SHA256", "SHA2", "sha256", " SHAOne", "sha2", "HSOne", "HS256"], "text": ["message", "path", "read", "pt", "template", "value", "out", "input", "url", "subject", "select", "output", "translation", "nt", "config", "current", "t", "string", "str", "tx", "test", "key", "ext", "TEXT", "word", "term", "txt", "source", "q", "ct", "act", "pattern", "password", "document", "msg", "form", "cont", "event", "content", "print", "code", "Text", "data", "name", "prefix", "comment"], "HASH_VALUE_SIZE": ["HASH_VAL_NO", "HASH_VALUE_NAME", "HASH_VALUE_DIR", "HASH_VAL_NAME", "HASH_value_TYPE", "HASH_VALUE_NO", "HASH_value_SIZE", "HASH_VALUE_TYPE", "HASH_VALUE_Size", "HASH_VALUE_SOURCE", "HASH_value_DIR", "HASH_VAL_SIZE", "HASH_value_SOURCE", "HASH_VAL_Size"], "md": ["ad", "nd", " mc", "cd", "mond", " ms", "dh", "ds", "mt", "grad", "MD", "m", "mp", "dir", " mm", "rm", " del", "der", "mk", "cond", "add", "and", " ma", "ctr", "mode", "hd", " dd", "mc", "df", " rm", " mo", "h", "dd", "cmd", "pd", " sd", " cmd", "det", "ind", "mod", " man", "mm", "js", "hm", "ld", "bd", "dig", "od", "mn", "mb", "td", "mand", "d", " Md", "sd", " cd", "metadata", "mg", "ms", "sm", "dm"], "sha1hash": ["SHA1hex", "ha2hash", "SHA1hash", "sha3str", " SHA1sum", "ha1result", " SHA1value", "ha1hash", "sha1Hash", "ha2result", "shaonesum", "ha2Hash", "sha2str", "sha31value", " SHA31value", "sha1sum", "sha1hex", "ha1sum", "sha2hex", "sha31hash", "sha31sum", "sha1str", "sha5have", "sha1result", "sha7hex", "sha2sum", "sha1have", "sha7Hash", "sha2value", "shaoneresult", "sha5sum", "sha3hex", "sha1value", "shaonehash", "sha7hash", " SHA31have", "sha3Hash", "shaoneHash", "SHA2str", "sha3hash", " SHA31hash", "SHA2Hash", "SHA2hex", "sha2Hash", "ha1Hash", "SHA1Hash", "SHA1str", "sha7str", " SHA1have", " SHA31sum", "sha5value", "sha2hash", " SHA1hash", "sha5hash", "sha31have", "sha2result", "ha2sum", "SHA2hash", "sha2have"]}}
{"id1": "2217889", "id2": "5682569", "code1": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "code2": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getResourceAsStreamIfAny": ["getResourceAsStreamIFAny", "getResourceAsSteamIfRequired", "getResourceAsStreamIfANY", "getResourceAsSteamIfANY", "getResourceAsStreamIfPresent", "getResourceAsStreamifPresent", "getResourceAsSteamIfPresent", "getResourceAsStreamifAny", "getResourceAsStreamWherePresent", "getResourceAsStreamWhereAny", "getResourceAsStreamIFRequired", "getResourceAsSteamIFPresent", "getResourceAsStreamIFPresent", "getResourceAsStreamIFANY", "getResourceAsStreamWhereANY", "getResourceAsStreamifRequired", "getResourceAsSteamIfAny", "getResourceAsSteamIFANY", "getResourceAsSteamIFAny", "getResourceAsStreamIfRequired", "getResourceAsStreamWhereRequired", "getResourceAsStreamifANY", "getResourceAsSteamIFRequired"], "resPath": ["resName", "resourcePath", "relPath", " resUrl", "ResId", "ResCh", "resourceDir", "resId", "resourceCh", "ResName", "resDir", " resName", "Respath", "relUrl", " resDir", "resCh", "relId", "respath", "ResUrl", "resUrl", "ResPath", "resourceName", "ResDir", "relpath", " resCh", " resId", " respath"], "url": ["ls", "user", "path", "dl", "cert", "http", "URL", "f", "address", "db", "file", "norm", "l", "ur", "gl", "link", "str", "job", "web", "nl", "loc", "domain", "host", "uri", "cmd", "util", "char", "ref", "sb", "impl", "mail", "Url", "build", "get", "bb", "ssl", "raw", "resource", "server", "print", "location", "rel", "ll", "name", "mount", "service", "sl"]}}
{"id1": "13657527", "id2": "22801734", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 0, "substitutes": {"getDatasetsList": ["getDatasuresList", "getDatasesList", "getDatasuresResult", "getDatasetsStatus", "getDatisetsList", "getDatasetList", "getDatisetResult", "getDatasesStatus", "getDatisetStatus", "getDatasetResult", "getDatasetStatus", "getDatisetsStatus", "getDatisetsResult", "getDatasesResult", "getDatisetList", "getDatasuresStatus", "getDatasetsResult"], "surl": ["lsmail", "sUrl", "esUrl", "suri", "sysurl", "stslt", "syslt", "stsurl", "sname", "slim", "lsserver", "jslim", "esname", "sserver", " smail", "lsUrl", "stsserver", "esURL", "lsuri", "sslim", " sname", "sysuri", "esurl", "ssurl", " suri", "stsuri", "jsUrl", "esuri", "ssuri", "lsurl", " sUrl", "lslt", "sURL", "ssURL", "smail", "ssUrl", "slt", "jsuri", "sysserver", "jsurl"], "datasetsList": ["datisetsMap", "datarsetsMap", "datarssetsTable", "datasetsMap", "datasagesData", "datmasetsList", "datassetslist", "dataselinesGroup", "datasETSMap", "datasETSGroup", "datarsetsLock", "datasenslist", "datasagesSet", "datarsetslist", "datasetsName", "datasETSName", "datmassetsData", "datmassetsList", "datassetsSet", "datasagesMap", "datassetsLock", "datasetGroup", "datmassetsMap", "datarsetsList", "datasamesMap", "datassetsData", "datasetData", "datasetLock", "datarssetsLock", "datasourcesTable", "datasensList", "datarssetsList", "datasetName", "datasuresMap", "datmassetsLock", "datassetsTable", "datmasetsLock", "datasagesLock", "datasamesSet", "datasetList", "datasensMap", "datasETSList", "datasagesTable", "datasetSet", "datasamesList", "datisetsList", "datasourcesList", "datassetsMap", "datassetsList", "datisetMap", "datisetsName", "datisetName", "datarsetlist", "datasetMap", "datasetsLock", "dataselinesMap", "datasetsGroup", "datisetGroup", "datarsetsSet", "datisetList", "datasureslist", "datasuresSet", "datmasetsMap", "datarssetsSet", "datasourcesLock", "datisetsGroup", "datasameslist", "dataselinesName", "dataselinesList", "datasetsTable", "datasetsData", "datasetlist", "datarsetList", "datarsetSet", "datmasetsData", "datasourcesSet", "datarsetsTable", "datasetsSet", "datasuresList", "datasagesList", "datasetslist", "datarsetMap"], "result": ["Result", "message", "there", "exist", "cert", "search", "relation", "first", "description", "success", "record", "answer", "test", "found", "results", "detail", "details", "menu", "successful", "def", "default", "valid", "sequence", "set", "successfully", "folder", "report", "form", "ret", "chain", "buffer", "complete", "contact", "res", "response", "comment", "status", "diff", "table"], "reader": ["read", "driver", "rer", "liner", "Reader", "dr", "iter", "range", "query", "r", "wrapper", "older", "author", "file", "ser", "per", "parser", "bo", "client", "loader", "test", "roller", "peer", "rar", "stream", "row", "READ", "layer", "handle", "rl", "er", "runner", "upper", "handler", "field", "ner", "via", "rr", "body", "river", "socket", "writer", "reading", "redo", "iterator", "buffer", "timer", "rd", "resource", "inner", "mr", "operator", "ro"], "url": ["ls", "user", "dl", "http", "URL", "lr", "id", "r", "address", "file", "l", "ur", "link", "str", "browser", "client", "loader", "web", "org", "nl", "key", "stream", "row", "null", "uri", "char", "rl", "il", "mail", "Url", "ssl", "resource", "ul", "location", "ll", "mount", "sl"], "s": ["ls", "b", "cs", "gs", "is", "full", "gets", "strings", "us", "ts", "ds", "sql", "r", "ats", "sv", "abs", "t", "csv", "l", "str", "string", "less", "sym", "sts", "as", "sq", "n", "rs", "source", "tes", "still", "os", "ins", "h", "bs", "S", "y", "hs", "its", "js", "sb", "has", "ps", "series", "i", "ss", "v", "sw", "qs", "sample", "ws", "ids", "ms", "es", "ns"], "list": ["ls", "block", "group", "collection", "dl", "full", "format", "note", "lists", "all", "array", "li", "join", "php", "ist", "l", "left", "add", "pretty", "pool", "top", "test", "L", "word", "detail", "single", "def", "batch", "layout", "listed", "part", "sequence", "set", "st", "form", "stack", "log", "LIST", "ml", "chain", "cont", "print", "ll", "member", "local", "table"]}}
{"id1": "7425022", "id2": "9846843", "code1": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"transferWSDL": ["transferWSML", "transferWSDML", "transferWSDDL", "transferSWsdl", "transferSWSDDL", "transferSWSDL", "transferWsdML", "transferWSSL", "transferSWsdDL", "transferWSSDL", "transferSWsdL", "transferSWSDML", "transferSWSDl", "transferWSSML", "transferWsdDL", "transferWsdl", "transferWSDl", "transferWSMl", "transferWSSl", "transferSWsdML", "transferWSMDL", "transferWsdL", "transferWSMML"], "wsdlURL": ["wsdlUrl", "WsdlURL", "wslUrl", "wsdlUR", "wsdUR", "wslURI", "wsqlURL", "awsdlurl", "wsDLUR", "wsdlURI", "wsqlurl", "wslurl", "wsDLUrl", "WsdlUR", "awsdlURL", "WsqlURL", "wsdURL", "WsdlUrl", "wslURL", "WsqlURI", "awsdlUR", "awsdlUrl", "wsDLurl", "WsqlUR", "wsqlUR", "awslUR", "WsqlUrl", "awslURL", "wsDLURL", "wsdlurl", "WsdlURI", "wsdURI", "wslUR", "wsqlUrl", "wsdUrl", "wsqlURI", "awslUrl", "awslurl"], "userPassword": ["userpassword", "usePass", "UserPass", "usernameToken", "usePassword", "clientPassword", "useSecret", "UserToken", "userSecret", "Userpassword", "clientToken", "UserPassword", "userSalt", " userpassword", "usepassword", "UserSalt", " userSalt", "userToken", "userInformation", "usernamePassword", " userToken", "userPass", "usernameSalt", "clientInformation", " userSecret", "UserInformation", "usernamePass", "clientPass", " userPass", "usernameInformation", "UserSecret"], "filePath": ["Filepath", "resourceRef", " fileName", " filepath", " fileRef", "resourcePath", "fileName", "FilePath", "resourceName", "FileRef", "filepath", "fileRef", "resourcepath", "FileName"], "endpoint": ["ndPoint", "adp", "endger", "EndPO", "Endger", "endPO", "ndpoint", " endPO", " endger", "adPoint", "endpoints", "ENDPO", "ENDpoint", "EndPoint", "Endpoint", "ndp", "endp", "adpoint", "ENDger", "ndpoints", "adpoints", " endPoint", "ENDPoint", "Endpoints", "Endp", "endPoint"], "conn": ["obj", "ce", "init", "Conn", "ctx", "cert", "http", "conf", "on", "auth", "url", "open", "comm", "subject", "nt", "pkg", "add", "exec", "ann", "client", "ens", "cb", "org", "proc", "req", "fin", "gn", "loc", "txt", "os", "ait", "gate", "cp", "en", "cn", "ct", "cmd", "resp", "addr", "act", "ell", "canon", "pas", "nc", "attach", "msg", "desc", "ch", "conv", "enc", "dial", "get", "con", "jp", "ssl", "connection", "cont", "nw", "res", "cur", "ws", "connect", "att", "pg", "cfg", "call"], "is": ["nis", "ess", "\u00eds", "gs", "us", "isl", "where", "fs", "info", "ys", "iso", "I", "abs", "IS", "bis", "s", "ist", "isc", " Is", "oss", "lis", "inst", "ri", "ISS", "ists", "does", "ins", "still", "iss", "xs", "os", "rs", "ous", "ris", " are", " seems", "in", "are", "isf", "Is", "bs", "est", "sys", "obs", "icks", "isi", "im", "its", "has", "isin", "ios", "ais", "ress", "serv", "ison", "ice", "i", "sis", "si", "ches", "ism", "isa", "ois", "ish", "iris", "ms", " IS", "es", "ims", "ip"], "isr": ["isw", "itsrc", "owser", "owsp", "isrc", "owsr", "iser", " iser", "isR", "isrt", "isp", "itsR", " isp", "esrt", "issw", "eser", " isrc", "itsr", " isrt", "issrc", " isw", "esr", "issr", "issR", "esp", "itsw", "owsrt", " isR"], "sw": ["sword", "igm", "tw", "sc", "ew", "war", "wn", "ser", "wa", "ow", "sv", "sr", "sem", "wh", "wx", "sn", "rew", "rw", "SW", "rs", "Sw", "hw", "sk", "sh", "sam", "sp", "iw", "she", "nex", "w", "ch", "wr", "sb", "fr", "writer", "aw", "sf", "nw", "amp", "ws", "wo", "sm", "we"], "buf": ["b", "bytes", "uf", "mu", "cap", "fam", "err", "pkg", "col", "bl", "rb", "ctr", "cb", "cat", "nm", "Buffer", "row", "next", "txt", "br", "orig", "cv", "img", "arr", "cp", "box", "good", "batch", "fac", "char", "bag", "bound", "bar", "msg", "seq", "tab", "conv", "bh", "temp", "Buff", "buffer", "wb", "vec", "cf", "cur", "mem", "buff", "cast", "db"], "read": ["iter", "check", "gets", "wait", "input", "Read", "find", "write", "warn", "open", "ok", "give", "tell", "reader", "current", "add", "count", "str", "reads", "load", "send", "need", "before", "size", "word", "run", "n", "end", "stream", "q", "READ", "close", "in", "have", "handle", "len", "char", "tail", "old", "ind", "set", "w", "length", "text", "get", "buffer", "seek", "hold", "print", "cur", "start", "skip", "mem", "readable", "each", "index", "ready"], "outputDir": [" outputLen", "createDir", "coinDest", " outputSp", "writeFile", "writedir", " outputDirectory", "writeDef", " outputDest", " OutputDirectory", "documentdir", "documentDirectory", "outputDef", "inputDir", "coinFile", " outputdir", " OutputSp", "outputLen", "outputdir", " outputDef", "documentSp", "createDest", "outputDirectory", "coinLen", "coinDir", "outputDest", "documentDir", "outputFile", "outputSp", "createLen", " OutputDir", "inputDef", " outputFile", "createFile", "inputFile", "inputdir", "writeDir", " Outputdir"], "file": ["library", "message", "path", "template", "format", "out", "type", "f", "filename", "class", "output", "fp", "task", "tf", "link", "pool", "web", "image", "page", "le", "p", "object", "ile", "to", "handle", "tree", "xml", "work", "el", "spec", "w", "FILE", "con", "resource", "print", "base", "data", "name", "node", "channel", "File", "local", "table"], "fos": [" fjson", "inew", "bops", "bOs", "ojson", "owe", "fwe", " foes", "boes", "Foes", " fops", "fops", "bos", " fOs", "ijson", "onew", "iwe", "foes", " fnew", "FOs", "Fops", "fjson", "fnew", " fwe", "Fos", "fOs"]}}
{"id1": "400275", "id2": "8932510", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 0, "substitutes": {"url": ["b", "ls", "external", "path", "dl", "http", "URL", "sql", "r", "address", "file", "config", "l", "ur", "gl", "string", "str", "link", "browser", "job", "cl", "web", "html", "nl", "key", "term", "loc", "domain", "page", "q", "uri", "pattern", "util", "char", "rl", "xml", "default", "el", "ref", "get", "log", "Url", "pl", "ld", "impl", "ssl", "resource", "location", "base", "bel", "name", "ll", "mount", "sl", "un"], "in": ["In", "read", "online", "check", "is", "init", "on", "out", "input", "rin", "al", "update", "f", "login", "ln", "IN", "ma", "inn", "reader", "m", "s", "l", "ai", "bin", "again", "include", "c", "vin", "ins", "n", "source", "from", "mc", "null", "en", "mi", "oin", "body", "din", "isin", "min", "nin", "cin", "serv", "con", "i", "gin", " din", "line", "inner", "o", "name"]}}
{"id1": "8164056", "id2": "11032546", "code1": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 0, "substitutes": {"encode": ["genode", "enoder", "Encode", " encoder", "genenc", " enccode", "enenc", "enode", "genoder", "Enenc", "gencode", " encenc", "Enoder", "Enode"], "str": ["b", "obj", "strings", "input", "it", "r", "comm", "m", "t", "Str", "string", "ctr", "c", "n", "this", "txt", "br", "p", "arr", "coll", "char", "tr", "sp", "msg", "spec", "st", "text", "w", "STR", "wr", "conv", "enc", "e", "print", "v", "res", "data", "name", "oct"], "buf": ["b", "aux", "agg", "obj", "iter", "block", "foo", "uf", "mu", "cap", "bp", "tmp", "output", "pkg", "bc", "rb", "bo", "queue", "cb", "proc", "printf", "que", "Buffer", "next", "bg", "txt", "av", "br", "cv", "cmd", "box", "batch", "hung", "bag", "bound", "bar", "msg", "bh", "Buff", "bn", "temp", "buffer", "cf", "cur", "aer", "buff", "np", "ob", "db", "var", "pool", "pb"], "md5": ["dd45", " Md3", "dig3", "dd5", " MD3", "MD3", " md12", "mdlet", "dig2", " mdct", " mdlet", " md3", "md3", " md8", "dig8", "MD2", "MD5", "dd8", " MDlet", "MD12", "md2", "md12", "dig45", " Mdct", "dig5", " Mdlet", "dd3", " MD5", " md45", "md45", " Md5", "md8", "dig12", " MDct", " md2", "mdct"], "bytes": ["b", "pieces", "gs", "words", "files", "gets", "clips", "vals", " slices", " tmp", "sites", "binary", "vs", "gb", "iers", "tmp", "fps", "bis", "ashes", "cb", "parts", "bes", "bps", "pointers", "ings", " b", "tes", "fixes", "xs", "bits", " pixels", "services", "bs", "Bytes", "classes", "outs", "frames", " buffers", "steps", "xy", "its", "seconds", "js", "bles", "ios", "names", " chunks", "terms", "es", "values", "pages", "blocks"], "i": ["b", "ij", "ex", "is", "init", "us", "gi", "qi", "ski", "id", "it", "xi", "\u0438", "ci", "li", "info", "I", "m", "di", "ai", "ix", "gu", "ki", "x", "c", "key", "hi", "bi", "n", "ii", "a", "q", "multi", "u", "mi", "uri", "ic", "in", "batch", "major", "io", "y", "ind", "json", "im", "phi", "iu", "sim", "ie", "conv", "ji", "chain", "me", "si", "v", "pi", "ti", "cli", "point", "j", "ui", "index", "ini", "ip"], "s": ["b", "ls", "gs", "is", "gets", "ts", "ds", "fs", "sql", "r", "f", "z", "join", "sv", "abs", "t", "l", "se", "string", "sq", "n", "rs", "txt", "single", "os", "p", "h", "S", "sp", "spec", "y", "sol", "hs", "set", "sb", "js", "conv", "g", "ps", "ss", "sf", "sw", "v", "j", "sl", "ns"]}}
{"id1": "15516136", "id2": "14038176", "code1": "    public static synchronized BufferedImage loadBufferedJPEGImage(URL url) {\n        BufferedImage image = null;\n        if (url != null) {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);\n                image = decoder.decodeAsBufferedImage();\n            } catch (Exception e) {\n                log.severe(\"URL: \" + url + \" - \" + e.getMessage());\n                image = null;\n            } finally {\n                try {\n                    if (in != null) in.close();\n                } catch (IOException ioe) {\n                    log.severe(\"URL: \" + url + \" - \" + ioe.getMessage());\n                }\n            }\n            if (image != null) {\n                log.config(\"Image type : \" + image.getType());\n                if (image.getWidth() <= 0 || image.getHeight() <= 0) {\n                    log.severe(\"URL: \" + url + \" =0\");\n                    image = null;\n                }\n            }\n        }\n        return image;\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"loadBufferedJPEGImage": ["loadBufferedJPPGImages", "loadBufferedJPPGElement", "loadBufferedJPECImage", "loadBufferedMPILElement", "loadBufferedMPILFrame", "loadBufferedMPEGFrame", "loadBufferedJPPGFrame", "loadBufferedMPEGImage", "loadBufferedMPEGElement", "loadBufferedMPEGImages", "loadBufferedJPILImages", "loadBufferedMPILImages", "loadBufferedJPEGImages", "loadBufferedJPILImage", "loadBufferedJPILFrame", "loadBufferedMPILImage", "loadBufferedJPILElement", "loadBufferedJPEGFrame", "loadBufferedJPECImages", "loadBufferedJPEGElement", "loadBufferedJPECElement", "loadBufferedJPECFrame", "loadBufferedJPPGImage"], "url": ["ls", "rect", "dl", "full", "http", "URL", "fail", "lr", "id", "all", "k", "r", "address", "download", "sql", "file", "abs", "l", "ur", "gl", "string", "str", "link", "browser", "job", "cl", "loader", "web", "org", "nl", "html", "key", "email", "term", "domain", "null", "loc", "hl", "lb", "uri", "addr", "util", "github", "rl", "char", "xml", "el", "kl", "ref", "get", "impl", "Url", "ssl", "date", "resource", "print", "ul", "location", "name", "ll", "rel", "mount", "sl", "un"], "image": ["pixel", "external", "item", "ilo", "device", "out", "update", "binary", "media", "file", "game", "size", "source", "still", "mi", "png", "archive", "xml", "attribute", "unsigned", "none", "entity", "resource", "auto", "user", "value", "input", "all", "description", "icon", "age", "feature", "window", "row", "photo", "figure", "shape", "inner", "sample", "message", "block", "empty", "application", "error", "m", "instance", "entry", "memory", "page", "img", "manager", "sequence", "scene", "im", "remote", "Image", "buffer", "print", "data", "channel", "display", "http", "cache", "audio", "associated", "address", "output", "video", "frame", "crop", "word", "one", "picture", "object", "document", "ge", "view", "policy", "no", "me", "event", "model"], "in": ["In", "read", "is", "init", "on", "out", "input", "it", "al", "rin", "r", "f", "file", "ain", "IN", "ma", "inn", "and", "reader", "s", "l", "inside", "inf", "bin", "ai", "again", "include", "ar", "stream", "ins", "n", "source", "from", "inc", "mc", "en", "mi", "h", "to", "up", "er", "xml", "ind", "oin", "body", "im", "din", "isin", "by", "get", "re", "nin", "cin", "con", "serv", "i", "gin", " din", "sum", "inner", "o", "mem"], "decoder": [" decode", "decer", "encoder", "desoding", "encode", " decoding", "decode", " decade", "encer", " decer", "deoder", "Decade", "deoding", "decoding", "Decer", "Decode", "desode", "decade", "desoder", "Decoder", "encade", "deode", "desade", "deade"]}}
{"id1": "16673769", "id2": "9738825", "code1": "    @Override\n    public void Start() {\n        try {\n            Enumeration<URL> resources = Configurator.class.getClassLoader().getResources(IOCContainer.GetApplicationName() + \".config\");\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                if (Logger.logger.isDebugEnabled()) {\n                    Logger.logger.debug(\"Loading '\" + url + \"'\");\n                }\n                JSONValue configFileContents = JSONValue.Decode(url.openStream(), url.toString());\n                if (configFileContents instanceof JSONObjectValue) {\n                    for (Configurable configurable : IOCContainer.LookupAll(Configurable.class)) {\n                        JSONValue jsonData = ((JSONObjectValue) configFileContents).GetProperty(configurable.GetConfigSectionName());\n                        if (jsonData != null) {\n                            if (Logger.logger.isDebugEnabled()) {\n                                Logger.logger.debug(\"Configurging \" + configurable.getClass() + \" with '\" + jsonData.Encode());\n                            }\n                            try {\n                                configurable.Configure(jsonData);\n                            } catch (Throwable th1) {\n                                Logger.logger.error(\"Caught throwable while configuring \" + configurable.getClass() + \":\" + th1.getMessage() + \". IGNORED.\", th1);\n                                Logger.logger.error(\"[Continued]. Config Data was:\" + jsonData.Encode());\n                            }\n                        }\n                    }\n                } else {\n                    Logger.logger.error(\"'\" + url + \"' does not contain a json object. Skipping and looking for other applciation.config files in classpath ...\");\n                }\n            }\n        } catch (Throwable th) {\n            throw new RuntimeException(\"Exception while attempting to load application.config:'\" + th.getMessage() + \"'\", th);\n        }\n    }\n", "code2": "    public void load(URL url) throws IOException {\n        ResourceLocator locator = null;\n        try {\n            locator = new RelativeResourceLocator(url);\n        } catch (URISyntaxException use) {\n            throw new IllegalArgumentException(\"Bad URL: \" + use);\n        }\n        ResourceLocatorTool.addResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n        InputStream stream = null;\n        try {\n            stream = url.openStream();\n            if (stream == null) {\n                throw new IOException(\"Failed to load materials file '\" + url + \"'\");\n            }\n            logger.fine(\"Loading materials from '\" + url + \"'...\");\n            load(stream);\n        } finally {\n            if (stream != null) stream.close();\n            ResourceLocatorTool.removeResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n            locator = null;\n        }\n    }\n", "label": 0, "substitutes": {"Start": [" Init", " starting", "Load", "Init", "Services", " Startup", "Application", "Config", " Activate", " Serve", "run", "Next", " START", " Continue", "Launch", " Stop", "Command", "Run", " start", "Configuration", "Continue", "Loader", " resume", "start", " Launch", "Runtime", " restart"], "resources": ["headers", "models", "states", "Resources", "bytes", "faces", "files", "actions", "modules", "links", "works", "these", "builders", "ables", "packages", "options", "users", "writers", "times", "ues", "parents", "https", "reports", "apps", "groups", "types", "they", "flows", "roots", "services", "events", "cles", "classes", "issues", "features", "images", "seconds", " Resources", "uploads", "relations", "ions", "names", "objects", "archives", "rooms", "ids", "stores", "pages"], "url": ["b", "ls", "external", "path", "item", "dl", "http", "URL", "id", "sql", "r", "address", "f", "file", "request", "config", "t", "l", "ur", "gl", "str", "link", "browser", "loader", "web", "html", "nl", "entry", "key", "row", "domain", "this", "host", "uri", "addr", "pattern", "handle", "char", "rl", "util", "xml", "json", "ref", "ret", "impl", "remote", "Url", "log", "get", "buffer", "raw", "resource", "server", "location", "bel", "res", "base", "name", "ll", "rel", "mount", "sl", "un"], "configFileContents": ["textfileContents", "jsonPageContent", "jsonFileSettings", "configFILEContent", "configPageSettings", "configFILEContents", "jsonPageSettings", "textFileCont", "textfileContent", "textfileCont", "configfileBytes", "configFileBytes", "jsonfileRest", "jsonPageContents", "configfileContent", "configDocumentRest", "configFILECont", "configDocumentBytes", "jsonFileContent", "textFileContents", "configStreamSettings", "configFileContent", "configPageCont", "configStreamContents", "jsonFileContents", "configfileContents", "configFileSettings", "configfileSettings", "configFileCont", "textFileContent", "configDocumentContents", "configPageContents", "jsonfileBytes", "configfileCont", "jsonFileRest", "configStreamContent", "configStreamBytes", "configfileRest", "jsonFileBytes", "configFileRest", "configStreamRest", "configPageContent", "jsonfileContents"], "configurable": ["confurable", "configcrete", " configcrete", "cturable", "Configuable", "ctured", "muturable", "configured", "controlurable", "figured", "figurer", "figuable", "cturer", "mututable", "Configcrete", "captured", "Configurer", "Configured", " configuable", "logcrete", "logorable", " configutable", " configured", " configurer", " configorable", "formuable", "controlured", " configure", "configutable", "Configutable", "mutuable", "confure", "logurable", "Configurable", "formurer", "figurable", "controlutable", "logure", "configuable", "capturer", "ctutable", "confcrete", "captorable", "mutcrete", "configure", "confured", "confurer", "configurer", "formurable", "formured", "conforable", "configorable", "capturable", "controlurer"], "jsonData": [" jsonInfo", "configPart", "JSONdata", "xmlDat", "jsonEntry", "JSONDat", "sondata", " jsonDat", "xmlData", " jsonPart", " jsonEntry", " jsonContent", "sonData", "logInfo", "xmlInfo", " jsonTime", "JSONInfo", "configdata", "configInfo", "configData", "logPart", "configContent", "jsonDat", "jsondata", "logDat", "xmldata", "sonTime", "sonDat", "configTime", "jsonPart", "configDat", " jsondata", "sonEntry", "xmlContent", "jsonContent", "JSONData", "jsonInfo", "sonInfo", "jsonTime", "logData", "xmlEntry"]}}
{"id1": "23246123", "id2": "18962382", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    protected void connect() throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + account.getServer());\n        client = new FTPClient();\n        client.connect(account.getServer());\n        if (client.login(account.getId(), account.getPassword()) == false) {\n            logger.info(\"Fail to login with id=\" + account.getId());\n            throw new LoginFailException(account.getId(), account.getPassword());\n        }\n    }\n", "label": 0, "substitutes": {"createDialogArea": ["createImagearea", "CreateDialogBar", " createWindowarea", "createDialogarea", "createWindowarea", "createEditorBox", "createDialogBox", "CreateDialoguearea", "createDialoguearea", "createEditorArea", "createEditorAction", "createImageArea", "createWindowBox", "createDialogAction", "createEditorarea", " createWindowBox", "CreateDialogarea", "createFrameBar", " createDialogBox", " createWindowArea", "CreateDialogArea", "createImageBox", "CreateDialogueBar", " createDialogAction", "createImageAction", "createFrameArea", "createDialogBar", "createWindowAction", " createDialogarea", "createEditorBar", " createWindowAction", "createDialogueBar", "CreateDialogueArea", "createWindowArea", "createFramearea", "createDialogueArea"], "parent": ["pt", "block", "template", "component", " parents", "context", "instance", "parents", "pc", "params", "root", "self", "container", "this", "page", "null", "p", "cp", "Parent", "comp", "tree", "part", "document", "default", "sp", "par", "form", "ca", "g", "port", "ps", "server", "base", "pool", "child"], "composite": ["conposesite", "Compositable", "composesitor", "compositionites", "composit", "compposites", "composites", "conposites", "compositionit", "compositionite", "composited", "conposited", "composesitable", "compositable", "Comosites", "Comositable", "completites", "compositor", "comosites", "conposesited", "conpositor", "composesited", "composert", "composesite", "conposesites", "comppositable", "compositionert", "comosite", "completite", "compoite", "compoit", "compposite", "composesites", "Composites", "completitor", "compoites", "comositor", "Composert", "conposite", "comosert", "compoitable", "Composite", "completited", "conposesitor", "composesert", "comositable", "compposit", "Comosite", "comosited", "comosit", "Comosert", "compositionitable"], "content": ["message", "path", "header", "ce", "template", "article", "ctx", "format", "title", "wp", "cache", "value", "component", "application", "wrapper", "widget", "context", "media", "instance", "core", "current", "Content", "load", "html", "c", "container", "image", "this", "page", "null", "object", "cp", "action", "ct", "control", "settings", "copy", "version", "cm", "document", "xml", "console", "body", "view", "form", "city", "get", "license", "con", "java", "cont", "cf", "code", "create", "comment", "section", "pool", "child"], "ncol": [" ncolumn", "Ncol", "nccl", "numcl", "numcolumn", "Ncolumn", "ncolumn", "NCol", "nrow", "nccol", "numCol", "ncl", "numcol", "nCol", " nCol", "nccolumn", " nrow", "numrow", " ncl", "Nrow", "ncCol"], "layout": ["setup", "library", "block", "group", "slot", "template", "format", "display", "sheet", "draw", "cache", "grid", "widget", "shell", "list", "join", "l", "padding", "loader", "Layout", "system", "management", "window", "rang", "def", "scroll", "unit", "lay", "layer", "settings", "batch", "loop", "flow", "height", "shadow", "set", "view", "style", "tab", "position", "shape", "background", "hold", "language", "pool"], "numColumns": ["numColumnd", "numColS", "numberColumnd", "numberColumns", "numcolumnd", "numcolumnS", "numViews", "numcolumns", "numColumnes", "numViewes", "numberColS", "numberColumnes", "numViewd", "numColes", "numberCold", "numViewS", "numberColes", "numcolumnes", "numberCols", "numCold", "numberColumnS", "numColumnS", "numCols"], "browser": ["b", "user", "driver", "there", "webkit", "bridge", "Browser", "storage", "or", "vr", "http", "flash", "ver", "vis", "rame", "wrapper", "be", "widget", "mobile", "core", "editor", "orer", "back", "erer", "aster", "google", "loader", "web", "html", "bor", "roller", "window", "client", "test", "platform", "root", "page", "rar", "br", "uri", "hr", "abl", "manager", "og", "er", "runner", "io", "caster", "ger", "bar", "console", "river", "writer", "sim", "by", "remote", "gg", "bb", "buffer", "server", "fb", "theme", "chrome", "ler", "callback", "book"], "text": ["message", "read", "template", "article", "net", "title", "note", "tt", "format", "out", "binary", "widget", "output", "translation", "nt", "context", "description", "config", "editor", "t", "string", "str", "html", "x", "ext", "TEXT", "image", "word", "ont", "source", "txt", "term", "page", "label", "object", "ct", "xml", "view", "pdf", "writer", "license", "cont", "print", "code", "Text", "data", "utils", "language", "comment", "font"], "url": ["b", "dl", "http", "URL", "lr", "address", "open", "file", "l", "ur", "link", "str", "https", "gl", "web", "html", "nl", "window", "dll", "domain", "uri", "char", "rl", "il", "result", "get", "Url", "re", "ssl", "resource", "bel", "location", "res", "rel", "ll", "name", "sl"], "in": ["In", "b", "iter", "is", "dr", "or", "init", "net", "on", "out", "input", "rin", "it", "all", "f", "err", "ain", "ln", "IN", "m", "inn", "reader", "file", "t", "s", "l", "inside", "inf", "bin", "ar", "ir", "n", "ins", "source", "from", "stream", "mc", "inc", "en", "mi", "er", "io", "el", "ner", "ind", "din", "mm", "ie", "nin", "cin", "con", "i", "gin", "inner", "o", "mr", "fr", "ini"], "r": ["b", "ren", "rect", "rer", "dr", "or", "vr", "ro", "lr", "rus", "err", "rm", "rx", "sr", "reader", "rem", "reg", "rc", "rt", "rb", "ur", "l", "rate", "rg", "ri", "c", "rar", "n", "rs", "kr", "right", "br", "p", "nr", "rn", "rf", "rl", "er", "tr", "cr", "rr", "R", "re", "rd", "i", "d", "res", "mr", "ra", "ry", "rel", "j", "hr", "fr"], "sb": ["b", "rob", "sth", "ib", "bp", "gb", "sv", "bis", "rb", "SB", "cb", "sq", "bps", "bg", "txt", "erb", "lb", "gc", "ibl", "bs", "obs", "zb", "sp", "ub", "gob", "bh", "eb", "nb", "bb", "bsp", "mb", "ssl", "wb", "sf", "si", "xb", "bt", "sa", "kb", "sw", "buf", "lp", "ws", " SB", "stab", "sg", "sm", "pb"], "line": ["LINE", "user", "range", "header", "liner", "block", "iter", "number", "ln", "file", "stroke", "l", "frame", "ine", "str", "eline", "cell", "link", "string", "inline", "entry", "lin", "rule", "term", "word", "row", "page", "le", "source", "Line", "ile", "char", "part", "field", "sequence", "body", "log", "re", "entity", "no", "ice", "chain", "print", "code", "sample", "name", "phrase", "comment"], "e": ["ce", "ome", "f", "be", "oe", "error", "m", "xe", "t", "l", "se", "eg", "entry", "ae", "c", "de", "ue", "le", "a", "p", "en", "die", "ze", "pe", "ve", "fe", "ent", "ed", "er", "eeee", "ne", "ger", "el", "ge", "exp", "E", "te", "ie", "g", "eb", "re", "ec", "es", "je", "me", "ke", "i", "event", "et", "v", "o", "ev", "ee"]}}
{"id1": "10728243", "id2": "237493", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"scramble411": ["scramlepassword", "scramlePassword", "scrambledBasic", "scrambledPassword", "scramblepassword", "scramle ", "scamblesBasic", "scamble ", "scramblePassword", "scrambledpassword", "scramblespassword", "scrambled ", "scamblepassword", "scamblesPassword", "scrambleBasic", "scamblePassword", "scramble ", "scambleBasic", "scrambles ", "scramblesPassword", "scramleBasic", "scramblesBasic", "scambles ", "scamblespassword"], "password": ["remember", "message", "user", "sword", "words", "auth", "pass", "Password", "wd", "address", "database", "description", "secret", "string", "padding", "email", "key", "word", "primary", "pattern", "username", "attribute", "shadow", "token", "text", "crypt", "hash", "profile", "data", "phrase", "prefix", "hello", "reset"], "seed": ["setup", "template", "Salt", "offset", "sudo", "sql", "mix", "ser", "secret", "se", "feed", "vector", "padding", "test", "entry", "key", "needs", "random", " seeded", "source", "df", "derived", "prime", " seeds", "initial", "shadow", "sex", "sequence", "eed", "eder", "start", "sample", "rand", "create", "hash", "example", "phrase", "index", "reset"], "md": ["ad", "nd", "pt", "amd", "cd", "dr", "dh", "gm", "mt", "grad", "red", "nt", "MD", "m", "mp", "pkg", "rm", "pm", "der", "ma", "mk", "exec", "ann", "rpm", "de", "hd", "managed", "mind", "mc", "df", "img", "multi", "pd", "cmd", "dd", "def", "ct", "addr", "det", "cm", "msg", "ind", "mod", "desc", "sha", "pdf", "mm", "ld", "med", "bd", "od", "dig", "mn", "mb", "rd", "esm", "td", "metadata", "sd", "d", "mand", "mg", "ms", "di", "sm", "dm"], "passwordHashStage1": ["passwordHashSHA0", "passwordHashPhaseOne", "passwordhashStage2", "passwordHashstage01", "passwordHashStage5", "passwordHashSHA2", "passwordHashstage2", "passwordhashstage1", "passwordHashstage0", "passwordHashStageOne", "passwordHashPage2", "passwordHashStage0", "passwordHashPhase0", "passwordHashSHA01", "passwordHashstage1", "passwordHashPage0", "passwordHashPhase2", "passwordHashPhase1", "passwordhashStageOne", "passwordhashStage0", "passwordhashStage1", "passwordHashPage5", "passwordhashstage2", "passwordHashstageOne", "passwordHashPage1", "passwordHashstage5", "passwordhashstage0", "passwordHashSHA1", "passwordHashStage01", "passwordhashstageOne"], "passwordHashStage2": ["passwordSaltStage62", "passwordHashStyle62", "passwordHashScene3", "passwordSaltStage2", "passwordHashstage2", "passwordHashStyle3", "passwordHashstageTwo", "passwordHashPhase4", "passwordHashVersionTwo", "passwordHashStyle2", "passwordHashstage1", "passwordHashStage4", "passwordHashStage3", "passwordHashPhase2", "passwordHashPhase1", "passwordHashVersion1", "passwordHashStageTwo", "passwordHashPhaseTwo", "passwordHashVersion4", "passwordSaltStage3", "passwordSaltStageTwo", "passwordHashStage62", "passwordHashScene62", "passwordHashSceneTwo", "passwordHashStyleTwo", "passwordHashVersion2", "passwordHashstage4", "passwordHashScene2"], "toBeXord": ["toBeYor", "tobeYor", "toBeXor", "tobeXor", "tobeYords", "toBeZords", "tobeXold", "toBeTxond", "toBeZor", "toBEXorg", "toBeXLor", "toBEXord", "toBeXond", "toBeZXold", "toBEXor", "toBeZXord", "toBeXords", "toBeYords", "toBexorg", "toBeXLord", "toBeTxords", "toBeZXords", "toBexor", "toBeYord", "toBeYod", "toBeYold", "toBexord", "toBeXorg", "toBEXords", "toBeZord", "tobeXords", "toBeXLords", "tobeYold", "toBeXold", "toBEXod", "toBeTxord", "toBexond", "toBeXLod", "toBEXond", "tobeYord", "toBeYorg", "toBeTxorg", "tobeXorg", "toBeZorg", "tobeXord", "tobeYorg", "toBexords", "toBeXod", "toBeZXor"], "numToXor": ["num2Xors", "numToRestor", "numToRestore", "num2Xor", "num2Xore", "num2Restore", "numToXors", "numToxord", "numtoYOR", "numToZors", "numtoYors", "numToYor", "numToxors", "numtoXord", "num2Restors", "numToYors", "num2Restor", "numToYOR", "numtoYor", "numToxOR", "numToZOR", "num2RestOR", "numToZord", "numtoXOR", "numToXord", "numtoXor", "numToxore", "numtoYord", "numToYord", "numToXOR", "numToZore", "numToXore", "numToRestors", "numToZor", "numtoXors", "numToRestOR", "numToxor", "num2XOR"], "i": ["ex", "is", "init", "ni", "us", "gi", "it", "qi", "xi", "k", "info", "ci", "li", "ms", "z", "I", "m", "\u0438", "t", "s", "ai", "ix", "ri", "x", "bi", "n", "ii", "multi", "u", "mi", "uri", "ic", "in", "batch", "io", "fi", "y", "ind", "set", "sequence", "im", "phi", "sim", "g", "e", "ie", "ji", "si", "span", "ei", "pi", "zi", "o", "ti", "cli", "j", "ui", "di", "ini", "ip"]}}
{"id1": "11305840", "id2": "16557837", "code1": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "code2": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "label": 0, "substitutes": {"setUpdateCliente": [" setupdateclienta", " setupdateClientes", " setUpdatePea", " setUpdateClienta", " setUpdatePersone", " setupdatecliento", " setUpdatePersono", " setupdatecliente", " setUpdatePersona", " setupdateCliente", " setupdateclientes", " setUpdatePees", " setUpdateCliento", " setUpdateclientes", " setUpdateClientes", " setupdateCliento", " setUpdateclienta", " setupdateClienta", " setUpdatecliente", " setUpdatecliento", " setUpdatePee", " setUpdatePeo", " setUpdatePersones"], "IDcliente": ["idClientel", "IDClientoe", "IDsclienti", "IDclientes", "IDclientE", "IDcellE", "IDClientee", "idClientes", "IDsClienti", "IDcliento", "IDactivee", "IDcelle", "idclientoe", "IDCliente", "IDstai", "IDClientE", "IDactiveE", "idclientes", "IDclienti", "IDstao", "IDsClientE", "IDcodee", "IDcodel", "IDsclientE", "idCliente", "idclientee", "idclientE", "IDcode", "IDactivees", "IDClienti", "IDClientes", "idclientel", "IDclientoe", "IDCliento", "idClientoe", "IDclientel", "idClientee", "IDactiveel", "IDparentoe", "IDstae", "IDcodoe", "IDcello", "IDscliento", "IDclientee", "IDstaE", "IDsCliento", "IDClientel", "idClientE", "IDparente", "IDcodes", "idcliente", "IDcelli", "IDsCliente", "IDscliente", "IDparentee", "IDparentE", "IDcodE"], "nombre": [" numbreb", "numbren", " nomer", "nuclereb", " nombres", "nombr", "numbres", " nombren", " nomere", "nomeren", "nometren", " nombreb", "nomeres", "nombren", "nomer", "nuclere", " nomeres", "numbr", " nomeren", "nucleren", " numbres", "numbreb", " numbren", " nombr", "nomereb", "numbre", "nucleres", "nometre", " numbre", "nombreb", "nometr", "nombres", "nometres", "nomere"], "paterno": ["pATEReno", "tatereno", "petterna", "patereno", "pATERne", "paterlo", "catterna", "paterna", "paterne", "patern", "peterno", "catterno", "tatterno", "peterlo", "caterna", "pATERna", "pattereno", "caterlo", "patterlo", "tatern", "peterna", "pattern", "catterlo", "caterno", "pettereno", "taterno", "tatterna", "catterne", "tattereno", "patterna", "pATERlo", "pettern", "patterno", "pATERno", "petterno", "pATERn", "tattern", "peterne", "caterne", "patterne", "taterna"], "materno": [" matterNO", "mterNo", "paterNo", "materna", " materna", "maserNo", "matterno", "mATERna", "mATERnumber", " matterna", "mterna", "paterna", "masernumber", "mterNO", "maserna", "paternumber", "pATERna", "matterna", "mATERNO", "mterno", "pATERnumber", " matterno", "materNo", "matterNO", "matternumber", "maserno", " matterNo", "pATERno", " materNO", " materNo", "maternumber", "mATERNo", "materNO", "mATERno", "matterNo", "pATERNo"], "ocupacion": ["ocuptarro", "incuppacion", "ocUpaci", "ocuptac", "ocuptaton", "ocupac", "ocuptanc", "ocuptaci", "ocuppac", "ocupsidad", "ocueac", "ocupaton", "ocuparro", "incuppanc", "ocUpacion", "incupacion", "ocUpidad", "ocueacion", "icupaci", "icuptaci", "ocupidad", "ocupsaci", "incuparro", "incupanc", "incupparro", "ocuptacion", "incupac", "ocueanc", "ocuppanc", "ocUpaton", "ocuppacion", "icuptacion", "ocupanc", "icupidad", "icuptaton", "ocupsacion", "ocupaci", "ocuptidad", "incuppac", "ocuearro", "ocupparro", "ocupsaton", "icuptidad", "icupacion", "icupaton"], "rfc": ["rcos", "rfa", "mfc", "urcos", "mwic", "rtc", "trfa", "mfl", "trtc", " rfa", "rfl", "rwic", "urwic", "trco", " rtc", " rfl", "yrfa", "urfc", " rco", "rco", "yrco", "yrtc", " rcos", "trfc", "urfl", "yrfc", " rwic", "mcos"], "stm": ["statm", "strm", "semc", "seM", "STm", "strmi", "strmt", "Stmi", "STM", "sem", "statmc", "stmi", "stmc", "Stmt", "STma", "Stm", "stma", "stmt", " stem", "statM", "strem", " stmi", "statma", "STmc", "sema", "stM", "Stem", " stmt", "stem"], "update": ["commit", "change", "Update", "check", "accept", "equal", "draw", "out", "fail", "component", "it", "write", "save", "open", "ok", "apply", "use", "add", "append", "UPDATE", "feed", "send", "success", "load", "include", "fill", "submit", "continue", "run", "end", "flush", "up", "layout", "initial", "result", "valid", "set", "report", "edit", "delete", "build", "remote", "updated", "remove", "only", "complete", "module", "create", "replace", "status", "local"]}}
{"id1": "14047629", "id2": "647224", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"source": ["message", "SOURCE", "format", "src", "input", "query", "sql", "Source", "address", "output", "shell", "file", "request", "reader", "ource", "seed", "se", "proc", "system", "image", "stream", "from", "q", "in", "expression", "copy", "result", "sequence", "console", "position", "iterator", "buffer", "event", "resource", "content", "sample", "data", "channel", "service"], "process": ["place", "script", "check", "init", "function", "pp", "parse", "store", "make", "thread", "component", "context", "class", "project", "pm", "file", "task", "session", "complex", "and", "processing", "use", "frame", "exec", "program", "network", "link", "se", "job", "proc", "Process", "memory", "term", "pid", "run", "p", "object", "cp", "cmd", "processor", "method", "handle", "pipe", "work", "command", "flow", "state", "sys", "console", "post", "status", "build", "condition", "chain", "code", "create", "execute", "mem", "node", "connect", "service", "call"], "processStdOut": ["processStrEx", "processStstdOut", "processStrdEr", "processStrrEr", "processStrOut", "processStdEx", "processStstdEx", "processStrrIn", "processStrEr", "processStstIn", "processStrdEx", "processStrrOut", "processStstEx", "processStstdIn", "processStstOut", "processStrIn", "processStrrEx", "processStdEr", "processStrdOut", "processStstdEr", "processStstEr", "processStrdIn"], "processStdIn": ["processStdsIN", "processStrIns", "processSTdIns", "processStackdsIn", "processStdIN", "processStdsIn", "processStrIN", "processStdsIns", "processSTdIN", "processSTtIns", "processStackdsin", "processStdsin", "processSttIn", "processStsIN", "processSttIN", "processStsIn", "processSttOut", "processStrin", "processStackdin", "processStrOut", "processStdIns", "processStackdIN", "processSTtIn", "processSTtIN", "processStdin", "processStackdsIN", "processStackdOut", "processStsOut", "processSTdOut", "processStackdsOut", "processStsin", "processStrIn", "processSTdIn", "processSTtOut", "processStdsOut", "processSttIns", "processStackdIn"]}}
{"id1": "10131427", "id2": "6470716", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpStream", " cpFile", " CopyFile", "CopyFile", "CopyStream", " copyfile", " Copyfile", " cpImage", " CopyImage", " copyStream", " CopyStream", " cpfile", "CopyImage", "Copyfile", " copyImage"], "in": ["In", "b", "is", "on", "input", "rin", "it", "r", "IN", "inn", "s", "l", "inf", "ar", "vin", "ins", "n", "source", "inc", "from", "en", "ic", "up", "el", "ind", "old", "st", "edIn", "din", "mm", "isin", "cin", "i", "gin", "o"], "out": ["b", "ex", "check", "OUT", "net", "ou", "it", "err", "output", "nt", "file", "help", "t", "l", "s", "str", "oss", "gt", "Out", "n", "os", "to", "io", "ne", "outs", "w", "ch", "po", "log", "serv", "i", "v", "o", "ot"], "sourceChannel": ["sourceChuck", "matchChuck", "srcStream", "srcChannel", "matchButton", "sourceConnection", "ourceChain", "sourceApplication", "ourceButton", " sourceButton", "ourceChan", "sourceChan", "sourceStream", "sourceChain", "SourceStream", " sourceChain", "singleChannel", "inputChannel", "sourceButton", "singleApplication", "SourceChannel", "ourceStream", "ourceConnection", "resourceStream", "sourcechannel", "resourcechannel", "ourceChannel", "resourceChannel", "resourceConnection", "srcchannel", "matchApplication", "singleButton", "seedChannel", "matchChannel", "singleChuck", "inputChan", " sourceChan", "inputConnection", " sourceStream", " sourcechannel", "ourcechannel", "srcButton", "SourceConnection", " sourceConnection", "seedChuck", "Sourcechannel", "inputChain", "seedApplication", "seedButton"], "destinationChannel": ["destinationsContext", "desticationChan", "DestensionChan", "DestinationChan", "destinatedContext", "destationClient", "destroyConnection", "destinationConnection", "destensionChan", "DestinationCow", "destinatoryCow", "DestinationChannel", "destroyChannel", "DestationConnection", "DestensionChannel", "DestationBlock", "destinatoryBlock", "destinatoryChan", "destinatedChan", "DestensionClient", "destationContext", "desticationBlock", "destinationChan", "DestinationConnection", "DestationChan", "destinationCow", "destinatoryChannel", "DestationContext", "DestinationClient", "DestensionConnection", "destinatedChannel", "destroyClient", "destroyChan", "destationChan", "destinatedConnection", "DestinationContext", "desticationCow", "destationConnection", "destationCow", "destensionChannel", "destensionConnection", "destinationsChan", "destinationContext", "DestationChannel", "destinationClient", "destensionClient", "destationBlock", "destinationsConnection", "destinationBlock", "destinationsChannel", "DestationCow", "DestinationBlock", "destationChannel", "desticationChannel"]}}
{"id1": "18793482", "id2": "12055086", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modifyAppMessage", "modifyApplicationmessage", "modifyapplicationData", "modureApplicationMessage", "modifyAppMsg", "modifyapplicationMsg", "modifyApplicationData", "modifyServerData", "modureApplicationmessage", "modifyapplicationmessage", "modifyAppData", "modifyServerMsg", "modifyapplicationMessage", "modureAppData", "modifyServerMessage", "modureAppMessage", "modureAppMsg", "modifyApplicationMsg", "modifyAppmessage", "modureApplicationData", "modifyServermessage", "modureAppmessage", "modureApplicationMsg"], "locale": ["regational", " locales", "locales", "localey", "localaley", "LocALE", "Locational", "Locales", " locALE", "regales", "regale", "Locale", "Localey", "localale", " localey", "locational", "localales", "localational", "localALE", "regALE", " locational", "locALE"], "messageName": ["mediaName", "MessageNAME", "msgValue", "messageNAME", "MessageNames", " messageNAME", "MessageKey", "messageType", "messageNames", "mediaKey", "MessageName", " messageKey", "msgKey", " messageNames", "messageKey", "msgName", "mediaNames", "msgType", "mediaNAME", " messageType", "MessageValue", "MessageType"], "messageValue": ["MessageVal", "msgValue", "essageName", "msgvalue", "languageVALUE", "messageType", " messageVal", "MessageName", "Messagevalue", "languageValue", "MessageType", "languageName", "MessageVALUE", "msgVALUE", "messageVal", "messageVALUE", "languagevalue", "essageType", "msgName", "messagevalue", "essageValue", " messageType", "MessageValue", "essageVal"], "properties": ["message", "files", "prop", "options", "project", "config", " Properties", "params", "parts", "types", "results", "pid", "details", "pro", "settings", "json", "policy", "property", "report", "pdf", "perties", "ps", " props", "metadata", "profile", "data", "utils"], "i18nPath": ["i18neDriver", "i18nePoints", "i18nyDir", "i8nStr", "i18neStr", "i18neDir", "i8lPath", "i18natPoints", "i18neP", "i18rDir", "i18anDriver", "i18rDriver", "i18nP", "i8nPath", "i18anIf", "i18nyPath", "i18natDriver", "i18nDriver", "i18bStr", "i18nUrl", "i18nyIf", "i18lStr", "i18neUrl", "i18anPoints", "i18rIf", "i18anP", "i18bPath", "i18lUrl", "i18natP", "i8lStr", "i18rPath", "i8nDir", "i18nPoints", "i8lUrl", "i18anDir", "i18nStr", "i18bDir", "i18nDir", "i18lPath", "i18bUrl", "i18nePath", "i18natPath", "i18nIf", "i8lDir", "i18lDir", "i18nyDriver", "i8nUrl", "i18anPath"], "englishFile": ["ianaTable", "englishPath", "languagefile", "ianaPort", "electricFile", "wikiFile", "EnglishFilename", " englishDir", "enFiles", "languageFile", "electricPort", "ianafile", "Englishfile", "englishPort", "languageFilename", " englishPort", "EnglishFiles", "enFile", "enFilename", "ianaDirectory", "electricDir", " englishPath", "englishDir", "EnglishFile", "englishFilename", "englishTable", " englishTable", "ianaPath", "languageFiles", "wikiTable", "electricDirectory", " englishDirectory", "englishfile", "englishDirectory", "wikifile", " englishfile", "wikiPath", "ianaFile", "ianaDir", "englishFiles", "enfile"], "propertiesFilePath": ["propertiesfileName", "propertiesFileName", "settingsFilenamepath", "settingsFilepath", "pertiesFileName", "propertiesfileLocation", "propertiesFilenameType", "propertiesFilesType", "propertiesFilepath", "propertiesFilesLocation", "pertiesFilepath", "propertiesfilepath", "settingsFilePath", "propertiesfileType", "settingsFilenameName", "pertiesfilepath", "propertiesFilespath", "propertiesFilesPath", "propertiesFileType", "settingsFileName", "propertiesFilenamepath", "pertiesFilePath", "propertiesFilenameLocation", "propertiesFilenamePath", "settingsFileLocation", "propertiesfilePath", "pertiesFileType", "pertiesfilePath", "propertiesFilenameName", "settingsFilenamePath", "pertiesfileType", "propertiesFileLocation", "pertiesfileName", "propertiesFilesName", "settingsFilenameLocation"], "file": ["message", "path", "library", "files", "format", "write", "application", "type", "f", "filename", "class", "output", "be", "info", "fp", "current", "use", "string", "record", "entry", "key", "rule", "image", "run", "domain", "page", "source", "null", "os", "object", "ile", "handle", "xml", "io", "document", "fi", "result", "attribute", "console", "style", "report", "port", "FILE", "parent", "buffer", "complete", "connection", "module", "resource", "content", "model", "print", "base", "language", "data", "name", "create", "local", "comment", "channel", "File", "pool", "table"], "in": ["In", "read", "iter", "sin", "init", "input", "rin", "it", "al", "ain", "IN", "inn", "reader", "inside", "inf", "bin", "ai", "ri", "ar", "ir", "ins", "from", "inc", "en", "ic", "io", "ind", "oin", "din", "isin", "get", "cin", "i", "gin", " din", "asin", "inner", "ini"], "out": ["external", "put", "ex", "check", "at", "net", "OUT", "ou", "conf", "cache", "it", "write", "output", "nt", "cos", "csv", "again", "Out", "n", "end", "os", "screen", "to", "io", "outs", "set", "w", "conv", "log", "con", "co", "inner", "can", "aos", "sw", "o", "outer", "print", "we"], "c": ["cs", "ce", "cd", "cache", "conf", "cap", "k", "r", "col", "fc", "pc", "t", "count", "rc", "bc", "cos", "l", "cc", "cb", "cl", "character", "etc", "x", "dc", "\u00e7", "n", "mc", "cp", "ac", "gc", "ct", "u", "unc", "arc", "char", "C", "cm", "nc", "cr", "cu", "ch", "cod", "ca", "ec", "con", "chain", "i", "cont", "co", "d", "v", "code", "cf", "lc", "call"], "is": ["nis", "\u00eds", "isl", "it", "iso", "bis", "tis", "IS", "isc", "lis", "as", "ri", "ins", "iss", "os", "ris", "ic", "isf", "Is", "sys", "isi", "its", "ios", "isin", "ais", "i", "sis", "isa", "iris", "sit", "es"], "breader": ["brewe", "brewger", " breade", "bbr", "breadder", "browe", "bbar", "breadr", "brewer", "breadar", "bleer", "brewber", "browber", " breadber", "blear", " breadar", "browger", "bleder", "bbder", "breadger", " breadr", " breadger", "bber", "bler", "breadber", " breadder", "brower", "breade"], "line": ["LINE", "message", "block", "range", "liner", "iter", "header", "online", "note", "parse", "lo", "query", "string", "shell", "ln", "inline", "l", "ine", "frame", "link", "eline", "cell", "stroke", "record", "trace", "se", "entry", "lin", "nl", "continue", "rule", "word", "email", "row", "detail", "page", "label", "section", "le", "next", "cmd", "Line", "handle", "char", "part", "sequence", "text", "body", "slice", "side", "port", "no", "log", "entity", "mail", "ice", "chain", "lines", "stay", "edge", "queue", "left", "code", "sample", "node", "phrase", "comment", "lane", "point", "column", "ip", "normal"], "strBuilder": ["strParser", "StrBuffer", "stringBuilder", "objBuilder", "objBuild", "stringbuilder", "StrBuilt", " strBu", "stringParser", "StrParser", "arrBuilder", "strBuffer", "strbuilder", "StrBu", "arrbuilder", "frBuilder", "frBuilt", "objBuffer", "strBuild", "arrBuild", "strBuilt", "frParser", "stringBuilt", "strBu", "stringBuffer", " strBuffer", "arrParser", "arrBu", "StrBuild", " strbuilder", " strBuild", "frBuild", "stringBuild", "StrBuilder", "Strbuilder", "arrBuffer", "objbuilder", " strParser"], "pieces": ["bytes", "strings", "words", "links", "blocks", "keys", "Parts", "ties", "times", "powers", "rings", "parts", "pins", "caps", "sts", "pointers", "groups", "types", "checks", "cars", "xes", "fixes", "letters", "ops", "ces", "tools", "bits", "maps", "services", "finals", "places", "steps", "sections", "eps", "tips", "its", "ctors", "plates", "units", "ps", "piece", "lines", "players", "cuts", "items", "fits", "knife", "terms", "feet"], "found": ["supported", "read", "loaded", "empty", "needed", "sold", "changed", "find", "search", "focused", "finished", "err", "printed", "first", "forced", "done", "count", " Found", "Found", "success", "confirmed", "given", "defined", "expected", "started", "created", "tested", "successful", "good", "fixed", " caught", " detected", "ed", "sent", "used", "opened", "index", "compl", "valid", "old", "bool", "filled", " founded", "finder", "failed", "mounted", "available", "installed", "identified", "released", "built"]}}
{"id1": "9872346", "id2": "20232250", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["selectRawDocument", "readremoteFile", "selectRawFile", "readLocalFile", "readRawFile", "selectRawdocument", "readRemoteObject", "readLocalObject", "readremotedocument", "readRawDocument", "readRemotedocument", "readLocaldocument", "readLocalDocument", "readremoteDocument", "selectRemoteDocument", "selectRemoteFile", "readRawdocument", "readremoteObject", "readRemoteFile", "selectRemoteObject", "selectRemotedocument", "selectRawObject", "readRawObject"], "url": ["b", "ls", "path", "dl", "http", "URL", "lr", "r", "address", "file", "request", "abs", "l", "ur", "link", "str", "load", "browser", "client", "cl", "loader", "web", "html", "org", "nl", "key", "loc", "domain", "q", "host", "p", "u", "uri", "addr", "util", "github", "rl", "href", "el", "ref", "impl", "mail", "Url", "ssl", "resource", "ul", "location", "base", "ll", "mount", "channel", "hub", "sl"], "validate": ["Validation", " invalidation", "Valididate", " validateidate", "validates", "valididate", "Validate", "Validates", " invalidates", " validateates", "validation", " invalididate", " validateate", " validateation", " invalidate"], "document": ["person", "message", "collection", "article", "value", "ocument", "number", "component", "Document", "application", "information", "context", "output", "database", "file", "instance", "program", "record", "entry", "window", "reason", "word", "null", "object", "expression", "dict", "tree", "xml", "initial", "result", "command", "json", "text", "um", "entity", "duration", "buffer", "event", "content", "metadata", "model", "location", "language", "data", "response", "node", "relation", "doc"], "factory": ["tacter", "bFactory", "facFactory", "tiber", "fancy", "Fility", "bancy", "fixture", "face", "hFactory", "FFactory", "hixture", "fiber", "Face", "facility", "hactory", "facixture", "affFactory", "forace", "invacter", "tixture", "affificate", "Facter", "afface", "Factory", "kixture", "fificate", "vFactory", "Fancy", "fFactory", "Fixture", "Fificate", "affactory", "fility", "bactory", "kacter", "facactory", "vactory", "vacter", "kactory", "kiber", "invactory", "invixture", "tactory", "vancy", "hility", "forificate", "bacter", "inviber", "forFactory", "foractory", "facter"], "connection": ["operation", "driver", "Connection", "function", "query", "application", "open", "wrapper", "context", "database", "ion", "description", "session", "reference", "current", "link", "network", "client", "directory", "entry", "connected", "character", "builder", "object", "close", "created", "uri", "to", "cone", "version", " Connection", "command", "handler", "socket", "position", "statement", "writer", "engine", "city", "conn", "con", "condition", "resource", "server", "communication", "creation", "location", "pointer", "create", "response", "connect", "channel", "service", "relation"], "stream": ["Stream", "message", "read", "is", "out", "input", "progress", "context", "REAM", "present", "file", "instance", "reader", "zip", "feed", "client", "window", "row", "source", "still", "screen", "in", "sam", "sequence", "console", "length", "body", "upload", "stack", "iterator", "shape", "buffer", "cont", "resource", "content", "sw", "sample", "data", "ream", "response", "channel", "pool"]}}
{"id1": "9275622", "id2": "13152325", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" cpStream", " cpFiles", " duplicateFile", "copyFiles", " cpFile", " copyfile", " duplicateStream", " copyFiles", " copyStream", " duplicateFiles", " cpfile", " duplicatefile", "copyStream", "copyfile"], "_file1": ["_fileInit", "_link1", "_ile2", "_ileOne", "_FileOne", "_ile1", "_ileInit", "_files2", "_linkInit", "_FileFirst", "_fileOne", "_File1", "_files1", "_File2", "_filesFirst", "_FileInit", "_fileFirst", "_linkOne", "_link2", "_ileFirst", "_filesOne"], "_file2": ["_Fileb", "_linkTwo", "_image1", "_link1", "_FILEb", "_file02", "_File02", "_FILE1", " _FILEb", " _FILE2", "_image2", " _Filetwo", " _FILE1", " _File1", "_image02", " _fileb", "_File1", "_FILE02", " _FileTwo", "_Filetwo", "_File2", "_FILE2", " _filetwo", " _fileTwo", "_link2", "_imageb", " _file02", " _FILE02", "_fileTwo", "_filetwo", "_FileTwo", "_fileb", " _File2", "_linktwo"], "fis": ["kais", "ufi", "fois", "Fios", "fios", "kis", "Fis", "cos", " fris", "cios", " fios", " fois", "ufis", "fiss", "cfris", "fais", "cis", " fais", "qos", "fliss", "ufiss", "fris", "fi", "ufios", "cfois", "qiss", "kios", "cfiss", " fiss", " fi", "qios", "kos", "flis", "Fois", "Fris", "cfis", "qis", "fli", "flios", "Fos", "cais", "Fiss"], "fos": ["flos", "ffoes", "waos", " foes", "moes", "ffis", "hose", "wis", "sfoes", "foss", " fows", "hos", "sfoss", "floes", "floss", "hoss", "maos", "sfose", "ffos", " foss", "wos", "mows", "woes", "foes", "fose", "woss", "wows", "faos", " fose", "flis", "ffoss", "hoes", "fows", "mos", " faos", "sfos"], "canalFuente": ["canalKuperor", "canalFuenza", "canallFuje", "canalfuestro", "canalFaleree", "canalFuje", "canalUtente", "canallfuent", "canalTenenza", "canalFienza", "canallfueree", "canalfuent", "canalFuestro", "canalFient", "canalUteree", "canallfuperor", "canalKuent", "canalFalje", "canalFiperor", "canallFuenza", "canalfuenza", "canallFueree", "canalUtent", "canalKuente", "canallFuestro", "canallFuperor", "canalUtestro", "canalTenente", "canalfuje", "canalFiente", "canalFalent", "canalTenent", "canalFalperor", "canalfuente", "canallfuenza", "canalFuent", "canalfuperor", "canallfuente", "canallfuje", "canallFuente", "canallFuent", "canalFueree", "canallfuestro", "canalFuperor", "canalKuje", "canalTenperor", "canalFalente", "canalfueree", "canalFalestro"]}}
{"id1": "14047629", "id2": "13666876", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 1, "substitutes": {"source": ["message", "SOURCE", "format", "src", "input", "query", "sql", "Source", "address", "output", "shell", "file", "request", "reader", "ource", "seed", "se", "proc", "system", "image", "stream", "from", "q", "in", "expression", "copy", "result", "sequence", "console", "position", "iterator", "buffer", "event", "resource", "content", "sample", "data", "channel", "service"], "process": ["place", "script", "check", "init", "function", "pp", "parse", "store", "make", "thread", "component", "context", "class", "project", "pm", "file", "task", "session", "complex", "and", "processing", "use", "frame", "exec", "program", "network", "link", "se", "job", "proc", "Process", "memory", "term", "pid", "run", "p", "object", "cp", "cmd", "processor", "method", "handle", "pipe", "work", "command", "flow", "state", "sys", "console", "post", "status", "build", "condition", "chain", "code", "create", "execute", "mem", "node", "connect", "service", "call"], "processStdOut": ["processStrEx", "processStstdOut", "processStrdEr", "processStrrEr", "processStrOut", "processStdEx", "processStstdEx", "processStrrIn", "processStrEr", "processStstIn", "processStrdEx", "processStrrOut", "processStstEx", "processStstdIn", "processStstOut", "processStrIn", "processStrrEx", "processStdEr", "processStrdOut", "processStstdEr", "processStstEr", "processStrdIn"], "processStdIn": ["processStdsIN", "processStrIns", "processSTdIns", "processStackdsIn", "processStdIN", "processStdsIn", "processStrIN", "processStdsIns", "processSTdIN", "processSTtIns", "processStackdsin", "processStdsin", "processSttIn", "processStsIN", "processSttIN", "processStsIn", "processSttOut", "processStrin", "processStackdin", "processStrOut", "processStdIns", "processStackdIN", "processSTtIn", "processSTtIN", "processStdin", "processStackdsIN", "processStackdOut", "processStsOut", "processSTdOut", "processStackdsOut", "processStsin", "processStrIn", "processSTdIn", "processSTtOut", "processStdsOut", "processSttIns", "processStackdIn"]}}
{"id1": "4937535", "id2": "6871529", "code1": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private boolean readUrlFile(String fullUrl, PrintWriter out) {\n        try {\n            URL url = new URL(fullUrl);\n            String encoding = \"gbk\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding));\n            return fileEditor.pushStream(out, in, fullUrl, false);\n        } catch (Exception e) {\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"loadProperties": ["loadPrproperties", "initPrproperties", "loadPrps", "initPrdates", "loadProproperties", "loadPrperties", "loadproproperties", "loadPrdates", "loadprops", "loadPropperties", "initProproperties", "loadPropdates", "initPrperties", "initProps", "initPrps", "loadProps", "initProdates", "loadproperties", "initProperties", "loadProdates", "loadPropps", "loadprodates", "loadPropproperties"], "properties": ["poses", "abilities", "states", "notes", "sheets", "papers", "modules", "prop", "where", "keys", "builders", "marks", "facts", "options", "packages", "database", "prints", "params", "comments", "reports", "parts", "jobs", "projects", "results", "rows", "types", "this", "details", "pro", "to", "people", "beans", "settings", "features", "organisms", "policy", "property", "posts", "ports", "perties", "units", "ps", "tests", "holders", "relations", "members", "names", "metadata", "objects", "terms", "values", "bugs", "changes", "rules"], "url": ["ls", "obj", "b", "rect", "user", "dl", "http", "URL", "id", "open", "f", "address", "context", "file", "config", "abs", "l", "ur", "str", "browser", "loader", "nl", "p", "u", "uri", "char", "rl", "result", "kl", "ref", "ret", "sb", "build", "Url", "resource", "location", "bel", "ll", "mount", "service", "sl"]}}
{"id1": "11616716", "id2": "23246123", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResultsasView", "getCMSResultasStream", "getCMSResultasSteam", "getCMSResultasView", "getCMSResultsAsSteam", "getCMSResultsAsString", "getCMSResultsasString", "getCMSResultasString", "getCMSResultsAsStream", "getCMSResultsasStream", "getCMSResultAsView", "getCMSResultAsSteam", "getCMSResultsAsView", "getCMSResultAsString", "getCMSResultsasSteam"], "rqlQuery": ["rqlquery", "rqString", "rqlCommand", "rviewQuery", "rqStatement", "rumbleStatement", "RQLquery", "rQLCommand", "rqlStatement", "rviewCommand", "RqlQuery", "rQLQuery", "rqquery", " rqlStatement", "rviewquery", "rqlString", "rumbleQuery", "rsqlStatement", "RQLQuery", "Rqlquery", "rQLquery", "RqlCommand", "rqQuery", "rumbleString", " rsqlString", "RQLCommand", "rqCommand", "rsqlString", " rsqlQuery", " rsqlStatement", " rqlString", "rsqlQuery"], "osr": ["ossq", "osrator", "osscr", "or", "osrg", "ossh", "ossr", "osq", "ooser", "ossd", "possr", "ossmr", "ioscr", "orar", "osssr", "oscr", "osrw", "ossrar", " oscr", "osrar", "ossrw", "iosvr", "oessr", "ooscr", " osq", "osesmr", "iosq", "ossrg", "osmr", " osmr", " osrar", "oser", "oosr", "osd", "oesmr", "iosrator", " osvr", "ossvr", "iosd", "oseser", "iossr", "iosr", "iosmr", "osh", "osvr", "osesr", "oeser", "oesrator", "oesr", "osser", "oesrw", "osesrw", " osrg", "ioser", " ossr", " osh", "iosrg", "posrator", "iosh", "posr", "oosd", "ovr"], "url": ["ls", "dl", "cert", "net", "http", "URL", "open", "pkg", "abs", "l", "ur", "link", "str", "https", "gl", "client", "web", "nl", "loc", "hl", "lb", "host", "uri", "char", "il", "el", "ol", "ret", "ld", "mail", "Url", "build", "mb", "ssl", "ul", "bel", "rel", "ll", "mount", "sl"], "conn": ["obj", "init", "Conn", "ctx", "cert", "conf", "out", "win", "open", "comm", "nt", "sync", "col", "l", "exec", "link", "client", "cb", "proc", "org", "connected", "c", "req", "loc", "n", "os", "close", "cp", "cn", "ct", "cmd", "resp", "act", "canon", "addr", "nc", "sys", "socket", "ch", "conv", "enc", "con", "jp", "connection", "cont", "nw", "syn", "res", "cur", "rel", "connect", "j", "pg", "ns", "pas"]}}
{"id1": "23296117", "id2": "17630906", "code1": "    public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException {\n        String fullname = System.mapLibraryName(name);\n        String path = \"native/\" + sysName + \"/\" + fullname;\n        URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n        if (url == null) {\n            if (!warning) {\n                logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname });\n            }\n            return;\n        }\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        File targetFile = new File(getExtractionDir(), fullname);\n        OutputStream out = null;\n        try {\n            if (targetFile.exists()) {\n                long targetLastModified = targetFile.lastModified();\n                long sourceLastModified = conn.getLastModified();\n                if (targetLastModified + 1000 > sourceLastModified) {\n                    logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname);\n                    return;\n                }\n            }\n            out = new FileOutputStream(targetFile);\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n            in.close();\n            in = null;\n            out.close();\n            out = null;\n            targetFile.setLastModified(conn.getLastModified());\n        } catch (FileNotFoundException ex) {\n            if (ex.getMessage().contains(\"used by another process\")) {\n                return;\n            }\n            throw ex;\n        } finally {\n            if (load) {\n                System.load(targetFile.getAbsolutePath());\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n        logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile });\n    }\n", "code2": "    public static int[] sortAscending(float input[]) {\n        int[] order = new int[input.length];\n        for (int i = 0; i < order.length; i++) order[i] = i;\n        for (int i = input.length; --i >= 0; ) {\n            for (int j = 0; j < i; j++) {\n                if (input[j] > input[j + 1]) {\n                    float mem = input[j];\n                    input[j] = input[j + 1];\n                    input[j + 1] = mem;\n                    int id = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = id;\n                }\n            }\n        }\n        return order;\n    }\n", "label": 0, "substitutes": {"extractNativeLib": ["extractBaselib", "extractnativeLib", "extractNativeLibrary", "extractnativeFile", "extractBaseLib", "extractNativeFile", "extractInternalFile", "extractedNativelib", "extractedNativeFile", "extractedNativeLibrary", "extractInternalLib", "extractednativeLibrary", "extractInternalLibrary", "extractednativeLib", "extractednativeFile", "extractBaseLibrary", "extractednativelib", "extractBaseFile", "extractedNativeLib", "extractInternallib", "extractNativelib", "extractnativelib", "extractnativeLibrary"], "sysName": ["sysMap", "ysname", " sysNames", "sysN", "systemMap", " sysHandle", "sysHandle", "systemName", "systemNames", "sysType", "nsHandle", "synName", " sysname", "systemType", "synMap", "systemname", "synType", "synname", "sysname", "ysType", "ysNames", "nsName", "systemHandle", "ysName", "nsNames", "nsname", "sysNames", "ysMap", "ysN", "systemN", " sysN"], "name": ["alias", "nam", "title", "id", "type", "info", "filename", "ename", "file", "unknown", "s", "about", "string", "loader", "root", "nm", "Name", "word", "n", "run", "term", "source", "a", "version", "part", "default", "named", "mod", "ame", "NAME", "me", "names", "resource", "module", "create", "base", "data", "brain", "local"], "load": ["launch", "read", "library", "loaded", "loading", "check", "init", "install", "parse", "store", "cache", "fail", "register", "oad", "update", "write", "download", "save", "force", "warn", "sync", "Load", "loads", "use", "debug", "LOAD", "help", "link", "lock", "loader", "test", "include", "boot", "leaf", "label", "util", "dump", "require", "show", "remove", "hack", "enter", "hold", "create", "start", "play", "connect", "local", "call"], "warning": ["WARN", "message", "loading", "weak", "getting", "value", "function", "starting", "flash", "war", "warn", "force", "info", "ew", "error", "wa", "we", "help", "debug", "yellow", "pretty", "success", "web", "setting", "ping", "testing", "saving", "default", "fw", "console", "w", "writing", "Warning", "usage", "very", "aw", "only", "comment", "WARNING", "speaking"], "fullname": ["fullpath", "fullyame", " fullpath", "longn", "longname", "localName", "Fullvalue", "flatfilename", "longfilename", "shortName", "fullyvalue", "fullyNAME", "Fullfilename", "fulln", "fullnamed", "fullName", "localpath", "fullvalue", "fullynamed", "shortname", "flatname", "flatName", " fullfilename", "Fullpath", " fullame", "localfilename", "FullName", "fullfilename", "longnamed", "flatpath", "longpath", "shortn", "fullyName", "Fullname", "fullNAME", "longNAME", " fullName", "fullypath", "localname", "fullyname", " fullnamed", "shortpath", "longName", "fullame", "longame", "shortNAME", " fulln", "longvalue"], "path": ["pt", "Path", "transform", "th", "full", "where", "prop", "filename", "file", "dir", "php", "link", "string", "trace", "test", "PATH", "key", "root", "image", "route", "patch", "this", "near", "p", "pro", "uri", "def", "cmd", "pattern", "up", "spec", "exp", "w", "ref", "ath", "hex", "chain", "raw", "partial", "pointer", "prefix", "local"], "url": ["ls", "user", "rect", "dl", "cert", "http", "URL", "lr", "open", "f", "r", "li", "err", "norm", "abs", "l", "ur", "gl", "link", "fl", "https", "str", "job", "client", "loader", "org", "web", "nl", "req", "loc", "lb", "host", "addr", "util", "rl", "xml", "socket", "ret", "impl", "build", "Url", "con", "mb", "ssl", "raw", "resource", "bel", "res", "atl", "rel", "ll", "mount", "channel", "sl"], "conn": ["ls", "obj", "Conn", "cert", "ctx", "conf", "sql", "open", "comm", "nt", "sync", "col", "config", "reg", "pc", "exec", "str", "ctr", "client", "cb", "cc", "c", "mc", "close", "cp", "cn", "ct", "cmd", "resp", "addr", "canon", "handle", "cm", "nc", "cmp", "msg", "iw", "socket", "ch", "conv", "enc", "serv", "con", "jp", "ssl", "connection", "cont", "cf", "res", "cur", "ws", "connect", "pg", "pas"], "in": ["In", "read", "iter", "is", "init", "or", "net", "on", "input", "rin", "it", "all", "info", "r", "m", "ain", "IN", "ln", "inn", "inside", "inf", "bin", "ai", "again", "ar", "ins", "n", "source", "from", "inc", "mc", "en", "ic", "io", "el", "ind", "oin", "st", "din", "mm", "re", "nin", "cin", "con", "i", "gin", " din", "serv", "inner", "ry", "ini"], "targetFile": ["saveEntity", " targetPage", " targetEntity", "targetEntity", " targetFilename", "argetLog", "targetPage", "targetLog", "toPage", " targetPath", "targetFilename", " targetfile", "TargetFull", "TargetLog", "targetfile", "targetFolder", " targetFolder", "tofile", "sourceFilename", "Targetfile", "sourcefile", "targetFull", "saveFile", "proxyFolder", "topfile", "TargetFILE", "thisFile", "sourceFile", "topFilename", "argetFILE", "TargetPage", "thisPage", "toFilename", "argetFilename", " targetFILE", "saveFILE", "toFile", "proxyFILE", "saveFolder", "proxyFile", "TargetFilename", "targetPath", "TargetFile", "sourcePage", " targetLog", "thisPath", "argetfile", "argetFull", " targetFull", "targetFILE", "topFile", "sourcePath", "argetFile", "thisfile", "TargetPath", "proxyEntity", "topPath"], "out": ["conf", "err", "t", "boot", "ins", "p", "ne", "outs", "ch", "writer", "OU", "mit", "log", "con", "co", "sum", "v", "o", "auto", "other", "ot", "inv", "obj", "user", "ex", "init", "or", "ou", "all", "write", "nt", "ion", "again", "c", "end", "os", "cn", "result", "conv", "chain", "inner", "outer", "pool", "ns", "check", "at", "net", "oe", "cos", "pos", "Out", "n", "up", "io", "w", "aos", "timeout", "comment", "OUT", "cache", "it", "output", "oss", "bin", "client", "one", "null", "cmd", "to", "flush", "no", "buf", "can"], "targetLastModified": ["targetLastmodify", "targetLastLoadify", "targetLastLoadured", "targetLastQualed", "targetlastModifier", "targetMaxReified", "targetLastModured", "targetlastModified", "targetlastQualmodified", "targetMaxModify", "targetLastReured", "targetLastReified", "targetLastReify", "targetLastMsifier", "targetMaxReifier", "targetLastQualmodified", "targetMaxModured", "targetLastModed", "targetLastQualifier", "targetMaxReify", "targetlastQualified", "targetLastMsed", "targetLastModmodified", "targetLastQualified", "targetlastModed", "targetMaxReured", "targetlastQualifier", "targetLastModify", "targetLastModifier", "targetLastmodifier", "targetLastReifier", "targetLastMsmodified", "targetMaxModifier", "targetlastModmodified", "targetLastmodified", "targetlastQualed", "targetLastmodured", "targetLastMsified", "targetLastLoadified", "targetMaxModified", "targetLastLoadifier"], "sourceLastModified": ["sourceLastmodified", "sourceLastModTime", "sourceLastTimed", "sourcelastTrified", "sourceLastModed", "sourceLastMsTime", "sourceLastmodification", "sourceLastTrification", "sourceLastModification", "sourceLastTimmodified", "sourcelastTrification", "sourceLastMsification", "sourceLastTimified", "sourcelastTrTime", "sourceLastModsed", "sourceLastModmodified", "sourcelastTrify", "sourceLastModify", "sourceLastTrified", "sourcelastModify", "sourceLastTimification", "sourceLastmodTime", "sourceLastModsmodified", "sourceLastmodify", "sourceLastTrTime", "sourcelastModification", "sourcelastModified", "sourceLastMsified", "sourcelastModTime", "sourceLastTrify", "sourceLastMsify", "sourceLastModsified", "sourceLastModsification"], "len": ["ls", "bytes", "lan", "dl", "all", "cap", "nt", "ln", "t", "count", "l", "str", "fl", "pos", "L", "size", "nl", "fin", "fun", "n", "val", "lim", "le", "hl", "end", "en", "num", "coll", "el", "lf", "length", "mat", "seq", "Len", "ld", "no", "buf", "vec", "pad", "syn", "elt", "ll", "pl"]}}
{"id1": "350482", "id2": "22442270", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"doVersionCheck": ["doBuildUpdate", " doApplicationInfo", "doFeaturecheck", "doApplicationQuery", "doVersioncheck", " doApplicationTest", " doVersionsTest", "doImageInfo", " doVersioncheck", "doFeatureCheck", "doBuildCheck", "doBuildcheck", "doFeatureQuery", " doVersionTest", " doVersionInfo", " doApplicationCheck", "doVersionUpdate", "doImageTest", " doVersionsCheck", "doVersionQuery", "doVersionInfo", "doFeatureTest", "doApplicationTest", "doVersionsTest", "doFeatureUpdate", " doVersionUpdate", " doApplicationQuery", "doVersionTest", "doFeatureInfo", "doImageCheck", "doVersionscheck", "doVersionsUpdate", "doImageQuery", " doVersionQuery", " doVersionsUpdate", " doVersionscheck", "doBuildTest", "doApplicationInfo", "doApplicationCheck", "doVersionsCheck"], "view": ["block", "check", "review", "display", "http", "input", "component", "query", "update", "subject", "widget", "context", "project", "file", "lock", "browser", "cell", "VIEW", "client", "virtual", "html", "self", "window", "image", "row", "this", "page", "q", "vm", "cv", "h", "box", "manager", "tv", "layout", "index", "tree", "version", "document", "eye", "show", "report", "form", "see", "port", "engine", "controller", "ml", "buffer", "server", "print", "v", "model", "views", "View", "iew", "pool", "call"], "url": ["b", "dl", "http", "URL", "r", "address", "f", "file", "l", "ur", "gl", "link", "str", "browser", "client", "job", "html", "nl", "loc", "domain", "hl", "lb", "host", "mount", "uri", "char", "rl", "ref", "get", "mail", "Url", "log", "build", "ssl", "oul", "ul", "v", "bel", "rel", "ll", "pl", "sl"], "in": ["In", "is", "sin", "init", "on", "out", "input", "rin", "info", "f", "ln", "ain", "IN", "inn", "reader", "l", "inf", "vin", " IN", "stream", "ins", "n", "source", "inc", "from", "body", "mat", "din", "isin", "cin", "mn", "i", "gin", " din", "asin", "inner", "can"], "bin": ["b", "sin", "init", "obin", "thin", "out", "cache", "rin", "all", "win", "binary", "lib", "ln", "file", "bl", "session", "inn", "reader", "cos", "brain", "rb", "abin", "cb", "bi", " Bin", "ins", "bg", "jin", "len", "sam", " bins", "ebin", "body", "din", "conv", "stock", "by", "nb", "bn", "re", "mon", "cin", "con", "buffer", "gin", " din", "spin", "ran", "inner", "buff", "bed", "db", "bur", "local"], "line": ["LINE", "message", "block", "range", "liner", "channel", "iter", "parse", "lo", "lane", "err", "ln", "file", "cat", "inline", "l", "ine", "frame", "string", "eline", "cell", "tile", "link", "record", "trace", "lin", "entry", "job", "key", "rule", "word", "stream", "row", "section", "page", "le", "next", "detail", "cmd", "Line", " block", "char", "part", "field", "sequence", "style", "port", "log", "ice", "chain", "lines", "zone", "stay", "print", "code", "base", "sample", "column", "comment", "point", "status"], "develBuild": ["deVELBuild", "DeVELbuild", "duVELBuild", "devBoot", "duffbuild", "depobuild", "develBuilt", "deeltaRelease", "duVELbuild", "deffBuild", "deffBuilder", "develRelease", "duvelbuild", "desVELLoad", "desVELbuild", "duvelBoot", "deployBoot", "devLog", "deeltaLoad", "DevelBuilt", "duvelBuild", "DeVELBuild", "depoBuild", "duffBuild", "deVELLoad", "deVELBoot", "deVELBuilt", "devbuild", "duvelBuilder", "deeltaBuild", "develBuilder", "duvelBuilt", "DevelLog", "deVELbuild", "deffbuild", "desvelbuild", "Develbuild", "desvelBuild", "deployLoad", "duffBuilt", "deployBuilt", "depoBuilt", "develLog", "depoLog", "duVELBuilder", "deploybuild", "develBoot", "desVELBuild", "devBuild", "deVELBuilder", "DeVELLog", "deVELRelease", "deployRelease", "duVELBoot", "deployBuilder", "desvelRelease", "devBuilder", "deployBuild", "DevelBuild", "deffBuilt", "DeVELBuilt", "deVELLog", "desvelLoad", "duffBuilder", "develLoad", "devBuilt", "desVELRelease", "deeltabuild", "develbuild"], "stableBuild": ["secureCraft", "stableBind", "stableCraft", " stableBuilder", " stablebuild", "activeMake", "devMake", "confirmedLong", "stableLong", "stablebuild", " unstableBuild", " unstableCraft", "stableMake", " unstableBuilder", " unstableLong", "securebuild", " stableBoot", " unstableBoot", " stableCraft", "devbuild", " stableLong", "devBind", "confirmedBuild", " stableBind", " stableMake", "secureBuilder", " unstableBind", "devBuild", "confirmedBoot", "stableBoot", "confirmedbuild", "secureBuild", " unstablebuild", "devBuilder", "stableBuilder", "activeBuilder", "activeBuild", "activebuild"]}}
{"id1": "10385815", "id2": "8069594", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["read", "opy", "write", "download", "Cop", "save", "clip", "sync", "file", "paste", "rm", "csv", "load", "cat", "clone", "move", "cop", "cp", " copying", " duplicate", "Copy", "slice", "delete", "upload", "transfer", "create", "replace"], "fileFrom": [" fileInitial", "FileForm", "projectInitial", "FileTo", "inputFrom", "sampleInitial", "projectA", "sampleFrom", "inputForm", "ileFrom", " fileStart", "fileInitial", "fileForm", "projectStart", "FileObject", "sampleA", "ileForm", "ileTo", "projectFrom", "fileObject", "inputObject", " fileA", "inputTo", "fileA", "sampleStart", "FileFrom", "ileObject", "fileStart"], "fileTo": ["FileDest", "ile2", "modelTo", " file2", "FileTo", "ileTarget", "fileTO", "modelTO", "modelTarget", "file2", "fileDest", " fileTarget", "modelDest", "FileTO", "FileTarget", "ileTo", "fileTarget", " fileTO", "File2", "ileDest", " fileDest"], "inputStream": ["inputStreamer", "importStream", "eventstream", "sourceSteam", " inputSteam", "InputChannel", "InputSource", "sourceStream", "activeStream", "eventStream", "eventStreamer", "imageSteam", "audioStreamer", "audiostream", "InputSteam", "activeSteam", "sourceChannel", "inputSource", "eventSteam", "imageStream", "InputStream", "InputStreamer", " inputSource", "imageStreamer", "activeStreamer", "activeChannel", "audioStream", "importChannel", "importSteam", "imagestream", "inputSteam", "sourceSource", "audioSteam", "inputFile", " inputFile", "inputstream", "InputFile", "importFile", "imageChannel"], "outputStream": ["OutputFile", "resultSteam", "displaySteam", "webSteam", "displayChannel", "webStream", "writeSocket", "outputSocket", "inputString", " outputSocket", "displayStream", "writeStream", "writeChannel", "resultChannel", " outputString", "outputString", "webString", "resultSocket", " outputSteam", "OutputSteam", "webFile", "OutputStream", "resultStream", "displaystream", "outputstream", "outputFile", "writeSteam", "outputSteam", "webChannel", "inputSteam", " outputFile", "OutputChannel", "inputstream", "Outputstream"], "inputChannel": ["readableChan", "operatorStream", " inputSteam", "InputChannel", "readableChannel", "readChan", "InputConnection", "operatorConnection", "InputCamera", " inputChain", "localChannel", "createChannel", "createStream", "inputCamera", "outputChan", "currentChannel", "InputStream", "readChain", " inputConnection", "readableConnection", "currentChan", "inputChan", "operatorCamera", "InputChan", "createSteam", "localChan", "inputConnection", "localConnection", "outputSteam", "currentChain", "currentCategory", "inputSteam", " inputCategory", "readChannel", "createChan", "inputChain", "outputConnection", " inputCamera", "readCategory", "operatorChannel", "inputCategory", " inputChan"], "outputChannel": ["putchannel", "putChannel", "Outputchannel", "OutputCategory", "successStream", "writeChan", "successChannel", "outputchannel", "updatechannel", "hiddenCategory", "writeChannel", "hiddenChannel", "OutputChan", "outputContext", "OutputConnection", "successchannel", "outputChan", " outputContext", "updateChan", "OutputStream", " outputConnection", "OutputContext", "hiddenChan", "outputCategory", "hiddenchannel", " outputchannel", "updateChannel", " outputChan", "putChan", "writeConnection", "putStream", "writeContext", "updateCategory", "OutputChannel", "successConnection", "outputConnection"]}}
{"id1": "17974661", "id2": "11562165", "code1": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 0, "substitutes": {"requestServerModifications": [" requestSystemMODifiers", " requestSystemMODifications", " requestServerMODets", " requestSystemModifiers", " requestServerFixifications", " requestServerFixets", " requestServerModification", " requestServerMODification", " requestSystemModets", " requestSystemModifications", " requestServerFixification", " requestServerMODifiers", " requestSystemModification", " requestServerMODifications", " requestServerModifiers", " requestSystemMODets", " requestServerModets", " requestServerFixifiers", " requestSystemMODification"], "sessionId": ["sessionID", "sessionKey", " sessionName", "sessionName", "essionAnd", "SessionId", "sessionInfo", "SessionAnd", "SessionID", " sessionKey", "essionID", " sessionInfo", "essionId", " sessionID", " sessionAnd", "essionKey", "SessionName", "essionName", "essionInfo", "SessionInfo", "SessionKey", "sessionAnd"], "out": ["channel", "check", "OUT", "ou", "it", "f", "err", "output", "file", "m", "t", "s", "Out", "n", "this", "os", "p", "in", "to", "up", "io", "sys", "outs", "set", "w", "ch", "OU", "parent", "log", "v", "aos", "o", "name", "yout", "status", "pool"], "client": ["net", "http", "cache", "secure", "tc", "url", "ip", "force", "wrapper", "Client", "context", "request", "app", "network", "https", "google", "cl", "web", "system", "c", "key", "cn", "uri", "io", "cm", "handler", "console", "socket", "city", "remote", "conn", "ssl", "connection", "co", "server", "resource", "cli", "channel", "service"], "builder": ["b", " build", "bridge", "full", "uf", "builders", "url", " builders", "su", "bean", "Build", "der", "l", "ur", "eng", "parser", "web", "ender", "row", "orig", "ener", "hub", "building", "util", "upper", "bar", "BU", "sb", "by", "build", "log", "Builder", "buffer", "sf", "fb", "order", "base", "utils", "db", "built"], "method": ["tm", "message", "transform", "rest", "template", "function", "http", "find", "query", "url", "gm", "api", "select", "m", "request", "direct", "METHOD", "md", "send", "verb", "right", "Method", "end", "uri", "cmd", "command", "result", "mod", "view", "body", "form", "get", "process", "module", "man", "service", "via", "hod", "sm"], "response": ["reply", "message", "block", "function", "http", "application", "info", "output", "description", "request", "list", "frame", "pos", "success", "answer", "entry", "onse", "window", "image", "next", "page", "still", "object", "successful", "ve", "resp", "tree", "version", "xml", "document", "attribute", "result", "json", "sequence", "respond", "body", "report", "history", "connection", "content", "resource", "res", "hash", "Response", "data", "status", "relation"], "header": ["headers", "user", "operation", "block", "check", "th", "dr", "channel", "message", "title", "heading", "ver", "member", "component", "query", "info", "context", "error", "file", "list", "relation", "head", "zone", "string", "entry", "key", "peer", "detail", "null", "environment", "Header", "HEAD", "h", "layer", "er", "xml", "version", "attribute", "handler", "token", "command", "hidden", "property", "body", "form", "option", "meta", "parent", "line", "condition", "buffer", "history", "event", "metadata", "content", "server", "resource", "holder", "hash", "column", "tag", "comment", "status", "filter", "table"], "code": ["change", "message", "ce", "check", "th", "value", "number", "component", "time", "type", "info", "error", "core", "currency", "here", "pc", "done", "coe", "zip", "count", "zone", "ode", "coded", "se", "age", "success", "cc", "size", "zero", "c", "key", "x", "reason", "one", "page", "go", "close", "created", "xxx", "num", "Code", "result", "command", "state", "ge", "length", "ch", "see", "cod", "ie", "city", "no", "codes", "e", "cont", "content", "level", "create", "ure", "timeout", "status", "index", "xx"], "expectedLength": ["allowedLen", "pectedTime", "pectedLength", " expectedSize", "expectedTime", " unexpectedSize", " expectedTime", "reportedSize", "expectedLen", " unexpectedLength", " expectedLen", "reportedLen", "pectedLen", "allowedTh", " unexpectedLen", "allowedSize", "pectedSize", "expectedTh", "allowedLength", " expectedTh", " unexpectedTime", "expectedSize", "reportedTh", "reportedLength"], "is": ["nis", "\u00eds", "value", "or", "us", "isl", "was", "id", "type", "info", "iso", "_", "error", "file", "isd", "IS", "bis", "tis", "s", "isc", "lis", "as", "x", "key", "ists", "does", "rs", "still", "iss", "xs", "os", "bits", "ris", "not", "in", "are", "isf", "Is", "bs", "io", "version", "isi", "im", "its", "has", "js", "isin", "ios", "ais", "get", "i", "sis", "cont", "mis", "content", "isa", "ois", "name", "iris", "ms", "index", "es", "values"]}}
{"id1": "12078471", "id2": "5998352", "code1": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 0, "substitutes": {"tryLoadURL": ["tryLoadString", " tryloadUR", "tryOpenUR", "tryOpenString", "tryLoadUrl", " tryLoadString", "tryloadUR", "tryReadURL", " tryloadURL", "tryReadString", "tryReadUR", "tryloadString", " tryLoadUrl", "tryLoadUR", "tryReadUrl", " tryLoadUR", "tryloadURL", "tryOpenURL", "tryloadUrl", " tryloadString", " tryloadUrl", "tryOpenUrl"], "url": ["ls", "path", "dl", "http", "URL", "out", "sql", "k", "address", "r", "file", "abs", "l", "ur", "link", "string", "https", "job", "web", "html", "nl", "key", "loc", "q", "host", "uri", "pattern", "ref", "log", "Url", "build", "ssl", "print", "ul", "location", "ll", "pl", "sl", "un"], "format": ["feat", "transform", "at", "template", "function", "accept", "parse", "MAT", "with", "type", "f", "mt", "output", "file", "list", "config", "join", "fc", "and", "use", "ats", "mode", "printf", "html", "cat", "term", "Format", "struct", "unit", "act", "pattern", "layout", "att", "index", "sort", "settings", "version", "spec", "set", "mat", "style", "edit", "form", "print", "status", "filter"], "c": ["b", "cs", "ce", "com", "sc", "f", "r", "m", "fc", "l", "rc", "xc", "cc", "cl", "cb", "etc", "dc", "mc", "a", "p", "u", "ac", "cp", "ct", "C", "cm", "nc", "cr", "cu", "ch", "enc", "ca", "g", "conv", "ec", "ctrl", "con", "cin", "i", "cont", "co", "v", "cf", "cur", "anc", "lc", "call"], "data": ["message", "bytes", "value", "accept", "cache", "input", "info", "output", "space", "description", "string", "feed", "html", "key", "window", "image", "row", "source", "serial", "batch", "area", "dump", "json", "sequence", "text", "body", "DATA", "dat", "hex", "no", "buffer", "ata", "raw", "content", "d", "base", "sample", "response", "name"], "model": ["models", "obj", "message", "transform", "template", "value", "human", "save", "m", "relation", "map", "rm", "instance", "frame", "job", "de", "proxy", "object", "batch", "manager", "tree", "xml", "el", "gp", "mod", "command", "set", "view", "result", "im", "report", "form", "mm", "Model", "sim", "impl", "log", "controller", "re", "me", "mb", "module", "server", "sample", "response", "bm", "ll", "db", "sm", "table", "dm"]}}
{"id1": "10445819", "id2": "3187685", "code1": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"getReader": ["getRead", " getreader", "getStream", "Getreader", "GetStream", " getStream", "GetReader", "getreader", "newRead", "newreader", "newStream", "GetRead", " getRead", "newReader"], "stream": ["Stream", "message", "user", "store", "draw", "secure", "out", "input", "url", "open", "wrapper", "context", "present", "clean", "instance", "list", "reader", "feed", "proc", "system", "window", "row", "page", "pipe", "sequence", "console", "st", "body", "style", "socket", "form", "port", "engine", "stack", "log", "iterator", "trans", "chain", "buffer", "ssl", "cont", "metadata", "resource", "inner", "sw", "sample", "data", "ream", "channel", "filter", "sl"]}}
{"id1": "21092340", "id2": "6457199", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addInHarive", "addToExFile", "addToArchFile", "addInArchiver", "addInArchive", "addToHarive", "addToZipFile", "addToExive", "addInArchZip", "addInArchFile", "addToZipive", "addToZipiver", "addInHariver", "addToExZip", "addToZipZip", "addToHarZip", "addToArchZip", "addInHarZip", "addToArchiver", "addToExiver", "addToHarFile", "addToHariver", "addInHarFile"], "pod": ["ad", "message", "check", "device", "wp", "component", "pick", "project", "pkg", "task", "pc", "zone", "job", "proc", "top", "Pod", "p", "cp", "ods", "archive", "op", "spec", "policy", "body", "report", "post", "ack", "od", "disk", "pad", "module", "start", "pack", "poll", "volume", "point", "table"], "podArchiveOutputStream": ["podArchiveEntryPoint", "podArchiverOutputSync", "podArchiveOutputPoint", "podArchiverInputForm", "podArchiverInputSync", "podArchiveOutputForm", "podArchiveInputForm", "podArchiverOutputPoint", "podArchiveOutputMap", "podArchiverOutputMap", "podArchiveEntrySteam", "podArchiveOutputContext", "podArchiveStreamMap", "podArchiveOutStream", "podArchiverInputContext", "podArchiveoutputStream", "podArchiverInputSteam", "podArchiveResourceSteam", "podArchiveMainForm", "podArchiveOutputstream", "podArchiveResourcestream", "podArchiveStreamStream", "podArchiveOUForm", "podArchiveOutputSteam", "podArchiveoutputSteam", "podArchiveInputStream", "podArchiveInputPoint", "podArchiveoutputForm", "podArchiveOUSync", "podArchiverInputMap", "podArchiverInputstream", "podArchiveInputStreamer", "podArchiverOutputForm", "podArchiveStreamForm", "podArchiveInputSteam", "podArchiveMainStreamer", "podArchiverOutputStreamer", "podArchiveStreamSync", "podArchiveMainStream", "podArchiveOutContext", "podArchiverOutputstream", "podArchiveInputstream", "podArchiveOUStream", "podArchiveInputContext", "podArchiveOUMap", "podArchiverOutputSteam", "podArchiveResourceContext", "podArchiveInputMap", "podArchiveEntryStream", "podArchiveOutPoint", "podArchiveoutputStreamer", "podArchiveResourceStream", "podArchiverInputStream", "podArchiveMainSteam", "podArchiveOutstream", "podArchiverInputPoint", "podArchiveOutputSync", "podArchiveOutSteam", "podArchiverOutputStream", "podArchiveInputSync", "podArchiveOutputStreamer", "podArchiverOutputContext", "podArchiverInputStreamer"], "filename": ["message", "path", "title", "url", "binary", "subject", "ename", "output", "FN", "file", "description", "fp", "Filename", "string", "release", "original", "directory", "nm", "key", "family", "fn", "txt", "p", "png", "jpg", "uri", "nil", "archive", "version", "username", "fil", "folder", "ame", "kl", "upload", "FILE", "NAME", "names", "resource", "location", "stem", "latest", "name", "prefix", "println"], "source": ["SOURCE", "template", "supp", "src", "store", "input", "component", "sql", "Source", "info", "address", "select", "force", "shell", "context", "file", "ser", "ource", "seed", "use", "proc", "loader", "image", "stream", "from", "copy", "password", "spec", "sequence", "view", "body", "style", "get", "iterator", "series", "resource", "inner", "start", "sample", "service"], "entry": ["obj", "ment", "ce", "or", "sheet", "ace", "component", "query", "card", "tmp", "nt", "file", "task", "quick", "zip", "se", "link", "cell", "record", "Entry", "job", "system", "key", "word", "row", "ent", "good", "char", "archive", "attribute", "cue", "element", "set", "ie", "log", "line", "enter", "connection", "resource", "data", "ry", "comment", "channel", "book"]}}
{"id1": "19322910", "id2": "1235538", "code1": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 0, "substitutes": {"test_blueprintTypeByTypeID": ["test_blueprintTypeByTypeId", "test_blueprintTypeByNameType", "test_blueprintTypeByTypesID", "test_blueprintTypebytypeId", "test_blueprintTypeBytypeType", "test_blueprintTypeByTypesName", "test_blueprintTypebytypeName", "test_blueprintTypeByNameName", "test_blueprintTypeByNameID", "test_blueprintTypebyTypeType", "test_blueprintTypebytypeID", "test_blueprintTypeByTypeName", "test_blueprintTypeByTypesId", "test_blueprintTypebyTypeName", "test_blueprintTypeBytypeId", "test_blueprintTypeBytypeName", "test_blueprintTypeByTypeType", "test_blueprintTypebyTypeID", "test_blueprintTypebytypeType", "test_blueprintTypeBytypeID", "test_blueprintTypeByTypesType", "test_blueprintTypeByNameId", "test_blueprintTypebyTypeId"], "url": ["ls", "b", "user", "channel", "dl", "http", "URL", "open", "context", "l", "ur", "link", "string", "str", "browser", "https", "loader", "builder", "email", "nl", "org", "web", "row", "this", "domain", "u", "uri", "util", "rl", "document", "sb", "ref", "get", "impl", "Url", "mail", "ml", "log", "conn", "ssl", "resource", "module", "ul", "location", "base", "bel", "atl", "language", "ll", "mount", "relation", "service", "sl"], "connection": ["operation", "message", "channel", "generation", "collection", "library", "user", "Connection", "government", "function", "number", "office", "application", "open", "information", "sql", "subject", "database", "ion", "translation", "description", "session", "instance", "reference", "current", "termination", "division", "link", "network", "client", "directory", "record", "entry", "character", "system", "container", "row", "still", "object", "close", "internet", "uri", "created", "computer", "expression", "settings", "initial", "attribute", "handler", "command", "console", "position", "using", "statement", "engine", "controller", "condition", "conn", "resource", "server", "communication", "creation", "location", "pointer", "language", "response", "connect", "machine", "section", "relation", "volume"]}}
{"id1": "20208819", "id2": "20019847", "code1": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"hash": ["read", "message", "check", "value", "format", " fingerprint", " Hash", "sign", "update", "id", " sum", " hashing", "key", "run", "h", "uri", "dump", "password", "sha", "get", "Hash", "render", "sum", "print", "code", "name", "tag"], "input": ["message", "empty", "value", "accept", "out", "bit", "url", "select", "output", "lat", "request", "config", "current", "Input", "string", "image", "this", "source", "null", "q", "p", "in", "pattern", "char", "password", "command", "valid", "sequence", "text", "form", "buffer", "raw", " inputs", "active", "sample", "example", "data", "prefix", "hello"], "algorithm": ["assgorithm", "alabet", "arabet", "assometry", "argo", " Algo", "aloch", "Algorithm", "Aloch", "Algo", "validgo", "argorithm", "Alabet", "alphgorithm", " Aloch", "validabet", "algo", "arometry", "alphgo", " Alabet", "alometry", "assgo", "alphoch", " Algorithm", "assabet", "validgorithm", "validometry", "alphabet"], "dig": ["nd", "ng", " Dig", "cd", "dep", "plug", "dh", "find", "dash", "des", "del", "comm", "grad", "dir", "alg", "add", "md", "cong", "fin", "de", "rip", "fun", "df", "Dig", "dd", "ve", "div", "cr", "mod", "ind", "desc", "pers", "round", "dec", "enc", "dat", "g", "ld", "dim", "deg", "od", "bd", "rd", "d", "sd", "her", "db"], "result": ["pixel", "Result", "match", "user", "group", "display", "make", "out", "component", "r", "wrapper", "output", "description", "join", "currency", "current", "use", "mark", "rc", "product", "summary", "success", "true", "answer", "proc", "continue", "results", "reason", "next", "this", "term", "run", "br", "pair", "created", "mate", "up", "part", "report", "position", "ret", "dat", "render", "ral", "date", "total", "event", "print", "res", "create", "profile", "response", "comment", "prefix", "complete", "relation", "region"], "digest": ["dest", " digEST", "Digenge", "digEST", " digtest", "dested", "hasested", "definedested", "equgest", "displaytest", "digenge", "definedgest", "displayEST", "displayested", "diggest", " digenge", "hasest", "displayest", "displayist", "Digtest", "digested", "Digist", "Digest", "digtest", "definedest", "hasenge", "digist", "Diggest", "displaygest", " digate", "equested", "Digse", "Digate", "digate", "equse", "definedse", "dist", "DigEST", "Digested", "equest", "dgest", "digse", " digested", "hasate"], "hex": ["xf", "ex", "iter", "solid", "check", "com", "full", "ph", "ape", "nuts", "prop", " Hex", "des", "utf", "sv", "zip", "wh", "https", "tx", "html", "x", "key", "zero", "term", "color", "pex", "row", "hl", "serial", "h", "percent", "hw", "def", "comp", "char", "sh", "sex", "hist", "json", "exp", "alph", "ch", "form", "tex", "raw", "rex", "print", "index", "alpha", "oct"], "i": ["ij", "gi", "it", "id", "xi", "qi", "k", "info", "ci", "li", "\u0438", "z", "I", "m", "f", "di", "ai", "ix", "hi", "ki", "x", "bi", "ri", "ii", "n", "a", "multi", "mi", "uri", "ic", "batch", "io", "y", "ind", "im", "phi", "status", "iu", "g", "conv", "e", "ji", "me", "si", "print", "zi", "v", "pi", "ei", "ti", "cli", "j", "ui", "index", "ini", "ip"], "u": ["b", "user", "U", "us", "ou", "fu", "uu", "mu", "f", "su", "t", "au", "uni", "ut", "ur", "c", "ue", "tu", "q", "h", "bu", "num", "you", "pu", "util", "up", "eu", "nu", "lu", "uj", "uint", "uid", "cu", "unsigned", "iu", "uc", "um", "d", "hu", "v", "ul", "ui", "uv"], "highCount": ["topCount", "highAmount", " highcount", "hiCast", "highLength", "highCast", "highCode", "lowAmount", "topcount", " highPtr", " highCode", "higherCount", " highCast", " highLength", " highAmount", "hiFlag", "higherCast", "Highcount", "topCode", "higherAmount", "highercount", "highPtr", "hiCount", "hiLength", " highFlag", "lowLength", "HighCode", "highFlag", "HighCount", "lowcount", "topPtr", "HighPtr", "lowFlag", "highcount", "lowCast"], "lowCount": ["highCounter", "ownCold", "lowCold", "littleCount", "midSum", "lowSum", "highLength", "midCold", "ownCount", "midCountry", "lowCounter", "midLength", "midCount", "lowButton", "lowCountry", "littleCounter", " lowSum", "littleLength", " lowCold", "midButton", "highCountry", "midCounter", " lowButton", "lowLength", "ownButton", "ownSum", "littleCountry"]}}
{"id1": "10218878", "id2": "18974466", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeFromfile", "DecodeFromFile", "DecodeToFiles", "DecvertMAPfile", "DecvertMAPFiles", "DecodeMAPFiles", "DecodeToLog", "DecvertMapFile", "DecvertMAPLog", "DecodeToFile", "DecvertMapfile", "DecvertMapLog", "DecodeMAPLog", "DecodeMapFiles", "DecodeFromFiles", "DecodeMapfile", "DecodeMAPFile", "DecvertMapFiles", "DecodeFromLog", "DecvertMAPFile", "DecodeMapLog", "DecodeTofile", "DecodeMAPfile"], "mapFile": ["listFile", "mapFilename", "imageFilename", " mapFILE", "listPath", " mapStream", "listFILE", "mapPath", " mapPath", "cacheFile", "MapFile", "cacheFILE", "cachePath", "MapStream", "imagefile", "Mapfile", "imageStream", "imageFile", "mapStream", " mapfile", "mapfile", "mapFILE", "MapFilename", " mapFilename"], "outputFile": [" outputFilename", "OutputFile", "OutputFilename", "mapDir", "writeFile", " outputDir", "inputStream", "inputName", "writeStream", "inputDir", "mapName", "OutputPath", "outFile", "writeDir", "outDir", "writeName", "outputFilename", "OutputDir", "mapStream", "outputStream", " outputPath", "outputDir", "inputFile", "outputPath", "outputName", "outFilename", "outPath"], "magicKey": ["encryptedKey", "encryptedChar", "magicField", " magicCode", "MagicId", "magickey", "prefixValue", "magicCode", "magicValue", "MagicName", "encryptedkey", " magicName", " magicKEY", "anticKey", "magicKEY", " magicCounter", " magicId", " magickey", "magicCounter", "MagicKEY", "uniqueKey", "serialName", " magicField", "prefixCode", "prefixKey", "magicId", "uniqueCounter", " magicValue", "antickey", "anticChar", "MagicKey", "uniqueCode", "serialKey", "serialId", "encryptedField", "anticField", "serialKEY", "magicChar", " magicChar", "magicName", "prefixCounter", "uniqueValue"], "buffer": ["message", "block", "header", "iter", "check", "template", "bridge", "display", "flash", "cache", "binary", "database", "paste", "stroke", "frame", "program", "bone", "bo", "queue", "append", "vector", "memory", "window", "Buffer", "stream", "row", "page", "detail", "screen", "batch", "char", "index", "initial", "document", "attribute", "command", "sequence", "length", "black", "stack", "shape", "buf", "history", "pad", "total", "sum", "print", "code", "base", "sample", "buff", "mem", "phrase", "filter", "button", "table", "variable"], "nread": ["renwrite", " nRead", "rnREAD", "Nget", "rnRead", " nreadable", "nwrite", "nreadable", "NREAD", "ncget", "rnread", "ncRead", "rawreader", "maxget", "nadd", "ncread", "rawtry", "ncwrite", " nREAD", "renread", "ncreadable", "NRead", "nreader", "nRead", "maxRead", "rawread", "ntry", "Nread", "maxadd", "nREAD", "rnwrite", " nwrite", "rentry", " ntry", " nreader", "maxread", "Nadd", "rawwrite", "Nwrite", "nget", "renreader", "Nreadable", "ncadd"], "map": ["read", "block", "place", "com", "bridge", "parse", "ape", "make", "cache", "ace", "where", "open", "address", "mt", "MAP", "mp", "m", "config", "per", "file", "app", "aps", "down", "lock", "load", "memory", "window", "image", "maps", "mask", "collect", "mate", "batch", "manager", "up", "apping", "master", "cm", "op", "mod", "view", "set", "clear", "form", "meta", "apper", "pl", "ml", "con", "shape", "module", "co", "man", "pack", "mem", "pose", "mount", "ap", "table", "ip"], "output": ["put", "online", "ilo", "block", "format", "display", "net", "ou", "cache", "out", "secure", "input", "update", "write", "open", "oe", "file", "icon", "current", "network", "queue", "client", "web", "stream", "next", "object", "exit", "batch", "result", "console", "hidden", "target", "socket", "port", "log", "entity", "four", "print", "can", "o", "outer", "blue", "response", "latest", "auto", "other", "plain", "Output"], "i": ["b", "ami", "is", "ni", "us", "gi", "it", "qi", "id", "xi", "ci", "li", "ms", "I", "m", "t", "ai", "ix", "gu", "ri", "x", "bi", "ii", "n", "q", "u", "mi", "multi", "uri", "ic", "batch", "index", "fi", "y", "ind", "phi", "iu", "sim", "g", "ie", "ji", "spin", "si", "v", "ei", "pi", "span", "ti", "cli", "ish", "j", "ui", "di", "ini", "ip"]}}
{"id1": "10176678", "id2": "17193692", "code1": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "code2": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "label": 0, "substitutes": {"testLoadHttpGzipped": ["testLoadHttpGZips", "testLoadHttpgZips", "testLoadHttpGzipipped", "testLoadHttpGgzips", "testLoadHttpGzipips", "testLoadHttpGgzipped", "testLoadHttpGgzipping", "testLoadHttpGZipping", "testLoadHttpGzIP", "testLoadHttpGzipping", "testLoadHttpgzIP", "testLoadHttpgzipped", "testLoadHttpgzipping", "testLoadHttpGzipIP", "testLoadHttpGZipped", "testLoadHttpgZipped", "testLoadHttpgZipping", "testLoadHttpgzips", "testLoadHttpGzips", "testLoadHttpgZIP", "testLoadHttpGZIP", "testLoadHttpGgzIP", "testLoadHttpGzipipping"], "url": ["ls", "b", "path", "rect", "dl", "full", "format", "http", "URL", "fail", "lr", "id", "type", "sql", "options", "err", "config", "l", "ur", "link", "string", "str", "browser", "web", "html", "test", "key", "reason", "loc", "acl", "q", "host", "p", "mount", "uri", "pattern", "result", "msg", "state", "policy", "ref", "ret", "mail", "Url", "build", "ssl", "location", "base", "name", "ll", "rel", "pl", "status"], "loadingInfo": [" loadingNow", "loadingData", " loadingData", "readingStatus", "contentInfo", "contentData", "LoadingNow", "readingNow", "loadingStatus", "readingInfo", "readingInf", "loadingNow", "loadingInf", "LoadingInf", "LoadingStatus", "contentNow", " loadingInf", "LoadingData", " loadingStatus", "LoadingInfo", "contentInf"], "contentInputStream": ["contentInfoThread", "contentByteThread", "fileStreamStream", "contentReadForm", "contentIntStream", "fileStreamstream", "contentOutputSteam", "contentIntPoint", " contentOutputSteam", " contentInputSteam", " contentOutputPoint", "contentInfoSteam", "contentReadStream", " contentOutputForm", "fileStreamSteam", "contentInputPoint", "fileInputStream", "fileStreamThread", "contentStreamstream", "contentInputSteam", " contentInputForm", "contentIntForm", "contentStreamSteam", "fileInputSteam", "contentReadSteam", "contentByteSteam", " contentOutputStream", "contentOutputForm", "contentInputThread", "fileInputThread", "contentReadPoint", "contentByteStream", "contentStreamThread", "contentInputForm", "contentStreamStream", "contentOutputStream", "contentBytestream", " contentInputPoint", "contentInfoStream", "contentInputstream", "contentOutputPoint", "contentInfostream", "fileInputstream", "contentIntSteam"], "actual": ["full", "all", "produced", "array", "received", "false", "verified", "present", "older", "real", "current", "original", "true", "test", "virtual", "fake", " Actual", "currently", "affected", "actually", "ual", "tested", "act", "initial", "valid", "result", "old", "truth", "view", "reported", "Act", "raw", "total", "rendered", "approximately", "partial", "now", "latest", "other", "required"], "expected": ["supported", "nexpected", "announced", "ex", "anticipated", "or", "EXP", "produced", "received", "current", "always", "checked", "fake", "test", "confirmed", "erved", "tested", "pect", "ired", "pected", " expect", " expecting", "ed", "pects", "umed", "valid", "old", "want", "reported", "anted", "awaited", "planned", "allowed", "example", "required", " unexpected", "important", "ert"]}}
{"id1": "19494842", "id2": "2465747", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 1, "substitutes": {"callService": ["callServices", " callServices", "useservice", "callservice", "useService", " callQuery", "runServices", "callQuery", "useServices", "useQuery", "runservice", "runQuery", " callservice", "runService"], "url": ["ls", "b", "dl", "http", "URL", "r", "address", "file", "l", "ur", "link", "str", "gl", "browser", "client", "google", "web", "nl", "hl", "acl", "uri", "char", "sb", "get", "Url", "conn", "ssl", "oul", "resource", "ul", "bel", "base", "ll", "pl", "channel", "service", "sl"], "in": ["In", "b", "read", "iter", "check", "is", "ill", "on", "conf", "out", "input", "rin", "it", "all", "r", "IN", "inn", "reader", "and", "l", "inf", "bin", "again", "ri", "ins", "from", "inc", "mc", "en", "ic", "er", "io", "el", "oin", "din", "isin", "cin", "mn", "con", "i", "gin", " din", "sum", "inner"], "inputLine": ["parseLINE", "InputLINE", "contextRow", "parseFile", " inputL", "helloLINE", " inputLINE", "responseRow", "InputLine", "parseRow", "contextline", "outputline", " inputRow", "inputline", "inputLINE", "contextL", "helloRow", "outputLine", "InputRow", "Inputline", "responseline", "parseLine", "inputL", " inputline", "responseLine", "outputRow", "helloFile", "responseLINE", "inputFile", "inputRow", "contextLine", "outputL", " inputFile", "helloLine"], "buf": ["inv", "aux", "block", "uf", "gor", "mu", "cap", "comm", "fam", "pkg", "mk", "rb", "queue", "cb", "nm", "Buffer", "bg", "nom", "br", "cv", "img", "bu", "cmd", "hung", "area", "bag", "bar", "cam", "vet", "msg", "alph", "tab", "conv", "bh", "Buff", "buffer", "vec", "cf", "cur", "raf", "buff", "mem", "bed", "ob", "db", "pb"], "answer": ["reply", "message", "remember", "place", "review", "value", "install", "accept", "cache", "Answer", "ver", "search", "array", "address", "argument", "say", "about", "send", "again", "entry", "sn", "onse", "continue", "image", "exit", "ve", "ask", "archive", "offer", "version", "username", "result", "command", "sequence", "report", "option", "form", "interpret", "equ", "question", "print", "poll", "response", "replace", "answered", "channel"]}}
{"id1": "23296117", "id2": "810342", "code1": "    public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException {\n        String fullname = System.mapLibraryName(name);\n        String path = \"native/\" + sysName + \"/\" + fullname;\n        URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n        if (url == null) {\n            if (!warning) {\n                logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname });\n            }\n            return;\n        }\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        File targetFile = new File(getExtractionDir(), fullname);\n        OutputStream out = null;\n        try {\n            if (targetFile.exists()) {\n                long targetLastModified = targetFile.lastModified();\n                long sourceLastModified = conn.getLastModified();\n                if (targetLastModified + 1000 > sourceLastModified) {\n                    logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname);\n                    return;\n                }\n            }\n            out = new FileOutputStream(targetFile);\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n            in.close();\n            in = null;\n            out.close();\n            out = null;\n            targetFile.setLastModified(conn.getLastModified());\n        } catch (FileNotFoundException ex) {\n            if (ex.getMessage().contains(\"used by another process\")) {\n                return;\n            }\n            throw ex;\n        } finally {\n            if (load) {\n                System.load(targetFile.getAbsolutePath());\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n        logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile });\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"extractNativeLib": ["extractBaselib", "extractnativeLib", "extractNativeLibrary", "extractnativeFile", "extractBaseLib", "extractNativeFile", "extractInternalFile", "extractedNativelib", "extractedNativeFile", "extractedNativeLibrary", "extractInternalLib", "extractednativeLibrary", "extractInternalLibrary", "extractednativeLib", "extractednativeFile", "extractBaseLibrary", "extractednativelib", "extractBaseFile", "extractedNativeLib", "extractInternallib", "extractNativelib", "extractnativelib", "extractnativeLibrary"], "sysName": ["sysMap", "ysname", " sysNames", "sysN", "systemMap", " sysHandle", "sysHandle", "systemName", "systemNames", "sysType", "nsHandle", "synName", " sysname", "systemType", "synMap", "systemname", "synType", "synname", "sysname", "ysType", "ysNames", "nsName", "systemHandle", "ysName", "nsNames", "nsname", "sysNames", "ysMap", "ysN", "systemN", " sysN"], "name": ["alias", "nam", "title", "id", "type", "info", "filename", "ename", "file", "unknown", "s", "about", "string", "loader", "root", "nm", "Name", "word", "n", "run", "term", "source", "a", "version", "part", "default", "named", "mod", "ame", "NAME", "me", "names", "resource", "module", "create", "base", "data", "brain", "local"], "load": ["launch", "read", "library", "loaded", "loading", "check", "init", "install", "parse", "store", "cache", "fail", "register", "oad", "update", "write", "download", "save", "force", "warn", "sync", "Load", "loads", "use", "debug", "LOAD", "help", "link", "lock", "loader", "test", "include", "boot", "leaf", "label", "util", "dump", "require", "show", "remove", "hack", "enter", "hold", "create", "start", "play", "connect", "local", "call"], "warning": ["WARN", "message", "loading", "weak", "getting", "value", "function", "starting", "flash", "war", "warn", "force", "info", "ew", "error", "wa", "we", "help", "debug", "yellow", "pretty", "success", "web", "setting", "ping", "testing", "saving", "default", "fw", "console", "w", "writing", "Warning", "usage", "very", "aw", "only", "comment", "WARNING", "speaking"], "fullname": ["fullpath", "fullyame", " fullpath", "longn", "longname", "localName", "Fullvalue", "flatfilename", "longfilename", "shortName", "fullyvalue", "fullyNAME", "Fullfilename", "fulln", "fullnamed", "fullName", "localpath", "fullvalue", "fullynamed", "shortname", "flatname", "flatName", " fullfilename", "Fullpath", " fullame", "localfilename", "FullName", "fullfilename", "longnamed", "flatpath", "longpath", "shortn", "fullyName", "Fullname", "fullNAME", "longNAME", " fullName", "fullypath", "localname", "fullyname", " fullnamed", "shortpath", "longName", "fullame", "longame", "shortNAME", " fulln", "longvalue"], "path": ["pt", "Path", "transform", "th", "full", "where", "prop", "filename", "file", "dir", "php", "link", "string", "trace", "test", "PATH", "key", "root", "image", "route", "patch", "this", "near", "p", "pro", "uri", "def", "cmd", "pattern", "up", "spec", "exp", "w", "ref", "ath", "hex", "chain", "raw", "partial", "pointer", "prefix", "local"], "url": ["ls", "user", "rect", "dl", "cert", "http", "URL", "lr", "open", "f", "r", "li", "err", "norm", "abs", "l", "ur", "gl", "link", "fl", "https", "str", "job", "client", "loader", "org", "web", "nl", "req", "loc", "lb", "host", "addr", "util", "rl", "xml", "socket", "ret", "impl", "build", "Url", "con", "mb", "ssl", "raw", "resource", "bel", "res", "atl", "rel", "ll", "mount", "channel", "sl"], "conn": ["ls", "obj", "Conn", "cert", "ctx", "conf", "sql", "open", "comm", "nt", "sync", "col", "config", "reg", "pc", "exec", "str", "ctr", "client", "cb", "cc", "c", "mc", "close", "cp", "cn", "ct", "cmd", "resp", "addr", "canon", "handle", "cm", "nc", "cmp", "msg", "iw", "socket", "ch", "conv", "enc", "serv", "con", "jp", "ssl", "connection", "cont", "cf", "res", "cur", "ws", "connect", "pg", "pas"], "in": ["In", "read", "iter", "is", "init", "or", "net", "on", "input", "rin", "it", "all", "info", "r", "m", "ain", "IN", "ln", "inn", "inside", "inf", "bin", "ai", "again", "ar", "ins", "n", "source", "from", "inc", "mc", "en", "ic", "io", "el", "ind", "oin", "st", "din", "mm", "re", "nin", "cin", "con", "i", "gin", " din", "serv", "inner", "ry", "ini"], "targetFile": ["saveEntity", " targetPage", " targetEntity", "targetEntity", " targetFilename", "argetLog", "targetPage", "targetLog", "toPage", " targetPath", "targetFilename", " targetfile", "TargetFull", "TargetLog", "targetfile", "targetFolder", " targetFolder", "tofile", "sourceFilename", "Targetfile", "sourcefile", "targetFull", "saveFile", "proxyFolder", "topfile", "TargetFILE", "thisFile", "sourceFile", "topFilename", "argetFILE", "TargetPage", "thisPage", "toFilename", "argetFilename", " targetFILE", "saveFILE", "toFile", "proxyFILE", "saveFolder", "proxyFile", "TargetFilename", "targetPath", "TargetFile", "sourcePage", " targetLog", "thisPath", "argetfile", "argetFull", " targetFull", "targetFILE", "topFile", "sourcePath", "argetFile", "thisfile", "TargetPath", "proxyEntity", "topPath"], "out": ["conf", "err", "t", "boot", "ins", "p", "ne", "outs", "ch", "writer", "OU", "mit", "log", "con", "co", "sum", "v", "o", "auto", "other", "ot", "inv", "obj", "user", "ex", "init", "or", "ou", "all", "write", "nt", "ion", "again", "c", "end", "os", "cn", "result", "conv", "chain", "inner", "outer", "pool", "ns", "check", "at", "net", "oe", "cos", "pos", "Out", "n", "up", "io", "w", "aos", "timeout", "comment", "OUT", "cache", "it", "output", "oss", "bin", "client", "one", "null", "cmd", "to", "flush", "no", "buf", "can"], "targetLastModified": ["targetLastmodify", "targetLastLoadify", "targetLastLoadured", "targetLastQualed", "targetlastModifier", "targetMaxReified", "targetLastModured", "targetlastModified", "targetlastQualmodified", "targetMaxModify", "targetLastReured", "targetLastReified", "targetLastReify", "targetLastMsifier", "targetMaxReifier", "targetLastQualmodified", "targetMaxModured", "targetLastModed", "targetLastQualifier", "targetMaxReify", "targetlastQualified", "targetLastMsed", "targetLastModmodified", "targetLastQualified", "targetlastModed", "targetMaxReured", "targetlastQualifier", "targetLastModify", "targetLastModifier", "targetLastmodifier", "targetLastReifier", "targetLastMsmodified", "targetMaxModifier", "targetlastModmodified", "targetLastmodified", "targetlastQualed", "targetLastmodured", "targetLastMsified", "targetLastLoadified", "targetMaxModified", "targetLastLoadifier"], "sourceLastModified": ["sourceLastmodified", "sourceLastModTime", "sourceLastTimed", "sourcelastTrified", "sourceLastModed", "sourceLastMsTime", "sourceLastmodification", "sourceLastTrification", "sourceLastModification", "sourceLastTimmodified", "sourcelastTrification", "sourceLastMsification", "sourceLastTimified", "sourcelastTrTime", "sourceLastModsed", "sourceLastModmodified", "sourcelastTrify", "sourceLastModify", "sourceLastTrified", "sourcelastModify", "sourceLastTimification", "sourceLastmodTime", "sourceLastModsmodified", "sourceLastmodify", "sourceLastTrTime", "sourcelastModification", "sourcelastModified", "sourceLastMsified", "sourcelastModTime", "sourceLastTrify", "sourceLastMsify", "sourceLastModsified", "sourceLastModsification"], "len": ["ls", "bytes", "lan", "dl", "all", "cap", "nt", "ln", "t", "count", "l", "str", "fl", "pos", "L", "size", "nl", "fin", "fun", "n", "val", "lim", "le", "hl", "end", "en", "num", "coll", "el", "lf", "length", "mat", "seq", "Len", "ld", "no", "buf", "vec", "pad", "syn", "elt", "ll", "pl"]}}
{"id1": "17296916", "id2": "3514286", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"logging": ["debugStorage", "Logging", "debugging", "Loging", "logStorage", " logger", "debuging", "logger", "LogStorage", "debugger", "Logger", " logStorage", " loging", "loging"], "wrap": ["xf", "message", "ad", "transform", "read", "format", "parse", "store", "grow", "find", "ew", "force", "wrapper", "wra", "wa", "ow", "use", "zip", "add", "link", "safe", "python", "web", "root", "wx", "x", "window", "word", "rap", "gate", "W", "box", "handle", "work", "sp", " wrapped", "w", "form", " wrapper", "get", "build", "chain", "me", "shape", "pad", "aw", "nw", "sw", "pack", "create", "inter", "start", "ws", "wind", "wire", "reset", "we"], "buffer": ["reply", "message", "library", "block", "header", "iter", "template", "bridge", "display", "note", "flash", "cache", "store", "binary", "face", "wrapper", "output", "database", "reference", "surface", "frame", "append", "trace", "queue", "bo", "directory", "builder", "size", "memory", "Buffer", "window", "row", "word", "quote", "screen", "batch", "flag", "layer", "document", "attribute", "bar", "command", "sequence", "view", "console", "body", "report", "position", "writer", "bb", "line", "buf", "complete", "reset", "print", "base", "buff", "profile", "ob", "phrase", "button", "table", "pb"], "encoding": ["cging", "cryption", "ecoding", "enoding", "encoded", "codryption", "Encaling", "ecoder", "encoder", "enlanguage", "coder", "Encoder", "enoder", "enging", "enclanguage", "clanguage", "enumlanguage", "Encoding", "enryption", "caling", "enaling", "cododer", "enumoding", "enoded", "enumoder", "Encryption", "encryption", "encaling", "encging", "ecoded", "enumging", "cododed", "coding", "cododing", "ecryption"], "getEncoding": ["getEncryption", " getEncling", "getExpryption", "getExpoding", "getencination", "getEnression", "getEncling", "getEnryption", "getEncression", "getencression", "getEncging", " getEncryption", " getEncination", "getExpging", "getEnination", " getEnling", "getencging", " getEncging", "getOrigoding", " getEnryption", "getencoding", "getOrigling", " getEnging", "getencling", " getEnoding", "getExpression", "getencryption", "getOrigryption", "getEnling", " getEnression", " getEncression", "getEnging", "getEnoding", " getEnination", "getOrigination", "getEncination"], "headers": ["header", "pres", "modules", "authors", "chains", "keys", "tags", "builders", "writers", "users", "properties", "head", "params", "comments", "ters", "boxes", "reports", "pins", "heads", "caps", "groups", "checks", "rs", "ilers", "weights", "limits", "frames", "ppers", "images", "ports", "ctors", "codes", "styles", "fields", "relations", "holders", "members", "names", "drivers", "ers", "objects", "ids", "terms", "values", "blocks"], "is": ["nis", "\u00eds", "or", "us", "isl", "was", "fs", "dis", "ys", "iso", "ms", "isd", "bis", "tis", "IS", "ist", "isc", "lis", "as", "ri", "ists", "does", "ins", "iss", "os", "ris", "ic", "in", "osi", "isf", "Is", "bs", "sys", "isi", "its", "has", "isin", "ios", "ais", "i", "sis", "si", "mis", "isa", "ois", "iris", "ui", "obs", "ims", "ip"], "bos": ["cs", "oos", "dos", "bytes", "pod", "ts", "ones", "fs", "oids", "ys", "des", "ms", "ows", "bas", "bis", "banks", "los", "ols", "cos", "tis", "bo", "oss", "bin", "bes", "bi", "uds", "tes", "os", "bits", "tops", "jas", "bs", "ods", "oops", "ubis", "ses", "sys", "bot", "isi", "soc", "uts", "windows", "lets", "js", "ios", "bh", "bones", "ps", "stats", "eros", "nos", "aos", "fits", "ui", "obs", "ots", "boards"], "e": ["ex", "r", "f", "err", "error", "oe", "m", "t", "ate", "se", "ae", "x", "de", "c", "n", "le", "a", "p", "exc", "en", "h", "ed", "er", "eeee", "ne", "ge", "E", "ie", "es", "g", "re", "me", "i", "d", "v", "o", "ev", "ee"]}}
{"id1": "17786231", "id2": "19322941", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"downloadFile": ["getContent", "transferContent", "loadResource", "downloadContent", "loadContent", "transferfile", "transferFile", "loadFile", "downloadfile", "loadfile", "downloadResource", "getFile", "transferResource", "getResource", "getfile"], "downloadUrl": ["downloadURL", "linkLink", "linkUrl", "reportWar", "installUr", "transferURL", "transferUrl", "DownloadWar", "DownloadURL", "downloadUr", "DownloadUrl", " downloadLink", "transferUr", "installLink", "linkUr", "reportURL", "DownloadUr", "installURL", " downloadURL", " downloadUr", "installUrl", "transferWar", "linkURL", "downloadLink", "reportUr", "reportUrl", "downloadWar"], "destinationFile": ["destarationDir", "destificationDir", "destiningDir", "destarationPath", "destarationSourceFile", " destificationSourceFile", "coordinationFolder", " destificationFile", " destificationDir", "destacementfile", "destiningFile", "destinationDir", "coordacementFile", "coordacementName", "destinationfile", "destinationPath", "destacementName", "destinationSourceFile", " destinationDir", "destinatedfile", " destinationSourceFile", "destiningPath", " destificationPath", "destinationName", " destinationPath", "destacementFolder", "destificationPath", "destificationFile", "destiningSourceFile", "destinatedFolder", "destinatedFile", "destarationfile", "coordinationfile", "coordacementfile", "destarationFolder", "coordinationFile", "destacementFile", "coordacementFolder", "destinationFolder", "coordinationName", "destinatedName", "destarationName", "destificationSourceFile", "destarationFile"], "client": ["collection", "template", "net", "http", "cache", "tc", "url", "query", "force", "ci", "Client", "api", "context", "wrapper", "request", "phone", "network", "https", "google", "cl", "system", "key", "uri", "io", "cm", "console", "city", "remote", "conn", "connection", "co", "server", "resource", "contact", "cli", "channel", "service", "pool", "call"], "httpGet": ["ttpget", " httpGET", "HttpPut", "ttpPut", "HttpGet", " httpQuery", "httpGET", "httpget", "utilGET", "HttpGET", "utilGet", "httpPut", "ttpGet", " httpPut", "hget", "HttpQuery", "httpQuery", "utilPut", "hPut", "utilQuery", "hGet", "Httpget"], "outputFile": ["OutputFile", "outStream", "outPlace", "betaFILE", "outPoint", "outputPlace", "newPlace", "newStream", "newFile", "OutputPlace", "regionStream", "outputFILE", "tempStream", "outFile", "seeFile", "regionFILE", "tempFile", "newPoint", "OutputStream", "outputPoint", "seeFILE", " outputFILE", "betaFile", "regionFile", "OutputPoint", "tempFILE"], "outputStream": ["printSteam", "OutputView", "inputStreamer", "coinStream", "coinStyle", "outputStreamer", " outputStyle", "coinStreamer", "inputForm", " outputStreamer", "putStyle", " outputView", "printStream", "putSteam", "responseSteam", "inputStyle", "outputForm", "responseStyle", "printForm", " outputSteam", "OutputSteam", "outputStyle", "responseStreamer", "OutputStyle", "OutputStream", "outputstream", "putStreamer", "coinSteam", "outputSteam", "inputView", "inputSteam", "responseStream", "putStream", "printFile", "outputView", "inputFile", " outputForm", "inputstream", "Outputstream", " outputstream"], "response": ["reply", "message", "block", "http", "application", "output", "description", "request", "answer", "onse", "entry", "image", "given", "still", "page", "details", "resp", "version", "initial", "document", "attribute", "result", "json", "body", "post", "remote", "connection", "content", "resource", "yes", "server", "example", "Response", "data", "status", "service"], "entity": ["obj", "person", "message", "ilo", "group", "note", "cache", "secure", "component", "type", "info", "associated", "iso", "translation", "error", "instance", "encrypted", "properties", "Entity", "entry", "email", "existent", "peer", "image", "quote", "detail", "details", "ent", "object", "pe", "xml", "document", "el", "unique", "valid", "json", "existing", "attribute", "body", "result", "ity", "enc", "e", "line", "buffer", "account", "event", "content", "resource", "metadata", "total", "security", "profile", "data", "name", "comment", "status", "member", "local", "activity"], "inputStream": ["inputStreamer", "sourceSteam", " inputSteam", "thisSteam", "sourcestream", "sourceStream", " inputForm", "readstream", "activeStream", "evalStreamer", "InputForm", "imageSteam", "activeSteam", "imageView", "inputForm", "activeView", " inputStreamer", "upstream", "thisStyle", "upForm", "readForm", "Inputstream", " inputView", "inputStyle", "outputForm", "evalSteam", "readStream", "sourceView", "imageStream", "evalStream", "InputStream", "outputStyle", "upStream", "thisForm", " inputstream", "outputstream", "upSteam", "activeStreamer", "thisStream", "outputSteam", "imagestream", "inputSteam", "inputView", "evalView", "outputView", "inputstream", "InputSteam", "InputStyle", "readSteam"], "callback": ["alias", "library", "message", "binding", "soon", "closure", "lambda", "function", "display", "creator", "update", "wrapper", "func", "consumer", "actor", "back", "parser", "cell", "browser", "job", "cb", "loader", "builder", "cc", "continue", "window", "facebook", "gc", "hook", "manager", "pattern", "processor", "handler", "token", "policy", "CB", "finder", "Callback", "background", "backs", "sound", "filter", "call"], "copiedLength": ["copyLength", "CopiedDuration", "copedLength", "CopedSize", "copiedLen", "CopedNumber", "copifiedLength", "CopedLen", "CopiedNumber", "copedDuration", "copifiedLen", "copifiedNumber", "copiedNumber", "CopiedSize", "copedLen", "copyDuration", "CopedDuration", "copedSize", "copIEDNumber", "copifiedDuration", "CopiedLength", "copIEDLength", "copiedSize", "copiedDuration", "CopiedLen", "copIEDDuration", "copedNumber", "CopedLength", "copifiedSize", "copySize", "copyLen"], "percentage": ["capaging", "Percentage", "capale", "percentages", "CENTages", "percentale", "percentaging", "Percentages", "capages", "Percenture", "CENTage", " percentages", " percentale", "percenture", "CENTure", " percenture", " percentaging", "Percentale", "Percentaging", "capage"]}}
{"id1": "17475530", "id2": "8490297", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkFromimage", "testAddLinkForimage", "testAddLinkFromImage", "testAddLinkToimage", "testAddLinkFromPicture", "testAddLinkstoImages", "testAddLinkForPicture", "testAddLinkFromImages", "testAddLinksToImage", "testAddLinkstoPicture", "testAddLinktoImage", "testAddLinktoimage", "testAddLinksToimage", "testAddLinksToImages", "testAddLinkToImages", "testAddLinkForImage", "testAddLinkstoImage", "testAddLinktoImages", "testAddLinkstoimage", "testAddLinksToPicture", "testAddLinkForImages", "testAddLinkToPicture", "testAddLinktoPicture"], "in": ["In", "ex", "check", "is", "init", "at", "or", "on", "out", "input", "it", "rin", "al", "all", "r", "info", "k", "sein", "file", "ma", "IN", "m", "inn", "and", "add", "inside", "bin", "include", "vin", "ins", "one", "source", "from", "inc", "mc", "en", "ini", "ed", "up", "er", "password", "ind", "set", "show", "din", "isin", "by", "get", "re", "nin", "cin", "i", "gin", " din", "sum", "inner", "v", "o", "pi", "doc"]}}
{"id1": "17729554", "id2": "18696387", "code1": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"clonarFichero": ["clonarfichero", "clonarfricher", "clonarFicher", "clonarFicoio", "clonarFricher", "clonarFicros", "clonarFicohero", "clonarFICio", "clonarFricio", "clonarFICros", "clonarficher", "clonarFicoros", "clonarFicio", "clonarFicoher", "clonarFrichero", "clonarficio", "clonarFICher", "clonarfrichero", "clonarFricros", "clonarFIChero", "clonarficros", "clonarfricio", "clonarfricros"], "rutaFicheroOrigen": ["rutaFicheroOrigEN", "rutaFiceraOrigener", "rutaFicheroorigEN", "rutaFiceraOriginEn", "rutaFicheroOrigener", "rutaFicheroOriginEN", "rutaFicheroOriginalener", "rutaFicherOrigens", "rutaFiceraOrigen", "rutaFicheroOriginEn", "rutaFicherorigener", "rutaFicheroorigin", "rutaFicherorigens", "rutaFicheroOrigens", "rutaFicherOrigen", "rutaFicheroOriginalEn", "rutaFicheroorigener", "rutaFicheroOrigin", "rutaFicheroOriginener", "rutaFiceraOrigEn", "rutaFicheroorigen", "rutaFicheroOriginalen", "rutaFicherOrigEN", "rutaFicheroOriginalin", "rutaFiceraOriginen", "rutaFicheroOriginalens", "rutaFicherorigEN", "rutaFiceraOriginener", "rutaFicherorigin", "rutaFicheroOriginen", "rutaFiceraOriginEN", "rutaFicheroorigEn", "rutaFicheroOrigEn", "rutaFicherorigen", "rutaFicherOrigener", "rutaFicherOrigin", "rutaFicheroorigens", "rutaFiceraOrigEN", "rutaFicheroOriginalEN"], "rutaFicheroDestino": ["rutaFicherOriginos", "rutaFicherDestino", "rutaFicherOrigino", "rutaFicheroDestINO", "rutaFichetDestino", "rutaFichetDestinos", "rutaFicheroDestinos", "rutaFicherDestINO", "rutaFicheroDestin", "rutaFicheroDestoso", "rutaFicheroOrigino", "rutaFicherodestin", "rutaFichetOrigin", "rutaFichetDestin", "rutaFicheroStinos", "rutaFicheroOrigin", "rutaFicherDestin", "rutaFicheroStino", "rutaFicheroOrigoso", "rutaFichetDestoso", "rutaFicherOrigINO", "rutaFichetOrigino", "rutaFicheroStin", "rutaFicherodestino", "rutaFicherodestinos", "rutaFicherDestinos", "rutaFicheroStoso", "rutaFicheroOrigINO", "rutaFicherodestINO", "rutaFichetOriginos", "rutaFichetOrigoso", "rutaFicheroOriginos", "rutaFicherOrigin"], "salida": ["salisa", " salisa", "SalIDA", "salIDA", "alIDA", "salidate", "alaria", " salido", "salaria", " salidate", "palidate", "salado", "salido", "alida", "palido", "Salado", "Salida", " salado", "Salidate", "palida", " salaria", "Salisa", " salid", " salIDA", "alado", "alido", "alisa", "palid", "Salaria", "Salido", "Salid", "salid"], "canalOrigen": ["canalOriginalEN", "canalOriginalened", "canALOriginen", "canallorigened", "canallorigen", "canalOriginEN", "canALOrigens", "canalOrigener", "canalorigEN", "canallOrigened", "canalOriginem", "canalOriginalener", "canallorigens", "canalOriginalen", "canalOrigem", "canalorigener", "canallOrigen", "canallorigEN", "canALOriginem", "canALOriginener", "canalorigens", "canalOrigens", "canalOriginalem", "canalOriginalens", "canalOrigened", "canalOrigEN", "canalorigened", "canALOrigen", "canallOrigens", "canALOrigener", "canalorigen", "canallorigener", "canALOriginens", "canalOriginens", "canalorigem", "canALOrigem", "canalOriginen", "canallOrigener", "canalOriginener", "canallOrigEN"], "canalDestino": ["canalEndina", "canalOrigination", "canalDestINO", "canalsdestina", "canalDestina", "canalDestination", "canalEndINO", "canalsDestino", "candalOrigino", "candalDestination", "candalOriginos", "canalDestinos", "canalEndino", "canalOrigINO", "canalStination", "candalOrigination", "canalsDestination", "canalsdestINO", "canalsDestINO", "canalsdestination", "canaldestinos", "candalOrigINO", "canalOrigino", "canalEndination", "canaldestino", "canaldestination", "canalStino", "canalsDestina", "canaldestINO", "canaldestina", "candalDestino", "candalDestINO", "canalStINO", "candalDestinos", "canalsdestino", "canalStinos", "canalOriginos"], "estado": ["stado", "cestilo", " estaban", "cestado", " gestada", "estata", "estaded", "gestaban", " estata", "astao", "cestada", "gestada", " estido", "astido", " estados", "testata", " gestados", "astada", " estilo", "stada", "estido", "stao", "Estados", "estaban", "estilo", "testada", "stido", "cestaban", "astado", "Estada", " gestaded", "ostada", " estada", "ostado", " estao", "testado", " estaded", "testido", "Estaded", "ostido", "Estado", "estao", "ostata", " gestado", "estada", "gestilo", "estados", "gestado"]}}
{"id1": "6009527", "id2": "13499897", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadAttachention", "doFinishLoadAssention", "doFinishLoadAttachachment", "doFinishLoadAttention", "doFinishLoadAssachment", "doFinishShowAttached", "doFinishShowDetached", "doFinishShowDetachment", "doFinishShowAttachment", "doFinishLoadDetention", "doFinishLoadAttached", "doFinishLoadDetached", "doFinishLoadAssached", "doFinishLoadDetachment", "doFinishShowAttention", "doFinishLoadAttachached", "doFinishShowDetention"], "attachmentId": ["detachedid", "ATTachmentKey", "attgmentKey", "attachmentName", "atutationName", "attachmentid", "attociationid", "detachedKey", "attentionById", "attachmentKey", "attociationKey", "detachedId", "attentionId", "attagramKey", "detachmentid", "attentionName", "attgmentid", "attutationId", "ATTachmentid", "detachmentKey", "attachedById", "atachmentId", "attagramId", "ATTociationKey", "attagramById", "attagramid", "ATTociationById", "atutationId", "attachedid", "atachmentById", "attociationId", "ATTachmentId", "attachedKey", "attociationById", "atachmentName", "attociationID", "attutationName", "attutationID", "attachmentById", "attachedId", "ATTociationId", "attachmentID", "ATTachmentById", "attentionID", "detachmentId", "atutationById", "attociationName", "attgmentId", "atutationID", "ATTociationid", "attutationById", "atachmentID"], "attachment": ["detached", "contached", "addociation", "ATTention", "attachachment", "attached", "attment", "detment", "attachaching", " attached", "contachment", "assaching", "attaching", "addached", "assachment", "ATTached", "assached", "detachment", "detacher", "attachociation", "ATTacher", "attachacher", "attention", "attociation", "addaching", "contacher", "association", "attachached", "addachment", " attment", "assacher", "attacher", "ATTachment", "attachention", " attacher", "contment", "assention"], "attachmentUri": ["attentionUrid", "attentionUri", "attentionUtpi", "attachmentuRI", "attachableOuri", "attachmentOri", "attachableOURI", "attachmentOURI", "attachmentUtri", "attachableUURI", "attentionUpi", "attachmenturi", "attachmentOpi", "attachableOri", "attachmenturid", "attachmentUtrid", "attachmentUtRI", "attachmentUnri", "attachmentURI", "attachableUuri", "attachmentUpi", "attachmentTpi", "attentionUtrid", "attachableOpi", "attachmentTuri", "attachmentUURI", "attentionURI", "attachmentUnpi", "attachmentUtpi", "attentionUtRI", "attachableUri", "attachmentupi", "attachmentUnuri", "attachmentTri", "attachmentUuri", "attachmentUrid", "attachmentOuri", "attachmentTURI", "attentionUtri", "attachableUpi", "attachmentUnURI"], "contentUri": ["ContentUris", "contentUtres", "ContentUsrid", "ContentUsuri", "contentuuri", "ContentUsris", "contentUsris", "contentURRI", "messageUtri", "contentURri", "resourceURres", "contenturi", "contentUtri", "contentUtric", "contentuRI", "contentUsuri", "contentUnrid", "contentURuri", "contentUruri", "resourceURI", "contentUriri", "contentSiri", "contentUrri", "contentUrric", "contentSric", "messageUri", "contentUrid", "contentUtrid", "messageUtiri", "contentURres", "contentURI", "ContentUuri", "messageUturi", "contentUturi", "contentures", "contentUris", "resourceUri", "contentUnuri", "resourceURRI", "contentUnris", "contentSuri", "contentUtiri", "resourceURuri", "contentUric", "contentUtRI", "contentUsrid", "resourceURri", "messageUric", "resourceUuri", "resourceUres", "ContentUri", "messageUiri", "messageUuri", "contentSri", "contentUsri", "contentUuri", "contentUnri", "contentUiri", "messageUtric", "contentUres", "ContentUsri", "ContentUrid", "contentUtris"], "file": ["user", "path", "message", "header", "template", "init", "files", "format", "type", "save", "f", "filename", "output", "media", "fp", "dir", "zip", "link", "rule", "image", "source", "le", "page", "picture", "from", "h", "ile", "to", "angle", "tree", "il", "document", "work", "result", "folder", "ca", "FILE", "port", "upload", "entity", "disk", "line", "buffer", "sf", "resource", "content", "local", "base", "create", "play", "name", "db", "channel", "File", "pool", "table"], "in": ["In", "read", "is", "on", "input", "rin", "it", "sql", "al", "ain", "IN", "inn", "and", "l", "inside", "inf", "bin", "ar", " IN", "ins", "source", "from", "inc", "en", "mi", "ic", "up", "io", "ind", "body", "din", "isin", "cin", "con", "i", "gin", " din", "inner", "play", "ini"], "out": ["b", "obj", "put", "ex", "check", "net", "OUT", "ou", "it", "all", "write", "output", "nt", "stable", "oss", "client", "Out", "n", "null", "os", "screen", "to", "flush", "ao", "io", "sys", "outs", "w", "writer", "conv", "OU", "g", "serv", "con", "i", "co", "print", "can", "aos", "auto", "o", "v", "res", "outer"], "intent": ["inv", "activate", "ment", "init", "device", "voice", "automatic", "spirit", "query", "widget", "context", "agent", "express", "verbal", "concept", "ink", "animate", "intention", "wordpress", "entry", "continue", "window", "term", "inst", "venture", "q", "ent", "action", "Activity", "ic", "act", "skill", "method", "alert", "ence", "xml", "initial", "asso", " Intent", "json", "text", "ant", "statement", "prom", "ident", "entity", "condition", "event", "displayText", "communication", "man", "phrase", "complete", "activation", "service", "activity"]}}
{"id1": "8024375", "id2": "21999120", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomCID", "getRandomGID", "getRandomGid", "getRandUid", "getRandomUid", "getRandUUID", "getRandomUUID", "getRandomSid", "getRandUID", "getRandomCid", "getRandomCUID", "getRandGID", "getRandomUID", "getRandomCuid", "getRandomGuid", "getRandomUuid", "getRandGUID", "getRandomSID", "getRandUuid", "getRandomSuid", "getRandGuid", "getRandGid", "getRandomSUID"], "secure": ["weak", "dirty", "quiet", "http", "force", "sync", " securely", "encrypted", "sec", "sr", "protect", "stable", "pretty", "https", "safe", "google", "client", "confirmed", "strong", "prime", "trust", "sys", "sensitive", "clear", "ie", "nice", "ssl", "active", "server", "security", " Secure", "status", "Secure", "service", "secret", " insecure"], "md5": ["dig3", " md6", "MD3", "md4", "md512", "MD4", "digle", "sha512", "MD6", "mdle", "sha5", "metadata3", "md3", " md3", "metadata5", "sha2", "MD2", "md6", "MD5", "MDle", "sha6", "MD512", " md512", "md2", " md4", " mdle", "metadata2", "sha3", "dig5", " md45", "md45", "metadata45", " md2", "MD45", "dig4"], "sbValueBeforeMD5": ["sbValueBeforeMP5", "sbValueWithoutMD5", "sbValueBeforeLM2", "sbValueAfterNDson", "sbValueBeforeMD2", "sbValueBeforeMS1", "sbValueBeforeDD5", "sbValueBeforemd5", "sbValueBeforeMAC2", "sbValueBeforemd2", "sbValueBeforeMDFound", "sbValueBeforeMTson", "sbValueBeforeND5", "sbValueBeforeNDson", "sbValueWithoutDD2", "sbValueBeforeDD65", "sbValueBeforeAMDson", "sbValueAfterND4", "sbValueWithoutDD5", "sbValueAfterMD5", "sbValueWithoutDD512", "sbValueWithoutMD512", "sbValueBeforeIM1", "sbValueAfterND5", "sbValueBeforeDD2", "sbValueBeforeAMDFound", "sbValueBeforeMT2", "sbValueBeforeMS2", "sbValueBeforeMD4", "sbValueBeforeOLD5", "sbValueBeforeMPLeft", "sbValueBeforeMD3", "sbValueBeforeDS5", "sbValueBeforeMACFive", "sbValueBeforeND2", "sbValueAfterMD4", "sbValueAfterMDFive", "sbValueBeforeSMson", "sbValueBeforeOLD512", "sbValueAfterMDLeft", "sbValueBeforeIM5", "sbValueBeforeSM2", "sbValueBeforeMAC65", "sbValueBeforeOLD2", "sbValueBeforeMT5", "sbValueBeforeMOD1", "sbValueBeforeMS3", "sbValueBeforeDS512", "sbValueBeforeSM4", "sbValueBeforeIMLeft", "sbValueBeforeDD512", "sbValueBeforeMDson", "sbValueBeforeMT4", "sbValueAfterMD2", "sbValueAfterMD65", "sbValueAfterMDson", "sbValueBeforeDDFive", "sbValueBeforeMS5", "sbValueBeforeMOD2", "sbValueBeforeMDLeft", "sbValueBeforeMP1", "sbValueBeforeMOD5", "sbValueBeforeSM5", "sbValueAfterND2", "sbValueBeforeMD65", "sbValueAfterMD1", "sbValueWithoutMD2", "sbValueBeforeAMD5", "sbValueBeforeND4", "sbValueBeforeDS2", "sbValueBeforeMP2", "sbValueBeforeLM5", "sbValueBeforeMDFive", "sbValueBeforeMD1", "sbValueBeforeMOD3", "sbValueBeforeMAC5", "sbValueBeforeIM2", "sbValueBeforeLM512", "sbValueBeforeMD512", "sbValueAfterMDFound", "sbValueBeforemdFound", "sbValueAfterMD3", "sbValueBeforeAMD2", "sbValueBeforemdson"], "time": ["user", "when", "counter", "value", "TIME", "ts", "id", "runtime", "times", "etime", "current", "t", "frame", "hour", "age", "client", "top", "size", "system", "ty", "estamp", "year", "tim", "est", "work", "clock", "set", "length", "Time", "race", "ime", "duration", "timer", "history", "date", "total", "now", "start", "timeout", "name", "rate", "today"], "rand": ["inv", "nd", "ng", "range", "dr", "mid", "init", "id", "rss", "r", "red", "z", "pick", "grad", "nt", "std", "reg", "and", "roll", "seed", "rc", "rt", "gt", "rad", "pid", "random", "rank", "did", "serial", "sid", "rid", "sam", "cr", "uid", "rev", "round", "dist", "frac", "rot", "rh", "rd", "quant", "res", "sample", "hash", "gz", "Rand", "rate", "gen"], "valueBeforeMD5": ["valueBeforeMOD2", "valueAfterND7", "valueBeforeMD3", "valueAfterMD7", "valueBeforeMC5", "valueBeforeMD25", "valueAfterMD2", "valueBeforeMOD3", "valueBeforeMC7", "valueBeforeMT25", "valueBeforeMD7", "valueAfterND2", "valueBeforeMT5", "valueBeforeND3", "valueBeforeMT3", "valueAfterND5", "valueBeforeMC3", "valueBeforeMT2", "valueAfterMD3", "valueBeforeMOD7", "valueBeforeMD2", "valueBeforeMC2", "valueBeforeMC25", "valueBeforeND7", "valueBeforeND2", "valueAfterND3", "valueBeforeMOD5", "valueBeforeND5"], "array": ["external", "range", "collection", "storage", "number", "audio", "Array", "binary", "address", "ary", "list", "instance", "map", "ash", "app", "vector", "record", "our", "feature", "image", "row", "random", "av", "a", "pair", "object", "share", "arr", "batch", "angle", "expression", "area", "archive", "sh", "attribute", "length", "arrow", "RAY", "buffer", "ray", "raw", "sample", "hash", "data", "rays", "response", "angular", " Array", "atomic", "var"], "sb": ["rob", "sth", "abb", "ib", "bp", "gb", "bf", "sv", "sr", "bis", "rb", "SB", "bps", "sq", "cb", "bg", "erb", "lb", "gc", "bs", "sh", "obs", "zb", "soc", "hs", "ub", "bh", "eb", "nb", "ctrl", "bb", "bsp", "ssl", "sa", "sf", "wb", "xb", "bt", "sw", "kb", "si", "lp", "ob", "db", "sg", "pb"], "j": ["obj", "ij", "jack", "us", "it", "k", "z", "_", "m", "dj", "t", "str", "bj", "jo", "job", "ix", "key", "oj", "ju", "q", "br", "kj", "ct", "aj", "off", "att", "jit", "__", "jj", "ja", "bot", "ind", "json", "uj", "msg", "yy", "jc", "js", "g", "je", "ji", "J", "i", "jp", "jl", "v", "jump", "index"], "b": ["beta", "ba", "k", "bp", "gb", "be", "ib", "bf", "ab", "bis", "bc", "rb", "cb", "bi", "bg", "a", "br", "u", "bu", "bs", "bar", "bound", "y", "eb", "nb", "bd", "B", "bb", "mb", "fb", "xb", "d", "v", "bt", "db"], "valueAfterMD5": ["valueAftermd7", "valueAfterID5", "valueBeforeMD3", "valueAftermd5", "valueAfterMD2", "valueAftermd3", "valueBeforeMD7", "valueAfterID3", "valueAfterMD3", "valueAfterID7", "valueBeforeMD2", "valueAftermd2", "valueAfterID2", "valueAfterMD7"]}}
{"id1": "3558512", "id2": "7499186", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["finalization", " serialate", "Serialze", "Serialized", "finalized", "Serialization", " serialized", "initialze", "Serializer", "finalize", "erializer", "Serialize", "serialized", "serialate", "erialate", "Serialate", "erialize", "finalze", " serializer", "initialize", "initialization", "serializer", "initialized", "serialze", "erialized", "serialization"], "out": ["b", "OUT", "ou", "it", "f", "err", "output", "file", "t", "c", "Out", "n", "stream", "a", "os", "p", " OUT", "to", "up", "io", "outs", "result", "w", "report", "ch", "OU", "log", "serv", "i", "d", "sum", "v", "res", "o", "aos", "sw", "pool"], "parser": ["rer", "jack", "format", "aser", "parse", "ker", "tp", "tar", "pkg", "instance", "per", "file", "reader", "arser", "job", "proc", "loader", "builder", "walker", "peer", "asser", "p", "Parser", "processor", "layer", "util", "manager", "er", "tree", "plan", "xml", "password", "part", "ger", "token", "handler", "command", "policy", "style", "writer", "worker", "inner", "base", "now", "language", "lp", "bank", "ler", "magic"], "on_disk": ["on2disk", "on_Disk", " on_file", "on_cloud", "on2link", " on_Disk", "On_disk", "on2file", "on2Disk", "on_link", "On_link", "On_cloud", " on_disc", " on_volume", "on_disc", " on_dis", "On_file", "on_dis", "on_download", "On2disk", "On2Disk", " on_download", "on_volume", "On_Disk", "On2link", "On2file", "on_file"], "in": ["In", "ad", "is", "sin", "on", "input", "rin", "it", "id", "r", "ain", "IN", "inn", "and", "inside", "inf", "bin", "vin", " IN", "ins", "inc", "from", "mi", "en", "io", "ind", "body", "din", "isin", "min", "cin", "i", "gin", " din", "inner"]}}
{"id1": "1357662", "id2": "7149578", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["CopFileFile", "CopDirectoryFile", "CopDirectoryFrom", "copyFileFrom", "copyfileTO", "copyDirectoryFrom", "CopFileFrom", "copyfileTo", "copyToFrom", "copyToFile", "copyFileFile", "copyToTo", "CopFileTO", "CopDirectoryTo", "copyDirectoryFile", "CopFileTo", "copyfileFile", "copyToTO", "copyDirectoryTo", "copyFileTO", "copyDirectoryTO", "copyfileFrom", "CopDirectoryTO"], "destination": ["dominator", "destification", " destinated", "domination", " destinator", "Destification", "descinated", "destinated", "Destinate", "delination", "catification", "restinated", "descification", " destinations", "estinations", "Destinated", "destinity", "descinate", "delification", "estination", "disturation", "distinity", "distination", "distification", "descination", "delinity", "restification", "catinated", "dominated", "destinator", "estinated", " desturation", "destinate", "deluration", "restination", " destinate", "estinator", "catinate", "destinations", "dominations", " destification", " destinity", "distinate", "distinated", "catination", "Destination", "restinate", "desturation"], "srcChannel": ["insChan", " srcchannel", "sysStream", " srcCase", "srcChan", "rcConnection", "srcCh", "srcStream", " srcStream", " srcChain", " srcChan", "sourceConnection", "sourceChan", "rcStream", "srcCase", "sourceChannel", "srcConnection", "srCase", "sourcechannel", "rcChan", "rcchannel", "sysChannel", "sysChan", "srChan", "srcchannel", " srcConnection", "sysConnection", "srChannel", "sinCase", "sinChannel", "insChain", "sinChain", "insChannel", "rcChain", "sourceCh", " srcCh", "srChain", "srcChain", "sinChan", "rcCh", "rcChannel", "insCh"], "destChannel": ["destCategory", "srcC", "destCh", "srcChan", "etcChannel", " destCan", "destC", "homeChan", "destchannel", " destConnection", "DestChan", " destchannel", " destChan", "DestCh", "etcConnection", "destCan", " destCh", "Destchannel", " destC", "srcConnection", "DestChannel", "DestCategory", "srcchannel", " destCategory", "homechannel", "certConnection", "destChan", "homeCategory", "homeChannel", "certCan", "etcChan", "certCh", "DestCan", "certChannel", "destConnection", "etcC", "DestConnection"]}}
{"id1": "21979717", "id2": "3756429", "code1": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"upload": [" go", "save", " confirm", " restore", " commit", " sort", " load", " login", " input", "submit", " update", " delete", " reload", " work", " insert", " install", " change", " press", "ction", " dump", " dispose", " move", " paste", " file", "execute", " store", " take"], "fileResult": ["FILEStatus", "fileRequest", "FileResults", "FILEReturn", "reportResult", "reportRequest", "fileStatus", "fileResults", "reportStatus", "FileResult", "fileReturn", "FILEResult", " fileStatus", " fileReturn", "FileReturn", "reportResults", "FileStatus", "FILEResults", " fileResults", "FileRequest", " fileRequest"], "in": ["In", "is", "init", "on", "input", "rin", "it", "win", "r", "file", "IN", "inn", "l", "inside", "inf", "bin", "lock", " IN", "ins", "n", "inc", "from", "p", "en", "up", "io", "ind", "st", "body", "din", "isin", "get", "cin", "conn", "i", "gin", " din", "inner", "doc", "un"], "url": ["ls", "dl", "net", "http", "URL", "r", "open", "f", "file", "abs", "l", "ur", "gl", "str", "https", "browser", "client", "web", "nl", "arl", "gc", "char", "xml", "www", "console", "ref", "conv", "get", "log", "Url", "conn", "ssl", "ul", "bel", "atl", "name", "ll", "pl", "channel", "sl"], "con": ["com", "Conn", "cert", "http", "conf", "ver", "coin", "open", "comm", "func", "ion", "ln", "ain", "Con", "bean", "fc", "cond", "pc", "cos", "col", "pos", "client", "cl", "cat", "c", "gate", "cp", "en", "cn", "cmd", "don", "canon", "fac", "act", "cm", "soc", "const", "cal", "CON", "conv", "dial", "re", "sub", "ctrl", "conn", "connection", "cont", "co", "ran", "pen", "cons", "cf", "cur", "can", "syn", "create", "connect", "un", "call"], "out": ["b", "obj", "ex", "at", "or", "OUT", "net", "ou", "conf", "output", "ion", "t", "cos", "oss", "pos", "client", "Out", "n", "this", "null", "os", "en", "to", "io", "ne", "sys", "outs", "w", "conv", "OU", "po", "conn", "i", "co", "sum", "aos", "can", "o", "auto", "outer", "vol", "un"], "in2": ["IN2", "IN3", "inner3", "din2", "inner02", "out1", "win1", "out02", "out4", "out2", "inner2", "out3", "in1", "IN02", " in1", "din1", "in4", "win2", "din4", "inner1", "IN1", "in3", " in3", "win3", " in4", "in02"], "buf": ["bytes", "block", "uf", "cap", "tmp", "cfg", "pkg", "rb", "str", "queue", "cb", "cat", "Buffer", "br", "orig", "cv", "img", "arr", "cp", "cmd", "box", "batch", "bag", "bar", "cam", "seq", "tab", "conv", "fg", "aka", "Buff", "log", "buffer", "vec", "emb", "cf", "cur", "mem", "buff", "data", "db", "var", "pb"], "bytesRead": ["secondsread", "tesCount", "bytesWrite", "bytesRun", " bytesCount", "BytesWritten", "tesWrite", "cellsRun", "secondsRead", " bytesread", "rowsread", " bytesRun", " bytesLoad", "bytesNeed", "rowsLoad", "tesWritten", "bytesLoad", "cellsLoad", " bytesWrite", "rowsRun", "rowsNeed", "rowsRead", "rowsWrite", "secondsNeed", "secondsWrite", " bytesWritten", "BytesCount", "bytesCount", "bytesread", "BytesRead", "cellsWrite", "cellsRead", " bytesNeed", "bytesWritten", "BytesWrite", "tesRead"]}}
{"id1": "3024992", "id2": "22625683", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter_NULLOut", "testCopy_readerToWriter_NULLIn", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter2nullOut", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter_null_", "testCopy_readerToWriter_NullOut", "testCopy_readerToWriter_NULL_", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_nullOut", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter2null_", "testCopy_readerToWriter_NULLin", "testCopy_readerToWriter2NullOut"], "baout": ["cait", "BAit", "gaouth", "abain", "abait", "dbouth", "baouth", "gain", "baouts", "dbout", "BAout", "buOut", "buout", "abaOut", "dboul", "baoul", "BAouth", "abaout", "caout", "gaout", "bait", " baouts", "gaoul", "dbin", "BAouts", "buouts", "BAin", "BAoul", " bain", "cain", "BAOut", "bain", "buin", "caOut", "baOut", " baOut"], "out": ["ex", "OUT", "net", "it", "write", "err", "output", "tmp", "ser", "Out", "n", "null", " OUT", "in", "er", "io", "sys", "outs", "result", "serv", "gr", "res", "o", "pool", "gen"], "writer": ["wright", "driver", "channel", "wrote", "write", "widget", "output", "file", "reader", "NULL", "player", "client", "builder", "window", "this", "null", "rw", "writ", "killer", "processor", "woman", "riter", "er", "document", "handler", "w", "target", "Writer", "worker", "buffer", "usher", "nw", "inner", "print", "outer", "data", "maker", "println", "service"]}}
{"id1": "3024970", "id2": "21824901", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamTooutputFile", "testCopy_inputStreamTooutputStream", "testCopy_inputStreamtoOutputFile", "testCopy_inputStreamtoOutputStream", "testCopy_inputStreamtoOutputSteam", "testCopy_inputStreamTooutputstream", "testCopy_inputStreamtoInputStream", "testCopy_inputStreamtoInputFile", "testCopy_inputStreamtoInputstream", "testCopy_inputStreamToOutputSteam", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamToInputStream", "testCopy_inputStreamtoInputSteam", "testCopy_inputStreamToInputstream", "testCopy_inputStreamTooutputSteam", "testCopy_inputStreamToInputSteam", "testCopy_inputStreamToInputFile", "testCopy_inputStreamtoOutputstream", "testCopy_inputStreamToOutputFile"], "in": ["In", "inv", "read", "iter", "is", "sin", "init", "on", "input", "it", "rin", "al", "sql", "r", "doc", "ain", "IN", "inn", "l", "inside", "inf", "bin", "ai", "c", "ins", "n", "source", "from", "mc", "q", "p", "this", "en", "ac", "h", "mi", "ic", "up", "copy", "xml", "io", "el", "ind", "im", "din", "mm", "isin", "log", "nin", "cin", "con", "i", "gin", " din", "inner", "scan", "ini"], "baout": ["oain", "kain", "baio", "kaend", "abaot", "oaout", "caouts", " baend", "abain", "oaio", "calog", "kaout", "baouts", "Baout", "baend", "boin", "BAout", "Baouts", "abaOut", "oaOut", "boio", "caio", "abaout", "caout", "boOut", "Balog", " balog", "BAot", " baouts", "caend", " baot", "balog", "baot", "BaOut", "BAin", "kaOut", " bain", "cain", "BAOut", "bain", "caOut", "baOut", "boout", " baOut"], "out": ["b", "obj", "ex", "check", "at", "net", "OUT", "ou", "all", "it", "output", "list", "t", "oss", "client", "gt", "Out", "n", "null", "cmd", "to", "up", "copy", "io", "sys", "outs", "set", " Out", "conv", "OU", "g", "log", "serv", "con", "gr", "co", "sum", "aos", "res", "o", "ot"], "count": ["Count", "read", "counter", "number", "id", "z", "amount", "nt", "N", "current", "ctr", "size", "c", "found", "ct", "num", "resp", "length", "nb", "total", "sum", "code", "start", "skip", "ount", "index"]}}
{"id1": "5551393", "id2": "7545002", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public static String POST(String url, String[][] props) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        for (int i = 0; i < props.length; ++i) {\n            conn.addRequestProperty(props[i][0], props[i][1]);\n        }\n        conn.connect();\n        try {\n            return new String((byte[]) conn.getContent());\n        } finally {\n            conn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMD4", "getMD2", " getMD4", "getSHA3", "getSHA2", " getMD3", "getSHA5", "getmd4", "getmd5", "getmd2", "getMD3", "getmd3", " getMD2", "getSHA4"], "source": ["SOURCE", "message", "template", "value", "src", "input", "url", "Source", "force", "subject", "filename", "output", "context", "space", "file", "config", "ource", "seed", "s", "string", "image", "reason", "from", "object", "site", "spec", "sequence", "text", "body", "target", "style", "content", "resource", "start", "sample", "base", "data", "name", "now"], "tmp": ["MP", "obj", "nd", "lambda", "pp", "src", "foo", "tt", "perm", "cache", "out", "input", "mobi", "tar", "gb", "Temp", "output", "nt", "pkg", "mp", "m", "mk", "t", "cb", "test", "etc", "found", "tn", "qq", "managed", "txt", " mp", "p", "cv", "img", "cp", "resp", "attr", "bag", "cmp", "sp", "msg", "result", "snap", "po", "temp", "aaa", "bb", "jp", "buf", "cont", "bt", "np", "buff", "data", "db", "rup"], "md": ["ad", "amd", "nd", "cd", "dr", "dh", "wd", "red", "mt", "nt", "MD", "m", "pm", "mp", "rm", "and", "der", "mk", "mac", "de", "hd", "df", "pd", "cmd", "dd", "det", " MD", "sam", "ind", "mod", "desc", "pdf", "mm", "ld", "bd", "od", "mn", "mb", "td", "mand", "d", "sd", " Md", "ms", "di", "sm", "dm"]}}
{"id1": "21363911", "id2": "1371265", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 1, "substitutes": {"testTransactions": ["testTransacts", "testTactions", " testtransaction", " testtransacts", " testtransactions", " testtransitions", "testTaction", "testTransitions", "testTacts", "testtransaction", "testtransitions", "testtransactions", "testTransaction", "testTitions", " testTransacts", " testTransaction", "testtransacts", " testTransitions"], "con": ["com", "conf", "on", "tc", "fc", "pc", "rc", "sur", "ens", "ct", "util", "nc", "ch", "enc", "dial", "conn", "connection", "co", "connect", "gen", "win", "sc", "open", "ain", "Con", "xc", "fl", "cc", "c", "cn", "dn", "ic", "act", "coll", "rec", "CON", "conv", "cont", "anc", "db", "un", "ren", "pt", "ctx", "ln", "config", "bo", "mc", "gate", "en", "cv", "gc", "console", "cal", "bn", "re", "ctrl", "cons", "cf", "res", "pl", "cache", "bc", "client", "fn", "go", "cp", "ac", "don", "cm", "po", "ran", "pen", "can", "cur"], "st": ["obj", "pt", "sl", "sta", "put", "th", "rest", "sth", "nd", "irst", "stop", "tt", "ts", "ste", "it", "ft", "sc", "mt", "std", "nt", "ln", "ust", "stan", "stat", "t", "s", "ist", "l", "rt", "str", "bo", "ut", "cl", "sts", "stra", "sn", "inst", "ST", "sty", "h", "ct", "stre", "ost", "est", "sp", "cr", "sol", "const", "wt", "St", "sb", "statement", "step", "ld", "stage", " superst", "must", "art", "so", "co", "bt", "sw", "et", "start", "ast", "fr"], "rs": ["cs", "dr", "ts", "ds", "usr", "rm", "pc", "rc", "rt", "rings", "ags", "ri", "rets", "ins", "Rs", "bs", "rl", "arts", "icks", "ress", "rd", "ss", "ros", "ges", "rots", "pres", "rus", "rss", "r", "irms", "ats", "RS", "s", "aps", "ras", "hs", "ems", "ns", "ls", "gs", "ics", "ubs", "vs", "vers", "times", "dds", "cases", "sts", "xs", "sys", "rys", "its", "js", "re", "els", "res", "mr", "ws", "ims", "arms", "vr", "ys", "ows", "ues", "rx", "sr", "abs", "rows", "ars", "ris", "ires", "rr", "acks", "rates", "ps", "ks", "stats", "qs", "rel", "ms", "hr"]}}
{"id1": "8778962", "id2": "23510383", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFileString", "decodeFileAsfile", "decodeStringToString", "decodeFile2String", "decodeFileAsFile", "decodeFileFileFile", "decodeFileAsString", "decodeString2Files", "decodeFileToFiles", "decodeFile2Files", "decodeFileFilefile", "decodeFile2file", "decodeStringTofile", "decodeString2file", "decodeStringToFile", "decodeFileToString", "decodeString2File", "decodeStringToFiles", "decodeFile2File", "decodeFileFileFiles", "decodeString2String", "decodeFileTofile", "decodeFileAsFiles"], "infile": ["InFile", "inputfile", "inname", "frombase", "isinfolder", "Infilename", "outbase", "inbase", "inFile", "isinname", "Inbase", "infolder", "outFile", "fromfilename", "fromfile", "Infile", "isinFile", "inputname", "outfilename", "infilename", "outfolder", "fromFile", "inputFile", "inputfolder", "isinfile", "outname"], "outfile": ["inname", " outname", "Outfilename", "outFILE", "inFILE", "inFile", "tofile", "todir", " outFILE", "otfile", "outFile", "outdir", "Outdir", "indir", "outname", "otFile", "toFile", " outFile", "otname", "outfilename", "OutFile", "infilename", "otFILE", "tofilename", "Outfile"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "fn", "null", "os", "en", "cn", "to", "flush", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "aos", "res", "o", "auto", "can", "outer", "ot", "inner"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "black", "stack", "temp", "shape", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "shift", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", " succeed", "exist", "ccess", "commit", "cess", "value", "accept", "fail", "growth", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "scope", "successful", "good", "please", "ceed", "town", "result", "valid", "successfully", " okay", " failure", "ratulations", " succeeds", "sufficient", "photo", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "14794404", "id2": "12055086", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encryptSecret", "encryptedpassword", "encipherSecret", "encryptionPassword", "decryptPassword", "decryptSecret", "encryptedPass", "encipherPass", "encryptedSecret", "encryptPass", "encryptionSecret", "encipherpassword", "encryptpassword", "decryptedPass", "decryptPass", "decryptedPassword", "decryptedpassword", "encipherPassword", "encryptionPass", "decryptedSecret", "decryptpassword", "encryptionpassword"], "password": ["message", "path", "user", "sword", "value", "number", "input", "pass", "Password", "address", "filename", "database", "description", "login", "past", "string", "directory", "padding", "email", "wordpress", "entry", "key", "word", "pattern", "username", "attribute", "token", "command", "shadow", "text", "w", "content", "reset", "hash", "data", "name", "phrase", "prefix", "secret"], "encryptedPassword": ["installedDatabase", "confirmedPassword", " encryptedConnection", "updatedAttribute", "updatedpassword", " encryptedpassword", "initializedPassword", " encryptedAttribute", "ryptedpassword", "encryptedpassword", "installedAttribute", "encryptedConnection", " encryptedStatement", "updatedPassword", "initializedStatement", "updatedDirectory", "finishedpassword", "encryptedDirectory", "encryptedDatabase", " encryptedDatabase", "ryptedDirectory", "coloredStatement", "installedPassword", " encryptedDirectory", "installedDirectory", "coloredDatabase", "updatedGuest", "updatedDatabase", "confirmedDatabase", "encryptedGuest", "confirmedDirectory", "initializedConnection", "finishedGuest", "coloredPassword", "coloredConnection", "confirmedpassword", "encryptedAttribute", "encryptedStatement", "finishedDatabase", "initializedDatabase", "finishedPassword", " encryptedGuest", "ryptedDatabase", "ryptedPassword"], "md5": [" Md3", " MDle", "dig3", " MD3", "MD3", "md512", "dig2", "sha512", "mdle", "sha5", "sha7", " Md8", " md3", "md3", " md8", "sha2", "MD2", " md25", " Mdle", "MD7", " MD2", "MD5", "dig25", "MD512", " md512", " mdle", "md25", "md2", "md7", " md7", "dig5", " MD5", "md8", " Md5", " MD8", " md2", "MD25"], "digest": ["mdEST", "Digester", "hexEST", " digEST", "Digum", "mdse", "digEST", "digester", "hashEST", "hashested", " digse", "mdester", "Digests", "mdests", "digum", "mdest", "digested", "Digest", "digests", "hexested", "Digse", "hashester", "digness", " digests", "Digness", "hashum", "mdness", "mdum", "hexness", "hexest", "DigEST", "mdested", "Digested", "digse", "hashest"], "i": ["b", "ij", "iter", "is", "init", "my", "gi", "id", "qi", "ski", "it", "xi", "\u0438", "ci", "li", "err", "z", "I", "m", "t", "di", "ai", "ix", "iq", "gu", "hi", "x", "bi", "c", "key", "ri", "n", "ii", "q", "a", "multi", "u", "mi", "uri", "ic", "in", "major", "io", "y", "ind", "im", "phi", "conv", "sim", "ie", "ji", "me", "si", "yi", "span", "ei", "pi", "zi", "o", "ti", "point", "j", "ui", "index", "ip"], "hex": ["xf", "ex", "iter", "solid", "check", "com", "full", "cert", "ph", "flash", " Hex", "des", "mix", "sv", "zip", "str", "kw", "tx", "html", "x", "term", "color", "pex", "txt", "hl", "br", "serial", "h", "comp", "def", "cmd", "percent", "dump", "sh", "ne", "sex", "json", "exp", "uint", "ch", "unsigned", "form", "none", "temp", "tex", "rh", "raw", "rex", "print", "cf", "rendered", "hash", "lit", "alpha", "oct"]}}
{"id1": "21921000", "id2": "9479502", "code1": "    @Override\n    public void parse() throws IOException {\n        URL url = new URL((new DataUrlResolver()).getDataUrl(DomainName.CROATIA));\n        URLConnection con = url.openConnection();\n        BufferedReader bStream = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String str;\n        bStream.readLine();\n        while ((str = bStream.readLine()) != null) {\n            String[] tokens = str.split(\"(\\\\s+)\");\n            String charCode = tokens[0].replaceAll(\"([0-9+])\", \"\");\n            Float value = Float.parseFloat(tokens[2].trim().replace(\",\", \".\"));\n            CurrencyUnit unit = new CurrencyUnit(charCode, value, DEFAULT_MULTIPLIER);\n            this.set.add(unit);\n        }\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"parse": ["read", "init", "install", "save", " dissect", "apply", "construct", " eval", " merge", "se", "run", "next", " evaluate", "close", " parser", "handle", "build", "fork", " solve", "process", "start", "execute", "scan", " scan", " ingest"], "url": ["ls", "b", "dl", "cert", "http", "URL", "lr", "r", "f", "open", "abs", "l", "ur", "link", "https", "sur", "au", "client", "cl", "job", "web", "nl", "loc", "hl", "lb", "mount", "cm", "ret", "log", "Url", "mail", "build", "conn", "ssl", "ul", "bel", "ll", "pl", "sl", "un"], "con": ["com", "Conn", "conf", "ver", "sc", "ln", "ain", "Con", "login", "fc", "bc", "sur", "client", "cl", "cc", "un", "c", "mc", " Con", "cp", "cn", "cm", "nc", "soc", "conv", "CON", "dial", "re", "cin", "conn", "connection", "co", "ran", "pen", "cons", "cf", "cur", "can", "connect", " conn"], "bStream": ["rbSteam", "bbStream", "rbStream", "fChannel", " bstream", "fStream", "bSteam", " bChannel", "bbSteam", "fRead", "rbRead", "bbRead", "rstream", " bRead", "rbStreamer", " bReader", "rSteam", "bstream", "bReader", "rbstream", "rbChannel", "rStreamer", "rStream", "bStreamer", "vReader", "vStream", "bChannel", "bRead", "bbReader", "fStreamer", " bStreamer", " bSteam", "vSteam", "vRead"], "str": ["b", "obj", "cs", "pt", "out", "input", "it", "r", "comm", "err", "z", "list", "t", "s", "l", "Str", "string", "ctr", "pos", "pr", "c", "req", "n", "txt", "source", "br", "p", "arr", "char", "tr", "sp", "msg", "cr", "st", "spec", "console", "text", "STR", "dec", "g", "e", "line", "i", "cont", "gr", "print", "res", "cur", "comment", "j", "vol", "fr"], "tokens": ["pokens", "toksets", "todkens", "tkents", "tokskens", "takents", "Tokets", "todens", "stokkens", "Tokeds", "stodkens", "pokents", "toksTokens", "todets", "takets", "tolkens", "toksents", "Tokents", "pokkens", "tobkens", "tolens", "tobens", "pobTokens", "pobens", "tolences", "stodens", "todTokens", "Toksents", "pobents", "stodences", "pokTokens", "tkeds", "stokets", "tkens", "stokences", "tokseds", "Toksens", "Toksets", "todences", "tokents", "stodets", "tokTokens", "tokkens", "pobkens", "takens", "tokets", "toksences", "takeds", "tobTokens", "tobents", "Tokens", "Tokseds", "tokeds", "tkets", "stokens", "toksens", "tokences", "tolets", "todents"], "charCode": ["charFore", "characterFore", "cellcode", "characterName", "charName", " charcode", "CharCode", "characterType", "CharName", "CharFore", "charType", "cellType", "charcode", "charactercode", " charType", "cellName", "characterCode", "CharacterName", "cellCode", "CharacterFore", "CharacterCode", " charName"], "value": ["VALUE", "dollar", "format", "function", "number", "type", "Value", "address", "instance", "description", "currency", "current", "zone", "feature", "system", "score", "key", "val", "family", "serial", "category", "price", "percent", "money", "scale", "version", "default", "average", "result", "sequence", "property", "pain", "position", "step", "hello", "total", "sum", "max", "v", "sample", "language", "data"], "unit": ["block", "group", "format", "note", "number", "component", "it", "type", "class", "unknown", "nit", "currency", "dir", "uni", "string", "stable", "term", "crit", "category", "u", "num", "money", "layout", "util", "io", "scale", "nu", "command", "Unit", "set", "unsigned", "units", "dimension", "chain", "sum", "base", "name", "volume", "prefix", "relation", "un", "variable"]}}
{"id1": "17475530", "id2": "14390569", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkFromimage", "testAddLinkForimage", "testAddLinkFromImage", "testAddLinkToimage", "testAddLinkFromPicture", "testAddLinkstoImages", "testAddLinkForPicture", "testAddLinkFromImages", "testAddLinksToImage", "testAddLinkstoPicture", "testAddLinktoImage", "testAddLinktoimage", "testAddLinksToimage", "testAddLinksToImages", "testAddLinkToImages", "testAddLinkForImage", "testAddLinkstoImage", "testAddLinktoImages", "testAddLinkstoimage", "testAddLinksToPicture", "testAddLinkForImages", "testAddLinkToPicture", "testAddLinktoPicture"], "in": ["In", "ex", "check", "is", "init", "at", "or", "on", "out", "input", "it", "rin", "al", "all", "r", "info", "k", "sein", "file", "ma", "IN", "m", "inn", "and", "add", "inside", "bin", "include", "vin", "ins", "one", "source", "from", "inc", "mc", "en", "ini", "ed", "up", "er", "password", "ind", "set", "show", "din", "isin", "by", "get", "re", "nin", "cin", "i", "gin", " din", "sum", "inner", "v", "o", "pi", "doc"]}}
{"id1": "14794404", "id2": "13152325", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encryptSecret", "encryptedpassword", "encipherSecret", "encryptionPassword", "decryptPassword", "decryptSecret", "encryptedPass", "encipherPass", "encryptedSecret", "encryptPass", "encryptionSecret", "encipherpassword", "encryptpassword", "decryptedPass", "decryptPass", "decryptedPassword", "decryptedpassword", "encipherPassword", "encryptionPass", "decryptedSecret", "decryptpassword", "encryptionpassword"], "password": ["message", "path", "user", "sword", "value", "number", "input", "pass", "Password", "address", "filename", "database", "description", "login", "past", "string", "directory", "padding", "email", "wordpress", "entry", "key", "word", "pattern", "username", "attribute", "token", "command", "shadow", "text", "w", "content", "reset", "hash", "data", "name", "phrase", "prefix", "secret"], "encryptedPassword": ["installedDatabase", "confirmedPassword", " encryptedConnection", "updatedAttribute", "updatedpassword", " encryptedpassword", "initializedPassword", " encryptedAttribute", "ryptedpassword", "encryptedpassword", "installedAttribute", "encryptedConnection", " encryptedStatement", "updatedPassword", "initializedStatement", "updatedDirectory", "finishedpassword", "encryptedDirectory", "encryptedDatabase", " encryptedDatabase", "ryptedDirectory", "coloredStatement", "installedPassword", " encryptedDirectory", "installedDirectory", "coloredDatabase", "updatedGuest", "updatedDatabase", "confirmedDatabase", "encryptedGuest", "confirmedDirectory", "initializedConnection", "finishedGuest", "coloredPassword", "coloredConnection", "confirmedpassword", "encryptedAttribute", "encryptedStatement", "finishedDatabase", "initializedDatabase", "finishedPassword", " encryptedGuest", "ryptedDatabase", "ryptedPassword"], "md5": [" Md3", " MDle", "dig3", " MD3", "MD3", "md512", "dig2", "sha512", "mdle", "sha5", "sha7", " Md8", " md3", "md3", " md8", "sha2", "MD2", " md25", " Mdle", "MD7", " MD2", "MD5", "dig25", "MD512", " md512", " mdle", "md25", "md2", "md7", " md7", "dig5", " MD5", "md8", " Md5", " MD8", " md2", "MD25"], "digest": ["mdEST", "Digester", "hexEST", " digEST", "Digum", "mdse", "digEST", "digester", "hashEST", "hashested", " digse", "mdester", "Digests", "mdests", "digum", "mdest", "digested", "Digest", "digests", "hexested", "Digse", "hashester", "digness", " digests", "Digness", "hashum", "mdness", "mdum", "hexness", "hexest", "DigEST", "mdested", "Digested", "digse", "hashest"], "i": ["b", "ij", "iter", "is", "init", "my", "gi", "id", "qi", "ski", "it", "xi", "\u0438", "ci", "li", "err", "z", "I", "m", "t", "di", "ai", "ix", "iq", "gu", "hi", "x", "bi", "c", "key", "ri", "n", "ii", "q", "a", "multi", "u", "mi", "uri", "ic", "in", "major", "io", "y", "ind", "im", "phi", "conv", "sim", "ie", "ji", "me", "si", "yi", "span", "ei", "pi", "zi", "o", "ti", "point", "j", "ui", "index", "ip"], "hex": ["xf", "ex", "iter", "solid", "check", "com", "full", "cert", "ph", "flash", " Hex", "des", "mix", "sv", "zip", "str", "kw", "tx", "html", "x", "term", "color", "pex", "txt", "hl", "br", "serial", "h", "comp", "def", "cmd", "percent", "dump", "sh", "ne", "sex", "json", "exp", "uint", "ch", "unsigned", "form", "none", "temp", "tex", "rh", "raw", "rex", "print", "cf", "rendered", "hash", "lit", "alpha", "oct"]}}
{"id1": "10131427", "id2": "15645004", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpStream", " cpFile", " CopyFile", "CopyFile", "CopyStream", " copyfile", " Copyfile", " cpImage", " CopyImage", " copyStream", " CopyStream", " cpfile", "CopyImage", "Copyfile", " copyImage"], "in": ["In", "b", "is", "on", "input", "rin", "it", "r", "IN", "inn", "s", "l", "inf", "ar", "vin", "ins", "n", "source", "inc", "from", "en", "ic", "up", "el", "ind", "old", "st", "edIn", "din", "mm", "isin", "cin", "i", "gin", "o"], "out": ["b", "ex", "check", "OUT", "net", "ou", "it", "err", "output", "nt", "file", "help", "t", "l", "s", "str", "oss", "gt", "Out", "n", "os", "to", "io", "ne", "outs", "w", "ch", "po", "log", "serv", "i", "v", "o", "ot"], "sourceChannel": ["sourceChuck", "matchChuck", "srcStream", "srcChannel", "matchButton", "sourceConnection", "ourceChain", "sourceApplication", "ourceButton", " sourceButton", "ourceChan", "sourceChan", "sourceStream", "sourceChain", "SourceStream", " sourceChain", "singleChannel", "inputChannel", "sourceButton", "singleApplication", "SourceChannel", "ourceStream", "ourceConnection", "resourceStream", "sourcechannel", "resourcechannel", "ourceChannel", "resourceChannel", "resourceConnection", "srcchannel", "matchApplication", "singleButton", "seedChannel", "matchChannel", "singleChuck", "inputChan", " sourceChan", "inputConnection", " sourceStream", " sourcechannel", "ourcechannel", "srcButton", "SourceConnection", " sourceConnection", "seedChuck", "Sourcechannel", "inputChain", "seedApplication", "seedButton"], "destinationChannel": ["destinationsContext", "desticationChan", "DestensionChan", "DestinationChan", "destinatedContext", "destationClient", "destroyConnection", "destinationConnection", "destensionChan", "DestinationCow", "destinatoryCow", "DestinationChannel", "destroyChannel", "DestationConnection", "DestensionChannel", "DestationBlock", "destinatoryBlock", "destinatoryChan", "destinatedChan", "DestensionClient", "destationContext", "desticationBlock", "destinationChan", "DestinationConnection", "DestationChan", "destinationCow", "destinatoryChannel", "DestationContext", "DestinationClient", "DestensionConnection", "destinatedChannel", "destroyClient", "destroyChan", "destationChan", "destinatedConnection", "DestinationContext", "desticationCow", "destationConnection", "destationCow", "destensionChannel", "destensionConnection", "destinationsChan", "destinationContext", "DestationChannel", "destinationClient", "destensionClient", "destationBlock", "destinationsConnection", "destinationBlock", "destinationsChannel", "DestationCow", "DestinationBlock", "destationChannel", "desticationChannel"]}}
{"id1": "2381663", "id2": "21555906", "code1": "    @Test(expected = GadgetException.class)\n    public void malformedGadgetSpecIsCachedAndThrows() throws Exception {\n        HttpRequest request = createCacheableRequest();\n        expect(pipeline.execute(request)).andReturn(new HttpResponse(\"malformed junk\")).once();\n        replay(pipeline);\n        try {\n            specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n            fail(\"No exception thrown on bad parse\");\n        } catch (GadgetException e) {\n        }\n        specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n    }\n", "code2": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"malformedGadgetSpecIsCachedAndThrows": ["malformedGadgetSpecIsCachedandthThrow", "malformedGadgetSpecIsCachedandThThrow", "malformedGadgetSpecIsCachedAndrethThrow", "malformedGadgetSpecIsCachedAndrethrows", "malformedGadgetSpecIsCachedAndthThrow", "malformedGadgetSpecIsCachedAndThrown", "malformedGadgetSpecIsCachedandthrown", "malformedGadgetSpecIsCachedandthrows", "malformedGadgetSpecIsCachedandThrows", "malformedGadgetSpecIsCachedAndthrown", "malformedGadgetSpecIsCachedAndrethows", "malformedGadgetSpecIsCachedAndThThrow", "malformedGadgetSpecIsCachedAndthows", "malformedGadgetSpecIsCachedandThrown", "malformedGadgetSpecIsCachedAndThows", "malformedGadgetSpecIsCachedandthows", "malformedGadgetSpecIsCachedAndrethrown", "malformedGadgetSpecIsCachedAndthrows", "malformedGadgetSpecIsCachedandThows"], "request": ["message", "pull", "http", "parse", "input", "query", "url", "context", "project", "instance", "task", "reference", "map", "first", "frame", "quest", "record", "client", "req", "Request", "next", "this", "q", "pair", "p", "object", "forward", "xml", "initial", "document", "command", "result", "requ", "report", "condition", "question", "resource", "create", "response", "ip", "call"]}}
{"id1": "7396682", "id2": "2511579", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"copy": ["pixel", "read", "opy", "write", "download", "clip", "Cop", "repeat", "sync", "core", "map", "php", "zip", "link", "load", "cat", "crop", "clone", "move", "fit", "proxy", "cop", "cp", "share", "gc", "py", "archive", "Copy", "cross", "slice", "delete", "upload", "transfer", "create", "replace", "split"], "srcFS": ["srcMS", "sysVS", "srcOS", "rcOS", "sourceVS", " srcVS", " srcMS", "rcFS", " srcfs", "srcCS", "rcFs", " srcSF", "rcfs", "srFS", " srcCS", "srcFs", "srMS", "sourceOS", "rcMS", "srcVS", "sysFs", "sourceCS", " srcOS", "srcSF", "sourcefs", "srcfs", "srFs", "sysOS", "sysFS", "srfs", "sourceFS", " srcFs", "sourceFs", "rcVS", "rcSF", "rcCS", "sourceSF"], "src": ["dest", "obj", "SOURCE", "path", "th", "check", "sin", "supp", "init", "http", "secure", "sci", "input", "sc", "Source", "usr", "subject", "filename", "tmp", "url", "sync", "pkg", "ser", "dir", "sec", "rx", "sr", "rc", "str", "ctr", "https", "proc", "sq", "inst", "sn", "req", "boot", "loc", "rs", "source", "from", "txt", "lb", "img", "pri", "uri", "comp", "addr", "nil", "sys", "spec", "st", "desc", "target", "sb", "iv", "sub", "cont", "resource", "syn", "cur", "start", "rel", "RC", "node", "sit", "obs", "via", "selected"], "dst": ["dest", "lgt", "lest", "dhst", "ddnd", "desdest", "dhDest", "degt", "ddlt", "ddst", "deest", "DST", "Dest", "Dlt", "dsgt", "dDest", "desst", "dslt", " dST", " ddest", "dlt", "ldest", "deslt", "Dst", "dsST", "ddest", "dhdest", "dddest", "dsdest", "dsst", "dedest", "DDest", " dest", " dDest", "dsest", "dsnd", "dgt", " dlt", "dST", "dhlt", "desnd", "dnd", "Ddest", "lst"], "deleteSource": ["delDest", "deleteTarget", "deleteSOURCE", "leteSources", "removeParent", "removeDest", " deleteTarget", " deleteSources", "delParent", "delSOURCE", "updateSource", "leteSOURCE", "updateSite", "leteSource", "DeleteSite", "deleteResult", "DeleteSource", "DeleteSOURCE", "removeSource", "removeSOURCE", "leteParent", "deleteParent", "deleteSite", "leteDest", "updateSourceFile", "leteResult", "destroySources", "closeSource", "deleteSources", "deleteSourceFile", "DeleteSourceFile", "leteTarget", "closeSourceFile", "deleteDest", "delSource", "destroySource", "updateSOURCE", " deleteResult", "closeSite", "closeSOURCE", "destroyResult", "destroyTarget"], "conf": ["css", "check", "com", "cms", "ctx", "cache", "prop", "ban", "Conf", "fs", "info", "comm", "f", "lib", "param", "ln", "m", "config", "map", "params", "irm", "job", "cc", "cb", "req", "q", "cn", "def", "plan", "cm", "acc", "report", "ch", "ref", "conv", "ca", "mm", "log", "conn", "con", "co", "cf", "hash", "scan", "comment", "pool", "cfg"], "contents": ["Contterms", "CONTants", "contends", " contENT", "contodes", "contresses", " Contents", "constENTS", "ContENT", " contterms", "Contodes", "Content", "contENT", "CONTENT", " ContENTS", "constends", "CONTends", " content", "CONTents", " contENTS", " Contresses", "CONTresses", "constaves", "CONTodes", "CONTaves", "CONTent", "Contents", "contaves", " Content", " contends", "contants", " contodes", "Contants", " contants", "content", "contENTS", "constents", "CONTterms", " contresses", "CONTENTS", " contaves", "contterms"], "i": ["ami", "ij", "iter", "is", "init", "my", "us", "gi", "id", "qi", "it", "ski", "xi", "\u0438", "ci", "li", "ms", "I", "m", "oi", "di", "ai", "ix", "docker", "iq", "client", "hi", "ki", "x", "key", "bi", "n", "ii", "q", "u", "multi", "mi", "ic", "ini", "y", "ind", "json", "im", "phi", "sim", "ie", "ori", "ji", "me", "chain", "si", "inner", "span", "ei", "pi", "o", "ti", "cli", "j", "ui", "index", "ims", "ip"], "in": ["In", "read", "check", "is", "out", "input", "sql", "r", "doc", "IN", "inn", "and", "reader", "add", "inf", "bin", "ins", "source", "from", "inc", "mc", "en", "ze", "char", "xml", "ind", "body", "din", "isin", "by", "re", "cin", "con", "raw", " din", "inner", "sample", "ini"]}}
{"id1": "13852596", "id2": "21316706", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "label": 0, "substitutes": {"execute": ["launch", " perform", "init", "evaluate", " execution", " launch", " sweep", "construct", " eval", "exec", " assemble", "run", " evaluate", " chain", " exec", " executed", " replay", " inherit", " executable", "process", " release", " proceed", " benchmark", " scan", " resolve", " deploy", " test"], "resources": ["models", "Resources", "bytes", "faces", "files", "modules", "actions", "these", "builders", "packages", "writers", "users", "banks", "accessible", "reports", "apps", "pointers", "groups", "projects", "types", "they", "rows", "results", "flows", "rs", "roots", "locks", "ris", "services", "classes", "issues", "images", "lets", "ports", " Resources", "uploads", "relations", "ifiers", "ions", "names", "resource", "objects", "res", "items", "artifacts", "archives", "workers", "rooms", "ids", "stores", "scripts", "blocks"], "i": ["ami", "ij", "ex", "ims", "gi", "mu", "xi", "info", "\u0438", "ci", "li", "I", "list", "ali", "bis", "t", "l", "oi", "ai", "hi", "ri", "ki", "ir", "bi", "ii", "q", "mi", "multi", "h", "in", "io", "im", "phi", "iu", "ios", "ori", "g", "abi", "ji", "e", "si", "iri", "v", "pi", "ti", "cli", "j", "ui", "di", "ini", "ip", "ia"], "classFile": ["classifiedSourceFile", "classifiedFile", "attributeChain", "sourceFiles", "classChain", "ClassFile", " classClass", "classEntry", "targetFile", "instanceFiles", "classResource", "classDirectory", "parentFILE", "classFolder", "classLine", "ClassChain", "recordFiles", "userFile", "objectFolder", "connectionFile", "objectClass", "attributeFile", "instanceFilename", "classfile", "ClassClass", "typeLine", "typeFile", "userFiles", "ClassResource", "clfile", "fastFiles", "cellClass", "connectionFILE", "Classfile", "connectionSourceFile", "targetSourceFile", " classFilename", "parentSourceFile", "ClassSourceFile", "classFILE", "recordfile", "classTree", "classifiedfile", "classFilename", "fastFILE", "recordFile", "typeFILE", " classFILE", "targetFILE", "classifiedFILE", "fastfile", "objectFile", "ClassLine", "attributeFILE", " classDirectory", "attributeEntry", "classSourceFile", "ClassDirectory", "classFiles", "connectionfile", "classClass", "cellFolder", "cellFile", "sourceFILE", " classChain", "userfile", " classFiles", " classFolder", "attributeFiles", "targetFiles", " classSourceFile", "ClassFilename", "sourceClass", "typeFiles", " classResource", "clFiles", "ClassFILE", "ClassFiles", " classLine", "instanceFile", "instanceDirectory", "recordFilename", "sourceFile", "parentFile", "clTree", "clFile", " classEntry", "classifiedFiles", "ClassTree", "userFILE", " classfile", "ClassEntry", " classTree", "parentfile", "attributeResource", "fastFile"], "inputStream": ["inputStreamer", "inputSt", "outputTime", "errorSteam", "ipStyle", "outStream", "jsonSteam", "inputSet", " inputSteam", "InputMode", "outputPort", "thisSteam", "inStream", "familyStream", "InputTime", "audioStreamer", "familyStyle", "jsonSet", " inputMode", "thisSource", " inputStreamer", "inStreamer", "thisFile", "ipSteam", "ipStream", "inSteam", "instream", "Inputstream", "inputSource", "inputStyle", " inputPort", "innerStream", "jsonStreamer", "inSet", "jsonStream", "outSt", "InputStream", "outputStyle", " inputSt", " inputSource", "familySource", "errorstream", "innerSet", "inputMode", "inputTime", "outputstream", " inputstream", "inPort", "outputFile", "familyFile", "audioStream", "thisStream", "outputSteam", "inputPort", "audioSt", "ipFile", "outStreamer", "innerSteam", "inputSteam", "errorMode", " inputTime", "audioSteam", "inputFile", " inputFile", "outSteam", "inputstream", "familySteam", "innerStreamer", "InputSteam", "errorStream"], "reader": ["read", "user", "driver", "rer", "Reader", "dr", "review", "query", "write", "r", "wrapper", "red", "author", "older", "instance", "per", "editor", "actor", "parser", "penter", "client", "loader", "builder", "entry", "test", "key", "peer", "rar", "rule", "row", "stream", "image", "dd", "manager", "layer", "service", "er", "runner", "rl", "master", "owner", "handler", "document", "ner", "field", "ger", "definition", "reading", "Writer", "worker", "finder", "iterator", "prototype", "inner", "mr", "operator", "draft", "readable", "oder", "ler", "variable"], "oldSize": ["olderSize", "OLDsize", "oldFontSize", "olderLength", "oldsize", " oldsize", "OLDFontSize", " oldLength", "OLDSize", "olderFontSize", "OLDLength", " oldFontSize", "oldersize", "oldLength"], "writer": ["read", "message", "driver", "Reader", "storage", "format", "wrote", "review", "draw", "write", "weight", "r", "wrapper", "author", "writers", "written", "editor", "actor", "parser", "penter", "player", "walker", "vector", "loader", "builder", "entry", "test", "key", "word", "row", "rw", "ter", "method", "manager", "riter", "service", "er", "runner", "document", "handler", "owner", "ner", "w", "writing", "definition", "adder", "Writer", "worker", "finder", "buffer", "buf", "wb", "inner", "draft", "node", "ler", "variable"], "b": ["bit", "ib", "r", "f", "gb", "bp", "binary", "m", "bf", "ab", "bis", "t", "l", "rb", "bin", "c", "n", "a", "br", "p", "erb", "u", "bits", "h", "batch", "bs", "bound", "w", "sb", "g", "nb", "B", "bb", "mb", "wb", "fb", "d", "v", "emb", "base", "ob", "db"], "outputStream": ["resultSteam", "writeView", "resultForm", "writeStream", "inputForm", " outputView", "outputString", " outputString", "outputForm", "resultstream", " outputSteam", "OutputSteam", "OutputStream", "resultStream", "outputstream", " outputPoint", "writeSteam", "writePoint", "outputSteam", "resultString", "inputSteam", " outputForm", "inputView", "outputPoint", "outputView", "inputstream", "Outputstream", "OutputString", "OutputForm", "inputPoint"], "injectedClasses": ["injectUsES", "injectedCountES", "injectedUsES", "injectedClassets", "injectedUses", "injectedSuccessBytes", "injectedUsets", "injectUsBytes", "injectedClassES", "injectedSuccessets", "injectedSuccesses", "injectedCountets", "injectedCountBytes", "injectUsets", "injectClasses", "injectClassBytes", "injectedClassBytes", "injectedCountes", "injectUses", "injectClassets", "injectClassES", "injectedSuccessES", "injectedUsBytes"], "newSize": ["newMax", " newName", "newName", "NewMax", "oldFontSize", " newMax", "newFontSize", " newFontSize", "oldMax", "oldName", "NewSize", "NewFontSize", "NewName"]}}
{"id1": "3375724", "id2": "16719805", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 0, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" insertarEmissoresDosTitULosT", " insertarEmissoresDosTitulasT", " insertarEmissoresDosTituloT", " insertarEmissoresDosTitulOsT", " insertarEmissoresDosTitulOsF", " insertarEmissoresDosTitulasC", " insertarEmissoresDosTitULoC", " insertarEmissoresDosTitulasFe", " insertarEmissoresDosTitULosF", " insertarEmissoresDosTituloC", " insertarEmissoresDosTitULoFe", " insertarEmissoresDosTitulasF", " insertarEmissoresDosTitULosFe", " insertarEmissoresDosTitulOsFe", " insertarEmissoresDosTitulOsC", " insertarEmissoresDosTitulosFe", " insertarEmissoresDosTitULoF", " insertarEmissoresDosTitulosC", " insertarEmissoresDosTitulosF", " insertarEmissoresDosTitULosC", " insertarEmissoresDosTituloF", " insertarEmissoresDosTituloFe", " insertarEmissoresDosTitulosT", " insertarEmissoresDosTitULoT"], "pArquivoTXT": ["pArquivoRIN", "pArquivoNRL", "pArquivNxt", "pArquivoFEX", "pArquivotOX", "pArquivoFXT", "pArquivoNEX", "pArquivRIN", "pArquivTOX", "pArquivTXT", "pArquivoBEX", "pArquivoDxt", "pArquivoTOX", "pArquivoNBT", "pArquivNEX", "pArquivoTIN", "pArquivotIN", "pArquivTIN", "pArquivoDEX", "pArquivoTxt", "pArquivoFxt", "pArquiveNEX", "pArquivRXT", "pArquivoBBT", "pArquivTEX", "pArquivNXT", "pArquivotxt", "pArquivoRxt", "pArquivoFBT", "pArquivTRL", "pArquivoDRL", "pArquivTxt", "pArquiveTxt", "pArquivoFRL", "pArquivoTBT", "pArquiveTXT", "pArquiveNBT", "pArquivoXTXT", "pArquivoTEX", "pArquivoXTxt", "pArquivotXT", "pArquivoBXT", "pArquivoTRL", "pArquivoNXT", "pArquiveNXT", "pArquiveTBT", "pArquivNRL", "pArquiveTEX", "pArquiveNxt", "pArquivoBxt", "pArquivoXTOX", "pArquivoRXT", "pArquivRxt", "pArquivROX", "pArquivoNxt", "pArquivoROX", "pArquivoXTIN", "pArquivoDXT"], "pAndamento": ["pAndementos", "pAndementO", "pAndumentoS", "pandamentos", "pAndamentoS", "pandmentO", "pAndemento", "pAndumentos", "pandamentO", "pandamento", "pandmento", "pandmentos", "pAndmentO", "pAndmentoS", "pAndmento", "pandmentoS", "pAndamentos", "pandamentoS", "pAndumento", "pAndmentos", "pAndamentO", "pAndumentO", "pAndementoS"], "numeroDoRegistro": ["numeroDoRegestro", "numeroDoregistulo", "numeroDoRegistros", "numeroDoregistros", "numeroDoRegestulo", "numeroDoregestr", "numeroDoregestro", "numeroDoRegitros", "numeroDoRegendulo", "numeroDoRegestros", "numeroDoregistr", "numeroDoRegestr", "numeroDoRegitro", "numeroDoregistro", "numeroDoRegitr", "numeroDoregestulo", "numeroDoRegistulo", "numeroDoRegitulo", "numeroDoRegendros", "numeroDoRegendro", "numeroDoRegistr", "numeroDoregestros", "numeroDoRegendr"], "in": ["In", "pin", "sin", "thin", "out", "input", "rin", "f", " ins", "ln", "IN", "m", "inn", "reader", "inf", "bin", "vin", "ins", "n", "inc", "inning", "from", " sin", " nin", "ner", " inn", "tin", "edIn", "kin", "din", "isin", "min", "nin", "cin", "con", "gin", " din", "inner", " out", "scan"], "stmtLimpezaInicialDestino": ["stmtLimpezaIniciaEstino", "stmtLimpezaInicioEstINO", "stmtLimpezaInicialStination", "stmtLimpezaInicialdestinos", "stmtLimpezaInicialEstination", "stmtLimpezaInicialStaine", "stmtLimpezaInicialDestinos", "stmtLimpezaInicialDestaine", "stmtLimpezaIniciaEstINO", "stmtLimpezaInicialDecinos", "stmtLimpezaInicialDecINO", "stmtLimpezaInicialEstINO", "stmtLimpezaInicialEstaine", "stmtLimpezaInicialEstino", "stmtLimpezaInicialStINO", "stmtLimpezaInicioDestaine", "stmtLimpezaInicialDestINO", "stmtLimpezaInicialEstinos", "stmtLimpezaInicialStinos", "stmtLimpezaInicialdestino", "stmtLimpezaInicioDestINO", "stmtLimpezaIniciaEstination", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialdestination", "stmtLimpezaInicialDecaine", "stmtLimpezaIniciaDestINO", "stmtLimpezaIniciaDestinos", "stmtLimpezaIniciaDestino", "stmtLimpezaIniciaEstinos", "stmtLimpezaInicioEstaine", "stmtLimpezaInicialDestination", "stmtLimpezaInicioDestino", "stmtLimpezaInicialDecino", "stmtLimpezaInicialStino", "stmtLimpezaInicioEstino", "stmtLimpezaInicioDestinos", "stmtLimpezaInicioEstinos"], "sql": ["inv", "ls", "script", "dl", "template", "format", "spr", "pp", "query", "url", "select", "wal", "description", "session", "ln", "join", "sv", "lex", "ql", "csv", "s", "seed", "string", "str", "params", "sq", "html", "nl", "sn", "fn", "xs", "q", "details", "pel", "cmd", "expression", "xml", "SQL", "command", "msg", "spec", "scl", "sol", "sp", "json", "socket", "eps", "statement", "js", "log", "serv", "ssl", "raw", "sd", "qs", "name", "rel"], "stmtDestino": ["stMTDecino", "stmmDestination", "stmmInstinos", "stmtdestin", "stmtInstorno", "stmmInstination", "stMTDestINO", "stmtDecino", "stmtDestinos", "stmtStino", "stmtDecINO", "stMTDestin", "stmtdestino", "stMTDestino", "stmtdestinos", "stmtDestINO", "stmtDestination", "stmmDestorno", "stmmDestinos", "stmtDestorno", "stmtdestINO", "stmtdestorno", "stMTDecINO", "stmtStin", "stmtStinos", "stmtdestination", "stMTDecinos", "stmmInstorno", "stMTDecin", "stmtDestin", "stmtInstinos", "stmtDecin", "stmmDestino", "stmtStINO", "stmtStination", "stmtInstino", "stmtInstination", "stMTDestinos", "stmmInstino", "stmtDecinos", "stmtStorno"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABUCALHI", "TAMANHO_DO_CABUCALLHI", "TAMANHO_DO_CABECALLH", "TAMANHO_DO_CABUCALHA", "TAMANHO_DO_CABECALHA", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECILHO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABUCALH", "TAMANHO_DO_CABECARHI", "TAMANHO_DO_CABUCALHO", "TAMANHO_DO_CABUCALLHA", "TAMANHO_DO_CABECULH", "TAMANHO_DO_CABECALLHA", "TAMANHO_DO_CABECALH", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECARH", "TAMANHO_DO_CABECILHI", "TAMANHO_DO_CABECARHA", "TAMANHO_DO_CABECILH", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABUCALLH", "TAMANHO_DO_CABUCALLHO", "TAMANHO_DO_CABECILHA"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPE2do", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAPEJFILE", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPE2Do", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAP_FILE", "TAMANHO_DO_RODAPE2DO", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPE_FILE"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADADDS_", "TAMANHO_DOS_METADABos_", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADABOON", "TAMANHO_DOS_METADADOON", "TAMANHO_DOS_METADABOSON", "TAMANHO_DOS_METADADSON", "TAMANHO_DOS_METADABOS_", "TAMANHO_DOS_METADABO_", "TAMANHO_DOS_METADADOSON", "TAMANHO_DOS_METADADDSON", "TAMANHO_DOS_METADADS_"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_POR_REGESS", "TAMANHO_MEDIO_POR_REGIN", "TAMANHO_MEDIO_POR_RegESS", "TAMANHO_MEDIO_POR_REMESS", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_POR_REMIS", "TAMANHO_MEDIO_POR_REMES", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_RECis", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_REMIN", "TAMANHO_MEDIO_POR_RegIN", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_POR_Regis", "TAMANHO_MEDIO_POR_RECES", "TAMANHO_MEDIO_POR_REGis"], "tamanhoDosArquivos": ["tamanhoDosArquivelos", "tamanhoDosArquIVores", "tamanhoDosArquivalo", "tamanhoDosArquivao", "tamanhoDosArquIVos", "tamanhoDosArquesivos", "tamanhoDosArquesivaoes", "tamanhoDosArquivaoes", "tamanhoDosArquiveos", "tamanhoDosArquivo", "tamanhoDosArquesivalos", "tamanhoDosArquivalores", "tamanhoDosArquiveoes", "tamanhoDosArquives", "tamanhoDosArquivores", "tamanhoDosArquIVoes", "tamanhoDosArquesivoes", "tamanhoDosArquivoes", "tamanhoDosArquIVo", "tamanhoDosArquesivlos", "tamanhoDosArquivs", "tamanhoDosArqIVores", "tamanhoDosArqivs", "tamanhoDosArqivores", "tamanhoDosArquivalos", "tamanhoDosArquIVlos", "tamanhoDosArqivo", "tamanhoDosArqIVs", "tamanhoDosArquIVs", "tamanhoDosArqivos", "tamanhoDosArquivals", "tamanhoDosArquesivaos", "tamanhoDosArquesivo", "tamanhoDosArquivaos", "tamanhoDosArquesivao", "tamanhoDosArqIVos", "tamanhoDosArquivlos", "tamanhoDosArquiveo", "tamanhoDosArqIVo", "tamanhoDosArquiveores"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstamados", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstimmados", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstipados", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimados", "quantidadeDeRegistrosEstamada", "quantidadeDeRegistrosEstamado", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstamadas"], "registro": ["Registros", "Registrob", "regdistros", "regitrob", "regestrob", "Regestrob", "registros", "regitr", "registrob", "regestro", "Regestros", "regdistrob", "Registr", "regestr", "Regestro", "regitros", "regestros", "regitro", "Registro", "Regestr", "regdistro", "registr", "regdistr"], "campos": ["campo", "jamo", "taros", "campOS", "tarOs", "campOs", " campOS", " campo", "jamOs", "tarOS", "jamos", " campOs", "taro", "jamOS"]}}
{"id1": "13644375", "id2": "665420", "code1": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"get": ["put", "read", "pull", "check", "gets", "http", "parse", "draw", "update", "query", "download", "open", "find", "select", "search", "give", "request", "Get", "current", "pre", "debug", "head", "exec", "send", "load", "run", "method", "command", "ge", "json", "set", "body", "show", "post", "see", "delete", "build", "GET", "resource", "print", "got", "create", "execute", "play", "like", "service", "we", "call"], "url": ["ls", "path", "dl", "full", "http", "URL", "parse", "id", "api", "address", "l", "ur", "link", "string", "str", "web", "html", "nl", "loc", "domain", "page", "host", "uri", "pattern", "rl", "href", "ref", "ret", "build", "Url", "pl", "server", "location", "base", "name", "ll", "mount", "sl"], "response": ["reply", "message", "block", "http", "all", "application", "open", "output", "request", "trace", "pos", "client", "answer", "onse", "entry", "image", "next", "page", "given", "still", "object", "successful", "resp", "tree", "document", "result", "json", "soc", "respond", "body", "post", "re", "connection", "resource", "content", "yes", "res", "Response", "data", "status", "service", "respons"], "entity": ["obj", "put", "person", "user", "group", "ce", "note", "component", "type", "info", "iso", "instance", "any", "session", "encrypted", "complex", "and", "load", "record", "client", "Entity", "entry", "email", "peer", "image", "one", "le", "ent", "object", "pe", "unit", "eme", "document", "el", "result", "unique", "json", "body", "ity", "form", "em", "e", "remote", "line", "me", "event", "resource", "content", "total", "model", "security", "base", "data", "comment", "channel", "member", "ee", "activity"]}}
{"id1": "20375440", "id2": "14231545", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "movefile", "CopyDirectory", "CopyFile", " copyfile", "moveFile", "moveFiles", "CopyFiles", " copyFiles", "moveDirectory", "copyDirectory", " copyDirectory", "Copyfile", "copyfile"], "srcFile": ["sourceFiles", "subLine", " srcfile", "rcfile", " srcFiles", "rcFile", "subWeb", "sourcefile", "sourceFile", " srcLine", "srcFiles", " srcWeb", "srcPath", "subFile", "rcWeb", "rcFiles", "subPath", "rcLine", " srcPath", "rcPath", "srcfile", "srcWeb", "srcLine", "sourcePath"], "destFile": ["DestFile", "destFilename", " destPath", "destPath", "srcDir", "srcMail", "DestFiles", "potMail", " destFiles", "DestPath", "srcFilename", "srcFiles", "potFilename", "potDir", "srcPath", " destDir", "DestDir", "potFile", "destDir", " destMail", "destFiles", " destFilename", "destMail"], "src": ["sl", "rob", "rest", "sin", "http", "sc", "usr", "sync", "ln", "ser", "rx", "sr", "reader", "rc", "rt", "rb", "ctr", "proc", "sq", "inst", "req", "loc", "ins", "rs", "source", "pri", "comp", "rl", "sh", "sys", "st", "const", "sb", "gob", "iv", "sub", "sel", "sing", "ssl", "sf", "syn", "inner", "cur", "scan", "rel", "sit", "via"], "dest": ["inv", "nd", "rest", "out", "dis", "des", "comb", "usr", "output", "nt", "std", "mk", "gd", "Dest", "news", "bin", "pos", "cat", "self", "priv", "dc", "loc", "end", "source", "nom", "them", "gate", "pub", "comp", "decl", "opt", "pipe", "master", "est", "result", "st", "desc", "coord", "target", "exp", "mm", "port", "dat", "temp", "trans", "must", "dist", "cont", "sum", "rel", "pl", "sit", "di", "doc", "pas"], "buffer": ["message", "block", "header", "channel", "value", "cache", "number", "component", "binary", "frame", "append", "entry", "memory", "Buffer", "stream", "window", "limit", "row", "word", "page", "object", "batch", "char", "initial", "document", "attribute", "bar", "result", "command", "sequence", "password", "length", "text", "stack", "shape", "buf", "event", "print", "available", "base", "sample", "buff", "data", "mem", "comment", "phrase", "button", "table", "variable"], "read": ["draw", " Read", "find", " write", "give", "current", "t", "add", "str", "fill", "size", "next", "pe", "text", "get", "build", "each", "wait", "shift", "pass", "input", "write", "open", "key", "run", "stream", "end", "READ", "num", "in", "len", "tail", "scale", "valid", "reading", "shape", "sample", "play", "readable", "iter", "check", "parse", "config", "count", "send", "reads", "load", "record", "n", "have", "ind", "length", "last", "depth", "print", "index", "Read", "query", "mix", "sync", "reader", "need", "word", "q", "char", "height", "old", "allow", "no", "seek", "hold", "start", "skip"]}}
{"id1": "3252116", "id2": "8921716", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMD4", "GetMD4", "Getmd4", "Getmd1", "getHash5", "getmd4", "getHash10", "Getmd5", "GetMD1", "getMC5", "getmd5", "getMC1", "getMD10", "GetMD10", "getHash4", "getMC10", "getMC4", "getmd10", "Getmd10", "getmd1", "GetMD5", "getHash1", "getMD1"], "source": ["b", "dest", "SOURCE", "message", "template", "src", "input", "Source", "f", "subject", "output", "file", "ser", "ource", "seed", "string", "origin", "c", "image", "this", "from", "null", "object", "copy", "site", "sequence", "text", "target", "style", "e", "buffer", "content", "code", "start", "sample", "base", "data", "name", "secret"], "s": ["ls", "b", "cs", "gs", "gets", "ts", "ds", "fs", "ats", "abs", " ts", "t", "parts", "sts", "ends", "bes", "ads", "ings", " gets", " es", "ins", "rs", "xs", "a", "os", "p", " samples", "bs", " ss", " outputs", "ses", "ies", "S", " fs", "hs", " streams", "eps", "sb", "its", " sets", "js", "ps", "ss", " returns", "ws", " rs", " ls", "es", "uns", "ns", " ans"], "hexDigits": ["hexDigit", " hexDigists", "hexDigities", "exdigits", "hexdigals", "hexdigit", "hexDitions", "hexDigists", "hexdigbits", " hexDigitions", "exDigits", "hexdigitions", " hexDigals", "exDigals", " hexDigit", "hexPosits", "hexPositions", "hexFunbits", "hexdigists", "hexDits", "hexDities", "exDigities", "exdigities", "hexFunits", " hexDigities", "hexdigits", "exDigitions", "hexFunit", "hexDigitions", "exdigitions", "hexdigities", "exdigals", "hexFunals", "hexDigals", "hexDigbits", " hexDigbits", "hexDists", "hexPosals", "hexPosities"], "md": ["ad", "amd", "nd", "cd", "dr", "dh", "mt", "grad", "red", "nt", "MD", "m", "rm", "der", "cond", "mk", "add", "de", "hd", "mc", "df", "pd", "cmd", "dd", "det", "ind", "mod", "desc", "pdf", "mm", "ld", "bd", "dig", "od", "mn", "mb", "td", "d", "sd", " Md", "ms", "di", "sm", "dm"], "tmp": ["obj", "bytes", "dirty", "ctx", "tt", "perm", "Temp", "pkg", "mp", "bis", "zip", "params", "sym", "proc", "fake", "etc", "html", "test", "sup", "cb", "qq", "txt", "xs", "img", "comp", "up", "cmp", "bag", "sp", "yy", "xy", "js", "temp", "nb", "mb", "cur", "np", "buff", "db", "emp", "local", "table"], "str": ["b", "obj", "cs", "iter", "dr", "out", "it", "sc", "r", "m", "list", "t", "string", "Str", "ctr", "cat", "ar", "c", "n", "txt", "br", "p", "arr", "arc", "char", "tr", "sp", "div", "cr", "st", "set", "w", "text", "STR", "ch", "fr", "hex", "e", "buf", "gr", "stri", "print", "v", "sw", "data", "name", "cast", "vol", "sl"], "k": ["b", "ka", "id", "f", "ok", "km", "z", "m", "kt", "kid", "t", "mk", "ku", "l", "kw", "kh", "ik", "unk", "x", "K", "c", "key", "n", "tk", "q", "p", "ko", "kar", "kj", "h", "sk", "kk", "ak", "set", "w", "kl", "g", "kan", "ks", "ke", "kn", "ck", "d", "v", "ikk", "j"], "i": ["ij", "is", "gi", "it", "qi", "xi", "\u0438", "ci", "li", "info", "I", "m", "ai", "ix", "hi", "ri", "x", "bi", "ii", "n", "p", "mi", "u", "multi", "ic", "ini", "in", "index", "io", "im", "phi", "iu", "sim", "status", "e", "ji", "conv", "me", "chain", "si", "print", "zi", "v", "pi", "o", "inter", "ti", "cli", "j", "ui", "di", " j", "ip"], "byte0": [" byte3", "hex6", " byte8", " byteElement", "hex1", "node1", " byte140", "Byte8", "channel140", "channel0", "byte3", "channel1", "Byte3", " byte6", " byte2", "node8", "byte6", "channel3", "Byte0", "pixel1", "byteElement", "hex0", "byte1", "Byte2", "Byte140", "byte8", "byte140", "Byte1", " byte1", "byte2", "node0", "pixel0", "node2", "pixel6", "hexElement", "pixelElement"]}}
{"id1": "7006052", "id2": "23666867", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyFilesFrom", "copyfileThrough", " copyFileOver", "copyToOver", " copyFilesThrough", "copyFileFrom", " copyFilesFrom", " copyFileThrough", "copyfileTo", "copyToFrom", " copyFileFrom", " copyFilesOver", " copyFilesTo", "copyFilesOver", "copyfileOver", "copyToThrough", "copyToTo", "copyFileOver", "copyFileThrough", "copyFilesThrough", "copyfileFrom", "copyFilesTo"], "src": ["init", "sin", "http", "input", "sc", "Source", "usr", "url", "pkg", "ser", "config", "sec", "rx", "sr", "cos", "rc", "rt", "ctr", "sq", "inst", "req", "ins", "rs", "source", "txt", "bs", "rl", "sys", "st", "ipl", "sb", "iv", "cont", "sf", "start", "cur", "rel", "sit", "obs"], "dest": ["rest", "usr", "home", "del", "tmp", "des", "nt", " dst", "dir", "done", "Dest", "test", "origin", "req", "de", "loc", "end", "source", "them", "orig", "pub", "good", "decl", "way", "est", "result", "st", "exp", "desc", "target", "port", "dat", "trans", "dist", "cont", "d", "mem", "pl", "www"], "destFile": ["DestFile", "newfile", "sourceFiles", "destPage", "destfile", "newFile", "srcDir", " destfile", "DestFiles", " destDo", "newDo", "sourcefile", "sourceFile", "sourceDir", "srcFiles", "distPage", "distfile", "Destfile", "distDo", " destPage", "DestDir", "destDir", "srcFile", "distFile", "srcfile", "newPage", "destFiles", "destDo"], "in": ["In", "read", "iter", "is", "init", "sin", "on", "input", "rin", "it", "al", "info", "ain", "per", "IN", "inn", "rc", "inside", "inf", "bin", "ai", "ins", "inc", "from", "en", "ze", "ic", "act", "up", "io", "el", "ind", "im", "din", "mm", "isin", "cin", "con", "i", "gin", "inner", "ini"], "out": ["b", "obj", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "and", "t", "cos", "oss", "client", "gt", "Out", "n", "null", "os", "p", "en", "cn", "to", "io", "ne", "sys", "outs", "writer", "by", "g", "po", "con", "co", "inner", "v", "can", "o", "auto", "outer", "aos", "ot", "res", "we"], "buf": ["b", "obj", "bytes", "block", "prop", "uf", "mu", "cap", "pkg", "bc", "rb", "str", "bin", "queue", "cb", "tx", "cat", "Buffer", "br", "cv", "cp", "arr", "img", "cmd", "box", "batch", "good", "bag", "bar", "msg", "abet", "cam", "seq", "alph", "tab", "conv", "bh", "aka", "Buff", "log", "buffer", "vec", "pad", "cf", "cur", "buff", "data", "bus", "db", "var", "gen"], "len": ["ls", "lan", "dl", "mid", "wid", "cap", "del", "z", "nt", "la", "ln", "t", "count", "l", "str", "pos", "size", "fin", "n", "val", "le", "end", "en", "lon", "coll", "il", "cmp", "compl", "el", "lf", "length", "seq", "exp", "Len", "lic", "lif", "e", "no", "ld", "vec", "v", "elt", "ll", "rel", "pl", "mun"]}}
{"id1": "9449064", "id2": "19467540", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "label": 0, "substitutes": {"readExp": ["passExpl", " readEx", "ReadProp", "checkExpl", "readerEXP", "checkExpress", "ReadExp", "readerExp", "passExpress", "ReadLoc", "readProp", "passexp", "readEXP", "ReadEXP", "readLoc", " readExpl", " readLoc", "readExpl", "readEx", " readExpress", "passExp", "readExpress", " readexp", " readEXP", "readerProp", "Readexp", "readerLoc", " readProp", "checkexp", "ReadEx", "readerEx", "readexp", "readerexp", "checkExp"], "writeExp": ["writeExt", "writXP", "riteConf", "writeEx", "updateExt", "riteEv", " writeReg", "writEXP", "applyExp", "writeReg", "updateEv", "updateExp", "writExp", "writeConf", "riteReg", "writeEXP", "writeXP", " writeEXP", " writeEv", "writeexp", "writEx", "riteExt", " writeEx", " writeexp", "writeEv", "writexp", " writeConf", "writConf", " writeXP", "riteExp", "applyEXP", " writeExt", "applyEx", "riteEXP", "applyXP", "riteexp", "updateReg"], "expFile": ["exPlace", "docField", "xpPath", "docFile", "docFILE", "exFILE", "exprFilename", "ExpDir", "expFiles", "exfile", "xpFiles", "expFILE", "exFile", "exFiles", "xpFILE", " expPlace", "expDir", " expFilename", "exprFile", "expfile", " expfile", "expFilename", "expField", " expFiles", "docPath", "mxFILE", "docPlace", "xpFile", "expPlace", "ExpFile", " expDir", "exprDir", "mxName", "mxFilename", "docFilename", "mxFile", "repField", "exprName", "Expfile", "xpFilename", "exprfile", "repFile", "expPath", "expName", "exFilename", "xpfile", "repFILE", "repPath", " expFILE", "exprFILE", "xpField", "xpName"], "exp": ["expr", "obj", "pp", " extr", "EXP", " np", "sc", " lim", "f", "comm", " imp", "eq", " expansion", "dem", " inst", "isp", "inf", " exc", " disp", " ev", "nz", "push", "zero", "plus", "inst", " vec", "ext", "wx", " ne", " exponent", "xp", "lim", "ent", " resp", "def", "resp", " xp", " expanded", "ev", "comp", "expl", "expression", "Exp", "opt", " doc", "acc", " est", " dj", "imp", "rep", "eps", " op", "ef", "ox", "ez", "prov", "ps", "jp", "raw", " expr", " expand", "esp", "bed", "pl", " rap", " sc", "pr", " ep"], "fi": ["xf", "ni", "ista", "aci", "fif", "zo", "ati", "gi", "qi", "obi", "ci", "li", "wi", "uci", "FI", "ki", "ri", "ii", "mi", "ffe", "fe", "osi", "flo", "ico", "fty", "isi", "lf", "uti", "phi", "cci", "abi", "i", "si", "fa", "iri", "eric", "zi", "ei", "pi", "ti", "ini", "Fi"], "oi": ["ami", "odi", "igi", "ita", "ovi", "ni", "ati", "vi", "obi", "iso", "ci", "bis", "ink", "uci", "asi", "uta", "ki", "ri", "ta", "bi", "ii", "eni", "mi", "multi", "osi", "obo", "flo", "ico", "io", "oni", "isi", "oin", "uti", "avi", "ori", "i", "iri", "oa", "eric", "ei", "rio", "ti", "uo", "ivo", "ini"], "jf": ["jfd", "djbf", "djfd", "jackbf", "gfm", "jsbf", "jssf", "jF", "jackfd", "jcxf", "jcb", "jcfm", " jif", "bjfp", "Jf", "gf", "jif", "jxf", "jjf", "bjf", " jsf", "Jxf", "jjif", "jackf", "Jfd", "jjfc", "gc", "Jif", "djf", "jsxf", "Jsf", "jjc", "jfp", "Jfm", "jjv", "jjfm", " jb", "jcfx", "jsf", "jackxf", "jfx", " jfp", "jc", " jc", " jfx", "gfc", " jv", "jbf", "bjv", " jxf", "Jbf", "JF", "Jb", " jfm", "djxf", "jv", "bjfm", "jfc", "jcf", "jjF", " jfc", " jF", "jjfp", "Jfx", "jfm", " jbf", "jb", "jcsf"], "sp": ["osp", "Sp", "pt", "pp", "spr", "tp", "vp", "sc", "bp", "space", "asp", "sv", "isp", "se", "SP", "p", "cp", " esp", "sk", "spl", "sh", "op", "sam", "st", "par", "rep", "sb", "ps", "bsp", "jp", "spe", "si", "sf", "so", "ep", "sw", "esp", "span", "lp", "pl", "ap", "sg", "sm", "pb"], "e": ["it", "f", "m", "t", "s", " ev", "x", "n", "a", "p", "fe", "pe", "ed", "er", "el", "w", "E", "ie", "re", "i", "event", "d", "v", "name", "ev", "ee"], "fo": ["xf", "oos", "aco", "fif", "zo", "uf", "lo", "hea", "wi", "oe", "tf", "bo", "tto", "ki", "folio", "tif", "olf", "mo", "obo", "flo", "io", "ico", "wt", "opa", "eno", "po", "ato", "so", "fa", "co", "cf", "o", "FO", "ti", "uo", "wo", "ooo", "ro"], "oo": ["oos", "ilo", "aco", "foo", "zo", "lo", "aha", "goo", "oes", "oe", "oco", "bo", "oto", "oooo", "OO", "ta", "oooooooo", "folio", "cro", "mo", "ero", "ola", "ko", "oid", "ao", "obo", "elo", "flo", "ico", "ano", "ollo", "olo", "opa", "po", "ox", "ato", "so", "yo", "co", "oa", "o", "uo", "ora", "wo", "ooo", "ro"], "ex": ["external", "aux", "EX", "com", "or", "ctx", "des", "err", "su", "xe", "lex", "exe", "ix", " exc", "tx", "x", "de", "ext", "wx", "pex", "ception", "exc", "ac", "def", "ic", "Ex", "act", "ax", "cre", "Exc", "el", "sex", "nex", "except", "pers", "iox", "te", "status", "hex", "none", "ox", "re", "tex", "log", "spe", "event", "rex", "example", "ry", "px", "six", "es"]}}
{"id1": "2198730", "id2": "20663364", "code1": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 1, "substitutes": {"importCSV": [" importESS", "importCSVD", " importESVD", "importDSVD", " importCSDF", " importDSS", " importESDF", " importWSVD", " importCSVD", " importWSDF", " importWSV", " importDSV", "importDSV", "importDSS", " importESV", "importCSDF", "importDSDF", " importDSDF", " importDSVD", " importCSS", "importCSS", " importWSS"], "csvfile": ["xmlFile", "httpsstream", "csvFILE", "txtresource", "csvfiles", "svFile", "cssfile", "csvstream", "httpsFile", "xmlfile", "cssresource", "csvFile", "cssFile", "txtFile", "httpsfile", "xmlFILE", "svresource", "httpsFILE", "cssfiles", "svfiles", "svstream", "svfile", "txtfiles", "csvresource", "xmlstream", "txtfile", "svFILE"], "qmarks": ["qmarked", " qarks", "qparams", "sqarks", "qumarked", "qugrades", "Qmarks", " qmarked", " qparams", "dqmark", "sqmarked", "qualgrades", " qgrades", "qualparams", "qmark", "qarks", "Qmarked", "qualmarks", " qmark", "dqmarked", "qualmarked", "qumarks", "qgrades", "Qarks", "dqmarks", "sqmarks", "sqmark", "quarks", "qumark", "dqparams", "Qgrades", "qualmark", "qualarks"], "i": ["b", "xi", "info", "f", "err", "I", "t", "ai", "ix", "iq", "hi", "ri", "p", "u", "mi", "batch", "jj", "set", "phi", "iu", "e", "history", "v", "ei", "o", "name", "status", "series", "ip", "ij", "ex", "is", "init", "cgi", "id", "z", "ion", "oi", "ki", "x", "ii", "multi", "ic", "in", "json", "sim", "chain", "zi", "ti", "point", "ui", "ini", "iter", "qi", "ci", "li", "m", "list", "iy", "gu", "n", "major", "io", "ind", "exp", "im", "ie", "g", "ice", "print", "span", "cli", "j", "index", "di", "ims", "ami", "gi", "it", "iii", "lo", "l", "bi", "q", "go", "uri", "h", "you", "to", "y", "inx", "ity", "ji", "me", "si", "pi"], "delsql": ["delsq", "deltfx", "dletesql", "dysfx", "dlesq", "delsQL", "delsfx", "deelsQL", "diffsQL", "deltdl", "dletessql", "deltql", "deltsql", "deletessql", "delesql", "dysdl", "dysql", "delssql", "deletesfx", "dyssql", "deelsfx", "deltq", "deletesdl", "deltQL", "dlesQL", "delsdl", "diffsq", "deelsq", "delesQL", "delesq", "dletesdl", "diffssql", "deelsdl", "dlessql", "dletesfx", "deletesql", "deelssql", "diffsql", "deelsql", "delessql", "dlesql"], "delstm": ["delStr", "delsttm", " delStr", " delStmt", " delStem", " delstr", "delstem", "delestn", " delStm", "delSttm", "delStem", "delctmt", " delstem", "Delstn", " delstmt", "delctem", "delstrm", "Delsttm", "delstn", "Delstem", "delStm", "delstrtm", "delestm", "delctr", "DelSttm", "DelStm", "DelStem", "delstmt", "delStn", "DelStn", "delesttm", "delstrem", "delstrn", "delstr", "delctm", "delestem", "Delstm", "delStmt"], "sql": ["inv", "ls", "setup", "script", "dl", "template", "format", "install", "query", "url", "select", "shell", "wal", "pkg", "su", "description", "login", "sv", "ql", "zip", "seed", "string", "repl", "sq", "html", "nl", "fn", "quote", "cmd", "asm", "expression", "plan", "xml", "sys", "SQL", "command", "spec", "sp", "scl", "json", "socket", "form", "statement", "sb", "js", "log", "ssl", "orm", "sf", "raw", "sd", "security", "qs", "rel", "sl"], "stm": ["Stm", "thmt", "Stsm", "tham", "stam", " stam", " stmt", "thsm", " stsm", "stmt", "Stmt", "Stam", "thm", "stsm"], "datatypes": ["datativities", "datAType", " datatools", " datATypes", "datamattypes", "datAtype", " datATools", "datatools", "datetpes", "datatstypes", " datatpes", "datmatype", "datmatools", "datetopes", "datmatypes", "dataatype", "dataatypes", "datATivities", " datattypes", "datamatype", "datAtpes", "datatopes", "datamativities", "datatpes", "datATpes", "datetypes", "dataattypes", " datAType", "datetype", "datATopes", " datatopes", "dataativities", "datamatypes", "datAtypes", "datatsools", "datATools", "datatsype", "datATypes", "datATtypes", "datatsypes", "datmattypes", " datATopes", " datATtypes", " datATpes", "datAtopes", "datmativities", "datattypes"], "tbl": ["ttable", "ptbl", "Tpl", "atbf", "tba", "ctbl", "rtbl", "rtll", "pttable", "atbody", "tamb", "rtpl", "Tbl", "ptpl", "tbody", "dbf", "tpl", "Ttable", "rttable", "dbody", " tbody", "dbl", "wtbl", "wtorg", "ptll", "wtpl", "torg", "Torg", " tamb", "ctpl", "Tba", "atbl", "atamb", "ctorg", "damb", "Tll", "tll", "tbf", "ctba", "wtba", " tbf"], "col": ["pt", "prop", "rol", "comm", "COL", "fc", "cond", "fl", "cell", "pos", "cl", "cat", "c", "dc", "Column", "loc", "row", "crit", "cop", "cp", "ct", "cmd", "def", "coll", "act", "num", "char", "cor", "el", "cal", "ol", "tab", "conv", "chron", "mon", "ctrl", "con", "serv", "crypt", "Col", "cont", "co", "cf", "cur", "column", "ll", "var", "local"], "datatype": ["datAType", " datmatype", "datcatype", "datatyp", " datatrace", "datAtype", "doncatty", "datamatime", "datantrace", "datAtyp", "datmatype", "datatime", "datantime", "datATty", "datmatypes", "datmatrace", "doncatypes", "datantype", "dataatypes", "donatty", "datamatype", "dataatime", "dataatype", "datcatrace", "datmatyp", " datmatrace", "doncatype", "datcatypes", "datmatty", "dataatyp", "datantypes", "datmatime", "datamatypes", "doncatyp", "datAtypes", "datcatty", "datATyp", "datcatyp", "donatypes", "datAtime", "datATypes", "datATime", " datatime", "datatty", "donatype", "datamatyp", "datcatime", "datatrace", "donatyp", " datmatypes", " datmatime"], "dtype": ["DType", "dltry", "dbtype", "dltest", "dype", "djword", " dword", "dtry", "dattry", "dword", "Dtype", " dType", "dcolor", " dype", "dType", "datword", "djtype", "domype", "ctry", "djuffy", "dvalid", "domstyle", "dltype", " dmt", "Dvalid", "duffy", "datstyle", "domtype", " dvalid", "djmt", "dmt", "datmt", "ctest", " dstyle", "dlcolor", "dfield", "dbvalid", "datype", "datcolor", "domuffy", " duffy", "ccolor", "dattype", "dbType", "dstyle", "dtest", " dfield", "dbfield", "dattest", "Dfield", "datuffy", "ctype"], "reader": ["read", "iter", "driver", "Reader", "input", "r", "wrapper", "file", "instance", "rx", "parser", "proc", "loader", "builder", "stream", "row", "rs", "df", "er", "runner", "handler", "ner", "writer", "iterator", "buffer", "inner", "data"], "line": ["LINE", "item", "block", "header", "message", "ln", "mark", "inline", "l", "ine", "link", "lock", "cell", "record", "lin", "entry", "key", "row", "next", "page", "label", "Line", "char", "field", "el", "lines", "column", "section"]}}
{"id1": "19307120", "id2": "1586662", "code1": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"sendPost": ["doText", "sendPOST", "postText", "dopost", "sendText", "postPOST", "doPost", " sendText", " sendpost", "sendpost", " sendPOST", "postPost", "doPOST", "postpost"], "url": ["ls", "path", "dl", "pp", "http", "URL", "address", "file", "l", "ur", "link", "string", "https", "str", "web", "nl", "term", "loc", "q", "host", "u", "uri", "addr", "ref", "ret", "pl", "mail", "Url", "build", "log", "ssl", "ul", "location", "base", "ll", "mount", "sl", "call"], "param": ["commit", "block", "ram", "conf", "prop", "input", "pass", "argument", "project", "m", "config", "rem", "dem", "params", "string", "proc", "padding", "key", "term", "row", "p", "Param", "password", "sp", "command", "aram", "par", "cal", "property", "post", "option", "mm", "meter", "model", "start", "mem", "name", "prefix", "tag", "amp", "comment", "prom"], "result": ["Result", "message", "match", "value", "query", "r", "wrapper", "output", "description", "request", "current", "product", "string", "success", "true", "answer", "test", "confirmed", "memory", "results", "reason", "found", "continue", "feature", "term", "p", "manager", "default", "valid", "command", "report", "ret", "temp", "chain", "buffer", "complete", "date", "sum", "code", "res", "cur", "response", "data", "comment", "status", "diff"], "httpurl": ["workURL", "hconn", "hurl", "workurl", "httpUrl", "workconn", " httpURL", "hURL", " httpUrl", "httpsurl", "webURL", "weburl", "httpsconn", "hUrl", "webconn", "httpURL", "webUrl", "workUrl", "httpsURL", "httpsUrl", "httpconn", " httpconn"], "httpConn": ["httpObj", "hconn", "ttpObj", " httpObj", "ttpConnection", "ttpCon", "hConnection", "HttpConn", "procCon", "ttpconn", "hConnect", "hoverConn", "hConn", "hoverconn", "Httpconn", "httpCod", " httpCon", "hoverConnect", "copCon", "httpsConn", "procConn", "httpsConnect", "ttpConn", "copCod", "httpsconn", "HttpCon", "copConn", "hoverConnection", "procconn", "httpCon", "procConnection", "httpsCon", " httpConnection", "procObj", " httpCod", "httpConnection", "HttpConnect", "copconn", "procCod", "httpconn", "httpsConnection", " httpconn", "httpConnect", " httpConnect"], "out": ["obj", "put", "ex", "check", "init", "net", "OUT", "ou", "it", "all", "write", "output", "nt", "cos", "pretty", "oss", "Out", "n", "os", "screen", "p", "cmd", "to", "flush", "up", "io", "sys", "outs", "set", "w", "ch", "writer", "conv", "OU", "by", "co", "inner", "v", "aos", "o", "auto", "outer", "print", "timeout"], "in": ["In", "read", "iter", "is", "init", "on", "input", "it", "al", "rin", "ma", "per", "IN", "inn", "reader", "se", "inf", "bin", "ri", "ins", "inc", "from", "mi", "en", "ic", "er", "el", "ind", "oin", "din", "isin", "by", "re", "cin", "mn", "i", "gin", " din", "inner"], "line": ["message", "LINE", "block", "header", "liner", "online", "iter", "lined", "file", "ln", "stroke", "l", "ine", "frame", "string", "eline", "cell", "inline", "link", "se", "email", "lin", "entry", "record", "continue", "rule", "row", "page", "le", "pe", "Line", "field", "sequence", "text", "body", "port", "e", "log", "chain", "piece", "ice", "print", "code", "point", "comment", "lane", "phrase", "ip"]}}
{"id1": "16466743", "id2": "7764011", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "label": 0, "substitutes": {"getmd5": ["getMD4", "getmd6", "getMD2", "getMD6", " getMD4", " getMD5", "getMD5", " getMD6", "getmd4", "getsha5", " getmd6", " getmd2", "getsha2", "getmd2", "getsha6", " getmd4", "getsha4", " getMD2"], "password": ["message", "user", "path", "sword", "auth", "value", "pass", "Password", "ew", "wd", "address", "database", "description", "login", " Password", "string", "padding", "email", "wordpress", "entry", "key", "word", "p", "pattern", "username", "attribute", "token", "shadow", "w", "text", "code", "security", "hash", "data", "name", "phrase", "prefix", "hello", "secret"], "pwHash": ["pswSum", "pwHas", "pswHash", " pwHas", "pwdHash", "pwdhash", "pwdSum", "spwhash", "pswhash", "pWHas", " pwhash", " pwSum", "pwthash", "pWHash", "pWhash", "spwdSum", "pwshash", " pwdHash", "spwdHas", "spwHas", "pwsHash", "spwdhash", " pwdSum", "pwtHash", " pwdHas", "pwSum", "spwSum", "pwsHas", "pwtHas", "pwhash", "spwdHash", "pWSum", "pwtSum", "spwHash", "pswHas", "pwsSum", " pwdhash", "pwdHas"], "md": ["ad", "nd", "ng", " mc", "cd", "ds", "del", "mt", "ms", "red", "grad", "MD", "m", "mp", "pm", "rm", "dir", "der", "cond", "mk", "add", "exec", "hd", " dd", "mo", "mc", "df", " mo", "pd", "cmd", "dd", "def", "det", "cmp", "msg", "mod", "ind", "desc", "mm", "ld", "mail", "bd", "od", "dig", "mn", "mb", "material", "td", "metadata", "d", "sd", "man", " Md", "mem", "mg", " mm", "di", "sm", "doc", "dm"], "b": ["obj", "reb", "bytes", "ba", "binary", "bp", "gb", "f", "ib", "be", "bas", "m", "bf", "ab", "abs", "bis", "bc", "l", "rb", "cb", "bi", "a", "br", "p", "bu", "batch", "bs", "bar", "y", "w", "sb", "bh", "eb", "nb", "g", "B", "bb", "mb", "fb", "d", "v", "buff", "ob", "db"], "i": ["ij", "iter", "is", "my", "init", "us", "gi", "id", "qi", "it", "ski", "xi", "\u0438", "ci", "li", "ms", "I", "m", "l", "oi", "di", "ai", "ix", "gu", "ki", "x", "hi", "ri", "bi", "n", "ii", "next", "a", "q", "p", "u", "multi", "mi", "ic", "in", "io", "y", "ind", "json", "im", "phi", "sim", "iu", "ie", "ji", "si", "yi", "v", "ei", "pi", "span", "o", "ti", "cli", "j", "ui", "index", "ini", "ip"]}}
{"id1": "10445819", "id2": "18211588", "code1": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"getReader": ["getRead", " getreader", "getStream", "Getreader", "GetStream", " getStream", "GetReader", "getreader", "newRead", "newreader", "newStream", "GetRead", " getRead", "newReader"], "stream": ["Stream", "message", "user", "store", "draw", "secure", "out", "input", "url", "open", "wrapper", "context", "present", "clean", "instance", "list", "reader", "feed", "proc", "system", "window", "row", "page", "pipe", "sequence", "console", "st", "body", "style", "socket", "form", "port", "engine", "stack", "log", "iterator", "trans", "chain", "buffer", "ssl", "cont", "metadata", "resource", "inner", "sw", "sample", "data", "ream", "channel", "filter", "sl"]}}
{"id1": "14093044", "id2": "11334468", "code1": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"insert": ["commit", "put", "check", "init", "update", "query", "write", "sql", "save", "select", "database", "login", "Insert", "add", "exec", "append", "load", "push", "submit", "set", "delete", "create", "execute", "scan", "replace", "index"], "consulta": ["conultaria", "consultla", "consumera", "consumptionla", "concenta", "consumerana", "Consumeras", "Consumerana", "conultsas", "Consulta", "consultsa", "conscentar", "Consumera", "consultas", "consumea", "conultae", "consertar", "conultsae", "conscentas", "conultas", "consumptionable", "Conscentla", "consaulta", "conscentana", "consertae", "consultsaria", "consulsae", "conscentae", "consulsaria", "ConsumerA", "Consultana", "consumptionas", "consulsas", "conultar", "conscentable", "Conscentable", "concentas", "consultable", "concentar", "consaultaria", "consultar", "consultsae", "Consultas", "consaultA", "Consultla", "consumeas", "consultaria", "conscentA", "Conscenta", "consumeras", "consaultana", "conulta", "consumeable", "conscenta", "Consultable", "consultae", "consumptionae", "consulsa", "consertas", "consumela", "consumptiona", "conserta", "conultsaria", "consultana", "consumerA", "Conscentas", "concentae", "consaultas", "conultsa", "consultsas", "ConsultA", "consumptionar", "consultA", "consaultae", "conscentla"], "autocommit": ["autoconombit", "autocommulate", "autocubits", "autocumnate", "autocomulate", "autoccelerulate", "autocomits", "autoconomate", "autocommate", "autocompate", "autocomort", "autococomate", "autocondite", "autocommort", "autococomit", "autoconommmit", "autOCommits", "autOComits", "autococomulate", "autocompbit", "autoccelerort", "autoccelerit", "autocommbit", "autoconommit", "autocomit", "autocondits", "autoccelermit", "autOComit", "autOCommit", "autOComulate", "autocompmit", "autocompit", "autocondort", "autOCommort", "autOComate", "autOComort", "autoconommate", "autOCommmit", "autocomate", "autocommits", "autocondit", "autocombit", "autocumnbit", "autocubit", "autOCommite", "autocondmit", "autOCommate", "autocumnmit", "autocondulate", "autoconomit", "autocubite", "autocubmit", "autOCommulate", "autocommmit", "autoconommbit", "autocumnit", "autocommite", "autocompulate", "autocomite", "autococommit", "autOComite"], "transactionIsolation": ["transceptionIsensitivity", "transactionStyleensitivity", "transactionISOL", "transceptionIensitivity", "transactionIsilon", "transceptionIsulation", "transactionStyleilon", "transactionInterolated", "transceptionIulation", "transactionISolated", "transversionIsavior", "transpointInterolation", "transactionIdration", "transceptionIsOL", "transactionIsulation", "transceptionIolated", "transactionInolation", "transactionInOL", "transceptionIsolation", "transactionAsularity", "transversionIsolation", "transceptionIilon", "transactionISavior", "transceptionIsolated", "transactionIfolated", "transceptionIsularity", "transactionInolated", "transactionAsolated", "transversionIsolate", "transactionISensitivity", "transceptionIolation", "transactionInterolate", "transactionInterruption", "transactionIsration", "transactionStyleolation", "transactionIsensitivity", "transactionIularity", "transactionAsolate", "transversionIdolation", "transactionIulation", "transactionIolate", "transpointIsruption", "transceptionIularity", "transactionInsolation", "transactionIsularity", "transactionIsavior", "transactionIsolated", "transactionStyleolate", "transactionInsration", "transversionIsration", "transactionIsola", "transactionInterola", "transactionInsavior", "transversionIdration", "transactionISolate", "transactionAsolation", "transactionISulation", "transactionISolation", "transceptionIOL", "transactionIensitivity", "transceptionIsilon", "transactionIOL", "transceptionIsolate", "transactionIfolation", "transactionInolate", "transactionIsruption", "transpointIsolation", "transactionIsOL", "transactionIdavior", "transactionInterularity", "transactionISilon", "transpointIsola", "transceptionIolate", "transactionIfola", "transactionIilon", "transactionISola", "transpointInterola", "transactionInsolate", "transactionInterulation", "transversionIdavior", "transactionInterolation", "transactionIsolate", "transpointIsolated", "transactionIolated", "transpointInterruption", "transactionISration", "transactionIdolation", "transactionIfruption", "transactionIolation", "transversionIdolate", "transactionISruption", "transactionIdolate", "transpointInterolated"], "cx": ["cxt", "ctx", " cxi", " ctx", "acxt", "Cxi", "cxi", "Cxt", "Ctx", " cxt", "Cx", "ncX", "actx", "cX", "nctx", "ncx", "ncxi", "acx", " cX", "CX", "acX"], "filasInsert": ["filrasUpload", "folasEnter", " filasaAdd", "filasAdd", "filataImport", "filASInsert", "folasRow", " filasaInsert", "filasUpload", "filasRow", "filrasUpdate", "filiasImport", "filasaUpload", "filrasAdd", " filasaUpdate", "filasaUpdate", "filinasEnter", "fundasDelete", "filASImport", "folASEnter", "filASRow", "filaInsert", "fundaDelete", "filinasUpload", "filacsEnter", "filaDelete", "filasUpdate", "filasEnter", "fundasImport", "filataInsert", "folasInsert", "filinasAdd", "filinasUpdate", "filinasInsert", " filasaUpload", "filaImport", " filasUpload", "filrasInsert", "folasImport", "filacsInsert", "fundaInsert", "filiasInsert", " filasAdd", "filacsRow", "filinasImport", "fundaImport", "folASInsert", "filasImport", "folASImport", "fundasInsert", "filiasDelete", "folASRow", " filasUpdate", "filasaAdd", "filasDelete", "filacsImport", "filataDelete", "filinasRow", "filASEnter", "filasaInsert"], "tipoConsulta": ["tipoConsultas", "tipoConsultA", "tipoconsultsada", "tipoConistara", "tipoConsulas", "tipoConistas", "tipoConsultsao", "tipoConsultsA", "tipoconsultsa", "tipoConsulsas", "tipoConsulsa", "tipoConsultsa", "tipoConsulao", "tipoConsumera", "tipoCoultada", "tipoCoultao", "tipoCoultar", "tipoConsulsao", "tipoconsultas", "tipoCoulta", "tipoConsultsas", "tipoConsulara", "tipoConsulsA", "tipoConultas", "tipoConsultada", "tipoConsultsada", "tipoCoulsao", "tipoConsistao", "tipoConista", "tipoConistao", "tipoConsumptiona", "tipoConsumerA", "tipoConsumptionao", "tipoCoulsa", "tipoConsistas", "tipoconsultsas", "tipoconsulta", "tipoConsulsada", "tipoConsultar", "tipoConsumptionara", "tipoConsultao", "tipoConsresenta", "tipoCoulsar", "tipoConsresentar", "tipoconsultsA", "tipoConsista", "tipoconsultA", "tipoConultao", "tipoConsresentao", "tipoConsultsar", "tipoCoulsada", "tipoConsistara", "tipoConsula", "tipoConsumeras", "tipoConulta", "tipoconsultada", "tipoConsultara", "tipoConsumptionas", "tipoConsulsar", "tipoConultara", "tipoConsresentada", "tipoConsumerada"], "execConsulta": ["execConsultalpha", "execConsaultar", "execConsaultas", "execConsultar", "execConsortiumalpha", "execCoulta", "execConsumea", "execCoertai", "execConsertai", "execConsertarea", "execConsumela", "execConsertalpha", "execCoultarea", "execConsonsealpha", "execConulta", "execConsortiumarea", "execConsultas", "execConsonsea", "execConsortiumai", "execConultla", "execCoultai", "execCoerta", "execConsortiuma", "execConsultarea", "execConsumear", "execConsultai", "execConsonseai", "execConultar", "execConsonsearea", "execConsumeas", "execConserta", "execCoertalpha", "execCoultalpha", "execConsaulta", "execConsultla", "execCoertarea", "execConultas", "execConsaultla"], "conexion": ["coextision", "coexione", "coexION", "coextion", "cakexION", "conextION", "coneplexison", "coexison", "coneuxions", "conextion", "coneixison", "caxison", "coneaxione", "caixion", "conextions", "coneuxinion", "Colexpions", "conexpion", "coexions", "coneplexion", "coneexible", "coexision", "coeexION", "Colexpion", "cakexison", "conenexression", "cakexpion", "conexpION", "Colexison", "Colexions", "coneaxison", "conexinion", "coeexion", "conenexION", "conenexions", "cakexpION", "coneaxision", "coexinion", "coneuxion", "coeuxinion", "Colexone", "coneexision", "coextison", "coneplexION", "coneXione", "coneixion", "coneplexione", "coexible", "conexions", "conenexion", "coneXION", "caxION", "coneixION", "conexression", "coneexone", "coneXion", "coeexible", "conexION", "coneexione", "conenexible", "coextione", "Colexion", "Colexpone", "coexion", "conenexone", "coneuxION", "coeexison", "conenexinion", "Colexpison", "conexpions", "coneixression", "cakexione", "coeexione", "conenexione", "conexione", "conextione", "coeuxion", "coexond", "cakexpione", "coneixond", "conexison", "conextison", "coneexison", "coneXible", "conextision", "conexond", "conexpison", "coneexION", "caxion", "coneexond", "caxression", "coeuxions", "conexpone", "coneaxion", "coneixione", "coneexion", "caixison", "conexpond", "conexible", "caixION", "conextinion", "coeuxION", "conexision", "conenexison", "cakexion", "caixression", "conextression", "coeexond", "coneexions", "conexone", "conexpione", "cakexpison"], "st": ["obj", "pt", "nd", "sl", "put", "rest", "sth", "src", "stop", "tt", "ste", "ts", "it", "sc", "mt", "tmp", "std", "ust", "stat", "t", " ST", "ist", "ut", "se", "str", "stable", "sle", "cl", "sts", "inst", "sn", "end", "null", "ST", "sty", "pe", "ct", "ost", "est", "sh", " est", "sp", "state", "set", "St", "statement", "stage", "sw", "start", "sm"], "MySQL": ["myDB", "MyDB", "MYQL", "mysDB", "mySQL", "MYDB", "MyQL", "MYSQL", "myQL", "mysSQL", "mysQL"]}}
{"id1": "822452", "id2": "8754809", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrites", "readAndRepWrite", "readAndResWrite", "readAndRewend", "readAndResend", "readAndrewrite", "readAndrewWrite", "readAndResrite", "readAndRewrites", "readAndrewrites", "readAndReprite", "readAndrewend", "readAndRewWrite", "readAndRepend", "readAndReprites"], "inFile": ["InFile", "inputFilename", "docFile", "docFILE", "iFILE", "iFilename", "INTime", "inFILE", "InFilename", "initPlace", "initFilename", "inputPlace", "docTime", "inFace", "outfile", "infile", "iFile", " inFilename", "initFile", "inPlace", "INPlace", "docFilename", " infile", "inTime", "Infile", "initFace", "INFace", "iTime", "INFilename", "INFile", "INFILE", "inputFile", "inputFace", "inFilename", "outFilename"], "outFile": ["reportFile", " outFilename", "checkFilename", "outFILE", "inFILE", "toFILE", "reportFILE", "tofile", "nameFilename", "outfile", "infile", " outFILE", "reportfile", "reportFilename", "toFilename", "namefile", "nameFile", "toFile", "checkFile", " outfile", "checkFILE", "inFilename", "outFilename", "nameFILE", "checkfile"], "iis": [" iris", "iiIs", "liris", "iIS", "eis", "aiis", "Iiss", "liisc", "Ii", "liIs", "liis", "eIS", "iiisc", "ii", " iiss", "iiss", "iiis", "iiris", " iIs", "iIs", " iIS", "diIs", " ii", "iisc", "IIs", "eIs", "aiIS", "dii", "aiIs", "diis", " iisc", "iris", "Iis", "diiss"], "dcmParser": ["dgrParser", " dpmListener", "dpcReader", "dpmAssistant", "DpmReader", "dcrparser", "dcommReader", " dpmarser", "dcmListener", "dmoduleReader", "dmoduleAssistant", " dpmStatement", "dpmLoader", "dmmParser", " dcmarser", " dpmparser", "dcommListener", "deromParser", "dpmBuilder", "dromparser", "dcmAdapter", "dcrParser", "dfmParser", "dpmStatement", "dmmmReader", " dcmLoader", "dcomReader", "dcmBuilder", "dromAssistant", "DpmAdapter", "dcrBuilder", "dpmPrivate", " dcmPar", "dcomBuilder", "dcrReader", " dpmReader", "dcommAssistant", " dpmLoader", " dcmStatement", " dcmAssistant", "dmmarser", "dmmparser", "DcmBuilder", "dpmarser", "dgrStatement", " dcmBuilder", "dmmmparser", "dcmparser", "dcfStatement", "dromReader", "dcmAssistant", "decmParser", " dcmListener", "deromarser", "Dpmparser", "decmReader", "DcmParser", "dpmAdapter", " dpmParser", "dcmStatement", "dgrReader", " dpmPar", "DpmPar", "dmReader", "decmarser", "dpcAssistant", "DpmBuilder", "dmmReader", "decmparser", "drumParser", "dromarser", " dpmBuilder", " dcmPrivate", "dpcParser", " dpmAssistant", "dcmLoader", "DcmReader", "dromParser", "dmmmParser", " dcmparser", "dmmAdapter", "DpmParser", "drumReader", "dfmReader", "dpmReader", "dgrPar", "dcmReader", "dcfReader", "deromReader", "Dcmparser", "deromparser", "dcommParser", "dmparser", "drumPar", " dcmReader", "dcmarser", "dmarser", "dcmPrivate", "dpmparser", "dcmPar", "dmParser", "dmmmAdapter", "dpcPrivate", "dcfPar", "dromListener", "dcomParser", "dmodulePrivate", "DcmAdapter", "drumBuilder", "dfmBuilder", "dfmLoader", "dpmListener", "dcomLoader", "dpmPar", "dmoduleParser", "dpmParser", "dcfParser", "DcmPar", " dpmPrivate"], "ds": ["ls", "cs", "dos", "dl", "gs", "eds", "dh", "ils", "fs", "des", "vs", "ys", "da", "der", "sv", "s", "gd", "dds", "sets", " des", "as", "ads", "hd", "dq", "rs", "uds", "tes", "xs", "df", "os", "details", "ins", "pd", "dd", "services", "in", "bs", "Ds", "ods", "sys", "obs", "outs", "dt", "hs", "pers", " DS", "eps", "its", "js", "dat", "bd", "ps", "dx", "ks", "ss", "drivers", "sd", "d", "aos", "qs", "data", "ws", "DS", "db", "es", "ims", "ns"], "pdReader": ["ddHelper", "ddParser", "pdLoader", "xdHelper", "pdParser", "tdWriter", "xdLoader", "tdRead", "ddLoader", "vdLoader", "pdRead", "dpCar", "dpLoader", "ddWriter", "ddReader", "pdCar", "ddRunner", "dpRunner", "pedReader", "tdParser", "hdParser", "tdReader", "pedLoader", "pedCar", "hdRead", "pdRunner", "vdHelper", "xdReader", "pdHelper", "hdWriter", "ddRead", "xdWriter", "dpReader", "vdReader", "pedRunner", "hdReader", "ddCar", "vdWriter"], "out": ["over", "full", "on", " err", "err", "t", "str", "ins", "p", "ent", "outs", "ch", "writer", "log", "conn", "con", "co", "sum", "sw", "v", "o", "auto", "name", "status", "gen", "inv", "obj", "ex", "ou", "all", "id", "nt", "s", "cb", "c", "end", "txt", "os", "nr", "cn", "in", "desc", "conv", "serv", "raw", "inner", "outer", "pool", "cfg", "at", "net", "tmp", "list", "pos", "Out", "n", "en", "up", "io", "sys", "w", "js", "aos", "res", "data", "we", "OUT", "cache", "it", "output", "oss", "client", "gt", "one", "null", "screen", "go", "cmd", "to", "opt", "flush", "msg", "gr", "inter"], "dcmEncParam": ["dcmEnPar", "dcmEnVal", "dcmencCmd", "dcmEncVal", "dcmEnParam", "dcmencParam", "dcmEscPar", "dmmencParam", "dcmDecParam", "dmmEncCmd", "dcmEncCmd", "dcmencNum", "dmmEncMsg", "dmmencNum", "dmmEncPar", "dcmEncPar", "dcmEscNum", "dmmEnPar", "dcmDecCmd", "dcmEncMsg", "dcmEnNum", "dmmEnNum", "dcmEscVal", "dcmDecMsg", "dcmEscParam", "dmmEncParam", "dmmencCmd", "dmmEnParam", "dmmEncNum", "dcmEncNum", "dcmDecNum", "dcmencPar", "dcmencMsg", "dmmEncVal", "dmmencMsg"], "pdWriter": ["dpEditor", "PDReader", "tdWriter", "dpWriter", "pidWrite", "PDWriter", "pdwriter", "pidWriter", "PDWrite", "tdWriting", "tdReader", "PDEditor", "pidwriter", "pidWriting", "dpWrite", "tdwriter", "pcWriter", "pcWrite", "pdWrite", "pdWriting", "pcwriter", "tdWrite", "pdEditor", "pcWriting", "dpReader", "tdEditor"]}}
{"id1": "14390569", "id2": "942693", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"title": ["setup", "message", "header", "tip", "template", "heading", "type", "subject", "filename", " Title", "description", "holiday", "itle", "help", "t", "string", "summary", "padding", "parts", "Title", "html", "size", "hd", "term", "label", "lead", "details", "TIT", "layout", "password", "notice", "msg", "text", "question", "content", "metadata", "start", "hash", "name", "theme", "prefix"], "imageURL": ["mediaID", "ImageUrl", "imageString", "photoURI", "ImageURI", " imageString", "mediaURL", "imageURI", "photoID", "ImageURL", " imageURI", "ImageUR", "imageID", "photoUrl", "fileURL", "ImageID", "photoURL", "fileUrl", "photoString", "fileString", "imageUR", "mediaURI", " imageUR", "imageUrl", "photoUR", "fileURI", " imageUrl", "mediaUrl"], "jd": ["qd", "qbd", "jjd", "zad", "gd", "ujd", "Jc", "zsd", "qp", "djsd", "jdm", "jdo", "gbd", "JD", "qdo", "Jmd", "kbd", "jsd", "Jds", "gds", "jdt", " jdo", "ijd", "jsds", " jc", "djc", "javapd", "jjbd", "djd", "jad", "djad", "jsdm", "ajdm", "Jp", "kdt", "ujdt", "jjp", "ujmd", "jobd", "javad", "simd", "ajpd", "ujD", " jdt", "ajds", "ajd", "kds", " jad", "simdt", "kd", "zd", "jobdt", " jD", "ijD", "jmd", "jds", "simD", "javadm", "simmd", "djdo", "jD", "djds", "Jdt", "jsD", "Jd", "Jdo", "jspd", "jobdo", "Jbd", " jds", "kdo", "jpd", "jc", "jbd", "ijds", " jsd", "javads", "Jad", "jjD", "qD", "qds", "gdo", "ujad"], "jl": ["ij", "lv", "dl", "bol", " li", "isl", "jac", "li", "ln", "dj", "bj", "gn", "nl", "dll", "jin", "txt", "jet", "kj", "ell", "elle", "kel", "ibl", "abl", "Label", "rl", "il", "jj", "ja", "ijk", "igl", "elly", "lu", "uj", "yl", "mil", "jc", "jah", "kl", "js", "ji", " ol", "J", "kn", "dyl", "syn", "lp", "elt", "j"], "icon": ["ex", "iban", "icons", "ion", " fruit", " canvas", " ion", "ocon", " screen", "lock", " widget", "ICO", "iao", " Icon", "image", "nic", "fn", " ancestor", "Icon", "label", "cil", "png", "cn", "gc", "ic", "ico", "addon", " lang", "jc", "conv", " tip", "icol", "chron", "con", "conn", "\u4e2d", "fa", "eric", "pen", " captcha", "syn", "font", "pic", " intent", " conn"], "chooser": ["compose", "boose", "boosen", "Chooder", "Choose", "CHOose", "choerer", "composen", "compicer", " chooder", "composer", "choicer", "Choosen", "boerer", "Choicer", "pooder", "CHOoser", "poicer", "comperer", "CHOosen", "poose", "choose", "Chooser", "CHOicer", "booser", "pooser", " choicer", " choosen", " choose", "choosen", " choerer", "chooder"], "jp": ["ij", " sip", " np", "bp", " pl", " cp", " ja", "bj", " joint", " ap", " je", "jin", "p", " mp", "kj", "JP", "ja", "sp", " dj", " gp", "jc", "js", " pic", "btn", " ip", " sp", "np", "j", "pic"], "jb": ["qbd", "kjcb", "jcb", "kjb", "kjbd", "Jcb", " jcb", "qb", "Jbd", " jbd", "jbd", "Jb", "qcb"], "e": ["or", "it", "f", "m", "t", "s", "c", "n", "a", "p", "u", "en", "ed", "er", "w", "E", "te", "ie", "g", "es", "re", "event", "d", "v", "o", "Event", "ev", "ee"], "returnVal": [" returnVol", "responseValid", "getVAL", "returnValue", "getVol", "returnValid", " returnval", "getVal", "ReturnValue", "Returnval", "retValue", "retVAL", "returnVAL", " returnValid", " returnValue", " returnVAL", "returnval", "responseVol", "retval", "returnVol", "getValid", "responseVal", "ReturnVal", "responseVAL", "ReturnVAL", "retVal"], "file": ["library", "path", "user", "place", "channel", "full", "format", "foo", "or", "http", "type", "info", "open", "f", "be", "filename", "class", "fs", "core", "fp", "dir", "real", "stat", "link", "rule", "image", "word", "run", "page", "null", "source", "le", "h", "fe", "ile", "to", "handle", "angle", "tree", "il", "io", "document", "work", "valid", "body", "target", "report", "drop", "port", "FILE", "get", "status", "buffer", "resource", "model", "base", "create", "name", "db", "relation", "File", "local", "table"], "fileName": ["FILEExt", "taskFace", "filePath", "taskname", " fileSystem", "fileClass", "FileSystem", "FILENames", "imageFace", "entityName", "filename", "fileFace", " filePath", "taskPath", "ileName", "handleNAME", "fileSystem", "FILEName", "fileExt", "Filename", "FILENAME", "entitySet", "imagePath", "ilename", "fileNames", "ileClass", "FILESystem", "taskName", "handlename", "FileName", "fileSet", "imageNAME", "handleClass", "FilePath", "handleName", "FileExt", "ileNAME", " fileExt", "FileNAME", "imagename", " filename", " fileNames", " fileClass", "FileNames", "FileSet", "FILEPath", "FileFace", "entityPath", "entityNAME", " fileNAME", "FILESet", "fileNAME", "imageName"], "ext": ["external", "aux", "ex", "pat", "lib", "dir", "xt", "lex", "t", "sem", "exe", "Ext", "ix", "prot", "test", "req", "word", "end", "txt", "xp", "vert", "exc", "ord", "def", "cmd", "ct", "off", "len", "ag", "part", "ind", "typ", "exp", "desc", "enc", "cod", "hex", "ec", "cont", "eur", "EXT", "fr"], "i": ["is", "init", "gi", "qi", "id", "xi", "it", "info", "ci", "li", "I", "m", "di", "ai", "hi", "bi", "ii", "mi", "fi", "y", "phi", "iu", "status", "ori", "si", "print", "ei", "pi", "ti", "cli", "j", "ui", "index", "ini"], "doIt": ["didIs", "odoWhich", "donIt", "doneit", "doWhich", "diWhich", "diit", " doIs", " doYou", "doIT", "diHe", " doit", "waIt", "doit", "didYou", "waIT", "didIt", " doIT", "donYou", "doIs", "doneIT", "donIs", "waIs", "doneIt", "diIt", " doWhich", "donIT", " doHe", "odoIt", "doYou", "odoit", "odoHe", "didit", "doHe", "donit", "odoIT"], "src": ["rob", "gs", "rest", "init", "ptr", "http", "input", "sc", "url", "usr", "r", "tmp", "ser", "sec", "rx", "sr", "ource", "rc", "rt", "rb", "ctr", "https", "proc", "sq", "inst", "crop", "loc", "ins", "rs", "source", "from", "lb", "comp", "rl", "copy", "sh", "sys", "st", "sb", "conv", "impl", "sub", "trans", "ources", "ssl", "cont", "syn", "inner", "start", "rel", "sl"], "dest": ["iter", "rest", "gest", "out", "des", "usr", "comb", "output", "tmp", "dir", "Dest", "pot", "https", "slave", "proc", "origin", "cat", "loc", "source", "nom", "orig", "cp", "decl", "pipe", "way", "master", "est", "sys", "sp", "st", "desc", "coord", "target", "port", "foreign", "dat", "temp", "trans", "dist", "cont", "nw", "can", "mem", "rel", "local", "pas"]}}
{"id1": "6987642", "id2": "2398448", "code1": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "label": 0, "substitutes": {"encodePassword": ["EncodePassword", "EnodePassword", "encodePass", "encodepassword", "enlatePassword", "enodePassword", "encodedPass", "enlatePass", "encodedValue", "EnodePass", "EncodePass", "enodePass", "enodepassword", "enlatepassword", "EncodeValue", "encodedpassword", "EnodeValue", "Enodepassword", "Encodepassword", "encodeValue", "enodeValue", "enlateValue"], "password": ["message", "user", "path", "sword", "value", "pass", "input", "Password", "wd", "address", "database", "description", "login", "string", "padding", "email", "key", "word", "random", "expected", "p", "pattern", "username", "attribute", "token", "command", "shadow", "default", "text", "reset", "data", "name", "phrase", "prefix", "hello", "secret"], "md": ["ad", "nd", " mc", "cd", "mond", "dr", " mg", " ms", "dh", "mt", "red", "grad", "nt", "MD", "m", "mp", "pm", "rm", "bf", "der", "mk", "add", "exec", "mg", "hd", " dd", "mo", "mc", "df", " rm", " mo", "dd", "cmd", "pd", " cmd", "det", "msg", "mod", "ind", "sha", "mm", "hm", "ld", " mac", "bd", "od", "mn", "mb", "ke", "mand", "d", "metadata", "sd", " cd", " Md", " mt", "ms", "di", "sm", "dm"], "encodedPassword": ["encatedConnection", "encatedString", "encodingConnection", "encryptedpassword", "encryptedConnection", "ecodingString", "equodedpassword", "ecodedpassword", "encodedConnection", "ecodingPassword", "equodedConnection", "encatedPassword", "equatedUser", "encatedSecret", "encodedUser", "encachedPassword", "encodingString", "encodedString", "encatedpassword", "encodingSecret", "encodedpassword", "encodingPassword", "encodingUser", "encatedUser", "encachedpassword", "encachedString", "ecodingSecret", "equatedConnection", "ecodedPassword", "equodedPassword", "encodingpassword", "ecodedSecret", "encachedSecret", "ecodingpassword", "equatedPassword", "equodedUser", "encryptedUser", "encryptedPassword", "encodedSecret", "equatedpassword", "ecodedString"]}}
{"id1": "13757855", "id2": "755203", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"process": ["transform", "format", "display", "parse", "write", "save", "project", "task", "processing", "apply", "add", "load", "proc", "Process", "run", "processor", "handle", "loop", "step", "build", "render", "create", "execute", "replace", "filter", "call"], "tpl": ["tmplate", " tpp", "topl", "Tph", "timplate", "tuple", "ptpl", "ttplug", "stpg", "ttph", "tpr", "timpg", "stspl", "tsurtle", "templ", "tembl", "Tpp", " tph", "ttPL", "tmplates", " tPL", "tpp", "tspl", "tmpp", "atuple", "ptbl", "tbl", "otbl", " tplate", "stbl", "itPL", "ttbl", "tsPL", "Tld", " tbl", "terld", "Tspl", "ttpl", "timspl", " tplates", "Tpr", "TPL", "ptld", "stplug", "itpl", "tmpl", "turtle", "timopl", "atpl", "itplate", "Tbl", "ttopl", "Tplate", "tspr", " turtle", "terplate", "timbl", "otld", "atplate", "atld", "tplate", " tuple", "itbl", "timpl", "otplate", "ptplates", " tld", "stpl", "tempr", "Tpl", "typl", "stplate", "tsbl", "teruple", "Tplates", "tmPL", "otpl", "tPL", "tplug", "timplug", "tyPL", "tmbl", "tld", "stopl", "tpg", "terpl", "temPL", "ttpg", "tyurtle", "tplates", "tph"], "model": ["models", " Model", "M", "Document", "project", "m", "file", "md", "product", "record", "html", "object", "tree", " models", "document", "el", "Model", "parent", "log", "ml", "module", "content", "base", "data", "node"], "packageName": [" packageNames", "Packagename", "viewClass", "packageVersion", "packageClass", " packageFamily", " packagename", "groupNames", " packageRoot", "groupVersion", "viewRoot", "viewname", "pkgNames", "packageFamily", "groupName", "packageNames", "pkgVersion", " packageClass", " packageVersion", "pkgName", "PackageClass", "groupFamily", "PackageName", "viewName", "pkgFamily", "PackageRoot", "packagename", "packageRoot"], "outFileName": ["outImagename", " outFilenameType", "outImageName", " outFileType", " outFilename", " outTableTime", " outTableSize", " outFilenameName", "infileTime", "outFileNames", "outStreamName", "outFilenamePath", "inFileType", "outFName", "outFilenameSize", " outfileNames", "outImagePath", "outFileSize", " outfilePath", "outDirTime", "outImageSize", "outFilenamename", " outTableName", "outFilenameTime", "infileName", "outFNames", " outFileChain", "outFileTime", "outFilenameName", " outFileNames", "inFilePath", "outTablePath", "infileNames", "outFilename", " outFileTime", " outFilenameChain", "outStreamType", "outfilePath", "outFileChain", " outFilenameSize", "outTableSize", "inFileNames", " outfilename", "outTableChain", "outStreamPath", "outfileName", "outStreamTime", "outFPath", "outfilename", "outTableName", "outTableType", "infileType", "inFileName", "outFilenameNames", " outFilePath", "outFname", " outfileName", "outTablename", " outFilenamePath", "outDirName", "outFilePath", " outTablePath", "outFilenameChain", "outDirSize", "outfileNames", "outDirPath", "outfileChain", "outfileTime", "outStreamNames", "outFilenameType", " outFileSize", "infilePath", "outTableTime", "outfileType", " outFilenamename", "inFileTime", "outFileType"], "xsltParam": ["xltConf", "xsltParameter", "xltParam", "xmlParam", "xsslParameter", "xmlConf", "xsmlConf", "xsslConf", "xsmlParam", "xsqlParameter", "xsqlConf", "xmlParameter", "xsltConf", "xltParameter", "xsmlParameter", "xsqlParam", "xsslParam"], "artifact": ["partifacts", "arifact", "artificial", "Artifact", "Artifacts", "anificial", "ardifacts", " artificial", "ardificial", "ardifact", "partifact", "anifact", "ardificate", "anifacts", "artificate", "arifacts", "anificate", " artificate", " artifacts", "artifacts"], "destinationPath": ["destinatedKey", "termininationJar", "destensionDir", "origininatedPath", "destionpath", " destinationTarget", "descositoryPort", "destinationPort", "destinatedHome", "destitutionPoint", "destranceLog", "destensionPoint", "termininationTarget", "destinoPath", "destificationLocation", "delinationLog", "destinatedForm", "destositoryPort", "destinationDir", "estationPart", "identinateInfo", "destinatedPath", "destinateName", "destinationKey", "destensionTemp", "destinoKey", "destinateInfo", "termininerPath", "destacementName", "identinationKey", "destationPath", "destociationHome", "estinationTime", "DestensionHost", "destacementPath", "destinateUrl", "destinationPoint", "destinerHost", "destionPoint", "destesticJar", "estinoTime", "destesticPath", "delinationPoints", "destinatorPort", "destinatorPath", "origininationForm", "termininerTarget", "chaininatedPath", "chaininatedDriver", "delinateLog", "destinatorPoint", "destinateAt", "estionPoint", "destinerJar", "destinateDir", "estionpath", "destociationPath", "destinatedpath", "descositoryPath", "destacementKey", "identinatePath", "origininationNow", "destinationDisk", "destinationPart", "chaininationPath", "destinatorHost", "destinationHost", "DestinationPod", "generinationJar", "identinationInfo", "estationHost", "destificationDir", "estionPath", "identinateKey", "destinoName", "destinationTarget", "descinationParent", "termininerJar", "destociationDir", "destationLocation", " destociationpath", "destinantTemp", "destociationpath", "destositoryParent", "destationDir", "desturationTarget", "destATIONPath", "destinationSystem", "chaininationHome", "destinateKey", "destacementTime", "destATIONParent", "estinationHost", "destinatorpath", "destigationChain", "destinationLog", "destinatorPATH", "estinationKey", "estinationpath", "destociationPoints", "destitutionPATH", "descinationPath", "destigationPath", "destregationpath", "origininatedChain", "destventionDriver", "destionPATH", "desticationDir", "destinantPath", "DestensionPoint", "descinationHost", "destinatorKey", "destinationAt", "origininationPath", "destrancePoints", "destositoryPath", "destinerAt", "destinatePath", "DestinationDir", "destATIONHost", "estionPATH", "destinateNow", "destinationPATH", "estinationPATH", "DestensionTemp", "DestinationUrl", "destificationUrl", " destinationDisk", "destinatorParent", " destociationTarget", "desturationPath", "destinerTarget", "destinateTarget", "origininatedNow", "identinateChain", "destinateChain", "DestinationPoint", "descositoryParent", "identinationChain", " destociationDisk", "destinerPart", "destinationTime", "DestinationTemp", "estinoKey", "destociationHost", "destinoPoint", "destinateLog", "destinationHome", "destinerDir", "generinateAt", "destinerSystem", "identinationPath", "estationPath", "destventionDisk", "destinoDir", "destinationPoints", "destinationpath", "destregationDisk", "generinationPath", "destensionHost", "destranceForm", "DestinationLocation", "destociationLog", "destinationName", "destociationPoint", "destificationPath", "destinationUrl", "desticationPod", "generinatePath", "destinatedDisk", "destinatorChain", "destventionHome", "destociationForm", "termininationPath", " destociationPath", "descositoryHost", "destigationForm", "destinatedTarget", "DestinationPath", "DestificationUrl", "destationUrl", "delinationPath", "estationDir", "destesticSystem", "destinantPod", "destinatorInfo", "destationHost", "origininatedForm", "termininationpath", "chaininatedDisk", "destregationPath", "destinateLocation", "DestificationDir", "DestensionPod", "origininationChain", "delinationForm", "destositoryHost", "estinationPoint", "generinateJar", "destinationChain", "desticationPath", "desturationJar", "destATIONPort", "estinoPath", "delinateForm", "destensionPath", "estinoName", "destinationPod", "destinatePoints", "destinationJar", "destinationDriver", "desticationTemp", "destinatedNow", "destinationForm", "destventionPath", "destationPart", "destinateTime", "destensionPod", "destinatepath", "DestificationLocation", "destinationTemp", "estinationPart", "destitutionPath", "delinatePath", "destesticAt", "desturationpath", "DestinationHost", "estinationName", "generinationSystem", "destinateHost", "descinationPort", "destrancePath", "destionPath", "DestensionDir", "destinatedDriver", "destinatedInfo", "DestensionPath", "destitutionpath", "generinationAt", "destinationParent", "chaininatedHome", "generinateSystem", "destinateSystem", "destociationDisk", "destregationTarget", " destinationpath", "estinationDir", "destociationDriver", "destinoHost", "destinatedChain", "destinateJar", "destinoTime", "destociationTarget", "destinateForm", "destigationNow", "estinationPath", "destinatePart", "destinerPath", "destinantDir", "termininerpath", "chaininationDisk", "destinationNow", "delinatePoints", "chaininationDriver", "destinationInfo", "destinerpath", "destinationLocation", "DestificationPath"], "in": ["In", "input", "id", "info", "r", "f", "file", "m", "IN", "reader", "t", "l", "bin", "c", " IN", "ins", "n", "io", "w", "din", "i", "d", "inner", "o", "doc"], "out": ["inv", "obj", "b", "ex", "or", "OUT", "net", "ou", "conf", "cache", "all", "it", "write", "dis", "f", "err", "output", "nt", "oe", "ln", "list", "file", "t", "s", "l", "client", "c", "Out", "n", "null", "ins", "os", "screen", "go", "nr", "p", "cn", "u", "cmd", "gen", "to", "up", "io", "sys", "ger", "outs", "msg", "w", "report", "ch", "writer", "e", "log", "conn", "con", "raw", "gr", "co", "print", "aos", "res", "o", "outer", "inner", "v", "can", "println", "cfg"], "root": ["group", "id", "r", "context", "ok", "_", "m", "Root", "config", "dir", "parents", " roots", "se", "de", "scope", "p", "roots", "graph", "def", "tree", "dump", "initial", "json", "parent", "impl", "New", "chain", "Template", "start", "create", "data", "name", "node", "println", "table", "child"]}}
{"id1": "4982745", "id2": "17083703", "code1": "    protected JSONObject doJSONRequest(JSONObject jsonRequest) throws JSONRPCException {\n        HttpPost request = new HttpPost(serviceUri);\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, getConnectionTimeout());\n        HttpConnectionParams.setSoTimeout(params, getSoTimeout());\n        HttpProtocolParams.setVersion(params, PROTOCOL_VERSION);\n        request.setParams(params);\n        request.addHeader(\"Authorization\", \"Basic \" + Base64Coder.encodeString(serviceUser + \":\" + servicePass));\n        HttpEntity entity;\n        try {\n            entity = new JSONEntity(jsonRequest);\n        } catch (UnsupportedEncodingException e1) {\n            throw new JSONRPCException(\"Unsupported encoding\", e1);\n        }\n        request.setEntity(entity);\n        try {\n            long t = System.currentTimeMillis();\n            HttpResponse response = httpClient.execute(request);\n            t = System.currentTimeMillis() - t;\n            Log.d(\"json-rpc\", \"Request time :\" + t);\n            String responseString = EntityUtils.toString(response.getEntity());\n            responseString = responseString.trim();\n            JSONObject jsonResponse = new JSONObject(responseString);\n            if (jsonResponse.has(\"error\")) {\n                Object jsonError = jsonResponse.get(\"error\");\n                if (!jsonError.equals(null)) throw new JSONRPCException(jsonResponse.get(\"error\"));\n                return jsonResponse;\n            } else {\n                return jsonResponse;\n            }\n        } catch (ClientProtocolException e) {\n            throw new JSONRPCException(\"HTTP error\", e);\n        } catch (IOException e) {\n            throw new JSONRPCException(\"IO error\", e);\n        } catch (JSONException e) {\n            throw new JSONRPCException(\"Invalid JSON response\", e);\n        }\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doJSONRequest": ["doJSONResponse", " doHTTPRequest", "dojsonResponse", "doCustomQuery", " doJSONQuery", "doHTTPResponse", " doHTTPConnection", "doCustomResponse", "doJSONConnection", "doHTTPRequest", "dojsonRequest", " doJSONConnection", " doHTTPResponse", "doCustomRequest", "dojsonQuery", "doHTTPQuery", " doHTTPQuery", "doCustomConnection", " doJSONResponse", "doJSONQuery", "doHTTPConnection", "dojsonConnection"], "jsonRequest": ["jsonPost", "JSONResponse", " jsonPost", "sonObject", "sonResponse", "jsonObject", "JSONPost", "sonPost", "sonRequest", " jsonObject", "rawRequest", "JSONRequest", "JSONObject", "rawObject", "rawResponse", "rawPost"], "request": ["setup", "person", "message", "transform", "http", "QUEST", "input", "update", "query", "search", "application", "url", "address", "context", "project", "instance", "first", "reference", "use", "add", "quest", "record", "client", "job", "self", "req", "Request", "this", "q", "pair", "object", "close", "copy", "xml", "initial", "document", "command", "requ", "report", "post", "position", "get", "remote", "re", "insert", "remove", "condition", "question", "complete", "resource", "order", "create", "start", "name", "claim", "begin", "hello", "reset", "call"], "params": ["headers", "pres", "gs", "ams", "ctx", "actions", "points", " parameters", "Parameters", "amps", "prop", "chains", "phys", "cap", "tags", "options", "tmp", "param", "pkg", "properties", "parts", "pins", "as", "proc", "caps", "groups", "types", "cas", "rs", "details", "ars", "cp", "multi", "services", "settings", "pas", "sys", "spec", "json", "par", "eters", "pers", "posts", "eps", "mm", "ports", "styles", "parent", "ps", "members", "shape", "stats", "pps", "names", "lines", "terms", "pool", "ims", "changes", "rules"], "entity": ["obj", "person", "user", "ce", "note", "component", "query", "type", "application", "iso", "ITY", "oe", "shell", "error", "encrypted", "Entity", "email", "entry", "ae", "quote", "null", "le", "details", "om", "ent", "object", "environment", "ell", "pe", "ct", "eme", "xml", "document", "iam", "el", "valid", "json", "ity", "em", "enc", "e", "buffer", "account", "event", "connection", "resource", "orm", "metadata", "code", "model", "security", "create", "available", "comment", "ip", "activity"], "t": ["tm", "pt", "at", "tt", "ts", "tp", "it", "tw", "tc", "tick", "f", "mt", "T", "z", "nt", "m", "tf", "s", "l", "ut", "iat", "qt", "x", "ta", "c", "n", "txt", "p", "ct", "tim", "det", "dt", "y", "st", "w", "wt", "g", "e", "temp", "duration", "i", "vt", "total", "d", "et", "now", "ti", "elt", "ot", "j", "time"], "response": ["reply", "message", "out", "application", "output", "description", "frame", "network", "success", "client", "answer", "onse", "memory", "next", "one", "given", "object", "environment", "resp", "tree", "version", "document", "result", "json", "sequence", "respond", "body", "report", "e", "remote", "re", "connection", "res", "Response", "data", "status", "service", "reset"], "responseString": ["responseArray", "messageString", "replyString", "outputArray", "ResponseStr", "messageStr", "replySystem", " responseText", " responseObject", "ResponseObject", "ResponseText", "ResponseString", "outputText", "messagestring", "ResponseArray", "outputString", "answerString", "replyStr", " responseStr", "resultstring", "replystring", "responseSystem", "ResponseSystem", "responseText", "resultObject", "responseStr", "Responsestring", " responseSystem", "resultStr", "responsestring", "responseObject", "outputStr", "answerstring", "resultString", "messageObject", "answerStr", "answerObject", " responsestring", " responseArray"], "jsonResponse": ["jsonData", "sonResp", " jsonAnswer", "sonStatus", "sonAnswer", "sonError", "JSONResponse", "jsonresponse", "csvResp", "xmlError", "JSONResp", " jsonResp", "jsonStatus", " jsonData", "sonresponse", "sonObject", "sonResponse", "sonData", "xmlRequest", "JSONAnswer", "jsonObject", "sonRequest", " jsonObject", "JSONresponse", "xmlAnswer", "xmlResp", "jsonAnswer", "JSONRequest", "JSONObject", " jsonStatus", "csvResponse", "jsonResp", "JSONData", "xmlResponse", "csvStatus", "csvAnswer", " jsonresponse", "xmlObject"], "jsonError": ["jsonEvent", "sonError", "javascriptQuery", "JSONResponse", "jEr", "jsonEr", "javascriptEr", " jsonQuery", "javascriptAuth", "sonResponse", "JSONQuery", "JSONEr", "sonQuery", "jAuth", "JSONEvent", "jsonAuth", "sonEvent", "jsonQuery", "jError", "javascriptError", " jsonEvent", "jQuery", "JSONError", "JSONAuth"]}}
{"id1": "18339787", "id2": "8320469", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 0, "substitutes": {"reload": ["disLoad", "display", "replay", "ReLoad", "overLoad", "disload", "Reload", "Replay", "reLoad", "Rebuild", "disbuild", "overplay", "overbuild", "rebuild", "overload"], "currentDate": ["CurrentYear", " currentYear", "CurrentDate", "currentDoc", " currentDoc", "currentData", " currentTime", " CurrentDoc", "reportedData", "reportedDoc", "reportedYear", " CurrentData", "currentYear", "currentTime", "CurrentTime", "reportedDate", " CurrentTime", " currentData", " CurrentDate", "reportedTime"], "xpath": ["expr", "xxpath", "expath", "txpath", "txPath", "ixpath", "xxpt", "rxpr", "xpr", "dxpath", "wprop", "dxPath", "expointer", "xxtrace", "ixpointer", " xath", "wwhere", "axpointer", " xtrace", " xpointer", " xpr", "xgraph", "rxpath", "xprop", "ixpt", "txgraph", "dxprop", "exPath", "ixath", "axwhere", "rxpointer", "xwhere", "axgraph", "wpath", " xPath", "xxwhere", " xgraph", "axpath", "axPath", "xath", "xtrace", "rxPath", "xPath", "xxath", " xprop", " xwhere", "xpt", "xxpointer", "wPath", "txpointer", "axtrace", " xpt", "xpointer", "dxwhere"], "docBuilderFactory": ["docBuildFactory", "docBuilderFactor", " docBuilderFactor", "docMakerInterface", "docBuilderFact", "docMakerFact", "docPathFactory", "docPathClass", " docBuilderClass", "docBuilderInterface", " docBuilderInterface", "docPathFact", "docBuilderClass", "docMakerFactor", "docBuildFact", "docMakerFactory", "docPathFactor", "docBuildClass", "docBuildInterface", "docBuildFactor", " docBuilderFact"], "docBuilder": ["DocBu", " DOCParser", "docBuild", " DOCBu", "docParser", "docBu", "documentBuilder", " DOCBuilder", "docbuilder", "documentBu", "DocumentParser", "DocumentBu", " docBuild", "DocBuilder", "DocBuild", "Docbuilder", " docBu", " docbuilder", " DOCBuild", "DocumentBuilder", "DocumentBuild", " docParser", "documentBuild", "documentbuilder"], "conn": ["ls", "obj", "Conn", "Connection", "ctx", "cert", "out", "open", "comm", "opens", "nt", "link", "oss", "ann", "client", "cb", "c", "loc", "n", "gate", "cp", "close", "cn", "ct", "cmd", "resp", "addr", "handle", "cm", "nc", "lang", "iw", "socket", "ch", "conv", "enc", "con", "jp", "ssl", "connection", "syn", "res", "ws", "connect", "db"], "url": ["b", "ls", "obj", "dl", "cert", "net", "http", "URL", "sql", "open", "f", "r", "abs", "l", "ur", "link", "str", "https", "browser", "gl", "client", "web", "nl", "window", "n", "lb", "u", "cp", "util", "char", "rl", "socket", "sb", "ref", "Url", "con", "mb", "ssl", "connection", "ul", "bel", "base", "rel", "ll", "mount", "sl"], "xml": ["xf", "tm", "path", "item", "dl", "full", "format", "cert", "template", "parse", "http", "rss", "input", "context", "output", "file", "list", "config", "php", "zip", "news", "str", "feed", "email", "html", "x", "image", "page", "txt", "xp", "details", "p", "tree", "document", "el", "element", "json", "text", "wt", "body", "eps", "pdf", "tml", "mail", "log", "ml", "raw", "event", "date", "content", "print", "model", "dom", "response", "ws", "data", "node", "px", "doc"], "exchangeRateDate": ["exactionrateTime", "exactionrateDate", "exchangeRangeTime", "exchangerateDay", "exchangeRateDays", "exchangeRangeDays", "exactionRateDays", "exchangeCountDay", "exchangeCountTime", "excelRateTime", "exchangeTimeDate", "exchangeRateTime", "exchangeCountMessage", "excelrateMessage", "exchangeRangeDay", "exchangeTimeDay", "excelrateTime", "exactionrateDay", "exchangeTimeTime", "exchangeCountDate", "excelrateDay", "exchangeTimeDays", "exactionRateDay", "exactionRateTime", "exactionrateDays", "excelRateMessage", "exchangerateDate", "exchangeRuleTime", "exchangeRuleMessage", "exactionRateDate", "exchangeRangeDate", "exchangerateMessage", "exchangeRateDay", "excelRateDay", "exchangeRuleDate", "exchangerateDays", "excelRateDate", "exchangeRuleDay", "exchangerateTime", "exchangeRateMessage", "excelrateDate"], "currenciesNode": ["currenciesEvent", "CurriesN", "CurriesEvent", "curriesCard", "currenciesN", "curthsNode", " currenciesChan", "currsNode", "cururrenciesChan", "currenciesList", "currencyNode", " currenciesCard", "curriersList", "currenciesCard", "curthsN", "curthsList", " curriesChan", "curriersN", "curreditsN", "CurrenciesN", "curriersCard", "currencyCard", "curriesChan", "CurriesNode", "curreditsList", "currsList", "cururrenciesNode", " curriesNode", "currsEvent", "cururrenciesCard", "CurrenciesEvent", "curriersNode", "currsN", "curreditsNode", "curthsCard", "currenciesChan", "CurriesList", "currencyChan", "curriesList", "curriesN", "CurrenciesList", "CurrenciesNode", "curriesEvent", "curreditsEvent", "curriesNode", "CurrenciesCard", "CurriesCard", " curriesCard"], "currencies": ["constractions", "corries", "crencies", "charrates", "constrencies", "charurrencies", "corarters", "curarters", "charables", " cururrencies", "cables", "correncies", "chries", "carries", "cururrencies", "carrencies", "Currencies", "Curries", "chractions", " curries", "carractions", "crates", "charrencies", "curries", "Cururrencies", "corurrencies", "chpora", "chrencies", "constpora", "corrates", "corables", "curables", "constries", "carpora", "currates", "Curarters", "curractions", " curarters", "curpora"], "i": ["ami", "is", "init", "gi", "id", "qi", "xi", "it", "\u0438", "ci", "li", "ms", "I", "m", "oi", "ai", "ix", "iq", "gu", "ki", "x", "bi", "c", "key", "ri", "n", "ii", "a", "mi", "multi", "u", "uri", "ic", "in", "batch", "index", "io", "y", "sequence", "phi", "status", "sim", "ie", "e", "ji", "me", "si", "yi", "span", "pi", "o", "ti", "cli", "j", "ui", "di", "ini", "ip"]}}
{"id1": "8320469", "id2": "14785308", "code1": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"md5": ["sha2", "MD6", "MD5", "sha5", " md6", "sha6", " md2", "md4", " md4", "sha4", "md2", "MD4", "MD2", "md6"], "text": ["message", "path", "read", "pt", "title", "input", "aut", "binary", "output", "translation", "nt", "config", "t", "string", "str", "email", "confirmed", "ext", "TEXT", "image", "published", "word", "txt", "source", "pattern", "password", "document", "bound", "msg", "hex", "log", "buffer", "event", "content", "print", "code", "Text", "data", "name", "prefix", "font", "required", "secret"], "encrypted": ["rypted", "message", "bytes", "loaded", "marked", "empty", "secure", "ended", "verified", "printed", "rounded", "written", "seed", "checked", "connected", "confirmed", "qualified", "created", "tested", "locked", "interrupted", " secured", "approved", "ressed", "added", "ed", "sent", "used", "password", "signed", "unsigned", "pdf", "enc", "colored", "hex", "packed", "updated", "initialized", "ebook", "rendered", "installed", "plain", "Secure", "required", "secret", "generated"], "md": ["amd", "ng", "nd", "cd", "dr", "dh", "ds", "del", "mt", "red", "grad", "db", "MD", "m", "pm", "dir", "rm", "and", "der", "mp", "mk", "exec", "met", "down", "hd", "managed", "mc", "df", "pd", "cmd", "dd", "det", "msg", "mod", "ind", "mm", "ld", "med", "bd", "od", "mn", "mb", "mand", "d", "sd", "mg", "ms", "di", "sm", "dm"]}}
{"id1": "7846688", "id2": "14785308", "code1": "    public void postData(String protocol, String host, String form, String data) throws Exception {\n        if ((protocol == null) || (protocol.equals(\"\"))) {\n            protocol = DEFAULT_PROTOCOL;\n        }\n        if ((host == null) || (host.equals(\"\"))) {\n            host = DEFAULT_HOST;\n        }\n        if (form == null) {\n            form = DEFAULT_FORM;\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Invalid data\");\n        }\n        URL url = new URL(protocol, host, form);\n        URLConnection con = url.openConnection();\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setUseCaches(false);\n        con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-length\", String.valueOf(data.length()));\n        PrintStream out = new PrintStream(con.getOutputStream(), true);\n        out.print(data);\n        out.close();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        while (in.readLine() != null) {\n        }\n        in.close();\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"postData": ["PostData", "storedata", "storeString", "storeData", "postString", "postText", " PostData", "storeText", " PostString", " Postdata", "postdata", " PostText", "Postdata", "PostString", "PostText"], "protocol": ["proolean", "protol", "roturation", "rototype", "protport", "pronocol", "terminocol", "pronolean", "prace", "horotype", "retotype", "terminology", "protology", "Protology", "procol", "retology", "Protolean", "pronport", "protace", "topotype", "rotology", "topavior", "terminuration", "topolean", "protavior", "pronotype", "prport", "rotol", "proace", "proport", "Protace", "terminotype", "Protport", "Protavior", "horocol", "horavior", "protolean", "Protol", "returation", "topocol", "Prototype", "prototype", "proturation", "retocol", "proocol", "topol", "Protocol", "topology", "prootype", "protype", "rotocol", "horolean"], "host": ["path", "check", "th", "cert", "format", "net", "http", "human", "on", "where", "bind", "campus", "address", "subject", "context", "home", "project", "localhost", "hop", "Host", "dir", "help", "mac", "https", "client", "root", "system", "org", "loc", "domain", "serial", "graph", "hook", "h", "uri", "control", "addr", "handle", "pattern", "ost", "hand", "height", "console", "sche", "target", "port", "ca", "remote", "build", "ether", "chain", "kind", "server", "hash", "other", "node", "prefix", "topic", "arch", "ip"], "form": ["user", "path", "transform", "th", "ce", "auth", "format", "template", "prop", "input", "component", "query", "type", "f", "file", "list", "col", "config", "reg", "fc", "request", "session", "zip", "brand", "forms", "params", "proc", "c", "term", "loc", "row", "stream", "from", "Form", "FORM", "ent", "ac", "ct", "cmd", "table", "control", "act", "method", "pattern", "password", "part", "command", "field", "mod", "old", "hidden", "body", "text", "ch", "post", "tab", "raw", "orm", "co", "other", "fr", "arch"], "data": ["message", "bytes", "dl", "empty", "block", "value", "format", "draw", "cache", "input", "all", "output", "description", "any", "t", "string", "str", "what", "size", "zero", "n", "one", "missing", "row", "action", "def", "batch", "area", "password", "default", "result", "valid", "text", "DATA", "body", "none", "dat", "na", "no", "post", "only", "buffer", "ata", "raw", "chain", "content", "auto", "response", "rel"], "url": ["ls", "dl", "http", "URL", "r", "open", "bl", "abs", "l", "ur", "gl", "str", "fl", "link", "browser", "job", "nl", "arl", "loc", "hl", "mount", "char", "il", "xml", "www", "cal", "sb", "build", "Url", "re", "log", "conn", "ssl", "ul", "bel", "atl", "rel", "ll", "pl", "sl", "call"], "con": ["com", "sin", "Conn", "cert", "conf", "ver", "open", "comm", "ln", "ain", "Con", "col", "fc", "cond", "pc", "bc", "cos", "fl", "bin", "cl", "proc", "c", "fn", "en", "cn", "don", "cone", "fac", "coll", "canon", "act", "cm", "nc", "soc", "const", "cal", "conv", "CON", "dial", "sub", "ctrl", "conn", "connection", "cont", "co", "ran", "pen", "cons", "can", "cur", "cf", "connect", "un", "call"], "out": ["obj", "put", "group", "check", "net", "OUT", "ou", "all", "write", "output", "ln", "list", "help", "cos", "pretty", "oss", "bin", "success", "client", "summary", "Out", "n", "null", "os", "screen", "en", "cn", "to", "flush", "ao", "io", "outs", "set", "body", "writer", "conv", "OU", "log", "re", "conn", "gr", "co", "inner", "aos", "print", "o", "outer", "can", "res", "comment", "ro"], "in": ["In", "read", "iter", "check", "is", "or", "on", "input", "rin", "all", "win", "al", "r", "f", "info", "it", "ain", "IN", "inn", "reader", "inf", "bin", "ai", "ins", "inc", "from", "en", "ic", "up", "io", "rec", "el", "ind", "old", "oin", "din", "cin", "mn", "i", "gin", " din", "sum", "inner"]}}
{"id1": "6906419", "id2": "18202328", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["encryptionString", "enccryptString", "encryptedpassword", "decryptString", "encryptionPassword", "decryptPassword", "encryptString", "encryptedPass", "encryptedString", "decryptedString", "enccryptPassword", "encryptPass", "encryptpassword", "enccryptpassword", "decryptedPass", "enccryptPass", "decryptPass", "decryptedPassword", "decryptedpassword", "encryptionPass", "decryptpassword", "encryptedPassword", "encryptionpassword"], "password": ["message", "user", "sword", "auth", "value", "pass", "input", "Password", "wd", "address", "database", "description", "login", "string", "padding", "email", "wordpress", "key", "word", "pattern", "username", "attribute", "token", "command", "shadow", "default", "text", "reset", "print", "data", "name", "phrase", "prefix", "hello", "secret"], "digest": ["decest", "dest", "minist", "Digester", " digEST", "digEST", "digester", "dested", "hashEST", "persested", " digse", "minester", "persester", "digested", "Digist", "Digest", "dester", "minested", "dse", "hashse", "Digse", "digist", "decse", "hashester", "persest", "persist", "decester", "decested", "DigEST", "Digested", " digester", "digse", "hashest", " digested", "minest"], "hash": ["match", "block", "hz", "check", "cache", "where", "shift", "all", "search", "query", "array", "address", "map", "ash", "here", "hed", "ashes", "mac", "ah", "oh", "test", "html", "memory", "score", "alt", "mask", "host", "share", "h", "esh", "have", "handle", "sh", "attribute", "height", "hist", "report", "sha", "has", "hex", "stock", "dig", "Hash", "rh", "history", "total", "sum", "print", "her", "filter", "square", "table"], "buf": ["b", "agg", "block", "foo", "forge", "uf", "mu", "cap", "usr", "func", "tmp", "fam", "pkg", "bc", "rb", "bo", "queue", "cb", "printf", "etc", "Buffer", "window", "font", "bg", "txt", "br", "cv", "img", "bu", "cmd", "hung", "batch", "off", "box", "bag", "bar", "msg", "alph", "conv", "bh", "nb", "Buff", "buffer", "mb", "vec", "fb", "cf", "buff", "np", "ob", "db", "var", "pool", "pb"], "i": ["b", "ex", "is", "init", "my", "gi", "id", "qi", "xi", "it", "ski", "info", "ci", "li", "f", "\u0438", "I", "m", "t", "oi", "di", "ai", "ix", "iq", "hi", "ri", "x", "bi", "c", "key", "ii", "n", "a", "q", "go", "u", "multi", "mi", "uri", "ic", "in", "to", "major", "io", "y", "ind", "json", "exp", "slice", "im", "phi", "iu", "sim", "g", "e", "ie", "ji", "get", "conv", "me", "si", "print", "v", "ei", "pi", "zi", "ti", "cli", "point", "j", "ui", "index", "ini", "ip"], "halfbyte": ["quarterpage", " halfpair", "Halfchannel", "leftbuffer", " halfnode", "halfbuffer", "Halfbuffer", " halfbuffer", "Halfbyte", "phychar", "Halfpiece", "phypiece", "Halfbytes", " halfletter", "phybytes", " halfpage", "Halfcoin", "phybyte", " halfbytes", "Halfpage", "halfpage", "quarterlen", "leftchar", "halfchar", "phypixel", "quarterpair", "quarterword", "Halfpixel", "halfword", "halflen", "phypair", "halfcoin", "phylen", "halfletter", "quarterpixel", " halfcoin", "leftbyte", "halfbytes", "halfpair", "halfpixel", "quarterchar", " halfchannel", "Halfchar", " halflen", "Halfletter", " halfpiece", "halfpiece", "leftnode", "halfnode", "quartercoin", " halfchar", "quarterbyte", "quarterchannel", "quarterletter", "Halfword", " halfpixel", " halfword", "halfchannel", "Halfnode"], "two_halfs": ["two_turnups", "two_enthalsets", "two_shakes", "two_halfisters", "two_enthalss", "two_shakess", "two_ledss", "two_leds", "two_parenls", "two_enthals", "two_roundls", "two_turni", "two_roundups", "two_rounds", "two_ledsets", "two_enthalisters", "two_roundi", "two_pareni", "two_halfls", "two_parens", "two_parenups", "two_halfss", "two_shakesets", "two_turnls", "two_halfsets", "two_turns", "two_halfi", "two_halfups", "two_shakeisters", "two_ledisters"]}}
{"id1": "8430178", "id2": "22264586", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpFiles", "copyFiles", "CopyFile", "cpFile", " copyLine", "CopyPath", "CopyFiles", "copyLine", "cpPath", " copyFiles", "copyPath", "cpLine", " copyPath", "CopyLine"], "source_name": ["source_NAME", "source_format", "sourcePlocal", "source_case", "sourceEName", "src_file", "src_format", "sourceptName", "source_word", "source_Name", " source_word", "source_check", "sourceEname", "source_names", "sourceptname", "sourceEcase", "source09name", "src_case", "source_link", "Source_NAME", "source09file", "sourceEnames", "Source_name", "src_name", "sourceptcheck", "src_link", "source_local", " source_names", "src_names", "Source_local", "sourcePname", "src_Name", "src_check", "source09names", "sourcePNAME", "source09link", "sourceptnames"], "dest_name": ["Dest_name", "destipfile", "source_NAME", "dest__names", "dest9Name", "destityadmin", "dest_common", "destityname", "dest_NAME", "destationadmin", " dest_file", "Dest_Name", "Dest_admin", "destipcreate", "dest9name", "destationcommon", "src_file", "Dest_group", "dest_names", "start_Name", "destaxynam", "src_create", "startitycommon", "dest_create", "source_Name", "source_nam", "startityname", "dest_key", "dest__size", "source_names", "destationName", "dest_no", "dest_nam", "destipname", "dest9admin", "dest_file", "destaxyName", "dest_Name", "startityName", "destitycommon", "dest__key", "dest_time", " dest_min", "destaxyname", "start_common", "dest_size", "dest_id", " dest_time", "dest_min", "src_name", "destityName", "startityadmin", " dest_size", "start_admin", "destaxynames", "dest9group", "start_name", "src_id", "dest_admin", "destationname", " dest_Name", "dest_group", "dest__name", " dest_no", "destipid", " dest_key", " dest_names"], "source_file": ["sourcepyservice", "sourcephpstream", "ource_class", "site_le", "ource_file", "source2entry", "src_stream", "site_stream", "sourcepyle", "sourceistlink", "source_time", "src_file", "source___stream", "site___le", "sourcephpfile", " source_link", "source_path", "source___class", "sourcephpservice", "source_entry", "source___le", "sourceistid", " source_info", "source_stream", "source___service", "source___file", "site_file", "source1path", "sourcepyfile", "source_le", " source_id", "source2info", "source_link", "source_id", "source1file", "ource_File", "source___time", "source_class", "sourcepystream", "sourceistfile", "src_name", "site___service", "src_path", "source1stream", "sourceistname", "ource_time", "sourcephple", "source2file", "source1name", "site___stream", "site_service", "source___File", "source_service", "source_File", " source_entry", "source_info", "site___file"], "destination_file": ["destrant_file", "destrantJfile", "destination____file", "destinate_ile", "destination__db", "destination_path", "destrant_fp", "destinationJfp", "destinant____File", "destination_dir", "destrant_image", "destination_do", "destinate_do", "destinant_db", "destinate_dir", "destination_ile", "destination_port", "destification_file", "destrantJpath", "destinant_File", "destinationJimage", "destination_domain", "destinant____db", "destrantJimage", "destinant_fp", "destinant_link", "destinate_file", "destinant_file", "destination____File", "destrant_path", "destination_File", "destination_image", "destination_db", "destination_fp", "destinant____domain", "destinationJfile", "destination_link", "destination__file", "destination____domain", "destination__File", "destinant____file", "destification_port", "destrantJfp", "destification_path", "destinant_port", "destination__domain", "destinationJpath", "destination____db", "destification_ile", "destinant_domain"], "source": ["dest", "SOURCE", "iter", "ce", "script", "template", "sin", "src", "title", "note", "store", "or", "out", "input", "search", "query", "Source", "argument", "class", "file", "session", "ser", "config", "reader", "join", "ource", "use", "product", "cause", "directory", "client", "origin", "system", "feature", "image", "scope", "from", "proxy", "object", "major", "tool", "unit", "copy", "master", "site", "existing", "sequence", "set", "shadow", "target", "ie", "parent", "ources", "connection", "resource", "content", "server", "start", "sample", "base", "volume", "status", "service", "local", "secret"], "destination": ["methodinator", "restinate", "destification", "origininated", " destinated", "gestinated", "Destinator", "origininator", " destinator", "termininated", "gestination", "targetion", "destinated", "restinator", "restinated", "terminination", " destication", "targetinations", "Destinated", "originification", "estination", "gestociation", "gestinator", "targetification", "restion", " destation", "estication", "targetociation", "destinator", "estinated", "destication", "coordinated", "destion", "restation", "coordination", "destation", "targetinated", "targetinator", "coordinate", "destinate", "targetination", "alterninator", "alterninate", "Destinations", "methodinate", "restination", " destinate", "methodinated", "coordication", "terminociation", "methodination", "destinations", "Destation", "destociation", " destification", "originination", "alterninated", "termininator", "Destination", "alternination", "restinations", "estinate", "Destion"], "buffer": ["b", "read", "message", "block", "iter", "cache", "binary", "context", "paste", "frame", "append", "Buffer", "window", "stream", "batch", "document", "command", "sequence", "length", "text", "bb", "buf", "transfer", "base", "buff", "comment", "table"], "bytes_read": [" bytes_written", "bytesunRead", "bytes2read", "bytesunwritten", "bytes_left", " bytes_left", "bytes_written", "bytes2Read", "bytesunread", "bytesunleft", " bytes_Read", "bytes_Read", "bytes2written", "bytes2left"], "in": ["In", "read", "user", "is", "conf", "out", "input", "rin", "all", "it", "id", "r", "err", "doc", "std", "file", "IN", "inn", "reader", "t", "add", "l", "inf", "bin", "client", "ar", " IN", "stream", "ins", "n", "from", "p", "en", "ic", "io", "ind", "body", "din", "mm", "isin", "get", "log", "nin", "cin", "mn", "con", "gin", "sum", "inner", "diff", "ini"], "response": ["reply", "message", "remember", "block", "value", "format", "query", "application", "output", "description", "request", "relation", "echo", "network", "success", "python", "vector", "entry", "answer", "onse", "continue", "window", "zero", "one", "page", "exit", "resp", "ping", "offer", "version", "command", "result", "notice", "json", "sequence", "respond", "bye", "line", "question", "hello", "connection", "print", "res", "example", "Response", "sample", "hash", "data", "status", "choice", "reset", "respons"], "parentdir": ["parentfolder", "fatdirect", "rootfolder", "parentDir", "masterDir", " parentdirectory", "parentdirect", "Parentdir", "fatdir", "masterfile", " parentfile", "rootdir", "Parentdirectory", "masterdir", "ParentDir", " parentDir", " parentdirect", " parentfolder", "parentd", "rootd", "rootdirectory", "fatdirectory", "parentdirectory", "rootDir", " parentd", "fatd", "Parentfile", "parentfile", "rootdirect", "masterdirectory", "Parentfolder"]}}
{"id1": "16079868", "id2": "4531653", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"readIntoList": ["readIntolist", "readIntintolist", "readintoMap", "readintoMenu", "readintintoMap", "readintintoList", "readIntTolist", "readIntintoList", "readintintolist", "readintintoMenu", "readIntIntMenu", "readIntIntList", "readintoList", "readIntToMenu", "readIntIntlist", "readIntoMap", "readintolist", "readIntintoMap", "readIntoMenu", "readIntintoMenu", "readIntIntMap", "readIntToMap", "readIntToList"], "url": ["b", "mol", "rect", "dl", "cert", "http", "URL", "input", "id", "open", "address", "r", "f", "file", "l", "ur", "link", "string", "str", "browser", "web", "nl", "window", "image", "loc", "domain", "from", "uri", "char", "xml", "el", "ref", "ret", "log", "Url", "mail", "ssl", "resource", "location", "bel", "name", "ll", "mount", "hub"], "list": ["block", "group", "collection", "is", "format", "lists", "cache", "out", "all", "type", "info", "relation", "map", "rm", "m", "t", "add", "l", "network", "summary", "record", "top", "test", "detail", "n", "label", "p", "batch", "dict", "tree", "listed", "part", "state", "set", "view", "st", "show", "port", "get", "parent", "LIST", "only", "module", "print", "level", "v", "name", "status", "pool", "table"], "in": ["In", "read", "pin", "check", "is", "ill", "on", "conf", "out", "input", "rin", "all", "r", "file", "IN", "inn", "reader", "and", "add", "inf", "bin", "ins", "val", "source", "inc", "from", "en", "ic", "up", "er", "din", "isin", "by", "get", "re", "cin", "mn", "con", "i", "gin", " din", "line", "sum", "inner", "doc"], "inputLine": ["httpLine", "outputLINE", "nameLine", "attLINE", "latLINE", "contextline", "outputline", "httpL", "nameline", "inputText", "activeLINE", "helloL", "actline", "InputBlock", "nextRow", "contextLINE", "inputRow", "formBlock", " inputLINE", "selectRow", "nameLINE", "htmlLINE", "InputLine", " inputRow", "dataLine", "commandline", "inputL", " inputline", "nextText", "nextLine", "attLine", " inputText", "commandLINE", "formLine", "actLINE", "formline", "helloLINE", "htmlLine", "htmlBlock", "actLine", "selectLine", "commandLine", "htmlline", "inputline", "inputBlock", "selectLINE", "outputLine", "inputLin", "textLin", " inputBlock", "selectText", "latLine", "nextLINE", "helloLine", "InputLINE", "dataLINE", "nameBlock", "helloLin", "inputLINE", "activeLine", "textLine", "httpLINE", "Inputline", "httpLin", "textL", "textLINE", "formLINE", "contextLine"], "commandNameBegin": ["commandnameBeginning", "commandNAMEBeginning", "CommandNamesBegin", "commandLinebegin", "commandNameMorning", "commandnameBeg", "commandOrderStart", "commandFamilyInitial", "commandFamilyEGIN", "CommandNamesbegin", "commandnameMorning", " commandOrderBeginning", "commandnamebegin", "commandNamesbegin", "commandTypeBegin", "commandNAMEBegin", "commandNameBeg", " commandNameStart", "commandNameInitial", " commandNameMon", "commandOrderbegin", " commandNameBeginning", "commandFamilyBeg", " commandSizeEGIN", " commandNameBeg", "CommandNameStart", "commandnameBegin", "commandSizeBeg", " commandOrderBegin", " commandOrderStart", " commandNamebegin", " commandNameEGIN", " commandNameMorning", "commandLineStart", "commandTypeStart", "commandnameStart", "commandNameBeginning", "commandNamesStart", "CommandNameBegin", "commandNamesBeginning", "commandNamebegin", "CommandNamesBeginning", "commandNameStart", "CommandNamebegin", "commandnameEGIN", " commandNameInitial", " commandSizeBeg", "commandNameMon", "commandLineBeginning", "commandNAMEMon", "commandNamesBegin", "commandSizeEGIN", "commandLineBegin", "commandFamilyBegin", "CommandNamesStart", "commandOrderBegin", "CommandNameBeginning", "commandNameEGIN", "commandTypeBeginning", "commandFamilyMon", "commandNAMEInitial", "commandFamilyMorning", "commandSizeBegin", "commandOrderBeginning", " commandSizeMorning", "commandSizeMorning", "commandFamilyBeginning", " commandSizeBegin", "commandTypebegin", " commandOrderbegin"], "commandNameEnd": [" commandNameEND", "commandNamesStart", " commandLineEnd", "formSizeend", "commandTimeEnd", " commandNameStart", "commandSizeend", " commandNamesBegin", "commandStringStart", "formNameend", "commandSizeEND", "cmdNameend", "commandNamesEnd", "formSizeEND", "commandTypeEnd", " commandNamesEnd", "formSizeStart", "commandNameStart", "commandLineEND", "formSizeEnd", "formNameStart", "commandNamesEND", "formNameEnd", "formNameEND", "commandLineEnd", "cmdTimeEND", "commandStringEnd", " commandLineend", "commandnameend", " commandNameend", "commandSizeStart", "commandStringEND", " commandNamesEND", "commandTimeend", "cmdNameEnd", "commandnameEnd", "commandTypeEND", "commandTypeBegin", "commandLineend", "commandNamesend", "commandnameEND", "cmdNameEND", "cmdTimeEnd", "commandNameend", "commandSizeEnd", "commandStringBegin", " commandNamesStart", "commandNamesBegin", " commandLineEND", "cmdTimeend", "commandTypeStart", "commandTimeEND", "commandNameEND", "commandTypeend"], "item": ["obj", "match", "iter", "check", "template", "article", "group", "title", "or", "store", "it", "type", "info", "mix", "widget", "li", "task", "instance", "m", "hit", "app", "add", "link", "entry", "rule", "key", "image", "row", "this", "page", "label", "Item", "p", "object", "menu", "unit", "tree", "owner", "handler", "el", "element", "command", "bar", "exp", "im", "related", "option", "em", "mm", "sim", "monitor", "i", "question", "event", "module", "inner", "base", "items", "mem", "other", "index", "button", "local", "member"], "e": ["b", "ex", "ce", "r", "f", "err", "be", "oe", "error", "m", "t", "l", "se", "eg", "ae", "x", "de", "c", "ue", "n", "end", "one", "le", "a", "q", "p", "u", "en", "h", "ent", "fe", "ve", "ze", "pe", "ed", "ea", "er", "eeee", "eu", "ne", "el", "ge", "w", "E", "te", "ie", "g", "es", "ec", "ef", "re", "eb", "i", "event", "d", "et", "v", "eur", "o", "ev", "ee"]}}
{"id1": "17161805", "id2": "22560224", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"encode": ["enode", "ensprocess", "Enforce", "enscode", "encprocess", "encforce", "ensode", "enccode", "unprocess", "Encode", "ensforce", "enprocess", "Enode", "unforce", "uncode", "enforce", "unode"], "plaintext": ["plainth", "plainText", "mainth", "pronth", "plainlat", "ainText", "mainlat", "pronText", "ainmessage", "formText", "aintext", "prontext", "formdata", "mainText", " plainth", "pronlat", "formmessage", "aindata", " plaindata", " plainmessage", " plainText", "maintext", " plainlat", "formtext", "plainmessage", "plaindata"], "md": ["amd", "ng", "cd", "dr", "dh", "del", "mt", " MD", "red", "nt", "MD", "m", "pm", "grad", "mp", "der", "mk", "add", "hd", "managed", "mo", "mc", "df", "pd", "cmd", "dd", "det", "msg", "ind", "mod", "sha", "pdf", "mm", "ld", "med", "bd", "od", "mn", "mb", "mand", "sd", "d", " Md", "mg", "ms", "sm", "dm"], "raw": ["message", "read", "RAW", "bytes", "full", "value", "input", "wrap", "strip", "des", "clean", "unknown", "map", "stable", "bare", "row", "n", "orig", " Raw", "serial", "derived", "cmd", "def", "sh", "bound", "valid", "Raw", "json", "unsigned", "hex", "modified", "aw", " RAW", "custom", "buf", "rendered", "inner", "pack", "mem", "cooked"]}}
{"id1": "2668853", "id2": "12783713", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileTOFile", "decodeFile2String", "decodeFileAsFile", "decodeFileAsString", "decodeFilesToFile", "decodeFilesToString", "decodeFiles2File", "decodeFileToFiles", "decodeFile2Files", "decodeFileAsPage", "decodeFiles2String", "decodeFile2Page", "decodeFileTOString", "decodeFileToString", "decodeFiles2Page", "decodeFilesToPage", "decodeFiles2Files", "decodeFileTOPage", "decodeFile2File", "decodeFileToPage", "decodeFileTOFiles", "decodeFilesToFiles", "decodeFileAsFiles"], "infile": ["InFile", "inputfile", "outbase", "innbase", "innfilename", "inbase", "inFile", "outpath", "innfile", "Inbase", "outFile", "Inpath", " infilename", "Infile", "inputbase", "innwhere", "infilename", "inpath", "inputpath", "inputfilename", " inwhere", "inputFile", "inputwhere", "inwhere", " inbase"], "outfile": ["listFile", "Outfilename", "listfile", "inFile", "outpath", "tofile", "listfilename", " outfilename", "infp", "outFile", "tofp", "toFile", "outfp", " outFile", "outfilename", "OutFile", "Outpath", "infilename", "inpath", "listfp", "tofilename", " outpath", "Outfile"], "in": ["In", "user", "iter", "pin", "is", "init", "on", "input", "rin", "it", "al", "info", "ain", "per", "IN", "inn", "inside", "inf", "bin", "ai", "amin", "image", "ins", "n", "source", "inc", "from", "en", "io", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "o", "ro", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "ln", "t", "oss", "gt", "Out", "n", "end", "fn", "os", "ent", "en", "cn", "to", "flush", "opt", "io", "ne", "sys", "outs", "w", "writer", "OU", "g", "con", "co", "inner", "aos", "res", "o", "outer", "can", "print", "ot"], "buffer": ["message", "block", "header", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "queue", "padding", "zero", "memory", "window", "Buffer", "row", "batch", "tree", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "length", "black", "stack", "temp", "buf", "history", "pad", "total", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "shift", "input", "find", "Read", "write", "query", "open", "select", "ok", "give", "first", "reader", "add", "count", "need", "reads", "load", "send", "push", "before", "size", "run", "stream", "end", "q", "READ", "close", "pe", "len", "through", "set", "length", "text", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "data", "connect", "readable", "each", "index", "ready"], "success": ["setup", " succeed", "exist", "ccess", "commit", "cess", "accept", "growth", "warning", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", " succeeded", "submit", "top", "continue", " convergence", "crit", " successfully", "primary", "close", "successful", "good", "green", "please", "ceed", "master", "town", "result", "valid", " Success", "successfully", " okay", " failure", "ratulations", " succeeds", "sufficient", "photo", "snap", "city", "unity", "democracy", " successes", "complete", "cont", "support", "security", "danger", "response", "status", " succ"]}}
{"id1": "20924119", "id2": "3187685", "code1": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"gzip": [" gZip", "garchive", "mdef", " gdef", "Gzip", "mzip", " garchive", "Gdef", "Garchive", "marchive", "GZip", "gZip", "mZip", "gdef"], "zipout": [" zipo", "gzout", "pipenet", "pipein", "zout", "zipo", " zipou", "gzconn", "zouts", "login", "zipnet", " zipnet", "zipin", "gzouts", "gzin", " zipconn", "zou", "lockop", "zipouts", "znet", "zOut", "zin", " zipin", "lockout", "zipOut", "pipeout", "gzo", "logouts", "locko", "zipou", "pipeou", "zipconn", " zipop", "logout", "zipop", "logOut", "gzop", "lockconn", "gzOut"], "buffer": ["message", "block", "bytes", "header", "device", "cache", "number", "binary", "database", "paste", "seed", "frame", "string", "append", "queue", "size", "memory", "Buffer", "stream", "window", "limit", "row", "word", "batch", "char", "password", "document", "attribute", "result", "command", "sequence", "stack", "line", "buf", "history", "pad", "code", "sample", "buff", "data", "mem", "phrase", "comment", "button", "table", "variable"], "dir": ["rect", "path", "iter", "dl", " director", "dr", "ory", "cd", "draw", "out", "DIR", "wd", "del", "tmp", "pkg", "file", "fd", "cond", "direct", "mk", "add", "md", "pos", "directory", "root", "self", "fin", "Dir", "ir", "req", "loc", "df", "ord", "dd", "def", "det", "tree", "part", "div", "ind", "folder", "desc", " Dir", "dat", "dra", "parent", "dist", "d", "cur", "rel", "db", "vol", " directory", "doc"], "in": ["In", "read", "ex", "iter", "check", "is", "sin", "init", "on", "out", "input", "rin", "al", "win", "it", "ain", "IN", "inn", "and", "reader", "inside", "inf", "bin", "ri", "ins", "source", "inc", "from", "en", "ic", "act", "up", "el", "ind", "oin", "im", "din", "form", "isin", "cin", "i", "gin", "inner", "like", "ini"], "length": ["message", "match", "read", "SIZE", "needed", "full", "number", "component", "time", "type", "database", "distance", "ENGTH", "join", "count", "l", "load", "before", "padding", "size", "character", "row", "end", "family", "angle", "len", "char", "tail", "frequency", "ength", "height", "ind", "sequence", "text", "body", "position", "Length", "port", "capacity", "impl", "duration", "shape", "history", "total", "available", "start", "data", "volume", "hello", "index"]}}
{"id1": "16466743", "id2": "3756429", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getmd5": ["getMD4", "getmd6", "getMD2", "getMD6", " getMD4", " getMD5", "getMD5", " getMD6", "getmd4", "getsha5", " getmd6", " getmd2", "getsha2", "getmd2", "getsha6", " getmd4", "getsha4", " getMD2"], "password": ["message", "user", "path", "sword", "auth", "value", "pass", "Password", "ew", "wd", "address", "database", "description", "login", " Password", "string", "padding", "email", "wordpress", "entry", "key", "word", "p", "pattern", "username", "attribute", "token", "shadow", "w", "text", "code", "security", "hash", "data", "name", "phrase", "prefix", "hello", "secret"], "pwHash": ["pswSum", "pwHas", "pswHash", " pwHas", "pwdHash", "pwdhash", "pwdSum", "spwhash", "pswhash", "pWHas", " pwhash", " pwSum", "pwthash", "pWHash", "pWhash", "spwdSum", "pwshash", " pwdHash", "spwdHas", "spwHas", "pwsHash", "spwdhash", " pwdSum", "pwtHash", " pwdHas", "pwSum", "spwSum", "pwsHas", "pwtHas", "pwhash", "spwdHash", "pWSum", "pwtSum", "spwHash", "pswHas", "pwsSum", " pwdhash", "pwdHas"], "md": ["ad", "nd", "ng", " mc", "cd", "ds", "del", "mt", "ms", "red", "grad", "MD", "m", "mp", "pm", "rm", "dir", "der", "cond", "mk", "add", "exec", "hd", " dd", "mo", "mc", "df", " mo", "pd", "cmd", "dd", "def", "det", "cmp", "msg", "mod", "ind", "desc", "mm", "ld", "mail", "bd", "od", "dig", "mn", "mb", "material", "td", "metadata", "d", "sd", "man", " Md", "mem", "mg", " mm", "di", "sm", "doc", "dm"], "b": ["obj", "reb", "bytes", "ba", "binary", "bp", "gb", "f", "ib", "be", "bas", "m", "bf", "ab", "abs", "bis", "bc", "l", "rb", "cb", "bi", "a", "br", "p", "bu", "batch", "bs", "bar", "y", "w", "sb", "bh", "eb", "nb", "g", "B", "bb", "mb", "fb", "d", "v", "buff", "ob", "db"], "i": ["ij", "iter", "is", "my", "init", "us", "gi", "id", "qi", "it", "ski", "xi", "\u0438", "ci", "li", "ms", "I", "m", "l", "oi", "di", "ai", "ix", "gu", "ki", "x", "hi", "ri", "bi", "n", "ii", "next", "a", "q", "p", "u", "multi", "mi", "ic", "in", "io", "y", "ind", "json", "im", "phi", "sim", "iu", "ie", "ji", "si", "yi", "v", "ei", "pi", "span", "o", "ti", "cli", "j", "ui", "index", "ini", "ip"]}}
{"id1": "160739", "id2": "18433984", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createOutputSteam", " createInputSteam", "createInputStream", " createInputstream", "createOutputstream", " createOutSteam", "createInputSteam", " createInputFile", " createFileFile", " createFilestream", " createFileStream", "createOutputFile", " createOutputstream", " createFileSteam", " createOutstream", " createOutStream", " createOutFile", "createInputstream", " createInputStream", " createOutputFile", "createInputFile", "createOutputSteam"], "inFile": [" inPort", "inDir", "ninfile", "ninPath", "inPath", "dinPath", "ninFilename", "inputDir", "outfile", "infile", " inFilename", " inDir", " infile", " inPath", "ninFile", "dinDir", "dinFile", "dinPort", "inPort", "inputPort", "outFilename", "inputFile", "inFilename", "inputPath", "outPath"], "outFile": ["exPlace", "newfile", "outPlace", "exfile", "exFile", "outputfile", "outputPlace", "newPlace", "newFile", "tofile", "outfile", "outPort", "infile", "toFilename", "outputFilename", "newFilename", "toFile", "inPort", "outputFile", "OutFile", "OutFilename", "exFilename", "toPort", "inFilename", "outFilename", "Outfile", "OutPort"], "k_blockSize": ["k2byteCount", "k_blockName", "k4blockName", "k2byteSize", "k4blockCount", "k_BlockLength", "k4BlockStyle", "k_BlockSize", "k2blockSize", "k_byteStyle", "k_byteName", "k_byteLength", "k2blockCount", "k_BlockName", "k_blockStyle", "k4blockSize", "k_byteCount", "k_byteTime", "k4BlockCount", "k_blockTime", "k_batchLength", "k_batchSize", "k_batchCount", "k_blockCount", "k_BlockCount", "k_BlockStyle", "k_byteSize", "k2blockTime", "k_batchTime", "k2byteLength", "k4BlockSize", "k4BlockName", "k_BlockTime", "k4blockStyle", "k2blockLength", "k2byteTime", "k_blockLength"], "byteCount": ["charLength", "byteCode", "wordSize", " byteCounter", "linePtr", "bitCode", "bytePtr", "charcount", "wordCode", "bbCount", "wordN", "charCount", "lineLength", "bitCounter", "bbSize", "bytecount", "bitCount", " byteCheck", "bbCode", "byteN", "blockLength", "blockCounter", "byteCheck", "byteLength", "linecount", "bitSize", "charPtr", "blockCount", " byteLength", "bitLength", " bytecount", "byteSize", "bbN", " bytePtr", "bitN", "bitCheck", "lineCount", "blockCheck", "byteCounter", "wordCount"], "buf": ["b", "bytes", "block", "ctx", "uf", "cap", "pkg", "bl", "bc", "rb", "ctr", "str", "queue", "cb", "proc", "tx", "cat", "Buffer", "bg", "txt", "cv", "img", "arr", "cmd", "batch", "bag", "msg", "seq", "exp", "alph", "conv", "fg", "Buff", "bn", "buffer", "raw", "vec", "cur", "mem", "buff", "cast", "db", "doc", "pb"], "ofp": ["owld", "owlpa", "OFd", "Ofd", "OFP", "Ofl", "OFp", "ofpa", "Ofpa", "ofP", "Ofp", " ofl", "ofd", "OFl", " ofd", "owlP", "owlp", "OfP", "ofl", " ofpa", " ofP"], "zos": ["css", "rose", "hz", "gs", "webkit", "zers", "init", "zo", "zh", "zzle", "rss", "za", "z", "std", "zu", "tis", "zip", "hess", "los", "sbm", "cos", "oss", "psy", "python", "nz", "bes", "zen", "sch", "os", "LOS", "enos", "zona", "ze", "osi", "jas", "cz", "bs", "settings", "zl", "zb", "zin", "socket", "zy", "ossus", "js", "ez", "ps", "zag", "sis", "rez", "eros", "south", "jp", "zi", "zes", "esa", "zer", "ws", "zon", "amia", "es", "zik"], "osw": ["isw", "ossW", "osswd", "osws", "oswx", "aosw", "osipace", " osW", "cosws", "osew", "owa", "syswd", "oswd", "ow", "osrw", "sysrw", "osssw", "aoswa", "ossrw", "aosW", " osew", "osd", "aosrw", "osiwa", "issw", "oswa", "ossw", " osd", "aosew", "cosw", "aospace", "oW", "osiW", "aosws", " oswx", "opace", "cosd", "cosew", " ossw", "iswx", "ospace", " osws", "osswx", "aoswd", "aosd", "osiw", "osW", "sysW", "isW", "sysw"], "bw": ["bwk", " bwl", "abwy", "besw", " bex", "pbz", "pbew", "rbws", "bew", "bend", "bbex", "pbwy", "rbz", "obsw", "abew", "wbend", " bsw", "bbwp", " bwt", "obz", "obwl", " bz", "nbew", "obwk", "bbz", "bwe", "wbx", " bend", "bewl", "bem", "bwb", "wbw", "bex", "obwb", "bz", "nbwy", "bbwt", "bbem", "bwt", "bbend", "bx", "rbex", "pbw", "bewk", "bwp", "wbz", "nbw", "sbwb", "nbwe", "pbwt", "sbz", "bsw", "wbwt", " bwp", "wbem", "sbw", "bbx", "bbws", "bbw", "abwe", "rbw", " bx", "bws", " bwk", "abw", "pbwe", " bem", "pbwb", "obwt", "obw", "wbwp", "bwl", "bwy", "sbwt", " bws"], "zot": ["zoonet", "zeronet", "zipot", "zeriat", " zote", "zhot", "zo", "zonet", "Zot", "zor", "zeror", " zott", "zerhot", "zoot", "zero", "zoor", " ziot", " zo", "Zote", " ziat", " zor", " zonet", "Zott", "zeriot", "zerote", "ziot", "zerott", "zoo", "ziphot", "zipiot", "zote", " zhot", "zerot", "Zit", "zipiat", "zott", "zerit", "ziat"], "ifp": [" ifP", "Ifjp", " ifth", "ihp", "iftp", "Ifp", "isjp", "iwr", "ifth", "isP", "isth", " iftp", "ifd", "isp", " ifd", "ifjp", "iwtp", "ihr", " ifjp", "ifr", "iwp", "ifP", "IfP", "iwd", " ifr", "ihtp", "Ifth", "ihd"], "zis": [" zisc", "izis", "izi", "zoinit", "ezi", "zoisa", "izisa", "zois", "zeris", "zipIS", "ziis", "zipic", "zic", "ezis", " zIS", "ziinit", "iziss", "zinit", "ezisc", " zi", "izisc", "zipis", "ziisa", "zisc", "zeric", "zerIS", "ziiss", "zisa", "zi", " ziss", "zIS", "eziss", "zoiss", " zic", "ziss", "izinit"], "isr": ["isalpr", "isrs", "siscr", "isscr", "sisrc", "sisr", "iospr", "isrc", "ispr", "sisrs", "isalr", "isalsr", "itssr", " isrc", "itsr", " isrs", "iscr", "iosstr", "iossr", "issrs", "iosr", "issrc", " iscr", "isalstr", "isstr", "issr", "itspr", "itsstr"], "br": ["b", "bro", "dr", "ptr", "vr", "lr", "ba", "bp", "r", "bf", "bl", "obl", "sr", "rb", "str", "ctr", "bj", "Fr", "pr", "bi", "ber", "kr", "shr", "BR", "tr", "cr", "wr", "js", "bh", "Br", "bd", "bn", "yr", "gr", "bt", "mr", "rel", "bm", "hr", "fr", " Br"], "zit": ["zist", "lexist", " zop", "zeop", "zlit", "ziIt", "zipist", "czit", " zite", "izit", "ziplit", "lexIt", "zipit", "izip", "ezIT", "ziit", "zip", "iziti", " zIT", "zite", "czot", "ezite", "ziist", "zeip", "ozip", " zlit", "zipIt", "zop", "ziti", "zIt", "ozunit", "ozit", "zunit", "izunit", "czunit", " zip", "ezlit", "ezit", "zeot", "zipIT", "czop", "czip", "cziti", "zeit", "lexit", "zIT", "oziti", "ziIT", "zipite", "lexIT"]}}
{"id1": "6908537", "id2": "19276022", "code1": "    public String login() {\n        System.out.println(\"Logging in to LOLA\");\n        try {\n            String data = URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_email(), \"UTF-8\");\n            data += \"&\" + URLEncoder.encode(\"pw\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_pw(), \"UTF-8\");\n            URL url = new URL(URL_LOLA + FILE_LOGIN);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line, sessid;\n            line = rd.readLine();\n            sessid = get_sessid(line);\n            this.set_session(sessid);\n            wr.close();\n            rd.close();\n            return sessid;\n        } catch (Exception e) {\n            System.out.println(\"Login Error\");\n            return \"\";\n        }\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 1, "substitutes": {"login": ["setup", "user", "auth", "register", " Login", "update", "write", "download", "open", "save", "session", "config", "request", "submit", "close", "in", "layout", "username", "password", "console", "Login", "dial", "log", "account", "connection", "connect", "hello"], "data": ["ment", "message", "dl", "value", "format", " DATA", "out", "input", "id", "info", "api", "red", "output", "error", "session", "join", "debug", "done", "string", "str", "feed", "success", "test", "html", "key", "window", "reason", "next", "this", "p", "action", "def", "password", "default", "part", "command", "result", "div", "json", "text", "DATA", "body", "post", "dat", "no", "ata", "connection", "content", "d", "response", "rel", "name", "db", "reset"], "url": ["ls", "dl", "cert", "net", "http", "URL", "r", "open", "pkg", "abs", "l", "ur", "gl", "str", "link", "web", "nl", "loc", "hl", "lb", "uri", "gc", "il", "xml", "www", "el", "conv", "ret", "ld", "mail", "Url", "re", "build", "log", "get", "ssl", "ul", "bel", "atl", "rel", "ll", "pl", "sl", "call"], "conn": ["ls", "obj", "inv", "Conn", "net", "cert", "yn", "open", "comm", "win", "nt", "pkg", "exec", "ann", "cb", "nl", "c", "fin", "loc", "n", "close", "cp", "nec", "cn", "ct", "cmd", "resp", "addr", "canon", "act", "pas", "nc", "socket", "ch", "conv", "dat", "enc", "ctrl", "con", "jp", "connection", "cont", "co", "nw", "syn", "res", "cur", "rel", "connect", "ll", "ns", "call"], "wr": ["dr", "wy", "spr", "wrote", "vr", "lr", "tw", "wid", "write", "r", "wn", "wm", "ln", "wa", "wer", "pr", "wx", "nl", "tn", "rew", "kr", "rw", "writ", "hw", "WR", "fw", "iw", "vet", "w", "wt", "writer", "kl", "mn", "RW", "wb", "nw", "sw", "mr", "wk", "wo", "hr", "fr"], "rd": ["nder", "nd", "rob", "rer", "dr", "erd", "ptr", "rog", "ro", "lr", "r", "red", "rx", "sr", "rc", "rt", "rb", "RD", "rad", "ri", "rar", "rs", "rw", "ris", "rn", "dd", "rid", "rl", "rend", "cr", "rr", "rod", "ld", "ird", "rh", "rex", "ra", "rand", "mr", "ry", "hr", "fr"], "line": ["LINE", "block", "iter", "liner", "header", "ste", "out", "id", "lo", "ln", "file", "inline", "l", "ine", "se", "ode", "eline", "link", "cell", "frame", "string", "str", "lin", "entry", "nl", "word", "row", "page", "le", "pe", "Line", "len", "char", "ne", "part", "el", "lf", "text", "e", "log", "no", "chain", "buffer", "code", "ide", "column", "comment", "stay", "fr"], "sessid": ["seessinfo", "Sessionname", "ssessionoid", "secessinfo", "descessid", " sesskey", " ssessioninfo", "Sessname", "secessid", " sessname", "sESSname", "seessoid", "sessionuid", "Sessionkey", "sessinfo", "ssessionuid", "Sessuid", "ssessioninfo", "sessname", "scessinfo", "sessoid", "seessname", "ssessionname", "desesskey", "ssessionid", "sessionkey", "descesskey", " ssessionname", "sessionid", "sESSuid", "scessoid", "sESSoid", "Sessid", "secessoid", "sessionoid", "sessuid", "descessuid", "scesskey", "desessuid", "scessname", "Sessionuid", "desessoid", " ssessionid", "scessid", "sessionname", "Sessionid", " sessinfo", "descessoid", "seessid", "scessuid", "ssessionkey", "desessid", "sESSid", "sessioninfo", "secessname", "Sesskey", "sESSkey", " ssessionkey", "sesskey"]}}
{"id1": "9257487", "id2": "15905041", "code1": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public void createPartControl(Composite parent) {\n        viewer = new ScrollingGraphicalViewer();\n        viewer.setRootEditPart(new ScalableRootEditPart());\n        viewer.setEditPartFactory(new BlockEditPartFactory());\n        viewer.setEditDomain(new EditDomain());\n        viewer.createControl(parent);\n        viewer.setKeyHandler(new GraphicalViewerKeyHandler(viewer));\n        ActionRegistry actionRegistry = new ActionRegistry();\n        createActions(actionRegistry);\n        ContextMenuProvider cmProvider = new BlockContextMenuProvider(viewer, actionRegistry);\n        viewer.setContextMenu(cmProvider);\n        Block b = new Block();\n        b.addChild(new ChartItem());\n        viewer.setContents(b);\n        System.err.println(\"!!! \" + viewer.getContents().getChildren().get(0));\n        viewer.select((EditPart) viewer.getContents().getChildren().get(0));\n        PaletteRoot root = new PaletteRoot();\n        PaletteGroup toolGroup = new PaletteGroup(\"Chart Tools\");\n        List toolList = new ArrayList();\n        ToolEntry tool = new SelectionToolEntry();\n        toolList.add(tool);\n        root.setDefaultEntry(tool);\n        tool = new MarqueeToolEntry();\n        toolList.add(tool);\n        toolGroup.addAll(toolList);\n        PaletteGroup templateGroup = new PaletteGroup(\"Templates\");\n        List templateList = new ArrayList();\n        CombinedTemplateCreationEntry entry = new CombinedTemplateCreationEntry(\"Rect\", \"Rect\", new ChartItem(), new SimpleFactory(ChartItem.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        CombinedTemplateCreationEntry entry1 = new CombinedTemplateCreationEntry(\"Line\", \"Line\", new ChartLine(), new SimpleFactory(ChartLine.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        templateList.add(entry);\n        templateList.add(entry1);\n        templateGroup.addAll(templateList);\n        List rootList = new ArrayList();\n        rootList.add(toolGroup);\n        rootList.add(templateGroup);\n        root.addAll(rootList);\n        final PaletteViewer v = new PaletteViewer();\n        v.setPaletteRoot(root);\n        v.createControl(parent);\n        v.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(\"selectionChanged \" + v.getActiveTool());\n            }\n        });\n        deleteAction.setSelectionProvider(viewer);\n        viewer.getEditDomain().setPaletteViewer(v);\n        viewer.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(event.getSelection());\n                deleteAction.update();\n            }\n        });\n        viewer.getEditDomain().getCommandStack().addCommandStackEventListener(new CommandStackEventListener() {\n\n            public void stackChanged(CommandStackEvent event) {\n                undoAction.setEnabled(viewer.getEditDomain().getCommandStack().canUndo());\n                redoAction.setEnabled(viewer.getEditDomain().getCommandStack().canRedo());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"downloadFile": ["updateFile", "updateResource", "DownloadFiles", " downloadfile", " downloadFiles", "downloadfile", "Downloadfile", "DownloadResource", "downloadResource", "updateFiles", "DownloadFile", "updatefile", " downloadResource", "downloadFiles"], "from": ["path", "range", "From", "or", "src", "input", "with", "request", "config", "add", "se", "fl", "original", "entry", "html", "term", "source", "a", "os", "uri", "initial", "part", "old", "st", "view", "ol", "form", "rom", "by", "of", "base", "name", "simple", "vol", "fr", "reset", "un"], "to": ["dest", "template", "title", "tt", "fully", "output", "tmp", "toc", "file", "done", "t", "pretty", "oto", "To", "top", "too", "ta", "eto", "tu", "p", "tom", "TO", "target", "delete", "te", "po", "by", "temp", "ato", "into", "auto", "o", "pi", "base", "tty", "name"], "pm": ["pt", "pp", "pa", "progress", "gm", "wm", "km", "mt", "ms", "m", "mp", "rm", "rem", "dem", "pc", "sem", " ppm", "rpm", "nom", "PM", "mc", "p", "vm", "mi", "asm", "cm", "aph", "em", "mm", "hm", "po", "ps", "meter", "monitor", "mon", "jp", "fm", "arm", "am", "mr", "pi", "bm", "pl", " mm", "pr", "mx", "dm"], "out": ["obj", "ex", "at", "net", "OUT", "ou", "cache", "on", "write", "f", "output", "oe", "nt", "file", "t", "pretty", "oss", "client", "Out", "n", "os", "p", "en", "flush", "io", "ne", "op", "outs", "w", "body", "writer", "OU", "log", "con", "i", "gr", "co", "aos", "can", "o", "auto", "res", "ot", "we"], "url": ["ls", "b", "user", "dl", "cert", "net", "http", "URL", "ver", "r", "f", "open", "li", "l", "ur", "link", "str", "fl", "https", "client", "job", "web", "nl", "loc", "hl", "host", "p", "uri", "char", "il", "ch", "conv", "ret", "Url", "re", "ssl", "ul", "bel", "base", "res", "rel", "ll", "sl"], "conn": ["com", "Conn", "ctx", "net", "cert", "yn", "open", "comm", "nt", "col", "l", "https", "client", "cb", "cc", "nl", "c", "gate", "cp", "nec", "cn", "close", "cmd", "addr", "cm", "nc", "iw", "ch", "enc", "conv", "serv", "con", "connection", "cur", "connect", "ns"], "in": ["In", "iter", "is", "sin", "init", "ill", "on", "input", "rin", "it", "ain", "IN", "inn", "reader", "and", "inside", "inf", "bin", "ai", "ri", "ar", "ins", "inc", "en", "ic", "up", "il", "io", "el", "ind", "oin", "din", "isin", "nin", "cin", "i", "gin", " din", "inner"], "buffer": ["message", "block", "library", "iter", "template", "value", "cache", "number", "binary", "paste", "frame", "se", "append", "cell", "entry", "memory", "window", "Buffer", "detail", "reason", "word", "row", "batch", "char", "tree", "initial", "document", "attribute", "command", "bar", "sequence", "view", "length", "stack", "temp", "chain", "buf", "raw", "pad", "base", "sample", "buff", "mem", "column", "phrase", "button", "table", "variable"], "read": ["iter", "check", "gets", " Read", "draw", "bind", "input", "Read", "find", "write", "download", "open", "query", "select", "ok", "output", "sync", "reader", "t", "add", "count", "head", "send", "reads", "load", "push", "size", "req", "score", "run", "stream", "end", "next", "val", "READ", "n", "q", "row", "pe", "num", "handle", "len", "used", "ind", "old", "text", "w", "last", "length", "reading", "get", "log", "ke", "raw", "i", "seek", "hold", "print", "start", "mem", "skip", "scan", "connect", "readable", "hello", "index", "ready"]}}
{"id1": "14001795", "id2": "11933797", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyOverwarFile", "copyOverTarfile", "copyOverwarfile", "copyoverWarFiles", "copyoverWarFilename", "copyOverTarFiles", "copyoverWarfile", "copyOverwarFilename", "copyoverwarFilename", "copyOverWarfile", "copyoverWarFile", "copyoverwarfile", "copyOverTarFile", "copyoverwarFile", "copyOverTarFilename", "copyoverwarFiles", "copyOverWarFilename", "copyOverWarFiles", "copyOverwarFiles"], "dir": ["path", "iter", "dep", "dl", "dr", "cd", "out", "DIR", "url", "wd", "vol", "del", "tmp", "file", "fd", "direct", "mk", "add", "zip", "md", "directory", "fin", "ir", "Dir", "window", "loc", "df", "dd", "good", "def", "addr", "coll", "div", "ind", "folder", "old", "desc", " Dir", "form", "dat", "dial", "parent", "log", "re", "dim", "ld", "disk", " d", "dist", "d", "res", "cur", "local", "name", "rel", "db", "di", " directory", "doc", "dm"], "ff": [" def", "xf", "fact", "xff", " eff", "uf", " cf", "ft", "mt", "aft", "file", "bf", "fd", "fp", "tf", "fc", "cond", "fl", "cb", "eff", "fx", " df", "FF", "df", "aff", "ffe", "af", "off", " aft", " af", "lf", "F", " ref", "ef", "fg", "ld", "iff", "UFF", "sf", "ck", "cf", "buff", "wind", "uff", "filter", " FF", "alf"], "files": ["ls", "mas", "models", "iles", "faces", "bees", "keys", "fs", "facts", "file", "days", "forms", "ories", "parts", "jobs", "Files", "rows", "balls", "resources", "leases", "flows", "issues", "features", "frames", "images", "ports", "styles", "uploads", "fields", "plates", "tests", "members", "ions", "les", "lines", "names", "assets", "objects", "items", "ails", "values"], "f": ["b", "xf", "uf", "ft", "fs", "k", "file", "bf", "fd", "fp", "fc", "tf", "elf", "t", "col", "l", "fl", "c", "n", "a", "p", "h", "fe", "rf", "def", "fac", "fw", "lf", "w", "F", "exp", "fab", "m", "g", "e", "i", "sf", "fa", "d", "fm", "cf", "v", "alf"], "newFile": ["newFiles", " newFiles", "newKey", "newfile", "NEWPage", "NewNode", " newFilename", "newPlace", "anotherFiles", "NewFilename", "NewFile", " newPlace", "newsKey", "uniqueNode", "NEWNode", "uniquefile", "newsfile", " newfile", "oldFilename", "anotherFile", "NewFiles", "oldfile", "securefile", "newFilename", "NewPage", "newNode", "anotherPlace", "secureFile", "NEWFile", "NEWfile", "uniquePage", "NewPlace", "oldFile", "uniqueFile", "newsFile", "newPage", "anotherfile", "secureKey", "NewKey", "Newfile"], "fi": ["ni", "uf", "ci", "li", "bf", "fd", "fp", "FI", "ki", "fin", "bi", "ri", "ii", "mi", "fe", "ifa", "flo", "io", "isi", "lf", "phi", "iu", "i", "afi", "si", "fa", "sf", "zi", "cf", "pi", "ti", "di", "fr", "ini", "Fi", "ife"], "fo": ["xf", "vo", "zo", "ph", "zz", "fam", "hea", "oe", "ow", "tf", "bo", "jo", "oooo", "tto", "ki", "hi", "tif", "eto", "mo", "tk", "ko", "sty", "flo", "ott", "oo", "wt", "opa", "eno", "te", "po", "ato", "sf", "co", "ho", "cf", "o", "FO", "ti", "uo", "wo"]}}
{"id1": "22057083", "id2": "10281203", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 0, "substitutes": {"Connect": [" Init", "Connection", "Conn", "Ping", "Client", "Sync", "Create", "Init", "Check", " Dial", "Start", "Connector", " Close", "Setup", " Open", "Construct", "Error", " Connection", "Dial", "Auth", "Open", "Close", "Bind", "Login", "Interface", "New", "Log", "connect"], "client": ["secure", "plugin", "pc", "phone", "product", "cell", "google", "batch", "util", "ch", "writer", "port", "mail", "log", "con", "conn", "connection", "co", "resource", "response", "name", "node", "connect", "service", "obj", "user", "collection", "cgi", "url", "open", "wrapper", "Client", "context", "browser", "c", "key", "window", "patch", "row", "proxy", "close", "pattern", "handle", "command", "controller", "chain", "man", "local", "table", "net", "api", "lib", "list", "core", "config", "session", "bo", "entry", "manager", "version", "remote", "buffer", "ssl", "cli", "channel", "pb", "http", "store", "cache", "component", "type", "force", "reader", "cl", "builder", "one", "null", "cp", "cmd", "control", "to", "handler", "form", "server", "module", "create", "call"], "reply": ["message", "match", "user", "query", "type", "write", "address", "translation", "shell", "error", "echo", "Reply", "rc", "link", "repl", "success", "job", "answer", "entry", "next", "close", "mi", "py", "resp", "flag", "command", "result", "state", "notice", "bill", "report", "ret", "nb", "no", "ply", "line", "print", "code", "response", "comment", "prefix", "status", "vote"]}}
{"id1": "18748516", "id2": "2199604", "code1": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["read", "download", "save", "Cop", "sync", "paste", "map", "rm", " cp", "csv", "load", " replicate", "printf", "cat", "clone", "move", "cp", " copying", "Copy", "slice", "delete", "upload", "export", "transfer", "create", " Copy", "replace", "println"], "fromFile": ["inputFilename", "outName", "inputPage", " fromPlace", "fromPage", "outPlace", "inByte", "toPage", "toByte", "inputUrl", "toUrl", "inUrl", "inputPlace", "inputName", "inFile", "fromName", " fromName", "inputByte", "fromFilename", "outFile", "fromUrl", " fromFilename", "fromByte", "inPage", "fromPlace", "outFilename"], "toFile": ["intoFile", "intofile", "toPage", "outputPlace", "outputfile", "targetFilename", "targetFile", "targetfile", "tofile", "outfile", "targetPlace", "outFile", "toPlace", "toFilename", "outputFilename", "outputPage", "intoPage", " tofile", "outPage", "outFilename", " toPlace", "intoFilename", " toFilename"], "inputFile": ["acceptBe", "inputPage", "inputfile", "innerFile", "outputTime", "acceptFile", "Inputfile", "fromPage", "acceptMail", "outputfile", "InputTime", "inputMail", "inFile", "inBe", "acceptDo", "fromTime", "fromfile", "outputPage", "innerBe", "inputBe", "inputTime", "inDo", "innerMail", "inMail", "innerDo", "inputDo", "InputPage", "InputFile"], "outputFile": ["webPlace", "toPath", "writefile", "resultFiles", "writeFile", "outputfile", "outputPlace", "resultFile", "writePlace", "webTable", "tofile", "outfile", "resultfile", "outputTable", "outFile", "webFile", "outFiles", " outputTable", "outputFiles", " outputPlace", "writeTable", "resultPath", "webfile", "toFiles", "outputPath", " outputfile", "outPath"], "in": ["In", "read", "iter", "is", "init", "sin", "on", "input", "rin", "al", "it", "info", "ain", "per", "IN", "inn", "reader", "inside", "inf", "ai", "bin", "ri", "ir", "ins", "inc", "en", "ze", "ic", "up", "io", "ind", "oin", "im", "din", "form", "isin", "cin", "con", "i", "gin", " din", "inner", "ini"], "out": ["b", "obj", "user", "put", "check", "at", "net", "OUT", "on", "cache", "it", "all", "write", "output", "nt", "and", "t", "client", "Out", "n", "os", "cn", "to", "up", "io", "ne", "sys", "outs", "w", "writer", "conv", "by", "g", "con", "co", "print", "v", "inner", "o", "outer", "auto", "aos", "ot", "res", "we"], "c": ["cs", "ce", "cd", "conf", "cache", "cap", "sc", "k", "f", "r", "z", "m", "current", "pc", "t", "count", "bc", "rc", "cos", "l", "cc", "cb", "cl", "character", "x", "dc", "n", "mc", "cp", "ac", "u", "ct", "gc", "unc", "arc", "char", "C", "cm", "nc", "cr", "jc", "ch", "uc", "ca", "conv", "cod", "chain", "i", "cont", "d", "v", "code", "o", "cf", "lc"]}}
{"id1": "15896098", "id2": "8667872", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"getSHA256Checksum": ["getSHA256Checsum", "getSHA256Checkam", "getSHA256Checkums", "getSHA256Chechecksume", "getSHA256Checsume", "getSHA256Checkcksam", "getSHA256Checksam", "getSHA256Checkchecksums", "getSHA256Checsam", "getSHA256Checkchecksum", "getSHA256Checkcksume", "getSHA256Checksume", "getSHA256Checkchecksam", "getSHA256Checkume", "getSHA256Checkum", "getSHA256Chechecksums", "getSHA256Checkcksum", "getSHA256Chechecksam", "getSHA256Checkchecksume", "getSHA256Chechecksum", "getSHA256Checkcksums", "getSHA256Checksums", "getSHA256Checsums"], "source": ["SOURCE", "message", "path", "template", "value", "src", "format", "out", "input", "url", "Source", "subject", "filename", "output", "context", "file", "ource", "seed", "s", "string", "image", "reason", "this", "from", "in", "sequence", "text", "body", "target", "style", "buffer", "raw", "content", "base", "sample", "data", "name", "status", "secret"], "checksum": ["checksums", "cksim", "checkum", "checkim", "checksumb", " checksums", "csum", "cksums", "cksum", "checkume", "cssum", "checksume", "checksim", "cksume", "checkssum", " checksumb", " checkssum", "csume", "ckssum", "csim", "cksumb", "checkums", "checkumb", " checksim", " checksume"], "md": ["ad", "cd", "dr", "dh", "wd", "mt", " MD", "red", "nt", "MD", "m", "pm", "grad", "mp", "der", "mk", "down", "hd", "mo", "mc", "df", "Cmd", "pd", "cmd", "dd", "def", "det", "mod", "ind", "pdf", "mm", "ld", "bd", "od", "mn", "mb", "mand", "sd", "d", " Md", "mg", "ms", "di", "sm", "dm"], "byteData": ["sliceDat", " byteList", "byteDATA", " byteBytes", "bleRel", "phraseBytes", "channelParts", "reverseDat", "channelRel", "byteRel", "ByteDATA", "ioDat", "phraseData", "byteArray", "byteDat", "phraseDATA", " byteDATA", "bleData", " byteCount", "sliceDATA", " byteRel", "ByteData", "routeDATA", "sliceList", "channeldata", "ioList", "bleParts", "byteBytes", "reverseCount", " bytedata", "ioData", " byteParts", "ByteParts", "byteList", "ioDATA", "sliceData", "wordArray", "byteCount", "wordData", "routeData", "routeCount", " byteArray", "phraseParts", "bytesDATA", "wordBytes", " byteDat", "wordDATA", "bytesBytes", "bledata", "channelData", "reverseData", "bytesArray", "bytesData", "byteParts", "bytedata", "ByteBytes", "reverseDATA", "routeDat"], "sb": ["b", "SF", "bash", "ib", "gb", "shell", "bf", "sv", "bis", "rb", "sbm", "bj", "obb", "SB", "cb", "sq", "bps", "bg", "erb", "lb", "bs", "sh", "sam", "zb", "sp", "ub", "bh", "eb", "nb", "bb", "bsp", "mb", "ssl", "si", "sf", "sa", "xb", "bt", "wb", "kb", "sw", "lp", "ob", "db", "sg", "sm", "pb"], "i": ["my", "xi", "info", "err", "I", "any", "ai", "ix", "iq", "hi", "ri", "u", "mi", "set", "phi", "iu", "history", "ei", "o", "series", "ip", "ij", "init", "id", "ion", "oi", "ki", "ii", "multi", "ic", "json", "sim", "ime", "chain", "ti", "point", "ui", "ini", "qi", "\u0438", "ci", "li", "m", "list", "iy", "gu", "this", "major", "io", "loop", "ind", "im", "ie", "g", "remote", "print", "cli", "j", "di", "ims", "gi", "it", "ski", "l", "client", "bi", "q", "uri", "to", "er", "y", "ity", "ji", "me", "si", "pi", "life", "ms"], "hexString": ["hexArray", " hexStore", "hashBuffer", "exString", " hexstring", " Hexstring", "shortBuffer", "htmlBuffer", "hashString", " HexString", "fullString", "exstring", "htmlstring", "hexBuffer", "htmlString", " hexBuffer", "shortArray", "exStore", "hexStore", " hexResource", "exArray", " HexBuffer", "shortstring", "hexstring", "fullBuffer", "hashstring", "exBuffer", "htmlArray", "fullStore", "hexResource", "shortResource", "hashArray", "fullstring", " HexResource", " hexArray", "shortString"], "hex": ["alias", "ex", "solid", "com", "full", "ph", "flash", " ex", "prop", "zh", " Hex", "des", "mix", "php", "tx", "html", "x", "cat", "ext", "term", "pex", "hl", "h", "comp", "he", "def", " sex", "dump", "sh", "sex", "json", "exp", "alph", "form", "none", "temp", "tex", "rh", "raw", "cont", "rex", "rendered", "lit", "hello", "oct"]}}
{"id1": "189963", "id2": "22977189", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrites", "readAndRepWrite", "readAndResWrite", "readAndRewend", "readAndResend", "readAndrewrite", "readAndrewWrite", "readAndResrite", "readAndRewrites", "readAndrewrites", "readAndReprite", "readAndrewend", "readAndRewWrite", "readAndRepend", "readAndReprites"], "inFile": ["InFile", "inputFilename", "docFile", "docFILE", "iFILE", "iFilename", "INTime", "inFILE", "InFilename", "initPlace", "initFilename", "inputPlace", "docTime", "inFace", "outfile", "infile", "iFile", " inFilename", "initFile", "inPlace", "INPlace", "docFilename", " infile", "inTime", "Infile", "initFace", "INFace", "iTime", "INFilename", "INFile", "INFILE", "inputFile", "inputFace", "inFilename", "outFilename"], "outFile": ["reportFile", " outFilename", "checkFilename", "outFILE", "inFILE", "toFILE", "reportFILE", "tofile", "nameFilename", "outfile", "infile", " outFILE", "reportfile", "reportFilename", "toFilename", "namefile", "nameFile", "toFile", "checkFile", " outfile", "checkFILE", "inFilename", "outFilename", "nameFILE", "checkfile"], "iis": [" iris", "iiIs", "liris", "iIS", "eis", "aiis", "Iiss", "liisc", "Ii", "liIs", "liis", "eIS", "iiisc", "ii", " iiss", "iiss", "iiis", "iiris", " iIs", "iIs", " iIS", "diIs", " ii", "iisc", "IIs", "eIs", "aiIS", "dii", "aiIs", "diis", " iisc", "iris", "Iis", "diiss"], "dcmParser": ["dgrParser", " dpmListener", "dpcReader", "dpmAssistant", "DpmReader", "dcrparser", "dcommReader", " dpmarser", "dcmListener", "dmoduleReader", "dmoduleAssistant", " dpmStatement", "dpmLoader", "dmmParser", " dcmarser", " dpmparser", "dcommListener", "deromParser", "dpmBuilder", "dromparser", "dcmAdapter", "dcrParser", "dfmParser", "dpmStatement", "dmmmReader", " dcmLoader", "dcomReader", "dcmBuilder", "dromAssistant", "DpmAdapter", "dcrBuilder", "dpmPrivate", " dcmPar", "dcomBuilder", "dcrReader", " dpmReader", "dcommAssistant", " dpmLoader", " dcmStatement", " dcmAssistant", "dmmarser", "dmmparser", "DcmBuilder", "dpmarser", "dgrStatement", " dcmBuilder", "dmmmparser", "dcmparser", "dcfStatement", "dromReader", "dcmAssistant", "decmParser", " dcmListener", "deromarser", "Dpmparser", "decmReader", "DcmParser", "dpmAdapter", " dpmParser", "dcmStatement", "dgrReader", " dpmPar", "DpmPar", "dmReader", "decmarser", "dpcAssistant", "DpmBuilder", "dmmReader", "decmparser", "drumParser", "dromarser", " dpmBuilder", " dcmPrivate", "dpcParser", " dpmAssistant", "dcmLoader", "DcmReader", "dromParser", "dmmmParser", " dcmparser", "dmmAdapter", "DpmParser", "drumReader", "dfmReader", "dpmReader", "dgrPar", "dcmReader", "dcfReader", "deromReader", "Dcmparser", "deromparser", "dcommParser", "dmparser", "drumPar", " dcmReader", "dcmarser", "dmarser", "dcmPrivate", "dpmparser", "dcmPar", "dmParser", "dmmmAdapter", "dpcPrivate", "dcfPar", "dromListener", "dcomParser", "dmodulePrivate", "DcmAdapter", "drumBuilder", "dfmBuilder", "dfmLoader", "dpmListener", "dcomLoader", "dpmPar", "dmoduleParser", "dpmParser", "dcfParser", "DcmPar", " dpmPrivate"], "ds": ["ls", "cs", "dos", "dl", "gs", "eds", "dh", "ils", "fs", "des", "vs", "ys", "da", "der", "sv", "s", "gd", "dds", "sets", " des", "as", "ads", "hd", "dq", "rs", "uds", "tes", "xs", "df", "os", "details", "ins", "pd", "dd", "services", "in", "bs", "Ds", "ods", "sys", "obs", "outs", "dt", "hs", "pers", " DS", "eps", "its", "js", "dat", "bd", "ps", "dx", "ks", "ss", "drivers", "sd", "d", "aos", "qs", "data", "ws", "DS", "db", "es", "ims", "ns"], "pdReader": ["ddHelper", "ddParser", "pdLoader", "xdHelper", "pdParser", "tdWriter", "xdLoader", "tdRead", "ddLoader", "vdLoader", "pdRead", "dpCar", "dpLoader", "ddWriter", "ddReader", "pdCar", "ddRunner", "dpRunner", "pedReader", "tdParser", "hdParser", "tdReader", "pedLoader", "pedCar", "hdRead", "pdRunner", "vdHelper", "xdReader", "pdHelper", "hdWriter", "ddRead", "xdWriter", "dpReader", "vdReader", "pedRunner", "hdReader", "ddCar", "vdWriter"], "out": ["over", "full", "on", " err", "err", "t", "str", "ins", "p", "ent", "outs", "ch", "writer", "log", "conn", "con", "co", "sum", "sw", "v", "o", "auto", "name", "status", "gen", "inv", "obj", "ex", "ou", "all", "id", "nt", "s", "cb", "c", "end", "txt", "os", "nr", "cn", "in", "desc", "conv", "serv", "raw", "inner", "outer", "pool", "cfg", "at", "net", "tmp", "list", "pos", "Out", "n", "en", "up", "io", "sys", "w", "js", "aos", "res", "data", "we", "OUT", "cache", "it", "output", "oss", "client", "gt", "one", "null", "screen", "go", "cmd", "to", "opt", "flush", "msg", "gr", "inter"], "dcmEncParam": ["dcmEnPar", "dcmEnVal", "dcmencCmd", "dcmEncVal", "dcmEnParam", "dcmencParam", "dcmEscPar", "dmmencParam", "dcmDecParam", "dmmEncCmd", "dcmEncCmd", "dcmencNum", "dmmEncMsg", "dmmencNum", "dmmEncPar", "dcmEncPar", "dcmEscNum", "dmmEnPar", "dcmDecCmd", "dcmEncMsg", "dcmEnNum", "dmmEnNum", "dcmEscVal", "dcmDecMsg", "dcmEscParam", "dmmEncParam", "dmmencCmd", "dmmEnParam", "dmmEncNum", "dcmEncNum", "dcmDecNum", "dcmencPar", "dcmencMsg", "dmmEncVal", "dmmencMsg"], "pdWriter": ["dpEditor", "PDReader", "tdWriter", "dpWriter", "pidWrite", "PDWriter", "pdwriter", "pidWriter", "PDWrite", "tdWriting", "tdReader", "PDEditor", "pidwriter", "pidWriting", "dpWrite", "tdwriter", "pcWriter", "pcWrite", "pdWrite", "pdWriting", "pcwriter", "tdWrite", "pdEditor", "pcWriting", "dpReader", "tdEditor"]}}
{"id1": "9319440", "id2": "11546108", "code1": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"load": ["read", "library", "loading", "init", "install", "store", "update", "save", "open", "download", "file", "Load", "loads", "LOAD", "link", "loader", "dump", "view", "show", "upload", "get", "build", "process", "create", "call"], "id": ["ad", "path", "mid", "aid", "title", "Id", "it", "info", "k", "ID", "description", "and", "kid", "t", "l", "md", "link", "job", "key", "pid", "image", "one", "sid", "oid", "h", "uri", "rid", "token", "json", "uid", "edit", "ref", "hex", "ident", "no", "i", "event", "code", "create", "hash", "data", "name", "ids", "tag", "db", "ip"], "xml": ["xf", " XML", "message", "chart", "css", "template", "format", "pp", "parse", "sheet", "http", "sql", "context", "output", "m", "file", "php", "sv", "t", "ql", "csv", "md", "s", "zip", "string", "tx", "html", "x", "image", "n", "txt", "cloud", "om", "img", "batch", "tree", "document", "msg", "json", "text", "body", "im", "report", "pdf", "tml", "mail", "log", "ml", "export", "content", "print", "model", "response", "name", "px", "doc"], "url": ["b", "dl", "cert", "http", "URL", "git", "r", "f", "open", "comm", "l", "ur", "gl", "link", "client", "cl", "loader", "nl", "dll", "loc", "hl", "lb", "q", "cmd", "addr", "handle", "rl", "socket", "ref", "ret", "build", "Url", "re", "con", "mb", "ssl", "connection", "resource", "ul", "bel", "base", "res", "rel", "ll", "mount", "att", "service", "sl"], "conn": ["obj", "Conn", "ctx", "Connection", "http", "open", " err", "nt", " net", "client", "cb", " con", "n", "txt", " cur", " cs", "w", "socket", "ch", " connection", "Url", "con", "connection", " res", "res", "ws", "j"], "reader": ["read", "iter", "rer", "Reader", "dr", "http", "input", "r", "wrapper", "context", "nt", "file", "ser", "rx", "rc", "parser", "reads", "client", "loader", "roller", "ri", "rar", "stream", "row", "in", "rl", "er", "runner", "io", "handler", "ner", "writer", "reading", "worker", "iterator", "buffer", "rot", "connection", "resource", "inner", "cur", "ro"], "str": ["ls", "obj", "pt", "cs", "block", "iter", "it", "r", "del", "err", "comm", "z", "m", "bl", "t", "s", "bc", "exec", "Str", "string", "entry", "n", "next", "txt", "source", "p", "arr", "char", "part", "tr", "sp", "msg", "cr", "st", "set", "text", "w", "STR", "exp", "hex", "e", "line", "chain", "cont", "gr", "print", "inner", "syn", "qs", "data", "name", "j", "ev", "fr"]}}
{"id1": "3683344", "id2": "8973505", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"genRandomGUID": [" genRandomSuid", " genRandUU", " genRandomGuid", " genRandGU", " genRandGUID", " genRandomRandomuid", " genRandomGID", " genRandGID", " genRandomUUID", " genRandUID", " genRandomUU", " genRandGuid", " genRandomRandomUID", " genRandomSID", " genRandomRandomU", " genRandomSUID", " genRandUUID", " genRandUuid", " genRandomSU", " genRandomRandomID", " genRandomGU", " genRandomUID", " genRandomUuid"], "secure": ["check", "weak", "quiet", "id", "force", "speed", "sync", " securely", "free", "encrypted", "sec", "sr", "protect", "stable", "pretty", "https", "safe", "client", "google", "confirmed", "domain", "strong", "close", "prime", "trust", "sys", "sensitive", "clear", "status", "ie", "deep", "nice", "ssl", "active", "server", "security", " Secure", "Secure", " insecure"], "valueBeforeMD5": ["valueUnderMM5", "valueUnderMM25", "valueBeforeSHA523", "valueAfterMD0", "valueBeforeND0", "valueBeforeMT25", "valueAfterMDInvalid", "valueBeforeMT2", "valueAfterMD3", "valueBeforeMD523", "valueBeforeMD4", "valueBeforeMT0", "valueAfterDER5", "valueAfterMD4", "valueBeforeMOD2", "valueBeforeID2", "valueUnderMD0", "valueBeforeMODFive", "valueBeforeND3", "valueBeforeDER5", "valueAfterND5", "valueBeforeMM0", "valueBeforeSHA2", "valueBeforeMDInvalid", "valueBeforeDER2", "valueBeforeMD2", "valueBeforeID4", "valueUnderMM0", "valueBeforeND2", "valueAfterND3", "valueBeforeRD5", "valueBeforeMD0", "valueAfterND4", "valueBeforeID3", "valueBeforeSHAInvalid", "valueBeforeMD25", "valueBeforeMTFive", "valueBeforeRDInvalid", "valueAfterND2", "valueBeforeMM25", "valueBeforeRD523", "valueBeforeDERFive", "valueBeforeND25", "valueBeforeMM5", "valueBeforeDER0", "valueBeforeRD2", "valueAfterDERFive", "valueUnderMD25", "valueAfterMD523", "valueBeforeMD3", "valueBeforeND5", "valueAfterDER0", "valueAfterMD2", "valueAfterDER2", "valueBeforeMDFive", "valueBeforeMT5", "valueUnderMD5", "valueBeforeND4", "valueBeforeSHA5", "valueBeforeID5", "valueBeforeMOD5", "valueBeforeMOD0", "valueAfterMDFive"], "valueAfterMD5": ["valueAfterMD55", "valueAfterMC5", "valueAfterCD2", "valueAfterMIPE", "valueAfterEMLeft", "valueAfterMM3", "valueAfterMDLeft", "valueAfterMM4", "valueAftermdPE", "valueBeforeMDRL", "valueAfterMDOK", "valueWithoutMDOK", "valueAfterMTdown", "valueWithoutmd2", "valueAfterMD3", "valueAfterMCdown", "valueBeforeMD4", "valueAfterMI2", "valueAfterMD4", "valueWithoutMDPE", "valueBeforeMM4", "valueBeforeMD8", "valueAfterMDPE", "valueafterEM55", "valueBeforeMC5", "valueAfterSD3", "valueafterEM2", "valueAfterUD3", "valueAfterUD5", "valueWithoutmdPE", "valueBeforeMD2", "valueAfterMDdown", "valueBeforeMC2", "valueafterMD2", "valueBeforeMDdown", "valueAftermd2", "valueAfterMT8", "valueAfterSDODY", "valueAfterMC8", "valueafterMD5", "valueBeforeMCdown", "valueafterMD55", "valueAfterCD5", "valueAftermd5", "valueafterEMLeft", "valueafterMDLeft", "valueAftermdOK", "valueAfterEM2", "valueWithoutmd5", "valueAfterMC4", "valueAfterSD5", "valueAfterMC3", "valueAfterMT2", "valueWithoutmdOK", "valueAfterEM55", "valueBeforeMM5", "valueAfterMM5", "valueAfterUDODY", "valueafterEM5", "valueAfterMI5", "valueAfterMTLeft", "valueAfterMT5", "valueAfterMD8", "valueAfterUDRL", "valueBeforeMD3", "valueAfterMT55", "valueAfterMM2", "valueAfterMIOK", "valueAfterMD2", "valueAfterEM5", "valueAfterMT3", "valueAfterMDODY", "valueBeforeMM3", "valueAfterMDRL", "valueWithoutMD5", "valueBeforeMM2", "valueAfterCDdown", "valueAfterMC2", "valueBeforeMDODY", "valueAfterSDRL", "valueWithoutMD2"], "md5": ["metadata25", "dig3", " MD3", "MD3", "dig2", " md3", "md3", "metadata3", "metadata5", "MD2", " md25", "MD7", " MD2", " MD7", "MD5", "md2", "md25", "metadata2", "md7", " md7", "dig5", " MD5", " md2", "MD25"], "sbValueBeforeMD5": ["sbValueBeforeLM2", "sbValueBeforeMD45", "sbValueAfterMD05", "sbValueBeforeMD2", "sbValueBeforeMED25", "sbValueBeforePD5", "sbValueBeforemd5", "sbValueInsideMD305", "sbValueBeforePD2", "sbValueInsideAMD5", "sbValueBeforemd2", "sbValueFrontMD65", "sbValueInsideMD5", "sbValueBeforeMED45", "sbValueBeforeND5", "sbValueBeforeSDNot", "sbValueBeforeMON5", "sbValueFrontMD20", "sbValueFrontMD2", "sbValueBeforeAND5", "sbValueAfterMD5", "sbValueBeforeMED5", "sbValueAfterMS25", "sbValueDefMD5", "sbValueFrontLM5", "sbValueBeforeMDLE", "sbValueBeforeMON512", "sbValueBeforeMT2", "sbValueAfterMS3", "sbValueBeforeAMD305", "sbValueBeforeMD3", "sbValueBeforeMTFive", "sbValueBeforeMED2", "sbValueBeforeMT65", "sbValueBeforemd45", "sbValueBeforeAND2", "sbValueBeforeMOD45", "sbValueBeforeSD5", "sbValueAfterMDFive", "sbValueBeforeND2", "sbValueAfterMDLE", "sbValueAfterMS5", "sbValueBeforeMEDNot", "sbValueDefMD45", "sbValueBeforeSD2", "sbValueBeforeMD05", "sbValueBeforeMED3", "sbValueBeforeMT5", "sbValueBeforeMS3", "sbValueInsideAMD512", "sbValueBeforeMS45", "sbValueBeforemdLE", "sbValueBeforeND45", "sbValueAfterMS45", "sbValueFrontLM2", "sbValueInsideAMD305", "sbValueInsideAMD2", "sbValueBeforeLM20", "sbValueBeforeAND05", "sbValueAfterMD45", "sbValueFrontMD5", "sbValueBeforeMOD25", "sbValueBeforeMT05", "sbValueAfterMD2", "sbValueFrontLM20", "sbValueBeforeLM65", "sbValueBeforeMS5", "sbValueBeforeMDNot", "sbValueAfterMDNot", "sbValueBeforeMDOK", "sbValueDefmd45", "sbValueBeforeMOD5", "sbValueBeforeMON2", "sbValueFrontLM65", "sbValueDefmd2", "sbValueBeforeMD65", "sbValueInsideMD512", "sbValueBeforeAMD5", "sbValueAfterMD25", "sbValueBeforeMT20", "sbValueBeforeLM5", "sbValueBeforeMDFive", "sbValueDefMD2", "sbValueInsideMD2", "sbValueBeforeMD20", "sbValueBeforeMOD3", "sbValueBeforeANDFive", "sbValueBeforeMD512", "sbValueBeforePDLE", "sbValueBeforeMD25", "sbValueBeforemdOK", "sbValueBeforeAMD512", "sbValueAfterMDOK", "sbValueBeforeMS25", "sbValueBeforePDOK", "sbValueAfterMD3", "sbValueBeforeMD305", "sbValueBeforeAMD2", "sbValueBeforeMON305", "sbValueDefmd5"], "time": ["user", "counter", "value", "TIME", "ts", "id", "tc", "runtime", "times", "etime", "t", "frame", "hour", "lock", "age", "size", "system", "ty", "window", "estamp", "year", "tim", "clock", "sequence", "length", "Time", "port", "race", "ime", "duration", "timer", "event", "date", "total", "now", "start", "timeout", "name", "order", "rate"], "rand": ["inv", "nd", "ng", "range", "rest", "dr", "mid", "init", "id", "rss", "with", "r", "pick", "z", "grad", "nt", "std", "reg", "and", "roll", "seed", "rc", "rt", "md", "kick", "gt", "pid", "random", "rank", "did", "sid", "rid", "trust", "sys", "cr", "uid", "round", "ripp", "rh", "dist", "rot", "rd", "max", "frac", "res", "sample", "hash", "gz", "Rand", "rate", "fine"], "array": ["ami", "external", "range", "collection", "at", "storage", "value", "number", "audio", "Array", "binary", "ary", "save", "amount", "list", "instance", "map", "ash", "app", "ashes", "string", "vector", "our", "aster", "random", "row", "share", "arr", "batch", "angle", "area", "archive", "upper", "length", "stack", "stage", "arrow", "RAY", "ray", "aw", "v", "assets", "rays", "hash", "data", "angular", " Array", "atomic", "var"], "strTemp": [" strTem", "hexCmd", "stringTest", "strtemp", "brTemplate", "stringTemp", "txtTemp", "arrMods", "stringPtr", "frPtr", "strTest", "arrTem", "stringUnt", "STRTem", "brTem", " strUnt", "strNew", " strNew", "frTemplate", "strCmd", "strUnt", "STRNew", "strTem", " strCmd", "frTemp", "txtTr", "brTemp", "arrPtr", " strTemplate", "stringTem", " strtemp", "stringMods", "txtTem", "drMods", " strTest", "arrUnt", "arrNew", "drTemp", "hexTr", "STRtemp", "brPtr", "drPtr", "strTemplate", "arrTest", "STRTemp", "hexTemp", "strMods", "strPtr", "strTr", "frTem", " strTr", "arrTemp", " strPtr", "arrtemp", "txtCmd", "hexTem", "drTem"], "i": ["b", "ogi", "init", "us", "gi", "id", "qi", "xi", "it", "info", "\u0438", "ci", "li", "I", "m", "ai", "ix", "iq", "hi", "gu", "x", "bi", "c", "ki", "ii", "a", "q", "u", "multi", "mi", "uri", "num", "ic", "in", "index", "y", "ind", "im", "phi", "sim", "ji", "chain", "si", "yi", "v", "ei", "pi", "ti", "cli", "name", "j", "ui", "di", "ini"]}}
{"id1": "5061606", "id2": "14598566", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNeccessary", "createSettingsIfNacessary", "createSettingsIfNeccesar", "createSettingsIfNecessed", "createSettingsIfNacessed", "createSettingsIfNecessesary", "createSettingsIfNeccessible", "createSettingsIfNacessesary", "createSettingsIfNacessesible", "createSettingsIfNecessar", "createSettingsIfNacessar", "createSettingsIfNecessible", "createSettingsIfNeccesible", "createSettingsIfNecessesar", "createSettingsIfNacessesar", "createSettingsIfNacessible", "createSettingsIfNecessesed", "createSettingsIfNeccessar", "createSettingsIfNacessesed", "createSettingsIfNeccesed", "createSettingsIfNeccessed", "createSettingsIfNecessesible", "createSettingsIfNeccesary"], "out": ["inv", "obj", "ex", "init", "or", "OUT", "net", "note", "ou", "on", "it", "write", "f", "err", "output", "that", "nt", "ion", "file", "oe", "list", "t", "cos", "oss", "bo", "client", "again", "Out", "n", "end", "null", "one", "os", "go", "ent", "exit", "cn", "gc", "to", "flush", "off", "up", "io", "ne", "sys", "outs", "w", "report", "ch", "writer", "conv", "OU", "cho", "log", "yes", "con", "conn", "co", "server", "print", "aos", "res", "o", "outer", "timeout", "max", "ot", "can", "comment"], "fSettings": ["eSettings", "finalOptions", "sfsettings", "hsettings", "finalsettings", "finalSetting", "esettings", "hSetting", "cfSetting", "fChanges", "sfOptions", "sfSetup", "cfSettings", " fSetup", "finalSettings", "cfSetup", "bfSettings", "fsettings", "cfsettings", "sfSetting", "sfSettings", "fSetup", " fSetting", "bfsettings", "sfChanges", "fSetting", "bfSetting", " fChanges", "bfChanges", "fOptions", "hSettings", "eSetting", " fsettings", " fOptions"], "src": ["dest", "ls", "th", "sc", "url", "filename", "tmp", "pkg", "ser", "config", "dir", "rx", "sr", "rc", "rt", "ur", "sq", "root", "loc", "fn", "rs", "txt", "source", "img", "rl", "attr", "sys", "spec", "view", "desc", "sb", "upload", "cont", "sf", "resource", "syn", "cur", "rel", "sit"], "in": ["In", "ad", "iter", "is", "sin", "init", "input", "rin", "id", "info", "r", "ln", "IN", "inn", "and", "l", "inside", "inf", "bin", "vin", "ins", "n", "source", "from", "en", "din", "isin", "cin", "i", "gin", " din", "inner"]}}
{"id1": "7981642", "id2": "11865906", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"update": ["commit", "reply", "change", "put", "place", "Update", "check", "auth", "init", "read", "store", "register", "input", "write", "save", "login", "config", "apply", "add", "append", "UPDATE", "feed", "load", "alter", "test", "printf", "move", "touch", "up", "handle", "username", "mod", "set", "text", "edit", "post", "delete", "upload", "insert", "updated", "remove", "escape", "create", "pack", "data", "replace", "sample"], "mail": ["message", "iter", "dl", "com", "Email", "cert", "net", "http", "tp", "id", "grid", "url", "ip", "eth", "del", "address", "mobile", "pkg", "m", "file", "dir", "ln", "zip", "md", "link", "test", "virtual", "gmail", "n", "domain", "mails", "alt", "label", "host", "Mail", "dn", "cmd", "addr", "username", "el", "msg", "old", "imp", "im", "mm", "port", "dial", "pl", "log", "enter", "server", "hold", "print", "mem", "name", "mount", "mun", "local", "dm", "mill"], "email": ["external", "message", "ilo", "Email", "template", "atom", "note", "number", "url", "sql", "address", "del", "file", "ln", "m", "echo", "zip", "phone", "link", "cdn", "html", "nl", "nm", "virtual", "image", "test", "n", "domain", "ns", "label", "detail", "host", "object", "dn", "cn", "uri", "addr", "il", "xml", "password", "username", "el", "text", "e", "log", "entity", "line", "enter", "date", "server", "et", "sample", "example", "name", "IL", "ip"], "pwd": ["pressw", "Pws", "pressws", " pword", "Pw", " pow", "psow", "pswd", "Pfx", "Pgen", "dpw", "dpgen", "pfx", " pw", "psw", " ppriv", "psfx", "ppriv", "pws", "Pword", "Pow", "pw", "Pwd", "dpwd", "dpword", "presspriv", "presswd", " pfx", "pow", "pword", " pgen", " pws", "Ppriv", "pgen"], "firstname": ["smallNAME", "firstName", " firstrun", " firstName", "firstnames", " firstNAME", "firstrun", "firstparent", "firstNAME", " firstparent", "smallrun", "FirstName", "lastnames", "lastNAME", "lastName", "Firstparent", "lastrun", "smallname", " firstnames", "Firstnames", "smallName", "Firstname", "lastparent", "FirstNAME"], "lastname": ["firstName", "longnum", "longname", "givenname", "firstnum", "fullName", "lastame", " lasttype", "givenName", "fullname", "lasttype", "lastName", " lastnum", " lastame", "longName", "giventype", "firstame", "fullame", "lastnum", "longame", " lastName", "firsttype", "givennum"], "connection": ["collection", "creator", "Connection", "application", "context", "database", "onet", "ion", "description", "session", "link", "network", "directory", "client", "entry", "system", "connected", "management", "c", "cone", "document", "nc", "command", "handler", "engine", "city", "conn", "con", "condition", "event", "resource", "communication", "response", "connect", "relation", "pool"], "attrs": ["atrys", "addrs", "latributes", "atras", " attras", "avrs", "attrd", "atrd", "attachRs", "attsrics", "adrs", "atries", "attRs", " attRs", " attries", "attributes", "latrs", "addrd", "addras", "avras", "atters", " attrd", "attrics", "addributes", "atrs", "actrs", "adributes", "attters", " attds", " attns", "attrys", "attds", "attps", "adras", "actters", "actributes", "atributes", "atds", "atRs", "attachrs", "latters", "actrys", "latrys", "atps", "attsries", "addRs", "attsrs", "adns", "atns", "attachras", "attsributes", " attps", "avrics", "avributes", "attras", "attsras", "attries", " attributes", "atrics", "attachributes", "attsds", "attns", "attsps"], "sha": ["shi", "lambda", "SHA", "ppa", " SHA", "ka", "pa", "git", "tar", "iso", "da", "func", "shell", "ma", "ssh", "wa", "mac", "cos", "md", "shared", "sq", "hi", "asha", "a", "acl", "go", "h", "comp", "ha", "ya", "sh", "sam", "HA", "sche", "has", "ca", "ksh", "no", "mb", "sa", "total", "sum", "alpha", "auto", "mem", "sm"], "digest": ["dest", "Digge", "mdEST", "dighest", " digEST", "digEST", "mdse", "dested", "dge", "Digests", "mdests", "redest", "mdhest", "digested", "mdest", "Digest", "divest", "divEST", "digests", "Digse", " digests", "redests", "redge", "dests", "redested", "digge", "divse", "DigEST", "Digested", "mdested", "divhest", "digse", "Dighest", " digested"], "hash": ["message", "check", "auth", "format", "flash", "cache", "input", "search", "ash", "mac", "ashes", "md", "ASH", "html", "key", "score", "h", "ha", "trust", "handle", "dump", "password", "sh", "result", "shadow", "has", "hex", "bh", "dig", "Hash", "rh", "total", "sum", "print", "proof", "base", "tag", "each", "filter"], "ctx": ["obj", "Conn", "tc", "gm", "sc", "context", "tmp", "nt", "pkg", "mk", "bc", " cx", "rc", "ctr", "xc", "kw", "tz", "tx", " context", "sq", "cb", "x", "wx", "dc", "loc", "txt", "tk", "mc", "cp", "cv", "gc", "ct", "cm", "cmp", "nc", "cu", "kl", "conv", "ca", "ctrl", "conn", "con", "jp", "ck", "co", "cf", "Context", "np", "pg", "lc"], "newName": ["newKey", "currentKey", "newname", "currentname", "oldname", "currentName", "finalHome", " newKey", " newname", "NewNAME", "currentNAME", " newNAME", "finalName", " newNames", "newNAME", "newHome", "NewName", "Newname", "finalNames", "newNames", "finalname", "oldNames", "oldHome", "NewKey", " newHome"], "oldName": ["olderPref", "newname", "olderKey", "oldername", " oldKey", " oldPref", "newOr", "oldname", "smallOr", "recentOr", "olderName", "prevName", "oldAnd", "recentName", "prevKey", "smallAnd", "prevPref", "newAnd", "oldPref", "recentAnd", "smallname", "oldOr", "smallName", "prevname", "recentname", " oldname", "oldKey"]}}
{"id1": "8330057", "id2": "8490297", "code1": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 0, "substitutes": {"getHttpURL": ["getHTTPUrl", "printHTTPUrl", "getHttpAddress", "getHTTPURL", "printHttpAddress", "getHttpUrl", "printHTTPurl", "getServiceAddress", "printHTTPURL", "getHTTPurl", "printHttpurl", "printHttpURL", "getServiceurl", "getServiceURL", "getHttpurl", "gethttpURL", "getHTTPAddress", "gethttpUrl", "getServiceUrl", "printHttpUrl", "printHTTPAddress", "gethttpAddress", "gethttpurl"], "url": ["path", "full", "pp", "str", "https", "nl", "image", "loc", "domain", "source", "label", "host", "u", "method", "util", "xml", "build", "connection", "resource", "name", "format", "URL", "lr", "id", "parser", "key", "window", "default", "result", "ref", "ll", "www", "dl", "api", "ur", "link", "string", "ocl", "html", "term", "page", "img", "gc", "github", "version", "ret", "buffer", "ssl", "ul", "res", "base", "location", "data", "pl", "mount", "channel", "sl", "http", "type", "download", "address", "l", "web", "null", "uri", "document", "msg", "impl", "Url", "server", "hub"], "uc": ["BC", "ucc", "oc", "uph", "us", "uf", "uu", "tc", "sc", "ocr", "ci", "func", "auc", "kt", "fc", "pc", "bc", "uci", "rc", "ur", "ut", "asc", "cc", "cl", "orc", "utt", "c", "uds", "uca", "mc", "u", "ac", "gc", "ct", "roc", "ud", "unc", "pac", "icc", "cus", "util", "ubis", "eu", "nc", "userc", "uh", "UC", "soc", "lu", "aus", "uid", "cu", "usc", "ub", "ux", "unsigned", "um", "universal", "ctrl", "con", "ul", "cur", "anc", "ru", "ui", "uv", "lc", "uma"], "allHeaders": [" allSignERS", "allheadered", "allHeadels", "AllHoldERS", "allBuffsters", "allHeadsters", " allHeadheaders", "allheaders", "allSigners", " allHeadERS", "allBuffERS", "allHoldels", " allSignels", " allHeadels", "allFootheaders", "AllHoldered", "AllHeadERS", "allHoldsters", "allFooters", "AllHeadered", "allHolders", "allSignheaders", "allHeadered", "allheadsters", "allSignERS", "allHoldERS", "AllHeadsters", "allHeadERS", "allFootERS", "allHoldheaders", "allHoldered", "AllHoldsters", "AllHeaders", " allSignheaders", "allheadERS", " allSigners", "allBuffered", "allSignels", "allHeadheaders", "allFootels", "allBuffers", "AllHolders"], "itHeaders": ["itHeadings", "itHEADers", " itDefERS", "itHosttons", "ItHeaderings", "itHeaderlers", "itHeaderings", "itMaclers", "itHEADles", " itDefs", "itHolds", "ItHeaderers", "itHolders", " itHeads", "icHeadters", "itHoldERS", "itHEADERS", "itHeads", "itHeaderers", "itHeadtons", "icHosttons", "icHeadERS", "itHEADters", "itHeaderters", "itHeaderERS", "ItHeads", "itHeadertons", "ItHeaders", "itDefles", "icHostters", "itHEADlers", "itHEADtons", "itHEADings", "icHeadtons", "icHeaders", "itHostters", "itMacings", "icHostERS", "itHeadlers", "icHosters", " itHeadles", "ItHeaderlers", "itHeadles", "itHostERS", "ItHeadlers", " itDefers", "itHosters", "itDefers", " itDefles", "itDefERS", "itHEADs", "itDefs", "ItHeadings", "itMacers", "itMacs", "itHoldles", "itHeadters", " itHeadERS", "itHeadERS"], "e": ["ce", "r", "be", "oe", "xe", "l", "se", "eg", "entry", "ae", "de", "ue", "end", "one", "le", "ent", "ze", "pe", "ve", "ea", "ed", "er", "eu", "ne", "owner", "el", "element", "ge", "E", "te", "ie", "es", "ec", "re", "ke", "eur", "et", "ei", "ele", "ev", "ee"], "itValues": ["Itvalues", "litContents", "iVs", "litValues", "ritFrames", "ItItems", " itKeys", "itItems", "ITvalues", "atvalues", "iKeys", "ritVs", "ITVersions", "ItContents", "itVersions", "atVersions", "litVersions", "ritValues", "iFrames", "ITContents", "itFrames", "atItems", "iValues", " itVs", "itvalues", "ItValues", "itContents", "ITValues", "ItVersions", "ITItems", "itKeys", "atValues", "itVs", "litvalues", " itFrames", "ritKeys"], "in": ["In", "ad", "is", "input", "rin", "it", "r", "m", "IN", "inn", "l", "inf", "bin", "stream", "ins", "n", "this", "from", "inc", "mc", "en", "mi", "ic", "io", "ind", "din", "cin", "i", "inner", "o"], "display": ["change", "read", "flash", "draw", "store", "register", "lo", "dis", "PLAY", "download", "enable", "enabled", "description", "debug", "link", "browser", "load", "summary", "html", "color", "label", "details", "screen", "visible", "relevant", "layout", "field", "view", "embed", "style", "report", "show", "position", "clear", "Display", "render", "friendly", "hide", "print", "play", "replace", "DIS"], "reader": ["read", "driver", "iter", "Reader", "dr", "parse", "r", "older", "ser", "editor", "rx", "parser", "proc", "loader", "builder", "roller", "rar", "stream", "row", "dd", "layer", "er", "rl", "runner", "io", "upper", "handler", "ner", "rr", "body", "writer", "reading", "worker", "iterator", "buffer", "inner", "readable", "ro"], "s": ["ls", "cs", "gs", "is", "full", "gets", "ges", "acs", "ts", "ds", "ves", "fs", "vs", "ans", "ats", "sv", "prints", "l", "se", "str", "string", "less", "sts", "sq", "ends", "tes", "rs", "still", "ins", "os", "p", "h", "als", "S", "y", "fts", "hs", "its", "js", "aws", "sb", "ps", "stats", "ss", "qs", "sample", "ws", "ms", "es", "ims", "ns"], "contentType": ["filetype", "contenttype", " contentTime", "fileTypes", "Contenttype", "ContentTime", "ContentType", " contentTypes", " contenttype", "fileTime", "ContentTypes", "contentTypes", "contentTime", "fileType"], "filename": ["path", "wrote", " fn", "write", "face", "fs", "f", "output", "ename", "FN", " writer", "fp", "bf", "Filename", " path", "nm", " name", "fn", "uri", "fil", "ame", "writer", "ername", "name", " fil"]}}
{"id1": "8329093", "id2": "18570190", "code1": "    public void parse(ParserEvent event) {\n        logger.debug(\"parse() called for link \" + event.getLink().getURI());\n        if (event.getLink().getURI().matches(itemFilter)) {\n            logger.debug(\"Content \" + event.getLink().getURI() + \" matched\");\n            Statement stmt = null;\n            ResultSet rs = null;\n            long checksum1 = 0;\n            try {\n                URL url = new URL(event.getLink().getURI());\n                checksum1 = url.openConnection().getLastModified();\n            } catch (MalformedURLException mfe) {\n                logger.error(\"Malformed url \" + event.getLink().getURI() + \" - \" + mfe.getMessage());\n                return;\n            } catch (IOException ioe) {\n                logger.error(\"Couldn't read \" + event.getLink().getURI() + \" - \" + ioe.getMessage());\n                return;\n            }\n            if ((checksum1 == 0) || (checksum1 == 1)) {\n                Adler32 adler32 = new Adler32();\n                NodeList nodes = (NodeList) event.getPageData().getData();\n                adler32.update(nodes.toHtml().getBytes());\n                checksum1 = adler32.getValue();\n            }\n            try {\n                stmt = conn.createStatement();\n                rs = stmt.executeQuery(\"SELECT * FROM documents WHERE url='\" + event.getLink().getURI() + \"'\");\n                if (rs.first()) {\n                    long checksum2 = rs.getLong(\"checksum\");\n                    if (checksum1 == checksum2) {\n                        stmt.executeUpdate(\"UPDATE documents SET checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    } else {\n                        stmt.executeUpdate(\"UPDATE documents SET checksum=\" + checksum1 + \", checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    }\n                } else {\n                    stmt.executeUpdate(\"INSERT INTO documents VALUES \" + \"(DEFAULT, '\" + event.getLink().getURI() + \"', \" + checksum1 + \", '\" + providerId + \"', \" + String.valueOf(System.currentTimeMillis()) + \")\");\n                }\n            } catch (SQLException e) {\n                logger.error(\"Could't perform database query or update - \" + e.getMessage());\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    rs = null;\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    stmt = null;\n                }\n            }\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["read", "match", "init", "format", "update", "apply", "parser", "se", "link", "load", "send", "rule", "patch", "arse", "page", "handle", "document", "handler", "get", "build", "render", "fire", "process", "print", "start", "execute", "scan"], "event": ["external", "device", "on", "info", "app", "after", "arg", "ext", "image", "ent", "archive", "attribute", "element", "except", "enc", "e", "log", "connection", "response", "dev", "when", "ex", "let", "context", "ow", "age", "window", "flow", "command", "result", "state", "ec", "now", "att", "ev", "vent", "message", "empty", "ctx", "information", "argument", "error", "instance", "request", "config", "network", "load", "this", "page", "action", "events", "initial", "owner", "el", "exp", "claim", "comment", "atom", "it", "address", "author", "rule", "from", "object", "exc", "cmd", "er", "document", "handler", "msg", "view", "form", "content", "Event", "complete", "ay"], "stmt": ["spmt", "stgt", "stmp", "STm", "STmm", "ostmm", "stMT", "stms", "strmt", "STMT", "ostMT", "StMT", "Stmm", "stm", "stmm", "spgt", "Stpt", " stm", " stmp", " Stmt", "stmb", "Stmt", "ostmt", " stpt", "Stm", "strMT", "ostmb", "Stms", " Stm", "STmt", "Stgt", " stmm", "strmm", "spMT", " Stmp", " stMT", " stms", "STpt", "stpt", " stgt", "strmb", "spm", "Stmp", " stmb", " Stms"], "rs": ["ls", "cs", "gs", "otes", "arms", "ges", "vals", "ts", "amps", "ds", "fs", "vs", "ys", "usr", "ows", "vers", "ues", "ats", "times", "sr", "RS", "rc", "rt", "rings", "ares", "ags", "ras", "sts", "caps", "rets", "results", "rows", "ins", "xs", "ars", "ris", "Rs", "hr", "bs", "rl", "arts", "ires", "rys", "icks", "acks", "hs", "its", "js", "rates", "ps", "ks", "els", "rd", "pps", "ros", "res", "mr", "qs", "ws", "ms", "ems", "sels", "ims"], "checksum1": ["cksum0", "csum51", "checksump4", "cssum2", "checksatumOne", "ckssumone", "cksum15", "cksum1", "checksums3", " checksumer2", "checksnum1", "checksum4", "checksnumone", "cssumOne", "checkssum81", "checksum51", "checksums01", "csumOne", "checksave15", "checkssum1", "checkssum15", "cssum51", "checksum81", " checksum4", " checksumer1", " checksum01", "ckssum2", "ckssum81", "cksumOne", "checksummOne", "checksumOne", "checksumm2", "checksumpone", " checksumer4", " checksumer01", "cksum2", "checksamOne", "cksum3", "cksums0", "checksnum0", "checksumone", "checksum01", "checksuum2", "ckssum4", "checkssum01", "checksam1", "checkssum51", "checksumer2", "cksum81", "cssum0", "checksave81", "checkssumOne", "checksatum51", "checkssum3", "cksums2", "checksatum0", "ckssum15", "checksnum4", "ckssumOne", "checksnum2", "checksnumOne", "checksums0", "checksumm0", "checksumm51", "cksums1", "ckssum1", "csum1", "checksums4", "checksuum1", "checksump1", "checksumer01", "checksuum81", "checksumer4", "checkssum0", "checkssum4", "cksum4", "checksums2", "checksumsOne", "checksum3", "checksum0", "checkssumone", "checksump2", "cksumone", "checksum15", "checksnum3", "checkssum2", "checksam2", "checksamone", "csum0", "cssum1", "checksums1", "checksuum15", "checksave2", "checksave1", "checksumm1", "checksumer1", "csum2", "checksatum1", "cksums3"], "url": ["ls", "b", "path", "item", "dl", "cert", "value", "http", "URL", "lr", "id", "input", "r", "f", "open", "error", " URL", "file", "abs", "UR", "l", "ur", "link", "str", "string", "browser", "load", "job", "web", "html", "nl", "image", "loc", "null", "page", "u", "uri", "char", "rl", "document", "result", "msg", "cal", "ol", "ref", "get", "log", "Url", "build", "mail", "conn", "buffer", "ssl", "connection", "content", "resource", "ul", "bel", "location", "base", "data", "rel", "ll", "name", "sl"], "adler32": [" adler64", "adsler32", "adling30", "adll33", " adlder31", " adle34", "adder40", "adger31", " adler16", "adll31", "adsll32", "adling32", "adlder34", "adle16", "adler30", "adlder16", "adger34", "adder32", "adder30", "adle31", "adler34", "adle34", "adler31", "adsler64", "adlder40", " adler31", "adsll64", "adlder31", "adsll33", "adlder30", "adling40", "adsler33", " adle64", "adger16", " adle32", " adlder32", " adle16", "adling31", "adger64", "adlder32", "adlder64", "adler40", "adll32", " adler40", "adsll31", "adsler31", "adle32", " adlder40", "adll64", "adle64", "adler16", "adler33", "adger32", "adder31", " adlder30", "adler64", "adger33", "adle33", " adler30", " adler34"], "nodes": [" nets", "Nos", "Node", " node", "Noms", "noms", "Nods", "renodes", " nods", "Nodes", "mnets", "Nets", "renos", "nods", " noms", " nos", "renode", "mnoms", "nos", "nets", "mnodes", "node", "mnode", "renods"], "checksum2": ["checksnum02", "checksume2", "checksums02", "checkssum02", "checksum3", " checksum3", " checksnum21", "checksums3", "checksume02", "checksnum21", "checksnum1", " checksnum1", "checkssum3", "checksume21", "checksnum3", "checkssum2", " checksum21", " checksnum3", "checksume1", "checksnum2", " checksum02", "checkssum1", "checksum02", "checkssum21", "checksums1", " checksnum02", " checksnum2", "checksums2", "checksum21"]}}
{"id1": "189963", "id2": "18433984", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrites", "readAndRepWrite", "readAndResWrite", "readAndRewend", "readAndResend", "readAndrewrite", "readAndrewWrite", "readAndResrite", "readAndRewrites", "readAndrewrites", "readAndReprite", "readAndrewend", "readAndRewWrite", "readAndRepend", "readAndReprites"], "inFile": ["InFile", "inputFilename", "docFile", "docFILE", "iFILE", "iFilename", "INTime", "inFILE", "InFilename", "initPlace", "initFilename", "inputPlace", "docTime", "inFace", "outfile", "infile", "iFile", " inFilename", "initFile", "inPlace", "INPlace", "docFilename", " infile", "inTime", "Infile", "initFace", "INFace", "iTime", "INFilename", "INFile", "INFILE", "inputFile", "inputFace", "inFilename", "outFilename"], "outFile": ["reportFile", " outFilename", "checkFilename", "outFILE", "inFILE", "toFILE", "reportFILE", "tofile", "nameFilename", "outfile", "infile", " outFILE", "reportfile", "reportFilename", "toFilename", "namefile", "nameFile", "toFile", "checkFile", " outfile", "checkFILE", "inFilename", "outFilename", "nameFILE", "checkfile"], "iis": [" iris", "iiIs", "liris", "iIS", "eis", "aiis", "Iiss", "liisc", "Ii", "liIs", "liis", "eIS", "iiisc", "ii", " iiss", "iiss", "iiis", "iiris", " iIs", "iIs", " iIS", "diIs", " ii", "iisc", "IIs", "eIs", "aiIS", "dii", "aiIs", "diis", " iisc", "iris", "Iis", "diiss"], "dcmParser": ["dgrParser", " dpmListener", "dpcReader", "dpmAssistant", "DpmReader", "dcrparser", "dcommReader", " dpmarser", "dcmListener", "dmoduleReader", "dmoduleAssistant", " dpmStatement", "dpmLoader", "dmmParser", " dcmarser", " dpmparser", "dcommListener", "deromParser", "dpmBuilder", "dromparser", "dcmAdapter", "dcrParser", "dfmParser", "dpmStatement", "dmmmReader", " dcmLoader", "dcomReader", "dcmBuilder", "dromAssistant", "DpmAdapter", "dcrBuilder", "dpmPrivate", " dcmPar", "dcomBuilder", "dcrReader", " dpmReader", "dcommAssistant", " dpmLoader", " dcmStatement", " dcmAssistant", "dmmarser", "dmmparser", "DcmBuilder", "dpmarser", "dgrStatement", " dcmBuilder", "dmmmparser", "dcmparser", "dcfStatement", "dromReader", "dcmAssistant", "decmParser", " dcmListener", "deromarser", "Dpmparser", "decmReader", "DcmParser", "dpmAdapter", " dpmParser", "dcmStatement", "dgrReader", " dpmPar", "DpmPar", "dmReader", "decmarser", "dpcAssistant", "DpmBuilder", "dmmReader", "decmparser", "drumParser", "dromarser", " dpmBuilder", " dcmPrivate", "dpcParser", " dpmAssistant", "dcmLoader", "DcmReader", "dromParser", "dmmmParser", " dcmparser", "dmmAdapter", "DpmParser", "drumReader", "dfmReader", "dpmReader", "dgrPar", "dcmReader", "dcfReader", "deromReader", "Dcmparser", "deromparser", "dcommParser", "dmparser", "drumPar", " dcmReader", "dcmarser", "dmarser", "dcmPrivate", "dpmparser", "dcmPar", "dmParser", "dmmmAdapter", "dpcPrivate", "dcfPar", "dromListener", "dcomParser", "dmodulePrivate", "DcmAdapter", "drumBuilder", "dfmBuilder", "dfmLoader", "dpmListener", "dcomLoader", "dpmPar", "dmoduleParser", "dpmParser", "dcfParser", "DcmPar", " dpmPrivate"], "ds": ["ls", "cs", "dos", "dl", "gs", "eds", "dh", "ils", "fs", "des", "vs", "ys", "da", "der", "sv", "s", "gd", "dds", "sets", " des", "as", "ads", "hd", "dq", "rs", "uds", "tes", "xs", "df", "os", "details", "ins", "pd", "dd", "services", "in", "bs", "Ds", "ods", "sys", "obs", "outs", "dt", "hs", "pers", " DS", "eps", "its", "js", "dat", "bd", "ps", "dx", "ks", "ss", "drivers", "sd", "d", "aos", "qs", "data", "ws", "DS", "db", "es", "ims", "ns"], "pdReader": ["ddHelper", "ddParser", "pdLoader", "xdHelper", "pdParser", "tdWriter", "xdLoader", "tdRead", "ddLoader", "vdLoader", "pdRead", "dpCar", "dpLoader", "ddWriter", "ddReader", "pdCar", "ddRunner", "dpRunner", "pedReader", "tdParser", "hdParser", "tdReader", "pedLoader", "pedCar", "hdRead", "pdRunner", "vdHelper", "xdReader", "pdHelper", "hdWriter", "ddRead", "xdWriter", "dpReader", "vdReader", "pedRunner", "hdReader", "ddCar", "vdWriter"], "out": ["over", "full", "on", " err", "err", "t", "str", "ins", "p", "ent", "outs", "ch", "writer", "log", "conn", "con", "co", "sum", "sw", "v", "o", "auto", "name", "status", "gen", "inv", "obj", "ex", "ou", "all", "id", "nt", "s", "cb", "c", "end", "txt", "os", "nr", "cn", "in", "desc", "conv", "serv", "raw", "inner", "outer", "pool", "cfg", "at", "net", "tmp", "list", "pos", "Out", "n", "en", "up", "io", "sys", "w", "js", "aos", "res", "data", "we", "OUT", "cache", "it", "output", "oss", "client", "gt", "one", "null", "screen", "go", "cmd", "to", "opt", "flush", "msg", "gr", "inter"], "dcmEncParam": ["dcmEnPar", "dcmEnVal", "dcmencCmd", "dcmEncVal", "dcmEnParam", "dcmencParam", "dcmEscPar", "dmmencParam", "dcmDecParam", "dmmEncCmd", "dcmEncCmd", "dcmencNum", "dmmEncMsg", "dmmencNum", "dmmEncPar", "dcmEncPar", "dcmEscNum", "dmmEnPar", "dcmDecCmd", "dcmEncMsg", "dcmEnNum", "dmmEnNum", "dcmEscVal", "dcmDecMsg", "dcmEscParam", "dmmEncParam", "dmmencCmd", "dmmEnParam", "dmmEncNum", "dcmEncNum", "dcmDecNum", "dcmencPar", "dcmencMsg", "dmmEncVal", "dmmencMsg"], "pdWriter": ["dpEditor", "PDReader", "tdWriter", "dpWriter", "pidWrite", "PDWriter", "pdwriter", "pidWriter", "PDWrite", "tdWriting", "tdReader", "PDEditor", "pidwriter", "pidWriting", "dpWrite", "tdwriter", "pcWriter", "pcWrite", "pdWrite", "pdWriting", "pcwriter", "tdWrite", "pdEditor", "pcWriting", "dpReader", "tdEditor"]}}
{"id1": "11716816", "id2": "13563706", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "label": 1, "substitutes": {"updateFile": ["UpdateSourceFile", "downloadContent", "archiveContent", "updateContent", "UpdateContent", "archivePage", "downloadPage", "updateSourceFile", "updatePage", "UpdatePage", "downloadFile", "archiveSourceFile", "UpdateFile", "downloadSourceFile", "archiveFile"], "file": ["message", "path", "issue", "full", "format", "title", "input", "url", "type", "info", "f", "filename", "output", "fp", "use", "t", "link", "entry", "rule", "image", "page", "source", "null", "le", "p", "h", "ile", "handle", "io", "document", "attribute", "report", "port", "FILE", "e", "log", "get", "line", "resource", "content", "base", "data", "name", "db", "channel", "File", "local", "table"], "IOException": ["IOError", "OperationException", "SecurityError", " IOError", "SecurityException", "OperationProblem", "SecurityProblem", "IOProblem", "OperationError", " IOProblem"], "destFile": ["DestPage", "destSourceFile", "DestFile", "tempfile", " destinationDo", " DestFile", "declFolder", " DestDir", "Destile", "destPage", " destPath", "declFile", "DestSourceFile", "declile", " destinationEmail", "destPath", "targetFile", "sourceFolder", " destPlace", "destfile", "targetDir", "targetFolder", " destfile", "optPlace", " destDo", "optPage", " destFolder", "sourceFile", "sourceDir", " destinationDir", "DestFolder", "DestPath", "Destfile", " destSourceFile", " destPage", "tempFile", " destile", " destEmail", "optFolder", " destDir", "tempDir", "DestDir", "targetPath", "tempPath", "declSourceFile", " DestDo", "destFolder", "destDir", "destPlace", " destinationFile", "optFile", "destEmail", "sourcePath", "DestPlace", "destDo", "destile", " DestEmail"], "in": ["In", "read", "iter", "is", "init", "sin", "net", "on", "input", "rin", "it", "al", "all", "r", "f", "pass", "info", "m", "ain", "IN", "ln", "inn", "s", "l", "inside", "inf", "bin", "ai", " IN", "ins", "n", "from", "inc", "en", "mi", "ic", "act", "up", "io", "ne", "ind", "oin", "edIn", "im", "din", "mm", "isin", "ie", "re", "cin", "con", "i", "gin", " din", "raw", "inner", "local", "ini"], "out": ["b", "obj", "ex", "at", "or", "net", "OUT", "note", "ou", "cache", "it", "write", "output", "oe", "nt", "ion", "t", "s", "cos", "oss", "client", "again", "gt", "Out", "n", "one", "null", "fn", "os", "en", " OUT", "cn", "cmd", "to", "flush", "up", "io", "ne", "sys", "outs", "result", "msg", "ch", "conv", "OU", "g", "no", "log", "con", "conn", "jp", "chain", "co", "v", "aos", "o", "outer", "can", "ot", "channel"]}}
{"id1": "1421557", "id2": "23510383", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeStringToFile", "encodeFileToFiles", "encodeStringAsDisk", "encodeFileFromStream", "encodeFileFromDisk", "encodeStringAsFile", "encodeFileAsFiles", "encodeFiletoFile", "encodeFiletoFiles", "encodeStringToStream", "encodeFileAsFile", "encodeFileAsDisk", "encodeFileAsStream", "encodeFileFromFile", "encodeStringAsStream", "encodeStringToDisk", "encodeFiletoDisk", "encodeFiletoStream", "encodeStringToFiles", "encodeFileToStream", "encodeStringAsFiles", "encodeFileToDisk"], "infile": ["InFile", "inputfile", "outbase", "inbase", " inFile", "inFile", "outpath", "Inbase", "outFile", "Inpath", " infilename", "Infile", "outfilename", "infilename", "inpath", "inputpath", "inputfilename", "inputFile", " inpath", " inbase"], "outfile": ["inname", "newfile", " outname", "newname", "newfilename", "newFile", "inFile", "tofile", "todir", "fromfp", " outfilename", "infp", "outFile", "fromfile", "outdir", "indir", "fromdir", "tofp", "toFile", "outfp", " outFile", "outfilename", "infilename", "fromFile", "outname"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "image", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ro", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "null", "fn", "os", "en", "cn", "to", "flush", "up", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "can", "aos", "o", "res", "outer", "inner", "ot"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "queue", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "length", "black", "stack", "temp", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", "commit", "ccess", "cess", "value", "accept", "fail", "growth", "warning", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "ith", "successful", "good", "please", "ceed", "town", "result", "valid", " Success", "successfully", " okay", " failure", "ratulations", "photo", "sufficient", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "17296916", "id2": "20091126", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"logging": ["debugStorage", "Logging", "debugging", "Loging", "logStorage", " logger", "debuging", "logger", "LogStorage", "debugger", "Logger", " logStorage", " loging", "loging"], "wrap": ["xf", "message", "ad", "transform", "read", "format", "parse", "store", "grow", "find", "ew", "force", "wrapper", "wra", "wa", "ow", "use", "zip", "add", "link", "safe", "python", "web", "root", "wx", "x", "window", "word", "rap", "gate", "W", "box", "handle", "work", "sp", " wrapped", "w", "form", " wrapper", "get", "build", "chain", "me", "shape", "pad", "aw", "nw", "sw", "pack", "create", "inter", "start", "ws", "wind", "wire", "reset", "we"], "buffer": ["reply", "message", "library", "block", "header", "iter", "template", "bridge", "display", "note", "flash", "cache", "store", "binary", "face", "wrapper", "output", "database", "reference", "surface", "frame", "append", "trace", "queue", "bo", "directory", "builder", "size", "memory", "Buffer", "window", "row", "word", "quote", "screen", "batch", "flag", "layer", "document", "attribute", "bar", "command", "sequence", "view", "console", "body", "report", "position", "writer", "bb", "line", "buf", "complete", "reset", "print", "base", "buff", "profile", "ob", "phrase", "button", "table", "pb"], "encoding": ["cging", "cryption", "ecoding", "enoding", "encoded", "codryption", "Encaling", "ecoder", "encoder", "enlanguage", "coder", "Encoder", "enoder", "enging", "enclanguage", "clanguage", "enumlanguage", "Encoding", "enryption", "caling", "enaling", "cododer", "enumoding", "enoded", "enumoder", "Encryption", "encryption", "encaling", "encging", "ecoded", "enumging", "cododed", "coding", "cododing", "ecryption"], "getEncoding": ["getEncryption", " getEncling", "getExpryption", "getExpoding", "getencination", "getEnression", "getEncling", "getEnryption", "getEncression", "getencression", "getEncging", " getEncryption", " getEncination", "getExpging", "getEnination", " getEnling", "getencging", " getEncging", "getOrigoding", " getEnryption", "getencoding", "getOrigling", " getEnging", "getencling", " getEnoding", "getExpression", "getencryption", "getOrigryption", "getEnling", " getEnression", " getEncression", "getEnging", "getEnoding", " getEnination", "getOrigination", "getEncination"], "headers": ["header", "pres", "modules", "authors", "chains", "keys", "tags", "builders", "writers", "users", "properties", "head", "params", "comments", "ters", "boxes", "reports", "pins", "heads", "caps", "groups", "checks", "rs", "ilers", "weights", "limits", "frames", "ppers", "images", "ports", "ctors", "codes", "styles", "fields", "relations", "holders", "members", "names", "drivers", "ers", "objects", "ids", "terms", "values", "blocks"], "is": ["nis", "\u00eds", "or", "us", "isl", "was", "fs", "dis", "ys", "iso", "ms", "isd", "bis", "tis", "IS", "ist", "isc", "lis", "as", "ri", "ists", "does", "ins", "iss", "os", "ris", "ic", "in", "osi", "isf", "Is", "bs", "sys", "isi", "its", "has", "isin", "ios", "ais", "i", "sis", "si", "mis", "isa", "ois", "iris", "ui", "obs", "ims", "ip"], "bos": ["cs", "oos", "dos", "bytes", "pod", "ts", "ones", "fs", "oids", "ys", "des", "ms", "ows", "bas", "bis", "banks", "los", "ols", "cos", "tis", "bo", "oss", "bin", "bes", "bi", "uds", "tes", "os", "bits", "tops", "jas", "bs", "ods", "oops", "ubis", "ses", "sys", "bot", "isi", "soc", "uts", "windows", "lets", "js", "ios", "bh", "bones", "ps", "stats", "eros", "nos", "aos", "fits", "ui", "obs", "ots", "boards"], "e": ["ex", "r", "f", "err", "error", "oe", "m", "t", "ate", "se", "ae", "x", "de", "c", "n", "le", "a", "p", "exc", "en", "h", "ed", "er", "eeee", "ne", "ge", "E", "ie", "es", "g", "re", "me", "i", "d", "v", "o", "ev", "ee"]}}
{"id1": "10218878", "id2": "536614", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeFromfile", "DecodeFromFile", "DecodeToFiles", "DecvertMAPfile", "DecvertMAPFiles", "DecodeMAPFiles", "DecodeToLog", "DecvertMapFile", "DecvertMAPLog", "DecodeToFile", "DecvertMapfile", "DecvertMapLog", "DecodeMAPLog", "DecodeMapFiles", "DecodeFromFiles", "DecodeMapfile", "DecodeMAPFile", "DecvertMapFiles", "DecodeFromLog", "DecvertMAPFile", "DecodeMapLog", "DecodeTofile", "DecodeMAPfile"], "mapFile": ["listFile", "mapFilename", "imageFilename", " mapFILE", "listPath", " mapStream", "listFILE", "mapPath", " mapPath", "cacheFile", "MapFile", "cacheFILE", "cachePath", "MapStream", "imagefile", "Mapfile", "imageStream", "imageFile", "mapStream", " mapfile", "mapfile", "mapFILE", "MapFilename", " mapFilename"], "outputFile": [" outputFilename", "OutputFile", "OutputFilename", "mapDir", "writeFile", " outputDir", "inputStream", "inputName", "writeStream", "inputDir", "mapName", "OutputPath", "outFile", "writeDir", "outDir", "writeName", "outputFilename", "OutputDir", "mapStream", "outputStream", " outputPath", "outputDir", "inputFile", "outputPath", "outputName", "outFilename", "outPath"], "magicKey": ["encryptedKey", "encryptedChar", "magicField", " magicCode", "MagicId", "magickey", "prefixValue", "magicCode", "magicValue", "MagicName", "encryptedkey", " magicName", " magicKEY", "anticKey", "magicKEY", " magicCounter", " magicId", " magickey", "magicCounter", "MagicKEY", "uniqueKey", "serialName", " magicField", "prefixCode", "prefixKey", "magicId", "uniqueCounter", " magicValue", "antickey", "anticChar", "MagicKey", "uniqueCode", "serialKey", "serialId", "encryptedField", "anticField", "serialKEY", "magicChar", " magicChar", "magicName", "prefixCounter", "uniqueValue"], "buffer": ["message", "block", "header", "iter", "check", "template", "bridge", "display", "flash", "cache", "binary", "database", "paste", "stroke", "frame", "program", "bone", "bo", "queue", "append", "vector", "memory", "window", "Buffer", "stream", "row", "page", "detail", "screen", "batch", "char", "index", "initial", "document", "attribute", "command", "sequence", "length", "black", "stack", "shape", "buf", "history", "pad", "total", "sum", "print", "code", "base", "sample", "buff", "mem", "phrase", "filter", "button", "table", "variable"], "nread": ["renwrite", " nRead", "rnREAD", "Nget", "rnRead", " nreadable", "nwrite", "nreadable", "NREAD", "ncget", "rnread", "ncRead", "rawreader", "maxget", "nadd", "ncread", "rawtry", "ncwrite", " nREAD", "renread", "ncreadable", "NRead", "nreader", "nRead", "maxRead", "rawread", "ntry", "Nread", "maxadd", "nREAD", "rnwrite", " nwrite", "rentry", " ntry", " nreader", "maxread", "Nadd", "rawwrite", "Nwrite", "nget", "renreader", "Nreadable", "ncadd"], "map": ["read", "block", "place", "com", "bridge", "parse", "ape", "make", "cache", "ace", "where", "open", "address", "mt", "MAP", "mp", "m", "config", "per", "file", "app", "aps", "down", "lock", "load", "memory", "window", "image", "maps", "mask", "collect", "mate", "batch", "manager", "up", "apping", "master", "cm", "op", "mod", "view", "set", "clear", "form", "meta", "apper", "pl", "ml", "con", "shape", "module", "co", "man", "pack", "mem", "pose", "mount", "ap", "table", "ip"], "output": ["put", "online", "ilo", "block", "format", "display", "net", "ou", "cache", "out", "secure", "input", "update", "write", "open", "oe", "file", "icon", "current", "network", "queue", "client", "web", "stream", "next", "object", "exit", "batch", "result", "console", "hidden", "target", "socket", "port", "log", "entity", "four", "print", "can", "o", "outer", "blue", "response", "latest", "auto", "other", "plain", "Output"], "i": ["b", "ami", "is", "ni", "us", "gi", "it", "qi", "id", "xi", "ci", "li", "ms", "I", "m", "t", "ai", "ix", "gu", "ri", "x", "bi", "ii", "n", "q", "u", "mi", "multi", "uri", "ic", "batch", "index", "fi", "y", "ind", "phi", "iu", "sim", "g", "ie", "ji", "spin", "si", "v", "ei", "pi", "span", "ti", "cli", "ish", "j", "ui", "di", "ini", "ip"]}}
{"id1": "7143591", "id2": "9319440", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 1, "substitutes": {"getWebByUrl": ["getWebByString", "getWebbyString", "getWebFromUrl", "getWebFromURL", "getUrlByUrl", "getUrlByString", "getUrlByurl", "getWebbyurl", "getUrlbyurl", "getWebbyURL", "getUrlbyUrl", "getWebFromurl", "getUrlbyURL", "getWebByURL", "getWebFromString", "getUrlByURL", "getUrlbyString", "getWebbyUrl", "getWebByurl"], "strUrl": [" strDb", "strurl", "drurl", "arrEmail", "volURL", " strUr", "arrUr", "strUr", "stringDb", "arrURL", "instURL", " strGl", "strEmail", "insturl", "instUr", " strURL", "volUr", "drUr", "drURL", "nameurl", "volStr", "stDb", "arrStr", "nameUrl", " strStr", "stringUrl", "strStr", "stringUr", "drUrl", "STRStr", "stUr", "nameUr", "txtGl", "txtURL", "volUrl", "STRUrl", "StrUrl", "StrUr", "stURL", "arrurl", "instUrl", "StrStr", "strURL", "nameStr", "nameURL", "Strurl", "txtStr", "stringURL", "STREmail", "strDb", "arrUrl", "STRURL", "StrGl", "nameDb", " strurl", "txtUrl", "nameEmail", "StrURL", "sturl", "strGl", "drDb", "stUrl", "STRUr"], "charset": ["ChARSET", "charsets", "ChARSet", "ChARSec", "chorsets", "chARSets", "chARSET", "Charsets", "chorsET", "charsET", "Charsec", "ChARSets", "charsec", "Charset", "chorsec", "CharsET", "chorset", "chARSet", "chARSec"], "fileIndex": [" filePos", "fileNum", "ileNum", "ileIndex", "filePos", " fileInd", "fileindex", "bytePath", "stringindex", "ileInd", "bytePos", " fileindex", "stringIndex", "fileInd", "stringPath", "byteInd", "byteNum", "stringPos", "ileindex", "byteindex", "byteIndex", " fileNum"], "url": ["ls", "obj", "dl", "cert", "net", "http", "URL", "open", "r", "f", "bl", "l", "ur", "gl", "link", "https", "str", "browser", "client", "web", "nl", "hl", "cp", "uri", "cmd", "rl", "il", "www", "socket", "ret", "g", "get", "build", "Url", "con", "ssl", "connection", "resource", "ul", "bel", "rel", "ll", "name", "sl"], "conn": ["obj", "Conn", "net", "Connection", "ctx", "open", "comm", "nt", "ln", "Con", "l", "ctr", "oss", "ens", "cb", "c", "cp", "nec", "cn", "en", "cmd", "addr", "act", "handle", "nc", "sys", "iw", "socket", "ch", "access", "enc", "conv", "ca", "con", "connection", "nw", "ws", "connect", "pg", "pas"], "is": ["ls", "nis", "iter", "or", "us", "http", "isl", "was", "out", "id", "it", "fs", "info", "ib", "iso", "IS", "bis", "s", "ist", "isc", "lis", "as", "ri", "ir", "ists", "ins", "rs", "iss", "os", "bits", "ris", "in", "are", "bs", "Is", "isf", "sys", "isi", "im", "its", "has", "js", "ios", "ais", "serv", "i", "si", "res", "isa", "ws", "iris", "ms", "es", "ip"], "filePath": ["Filepath", "familypath", " filepath", " fileSystem", "fileFile", "FileSystem", "filepath", "familySystem", "filePATH", "fileSystem", "ioSystem", "fName", "ioName", "FileName", "ioFile", "FilePath", "fSystem", "familyPATH", "fPath", "familyPath", "FileFile", "ioPath", "fileName", "fFile", " filePATH", "FilePATH"], "pw": ["wpwe", "apwb", "Pws", "npwd", "pwp", "pwr", "fW", "mw", "apw", "wpv", " pwe", "npwt", "npw", "Pw", "Pwb", "cpw", "pv", " pwp", " pwh", "mwd", "jwb", "pwb", "pW", "fws", "cpwp", "npwp", "pws", "fwd", "wpwt", "wpw", "PW", "pwh", "fw", "npv", "npwe", "pwd", " pwt", "pwt", "cpwr", "jW", "Pwd", "mwb", "apwd", "jwd", "cpwd", "jw", " pv", " pwr", " pW", "pwe", " pws", "mwh", " pwb", " pwd", "apwh", "npwr"], "fos": ["flos", "flOs", "eoss", "bOs", " foses", "eOs", "boses", "wOS", "fo", "bo", "foses", "foss", "bos", "eos", " fOs", "fOS", "flo", " foss", "wos", "wOs", "woss", " fo", "eOS", "floses", " fOS", "fOs"], "writer": ["wright", "liner", "wrote", "wp", "out", "write", "widget", "output", "wn", "author", "written", "ser", "nt", "editor", "reader", "aver", "player", "println", "walker", "aster", "builder", "window", "rew", "rw", "writ", "ter", "woman", "riter", "width", "master", "handler", "fw", "console", "w", "desc", "writing", "wr", "Writer", "worker", "buffer", "usher", "wb", "nw", "member"], "bReader": [" bBuffer", "bcClient", "bhReader", "rbRead", "bWriter", " bRead", "bClient", "bhClient", "aWriter", " bR", "bcReader", "bcBuffer", "bR", "aReader", "bRead", "aRead", " bClient", " bWriter", "rbR", "bBuffer", "rbWriter", "aR", "rbReader", "bhBuffer"], "sb": ["b", "rob", "sth", "ib", "gb", "bf", "sv", "bis", "rb", "bj", "SB", "cb", "sq", "bg", "erb", "lb", "bs", "zb", "sp", "CB", "bh", "eb", "nb", "bd", "bb", "bsp", "mb", "ssl", "wb", "sa", "sf", "stab", "bt", "sw", "kb", "lp", "sg", "pb"], "rLine": ["rL", "rEl", "lline", "srFrame", "bRow", "bline", " rLink", "lLine", "brLine", " rFrame", "brFrame", "brL", "srEl", "rline", "rLe", " rEl", "rrLine", "srLe", " rChan", "rrChan", " rline", "srChan", "srL", "rRow", "brRow", "lRow", "bLink", " rL", " rRow", " rLe", "rrEl", "rrLe", "rChan", "lLink", "srLine", "srRow", "rFrame", "rLink", "bLine"], "tmp_rLine": ["tmp_nrVal", "tmp_hLine", "tmp_drLine", "tmp_rRecord", "tmp_bline", "tmp_rgOrig", "tmp_rnRule", "tmp_nrRow", "tmp_cline", "tmp_Rline", "tmp_RBlock", "tmp_RVal", "tmp_bRow", "tmp_pLin", "tmp_RRecord", "tmp_rVal", "tmp_lRecord", "tmp_lLine", "tmp_rnOrig", "tmp_rRule", "tmp_nrChain", "tmp_rSet", "tmp_cRow", "tmp_lRow", "tmp_cLine", "tmp_rgLine", "tmp_rline", "tmp_eline", "tmp_hLin", "tmp_rLin", "tmp_rgLin", "tmp_nBlock", "tmp_pBlock", "tmp_RChain", "tmp_eRecord", "tmp_eObj", "tmp_RRow", "tmp_bLine", "tmp_drRow", "tmp_hRule", "tmp_rChain", "tmp_lChain", "tmp_rRow", "tmp_rgRule", "tmp_lVal", "tmp_nL", "tmp_nSet", "tmp_hOrig", "tmp_rnLin", "tmp_drLin", "tmp_rnLine", "tmp_pLine", "tmp_nLine", "tmp_rOrig", "tmp_RSet", "tmp_drline", "tmp_pline", "tmp_eLine", "tmp_lline", "tmp_pL", "tmp_rL", "tmp_RL", "tmp_rBlock", "tmp_pSet", "tmp_rObj", "tmp_eRow", "tmp_RLine", "tmp_pRow", "tmp_nrLine", "tmp_lObj", "tmp_bLin", "tmp_cObj"], "str_len": ["str2Len", "string_len", "str_length", " str_Len", "string3len", "str__Len", "string3vec", "string3ls", "str2len", "str_ls", "str3len", "string_ls", " str_ls", "str3length", "string_vec", "str_Len", "str3vec", "str__ls", " str_ll", "str__len", " str2len", "str3ls", "string3length", "str2ls", "str_vec", "str2ll", "str__ll", "str_ll", " str2ll", " str2ls", "string_length", " str2Len"]}}
{"id1": "19912848", "id2": "2668634", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFileString", "decodeFileAsfile", "decodeStringToString", "decodeFile2String", "decodeFileAsFile", "decodeFileFileFile", "decodeFileAsString", "decodeString2Files", "decodeFileToFiles", "decodeFile2Files", "decodeFileFilefile", "decodeFile2file", "decodeStringTofile", "decodeString2file", "decodeStringToFile", "decodeFileToString", "decodeString2File", "decodeStringToFiles", "decodeFile2File", "decodeFileFileFiles", "decodeString2String", "decodeFileTofile", "decodeFileAsFiles"], "infile": ["InFile", "inputfile", "inname", "frombase", "isinfolder", "Infilename", "outbase", "inbase", "inFile", "isinname", "Inbase", "infolder", "outFile", "fromfilename", "fromfile", "Infile", "isinFile", "inputname", "outfilename", "infilename", "outfolder", "fromFile", "inputFile", "inputfolder", "isinfile", "outname"], "outfile": ["inname", " outname", "Outfilename", "outFILE", "inFILE", "inFile", "tofile", "todir", " outFILE", "otfile", "outFile", "outdir", "Outdir", "indir", "outname", "otFile", "toFile", " outFile", "otname", "outfilename", "OutFile", "infilename", "otFILE", "tofilename", "Outfile"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "fn", "null", "os", "en", "cn", "to", "flush", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "aos", "res", "o", "auto", "can", "outer", "ot", "inner"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "black", "stack", "temp", "shape", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "shift", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", " succeed", "exist", "ccess", "commit", "cess", "value", "accept", "fail", "growth", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "scope", "successful", "good", "please", "ceed", "town", "result", "valid", "successfully", " okay", " failure", "ratulations", " succeeds", "sufficient", "photo", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "7809093", "id2": "4562786", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 1, "substitutes": {"getContent": ["GetEntity", "readData", "GetContent", "readEntity", " getContents", " getData", "GetContents", "getStream", " getStream", "readStream", "getEntity", "GetData", "readContents", " getEntity", "readContent", "getData", "GetStream", "getContents"], "request": ["message", "transform", "item", "template", "http", "QUEST", "input", "query", "search", "application", "url", "address", "open", "project", "instance", "task", "quest", "job", "email", "self", "req", "Request", "this", "q", "object", "xml", "document", "attribute", "command", "post", "get", "question", "event", "resource", "create", "execute", "start", "claim", "hello", "call"], "sb": ["b", "rob", "sth", "ib", "bp", "gb", "bf", "rm", "sv", "rb", "obb", "SB", "cb", "sq", "bps", "bg", "erb", "lb", "gc", "bs", "zb", "sp", "ub", "bh", "eb", "nb", "bn", "bd", "bb", "bsp", "buffer", "ssl", "sa", "sf", "wb", "xb", "bt", "fb", "kb", "mb", "buf", "lp", "sg", "sm", "pb"], "client": ["ce", "init", "net", "http", "cache", "secure", "grid", "tc", "ip", "force", "ci", "Client", "context", "api", "wrapper", "config", "core", "https", "cell", "google", "cl", "web", "c", "key", "cp", "cn", "cmd", "control", "io", "cm", "console", "ch", "city", "remote", "con", "chain", "conn", "connection", "co", "resource", "server", "create", "cli", "connect", "service", "call"], "httpParams": ["apiparAMS", "httpPARars", "apiparams", "httpparAMS", "httpParms", "httpPerans", "httpParars", "httpPrms", "httpParAMS", " httpPams", "apiparparams", "apiparms", "httpParans", "apiParams", "httpPrparams", " httpParars", "httpPARams", "httpPARims", "httpPeram", "httpparms", "httpParparams", "apiParAMS", "httpParims", "httpPARms", " httpParam", "httpPrams", "httpPerms", "apiParparams", "httpPms", " httpPars", "httpparparams", " httpParims", "apiParms", "httpPerams", "httpPam", "httpPrAMS", "httpPims", " httpPims", "httpPars", " httpParans", " httpParms", "httpPams", "httpparams", "httpParam", " httpPms", "httpPans"], "response": ["reply", "message", "block", "http", "out", "application", "output", "that", "description", "pos", "success", "answer", "entry", "onse", "image", "next", "page", "still", "given", "object", "successful", "resp", "tree", "version", "document", "result", "json", "sequence", "respond", "body", "report", "connection", "resource", "Response", "data", "status", "service"], "entity": ["obj", "person", "user", "group", "ce", "net", "note", "component", "info", "application", "translation", "error", "encrypted", "Entity", "entry", "email", "peer", "existent", "image", "quote", "one", "details", "ent", "object", "pe", "xml", "document", "el", "unique", "valid", "json", "result", "attribute", "body", "token", "ity", "form", "enc", "e", "me", "event", "resource", "metadata", "code", "data", "comment", "phrase", "status", "ee", "activity"], "reader": ["read", "user", "iter", "rer", "range", "Reader", "dr", "input", "r", "older", "file", "per", "parser", "loader", "entry", "roller", "builder", "rar", "stream", "row", "linger", "dd", "rl", "runner", "er", "owner", "handler", "ner", "rr", "writer", "reading", "worker", "iterator", "buffer", "resource", "inner", "data", "readable", "comment", "ro"], "line": ["message", "LINE", "user", "header", "liner", "block", "lined", "day", "where", "number", "ln", "file", "stroke", "l", "ine", "frame", "string", "eline", "cell", "link", "inline", "zone", "email", "entry", "lin", "nl", "rule", "continue", "row", "detail", "page", "label", "source", "le", "Line", "el", "msg", "sequence", "text", "body", "e", "license", "ice", "chain", "lines", "edge", "print", "sample", "comment", "phrase", "lane", "point"]}}
{"id1": "15896098", "id2": "4398382", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "label": 1, "substitutes": {"getSHA256Checksum": ["getSHA256Checsum", "getSHA256Checkam", "getSHA256Checkums", "getSHA256Chechecksume", "getSHA256Checsume", "getSHA256Checkcksam", "getSHA256Checksam", "getSHA256Checkchecksums", "getSHA256Checsam", "getSHA256Checkchecksum", "getSHA256Checkcksume", "getSHA256Checksume", "getSHA256Checkchecksam", "getSHA256Checkume", "getSHA256Checkum", "getSHA256Chechecksums", "getSHA256Checkcksum", "getSHA256Chechecksam", "getSHA256Checkchecksume", "getSHA256Chechecksum", "getSHA256Checkcksums", "getSHA256Checksums", "getSHA256Checsums"], "source": ["SOURCE", "message", "path", "template", "value", "src", "format", "out", "input", "url", "Source", "subject", "filename", "output", "context", "file", "ource", "seed", "s", "string", "image", "reason", "this", "from", "in", "sequence", "text", "body", "target", "style", "buffer", "raw", "content", "base", "sample", "data", "name", "status", "secret"], "checksum": ["checksums", "cksim", "checkum", "checkim", "checksumb", " checksums", "csum", "cksums", "cksum", "checkume", "cssum", "checksume", "checksim", "cksume", "checkssum", " checksumb", " checkssum", "csume", "ckssum", "csim", "cksumb", "checkums", "checkumb", " checksim", " checksume"], "md": ["ad", "cd", "dr", "dh", "wd", "mt", " MD", "red", "nt", "MD", "m", "pm", "grad", "mp", "der", "mk", "down", "hd", "mo", "mc", "df", "Cmd", "pd", "cmd", "dd", "def", "det", "mod", "ind", "pdf", "mm", "ld", "bd", "od", "mn", "mb", "mand", "sd", "d", " Md", "mg", "ms", "di", "sm", "dm"], "byteData": ["sliceDat", " byteList", "byteDATA", " byteBytes", "bleRel", "phraseBytes", "channelParts", "reverseDat", "channelRel", "byteRel", "ByteDATA", "ioDat", "phraseData", "byteArray", "byteDat", "phraseDATA", " byteDATA", "bleData", " byteCount", "sliceDATA", " byteRel", "ByteData", "routeDATA", "sliceList", "channeldata", "ioList", "bleParts", "byteBytes", "reverseCount", " bytedata", "ioData", " byteParts", "ByteParts", "byteList", "ioDATA", "sliceData", "wordArray", "byteCount", "wordData", "routeData", "routeCount", " byteArray", "phraseParts", "bytesDATA", "wordBytes", " byteDat", "wordDATA", "bytesBytes", "bledata", "channelData", "reverseData", "bytesArray", "bytesData", "byteParts", "bytedata", "ByteBytes", "reverseDATA", "routeDat"], "sb": ["b", "SF", "bash", "ib", "gb", "shell", "bf", "sv", "bis", "rb", "sbm", "bj", "obb", "SB", "cb", "sq", "bps", "bg", "erb", "lb", "bs", "sh", "sam", "zb", "sp", "ub", "bh", "eb", "nb", "bb", "bsp", "mb", "ssl", "si", "sf", "sa", "xb", "bt", "wb", "kb", "sw", "lp", "ob", "db", "sg", "sm", "pb"], "i": ["my", "xi", "info", "err", "I", "any", "ai", "ix", "iq", "hi", "ri", "u", "mi", "set", "phi", "iu", "history", "ei", "o", "series", "ip", "ij", "init", "id", "ion", "oi", "ki", "ii", "multi", "ic", "json", "sim", "ime", "chain", "ti", "point", "ui", "ini", "qi", "\u0438", "ci", "li", "m", "list", "iy", "gu", "this", "major", "io", "loop", "ind", "im", "ie", "g", "remote", "print", "cli", "j", "di", "ims", "gi", "it", "ski", "l", "client", "bi", "q", "uri", "to", "er", "y", "ity", "ji", "me", "si", "pi", "life", "ms"], "hexString": ["hexArray", " hexStore", "hashBuffer", "exString", " hexstring", " Hexstring", "shortBuffer", "htmlBuffer", "hashString", " HexString", "fullString", "exstring", "htmlstring", "hexBuffer", "htmlString", " hexBuffer", "shortArray", "exStore", "hexStore", " hexResource", "exArray", " HexBuffer", "shortstring", "hexstring", "fullBuffer", "hashstring", "exBuffer", "htmlArray", "fullStore", "hexResource", "shortResource", "hashArray", "fullstring", " HexResource", " hexArray", "shortString"], "hex": ["alias", "ex", "solid", "com", "full", "ph", "flash", " ex", "prop", "zh", " Hex", "des", "mix", "php", "tx", "html", "x", "cat", "ext", "term", "pex", "hl", "h", "comp", "he", "def", " sex", "dump", "sh", "sex", "json", "exp", "alph", "form", "none", "temp", "tex", "rh", "raw", "cont", "rex", "rendered", "lit", "hello", "oct"]}}
{"id1": "14783950", "id2": "20019847", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressWithoutFiles", "compressByZip", "compresswithExt", "composeWithzip", "compressWithoutZip", "composeWithZip", "compresswithZip", "compressWithzip", "compressByFiles", "compresswithzip", "composeWithoutExt", "compressWithFiles", "composeWithFiles", "composeWithoutzip", "compressWithoutzip", "composeWithoutFiles", "compressByExt", "compresswithFiles", "composeWithExt", "compressWithoutExt", "composeWithoutZip", "compressByzip", "compressWithExt"], "fileList": ["pageLIST", "resourceNames", "ilelist", " FileCode", "fileIterator", "pagelist", "itemLock", "filelist", "wordLIST", " fileLock", "resourceList", " fileLIST", "tileSet", "pageCode", " FileLIST", " fileIterator", "fileNames", "fileL", "tileLIST", "fileLIST", " fileL", "itemNames", "wordSet", "wordList", "itemList", " FileSet", "pageSet", "fileSet", "pageList", " fileSet", "pageL", "ileLIST", " fileCode", " fileNames", "ileList", "fileCode", "fileLock", "wordIterator", "ileL", "tileList", " FileList", " filelist", "resourceLock", "tileIterator"], "zipFileName": [" zipFilePath", "zipFileNames", "zipilePath", "zFilename", "zipDirNames", "zipfilename", "zipDirFilename", " zipFileNames", "zFilenameFilename", "zipileName", "zipFilenamePath", " zipfileName", "zipFilenameFilename", "zipfileNames", "zipfileFilename", "zipFilenameName", "zipDirPath", "zipfileName", "zFilePath", " zipfilePath", "zFilenamename", "zipfilePath", " zipfileFilename", "zipFilename", "zipFilenameNames", " zipfileNames", "zFileFilename", " zipFileFilename", "zipFileFilename", "zipDirName", "zipilename", "zipFilePath", "zipFilenamename", "zFileName", "zFilenamePath", "zFilenameName", "zipileFilename"], "fos": ["flos", "foos", "flOS", "floos", " foos", "wOS", "los", "lOS", "Foss", "FOS", "foss", "lfOS", "fOS", "Foos", "wos", "lfis", "lfos", "Fos", "woos", "woss", "loss", "lfoos", " fOS", "flis", "loos"], "zos": ["han", "zar", "ess", "css", "hz", "zers", "webkit", "zan", "zo", "zh", "zzle", "za", "z", "zu", "hess", "los", "zip", "sbm", "oss", "less", "nz", "bes", "zero", "zen", "enos", "iners", "iaz", "os", "ze", "jas", "cz", "ses", "zb", "zin", "rys", "ippers", "enz", "js", "ossus", "ez", "ps", "zag", "sis", "eros", "rez", "ss", "zi", "zes", "zer", "Sax", "ws", "zon", "es", "zik"], "iter": ["user", "is", "liter", "ptr", "cer", "iver", "where", "vis", "it", "ver", "Iter", "li", "list", "ser", "reader", "here", "orient", "Iterator", "walker", "fer", "loader", "kit", "ir", "train", "loc", "former", "ator", "izer", "oper", "ait", "ter", "coll", "er", "loop", "tr", "ger", "valid", "ner", "el", "exp", "iner", "its", "iv", "gener", "re", "iterator", "i", "inner", "outer", "inter", "order", "maker", "ee", "ipper", "ip"], "fileName": ["filePath", " fileBody", "tableName", "fBody", "ileSource", "FileString", "filename", "fNumber", "fString", "FileCurrent", " filePath", "ileName", "fileCurrent", "tablePath", "ileCurrent", "Filename", "fName", "fieldList", " fileCurrent", "ileSet", "fileSource", "fileNames", "fileStore", "shortname", "fieldname", "ilename", "shortSource", "FileName", "getname", "fname", "fieldName", "fileSet", " fileSource", "FilePath", "tableSet", " fileSet", "ileBody", "shortStore", "getSource", "fileString", "getStore", "ileNAME", "localname", "localName", " fileString", " filename", "ilePath", " fileNames", "ileString", "fileBody", "ileList", "FileNames", "localList", "localNAME", "getName", "fSource", " fileStore", " fileNumber", "fileNAME", "fNames", "fileNumber", "ileNumber", "fieldNAME"], "ind": ["nd", "cd", "ptr", "stick", "draw", "sign", "bind", "find", "pred", "red", "cand", "roll", "inn", "Ind", "cond", "dj", "count", "seed", "md", "IND", "pos", "req", "n", "loc", "mind", "inc", "inder", "butt", "ent", "num", "att", "hend", "ded", "div", "mod", "typ", "cod", "dial", "ld", "med", "pl", "i", "kind", "td", "d", "wind", "j", "index"], "shortName": ["shortType", "ShortFilename", "ShortKey", "quickName", "recentCode", "ShortCode", "fullString", "fullName", " shortKey", "quickString", "shortname", "recentName", " shortString", "shortKey", "shortCode", "fullType", "smallCode", "fullname", " shortType", "quickKey", "shortFilename", "smallname", "ShortString", "quickname", "recentFilename", "ShortName", "smallName", "Shortname", " shortname", "ShortType", "recentname", "smallFilename", "shortString"], "fis": ["ufi", "fois", "hois", "wIs", " fIs", "ufIs", "cfi", "hris", "wi", "Fis", "pis", "sfis", " fris", "wis", "pois", "hi", "FIs", "ufis", "ufris", "ufois", "sfois", "fIs", "cfris", "fris", "fi", "cfois", "sfi", "wois", "sfIs", "Fris", "pi", "his", "pris", "cfis"], "buf": ["b", "block", "bytes", "uf", "mu", "cap", "fam", "pkg", "bl", "bc", "rb", "bin", "cb", "cat", "Buffer", "br", "orig", "cv", "img", "arr", "cmd", "box", "batch", "bag", "tr", "bar", "msg", "seq", "tab", "ref", "conv", "fg", "aka", "Buff", "temp", "buffer", "wb", "vec", "fb", "cur", "mem", "buff", "bus", "bed", "db", "var"], "bytesRead": ["postsLoad", "bytesWrite", "blocksWrite", "secondsLoad", "bytesReady", "flowsLoad", "postsReady", "BytesWritten", "BytesLength", "secondsRead", "flowsRead", "postsFind", "blocksLoad", " bytesLoad", "bytesNeed", "linesLength", "usersLoad", "flowsReady", "blocksWritten", "bytesLoad", "linesRead", "flowsFind", "linesWritten", "BytesNeed", "bytesFind", "blocksRead", "secondsWrite", "secondsWritten", " bytesWritten", " bytesLength", "usersFind", "postsRead", "BytesRead", " bytesNeed", "bytesWritten", "linesNeed", "usersReady", " bytesWrite", "bytesLength", "usersRead"]}}
{"id1": "10385815", "id2": "20619879", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["read", "opy", "write", "download", "Cop", "save", "clip", "sync", "file", "paste", "rm", "csv", "load", "cat", "clone", "move", "cop", "cp", " copying", " duplicate", "Copy", "slice", "delete", "upload", "transfer", "create", "replace"], "fileFrom": [" fileInitial", "FileForm", "projectInitial", "FileTo", "inputFrom", "sampleInitial", "projectA", "sampleFrom", "inputForm", "ileFrom", " fileStart", "fileInitial", "fileForm", "projectStart", "FileObject", "sampleA", "ileForm", "ileTo", "projectFrom", "fileObject", "inputObject", " fileA", "inputTo", "fileA", "sampleStart", "FileFrom", "ileObject", "fileStart"], "fileTo": ["FileDest", "ile2", "modelTo", " file2", "FileTo", "ileTarget", "fileTO", "modelTO", "modelTarget", "file2", "fileDest", " fileTarget", "modelDest", "FileTO", "FileTarget", "ileTo", "fileTarget", " fileTO", "File2", "ileDest", " fileDest"], "inputStream": ["inputStreamer", "importStream", "eventstream", "sourceSteam", " inputSteam", "InputChannel", "InputSource", "sourceStream", "activeStream", "eventStream", "eventStreamer", "imageSteam", "audioStreamer", "audiostream", "InputSteam", "activeSteam", "sourceChannel", "inputSource", "eventSteam", "imageStream", "InputStream", "InputStreamer", " inputSource", "imageStreamer", "activeStreamer", "activeChannel", "audioStream", "importChannel", "importSteam", "imagestream", "inputSteam", "sourceSource", "audioSteam", "inputFile", " inputFile", "inputstream", "InputFile", "importFile", "imageChannel"], "outputStream": ["OutputFile", "resultSteam", "displaySteam", "webSteam", "displayChannel", "webStream", "writeSocket", "outputSocket", "inputString", " outputSocket", "displayStream", "writeStream", "writeChannel", "resultChannel", " outputString", "outputString", "webString", "resultSocket", " outputSteam", "OutputSteam", "webFile", "OutputStream", "resultStream", "displaystream", "outputstream", "outputFile", "writeSteam", "outputSteam", "webChannel", "inputSteam", " outputFile", "OutputChannel", "inputstream", "Outputstream"], "inputChannel": ["readableChan", "operatorStream", " inputSteam", "InputChannel", "readableChannel", "readChan", "InputConnection", "operatorConnection", "InputCamera", " inputChain", "localChannel", "createChannel", "createStream", "inputCamera", "outputChan", "currentChannel", "InputStream", "readChain", " inputConnection", "readableConnection", "currentChan", "inputChan", "operatorCamera", "InputChan", "createSteam", "localChan", "inputConnection", "localConnection", "outputSteam", "currentChain", "currentCategory", "inputSteam", " inputCategory", "readChannel", "createChan", "inputChain", "outputConnection", " inputCamera", "readCategory", "operatorChannel", "inputCategory", " inputChan"], "outputChannel": ["putchannel", "putChannel", "Outputchannel", "OutputCategory", "successStream", "writeChan", "successChannel", "outputchannel", "updatechannel", "hiddenCategory", "writeChannel", "hiddenChannel", "OutputChan", "outputContext", "OutputConnection", "successchannel", "outputChan", " outputContext", "updateChan", "OutputStream", " outputConnection", "OutputContext", "hiddenChan", "outputCategory", "hiddenchannel", " outputchannel", "updateChannel", " outputChan", "putChan", "writeConnection", "putStream", "writeContext", "updateCategory", "OutputChannel", "successConnection", "outputConnection"]}}
{"id1": "494226", "id2": "7911686", "code1": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"linesep": [" linespeg", "desep", "inesp", " lineset", "ineset", "lineps", "codespe", " linesip", "lineseps", " linesp", "lineep", "inesep", "codesp", "mysep", "inesel", "codeset", "despeg", "myseps", "lineseper", " linesop", " lineseper", "ineseps", "deseps", "linep", "linespeg", " linesel", "linesip", "linesel", "linepe", "linesop", "lineel", "inespe", "lineop", "codesep", "linip", "inesip", "inesop", "lineip", "codesel", "myseper", " lineseps", "linesp", "deseper", "lineset", "lineet", "lineeps", " linespe", "linespe", "myspeg"], "fos": ["fluts", "foS", "fess", "utfess", "fullos", "foss", " fows", "Foses", "hos", "pows", "utfuts", "wos", " foS", "yo", "flaos", "yos", "waos", "wOS", "fo", "Fo", "fullaos", "fortos", "fom", "floss", " foss", "bot", "utfoss", "faos", "flom", "fulloa", "nos", "eoes", " foa", "foa", "naos", "hOS", "utfos", "utfaos", "fulloS", "bo", "yoses", "pos", "fless", " fess", " fom", "fortoS", "eaos", "woes", "futs", "woss", " fOS", "hoes", "yot", "Fos", " faos", "fot", "flos", "flOS", "nows", " foes", "boses", "fortoa", "foses", "bos", "eos", "wess", "fOS", "hoss", "Fot", "foes", " fo", "po", "no", " futs", "eOS", "haos", "utfom", "fows", "fortaos", "paos"], "files": ["models", "states", "iles", "faces", "bees", "actions", "chains", "books", "sites", "fs", "users", "parents", "thumbnails", "checked", " Files", "jobs", "projects", "Files", "balls", "rows", "fixes", "flows", "roots", "events", "classes", "features", "frames", "images", "lets", "seconds", "ports", "uploads", "plates", "fields", "videos", "tests", "lines", "assets", "objects", "items", "artifacts", "archives", "workers", "ids", "ails", "scripts", "obs", "pages"], "i": ["ij", "is", "init", "us", "gi", "it", "xi", "info", "ci", "li", "I", "m", "t", "oi", "ai", "ix", "iq", "hi", "ki", "x", "bi", "ri", "n", "ii", "u", "mi", "multi", "uri", "ic", "index", "y", "im", "phi", "iu", "sim", "status", "ji", "me", "si", "ei", "pi", "ti", "cli", "point", "j", "ui", "di", "ini", "ip"], "metaprops": ["metapargs", "metiproperties", "metaproms", "metaproeps", "metiproeps", "metappros", "metapropPS", "metAProvPS", "metaprobps", "metapros", "metaprobPS", "metipproeps", "metapromps", "metapproeps", "metipproperties", "metAProeps", "metaprobgs", "metippropes", "metiprops", "metaprobeps", "metapraeps", "metaprms", "metaprps", "metAProbPS", "metaprovps", "metipprops", "metapropps", "metapropms", "metAProPS", "metaprperties", "metaproveps", "metAProbperties", "metAProvperties", "metapromeps", "metAProps", "metipropes", "metapromPS", "metaprovPS", "metaprobpes", "metaprPS", "metAProveps", "metapraps", "metapars", "metAProperties", "metapprogs", "metaprovperties", "metapprops", "metapromperties", "metaprapes", "metaprobms", "metAProvps", "metaprobperties", "metaparperties", "metaproPS", "metaproperties", "metAProbms", "metaparps", "metAProms", "metapproperties", "metapropperties", "metapropes", "metapraperties", "metAProbps", "metaprogs", "metappropes", "metaprobs"], "itsect": ["ilex", "Itsect", " itsection", "itconnect", "isections", "Itsector", "icsect", " itconnect", " itsections", "icsections", "isection", "Itsec", "icsection", "itsector", "isect", "tconnect", "iclex", "itlex", "isec", " itsector", " itsec", "entsect", "entconnect", "tsections", "tsection", "itsection", " itlex", "itsec", "itsections", "entsections", "entsection", "Itsection", "isector", "tsect"], "section": ["library", "block", "header", "group", "title", "component", "establishment", "subject", "filename", "context", "file", "session", "config", "sec", "instance", "journal", "second", "network", "string", "job", "client", "entry", "character", "test", "key", "container", "system", "row", "page", "label", "pair", "environment", "setting", "area", "element", "sector", "set", "course", "body", "definition", "sections", "option", "parent", "connection", "server", "Section", "language", "name", "tag", "member", "service", "sect"]}}
{"id1": "530882", "id2": "7425022", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrites", "readAndRepWrite", "readAndResWrite", "readAndRewend", "readAndResend", "readAndrewrite", "readAndrewWrite", "readAndResrite", "readAndRewrites", "readAndrewrites", "readAndReprite", "readAndrewend", "readAndRewWrite", "readAndRepend", "readAndReprites"], "inFile": ["InFile", "inputFilename", "docFile", "docFILE", "iFILE", "iFilename", "INTime", "inFILE", "InFilename", "initPlace", "initFilename", "inputPlace", "docTime", "inFace", "outfile", "infile", "iFile", " inFilename", "initFile", "inPlace", "INPlace", "docFilename", " infile", "inTime", "Infile", "initFace", "INFace", "iTime", "INFilename", "INFile", "INFILE", "inputFile", "inputFace", "inFilename", "outFilename"], "outFile": ["reportFile", " outFilename", "checkFilename", "outFILE", "inFILE", "toFILE", "reportFILE", "tofile", "nameFilename", "outfile", "infile", " outFILE", "reportfile", "reportFilename", "toFilename", "namefile", "nameFile", "toFile", "checkFile", " outfile", "checkFILE", "inFilename", "outFilename", "nameFILE", "checkfile"], "iis": [" iris", "iiIs", "liris", "iIS", "eis", "aiis", "Iiss", "liisc", "Ii", "liIs", "liis", "eIS", "iiisc", "ii", " iiss", "iiss", "iiis", "iiris", " iIs", "iIs", " iIS", "diIs", " ii", "iisc", "IIs", "eIs", "aiIS", "dii", "aiIs", "diis", " iisc", "iris", "Iis", "diiss"], "dcmParser": ["dgrParser", " dpmListener", "dpcReader", "dpmAssistant", "DpmReader", "dcrparser", "dcommReader", " dpmarser", "dcmListener", "dmoduleReader", "dmoduleAssistant", " dpmStatement", "dpmLoader", "dmmParser", " dcmarser", " dpmparser", "dcommListener", "deromParser", "dpmBuilder", "dromparser", "dcmAdapter", "dcrParser", "dfmParser", "dpmStatement", "dmmmReader", " dcmLoader", "dcomReader", "dcmBuilder", "dromAssistant", "DpmAdapter", "dcrBuilder", "dpmPrivate", " dcmPar", "dcomBuilder", "dcrReader", " dpmReader", "dcommAssistant", " dpmLoader", " dcmStatement", " dcmAssistant", "dmmarser", "dmmparser", "DcmBuilder", "dpmarser", "dgrStatement", " dcmBuilder", "dmmmparser", "dcmparser", "dcfStatement", "dromReader", "dcmAssistant", "decmParser", " dcmListener", "deromarser", "Dpmparser", "decmReader", "DcmParser", "dpmAdapter", " dpmParser", "dcmStatement", "dgrReader", " dpmPar", "DpmPar", "dmReader", "decmarser", "dpcAssistant", "DpmBuilder", "dmmReader", "decmparser", "drumParser", "dromarser", " dpmBuilder", " dcmPrivate", "dpcParser", " dpmAssistant", "dcmLoader", "DcmReader", "dromParser", "dmmmParser", " dcmparser", "dmmAdapter", "DpmParser", "drumReader", "dfmReader", "dpmReader", "dgrPar", "dcmReader", "dcfReader", "deromReader", "Dcmparser", "deromparser", "dcommParser", "dmparser", "drumPar", " dcmReader", "dcmarser", "dmarser", "dcmPrivate", "dpmparser", "dcmPar", "dmParser", "dmmmAdapter", "dpcPrivate", "dcfPar", "dromListener", "dcomParser", "dmodulePrivate", "DcmAdapter", "drumBuilder", "dfmBuilder", "dfmLoader", "dpmListener", "dcomLoader", "dpmPar", "dmoduleParser", "dpmParser", "dcfParser", "DcmPar", " dpmPrivate"], "ds": ["ls", "cs", "dos", "dl", "gs", "eds", "dh", "ils", "fs", "des", "vs", "ys", "da", "der", "sv", "s", "gd", "dds", "sets", " des", "as", "ads", "hd", "dq", "rs", "uds", "tes", "xs", "df", "os", "details", "ins", "pd", "dd", "services", "in", "bs", "Ds", "ods", "sys", "obs", "outs", "dt", "hs", "pers", " DS", "eps", "its", "js", "dat", "bd", "ps", "dx", "ks", "ss", "drivers", "sd", "d", "aos", "qs", "data", "ws", "DS", "db", "es", "ims", "ns"], "pdReader": ["ddHelper", "ddParser", "pdLoader", "xdHelper", "pdParser", "tdWriter", "xdLoader", "tdRead", "ddLoader", "vdLoader", "pdRead", "dpCar", "dpLoader", "ddWriter", "ddReader", "pdCar", "ddRunner", "dpRunner", "pedReader", "tdParser", "hdParser", "tdReader", "pedLoader", "pedCar", "hdRead", "pdRunner", "vdHelper", "xdReader", "pdHelper", "hdWriter", "ddRead", "xdWriter", "dpReader", "vdReader", "pedRunner", "hdReader", "ddCar", "vdWriter"], "out": ["over", "full", "on", " err", "err", "t", "str", "ins", "p", "ent", "outs", "ch", "writer", "log", "conn", "con", "co", "sum", "sw", "v", "o", "auto", "name", "status", "gen", "inv", "obj", "ex", "ou", "all", "id", "nt", "s", "cb", "c", "end", "txt", "os", "nr", "cn", "in", "desc", "conv", "serv", "raw", "inner", "outer", "pool", "cfg", "at", "net", "tmp", "list", "pos", "Out", "n", "en", "up", "io", "sys", "w", "js", "aos", "res", "data", "we", "OUT", "cache", "it", "output", "oss", "client", "gt", "one", "null", "screen", "go", "cmd", "to", "opt", "flush", "msg", "gr", "inter"], "dcmEncParam": ["dcmEnPar", "dcmEnVal", "dcmencCmd", "dcmEncVal", "dcmEnParam", "dcmencParam", "dcmEscPar", "dmmencParam", "dcmDecParam", "dmmEncCmd", "dcmEncCmd", "dcmencNum", "dmmEncMsg", "dmmencNum", "dmmEncPar", "dcmEncPar", "dcmEscNum", "dmmEnPar", "dcmDecCmd", "dcmEncMsg", "dcmEnNum", "dmmEnNum", "dcmEscVal", "dcmDecMsg", "dcmEscParam", "dmmEncParam", "dmmencCmd", "dmmEnParam", "dmmEncNum", "dcmEncNum", "dcmDecNum", "dcmencPar", "dcmencMsg", "dmmEncVal", "dmmencMsg"], "pdWriter": ["dpEditor", "PDReader", "tdWriter", "dpWriter", "pidWrite", "PDWriter", "pdwriter", "pidWriter", "PDWrite", "tdWriting", "tdReader", "PDEditor", "pidwriter", "pidWriting", "dpWrite", "tdwriter", "pcWriter", "pcWrite", "pdWrite", "pdWriting", "pcwriter", "tdWrite", "pdEditor", "pcWriting", "dpReader", "tdEditor"]}}
{"id1": "9275622", "id2": "11477906", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpStream", " cpFiles", " duplicateFile", "copyFiles", " cpFile", " copyfile", " duplicateStream", " copyFiles", " copyStream", " duplicateFiles", " cpfile", " duplicatefile", "copyStream", "copyfile"], "_file1": ["_fileInit", "_link1", "_ile2", "_ileOne", "_FileOne", "_ile1", "_ileInit", "_files2", "_linkInit", "_FileFirst", "_fileOne", "_File1", "_files1", "_File2", "_filesFirst", "_FileInit", "_fileFirst", "_linkOne", "_link2", "_ileFirst", "_filesOne"], "_file2": ["_Fileb", "_linkTwo", "_image1", "_link1", "_FILEb", "_file02", "_File02", "_FILE1", " _FILEb", " _FILE2", "_image2", " _Filetwo", " _FILE1", " _File1", "_image02", " _fileb", "_File1", "_FILE02", " _FileTwo", "_Filetwo", "_File2", "_FILE2", " _filetwo", " _fileTwo", "_link2", "_imageb", " _file02", " _FILE02", "_fileTwo", "_filetwo", "_FileTwo", "_fileb", " _File2", "_linktwo"], "fis": ["kais", "ufi", "fois", "Fios", "fios", "kis", "Fis", "cos", " fris", "cios", " fios", " fois", "ufis", "fiss", "cfris", "fais", "cis", " fais", "qos", "fliss", "ufiss", "fris", "fi", "ufios", "cfois", "qiss", "kios", "cfiss", " fiss", " fi", "qios", "kos", "flis", "Fois", "Fris", "cfis", "qis", "fli", "flios", "Fos", "cais", "Fiss"], "fos": ["flos", "ffoes", "waos", " foes", "moes", "ffis", "hose", "wis", "sfoes", "foss", " fows", "hos", "sfoss", "floes", "floss", "hoss", "maos", "sfose", "ffos", " foss", "wos", "mows", "woes", "foes", "fose", "woss", "wows", "faos", " fose", "flis", "ffoss", "hoes", "fows", "mos", " faos", "sfos"], "canalFuente": ["canalKuperor", "canalFuenza", "canallFuje", "canalfuestro", "canalFaleree", "canalFuje", "canalUtente", "canallfuent", "canalTenenza", "canalFienza", "canallfueree", "canalfuent", "canalFuestro", "canalFient", "canalUteree", "canallfuperor", "canalKuent", "canalFalje", "canalFiperor", "canallFuenza", "canalfuenza", "canallFueree", "canalUtent", "canalKuente", "canallFuestro", "canallFuperor", "canalUtestro", "canalTenente", "canalfuje", "canalFiente", "canalFalent", "canalTenent", "canalFalperor", "canalfuente", "canallfuenza", "canalFuent", "canalfuperor", "canallfuente", "canallfuje", "canallFuente", "canallFuent", "canalFueree", "canallfuestro", "canalFuperor", "canalKuje", "canalTenperor", "canalFalente", "canalfueree", "canalFalestro"]}}
{"id1": "20100809", "id2": "5744992", "code1": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"copy": ["pixel", "perm", "opy", "write", "download", "clip", "save", "Cop", "sync", "paste", "map", "php", "mk", "zip", "same", "link", "cat", "crop", "clone", "move", "proxy", "cop", "cp", "share", "gc", "archive", "Copy", "cross", "slice", "delete", "remote", "remove", "export", "transfer", "create", "split"], "srcPath": ["srPatch", "selFolder", "rcPain", "srcCh", "srcRoot", " srcForm", "rcPatch", "srPath", "rcMat", " srcDir", "selFile", "rxForm", "urgPain", "rcForm", "srcDir", " srcFolder", "srcPain", " srcPort", "rcFile", "rcFolder", "hlUrl", "srcMat", "rxDir", "usrFile", "urgFile", "sourceFile", "sourceDir", "srCh", "rxPort", "srUrl", "hlPath", "rcUrl", "srcFolder", "sourcePath", "rcPort", "usrMat", "hlPatch", "srcPort", "srcFile", "rxPath", "rcPath", "rcDir", "sourceRoot", "srcUrl", "sourceCh", "srcPatch", "srcForm", " srcFile", "usrPath", " srcCh", "selDir", "urgMat", "urgPath", "rcRoot", "hlCh", " srcRoot", "rcCh", "usrPain", "selPath"], "dstPath": ["DstCh", "dstName", "dSTPath", "ddestPath", "dSTDir", " dndCh", "dndFile", "dndTime", "dndCl", "dctPath", "dstHome", "DdestPath", "dstpath", "derstPos", "dptDir", "derstTime", "ddestParent", "DdestFile", "dndDir", "dndHome", "dstDir", "dndpath", "dndCh", "ddestpath", "dstPretty", "ddPos", " ddestName", "drcPath", "destDir", "dktFile", "dctFile", " dstpath", "dSTName", "thrcPretty", "derdPos", "thrcFile", "ddestCl", " dndPath", "drcFile", " dstCh", "dstCl", "dptpath", "thstPath", "derstDir", "thstpath", " dstDir", "destPath", " dstParent", "ddTime", " dndParent", " ddestDir", "dstTime", "DstHome", "ddPath", " dndName", "dndName", "dctTime", "dctpath", "ddestHome", "dptName", "drcPretty", "ddestPretty", "ddestName", "dstParent", " ddestPath", "derstPath", "DstFile", " ddestCl", " dndpath", "dktHome", "dktPath", "dstPos", "dctPretty", "drcpath", " dndDir", "destCh", "ddestFile", "thstPretty", "DdestCh", " dstCl", "dSTCl", " dstName", "thrcpath", "dndParent", "dstCh", "thrcPath", "DdestHome", "dctPos", "derdDir", "ddDir", "derdTime", "dctDir", "DstPath", "ddestCh", "dstFile", "thstFile", "dndPath", "dndPos", "destParent", "derdPath", "dptPath", "dktCh", "ddestDir"], "result": ["Result", "match", "there", "group", "cert", "forge", "make", "sign", "register", "gem", "associated", "fully", "know", "done", "product", "success", "record", "true", "test", "confirmed", "results", "successful", "global", "char", "valid", "successfully", "set", "report", "status", "ret", "ful", "process", "trade", "date", "contact", "resource", "res", "were", "comment", "complete", "table", "region"], "files": ["ls", "mas", "states", "iles", "pres", "faces", "links", "actions", "chains", "works", "books", "fs", "packages", "users", "days", "forms", "reports", "balls", "Files", "resources", "leases", "mails", "issues", "features", "images", "ports", "styles", "uploads", "plates", "fields", "tests", "les", "lines", "names", "assets", "objects", "items", "workers"], "file": ["message", "path", "item", "block", "id", "url", "type", "f", "filename", "task", "dir", "tile", "link", "string", "record", "entry", "key", "rule", "image", "row", "source", "from", "le", "page", "p", "pe", "ile", "part", "field", "style", "FILE", "e", "line", "chain", "resource", "print", "base", "sample", "play", "data", "name", "File", "local", "table", "child"], "in": ["In", "read", "iter", "is", "init", "or", "net", "sin", "on", "input", "rin", "al", "win", "all", "it", "ain", "IN", "ln", "inn", "inside", "inf", "bin", "ai", "client", "again", "include", "ar", "ir", "vin", "image", "ins", "one", "source", "inc", "from", "n", "mi", "en", "ic", "up", "io", "ind", "oin", "old", "im", "ch", "din", "mm", "isin", "ie", "get", "re", "cin", "con", "conn", "i", "gin", "co", "internal", "inner", "o", "like", "local", "ini"], "out": ["user", "ex", "check", "at", "or", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "oe", "ln", "t", "cos", "oss", "bin", "client", "again", "gt", "ext", "Out", "n", "end", "null", "one", "os", "not", "cn", "cmd", "to", "up", "io", "ne", "sys", "outs", "op", "msg", "writer", "conv", "serv", "conn", "con", "co", "inner", "can", "aos", "o", "outer", "v", "other", "ot", "ns"], "size": ["read", "bytes", "range", "empty", "SIZE", "gets", "zie", "number", "write", "speed", "z", "amount", "space", "ize", "count", "send", "string", "pos", "zero", "sn", "n", "fee", "close", "en", "ze", "num", "area", "width", "len", "scale", "notice", "height", "Size", "length", "see", "position", "ness", "capacity", "city", "get", "shape", "loss", "export", "sum", "seek", "total", "max", "start", "name"], "buf": ["b", "uf", "cap", "bp", "fam", "func", "pkg", "map", "bc", "rb", "ann", "queue", "job", "cb", "cat", "Buffer", "bg", "br", "cv", "img", "cmd", "good", "batch", "bag", "bar", "cam", "msg", "seq", "tab", "ref", "bh", "aka", "Buff", "fg", "buffer", "vec", "cur", "mem", "buff", "data", "db", "pool"]}}
{"id1": "17190057", "id2": "3514286", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"encode": ["deCode", "EnCode", " enode", "enclose", "Encode", "Enclose", "enCode", " enCode", "decode", "enode", "deode", "Enode", " enclose", "declose"], "input": ["check", "value", "format", "out", "qi", "audio", "url", "it", "address", "context", "output", "file", "request", "config", "Input", "string", "str", "client", "image", "source", "q", "cmd", "in", "act", "pattern", "xml", "password", "initial", "op", "command", " Input", "sequence", "text", "qa", "form", " inputs", "raw", "buffer", "active", "print", "sample", "data", "name", "hello"], "NoSuchAlgorithmException": ["NoSuchALgorithClass", "NoSuchALgorithError", "NoSuchALgorithmEx", "NoSuchAlryptionException", "NoSuchALgorithmException", "NoSuchAlryptionClass", "NoSuchAlryptionEx", "NoSuchAlgorithError", "NoSuchAlryptionError", "NoSuchAlgorithEx", "NoSuchAlgorithException", "NoSuchALgorithmClass", "NoSuchAlgorithClass", "NoSuchALgorithmError", "NoSuchALgorithEx", "NoSuchAlgorithmError", "NoSuchALgorithException", "NoSuchAlgorithmEx", "NoSuchAlgorithmClass"], "md": ["ad", "nd", "ng", "cd", "dr", "mt", "red", "nt", "MD", "m", "pm", "mp", "rm", "der", "mk", "add", "de", "hd", "mc", "df", "strong", "pd", "cmd", "dd", "def", "det", "cm", "sam", "msg", "mod", "ind", "desc", "sha", "pdf", "mm", "js", "ld", "bd", "od", "dig", "mn", "mb", "mand", "d", "sd", "metadata", "mg", "ms", "di", "sm", "dm"]}}
{"id1": "21824901", "id2": "4716110", "code1": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyExternalResource": ["copyexternalResource", "copyInternalReference", "copyInternalResources", "downloadExternalReference", "copyexternalReference", "copyExternalReference", "copyOptionalReference", "copyOptionalResource", "copyExternalResources", "copyExternalresource", "downloadExternalResource", "copyexternalResources", "copyInternalResource", "downloadExternalresource", "copyOptionalResources", "copyInternalresource", "downloadExternalResources", "downloadexternalResource", "downloadexternalReference", "downloadexternalresource", "downloadexternalResources", "copyexternalresource", "copyOptionalresource"], "sourceFile": ["srcPage", "destLine", "ourceChain", "destPage", "destPath", "sourceChain", "SourceChain", " sourceChain", "sourceFilename", "sourceDir", "sourceLine", "SourceFilename", " sourceDir", "ourceDir", " sourceLine", "srcPath", "ourceFile", " sourcePage", "sourcePage", " sourceFilename", "srcFile", "ourceFilename", "SourceDir", "SourceFile", "srcLine", "sourcePath", " sourcePath"], "destFile": ["DestFile", "destFilename", "critFile", " destPath", "DestFilename", "destPath", "srcDir", "destfile", " destPlace", "critDir", " destfile", "optPlace", "DestFiles", "destFILE", "locPath", "locDir", " destFiles", "srcFiles", "srcPlace", "Destfile", "optDir", "optFiles", "srcPath", " destDir", "srcFILE", "DestDir", "critFilename", "locFILE", "destDir", "srcFile", "critfile", "destPlace", "srcfile", "optFile", "destFiles", "locFile", " destFilename", " destFILE"], "source": ["SOURCE", "match", "iter", "check", "ce", "init", "src", "store", "cache", "component", "input", "search", "query", "Source", "force", "subject", "address", "sql", "shell", "update", "session", "reader", "ource", "use", "se", "back", "cause", "less", "load", "before", "origin", "score", "image", "stream", "scope", "from", "proxy", "in", "copy", "archive", "owner", "result", "sequence", "console", "body", "target", "style", "ie", "none", "parent", "iterator", "series", "connection", "resource", "inner", "start", "sample", "pose", "create", "base", "channel", "index", "service", "local", "table"], "destination": ["notination", "Destociation", "Destuation", " destinated", "notinated", "descinator", "Destinator", " destinator", " destuation", "compinator", "destinated", "descinated", "Destinated", "descinate", "potination", "potociation", "descination", " destation", "combinated", "catinated", "destinator", "compination", "compinated", "notinate", "destation", "destinate", " destociation", "notinator", "combination", "catinator", "destuation", "compation", "catinate", "combinator", "Destation", "destociation", "combuation", "catination", "Destination", "potation", "potinator"]}}
{"id1": "22503685", "id2": "3745402", "code1": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 0, "substitutes": {"readGeoParserResult": ["readGeoHandlerResults", "readGeoReaderResults", "readGeaParserRecord", "readGeoHandlerResult", "readGeaParserResult", "readGeoHandlerRecord", "readGeaReaderResponse", "readGeaReaderResults", "readGeoReaderResult", "readGeaReaderRecord", "readGeoParserRecord", "readGeaParserResponse", "readGeoReaderRecord", "readGeoReaderResponse", "readGeaParserResults", "readGeoarserResponse", "readGeoParserResponse", "readGeoHandlerResponse", "readGeaReaderResult", "readGeoParserResults", "readGeoarserResults", "readGeoarserRecord", "readGeoarserResult"], "recordContent": ["recordString", "RecordString", "recContents", "RecordData", "RecordContent", "resourceContent", "resourceText", "RecordContents", "RecordName", "recordContents", " recordText", "recordText", "RecordText", " recordContents", " recordString", "recText", " recordName", "resourceString", " recordData", "recData", "recContent", "resourceName", "recordData", "recordName"], "getGazeteerIds": ["getGazeteerByIders", "getGazeteerCountls", "getGazeteerLoges", "getGazeteerInts", "getGazeteerCounts", "getGazeteerNeedls", "getGazeteersByIders", "getGazeteerByIdids", "getGazeteerNeedl", "getGazeteerIntids", "getGazeteerNeeds", "getGazeteerCountes", "getGazeteersIdl", "getGazeteersByIdids", "getGazeteersIdls", "getGazeteerIdls", "getGazeteerByIdls", "getGazeteersIdes", "getGazeteersByIdl", "getGazeteerByIdl", "getGazeteersByIds", "getGazeteerLogers", "getGazeteerIders", "getGazeteersByIdes", "getGazeteersIders", "getGazeteerIdes", "getGazeteerByIdes", "getGazeteerIntes", "getGazeteerIdl", "getGazeteerLogs", "getGazeteerLogids", "getGazeteerInters", "getGazeteerCountl", "getGazeteersByIdls", "getGazeteersIdids", "getGazeteersIds", "getGazeteerNeedes", "getGazeteerByIds", "getGazeteerIdids"], "ret": ["cert", "net", "ts", "out", "uf", "ft", "r", "usr", "mt", "red", "tmp", "nt", "reg", "rm", "t", "rt", "repl", "Return", "gt", "test", "rg", "arg", "rets", "continue", "ext", "ar", "RET", "alt", "txt", "Ret", "gc", "def", "arr", "opt", "tr", "result", "set", "ref", "get", "re", "mb", "buf", "cont", "print", "et", "res", "cur", "mem", "ry", "ll", "lit", "att", "reset", "ert"], "retries": [" retriers", "trying", "altries", "interrying", "ties", " retrys", "interries", " retrying", "retrying", "interrys", "retrys", "attrys", "attrying", "altrys", "attriers", "retriers", "trys", "triers", "tries", "alties", "interies", "reties", "attries", "altrying"], "reqPre": ["questpre", " reqpre", "reqPost", "requestPre", " reqPost", "RequestPre", "reqpre", " reqPRE", "requestPRE", "RequestPost", "requestpre", "RequestPRE", "requestPost", "questPRE", "Requestpre", "reqPRE", "questPre"], "outputFormat": ["outputForm", "inputformat", " outputformat", "OutputFormat", " outputForm", " outputType", "Outputformat", "inputForm", "inputType", "inputFormat", "outputType", "OutputForm", "OutputType", "outputformat"], "doc": ["ad", "dr", "parse", "DOC", "ds", "Doc", "Document", "comm", "du", "m", "file", "dir", "norm", "mk", "md", "str", "tx", "org", "html", "dc", "window", "py", "h", "def", "pub", "good", "unit", "dict", "tree", "xml", "document", "div", "msg", "json", "cam", "desc", "body", "exp", "dec", "form", "js", "ml", "date", "content", "man", "res", "data", "db", "di"], "url": ["ls", "dl", "cert", "http", "URL", "r", "address", "api", "file", "l", "ur", "link", "str", "https", "au", "parser", "loader", "web", "org", "nl", "loc", "hl", "uri", "addr", "char", "rl", "xml", "el", "socket", "ref", "Url", "conn", "ssl", "resource", "ul", "bel", "base", "ll", "hub", "sl"], "reader": ["read", "driver", "Reader", " readers", " Reader", " data", " resource", "input", "r", " writer", "file", " scanner", "parser", "loader", "builder", "stream", " read", " loader", " parser", "er", "handler", " r", "writer", "buffer", "resource", "data"]}}
{"id1": "11032546", "id2": "20619879", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"testCopyUnknownSize": [" testCopyDifferentsize", " testCopyKnownShape", " testcopyUnknownSize", " testCopyKnownsize", " testCopyKnownSize", " testCopyunknownLength", " testcopyUnknownShape", " testcopyKnownShape", " testcopyUnknownsize", " testCopyUnknownShape", " testCopyDifferentShape", " testCopyunknownsize", " testcopyKnownLength", " testCopyunknownSize", " testCopyKnownLength", " testCopyUnknownsize", " testcopyKnownsize", " testCopyunknownShape", " testcopyUnknownLength", " testcopyKnownSize", " testCopyUnknownLength", " testCopyDifferentSize", " testCopyDifferentLength"], "in": ["inv", "In", "is", "sin", "on", "input", "it", "rin", "al", "r", "ain", "file", "IN", "inn", "l", "inside", "inf", "bin", "ins", "source", "from", "null", "en", "up", "copy", "ind", "din", "mm", "isin", "log", "cin", "con", "i", "gin", "inner", "data"], "out": ["inv", "b", "user", "ex", "obj", "check", "at", "or", "OUT", "net", "ou", "on", "all", "it", "err", "output", "list", "t", "client", "gt", "Out", "n", "one", "null", "end", "a", "os", " OUT", "cmd", "to", "up", "io", "outs", "result", " Out", "OU", "by", "log", "con", "gr", "co", "sum", "aos", "res", "auto", "o", "data"], "cpySize": ["cdyCount", "Cplysize", "cplyLength", "Cpysize", " cplyCount", " cpysize", "cpeSize", " cpyCount", "cdysize", " cplysize", "cfiLength", "cpesize", "CpyLength", "CplySize", "CplyCount", "cpyCount", "cpeCount", " cplySize", "cpeLength", "cfiSize", "cfisize", "CplyLength", "cpyLength", "CpySize", "cpysize", "cdyLength", "cplysize", "cplyCount", "cfiCount", " cplyLength", "cplySize", " cpyLength", "CpyCount", "cdySize"], "outArray": [" outString", "outStream", "listArea", "inArray", "outString", "listArray", "OUTObject", "OUTarray", " outarray", "outObject", "listImpl", "inString", "outImpl", "nearray", "outarray", "inImpl", "inArea", "listString", " outArea", " outStream", "neArray", "OUTArray", " outObject", " outImpl", "neObject", "outArea", "neStream", "OUTStream"]}}
{"id1": "4501356", "id2": "10391753", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"calculateProfileDiffDigest": ["calculateProfileDiffdigest", "calculateProfileChangedigest", "calculateProfileChangedigests", "calculateProfileDiffDiffest", "calculateProfileDiffDiffe", "calculateProfileDiffDiffests", "calculateProfileChangedigst", "calculateProfileChangeDigests", "calculateProfileDiffDigests", "calculateProfileDiffdigests", "calculateProfileDiffDigst", "calculateProfileDiffSignest", "calculateProfileDiffdige", "calculateProfileDiffSignst", "calculateProfileChangeDigst", "calculateProfileChangeDige", "calculateProfileDiffSignests", "calculateProfileDiffSigne", "calculateProfileDiffDige", "calculateProfileChangeDigest", "calculateProfileChangedige", "calculateProfileDiffdigst", "calculateProfileDiffDiffst"], "profileDiff": ["jsonData", "ProfileData", "jsonDelta", "picturediff", "jsonDiff", "pictureDiff", " profileDelta", "templateDelta", "phdiff", " profileInf", "ProfileDelta", "caseDiff", "personDiff", "caseUpdate", " profileUpdate", "profileDifferent", "persondiff", "personUpdate", "ProfileChange", "userDelta", "jsonDifferent", "userDiff", "profilediff", "phInf", "phDiff", "pictureInf", "profileUpdate", " profilediff", "profileInf", "templateDifferent", "profileData", "pictureChange", "caseDelta", "ProfileDiff", "personDelta", "profileChange", "profileDelta", "userChange", "templateDiff", "ProfileDifferent", " profileChange", "casediff", "templateData", "phChange"], "normaliseWhitespace": ["normaliseWhatsSpace", "normaliseWatsspace", "normaliseWhitesace", "normaliseWhitsspace", "normaliseWipsspace", "normaliseWitesspace", "normaliseWhitspaces", "normaliseWatsSpace", "normaliseWhipsace", "normaliseWhipspace", "normaliseWhitesspace", "normaliseWitespace", "normaliseWhipspaces", "normaliseWhatsace", "normaliseWhatsspace", "normaliseWitesSpace", "normaliseWipspaces", "normaliseWitespaces", "normaliseWhipsspace", "normaliseWhitsSpace", "normaliseWitesace", "normaliseWatsace", "normaliseWipspace", "normaliseWhipsSpace", "normaliseWhitespaces", "normaliseWhitspace", "normaliseWhatspace", "normaliseWatspace", "normaliseWipsSpace", "normaliseWhitesSpace", "normaliseWhatspaces"], "md": ["obj", "amd", "ad", "nd", "cd", "dr", "mt", "red", "grad", "nt", "MD", "m", "pm", "fd", "dir", "and", "der", "rm", "mk", "add", "mac", "de", "hd", " df", "mc", "df", "pd", "cmd", "dd", " sd", "det", "sam", "ind", "mod", "pdf", "mm", "js", "ld", "deep", "bd", "od", "mn", "dist", "d", "sd", "mg", "ms", "sm", "dm"]}}
{"id1": "13644374", "id2": "21125261", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getByteFromPath", "getBytesForPath", "getByteFromUrl", "getBytesFormPage", "getByteFormPage", "getBytesFromPath", "getBytesfromURL", "getBytesfromPage", "getByteFormPath", "getBytesFromPage", "getBytesfromPath", "getBytesForPage", "getBytesForURL", "getByteFormURL", "getByteFromPage", "getBytesFromURL", "getByteFromURL", "getBytesFormURL", "getBytesForUrl", "getBytesFormUrl", "getBytesfromUrl", "getByteFormUrl", "getBytesFormPath"], "url": ["ls", "path", "rect", "dl", "full", "http", "URL", "parse", "id", "address", "l", "ur", "link", "string", "str", "https", "web", "html", "nl", "loc", "domain", "page", "host", "uri", "pattern", "xml", "default", "el", "ref", "build", "Url", "ul", "location", "base", "res", "name", "ll", "pl", "sl"], "get": ["put", "read", "pull", "check", "let", "gets", "full", "http", "parse", "find", "query", "download", "search", "select", "give", "request", "Get", "pre", "exec", "send", "load", "this", "ge", "set", "body", "show", "post", "g", "build", "GET", "got", "create", "play", "like", "service", "we", "call"], "response": ["reply", "message", "block", "http", "application", "open", "output", "that", "request", "pos", "client", "success", "answer", "entry", "onse", "image", "next", "page", "given", "still", "object", "successful", "resp", "tree", "version", "document", "result", "json", "soc", "respond", "body", "post", "connection", "resource", "content", "yes", "res", "Response", "status", "service", "respons"], "entity": ["obj", "put", "person", "user", "group", "ce", "note", "component", "type", "info", "iso", "instance", "any", "encrypted", "icon", "and", "se", "load", "record", "client", "Entity", "entry", "email", "peer", "image", "one", "le", "ent", "object", "pe", "unit", "eme", "document", "el", "result", "unique", "json", "body", "ity", "form", "em", "line", "me", "event", "content", "resource", "total", "model", "security", "base", "data", "comment", "member", "ee", "activity"]}}
{"id1": "23452437", "id2": "13783549", "code1": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"internalCopy": [" internalTransfer", "internalCop", " doSave", "internalTransfer", " doCopy", " internalCop", " doTransfer", " deepCop", "internalSave", " doCop", " internalSave", " deepCopy", " deepSave", " deepTransfer"], "fSource": ["oTarget", "rfSOURCE", "dataStar", "fStar", " fTarget", "fTarget", "gTarget", "fSOURCE", "fmSourceFile", "pSource", "oSourceFile", " fCopy", "vSource", " fsource", "fileSource", "tSourceFile", "dataSource", " fSOURCE", "fCopy", "psource", "fsource", " fSourceFile", "fileSOURCE", "oSOURCE", "tSource", "gSource", "vTarget", "tTarget", "fmsource", "rfSource", "oSource", "rfSourceFile", "fmSource", "vsource", "dataSourceFile", "dataSOURCE", "rfStar", "fileSourceFile", "pCopy", "fileStar", "vSOURCE", "fSourceFile", "pSourceFile", "fmCopy", "tSOURCE", "gsource", "gSOURCE"], "file": ["message", "path", "th", "files", "format", "template", "or", "out", "type", "info", "f", "filename", "output", "fp", "use", "t", "l", "image", "source", "null", "txt", "le", "p", "page", "h", "ile", "io", "fil", "spec", "w", "ol", "port", "FILE", "e", "log", "chain", "resource", "print", "base", "data", "name", "db", "File", "local", "table"], "o": ["obj", "ome", "on", "out", "lo", "iso", "output", "ok", "onet", "oe", "ow", "l", "bo", "fo", "mo", "os", "go", "ko", "u", "ao", "to", "O", "og", "io", "op", "y", "oo", "ol", "po", "ox", "e", "no", "so", "yo", "co", "oa", "et", "ho", "\u00f3", "auto", "v", "ot", "ob", "ooo", "ro"], "i": ["ij", "iter", "is", "out", "gi", "it", "qi", "xi", "ib", "info", "ci", "li", "f", "I", "bis", "l", "oi", "ai", "hi", "ri", "ki", "bi", "ii", "mi", "u", "ic", "in", "il", "io", "im", "phi", "iu", "si", "pi", "ui", "di", "ini", "ip"], "b": ["bit", "binary", "gb", "f", "lib", "be", "z", "bf", "bl", "ab", "bis", "l", "rb", "bin", "bi", "bg", "erb", "br", "p", "a", "bits", "bs", "bar", "body", "sb", "eb", "bh", "nb", "bd", "B", "bb", "buffer", "buf", "mb", "fb", "bt", "v", "base", "bus", "blue", "buff", "ob", "j", "pb"], "n": ["ren", "ni", "on", "nn", "out", "number", "yn", "k", "r", "N", "nt", "m", "ln", "t", "count", "l", "after", "nor", "gn", "c", "nl", "sn", "missing", "a", "en", "cn", "num", "nan", "len", "ne", "nc", "nu", "y", "na", "no", "an", "nb", "mn", "d", "syn", "v", "span", "ll", "j", "ns", "un"]}}
{"id1": "20751378", "id2": "2642914", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 0, "substitutes": {"hashPassword": ["hashpassword", "updatePrivate", " hashPrivate", "HashPassword", "hashPrivate", "updatepassword", "HashPrivate", "updateText", "hashText", "Hashpassword", " hashText", "updatePassword", " hashpassword", "HashText"], "password": ["message", "user", "sword", "auth", "value", "device", "pass", "input", "Password", "query", "wd", "application", "address", "argument", "database", "login", "request", "description", "encrypted", "string", " Password", "client", "directory", "email", "padding", "wordpress", "key", "word", "p", "pattern", "expression", "username", "attribute", "command", "token", "PASS", "shadow", "w", "property", "default", "crypt", "connection", "reset", "print", "security", "language", "name", "column", "phrase", "prefix", "hello", "comment", "secret"], "hash": ["put", "cloth", "title", "where", "search", "mass", "hed", "str", "oh", "test", "zero", "method", "trust", "ping", "report", "build", "log", "sum", "ho", "response", "replace", "other", "filter", "user", "value", "checking", "shift", "ash", "also", "ah", "key", "ha", "handle", "username", "result", "uh", "token", "has", "hex", "reading", "bh", "dig", "Hash", "rh", "total", "proof", "her", "tag", "message", "block", "check", "hing", " Hash", "here", "string", "html", "alert", "version", "sh", "tr", "sha", "print", "ashing", "index", "locking", "cache", "number", "array", "address", "class", "alg", " hashing", "mask", "object", "h", "copy", "height", "shadow", "crypt", "hello"], "md": ["obj", "ad", "nd", "cd", "dr", "dh", "ds", "del", "mt", "red", "grad", "pm", "MD", "m", "mp", "dir", "and", "der", "mk", "add", "hd", "managed", "mc", "df", "pd", "dd", "cmd", "det", "sam", "ind", "mod", "sha", "mm", "js", "ld", "bd", "od", "mn", "mand", "d", "sd", "man", "ms", "di", "sm", "dm"]}}
{"id1": "20232250", "id2": "13152325", "code1": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"sendRequest": ["executeRequest", " sendrequest", " sendMessage", " sendCommand", "executeCommand", "processRequest", "processMessage", "sendMessage", "executerequest", "executeMessage", "sendrequest", "processCommand", "processrequest", "sendCommand"], "seq": ["item", "block", "iter", "ctx", "id", "err", "session", "config", "sec", "eq", "sequ", "frame", "str", "queue", "cell", "client", "cl", "sq", "test", "iq", "req", "que", "pos", "cas", "next", "q", "struct", "exc", "comp", "cmd", "batch", "ence", "msg", "state", "sequence", "desc", "tab", "ref", "enc", "sim", "pse", "clus", "sel", "sub", "serv", "buf", "rez", "protein", "res", "cli", "Sequ", "prefix", "gen"], "IOException": ["ioFailure", "ReadingFailure", "ReadingStatus", "ioException", "ReadingException", "ioStatus", " IOFailure", "IOFailure", "IOStatus", " IOStatus"], "putBuf": ["putBebuf", "putOutub", "putLuf", "PUTGbuff", "putPbuff", "putLpkg", "putBbuff", "outputBurg", "putMimg", "putPuf", "outputBuf", "putCuf", "outputBub", "putLub", "putBld", "outputbbuff", " putBbuf", "PUTBbuff", "outputburg", "putDebld", "outputGub", "outputGuff", "outputGbuf", "putEBagg", "outputbuf", "posBeUF", "putGurg", "putbagg", "putDebuff", "putBimg", "putBUF", "PUTMld", "putGbuff", "putbbuf", "posBuf", "putbuf", "putCld", " putBagg", "putMld", "putLbuff", "PUTBuf", "outputGuf", "putbpkg", "putMuf", " putLbuf", "putCuff", "putOutuf", "putLbuf", "outputBuff", "putEBpkg", "posBebuf", "putEBbuf", "posBagg", "putBeagg", "putGbuf", "PUTBuff", "putbbuff", "putLagg", "PUTBimg", "posBUF", "putGUF", "putEBuf", "posBeuf", "PUTMuf", "outputBbuff", "putOutbuf", "putBurg", "PUTGbuf", "PUTBurg", "PUTMuff", "putGuf", "PUTBbuf", "putGagg", "putBpkg", " putLagg", " putLpkg", "putPurg", "PUTMimg", "putPbuf", "putDebimg", "putBbuf", "putCimg", "putGub", "outputbbuf", "PUTGurg", "putGuff", "putLuff", " putBpkg", "putDebuf", "PUTGuf", "PUTBld", "posBeagg", "putLurg", "putOutuff", "putBuff", "putburg", "posBbuf", " putLuf", "outputBbuf", "putBagg", "putBeuf", "putBub", "putMuff", "putBeUF"], "url": ["ls", "dl", "cert", "net", "http", "URL", "r", "open", "pkg", "abs", "l", "ur", "link", "str", "https", "browser", "client", "nl", "loc", "hl", "lb", "p", "uri", "cmd", "addr", "rl", "xml", "sb", "ret", "get", "build", "Url", "log", "ctrl", "ssl", "oul", "bel", "atl", "rel", "ll", "att", "sl"], "conn": ["inv", "obj", "dl", "Conn", "net", "cert", "ctx", "secure", "win", "open", "comm", "write", "nt", "ln", "exec", "ctr", "ann", "client", "cb", "cl", "fin", "tn", "loc", "n", "close", "nec", "cp", "cn", "ct", "cmd", "resp", "addr", "nc", "iw", "soc", "socket", "ch", "conv", "enc", "ctrl", "con", "jp", "connection", "cont", "nw", "syn", "res", "cur", "sw", "ws", "connect", "db", "ns", "pas"], "wr": ["dr", "wy", "spr", "wrote", "vr", "tw", "wid", "write", "wm", "wn", "ln", "writers", "wa", "mk", "wer", "pr", "wx", "Wr", "fn", "rew", "kr", "rw", "writ", "WR", "hw", "fw", "iw", "vet", "w", "wt", "writer", "kl", "Writer", "mn", "wb", "nw", "sw", "mr", "wk", "ws", "mg", "wo", "fr", "we"]}}
{"id1": "13233761", "id2": "5808579", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 0, "substitutes": {"executeUpdateTransaction": ["startUpdateTx", "executeUpdateTx", "startUpdateTransaction", "executeWriteStatement", "startUpdateStatement", "executeQueryStatement", "executeUpdateStatement", "executeInsertTx", "executeQueryTx", "executeInsertTask", "startQueryTask", "startQueryTransaction", "executeQueryTransaction", "executeInsertStatement", "executeWriteTransaction", "executeQueryTask", "startQueryTx", "executeInsertTransaction", "executeWriteTx", "startQueryStatement", "startUpdateTask", "executeUpdateTask", "executeWriteTask"], "queries": ["queeries", "quearks", "galliries", "aqueries", "quiries", "aquiries", " Quarks", "queues", "Queries", "qualands", "galleries", "quues", "aquands", "gallenges", "quands", " Quands", " Queries", "qualenges", " Quues", "aquenges", "qualiries", "quenges", "gallands", "queands", "quarks", "qualeries", "Quarks", "Quues", "Quands"], "autoCommit": ["automaticCommate", "autoDebcommit", "automaticCompit", "autoBeport", "autoCommate", "autoDebate", "automaticCommit", "AutoCommit", "autoBeits", "autoDebit", "autoCompcommit", "autoAmport", "autoCommport", "autoClport", "autoClits", "autoAmit", "autoClmit", "autoCompate", "autoCommmit", "autoAmits", "autoBeit", "automaticCompate", "autoDebist", "autoCommist", "AutoCommits", "autoBemit", "autoAbsate", "autoAbscommit", "autoAmmit", "AutoClit", "autoCompit", "AutoCommmit", "automaticCompcommit", "autoCommits", "autoAbsist", "autoCompist", "automaticCommist", "automaticCommcommit", "automaticCompist", "autoAbsit", "AutoClits", "AutoClport", "AutoCommport", "autoClit", "autoCommcommit", "AutoClmit"], "iterator": ["iter", "liner", "collection", "storage", "creator", "pie", "number", "ski", "information", "list", "instance", "zero", "reader", "current", "starter", "video", "bis", "Iterator", "immigrant", "trace", "walker", "rounder", "loader", "size", "vector", "oser", "continue", "encer", "giving", "former", "udder", "ator", "stream", "next", "rows", "page", "menu", "started", "internet", "pour", "ter", "processor", "pler", "upper", "loop", "issues", "runner", "interstitial", "ner", "sequence", "folder", "set", "taker", "river", "writer", "seconds", "gener", "finder", "members", "pee", "integer", "inner", "operator", "sample", "outer", "directory", "series", "values"], "query": ["message", "script", "check", "qu", "title", "parse", "update", "sql", "subject", "description", "request", "join", "task", "string", "quest", "lock", "sq", "test", "key", "term", "row", "quote", "family", "q", "menu", "Query", "version", "password", "command", "result", "sequence", "condition", "question", "escape", "resource", "code", "execute", "name", "comment", "prefix", "series", "table"], "statement": ["ment", "message", "block", "group", "slot", "template", "parse", "sql", "binary", "mt", "shell", "description", "session", "task", "Statement", "system", "continue", "rule", "word", "confirmed", "quote", "batch", "expression", "minute", "command", "state", "sequence", "set", "usage", "fire", "line", "condition", "connection", "resource", "print", "execute", "comment", "phrase", "status", "table", "call"]}}
{"id1": "12066447", "id2": "12766394", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"truncate": ["trculate", "extvalidation", "extvalidate", "trvalidate", "extuncation", "truncize", "trunicate", "trculicate", "trvalidize", "extvalidicate", "trculize", "truncicate", "trunize", "trculation", "extuncicate", "trvalidicate", "truncation", "extvalidize", "trunate", "trvalidation", "trunation", "extuncize", "extuncate"], "file": ["message", "path", "block", "range", "user", "channel", "full", "foo", "or", "format", "files", "template", "out", "type", "info", "f", "filename", "class", "be", "fp", "dir", "current", "use", "zip", "frame", "link", "lock", "size", "image", "run", "word", "this", "page", "le", "null", "source", "from", "object", "ile", "to", "handle", "tree", "io", "attribute", "work", "spec", "report", "port", "FILE", "get", "log", "e", "parent", "line", "event", "resource", "module", "model", "base", "create", "data", "name", "time", "File", "local", "table"], "backupRoot": ["backumproot", "workuproot", "backureHome", "backupBox", "backuperroot", "backupsBox", "backumpRoot", "backumpDir", "workupDir", "backflowDir", "backuperRoot", "backmpRoot", "backmpDir", "backupidroot", "backupHome", "workupidHome", "backumpBox", " backupidBox", "backupidBox", "BackupDir", "backflowRoot", "backupsDir", " backupBox", " backupidDir", "backuproot", " backupidRoot", "BackupidRoot", "workupRoot", "backdownDir", "BackupRoot", "workupHome", "backureBoot", "workupidRoot", "backflowFolder", "backupidBoot", "backupDir", "backupidFolder", "backupsRoot", "backupidRoot", " backuproot", "backupidHome", "backureRoot", "workupidBoot", "backupBoot", "backureDir", "backupsroot", " backupidroot", "backureroot", "backupidDir", "BackupidDir", "backuperDir", "backmproot", "BackupidFolder", "backdownRoot", "workupidroot", "backuperHome", "workupBoot", " backupDir", "backdownFolder", "backupFolder", "workupidDir", "BackupFolder", "backmpBoot"], "df": ["dl", "dep", "dr", "format", "cd", "uf", "dp", "ds", "f", "du", "bf", "fd", " pdf", "DF", "tf", "gd", "md", "tif", "hd", "dc", "fun", "pd", "dd", "def", "dt", "Def", "lf", "pdf", "mm", "deb", "dim", "dx", "sf", "d", "sd", "cf", "raf", "db", "di", "dm", "NF"], "date": ["message", "match", "daily", "day", "future", "when", "range", "format", "value", "note", "number", "update", "save", "grade", "output", "days", "ate", "zone", "frame", "string", "down", "dated", "standard", "age", "dates", "run", "due", "year", " day", "version", "default", "late", "dt", "cal", "dat", "get", "month", "duration", "event", "resource", "content", "module", "sum", "create", "start", "now", "data", "name", "Date", "tag", "time", "today", " Date"], "zipFile": ["logfile", "pdfStream", "jsonfile", "zfile", "zFilename", "zipfile", "Zipfile", "ZipPath", "logPath", "pdfPath", "logFile", "zipPath", "ZipStream", "pdfFile", "jsonStore", "logStream", "zipFilename", "pdffile", "logFilename", "zStore", "logStore", "ZipFile", "jsonFile", "jsonFilename", "zFile", "zipStream", "zipStore"], "zos": [" sands", "zar", "asar", "hz", "css", "webkit", "zers", "zan", "zo", "oses", "ones", "zzle", "za", "z", "ss", "hess", "cos", "los", "sbm", "oss", "tz", "nz", "asio", "bes", "zen", "sch", "enos", "os", "zona", "ze", "estro", "jas", "cz", "bs", "ses", "zb", "zin", "enz", "sol", "hs", "js", "ez", "shed", "ozo", "zag", "sis", "eros", "rez", "esm", "ros", "south", "zi", "zes", "stice", "zer", "Sax", "zon", "zik"], "fis": ["sfier", "ofib", "sfiss", "fois", "foi", "ofis", "Fier", "fier", "dfis", "li", "fiois", "ifisc", "Fis", "F\u00eds", "sfis", "fisc", "efisc", "fib", "cfisc", "ef\u00eds", "lis", " fois", "fiis", "FIs", "ifis", "fiiss", "fiib", "ofois", "fiss", "Fia", "f\u00eds", "fIs", "if\u00eds", "dfier", "dfiss", "Fisc", "fi", "sfits", "foia", "fia", "cfiss", " fiss", "sfisc", "efIs", "lia", "ofits", "foIs", "efis", "ofiss", "sfIs", " fib", "ofisc", "cfis", "fits", "ifIs", "cfits", "dfIs", "lIs", "Fi", "Fiss"], "entry": ["obj", "ment", "ce", "or", "zo", "sheet", "ace", "search", "office", "rance", "ary", "ion", "description", "and", "zip", "add", "se", "cell", "record", "Entry", "de", "key", "word", "row", "ent", "object", "def", "char", "xml", "attribute", "cue", "element", "command", "set", "option", "delete", "ie", "e", "deep", "entity", "tex", "insert", "event", "connection", "resource", "escape", "internal", "data", "ry", "comment", "section", "member"], "buffer": ["message", "library", "block", "iter", "header", "template", "cache", "binary", "paste", "frame", "append", "queue", "padding", "zero", "memory", "window", "Buffer", "word", "page", "screen", "category", "batch", "char", "document", "letter", "command", "bar", "attribute", "sequence", "view", "length", "stack", "temp", "buf", "available", "code", "base", "sample", "buff", "phrase", "comment", "volume", "button", "table", "variable"], "readed": ["indexed", "readED", "counter", "Reader", "READer", "readeded", "countd", "Readared", "Readed", "readableied", "finded", "findared", "reader", "rededed", "readented", "indexED", "readared", "READd", "counted", "findED", "readableed", "READED", "indexeded", "redED", "Readied", "readd", "redented", " readented", "findied", "indexented", "readableared", "readableED", "readied", "READed", "countED", "reded", "ReadED", " readED", " readeded", "Readd"]}}
{"id1": "8665649", "id2": "18211588", "code1": "    private BufferedImage _getImage(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        InputStream in = null;\n        try {\n            in = conn.getInputStream();\n            return ImageIO.read(in);\n        } finally {\n            IOUtilities.close(in);\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"_getImage": ["_downloadImage", "_downloadimage", " _getimage", "_downloadImages", " _getImages", "_buildFile", " _downloadFile", " _downloadImages", "_getimage", "_downloadFile", "_getImages", "_getFile", "_buildImages", "_buildimage", "_buildImage", " _downloadImage", " _downloadimage", " _getFile"], "urlStr": ["urlSt", "urlString", "imageString", "UrlString", "uriStr", "lString", "lSt", "lSTR", "mountString", "mountSTR", "imageStr", " urlString", "imageSTR", "UrlSTR", "UrlStr", "imageSt", " urlSTR", "uriSTR", "urlstr", "uriString", "mountStr", " urlSt", "mountstr", "uristr", "Urlstr", "lStr", "urlSTR"], "url": ["ls", "dl", "cert", "http", "URL", "parse", "r", "api", "f", "abs", "l", "ur", "link", "str", "https", "sur", "gl", "client", "google", "web", "org", "nl", "loc", "q", "lb", "host", "uri", "char", "rl", "el", "sb", "build", "Url", "re", "ssl", "ul", "bel", "base", "atl", "ll", "pl", "sl"], "conn": ["cs", "init", "Conn", "net", "ctx", "cert", "conf", "nn", "yn", "open", "comm", "nt", "l", "ann", "client", "cb", "org", "c", "loc", "gate", "cp", "cn", "ct", "cmd", "coll", "canon", "nc", "ch", "conv", "enc", "serv", "con", "ctrl", "jp", "connection", "cont", "ssl", "syn", "res", "cur", "rel", "connect", "db", "pg", "pas"], "in": ["In", "user", "is", "init", "or", "ill", "on", "out", "input", "rin", "it", "all", "file", "ma", "IN", "m", "inn", "reader", "and", "t", "s", "l", "ai", "bin", "again", "proc", "include", "as", "req", "pid", "ins", "stream", "source", "inc", "mc", "txt", "from", "en", "act", "xml", "io", "ind", "oin", "body", "im", "mat", "qa", "din", "isin", "cin", "con", "i", "gin", "serv", " din", "sum", "inner", "o", "doc"]}}
{"id1": "13563706", "id2": "23273706", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"doGet": ["doget", "DoGET", " doGET", " doget", "handleget", "DoGet", "doGET", "handleGET", " doPut", "handlePut", "handleGet", "doPut", "Doget", "DoPut"], "request": ["setup", "message", "transform", "path", "user", "each", "http", "QUEST", "input", "query", "search", "application", "url", "address", "context", "subject", "project", "first", "reference", "current", "use", "frame", "directory", "route", "Request", "forward", "xml", "initial", "attribute", "document", "command", "version", "view", "socket", "report", "position", "get", "parent", "re", "complete", "connection", "event", "resource", "create", "order", "hello", "reset", "call"], "response": ["reply", "message", "block", "header", "ce", "collection", "format", "display", "http", "search", "write", "application", "output", "description", "frame", "network", "success", "summary", "answer", "zero", "continue", "image", "next", "exit", "ve", "resp", "tree", "version", "document", "default", "result", "foundation", "sequence", "view", "respond", "json", "console", "report", "position", "see", "fire", "render", "condition", "connection", "server", "print", "res", "security", "hash", "Response", "example", "status", "service", "relation"], "selectedPage": ["selectionItem", "electionPage", "selectionFile", " selectedFile", "lectedLine", "selectedLine", "lectedFile", "selectPage", " selectedPort", "specifiedFrame", "selectItem", "selectionPage", "electedPage", "verifiedFile", "selectedDocument", "selectedpage", "namedPort", "matchedPort", "lectedItem", " selectedFrame", "lectedPort", " selectedpage", "singlepage", "selectLine", "namedLine", "matchedpage", "electedPort", "matchedPage", "selectFile", "selectionToken", "singlePage", "singleFrame", "lectedPage", "selectionLine", " selectedRow", "selectedToken", "namedFrame", "namedKey", "specifiedDocument", "selectPort", "lectedRow", "selectPath", "selectedRow", "verifiedRow", "singlePort", "specifiedPort", "lectedDocument", "selectedPath", " selectedPath", "selectedItem", "verifiedPage", "namedPage", "matchedFrame", "lectedKey", " selectedKey", "namedToken", "verifiedpage", "electionDocument", "lectedpage", "lectedToken", "selectedFile", "specifiedPage", "electedpage", "lectedFrame", "selectedKey", "selectedPort", "electionFrame", "namedpage", "lectedPath", "selectedFrame", "electionPort", "selectionPort", " selectedLine", "electedFrame"], "page": ["group", "pp", "project", "current", "phone", "image", "next", "p", "port", "log", "line", "resource", "profile", "node", "filter", "user", "collection", "url", "age", "self", "window", "row", "proxy", "successful", "result", "site", "chain", "pointer", "point", "pool", "table", "message", "block", "application", "instance", "network", "record", "peer", "layout", "version", "Page", "phrase", "channel", "pages", "display", "cache", "number", "office", "associated", "address", "be", "force", "output", "frame", "client", "rule", "created", "menu", "object", "to", "document", "view", "policy", " Page", "position", "form", "parent", "me", "server", "language", "complete"], "portalRequest": ["portaleApply", "portalingAccess", "portalaAccess", "portalityRequest", "portsalResponse", "PortalThread", " portalApply", "portalaCall", "portsortalEvent", "portualRequest", "terminalidQuery", "portortalContext", "portalidSession", "portalContext", "portortalQuery", "portualrequest", " portalCall", "portaleResponse", "portsortalResponse", "portaleSession", "PortalContext", "portaleContext", " portaleCall", "terminalRequest", "portalrequest", "terminalQuery", "PortalQuery", "portalidResponse", "portalingRequest", "portralContext", "PortalResponse", "portpalContext", "terminalResponse", "portalThread", "portalidContext", "portortalRequest", "PortaleContext", "portpalRequest", "portralResponse", "portalidRequest", "portralQuery", "portalFrame", "PortaleThread", "portalidFrame", "portsortalRequest", "portortalThread", " portaleRequest", "portalityResponse", "portpalThread", " portaleApply", "portortalrequest", "portalerequest", "portalingApply", "portalAccess", "portalQuery", "portralSession", "portaleQuery", "portsortalrequest", " portalAccess", "PortalRequest", "terminalidResponse", "portalaRequest", " portaleAccess", "PortalFrame", "portsalrequest", "portortalResponse", "PortaleRequest", "terminalidRequest", "portaleEvent", "portaleCall", "PortaleFrame", "portalityFrame", "portalingCall", "portpalResponse", "portaleThread", "portsalRequest", "portalaApply", "portaleAccess", "PortaleResponse", "portalityContext", "portaleRequest", "portualEvent", "portalApply", "portualResponse", "portalSession", "portsalEvent", "portaleFrame", "portalEvent", "portalidQuery", "PortaleQuery", "portralRequest", "terminalSession", "portalCall", "portortalEvent", "portalResponse", "terminalidSession"], "pageProp": ["poolProp", "propertyPriv", "pagePriv", " pageComp", "propertyProp", "pagePred", "agePro", " pagePriv", "profileZip", "pageProperty", "keyProperty", "profilePred", "poolPred", "phrasePr", "pagePro", "officeProp", "pageComp", "officePriv", "pageZip", " pagePr", "imagePr", "sectionPred", "imageProp", "agePred", "officeDef", "pageDef", "agePr", "propertyDef", " pagePred", "sectionPro", "imagePred", "pagePr", "imagePro", " pagePack", "phraseProperty", "profilePro", "propertyPack", "ageProp", "keyProp", " pagePro", "poolZip", "poolPro", " pageProperty", "sectionProp", "phraseComp", "keyComp", " pageDef", "profileProp", "officePack", "sectionZip", "keyPr", "phraseProp", "pagePack"], "possiblePage": ["PossiblyPage", "PossiblePage", "piblePage", "pibleChild", "pbableCollection", " packedLine", "possiblyCollection", "possibleLine", " possibleTag", "pentialPage", "possiblyUser", "pablePage", "pableLine", "pspecifiedPage", "pspecifiedPages", "packedTag", "possiblyTag", "pbableUser", "possiblyChild", "packedCollection", "possibleChild", " possibleLine", "PossiblePages", "Possiblepage", "PossiblyCollection", " packedTag", " possibleCollection", "pentialTag", "pibleCollection", "possiblepage", "pbableChild", "pspecifiedpage", "pibleUser", "possibleTag", "PossiblyUser", "pbablePage", "pableTag", "possibleCollection", "PossibleTag", "PossibleCollection", "possiblyLine", "possiblePages", " packedCollection", "possiblyPage", "PossiblyChild", "pentialpage", "pableCollection", "pspecifiedTag", " packedPage", "packedPage", "pentialPages", "PossibleChild", "possibleUser", "packedLine", "PossibleUser"], "property": ["message", "header", "value", "Property", "title", "function", "prop", "type", "address", "class", "description", "config", "properties", "second", "frame", "string", "trace", "feature", "key", "rule", "domain", "p", "object", "rue", "expression", "attribute", "owner", "command", "field", "policy", "definition", "position", "behavior", "resource", "metadata", "integer", "location", "operator", "name", "phrase", "relation", "service", "variable"], "referer": ["relender", "relerential", "rorered", "reportrer", "Referee", "retered", "diffrer", "deferer", "refrer", "verrer", "redere", "reonder", "aferential", "refener", "printrier", "afrer", "reener", " refered", "referential", "Refere", "vererential", "refered", "vererer", "requonder", "requering", "retarer", "rorirect", "defrer", "relener", "defirect", "reportered", "refere", "aferer", " refirect", "refonder", "retrer", "relrer", "rorrer", "differer", "rederee", "refering", "refarer", "afener", "fener", "frer", "requerer", "rerier", "rorerer", "reere", "reterer", "reender", "printerer", "refirect", "reering", "rangeender", "reeree", "differing", "ferer", "reerer", "reered", "refender", "diffonder", " refrer", "refrier", "reerential", "redrer", "rangerer", "relering", "rearer", "rederer", "reportarer", "Refrer", "rangeerer", "reporterer", "Referer", "defered", "verrier", "relerer", "fering", "printrer", "printerential", "referee", "rerer", "requrer", "rangeener"], "e": ["r", "f", "err", "oe", "error", "m", "echo", "t", "se", "eg", "ae", "x", "de", "n", "ception", "a", "p", "h", "eeee", "er", "eu", "ge", "E", "te", "ie", "g", "es", "me", "event", "eur", "o", "ee"]}}
{"id1": "17716716", "id2": "20751378", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "label": 1, "substitutes": {"plainToMD": [" convertToMD", " convertTomd", " stringToDM", " stringFromMD", " stringAsmd", " convertAsmd", " stringFrommd", " convertAsMC", " stringAsMC", " convertToDM", " stringFromDM", " stringAsDM", " convertToMC", " stringTomd", " convertAsMD", " stringToMC", " convertAsDM", " stringAsMD", " stringToMD", " stringFromMC"], "loggerCol": ["loggerCl", "loggerColl", "badgerColl", " logggerCol", " logggerCOL", "loggeCl", "logGERCol", " loggerColumn", "badgerCOL", " loggerCOL", "badinatorCol", "logGERColumn", "badinatorColl", "loggeCOL", "logggerCl", "badgerCl", "badgerCol", "loginatorCl", "logggerColl", "badinatorCOL", "loginatorCOL", "loggeCol", "loginatorColl", " logggerColumn", "badinatorCl", "logiderCOL", "logiderColumn", "loginatorCol", "logGERCOL", "logggerColumn", "loggerCOL", "logiderCol", "logggerCOL", "loggerColumn", "logggerCol", "loggeColl"], "input": ["value", "out", "it", "url", "subject", "context", "output", "file", "request", "config", "Input", "string", "str", "image", "this", "source", "from", "q", "in", "pattern", "up", "char", "initial", "document", "command", "result", " Input", "text", "form", " inputs", "raw", "buffer", "active", "background", "base", "example", "hash", "data", "prefix", "hello"], "byteHash": [" byteMap", "byteMap", " byteTr", "binaryHash", "bytesMap", "byteHas", "ueHash", "uehash", "binaryhash", "bytesHash", "bytehash", " byteHas", "ueLength", "ByteHash", "bytesHas", "ByteHas", " bytehash", "byteLength", "byteshash", "Bytehash", "ByteLength", "ByteTr", " byteLength", "byteTr", "ueTr", "ByteMap", "binaryHas"], "md": ["nd", "ng", " mc", "cd", "dr", "ds", "gm", "mt", " MD", "red", "grad", "MD", "m", "mp", "pm", "rm", "der", "cond", "mk", "mac", "add", "met", "de", "hd", "mo", "mc", "df", "dd", "cmd", "ct", "pd", "comp", "def", "det", "sam", "ded", "msg", "mod", "ind", "mm", "ld", "med", "bd", "od", "dig", "mn", "mb", "material", "gr", "d", " Md", "sd", "hash", "mg", "ms", "di", "sm", "doc", "dm"], "md5result": [" md8Result", "md8message", "MD5results", "md5results", "md3message", "MD5result", "md7string", "md2results", "md3string", "md8proc", "md5comment", " md5Result", "md65Result", "md5message", "MD2Result", "md5response", "md65message", "md45response", " md8proc", "md3results", "MD5Result", "md5string", " md5message", "md2result", "md5proc", "md45result", "md45comment", "MD2results", " md8result", "md64comment", "md64results", "md7result", "md3proc", "md2response", "md8result", "md5Result", "MD5response", "md3result", "md2comment", "md7Result", "MD5comment", "md65result", "md64response", "md7results", "MD2comment", "md3Result", " md5proc", "md65proc", "md8Result", "md45results", "md64result", "MD2response", " md8message", "MD5string", "md2string", "MD2result", "MD2string", "md2Result"], "i": ["b", "iter", "is", "init", "my", "us", "gi", "id", "qi", "it", "xi", "\u0438", "ci", "li", "z", "I", "m", "l", "di", "ai", "ix", "gu", "x", "c", "key", "bi", "n", "ii", "a", "q", "multi", "u", "mi", "uri", "ic", "in", "io", "fi", "ind", "y", "im", "phi", "sim", "ie", "ji", "me", "si", "v", "ei", "pi", "span", "o", "ti", "cli", "j", "ui", "index", "ims", "ip"]}}
{"id1": "2168610", "id2": "18631594", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 0, "substitutes": {"update": ["put", "equal", "draw", "out", "offset", "where", "find", "info", "grade", "current", "add", "fill", "size", "continue", "u", "batch", "set", "edit", "report", "get", "resource", "status", "commit", "change", "user", "init", "value", "id", "write", "save", "select", "login", "UPDATE", "run", "row", "num", "handle", "result", "state", "updated", "insert", "date", "now", "diff", "check", "database", "count", "send", "load", "dates", "exit", "action", "up", " UPDATE", "print", "ul", "latest", "index", "Update", "http", "component", " Update", "use", "touch", "op", "msg", "delete", "remove", "create", "call"], "o": ["obj", "ilo", "aco", "out", "lo", "k", "iso", "onet", "oco", "m", "t", "l", "bo", "fo", "c", "n", "mo", "a", "os", "p", "object", "oid", "om", "q", "h", "ao", "to", "O", "oin", "oo", "po", "e", "i", "cont", "co", "oa", "ob", "ooo"], "contact": ["message", "match", "group", "check", "aco", "pp", "format", "title", "impact", "display", "panel", "component", "responsible", "info", "force", "address", "comm", "translation", "config", "acts", "add", "phone", "l", "consider", "cell", "country", "client", "cc", "entry", "character", "international", "detail", "lead", "ACT", "details", "conduct", "close", "cp", "action", "ct", "act", "compliance", "control", "char", "Contact", "addr", "work", "company", "charge", "report", "form", "port", "mail", "controller", "trans", "fax", "cont", "connection", "content", "print", "communication", "transfer", "module", "claim", "hello", "att", "service", "CONT"], "pst": ["jply", "bpst", "jpsy", "pct", "phpstal", "pnt", "phpnt", "vply", "epnt", "pingth", "jpSt", "Prest", "pingstal", "vpct", " pnt", "preth", " pST", "post", "pest", "lST", " pstan", "ipsth", "PST", "ipth", "epct", "epstal", "pstra", "lst", "jpset", "pth", "pstal", "pingst", "jpct", "pstan", " pstra", "bpost", "jpmt", "prst", "psta", "jpster", "pect", "dct", "pmt", "epst", "prect", "ipmt", "prct", "lse", "dpct", "pse", "ply", "presta", "Pse", "pingstra", "jpst", "apost", "drest", " pster", "pingct", "tpstal", " pct", " pmt", "tpst", "ppt", " post", "tpct", "dpst", "apst", "pST", "lct", "vpset", "ipct", "preSt", "psth", "presth", " psy", "bpstan", "dpt", "Ppt", "apstan", "prST", "dpster", "pster", "ipSt", "pingsta", "perest", "dpsy", "bpSt", "jpST", " pSt", "pset", "prest", "ipsta", "psy", "phpct", "vpst", "Pct", "phpst", "apSt", "pept", "ipST", "prse", " ply", "pingSt", " psth", "Pst", "dst", "pSt", "ipst", " pstal", "tpstra", " pset"]}}
{"id1": "18504192", "id2": "10131427", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" transferfile", "copyFiles", " transferFile", " CopyFiles", " CopyFile", "CopyFile", "CopyStream", " Copyfile", " transferFiles", " transferStream", "CopyFiles", " CopyStream", "copyStream", "Copyfile", "copyfile"], "in": ["b", "In", "is", "or", "on", "input", "rin", "it", "id", "IN", "inn", "l", "inf", "as", "vin", "ins", "n", "from", "inc", "en", "ic", "up", "el", "old", "ind", "edIn", "din", "mm", "isin", "cin", "i", "gin", "o"], "out": ["b", "ex", "at", "OUT", "net", "ou", "it", "k", "err", "output", "nt", "t", "help", "l", "s", "oss", "gt", "Out", "n", "os", "to", "io", "ne", "outs", "w", "g", "po", "log", "serv", "i", "v", "o", "ot"], "source": ["SOURCE", "match", "sin", "template", "src", "init", "parse", "store", "input", "search", "query", "Source", "open", "subject", "force", "info", "shell", "space", "file", "instance", "reader", "ource", "seed", "use", "se", "inside", "before", "back", "origin", "system", "from", "scope", "copy", "spec", "sequence", "style", "position", "access", "ie", "pse", "iterator", "me", "ources", "resource", "inner", "start", "sample", "create", "scan", "volume", "comment", "service", "local", "secret"], "destination": ["destification", "coordification", "Destension", " destregation", " destinated", "Destinator", " destinator", "destinated", "restinator", "coordregation", "restinated", "Destinated", "comination", "seeinator", "destension", "comification", " destation", "seeinated", "destato", "destinator", "restation", "coordination", "seeension", "destation", "destregation", "coordato", "restination", " destension", " destato", "seeination", "Destation", " destification", "comato", "comregation", "Destination"]}}
{"id1": "23666867", "id2": "15166511", "code1": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["copyFiles", " mirrorChannel", "CopyChannel", "CopyFile", "CopyStream", "copyChannel", " mirrorFile", "CopyFiles", " copyFiles", " copyStream", " mirrorFiles", " copyChannel", "copyStream", " mirrorStream"], "in": ["In", "b", "is", "init", "on", "input", "rin", "it", "id", "info", "r", "IN", "inn", "s", "l", "bin", "ar", "ins", "n", "source", "from", "inc", "en", "ic", "xml", "el", "old", "ind", "isin", "cin", "i", "gin", "inner", "o"], "out": ["b", "dest", "user", "ex", "at", "OUT", "net", "ou", "it", "all", "write", "f", "output", "nt", "file", "t", "l", "s", "gt", "Out", "n", "one", "null", "source", "os", "p", "to", "io", "ne", "outs", "result", "y", "w", "target", "ch", "port", "po", "g", "log", "temp", "i", "v", "aos", "o", "base", "ot", "name"], "inChannel": ["incButton", " inCh", "incClient", " inCamera", " inchannel", "outStream", " inChain", "innerchannel", "inChain", " inClient", "vinChan", " inStream", "inStream", "incChannel", "inCh", "dinFace", "isinCamera", "cinCommand", "inFace", "sinChan", "ginButton", "innerCommand", " inChan", "insideChannel", "vinChannel", "isinStream", "rinChannel", " inButton", "inClient", "innerChannel", "insideCondition", "outCamera", "inCamera", "inButton", "dinCh", "innerChan", "inCommand", "dinButton", "innerChain", "isinChannel", "innerClient", "cinChain", "sinChannel", "sinChain", "cinchannel", "ginClient", "cinChannel", "sinClient", "incChain", "ginChannel", "rinGray", "cinClient", "dinCondition", "inchannel", "dinGray", "rinCh", "dinChannel", "inChan", "cinChan", "inCondition", "insideFace", "vinFace", "inGray", " inGray", "ginChain", "outChan", " inCommand", "vinCondition", "rinButton", "insideChan", "dinChan", "isinChan"], "outChannel": ["outchannel", "outHandler", "netChan", " outRoom", " outCategory", " outChan", "canChan", "outCategory", " outClient", "outerButton", "netChannel", "courseChannel", "courseChan", "outputchannel", "outerChan", " outConnection", "onChan", "Outchannel", "outConnection", "netClient", "outputClient", "outerCan", " outchannel", "outClient", "netConnection", "OutChan", " outHandler", "inCan", "onChannel", "outputChan", "outputCache", " outCache", "OutHandler", "inButton", "outRoom", "courseCan", "canCategory", "outputChannel", "outCan", "outerChannel", "courseButton", "onRoom", "canRoom", "inChan", "outCache", "OutChannel", "outputHandler", "outButton", "outChan", "canChannel", "onCategory", "outputConnection"]}}
{"id1": "9275622", "id2": "3584508", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpStream", " cpFiles", " duplicateFile", "copyFiles", " cpFile", " copyfile", " duplicateStream", " copyFiles", " copyStream", " duplicateFiles", " cpfile", " duplicatefile", "copyStream", "copyfile"], "_file1": ["_fileInit", "_link1", "_ile2", "_ileOne", "_FileOne", "_ile1", "_ileInit", "_files2", "_linkInit", "_FileFirst", "_fileOne", "_File1", "_files1", "_File2", "_filesFirst", "_FileInit", "_fileFirst", "_linkOne", "_link2", "_ileFirst", "_filesOne"], "_file2": ["_Fileb", "_linkTwo", "_image1", "_link1", "_FILEb", "_file02", "_File02", "_FILE1", " _FILEb", " _FILE2", "_image2", " _Filetwo", " _FILE1", " _File1", "_image02", " _fileb", "_File1", "_FILE02", " _FileTwo", "_Filetwo", "_File2", "_FILE2", " _filetwo", " _fileTwo", "_link2", "_imageb", " _file02", " _FILE02", "_fileTwo", "_filetwo", "_FileTwo", "_fileb", " _File2", "_linktwo"], "fis": ["kais", "ufi", "fois", "Fios", "fios", "kis", "Fis", "cos", " fris", "cios", " fios", " fois", "ufis", "fiss", "cfris", "fais", "cis", " fais", "qos", "fliss", "ufiss", "fris", "fi", "ufios", "cfois", "qiss", "kios", "cfiss", " fiss", " fi", "qios", "kos", "flis", "Fois", "Fris", "cfis", "qis", "fli", "flios", "Fos", "cais", "Fiss"], "fos": ["flos", "ffoes", "waos", " foes", "moes", "ffis", "hose", "wis", "sfoes", "foss", " fows", "hos", "sfoss", "floes", "floss", "hoss", "maos", "sfose", "ffos", " foss", "wos", "mows", "woes", "foes", "fose", "woss", "wows", "faos", " fose", "flis", "ffoss", "hoes", "fows", "mos", " faos", "sfos"], "canalFuente": ["canalKuperor", "canalFuenza", "canallFuje", "canalfuestro", "canalFaleree", "canalFuje", "canalUtente", "canallfuent", "canalTenenza", "canalFienza", "canallfueree", "canalfuent", "canalFuestro", "canalFient", "canalUteree", "canallfuperor", "canalKuent", "canalFalje", "canalFiperor", "canallFuenza", "canalfuenza", "canallFueree", "canalUtent", "canalKuente", "canallFuestro", "canallFuperor", "canalUtestro", "canalTenente", "canalfuje", "canalFiente", "canalFalent", "canalTenent", "canalFalperor", "canalfuente", "canallfuenza", "canalFuent", "canalfuperor", "canallfuente", "canallfuje", "canallFuente", "canallFuent", "canalFueree", "canallfuestro", "canalFuperor", "canalKuje", "canalTenperor", "canalFalente", "canalfueree", "canalFalestro"]}}
{"id1": "13757855", "id2": "13159394", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public HttpResponse fetch(HttpServletRequest request) throws IOException {\n        GUI = SwingUI.getApplicatoin();\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n        CookieSpecFactory csf = new CookieSpecFactory() {\n\n            public CookieSpec newInstance(HttpParams params) {\n                return new BrowserCompatSpec() {\n\n                    @Override\n                    public void validate(Cookie cookie, CookieOrigin origin) throws MalformedCookieException {\n                    }\n                };\n            }\n        };\n        if (Helper.useProxy()) {\n            HttpHost proxy = new HttpHost(Helper.getProxyServer(), Helper.getProxyPort());\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);\n        }\n        httpclient.getCookieSpecs().register(\"easy\", csf);\n        httpclient.getParams().setParameter(ClientPNames.COOKIE_POLICY, \"easy\");\n        String currentRemoteGAEHost = Helper.getRemoteServer();\n        try {\n            HttpUriRequest httpRequest = createRequest(request);\n            addHeader(request, httpRequest);\n            HttpResponse response = httpclient.execute(httpRequest);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_FORBIDDEN) {\n                challengeProxy(currentRemoteGAEHost);\n            }\n            logger.info(Helper.count.incrementAndGet() + \" Response received from \" + request.getRequestURL().toString() + \", status is \" + response.getStatusLine());\n            GUI.updateFetchCount();\n            return response;\n        } catch (ClientProtocolException e) {\n            logger.error(\"Fetch ClientProtocol Error\", e);\n            throw e;\n        } catch (IOException e) {\n            logger.error(\"Fetch IO Error\", e);\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"process": ["transform", "format", "display", "parse", "write", "save", "project", "task", "processing", "apply", "add", "load", "proc", "Process", "run", "processor", "handle", "loop", "step", "build", "render", "create", "execute", "replace", "filter", "call"], "tpl": ["tmplate", " tpp", "topl", "Tph", "timplate", "tuple", "ptpl", "ttplug", "stpg", "ttph", "tpr", "timpg", "stspl", "tsurtle", "templ", "tembl", "Tpp", " tph", "ttPL", "tmplates", " tPL", "tpp", "tspl", "tmpp", "atuple", "ptbl", "tbl", "otbl", " tplate", "stbl", "itPL", "ttbl", "tsPL", "Tld", " tbl", "terld", "Tspl", "ttpl", "timspl", " tplates", "Tpr", "TPL", "ptld", "stplug", "itpl", "tmpl", "turtle", "timopl", "atpl", "itplate", "Tbl", "ttopl", "Tplate", "tspr", " turtle", "terplate", "timbl", "otld", "atplate", "atld", "tplate", " tuple", "itbl", "timpl", "otplate", "ptplates", " tld", "stpl", "tempr", "Tpl", "typl", "stplate", "tsbl", "teruple", "Tplates", "tmPL", "otpl", "tPL", "tplug", "timplug", "tyPL", "tmbl", "tld", "stopl", "tpg", "terpl", "temPL", "ttpg", "tyurtle", "tplates", "tph"], "model": ["models", " Model", "M", "Document", "project", "m", "file", "md", "product", "record", "html", "object", "tree", " models", "document", "el", "Model", "parent", "log", "ml", "module", "content", "base", "data", "node"], "packageName": [" packageNames", "Packagename", "viewClass", "packageVersion", "packageClass", " packageFamily", " packagename", "groupNames", " packageRoot", "groupVersion", "viewRoot", "viewname", "pkgNames", "packageFamily", "groupName", "packageNames", "pkgVersion", " packageClass", " packageVersion", "pkgName", "PackageClass", "groupFamily", "PackageName", "viewName", "pkgFamily", "PackageRoot", "packagename", "packageRoot"], "outFileName": ["outImagename", " outFilenameType", "outImageName", " outFileType", " outFilename", " outTableTime", " outTableSize", " outFilenameName", "infileTime", "outFileNames", "outStreamName", "outFilenamePath", "inFileType", "outFName", "outFilenameSize", " outfileNames", "outImagePath", "outFileSize", " outfilePath", "outDirTime", "outImageSize", "outFilenamename", " outTableName", "outFilenameTime", "infileName", "outFNames", " outFileChain", "outFileTime", "outFilenameName", " outFileNames", "inFilePath", "outTablePath", "infileNames", "outFilename", " outFileTime", " outFilenameChain", "outStreamType", "outfilePath", "outFileChain", " outFilenameSize", "outTableSize", "inFileNames", " outfilename", "outTableChain", "outStreamPath", "outfileName", "outStreamTime", "outFPath", "outfilename", "outTableName", "outTableType", "infileType", "inFileName", "outFilenameNames", " outFilePath", "outFname", " outfileName", "outTablename", " outFilenamePath", "outDirName", "outFilePath", " outTablePath", "outFilenameChain", "outDirSize", "outfileNames", "outDirPath", "outfileChain", "outfileTime", "outStreamNames", "outFilenameType", " outFileSize", "infilePath", "outTableTime", "outfileType", " outFilenamename", "inFileTime", "outFileType"], "xsltParam": ["xltConf", "xsltParameter", "xltParam", "xmlParam", "xsslParameter", "xmlConf", "xsmlConf", "xsslConf", "xsmlParam", "xsqlParameter", "xsqlConf", "xmlParameter", "xsltConf", "xltParameter", "xsmlParameter", "xsqlParam", "xsslParam"], "artifact": ["partifacts", "arifact", "artificial", "Artifact", "Artifacts", "anificial", "ardifacts", " artificial", "ardificial", "ardifact", "partifact", "anifact", "ardificate", "anifacts", "artificate", "arifacts", "anificate", " artificate", " artifacts", "artifacts"], "destinationPath": ["destinatedKey", "termininationJar", "destensionDir", "origininatedPath", "destionpath", " destinationTarget", "descositoryPort", "destinationPort", "destinatedHome", "destitutionPoint", "destranceLog", "destensionPoint", "termininationTarget", "destinoPath", "destificationLocation", "delinationLog", "destinatedForm", "destositoryPort", "destinationDir", "estationPart", "identinateInfo", "destinatedPath", "destinateName", "destinationKey", "destensionTemp", "destinoKey", "destinateInfo", "termininerPath", "destacementName", "identinationKey", "destationPath", "destociationHome", "estinationTime", "DestensionHost", "destacementPath", "destinateUrl", "destinationPoint", "destinerHost", "destionPoint", "destesticJar", "estinoTime", "destesticPath", "delinationPoints", "destinatorPort", "destinatorPath", "origininationForm", "termininerTarget", "chaininatedPath", "chaininatedDriver", "delinateLog", "destinatorPoint", "destinateAt", "estionPoint", "destinerJar", "destinateDir", "estionpath", "destociationPath", "destinatedpath", "descositoryPath", "destacementKey", "identinatePath", "origininationNow", "destinationDisk", "destinationPart", "chaininationPath", "destinatorHost", "destinationHost", "DestinationPod", "generinationJar", "identinationInfo", "estationHost", "destificationDir", "estionPath", "identinateKey", "destinoName", "destinationTarget", "descinationParent", "termininerJar", "destociationDir", "destationLocation", " destociationpath", "destinantTemp", "destociationpath", "destositoryParent", "destationDir", "desturationTarget", "destATIONPath", "destinationSystem", "chaininationHome", "destinateKey", "destacementTime", "destATIONParent", "estinationHost", "destinatorpath", "destigationChain", "destinationLog", "destinatorPATH", "estinationKey", "estinationpath", "destociationPoints", "destitutionPATH", "descinationPath", "destigationPath", "destregationpath", "origininatedChain", "destventionDriver", "destionPATH", "desticationDir", "destinantPath", "DestensionPoint", "descinationHost", "destinatorKey", "destinationAt", "origininationPath", "destrancePoints", "destositoryPath", "destinerAt", "destinatePath", "DestinationDir", "destATIONHost", "estionPATH", "destinateNow", "destinationPATH", "estinationPATH", "DestensionTemp", "DestinationUrl", "destificationUrl", " destinationDisk", "destinatorParent", " destociationTarget", "desturationPath", "destinerTarget", "destinateTarget", "origininatedNow", "identinateChain", "destinateChain", "DestinationPoint", "descositoryParent", "identinationChain", " destociationDisk", "destinerPart", "destinationTime", "DestinationTemp", "estinoKey", "destociationHost", "destinoPoint", "destinateLog", "destinationHome", "destinerDir", "generinateAt", "destinerSystem", "identinationPath", "estationPath", "destventionDisk", "destinoDir", "destinationPoints", "destinationpath", "destregationDisk", "generinationPath", "destensionHost", "destranceForm", "DestinationLocation", "destociationLog", "destinationName", "destociationPoint", "destificationPath", "destinationUrl", "desticationPod", "generinatePath", "destinatedDisk", "destinatorChain", "destventionHome", "destociationForm", "termininationPath", " destociationPath", "descositoryHost", "destigationForm", "destinatedTarget", "DestinationPath", "DestificationUrl", "destationUrl", "delinationPath", "estationDir", "destesticSystem", "destinantPod", "destinatorInfo", "destationHost", "origininatedForm", "termininationpath", "chaininatedDisk", "destregationPath", "destinateLocation", "DestificationDir", "DestensionPod", "origininationChain", "delinationForm", "destositoryHost", "estinationPoint", "generinateJar", "destinationChain", "desticationPath", "desturationJar", "destATIONPort", "estinoPath", "delinateForm", "destensionPath", "estinoName", "destinationPod", "destinatePoints", "destinationJar", "destinationDriver", "desticationTemp", "destinatedNow", "destinationForm", "destventionPath", "destationPart", "destinateTime", "destensionPod", "destinatepath", "DestificationLocation", "destinationTemp", "estinationPart", "destitutionPath", "delinatePath", "destesticAt", "desturationpath", "DestinationHost", "estinationName", "generinationSystem", "destinateHost", "descinationPort", "destrancePath", "destionPath", "DestensionDir", "destinatedDriver", "destinatedInfo", "DestensionPath", "destitutionpath", "generinationAt", "destinationParent", "chaininatedHome", "generinateSystem", "destinateSystem", "destociationDisk", "destregationTarget", " destinationpath", "estinationDir", "destociationDriver", "destinoHost", "destinatedChain", "destinateJar", "destinoTime", "destociationTarget", "destinateForm", "destigationNow", "estinationPath", "destinatePart", "destinerPath", "destinantDir", "termininerpath", "chaininationDisk", "destinationNow", "delinatePoints", "chaininationDriver", "destinationInfo", "destinerpath", "destinationLocation", "DestificationPath"], "in": ["In", "input", "id", "info", "r", "f", "file", "m", "IN", "reader", "t", "l", "bin", "c", " IN", "ins", "n", "io", "w", "din", "i", "d", "inner", "o", "doc"], "out": ["inv", "obj", "b", "ex", "or", "OUT", "net", "ou", "conf", "cache", "all", "it", "write", "dis", "f", "err", "output", "nt", "oe", "ln", "list", "file", "t", "s", "l", "client", "c", "Out", "n", "null", "ins", "os", "screen", "go", "nr", "p", "cn", "u", "cmd", "gen", "to", "up", "io", "sys", "ger", "outs", "msg", "w", "report", "ch", "writer", "e", "log", "conn", "con", "raw", "gr", "co", "print", "aos", "res", "o", "outer", "inner", "v", "can", "println", "cfg"], "root": ["group", "id", "r", "context", "ok", "_", "m", "Root", "config", "dir", "parents", " roots", "se", "de", "scope", "p", "roots", "graph", "def", "tree", "dump", "initial", "json", "parent", "impl", "New", "chain", "Template", "start", "create", "data", "name", "node", "println", "table", "child"]}}
{"id1": "13012591", "id2": "481364", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"getPasswordHash": ["getpasswordSum", "getpasswordMac", "getPasswordhash", "getpasswordHash", "getUserSum", "getPasswordMac", " getPasshash", " getPassHash", "getpasswordhash", "getPassMac", "getPassSum", " getPasswordhash", "getUserMac", " getPasswordMac", "getPasswordSum", "getUserHash", " getPassSum", "getUserhash", " getPassMac", " getPasswordSum", "getPassHash", "getPasshash"], "password": ["message", "user", "sword", "value", "pass", "input", "Password", "wd", "address", "database", "description", "login", "string", " Password", "padding", "email", "entry", "key", "word", "pattern", "username", "attribute", "token", "command", "shadow", "text", "w", "raw", "content", "reset", "data", "name", "phrase", "prefix", "hello", "secret"], "md": ["nd", " mc", "cd", " ms", "dh", "ms", "mt", "grad", "red", "MD", "m", "mp", "dir", "rm", "and", "der", "mk", "add", "mac", " ma", "hd", " dd", "mo", "mc", "df", "ent", " mo", "pd", "cmd", "dd", " sd", "det", "ind", "mod", "mm", "e", "ld", "bd", "od", "med", "mn", "gr", "mand", "d", "sd", "metadata", " Md", "mem", "mg", " mm", "di", "sm", "dm"], "hash": ["match", "block", "hz", "check", "cache", "where", "number", "all", "shift", "search", "array", "address", "map", "ash", "here", "mac", "ashes", "oh", "test", "html", "score", "color", "mask", "host", "h", "esh", "box", "handle", "char", "index", "used", "sh", "ashed", "style", "report", "sha", "has", "hex", "bh", "stack", "dig", "Hash", "total", "sum", "print", "sample", "filter", "square", "table"], "buf": ["b", "aux", "agg", "block", "bytes", "foo", "forge", "uf", "mu", "cap", "bp", "fam", "tmp", "pkg", "bl", "abs", "bc", "rb", "bo", "cb", "proc", "printf", "cat", "Buffer", "next", "bg", "av", "txt", "br", "cv", "img", "bu", "cmd", "hung", "bs", "box", "bag", "bar", "msg", "alph", "bh", "nb", "Buff", "bn", "buffer", "cf", "cur", "buff", "ov", "bed", "ob", "db", "var", "pb"], "i": ["ex", "is", "my", "ogi", "us", "gi", "qi", "it", "ski", "xi", "\u0438", "ci", "li", "ms", "z", "I", "m", "ai", "ix", "iq", "gu", "ki", "x", "key", "c", "hi", "ri", "n", "ii", "bi", "a", "q", "u", "mi", "multi", "uri", "ic", "ini", "in", "index", "y", "ind", "json", "im", "phi", "iu", "sim", "e", "ji", "chain", "si", "yi", "v", "ei", "pi", "o", "ti", "cli", "j", "ui", "di", "ims", "ip"]}}
{"id1": "771802", "id2": "2511579", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createOutputSteam", " createInputSteam", "createInputStream", " createInputstream", "createOutputstream", " createOutSteam", "createInputSteam", " createInputFile", " createFileFile", " createFilestream", " createFileStream", "createOutputFile", " createOutputstream", " createFileSteam", " createOutstream", " createOutStream", " createOutFile", "createInputstream", " createInputStream", " createOutputFile", "createInputFile", "createOutputSteam"], "inFile": [" inPort", "inDir", "ninfile", "ninPath", "inPath", "dinPath", "ninFilename", "inputDir", "outfile", "infile", " inFilename", " inDir", " infile", " inPath", "ninFile", "dinDir", "dinFile", "dinPort", "inPort", "inputPort", "outFilename", "inputFile", "inFilename", "inputPath", "outPath"], "outFile": ["exPlace", "newfile", "outPlace", "exfile", "exFile", "outputfile", "outputPlace", "newPlace", "newFile", "tofile", "outfile", "outPort", "infile", "toFilename", "outputFilename", "newFilename", "toFile", "inPort", "outputFile", "OutFile", "OutFilename", "exFilename", "toPort", "inFilename", "outFilename", "Outfile", "OutPort"], "k_blockSize": ["k2byteCount", "k_blockName", "k4blockName", "k2byteSize", "k4blockCount", "k_BlockLength", "k4BlockStyle", "k_BlockSize", "k2blockSize", "k_byteStyle", "k_byteName", "k_byteLength", "k2blockCount", "k_BlockName", "k_blockStyle", "k4blockSize", "k_byteCount", "k_byteTime", "k4BlockCount", "k_blockTime", "k_batchLength", "k_batchSize", "k_batchCount", "k_blockCount", "k_BlockCount", "k_BlockStyle", "k_byteSize", "k2blockTime", "k_batchTime", "k2byteLength", "k4BlockSize", "k4BlockName", "k_BlockTime", "k4blockStyle", "k2blockLength", "k2byteTime", "k_blockLength"], "byteCount": ["charLength", "byteCode", "wordSize", " byteCounter", "linePtr", "bitCode", "bytePtr", "charcount", "wordCode", "bbCount", "wordN", "charCount", "lineLength", "bitCounter", "bbSize", "bytecount", "bitCount", " byteCheck", "bbCode", "byteN", "blockLength", "blockCounter", "byteCheck", "byteLength", "linecount", "bitSize", "charPtr", "blockCount", " byteLength", "bitLength", " bytecount", "byteSize", "bbN", " bytePtr", "bitN", "bitCheck", "lineCount", "blockCheck", "byteCounter", "wordCount"], "buf": ["b", "bytes", "block", "ctx", "uf", "cap", "pkg", "bl", "bc", "rb", "ctr", "str", "queue", "cb", "proc", "tx", "cat", "Buffer", "bg", "txt", "cv", "img", "arr", "cmd", "batch", "bag", "msg", "seq", "exp", "alph", "conv", "fg", "Buff", "bn", "buffer", "raw", "vec", "cur", "mem", "buff", "cast", "db", "doc", "pb"], "ofp": ["owld", "owlpa", "OFd", "Ofd", "OFP", "Ofl", "OFp", "ofpa", "Ofpa", "ofP", "Ofp", " ofl", "ofd", "OFl", " ofd", "owlP", "owlp", "OfP", "ofl", " ofpa", " ofP"], "zos": ["css", "rose", "hz", "gs", "webkit", "zers", "init", "zo", "zh", "zzle", "rss", "za", "z", "std", "zu", "tis", "zip", "hess", "los", "sbm", "cos", "oss", "psy", "python", "nz", "bes", "zen", "sch", "os", "LOS", "enos", "zona", "ze", "osi", "jas", "cz", "bs", "settings", "zl", "zb", "zin", "socket", "zy", "ossus", "js", "ez", "ps", "zag", "sis", "rez", "eros", "south", "jp", "zi", "zes", "esa", "zer", "ws", "zon", "amia", "es", "zik"], "osw": ["isw", "ossW", "osswd", "osws", "oswx", "aosw", "osipace", " osW", "cosws", "osew", "owa", "syswd", "oswd", "ow", "osrw", "sysrw", "osssw", "aoswa", "ossrw", "aosW", " osew", "osd", "aosrw", "osiwa", "issw", "oswa", "ossw", " osd", "aosew", "cosw", "aospace", "oW", "osiW", "aosws", " oswx", "opace", "cosd", "cosew", " ossw", "iswx", "ospace", " osws", "osswx", "aoswd", "aosd", "osiw", "osW", "sysW", "isW", "sysw"], "bw": ["bwk", " bwl", "abwy", "besw", " bex", "pbz", "pbew", "rbws", "bew", "bend", "bbex", "pbwy", "rbz", "obsw", "abew", "wbend", " bsw", "bbwp", " bwt", "obz", "obwl", " bz", "nbew", "obwk", "bbz", "bwe", "wbx", " bend", "bewl", "bem", "bwb", "wbw", "bex", "obwb", "bz", "nbwy", "bbwt", "bbem", "bwt", "bbend", "bx", "rbex", "pbw", "bewk", "bwp", "wbz", "nbw", "sbwb", "nbwe", "pbwt", "sbz", "bsw", "wbwt", " bwp", "wbem", "sbw", "bbx", "bbws", "bbw", "abwe", "rbw", " bx", "bws", " bwk", "abw", "pbwe", " bem", "pbwb", "obwt", "obw", "wbwp", "bwl", "bwy", "sbwt", " bws"], "zot": ["zoonet", "zeronet", "zipot", "zeriat", " zote", "zhot", "zo", "zonet", "Zot", "zor", "zeror", " zott", "zerhot", "zoot", "zero", "zoor", " ziot", " zo", "Zote", " ziat", " zor", " zonet", "Zott", "zeriot", "zerote", "ziot", "zerott", "zoo", "ziphot", "zipiot", "zote", " zhot", "zerot", "Zit", "zipiat", "zott", "zerit", "ziat"], "ifp": [" ifP", "Ifjp", " ifth", "ihp", "iftp", "Ifp", "isjp", "iwr", "ifth", "isP", "isth", " iftp", "ifd", "isp", " ifd", "ifjp", "iwtp", "ihr", " ifjp", "ifr", "iwp", "ifP", "IfP", "iwd", " ifr", "ihtp", "Ifth", "ihd"], "zis": [" zisc", "izis", "izi", "zoinit", "ezi", "zoisa", "izisa", "zois", "zeris", "zipIS", "ziis", "zipic", "zic", "ezis", " zIS", "ziinit", "iziss", "zinit", "ezisc", " zi", "izisc", "zipis", "ziisa", "zisc", "zeric", "zerIS", "ziiss", "zisa", "zi", " ziss", "zIS", "eziss", "zoiss", " zic", "ziss", "izinit"], "isr": ["isalpr", "isrs", "siscr", "isscr", "sisrc", "sisr", "iospr", "isrc", "ispr", "sisrs", "isalr", "isalsr", "itssr", " isrc", "itsr", " isrs", "iscr", "iosstr", "iossr", "issrs", "iosr", "issrc", " iscr", "isalstr", "isstr", "issr", "itspr", "itsstr"], "br": ["b", "bro", "dr", "ptr", "vr", "lr", "ba", "bp", "r", "bf", "bl", "obl", "sr", "rb", "str", "ctr", "bj", "Fr", "pr", "bi", "ber", "kr", "shr", "BR", "tr", "cr", "wr", "js", "bh", "Br", "bd", "bn", "yr", "gr", "bt", "mr", "rel", "bm", "hr", "fr", " Br"], "zit": ["zist", "lexist", " zop", "zeop", "zlit", "ziIt", "zipist", "czit", " zite", "izit", "ziplit", "lexIt", "zipit", "izip", "ezIT", "ziit", "zip", "iziti", " zIT", "zite", "czot", "ezite", "ziist", "zeip", "ozip", " zlit", "zipIt", "zop", "ziti", "zIt", "ozunit", "ozit", "zunit", "izunit", "czunit", " zip", "ezlit", "ezit", "zeot", "zipIT", "czop", "czip", "cziti", "zeit", "lexit", "zIT", "oziti", "ziIT", "zipite", "lexIT"]}}
{"id1": "11546108", "id2": "4562786", "code1": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 1, "substitutes": {"run": ["launch", "block", "evaluate", "wait", "find", "search", "func", "apply", "exec", "submit", " runs", "go", "running", "Run", "runner", "loop", "impl", "render", "process", "runs", " Run", "start", "execute", "sample", "invoke", "scan", "hello", "call"], "in": ["In", "read", "is", "on", "conf", "out", "input", "rin", "all", "info", "r", "f", "ln", "file", "IN", "ma", "inn", "reader", "and", "add", "l", "inf", "bin", "again", "fin", "ins", "source", "from", "mc", "inc", "p", "er", "copy", "oin", "din", "isin", "by", "get", "cin", "mn", "line", "gin", " din", "asin", "inner", "sum"], "ligneEnCours": ["ligneEnACour", "ligneENCurs", "ligneEnCour", "ligneEnCres", "ligneEnChours", "ligneEnCuRS", "ligneEnACurs", "ligneEnCoourses", "ligneEnCRS", "ligneENCours", "ligneEnChurs", "ligneENcears", "ligneEnCodes", "ligneENNourses", "ligneEnCoons", "ligneEncons", "ligneEnCuChamp", "ligneEncodes", "ligneConCours", "ligneEnCurs", "ligneENCres", "ligneENCons", "ligneENCsours", "ligneENCsurs", "ligneENNres", "ligneEnClChamp", "ligneENCour", "ligneENCChamp", "ligneEnNours", "ligneENConturs", "ligneEnContRS", "ligneConcodes", "ligneENCourses", "ligneENCsour", "ligneENNurs", "ligneENNours", "ligneEnCsour", "ligneEnContChamp", "ligneEnCears", "ligneENContours", "ligneENcour", "ligneENContChamp", "ligneEnCuurs", "ligneEnClRS", "ligneEnNourses", "ligneEnCores", "ligneEnClours", "ligneEnACours", "ligneEnChodes", "ligneEncears", "ligneEnNres", "ligneEncour", "ligneConcour", "ligneEnCuours", "ligneConcurs", "ligneEnCsours", "ligneEnCourses", "ligneEnConturs", "ligneEnChour", "ligneENcours", "ligneEnCoours", "ligneENCRS", "ligneConCodes", "ligneENCsons", "ligneEnCsons", "ligneENCears", "ligneEncurs", "ligneENcurs", "ligneEnClurs", "ligneEnContours", "ligneEnCChamp", "ligneConcours", "ligneENContRS", "ligneEnACears", "ligneEncours", "ligneEnCoodes", "ligneConCour", "ligneEnNurs", "ligneEnCons", "ligneEnCoour", "ligneConCurs", "ligneEnCsurs"], "i": ["b", "iter", "is", "init", "it", "xi", "ci", "li", "I", "m", "t", "l", "oi", "asi", "ai", "ix", "x", "continue", "bi", "ii", "n", "p", "mi", "multi", "off", "index", "io", "y", "ind", "phi", "iu", "ori", "g", "e", " j", "si", "v", "ei", "pi", "ti", "cli", "j", "ui", "di", "ini", " I"], "informations": ["ingenerations", "Informsation", "informsation", "Informators", "inflATIONS", "Informions", "inflions", "instration", "Informsators", "informsators", "Informsations", "ingenerATIONS", "information", "inflates", "inflation", "Informsions", "InformsATIONS", "Informations", "inflators", "informators", "ingenerions", "Informates", "informATIONS", "informions", "inflations", "Information", "informsATIONS", "Informsates", "instrATIONS", "informates", "informsations", "informsates", "instrations", "InformATIONS", "instrators", "ingenerates", "informsions"], "version": ["channel", "format", "value", "title", "number", "ver", "id", "type", "edition", "versions", "class", "description", "program", "client", "VERSION", "source", "label", "serial", "major", "action", "part", "sequence", "position", "status", "port", "server", "v", "index"], "url": ["path", "format", "title", "http", "URL", "id", "download", "address", "filename", "file", "l", "link", "str", "browser", "loc", "domain", "source", "label", "host", "uri", "pattern", "href", "Url", "resource", "print", "location", "base"], "texteErreur": ["texteErREult", "texteCorreur", "texteErreura", "texteStrreurs", "texteErrure", "texteErbreUR", "texteErruleurred", "texteCorreut", "texteCorreure", "texteErleure", "texteErrorbreuer", "texteErREut", "texteIrbreura", "texteStrreur", "texteIrreUR", "texteIrbreur", "texteErneurs", "texteErrerurred", "texteErreure", "texteErriul", "texteErleuer", "texteErbreur", "texteErseut", "texteIrreur", "texteErseure", "texteErseul", "texteIrreura", "texteErreut", "texteErREure", "texteCorseur", "texteErrerur", "texteErseur", "texteCorreult", "texteErneurred", "texteIrbreUR", "texteErriura", "texteErrUR", "texteErrorbreUR", "texteErrorreuer", "texteCorseut", "texteErrorreUR", "texteErruleur", "texteErneur", "texteErruleurs", "texteCorseult", "texteErrorreur", "texteErrerurs", "texteErruer", "texteErreurred", "texteErbreul", "texteErrorbreur", "texteErseult", "texteErreult", "texteErreUR", "texteStrneurred", "texteErreuer", "texteErrorreure", "texteErriUR", "texteErbreuer", "texteCorseure", "texteStrneurs", "texteErrorbreure", "texteErreurs", "texteErseura", "texteErREur", "texteErreul", "texteErrur", "texteErrult", "texteIrbreul", "texteErriur", "texteStrreurred", "texteErseUR", "texteErbreure", "texteErleur", "texteIrreul", "texteStrneur", "texteErrut", "texteErbreura", "texteErleUR"], "numErreur": ["numerReurs", "numErreiber", "numErbreiber", "numerreUR", "numErbreurs", "numErReurs", "numErr\u00e9urs", "numerreur", "numErbreur", "numErneur", "numErneau", "numErreUR", "numErr\u00e9UR", "numErbreUR", "numErReUR", "numerreiber", "numerReur", "numerreurs", "numErreau", "numErReau", "numErbreau", "numErr\u00e9iber", "numErneUR", "numErneurs", "numerReiber", "numErr\u00e9ur", "numerReUR", "numErReiber", "numErreurs", "numErReur"], "al": [" hal", "ad", " aval", " sal", " bal", "pal", "all", "tal", "sal", "wal", "ali", "alog", " recal", "bl", "l", "ial", "ale", "mal", "ap", "ar", " wal", "hal", "dal", "a", " bl", "stal", " tal", "af", "aval", "als", "el", " cal", "fal", "cal", "ald", "alist", " fal", "sel", "ral", "Al", " mal", "AL", "bal", "alon", "att", "atal", "alf"]}}
{"id1": "414258", "id2": "23452437", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 0, "substitutes": {"url": ["b", "ls", "external", "path", "dl", "http", "URL", "sql", "r", "address", "file", "config", "l", "ur", "gl", "string", "str", "link", "browser", "job", "cl", "web", "html", "nl", "key", "term", "loc", "domain", "page", "q", "uri", "pattern", "util", "char", "rl", "xml", "default", "el", "ref", "get", "log", "Url", "pl", "ld", "impl", "ssl", "resource", "location", "base", "bel", "name", "ll", "mount", "sl", "un"], "in": ["In", "read", "online", "check", "is", "init", "on", "out", "input", "rin", "al", "update", "f", "login", "ln", "IN", "ma", "inn", "reader", "m", "s", "l", "ai", "bin", "again", "include", "c", "vin", "ins", "n", "source", "from", "mc", "null", "en", "mi", "oin", "body", "din", "isin", "min", "nin", "cin", "serv", "con", "i", "gin", " din", "line", "inner", "o", "name"]}}
{"id1": "1357662", "id2": "5414088", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["CopFileFile", "CopDirectoryFile", "CopDirectoryFrom", "copyFileFrom", "copyfileTO", "copyDirectoryFrom", "CopFileFrom", "copyfileTo", "copyToFrom", "copyToFile", "copyFileFile", "copyToTo", "CopFileTO", "CopDirectoryTo", "copyDirectoryFile", "CopFileTo", "copyfileFile", "copyToTO", "copyDirectoryTo", "copyFileTO", "copyDirectoryTO", "copyfileFrom", "CopDirectoryTO"], "destination": ["dominator", "destification", " destinated", "domination", " destinator", "Destification", "descinated", "destinated", "Destinate", "delination", "catification", "restinated", "descification", " destinations", "estinations", "Destinated", "destinity", "descinate", "delification", "estination", "disturation", "distinity", "distination", "distification", "descination", "delinity", "restification", "catinated", "dominated", "destinator", "estinated", " desturation", "destinate", "deluration", "restination", " destinate", "estinator", "catinate", "destinations", "dominations", " destification", " destinity", "distinate", "distinated", "catination", "Destination", "restinate", "desturation"], "srcChannel": ["insChan", " srcchannel", "sysStream", " srcCase", "srcChan", "rcConnection", "srcCh", "srcStream", " srcStream", " srcChain", " srcChan", "sourceConnection", "sourceChan", "rcStream", "srcCase", "sourceChannel", "srcConnection", "srCase", "sourcechannel", "rcChan", "rcchannel", "sysChannel", "sysChan", "srChan", "srcchannel", " srcConnection", "sysConnection", "srChannel", "sinCase", "sinChannel", "insChain", "sinChain", "insChannel", "rcChain", "sourceCh", " srcCh", "srChain", "srcChain", "sinChan", "rcCh", "rcChannel", "insCh"], "destChannel": ["destCategory", "srcC", "destCh", "srcChan", "etcChannel", " destCan", "destC", "homeChan", "destchannel", " destConnection", "DestChan", " destchannel", " destChan", "DestCh", "etcConnection", "destCan", " destCh", "Destchannel", " destC", "srcConnection", "DestChannel", "DestCategory", "srcchannel", " destCategory", "homechannel", "certConnection", "destChan", "homeCategory", "homeChannel", "certCan", "etcChan", "certCh", "DestCan", "certChannel", "destConnection", "etcC", "DestConnection"]}}
{"id1": "5441579", "id2": "17111859", "code1": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 1, "substitutes": {"createPseudoUUID": ["createPseudoUId", "createPseudoUniqueId", "createPseanRandomuid", "createPseudoUniqueuid", "createPseudoUniqueID", "createPseanRandomID", "createPseudoRandomID", "createPseanUuid", "createPseanRandomId", "createPseudoUniqueUID", "createPseanUId", "createPseudoUID", "createPseudoRandomuid", "createPseudoUuid", "createPseanUID", "createPseudoRandomId", "createPseanUUID", "createPseanRandomUID", "createPseudoUUuid", "createPseudoRandomUID", "createPseudoUUUID", "createPseudoUUId"], "messageDigest": ["messageLocse", "messageHasist", "numberDigest", "messageLocifier", "messageMacest", " messageDigester", "messageDigse", "messageDesignester", " messageDigse", "messagedigifier", "numberDesignist", "messageDigment", "messageHasester", " messageDigment", "messagedigest", "messageHasest", "messageDester", "messageDest", " messageDigist", "messageLocest", "messagedigist", " messageDesignse", "messagedigse", "messageDesignest", "messagediger", "messageMacse", "messageDests", " messagedigment", "messageDriest", "messageMacested", "messageMacer", "numberDigests", "messageDigifier", " messageDesignist", "messageDesignse", "messageDigist", "numberDesignest", "messageDriester", " messageDesignester", "messagedigester", " messageDesignest", "messageDriist", " messageDigested", "messageDigester", "messageDesignist", " messagedigifier", "messageDist", "numberDesignester", " messagedigse", "messageDesignests", "messagedigment", " messageDiger", "messageDigests", "numberDigester", "messageDrise", "messageLocment", "numberDigist", " messageDigifier", "messageDiger", "messageHasests", " messagedigest", "messagedigested", "numberDesignests", "messageDigested"], "localHost": ["localPort", " localPort", "LocalPort", "Localhost", "remoteAddress", " localhost", "localhostPort", "remotePort", "LocalHost", "localhostHost", "LocalAddress", "remoteHost", "localServer", "remotehost", " localServer", "LocalServer", " localAddress", "localhostServer", "localhosthost", "localAddress", "localhost"], "digestBytes": ["mixestAttributes", "mixestedLinks", "diggestBytes", " digestedbytes", "diggestKeys", "drivenesterValues", " digestResults", "digistanceKeys", "digESTLinks", "digesterBytes", "diggeParts", "drivenesterParts", "digestKeys", "digesterBs", "drivenesterBs", "mixestLinks", "DigestServices", "digestedbytes", "digistanceExamples", "digestedArgs", " digestExamples", "mixestParts", "digestValues", "mixestedServices", "digestBs", "digstServices", "digestedAttributes", "diggestParts", "digESTArgs", "diggestServices", "digestExamples", "digestbytes", "digESTBytes", "digesterValues", "digestedLinks", "digesterResults", " digestbytes", " digestValues", "drivenesterBytes", "digstBytes", "mixestServices", "drivenestBs", "digestAttributes", "diggeBytes", "digetParts", "digestArgs", "drivenestValues", "digESTValues", " digestParts", "diggeServices", "digestedBs", " digestKeys", "digestServices", "digESTbytes", "mixestedAttributes", "digetBytes", " digestedBytes", "digestLinks", "digestedBytes", "DiggestBytes", "mixestedArgs", "diggestExamples", "Digestbytes", "digesterbytes", "digetServices", "mixestedBytes", "mixestBytes", "digesterParts", "diggeAttributes", "mixestedParts", "DiggestParts", " digestArgs", "digesterLinks", "drivenestParts", "DiggestServices", "mixestedbytes", "diggestbytes", "drivenestBytes", "digistanceBytes", "digestResults", "digstAttributes", "digestParts", " digestedValues", "Diggestbytes", "mixestArgs", "digestedValues", "mixestbytes", "digestedParts", "digestedResults", "digetbytes", "DigestParts", "digesterArgs", "DigestBytes", "digestedServices", "digstParts"], "sb": ["b", "rob", "bash", "storage", "sth", "src", "abb", "ib", "bp", "gb", "shell", "bf", "sv", "bis", "rb", "sbm", "bj", "obb", "SB", "bps", "cb", "sn", "tn", "bg", "erb", "lb", "gc", "ibl", "bs", "sh", "sam", "zb", "sp", "ub", "gob", "bh", "eb", "nb", "bn", "ctrl", "bb", "jp", "ssl", "sa", "sf", "fb", "esm", "bt", "sw", "kb", "wb", "stab", "pg", "sd", "lp", "db", "sg", "sl", "pb"]}}
{"id1": "7044153", "id2": "11562173", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendExceptionTOServer", "sendExceptiontoHost", "sendErrortoClient", "sendErrortoServer", "sendExceptionToHost", "sendErrorToClient", "sendExceptiontoServer", "sendErrorToServer", "sendErrorToHost", "sendExceptionTOHost", "sendExceptiontoClient", "sendExceptionTOClient", "sendExceptionToClient", "sendErrortoHost"], "server": ["value", "store", "Server", "ver", "address", "description", "ser", "env", "string", "client", "email", "test", "null", "host", "version", "password", "site", "port", "remote", "serv", "code", "v", "base", "erver", "channel", "service", "localhost"], "ex": ["obj", "aux", "EX", "Exception", "eas", "com", "or", "fail", "it", "err", "error", "any", "rx", "lex", "exe", "xc", "ix", "tx", "test", "exclusive", "x", "wx", "ext", "pex", "one", "ception", "exit", "exc", "expl", "Ex", "ic", "Exc", "el", "except", "nex", "exp", "hex", "none", "e", "ox", "re", "an", "event", "rex", "example", "ry"], "config": ["auth", "fig", "cert", "conf", "cache", "input", "context", "param", "debug", "rc", "Config", "env", "params", "c", "ct", "control", "settings", "password", "Configuration", "text", "form", "log", "figure", "content", "channel", "service", "cfg"], "prob": [" prbe", " prb", "prbe", "prb", " prbes", "Probes", "probes", "probe", "Probe", "probj", "prbes", "Prob", " prbj", "Probj", "prbj"], "dataSB": ["mapBS", "relationSN", "ataBB", "dataGB", "divSquare", "joinWB", "imageBP", " dataSW", "divNB", "relationSL", " datasb", "cacheBW", "relationBS", "reasonBS", " dataSF", "relationSquare", "dataBB", "listEB", "datasb", "jsonsb", "cacheSM", "joinSF", "listBB", "divSB", "listsb", "windowSN", "partialBB", "contentNB", " dataRB", "windowSB", "windowSF", "keyBB", "ataSB", "ataSA", "relationQB", " dataBB", "ataEB", "resourceSF", " dataHB", "ataSN", "ataSW", "imageSB", "relBB", " dataNB", "listSF", "valueSB", "reasonSW", "ataSF", "mapGB", " dataMB", "resourceSB", "contentSB", "keySB", "imageBS", "debugSF", "mapSL", "defSB", "ataSL", "dataNB", " dataSL", "debugBB", "partialSL", "cacheSA", "defQB", "reasonSB", "divBB", "partialGB", "dataBP", "mapSN", "contentSN", " dataBS", "windowBB", "ataBP", "keyBS", "debugSB", "jsonSw", "nextSF", "cacheBS", " dataSN", "dataQB", "imageSM", "joinMB", "cacheSF", "valueBB", "nextBB", "reasonSF", "imageQB", "dataMB", "imageSw", "dataSI", "mapSB", "nextGB", "contentSR", "DATASB", "nextSB", " dataBP", "windowBS", "ataMB", "debugRB", "dataSF", "cachesb", " dataGB", " dataSM", "dataWB", "divSN", "divSF", "dataEB", "dateSB", "windowSL", "dataSA", " dataBW", "defGB", "ataWB", "imageNB", "contentSF", "joinSB", "DATASF", " dataSquare", "imageSR", " dataSI", "contentBS", "mapBB", "ataSR", "imagesb", "dataSw", "relationMB", "dateQB", "nextBS", "dataRB", "dataBW", "imageBB", "mapSF", "listSB", " dataEB", "keySL", "imageSN", "relBS", "mapHB", "joinSL", "relationSB", "dataHB", "dateBu", "relSW", "valueSW", "imageHB", "dataSW", "ataBu", "datWB", "resourcesb", " dataSA", "dataSquare", "relationNB", "resourceSI", "listMB", "cacheBB", "cacheSB", "partialSB", "dataBu", "DATABS", "dataSN", "ataQB", "datSL", "valueBS", "dataSM", "jsonSB", "joinsb", "divBS", "dataBS", "dataSR", "divBW", "dataSL", "datMB", " dataSw", "relationBu", "jsonSF", "ataBS", "relSB", "relationSF", "datSB", "imageSF", "defBB", "atasb", "relationRB", "relationBB", "DATASW", "imageSL", " dataQB", "dateBS", "nextQB", "listSI", "ataNB"], "trace": ["tm", "message", "transform", "range", "th", "store", "thread", "ace", "address", "mt", "be", "list", "debug", "tile", "frame", "se", "network", "stable", "true", "test", "feature", "fake", "stream", "detail", "track", "batch", "dump", "tr", "sequence", "body", "style", "report", "te", "stack", "temp", "log", "race", "role", "buffer", "history", "chain", " Trace", "span", "create", "sample", "profile", "data", "tty", "comment", "time", "table"]}}
{"id1": "21754659", "id2": "411595", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getButtonSonilo", "getButtonLeonilo", "getbuttonSonida", "getButtonDonico", "getButtonLeonido", "getbuttonSonico", "getbuttonSonilo", "getButtonDonido", "getButtonSonida", "getButtonLeonico", "getButtonDonida", "getButtonLeonida", "getButtonSonico", "getbuttonSonido", "getButtonDonilo"], "buttonSonido": ["labelSONido", "ButtonSunao", "buttonSonito", "buttonSONico", "buttonSonidable", "secondSynito", "buttonsonano", "buttonJonida", "buttonBonido", "fieldsonano", "buttonHonilo", "fieldSonano", "keySonardo", "ButtonSonido", "buttonson\u00ed", "buttonBonardo", "buttonSONphp", "positionJonido", "buttonSon\u00ed", "buttonJonico", "keySonilo", "buttonsonido", "ButtonSonao", "keysonido", "buttonJonito", "buttonsonida", "buttonJonidable", "positionJonito", "buttonDenido", "buttonSonilo", "keysonilo", "buttonBoningo", "buttonSynphp", "buttonNorthingo", "secondSonicho", "fieldsoningo", "keysonardo", "buttonSunico", "positionJonico", "fieldSonida", "buttonJonicho", "buttonNorthido", "buttonJonphp", "keyson\u00ed", "positionSonilo", "fieldsonida", "buttonJonao", "buttonSONilo", "buttonSunito", "buttonBonano", "buttonBonao", "buttonSonida", "buttonSonila", "buttonSonano", "positionSonito", "buttonNorthida", "ButtonSonico", "fieldSonido", "positionSonico", "buttonSonao", "buttonSunilo", "fieldSoningo", "fieldsonido", "labelSonila", "buttonSonardo", "buttonsonilo", "labelSonido", "labelSONphp", "buttonHonido", "labelSonida", "buttonSONida", "buttonBon\u00ed", "positionJonilo", "buttonSynido", "secondSynido", "buttonSONido", "buttonSunao", "buttonJonido", "labelSONila", "buttonJonata", "buttonJonilo", "buttonSoningo", "secondSynidable", "buttonHonardo", "buttonBonida", "keySonido", "buttonJonila", "labelSONida", "buttonNorthano", "positionSonido", "buttonSONito", "buttonBonata", "keySon\u00ed", "buttonSynidable", "buttonSunido", "secondSonido", "buttonBonilo", "buttonsonardo", "buttonSonata", "secondSonito", "buttonSonphp", "buttonSynito", "buttonSunata", "secondSynicho", "buttonsoningo", "ButtonSunata", "buttonSynida", "buttonSONila", "secondSonidable", "buttonHon\u00ed", "buttonBonico", "buttonSynila", "buttonSonicho", "buttonDenidable", "buttonDenicho", "labelSonphp", "buttonDenito", "buttonSynicho", "ButtonSonata", "ButtonSunido", "ButtonSunico", "buttonSonico"], "e": ["ing", " ie", "ee", " ke", "t", " ve", "ae", " ate", "AE", "a", "pe", " sent", "act", " fe", "ed", "er", "E", "te", "ED", "ie", "ese", " ge", "me", "event", " pe", " who", "ev", "es"], "fc": ["WC", "tc", "fs", "f", "fd", "fp", "bf", "tf", "pc", "bc", "mac", "irc", "isc", "rc", "fl", "cc", "etc", "c", "dc", "fn", "inc", "mc", "cv", "gc", "ic", "icc", "coll", "ifa", "rl", "fi", "nc", "lf", "soc", "fab", "conv", "uc", "vc", "ec", "ctrl", "con", "fm", "fb", "fa", "cf", "RFC", "anc", "FC", "lc", "abc"], "returnVal": ["resultval", "returnValue", "resultVal", " returnval", "ReturnValue", "Returnval", "retValue", "retVAL", "returnVAL", " returnValue", " returnVAL", "resultValue", "returnval", "retVal", "retval", "ReturnVal", "ReturnVAL", "resultVAL"], "file": ["message", "path", "user", "block", "files", "format", "full", "template", "http", "time", "input", "url", "info", "type", "f", "output", "fp", "dir", "stat", "link", "image", "word", "this", "source", "page", "null", "single", "uri", "fe", "ile", "to", "handle", "tree", "io", "document", "valid", "spec", "show", "form", "FILE", "get", "parent", "disk", "buffer", "resource", "base", "create", "data", "name", "channel", "File", "local", "table"], "rutaGlobal": ["rutiRemote", "rutanGlobal", "redutaLocal", "redutanDefault", "RutaLocal", "rutaRemote", "rutaGeneral", "redutaGeneral", "rontoDefault", "RutaRemote", "redutanGeneral", "rutiFile", "rutoStatic", "rutiglobal", "rutoGlobal", "rutiGlobal", "rutaLocal", "rutaFile", "rutenLocal", "redutanLocal", "RutoStatic", "rutenRemote", "RutoFile", "rutoglobal", "rutaglobal", "redutaDefault", "rutanLocal", "Rutoglobal", "rutanGeneral", "rutoFile", "RutoRemote", "rutanDefault", "Rutaglobal", "rontoGlobal", "rutiGeneral", "rontoGeneral", "RutaGlobal", "rutenGlobal", "rutaStatic", "rutenFile", "RutoLocal", "redutaGlobal", "rutoRemote", "rutoLocal", "RutaStatic", "RutaFile", "rontoLocal", "redutanGlobal", "rutiLocal", "RutoGlobal", "rutiStatic", "rutenStatic", "rutenglobal", "rutaDefault", "rutiDefault"], "rutaRelativa": ["rutaRELativ", "rutaRelantiv", "rutaRelATiv", "rutaRELitivas", "rutaRelATivas", "rutaRelATiva", "rutaRelatiivas", "rutaRELitiva", "rutaRELitiv", "rutaRELATiv", "rutaRelantivo", "rutaRELATivo", "rutaRelatiiva", "rutaRELativas", "rutaRelativo", "rutaRelitivo", "rutaRelativas", "rutaRelantivas", "rutaRelATivo", "rutaRELATivas", "rutaRELitivo", "rutaRelitiva", "rutaRelantiva", "rutaRelatiiv", "rutaRELativa", "rutaRelativ", "rutaRelitivas", "rutaRELATiva", "rutaRelitiv", "rutaRELativo", "rutaRelatiivo"], "fis": ["flos", "fois", "vis", "dfis", " f\u00eds", " fisc", " fys", "dfais", "dfois", "dfisa", "fisc", "flisc", " fois", "lf\u00eds", "lfiss", "fiss", "f\u00eds", "risc", "ris", "fais", " fais", "fisa", "dfiss", "lfis", "rys", "viss", "lfisa", "vais", "df\u00eds", " fiss", "vois", "flys", "ros", "fys", "flis", " fisa"], "fos": ["ioss", "waos", "mos", " foes", "fios", "moes", "wios", "fdoes", "foses", " fops", "foss", "fops", " fows", "fdoss", "hos", "fdaos", "hoss", " foss", "wos", "mows", "woes", "ioses", "foes", "woss", "faos", "iios", "ios", "hoses", "vows", "vos", "mops", "vops", "woses", "voes", "fows", "fdos", " faos", "hios"], "canalFuente": ["canalFaente", "canelFuent", "canalPotmelon", "canalFUent", "canalFuper", "canalfuestro", "canalFramelon", "canalFaante", "canelFaelia", "canallfuent", "canelFuante", "canalFicer", "canallfuencia", "canalFUante", "canalFaestro", "canalfuent", "canalFuestro", "canalFient", "canalfumelon", "canallFuper", "canalFraper", "canallFuencia", "canalFaent", "canalFaelia", "canallFumelon", "canalFucer", "canalfuelia", "canalFuante", "canelFuelia", "canelFaent", "canallFuestro", "canelFuente", "canalfuper", "canalFUente", "canalFumelon", "canelFaente", "canalFuencia", "canalfuante", "canalFiente", "canalPotente", "canalFUelia", "canelFaante", "canallfucer", "canalFuelia", "canalfuente", "canalFacer", "canalPotper", "canallfumelon", "canalFuent", "canallfuente", "canalFiestro", "canallFuente", "canallFuent", "canallfuestro", "canalPotencia", "canalFraente", "canallfuper", "canalFraencia", "canalfucer", "canallFucer", "canalfuencia"], "canalDestino": ["canaldOrigina", "canalDescina", "canalDescino", "canalOrigination", "canalOrigine", "canalsdestina", "canalDestina", "canalDestination", "canaldestinian", "canalsdestinian", "canalsDestino", "canalOrigina", "canaldDestination", "canalDestine", "canalsDestination", "canaldOrigine", "canalDescine", "canaldOrigino", "canalsdestination", "canalNegination", "canalNeginian", "canaldDestino", "canalNegino", "canalDestinian", "canalOrigino", "canalNegina", "canaldestino", "canaldestination", "canaldDestine", "canalsDestina", "canaldestina", "canalsDestinian", "canalDescination", "canaldDestina", "canaldOrigination", "canalsdestino"]}}
{"id1": "2982747", "id2": "18631594", "code1": "    public FileParse(String fileStr, String type) throws MalformedURLException, IOException {\n        this.inFile = fileStr;\n        this.type = type;\n        System.out.println(\"File str \" + fileStr);\n        if (fileStr.indexOf(\"http://\") == 0) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"File\")) {\n            File inFile = new File(fileStr);\n            size = inFile.length();\n            inStream = new FileInputStream(inFile);\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URL\")) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URLZip\")) {\n            URL url = new URL(fileStr);\n            inStream = new GZIPInputStream(url.openStream(), 16384);\n            InputStreamReader zis = new InputStreamReader(inStream);\n            bufReader = new BufferedReader(zis, 16384);\n        } else {\n            System.out.println(\"Unknown FileParse inType \" + type);\n        }\n    }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 0, "substitutes": {"fileStr": ["FILEstr", "valueSTR", "fromString", "FILEStr", "FileSt", "FILEString", "ileSyn", " fileSTR", "filePar", "FileString", "ilePar", "ileSt", "ileName", "fileRest", "FileSyn", "stringStr", "fileSt", "ileStr", "placeString", "valueString", "fileSyn", "FileStr", "FILESTR", "whereStr", "fromstr", "ileSTR", "FilePar", "whereSTR", "channelSTR", "FileName", "placeSt", "channelStr", "stringString", "whereString", " fileName", "fileSTR", "placestr", "wherePar", "ileRest", "stringSTR", "fileString", " fileSt", "ilestr", "channelString", " fileString", "ileString", "valueName", "placeStr", "FileSTR", "filestr", "FILESt", "fileName", "channelSt", "stringSyn", " fileRest", "fromStr", "fromSTR", "valueStr", "FileRest", "Filestr"], "type": ["user", "range", "template", "format", "value", "title", "function", "where", "out", "id", "ver", "info", "time", "class", "error", "file", "description", "core", "instance", "t", "pretty", "what", "client", "test", "ype", "ty", "rule", "types", "key", "family", "source", "scope", "right", "p", "pe", "unit", "ping", "Type", "version", "token", "state", "typ", "y", "sequence", "length", "style", "port", "parent", "shape", "role", "kind", "buffer", "total", "module", "code", "model", "o", "create", "other", "TYPE", "name", "phrase", "tag", "rel", "index", "comment", "relation"], "inFile": ["InFile", "inputFilename", " inString", "cinUser", " inResource", "outString", "cinStream", " INStream", "inifile", "inputString", "inPath", "intResource", " INLe", "infile", " inFormat", " inFilename", "inString", "outFile", "intfile", " inputStream", "iniFile", "inSet", "cinFile", " infile", "Infile", "InStream", "intSet", " inLe", " inputLe", " inPath", "iniResource", " INFormat", "iniSet", " inUser", " inSet", "outFilename", "InUser", "intFile", "cinfile", "inLe", "inFormat", "inUser", "inputFile", " inputFile", " INFile", "inFilename", "inputPath", "inResource", "outPath", " inputFormat"], "url": ["ls", "external", "dl", "cert", "net", "http", "URL", "lr", "open", "pkg", "norm", "help", "l", "ur", "gl", "link", "back", "str", "browser", "job", "client", "cl", "web", "org", "nl", "term", "run", "null", "hl", "host", "mount", "uri", "cmd", "addr", "char", "rl", "el", "bool", "cal", "ol", "ref", "kl", "impl", "mail", "Url", "log", "build", "conn", "deb", "mb", "ssl", "ml", "ctrl", "ul", "bel", "rel", "ll", "name", "db", "call"], "urlconn": ["belconf", "belconn", "URLconnection", "sslconnection", "Urlconn", "URLConn", " urlcomm", "belll", "implConn", "urlConn", "sslconn", "urljp", "UrlConn", "urlopen", "webcon", "impldb", "webconnection", "consolecomm", "urlcon", "urlcomm", "Urlcon", "impljp", "urlll", "sslConn", " urljp", "URLconn", "httpjp", "urldb", "Urlconnection", " urlconf", "webConn", "consoleconn", "webconn", " urldb", " urlll", "Urlopen", "implconn", "urlconnection", "consolell", "httpConn", "belcomm", "consoleconf", "httpconn", " urlConn", "httpdb", "URLopen", "sslopen", "URLcon", "urlconf"], "inStream": ["innView", "InFile", "innStream", "rinStream", "inputSt", "iStream", "iSteam", "inView", "indSet", "inputSet", "cinStream", "INView", "rinSt", "dinStream", "INSteam", "inSt", "innSt", "cinView", "InView", "inputStream", "inFrame", "actSteam", "scanView", "inList", "indStream", "inSteam", "indSteam", " inFrame", "innFile", "cinSet", "InSteam", "scanSteam", "instream", " instream", "istream", "inSet", "cinFile", "innSet", "actSet", "iSt", " inSteam", "InStream", " inList", " inSt", "actStream", "cinSteam", "innFrame", "scanFile", "dinFile", "rinSteam", "innList", "INStream", "cinFrame", "indView", "rinList", "scanStream", " inSet", "dinView", "INSet", "inputView", "inputSteam", "innSteam", "inputstream", " inView", "actView", "dinSteam"], "bufReader": ["buffLoader", "errHelper", "bufWriter", "errWriter", "funcDr", "matReader", "ufHelper", " bufDr", "buffDriver", "buffDr", "funcLoader", " bufHelper", "bufferWriter", "errReader", " bufDriver", "ufWriter", "ufStreamer", "funcReader", "errLoader", "funcDriver", "buffReader", "buffStreamer", "buffWriter", "buffRead", "ufReader", "ufLoader", "bufRead", "bufStreamer", "bufDriver", "matWriter", "ufRead", "bufDr", "matStreamer", "bufHelper", "buffBuilder", "ufBuilder", "bufferRead", " bufLoader", "bufBuilder", "bufLoader", " bufWriter", "matBuilder", "bufferReader", "bufferLoader"], "size": ["read", "bytes", "empty", "SIZE", "offset", "small", "space", "fd", "ize", "count", "pos", "sn", "nl", "c", "n", "len", "height", "Size", "length", "set", "shape", "buffer", "max", "sum", "start", "data", "name", "gz"], "zis": [" zisc", "ziisl", "zeris", "zisl", " zisi", "zipisc", "jisl", "gzis", "ziis", "jIS", "zerisl", "ziIS", "jis", "zipis", "zipisi", "zisc", "zeriss", "zerIS", "ziiss", "zisi", "zIS", "jiss", "gzisi", "ziss", "gzisc"]}}
{"id1": "11716816", "id2": "17296916", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "label": 1, "substitutes": {"updateFile": ["UpdateSourceFile", "downloadContent", "archiveContent", "updateContent", "UpdateContent", "archivePage", "downloadPage", "updateSourceFile", "updatePage", "UpdatePage", "downloadFile", "archiveSourceFile", "UpdateFile", "downloadSourceFile", "archiveFile"], "file": ["message", "path", "issue", "full", "format", "title", "input", "url", "type", "info", "f", "filename", "output", "fp", "use", "t", "link", "entry", "rule", "image", "page", "source", "null", "le", "p", "h", "ile", "handle", "io", "document", "attribute", "report", "port", "FILE", "e", "log", "get", "line", "resource", "content", "base", "data", "name", "db", "channel", "File", "local", "table"], "IOException": ["IOError", "OperationException", "SecurityError", " IOError", "SecurityException", "OperationProblem", "SecurityProblem", "IOProblem", "OperationError", " IOProblem"], "destFile": ["DestPage", "destSourceFile", "DestFile", "tempfile", " destinationDo", " DestFile", "declFolder", " DestDir", "Destile", "destPage", " destPath", "declFile", "DestSourceFile", "declile", " destinationEmail", "destPath", "targetFile", "sourceFolder", " destPlace", "destfile", "targetDir", "targetFolder", " destfile", "optPlace", " destDo", "optPage", " destFolder", "sourceFile", "sourceDir", " destinationDir", "DestFolder", "DestPath", "Destfile", " destSourceFile", " destPage", "tempFile", " destile", " destEmail", "optFolder", " destDir", "tempDir", "DestDir", "targetPath", "tempPath", "declSourceFile", " DestDo", "destFolder", "destDir", "destPlace", " destinationFile", "optFile", "destEmail", "sourcePath", "DestPlace", "destDo", "destile", " DestEmail"], "in": ["In", "read", "iter", "is", "init", "sin", "net", "on", "input", "rin", "it", "al", "all", "r", "f", "pass", "info", "m", "ain", "IN", "ln", "inn", "s", "l", "inside", "inf", "bin", "ai", " IN", "ins", "n", "from", "inc", "en", "mi", "ic", "act", "up", "io", "ne", "ind", "oin", "edIn", "im", "din", "mm", "isin", "ie", "re", "cin", "con", "i", "gin", " din", "raw", "inner", "local", "ini"], "out": ["b", "obj", "ex", "at", "or", "net", "OUT", "note", "ou", "cache", "it", "write", "output", "oe", "nt", "ion", "t", "s", "cos", "oss", "client", "again", "gt", "Out", "n", "one", "null", "fn", "os", "en", " OUT", "cn", "cmd", "to", "flush", "up", "io", "ne", "sys", "outs", "result", "msg", "ch", "conv", "OU", "g", "no", "log", "con", "conn", "jp", "chain", "co", "v", "aos", "o", "outer", "can", "ot", "channel"]}}
{"id1": "14303294", "id2": "8064604", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getserverMac", "getClientPassword", "toClientSalt", "getClientSalt", "getUserPassword", "toServerMac", "getClientMac", "toServerPassword", "toClientPassword", "getUserSalt", "getServerSalt", "getServerPassword", "toServerHash", "getUserMac", "toClientMac", "getUserHash", "getserverPassword", "toServerSalt", "getServerMac", "getserverHash", "toClientHash", "getClientHash", "getserverSalt"], "passwordHash": ["emailSalt", "serverSalt", "emailHTML", "swordHTML", " passwordKey", "PasswordHTML", "serverPassword", "serverHash", "PasswordHas", " passwordPassword", "PasswordKey", "swordHas", "passwordKey", "emailHas", "emailHash", "serverKey", "swordSalt", "swordHash", "passwordSalt", "PasswordHash", "passwordHTML", "PasswordPassword", "passwordPassword", " passwordSalt", "passwordHas"], "PasswordSalt": [" passwordPassword", "UserToken", " PasswordToken", "passwordToken", "PasswordSecret", " passwordToken", "UserSalt", " PasswordPassword", "passwordSalt", "passwordSecret", "PasswordHash", "UserHash", " PasswordSecret", "PasswordToken", "passwordPassword", "PasswordPassword", " passwordSalt", " PasswordHash", "UserSecret"], "hash": ["message", "match", "block", "transform", "value", "cache", "shift", "component", "search", "address", "map", "ash", "echo", "mac", "test", "html", "key", "score", "word", "row", "mask", "serial", "h", "handle", "char", "index", "copy", "password", "sh", "result", "height", "json", "sha", "report", "hex", "build", "log", "crypt", "Hash", "dig", "total", "sum", "print", "sample", "response", "tag", "filter"], "digest": ["decest", "dest", "mdEST", "Digester", " digEST", "digEST", "digester", "dested", "descest", "hashested", " digse", "displayested", "diggest", "mdester", "displayest", "digested", "mdest", "Digest", "descester", "dester", "Digse", "decse", "Diggest", "displaygest", "hashester", "displayester", "descse", "decester", "dEST", "decested", "DigEST", "Digested", "descested", "hashgest", "mdested", " digester", "digse", "hashest", " digested"]}}
{"id1": "9727056", "id2": "17557289", "code1": "    @Override\n    public OBJModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        OBJModel model = loadModel(url.openStream(), skin);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 0, "substitutes": {"loadModel": [" loadEL", "LoadModule", "openModule", "parseModule", "openModel", "readData", " loadFile", "LoadEL", "getModel", "readModule", "LoadFile", "parseJSON", "readJSON", " loadModule", "loadData", "getJSON", "getModule", "parseModel", "LoadModel", "openFile", "loadModule", "loadJSON", "getData", "readModel", "loadFile", "parseData", "openEL", "loadEL"], "url": ["b", "ls", "mol", "path", "rect", "dl", "http", "URL", "id", "address", "file", "config", "abs", "l", "ur", "link", "string", "str", "browser", "gl", "job", "cl", "web", "html", "nl", "loc", "page", "q", "host", "mount", "uri", "util", "document", "el", "ref", "impl", "log", "Url", "mail", "build", "ssl", "resource", "location", "base", "rel", "ll", "name", "pl", "sl"], "skin": ["template", "format", "Skin", "sheet", "thin", "type", "species", "config", "plugin", "starter", "string", "bin", "kit", "knit", "source", "fit", "scope", "gender", "sid", "png", "version", "lang", "site", "spec", "tin", "kin", "socket", "style", "side", "silver", "suit", "license", "spin", "sis", "kind", "span", "name", "theme"], "ParsingErrorException": ["ParsingFormatExit", "ParsesFormatError", "ParsingFormatException", "ParsesErrorException", "ParsingErrorEx", "ParsesFormatEx", "ParsingInputError", "ParsingConfigError", "ParsesErrorExit", "ParsesErrorError", "ParsingInputEx", "ParsingFormatError", "ParsingFormatEx", "ParsesFormatExit", "ParsingConfigException", "ParsesErrorEx", "ParsingInputExit", "ParsingConfigExit", "ParsingInputException", "ParsingConfigEx", "ParsesFormatException", "ParsingErrorExit", "ParsingErrorError"], "baseURLWasNull": ["baseURLWerenull", "baseURLWasnull", "baseURLwasMissing", "baseUrlwasFound", "baseURLWereNULL", "baseUrlWasNull", "baseUrlwasNULL", "baseURLWereMissing", "baseURLEvernull", "baseURLwasNull", "baseUrlWasMissing", "baseURLWasNULL", "baseURLWasFound", "baseURLwasFound", "baseURLWasMissing", "baseURLHadNull", "baseUrlwasNull", "baseURLHadFound", "baseURLHadMissing", "baseURLWereNull", "baseUrlWasNULL", "baseURLEverNull", "baseUrlwasnull", "baseURLWereFound", "baseUrlwasMissing", "baseUrlWasnull", "baseURLHadNULL", "baseURLwasnull", "baseUrlWasFound", "baseURLEverNULL", "baseURLwasNULL"], "model": ["models", "obj", "message", "transform", "my", "human", "morph", "m", "instance", "map", "link", "cell", "jo", "job", "row", "fit", "serial", "object", "mi", "successful", "mor", "batch", "tree", "xml", "document", "result", "el", "mod", "json", "view", "body", "report", "Model", "sim", "entity", "me", "buffer", "module", "resource", "base", "sample", "data", "ll"]}}
{"id1": "7169984", "id2": "17996547", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 0, "substitutes": {"connRemote": [" validateBase", " communicateBase", " validateAsync", " connLocal", " authLocal", " communicateRemote", " authRemote", " communicateAsync", " authBase", " validateRemote", " validateLocal", " authAsync", " communicateLocal", " connBase", " connAsync"], "jsonObject": ["jsobject", "JSONObj", "jsonArray", "jsonobject", "JSONAst", "xmlAst", "JSONobject", "jsObj", " jsonElement", "jsonElement", "jsArray", "JSONElement", " jsonObj", " jsonAst", "xmlElement", "jsonObj", " jsonArray", " jsonobject", "JSONArray", "JSONObject", "jsonAst", "xmlObj", "jsObject", "xmlObject"], "OPCode": [" OpCause", " OpType", "OPCause", "OpCause", "OpCode", "OPType", " OPName", "OPcode", "opData", " OPType", " OpName", "OPData", " OPCause", "opCode", "OpType", "OPName", " OPData", "opcode", "Opcode", "OpData", " OPcode", " OpCode", "OpName", "opType"], "retSrc": [" retSRC", "retSetcr", "retStrsrc", "retInsRC", "RetStrsrc", "returnSrc", "retAsRC", "retSetsrc", "returnSetRC", " retInssrc", "retInsrs", "retRsource", " retSource", "RetSRC", "retSRC", " retInsource", "returnSetcr", "retNrc", "retSrs", "retSetRC", "RetStrrc", " retInsrc", "retAsrs", "retStrRC", "returnSRC", "retNRC", "retNsrc", "RetStrRC", "retInssrc", " retSsrc", "returnSetsrc", "retStrrc", "retInscr", "retStrrs", "retInsource", "retInsrc", "retSetrc", "retRsRC", "RetSsrc", "retSsrc", "returnSetrc", "retAsrc", "RetStrrs", "returnSsrc", "retRssrc", "retAssrc", "retStrource", "returnScr", "RetSrs", "retRsrc", " retInsRC", "retScr", "RetSrc", "retSource", "retNcr"], "httpClient": ["upperNet", "HttpSystem", "upperCo", " httpCo", "ttpClient", "healthClient", "healthGe", "healthNet", "httpCo", " httpGe", "httpStore", "httpNet", " httpStore", "httpSystem", "httpGe", " httpNet", "ttpConnect", "HttpClient", " httpSystem", "upperGe", "ttpStore", "upperClient", "HttpConnect", "healthCo", "ttpSystem", "HttpStore", "httpConnect", " httpConnect"], "httpPost": ["httpsPOST", "hoverPOST", "hoverPre", " httpPress", "ttpPut", "hoverpost", "HTTPPOST", "ttpPOST", "HTTPpost", "httpPre", "healthPOST", "healthPost", "HTTPPut", "httpPut", "hPOST", "hPost", "httpsPost", "httpPOST", " httpPOST", "healthPress", "ttppost", " httpPut", "hoverPost", "httpPress", "ttpPre", " httppost", " httpPre", "ttpPost", "HTTPPost", "hpost", "httpsPress", "httppost"], "httpParams": ["httpSharants", "ttpParams", "httpPps", "httpPgs", "httpParms", "ttpPrps", "ttpParars", "httpPrants", "httpParars", " httpPams", "httpPrps", "ttpParms", "ttpPrars", " httpPants", "ttpPrms", " httpPgs", "httpSharams", "httpPrgs", "httpparps", "httpparars", "httpPants", "httpparms", "ttpPrams", "httpShargs", " httpPargs", "httpParps", "httpPrams", "httpSharms", "httpPms", " httpParants", "httpPrars", "ttpParps", "httpPars", "httpPargs", " httpParms", "httpPams", "httpparams", "httpParants", "httpPrms", " httpPms"], "nameValuePair": ["nameValueChpair", "nameValueppair", "nameNameParatch", "nameValueChairs", "nameValuesPiece", "nameValuesPair", "nameKeyParpair", "nameKeyPareter", "nameValuesppair", "nameValueChair", "nameValuepiece", "nameValuePatch", "nameValuePeter", "nameValuepair", "nameValueParairs", "nameValueParpair", "nameKeyParair", "nameValuePersairs", "nameValuePointpair", "nameKeyPairs", "nameValuePareter", "nameKeyParairs", "nameKeyPeter", "nameValuespair", "nameNamePatch", "nameValuesPpair", "nameValuePartpair", "nameValuespiece", "nameValuePiece", "nameValuePointairs", "nameValuePointiece", "nameValuespairs", "nameValuePariece", "nameValuepatch", "nameValuepairs", "nameValueParatch", "nameKeyPair", "nameNamePpair", "nameNameParpair", "nameValueParair", "nameValuePartair", "nameValuePersair", "nameValuePointair", "nameKeyPpair", "nameNamePair", "nameValuesPairs", "nameValuepeter", "nameValuePpair", "nameNameParair", "nameValuePerspair", "nameValuePairs", "nameValuePerseter", "nameValuePartatch"], "response": ["reply", "message", "block", "cache", "application", "output", "description", "request", "frame", "network", "trace", "answer", "entry", "onse", "image", "next", "given", "still", "object", " responding", "resp", "social", "tree", "xml", "document", "result", "command", "json", "sequence", "respond", "body", "view", "report", "e", "entity", "connection", "res", "Response", "data", "relation", "service"]}}
{"id1": "22503685", "id2": "2465747", "code1": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 1, "substitutes": {"readGeoParserResult": ["readGeoHandlerResults", "readGeoReaderResults", "readGeaParserRecord", "readGeoHandlerResult", "readGeaParserResult", "readGeoHandlerRecord", "readGeaReaderResponse", "readGeaReaderResults", "readGeoReaderResult", "readGeaReaderRecord", "readGeoParserRecord", "readGeaParserResponse", "readGeoReaderRecord", "readGeoReaderResponse", "readGeaParserResults", "readGeoarserResponse", "readGeoParserResponse", "readGeoHandlerResponse", "readGeaReaderResult", "readGeoParserResults", "readGeoarserResults", "readGeoarserRecord", "readGeoarserResult"], "recordContent": ["recordString", "RecordString", "recContents", "RecordData", "RecordContent", "resourceContent", "resourceText", "RecordContents", "RecordName", "recordContents", " recordText", "recordText", "RecordText", " recordContents", " recordString", "recText", " recordName", "resourceString", " recordData", "recData", "recContent", "resourceName", "recordData", "recordName"], "getGazeteerIds": ["getGazeteerByIders", "getGazeteerCountls", "getGazeteerLoges", "getGazeteerInts", "getGazeteerCounts", "getGazeteerNeedls", "getGazeteersByIders", "getGazeteerByIdids", "getGazeteerNeedl", "getGazeteerIntids", "getGazeteerNeeds", "getGazeteerCountes", "getGazeteersIdl", "getGazeteersByIdids", "getGazeteersIdls", "getGazeteerIdls", "getGazeteerByIdls", "getGazeteersIdes", "getGazeteersByIdl", "getGazeteerByIdl", "getGazeteersByIds", "getGazeteerLogers", "getGazeteerIders", "getGazeteersByIdes", "getGazeteersIders", "getGazeteerIdes", "getGazeteerByIdes", "getGazeteerIntes", "getGazeteerIdl", "getGazeteerLogs", "getGazeteerLogids", "getGazeteerInters", "getGazeteerCountl", "getGazeteersByIdls", "getGazeteersIdids", "getGazeteersIds", "getGazeteerNeedes", "getGazeteerByIds", "getGazeteerIdids"], "ret": ["cert", "net", "ts", "out", "uf", "ft", "r", "usr", "mt", "red", "tmp", "nt", "reg", "rm", "t", "rt", "repl", "Return", "gt", "test", "rg", "arg", "rets", "continue", "ext", "ar", "RET", "alt", "txt", "Ret", "gc", "def", "arr", "opt", "tr", "result", "set", "ref", "get", "re", "mb", "buf", "cont", "print", "et", "res", "cur", "mem", "ry", "ll", "lit", "att", "reset", "ert"], "retries": [" retriers", "trying", "altries", "interrying", "ties", " retrys", "interries", " retrying", "retrying", "interrys", "retrys", "attrys", "attrying", "altrys", "attriers", "retriers", "trys", "triers", "tries", "alties", "interies", "reties", "attries", "altrying"], "reqPre": ["questpre", " reqpre", "reqPost", "requestPre", " reqPost", "RequestPre", "reqpre", " reqPRE", "requestPRE", "RequestPost", "requestpre", "RequestPRE", "requestPost", "questPRE", "Requestpre", "reqPRE", "questPre"], "outputFormat": ["outputForm", "inputformat", " outputformat", "OutputFormat", " outputForm", " outputType", "Outputformat", "inputForm", "inputType", "inputFormat", "outputType", "OutputForm", "OutputType", "outputformat"], "doc": ["ad", "dr", "parse", "DOC", "ds", "Doc", "Document", "comm", "du", "m", "file", "dir", "norm", "mk", "md", "str", "tx", "org", "html", "dc", "window", "py", "h", "def", "pub", "good", "unit", "dict", "tree", "xml", "document", "div", "msg", "json", "cam", "desc", "body", "exp", "dec", "form", "js", "ml", "date", "content", "man", "res", "data", "db", "di"], "url": ["ls", "dl", "cert", "http", "URL", "r", "address", "api", "file", "l", "ur", "link", "str", "https", "au", "parser", "loader", "web", "org", "nl", "loc", "hl", "uri", "addr", "char", "rl", "xml", "el", "socket", "ref", "Url", "conn", "ssl", "resource", "ul", "bel", "base", "ll", "hub", "sl"], "reader": ["read", "driver", "Reader", " readers", " Reader", " data", " resource", "input", "r", " writer", "file", " scanner", "parser", "loader", "builder", "stream", " read", " loader", " parser", "er", "handler", " r", "writer", "buffer", "resource", "data"]}}
{"id1": "15051083", "id2": "1235538", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getContentdigests", "getContentDigest", "getContentDigested", "getMessagedigse", "getContentdigested", "getContentDigse", "getMessagedigested", "getContentDigests", "getMessageDigse", "getMessagedigest", "getMessageTimested", "getMessageDigests", "getMessagedigests", "getMessageTimests", "getMessageDigested", "getContentdigest", "getMessageTimest", "getMessageTimse", "getContentdigse"], "digest": ["dest", " digestest", "driverested", "Digester", "drivergest", "Digast", " Digest", "digester", "mdse", "modester", "dested", " Digend", " digast", "dependested", "dependest", "hashested", " diggest", " digse", " Digested", "diggest", "mdester", "digend", "driverest", "signest", "dend", " Digester", "digested", "mdest", "dependester", "Digest", "dester", "Digse", "Diggest", "hashester", "signgest", "digast", "modest", "signested", "modested", " digestested", " digestester", "Digested", "mdested", "dependast", "signester", "Digend", " digester", "digse", "hashgest", "hashest", " digested", "driverester"], "node": ["Node", "note", "nn", "query", "yn", "binary", "open", "common", "network", "link", "cell", "job", "root", "system", "entry", "peer", "run", "n", "one", "source", "missing", "host", "object", "dependent", "normal", "tree", "ne", "document", "attribute", "element", "post", "remote", "process", "role", "resource", "inner", "create", "name", "angular", "child"], "external": ["obj", "ex", "extra", "multiple", "note", "outside", "binary", "optional", "any", "express", "reference", "common", "https", " External", "self", "ext", "n", "this", "object", "exit", "secondary", "global", "ternal", "unique", "External", "foreign", "intern", "remote", "get", "custom", "internal", "export", "escape", "tern", "name", "complete", "local", "qualified", "ns", "child"], "messageDigest": ["messageGuested", "essageDatese", "essageDateest", "essageDateesting", " messageDigested", "messageGuest", "messageDesignse", "messageGuhest", "MessageDigest", "essageDigse", "messageDigse", "MessageDighest", "messagedigse", "messageGuEST", " messageDigse", "messagedighest", "essageDigest", "messageDesignEST", "messageMixest", " messageDigEST", "MessageDigested", "messageDighest", "messageDesignest", "messageDateest", "Messagedigested", "messageDigesting", "messagedigesting", "messageDigEST", "messageDateesting", "messagedigest", "Messagedighest", "Messagedigest", "messagedigEST", "messageMixesting", "MessageDigEST", "messageDesignested", "messageMixse", "messageDatese", "messagedigested", "essageDigesting", "MessagedigEST", "messageDigested"]}}
{"id1": "13783898", "id2": "19784131", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static String getMD5Hash(String original) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            StringReader sr = null;\n            int crypt_byte = 0;\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(original.getBytes());\n            byte[] digest = md.digest();\n            sr = new StringReader(new String(digest, \"ISO8859_1\"));\n            while ((crypt_byte = sr.read()) != -1) {\n                String hexString = Integer.toHexString(crypt_byte);\n                if (crypt_byte < 16) {\n                    hexString = \"0\" + hexString;\n                }\n                sb.append(hexString);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n        } catch (IOException ioe) {\n        }\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeStringToFile", "encodeFileToFiles", "encodeStringAsDisk", "encodeFileFromStream", "encodeFileFromDisk", "encodeStringAsFile", "encodeFileAsFiles", "encodeFiletoFile", "encodeFiletoFiles", "encodeStringToStream", "encodeFileAsFile", "encodeFileAsDisk", "encodeFileAsStream", "encodeFileFromFile", "encodeStringAsStream", "encodeStringToDisk", "encodeFiletoDisk", "encodeFiletoStream", "encodeStringToFiles", "encodeFileToStream", "encodeStringAsFiles", "encodeFileToDisk"], "infile": ["InFile", "inputfile", "outbase", "inbase", " inFile", "inFile", "outpath", "Inbase", "outFile", "Inpath", " infilename", "Infile", "outfilename", "infilename", "inpath", "inputpath", "inputfilename", "inputFile", " inpath", " inbase"], "outfile": ["inname", "newfile", " outname", "newname", "newfilename", "newFile", "inFile", "tofile", "todir", "fromfp", " outfilename", "infp", "outFile", "fromfile", "outdir", "indir", "fromdir", "tofp", "toFile", "outfp", " outFile", "outfilename", "infilename", "fromFile", "outname"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "image", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ro", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "null", "fn", "os", "en", "cn", "to", "flush", "up", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "can", "aos", "o", "res", "outer", "inner", "ot"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "queue", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "length", "black", "stack", "temp", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", "commit", "ccess", "cess", "value", "accept", "fail", "growth", "warning", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "ith", "successful", "good", "please", "ceed", "town", "result", "valid", " Success", "successfully", " okay", " failure", "ratulations", "photo", "sufficient", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "20208819", "id2": "20519261", "code1": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 0, "substitutes": {"hash": ["read", "message", "check", "value", "format", " fingerprint", " Hash", "sign", "update", "id", " sum", " hashing", "key", "run", "h", "uri", "dump", "password", "sha", "get", "Hash", "render", "sum", "print", "code", "name", "tag"], "input": ["message", "empty", "value", "accept", "out", "bit", "url", "select", "output", "lat", "request", "config", "current", "Input", "string", "image", "this", "source", "null", "q", "p", "in", "pattern", "char", "password", "command", "valid", "sequence", "text", "form", "buffer", "raw", " inputs", "active", "sample", "example", "data", "prefix", "hello"], "algorithm": ["assgorithm", "alabet", "arabet", "assometry", "argo", " Algo", "aloch", "Algorithm", "Aloch", "Algo", "validgo", "argorithm", "Alabet", "alphgorithm", " Aloch", "validabet", "algo", "arometry", "alphgo", " Alabet", "alometry", "assgo", "alphoch", " Algorithm", "assabet", "validgorithm", "validometry", "alphabet"], "dig": ["nd", "ng", " Dig", "cd", "dep", "plug", "dh", "find", "dash", "des", "del", "comm", "grad", "dir", "alg", "add", "md", "cong", "fin", "de", "rip", "fun", "df", "Dig", "dd", "ve", "div", "cr", "mod", "ind", "desc", "pers", "round", "dec", "enc", "dat", "g", "ld", "dim", "deg", "od", "bd", "rd", "d", "sd", "her", "db"], "result": ["pixel", "Result", "match", "user", "group", "display", "make", "out", "component", "r", "wrapper", "output", "description", "join", "currency", "current", "use", "mark", "rc", "product", "summary", "success", "true", "answer", "proc", "continue", "results", "reason", "next", "this", "term", "run", "br", "pair", "created", "mate", "up", "part", "report", "position", "ret", "dat", "render", "ral", "date", "total", "event", "print", "res", "create", "profile", "response", "comment", "prefix", "complete", "relation", "region"], "digest": ["dest", " digEST", "Digenge", "digEST", " digtest", "dested", "hasested", "definedested", "equgest", "displaytest", "digenge", "definedgest", "displayEST", "displayested", "diggest", " digenge", "hasest", "displayest", "displayist", "Digtest", "digested", "Digist", "Digest", "digtest", "definedest", "hasenge", "digist", "Diggest", "displaygest", " digate", "equested", "Digse", "Digate", "digate", "equse", "definedse", "dist", "DigEST", "Digested", "equest", "dgest", "digse", " digested", "hasate"], "hex": ["xf", "ex", "iter", "solid", "check", "com", "full", "ph", "ape", "nuts", "prop", " Hex", "des", "utf", "sv", "zip", "wh", "https", "tx", "html", "x", "key", "zero", "term", "color", "pex", "row", "hl", "serial", "h", "percent", "hw", "def", "comp", "char", "sh", "sex", "hist", "json", "exp", "alph", "ch", "form", "tex", "raw", "rex", "print", "index", "alpha", "oct"], "i": ["ij", "gi", "it", "id", "xi", "qi", "k", "info", "ci", "li", "\u0438", "z", "I", "m", "f", "di", "ai", "ix", "hi", "ki", "x", "bi", "ri", "ii", "n", "a", "multi", "mi", "uri", "ic", "batch", "io", "y", "ind", "im", "phi", "status", "iu", "g", "conv", "e", "ji", "me", "si", "print", "zi", "v", "pi", "ei", "ti", "cli", "j", "ui", "index", "ini", "ip"], "u": ["b", "user", "U", "us", "ou", "fu", "uu", "mu", "f", "su", "t", "au", "uni", "ut", "ur", "c", "ue", "tu", "q", "h", "bu", "num", "you", "pu", "util", "up", "eu", "nu", "lu", "uj", "uint", "uid", "cu", "unsigned", "iu", "uc", "um", "d", "hu", "v", "ul", "ui", "uv"], "highCount": ["topCount", "highAmount", " highcount", "hiCast", "highLength", "highCast", "highCode", "lowAmount", "topcount", " highPtr", " highCode", "higherCount", " highCast", " highLength", " highAmount", "hiFlag", "higherCast", "Highcount", "topCode", "higherAmount", "highercount", "highPtr", "hiCount", "hiLength", " highFlag", "lowLength", "HighCode", "highFlag", "HighCount", "lowcount", "topPtr", "HighPtr", "lowFlag", "highcount", "lowCast"], "lowCount": ["highCounter", "ownCold", "lowCold", "littleCount", "midSum", "lowSum", "highLength", "midCold", "ownCount", "midCountry", "lowCounter", "midLength", "midCount", "lowButton", "lowCountry", "littleCounter", " lowSum", "littleLength", " lowCold", "midButton", "highCountry", "midCounter", " lowButton", "lowLength", "ownButton", "ownSum", "littleCountry"]}}
{"id1": "6457199", "id2": "12306305", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"doRequest": ["dorequest", " dorequest", "handleQuery", "handleResponse", " doResponse", "processRequest", "doResponse", "processQuery", "handleRequest", " doQuery", "handlerequest", "doQuery", "processrequest", "processResponse"], "request": ["setup", "message", "user", "transform", "each", "http", "QUEST", "input", "query", "search", "application", "open", "address", "select", "context", "project", "first", "reference", "frame", "quest", "req", "Request", "forward", "xml", "initial", "document", "command", "view", "report", "position", "get", "re", "question", "complete", "seek", "create", "hello", "reset", "call"], "response": ["reply", "message", "block", "channel", "header", "format", "display", "http", "out", "write", "application", "context", "output", "relation", "frame", "send", "release", "feed", "onse", "continue", "image", "next", "page", "exit", "resp", "xml", "document", "result", "json", "view", "respond", "console", "socket", "report", "position", "writer", "e", "re", "render", "fire", "connection", "content", "print", "server", "res", "Response", "status", "service", "reset", "respons"], "path": ["alias", "message", "Path", "transform", "ex", "binding", "template", "full", "format", "prop", "where", "input", "url", "type", "relative", "filename", "select", "api", "context", "pkg", "clean", "dir", "core", "error", "string", "trace", "parts", "root", "PATH", "test", "key", "route", "patch", "right", "near", "primary", "host", "p", "uri", "method", "pattern", "href", "physical", "json", "policy", "text", "length", "ath", "port", "parent", "log", "chain", "raw", "kind", "print", "location", "base", "partial", "pointer", "name", "prefix", "mount", "index", "local", "qualified"], "internal": ["external", "alias", "template", "init", "id", "san", "url", "binary", "relative", "context", "api", "real", " external", "inline", "inside", "common", "back", "central", "original", "bin", "standard", "entry", "virtual", "origin", "managed", "this", "primary", "orig", "in", "generic", "regular", "initial", "valid", "console", "uid", "ret", "intern", "impl", "ident", "Internal", "inner", "skin", "invoke", "inter", "rel", "name", "identified", "index", "local", "normal"], "resource": ["library", "range", "store", "component", "url", "binary", "address", "Resource", "context", "media", "file", "core", "instance", "reference", "network", "release", "record", "directory", "entry", "system", "exclusive", "image", "stream", "resources", "source", "object", "uri", "handle", "result", "console", "socket", "remote", "controller", "resolution", "re", "process", "buffer", "connection", "print", "model", "pointer", "res", "create", "channel", "service", "local", "region"], "mimeType": ["metytype", "maxTypes", "mimetype", " mimeName", "metyPolicy", "MetyType", "mtimeStyle", " meshName", "mimesStyle", "metyStyle", "MimeName", "Metytype", "metyName", "mimesTypes", "maxStyle", "miscType", "mIMEType", "meshName", " meshStyle", "mimeStyle", " mimeTypes", "miscName", "miscTypes", "Mimetype", " mimePolicy", "mtimeType", "mIMEStyle", "meshtype", "metyTypes", " mimeStyle", "MimeTypes", "mimesType", "metyType", "mtimeName", "MimeType", "misctype", "MetyTypes", "mtimetype", "mIMEtype", "mIMETypes", "mimeTypes", "mIMEName", "maxPolicy", "mimePolicy", "meshType", " meshType", "mimesPolicy", " mimesPolicy", "mimeName", "maxType", " mimetype", "MetyName", " mimesType", "meshStyle", " mimesTypes", " mimesStyle", " meshtype"], "is": ["ls", "mus", "cs", "nis", "gets", "ics", "isl", "fs", "ys", "iso", "bis", "IS", "s", "isc", "as", "ri", "ins", "rs", "iss", "ris", "ic", "in", "are", "isf", "Is", "obs", "icks", "isi", "has", "its", "ios", "isin", "ais", "i", "sis", "si", "ism", "res", "ains", "isa", "iris", "es"], "os": ["ls", "cs", "oos", "css", "OS", "us", "oses", "ts", "ds", "fs", "des", "ys", "oes", "ols", "s", "los", "oss", " Os", "as", "oS", "Os", "bos", "osi", "bs", "er", "sys", "ios", "es", "ox", "ps", "ks", "ss", "ros", "nos", "et", "aos", "res", "o", "ot", "ms", "obs", "oz"]}}
{"id1": "20247400", "id2": "2834524", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "label": 1, "substitutes": {"in": ["In", "check", "is", "init", "net", "on", "input", "rin", "it", "info", "file", "IN", "inn", "and", "inf", "bin", "ai", "ins", "source", "inc", "from", "ze", "up", "io", "ind", "din", "isin", "cin", "con", "i", "gin", " din", "inner"], "out": ["b", "obj", "ex", "check", "at", "or", "OUT", "net", "ou", "it", "write", "r", "err", "output", "ln", "list", "dir", "t", "str", "oss", "client", "gt", "Out", "n", "null", "ins", "os", "screen", "exit", "cmd", "to", "io", "ne", "sys", "outs", "msg", "w", "report", "writer", "OU", "log", "line", "con", "print", "o", "outer", "auto", "other", "name", "ot", "println", "we"], "buffer": ["b", "message", "match", "block", "header", "channel", "iter", "template", "function", "bridge", "display", "cache", "component", "binary", "address", "output", "database", "se", "append", "trace", "queue", "size", "memory", "Buffer", "window", "key", "limit", "source", "filter", "batch", "flush", "processor", "document", "attribute", "result", "bar", "command", "sequence", "view", "length", "position", "clear", "stack", "temp", "pause", "library", "shape", "buf", "event", "history", "total", "available", "sample", "buff", "data", "phrase", "db", "comment", "index", "table", "variable"]}}
{"id1": "4895903", "id2": "20886320", "code1": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"load": ["launch", "read", "transform", "loading", "init", "install", "store", "oad", "download", "open", "save", "sync", "Load", "map", "loads", "LOAD", "use", "link", "lock", "loader", "dump", "show", "build", "insert", "sample", "execute", "call"], "sourceType": ["templateCopy", "SOURCEApp", "ourceDefault", "noteType", "statustype", "sequenceType", "sourceStyle", "causeTyp", "templateStyle", "SOURCETyp", "licenseTyp", "scanField", "sequenceUnit", "scoreType", "versionStyle", " sourceSpec", "serviceApp", "licenseVersion", " sourceClass", "componentTYPE", "statusType", "versionType", "sourceVersion", "noTyp", "ourceType", "scopeSpec", "scantype", "componenttype", "styleTyp", "licenseUnit", "versionTyp", "ourceTyp", "speCopy", "statusTyp", "scoreTyp", "noType", "messageTyp", "causetype", "licensetype", "componentType", "versiontype", "sourceField", "styleClass", "styleTYPE", "componentClass", "unittype", "sourceTyp", " sourceTyp", "styleType", "sourceDefault", " sourceStyle", "SOURCEtype", "spetype", "typeUnit", "scopeStyle", "serviceTyp", "scopeType", "noteTy", "versionDefault", "typeEmail", "sourcetype", "templateSpec", "speTyp", "sourceTYPE", "serviceType", "scopetype", "typeType", "noteTyp", "messageDefault", "licenseTYPE", "templatetype", "sourceEmail", "scanType", " sourceTYPE", "sequenceTYPE", "sourceTy", "sequenceEmail", "secretType", "notetype", "sourceSpec", "secrettype", "typeTYPE", "componentTyp", "unitTyp", "scoretype", "SOURCEType", "scanTyp", "secretTyp", "scopeTyp", "notype", "sourceApp", "speType", "statusVersion", "sourceClass", "unitType", "scopeCopy", "sourceCopy", "secretApp", "licenseType", "licenseEmail", "templateTyp", "noStyle", "messageType", "servicetype", "versionTy", "causeType", "sourceUnit", "causeTy", "ourceTy", " sourceField", "messageTy", " sourcetype", "statusTy", "SOURCEVersion", "componentField", "templateType"], "source": ["SOURCE", "ce", "supp", "draw", "update", "search", "find", "filename", "file", "any", "seed", "se", "size", "origin", "image", "expression", "sp", "spec", "text", "body", "report", "none", "get", "license", "resource", "node", "status", "series", "service", "alias", "init", "format", "src", "note", "input", "sql", "subject", "context", "description", "join", "ource", "feature", "key", "stream", "scope", "details", "handle", "settings", "site", "state", "json", "target", "show", "see", "raw", "sample", "scan", "via", "table", "message", "iter", "slot", "storage", "function", "parse", "Source", "instance", "list", "config", "core", "string", "send", "missing", "sequence", "ie", "remote", "comment", "template", "store", "cache", "component", "query", "force", "address", "use", "reason", "from", "object", "unit", "copy", "view", "slice", "style", "parent", "me", "module", "content", "start", "create"], "param": ["item", "path", "rest", "init", "format", "perm", "conf", "prop", "query", "Parameter", "argument", "m", "pm", "config", "rm", "rem", "pre", "reference", "params", "arg", "rpm", "req", "term", "p", "cp", "asm", "method", "Param", "attr", "attribute", "pai", "msg", "problem", "aram", "typ", "par", "property", "cal", "ref", "mm", "meter", "monitor", "arm", "model", "start", "name", "admin", "tag", "comment", "prefix", "index", "member", "prom"], "location": ["operation", "path", "message", "library", "Location", "device", "value", "center", "where", "direction", "search", "info", "address", "context", "filename", "translation", "ion", "activity", "description", "media", "reference", "ocation", "availability", "trace", "directory", "padding", "root", "origin", "feature", "key", "peer", "entry", "loc", "color", "family", "scope", "mount", "area", "layout", "expression", "initial", "owner", "document", "bound", "folder", "sequence", "property", "target", "position", "LOC", "remote", "usage", "condition", "shape", "history", "event", "resource", "module", "sample", "language", "name", "point", "comment", "local", "region"], "type": ["function", "format", "title", "tp", "where", "ver", "time", "info", "all", "id", "options", "class", "address", "error", " Type", "description", "t", "link", "trace", "pretty", "what", "test", "root", "ype", "ty", "key", "types", "color", "family", "scope", "term", "action", "pe", "unit", "method", "ping", "sort", "Type", "op", "part", "command", "state", "typ", "length", "style", "position", "option", "form", "port", "ime", "shape", "role", "kind", "event", "operator", "language", "TYPE", "name", "comment", "tag", "status"], "inputsource": ["submitsource", "InputSource", "inputsum", " inputscope", "pullSOURCE", "Inputstore", " inputource", " inputsample", "uploadstore", "operatorstream", " inputobject", "inputsite", "uploadsource", "outputstore", " inputiterator", "inputobject", "submitsample", " inputsequence", "inputservice", "inputource", "helpiterator", "submitsequence", "insertsource", "outputsource", "inource", "submitsrc", "inputresource", "Inputresource", " inputSource", "insertstore", "othersample", " inputSOURCE", "insource", "Inputsrc", "inputstream", "insertsite", "operatorSOURCE", " inputsum", "operatorseed", " inputseed", " inputstore", " inputservice", "inputsrc", "inputSource", "pullseed", "outputresource", "operatorsource", "pullsource", " inputstream", "acceptsource", "inputiterator", "inputseed", "Inputobject", "helpsite", "inputscope", "acceptsrc", " inputresource", "othersequence", "insertsum", "pullstream", " inputsite", "insertiterator", "inputstore", "Inputsource", "acceptresource", "uploadservice", "inputsample", "insertservice", "outputobject", "helpstore", "outputscope", "othersrc", "insrc", "Inputource", " inputsrc", "acceptscope", "helpsource", "uploadsum", "outputsrc", "othersource", "inputSOURCE", "inSource", "inputsequence"], "url": ["external", "user", "path", "dl", "cert", "net", "http", "URL", "git", "download", "r", "f", "api", "address", "open", "sql", "file", "abs", "l", "ur", "link", "str", "gl", "browser", "string", "client", "web", "html", "nl", "term", "host", "p", "u", "uri", "char", "rl", "xml", "text", "ref", "impl", "mail", "Url", "ml", "buffer", "ssl", "resource", "bel", "base", "rel", "ll", "mount", "sl"], "ds": ["ls", "cs", "dos", "dl", "gs", "dr", "eds", "dh", "ts", "fs", "des", "ys", "gd", "md", "dds", "ysis", "sq", "sts", "ads", "dc", "ees", "uds", "rs", "xs", "df", "pd", "dd", "bs", "Ds", "sys", "dt", "hs", "eps", "js", "ps", "ks", "ss", "sd", "qs", "ws", "DS", "db", "ms", "di", "ns"], "mbeans": ["lubes", "umbean", "Mbs", "mubes", "lbeans", "cmbs", " mbean", "mxbean", "Mubes", "mxubes", "movies", "umovies", "umbeans", "mbs", "mxbs", "cmbean", "lbs", "Mbean", "cmovies", "umbs", "Mbeans", " movies", "mxbeans", "cmbeans", "mbean", "lbean", " mbs"]}}
{"id1": "646016", "id2": "12171364", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"elimina": ["allimina", "eligina", "elitisa", "eligisa", "ellimina", "ellimino", "allimine", "elitine", "alimina", "elimine", "allimisa", "eligino", "alimisa", "alimine", "elitino", "elimino", "allimino", "ellimisa", "elitina", "ellimine", "elimisa", "alimino", "eligine"], "cli": ["Cl", "dl", "aci", "cgi", "grid", "gui", "ci", "GUI", "li", "Client", "cfg", "ln", "coe", "exe", "l", "udi", "uci", "client", "cl", "prot", " CLI", "c", " cl", "ctl", "multi", "cmd", "util", "lu", "console", "cu", "cci", "dial", "e", "cho", "clus", "gil", "ctrl", "conn", "i", "eric", "coni", "pi", "ui", "lc", "idi"], "id": ["ad", "is", "mid", "value", "aid", "ida", "out", "Id", "wid", "url", "info", "with", "iden", "it", "type", "del", "ID", "f", "and", "kid", "md", "key", "pid", "end", "null", "did", "sid", "oid", "h", "rid", "num", "in", "bid", "uid", "vid", "ref", "e", "ident", " fid", "mail", "no", "i", "sd", "d", "code", "ide", "start", "rand", "hash", "res", "name", "ids", "db", "status", "index", "ip"], "sql": ["ls", "inv", "dl", "QL", "format", "spr", " SQL", "pp", "ds", "query", "url", "shell", "sal", "pkg", "ln", "wal", "sv", "lex", "ql", "csv", "s", "string", "lock", "https", "what", "sq", "html", "nl", "fn", "software", "xs", "details", "pel", "services", "sk", "expression", "util", "ping", "lua", "xml", "sys", "SQL", "sp", "msg", "spec", "scl", "sol", "json", "ips", "socket", "eps", "sb", "js", "owl", "mail", "ps", "ssl", "sd", "security", "ship", "ll", "db", "ms", "sl", "ns"], "stmt": ["tm", "scmt", "strm", "STmm", "STm", "scm", "stMT", "strmt", "STMT", "tmt", "Stmm", "StMT", "stmm", "Stmn", " stm", "STmn", " stmn", "stmb", "Stmt", "tmm", "ttm", "Stm", "scmm", "strMT", "sttm", " sttm", "sctm", "STmt", " stmm", "Sttm", "stmn", " stMT", "Stmb", "strmb", " stmb", "stm"]}}
{"id1": "11716816", "id2": "12380475", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"updateFile": ["UpdateSourceFile", "downloadContent", "archiveContent", "updateContent", "UpdateContent", "archivePage", "downloadPage", "updateSourceFile", "updatePage", "UpdatePage", "downloadFile", "archiveSourceFile", "UpdateFile", "downloadSourceFile", "archiveFile"], "file": ["message", "path", "issue", "full", "format", "title", "input", "url", "type", "info", "f", "filename", "output", "fp", "use", "t", "link", "entry", "rule", "image", "page", "source", "null", "le", "p", "h", "ile", "handle", "io", "document", "attribute", "report", "port", "FILE", "e", "log", "get", "line", "resource", "content", "base", "data", "name", "db", "channel", "File", "local", "table"], "IOException": ["IOError", "OperationException", "SecurityError", " IOError", "SecurityException", "OperationProblem", "SecurityProblem", "IOProblem", "OperationError", " IOProblem"], "destFile": ["DestPage", "destSourceFile", "DestFile", "tempfile", " destinationDo", " DestFile", "declFolder", " DestDir", "Destile", "destPage", " destPath", "declFile", "DestSourceFile", "declile", " destinationEmail", "destPath", "targetFile", "sourceFolder", " destPlace", "destfile", "targetDir", "targetFolder", " destfile", "optPlace", " destDo", "optPage", " destFolder", "sourceFile", "sourceDir", " destinationDir", "DestFolder", "DestPath", "Destfile", " destSourceFile", " destPage", "tempFile", " destile", " destEmail", "optFolder", " destDir", "tempDir", "DestDir", "targetPath", "tempPath", "declSourceFile", " DestDo", "destFolder", "destDir", "destPlace", " destinationFile", "optFile", "destEmail", "sourcePath", "DestPlace", "destDo", "destile", " DestEmail"], "in": ["In", "read", "iter", "is", "init", "sin", "net", "on", "input", "rin", "it", "al", "all", "r", "f", "pass", "info", "m", "ain", "IN", "ln", "inn", "s", "l", "inside", "inf", "bin", "ai", " IN", "ins", "n", "from", "inc", "en", "mi", "ic", "act", "up", "io", "ne", "ind", "oin", "edIn", "im", "din", "mm", "isin", "ie", "re", "cin", "con", "i", "gin", " din", "raw", "inner", "local", "ini"], "out": ["b", "obj", "ex", "at", "or", "net", "OUT", "note", "ou", "cache", "it", "write", "output", "oe", "nt", "ion", "t", "s", "cos", "oss", "client", "again", "gt", "Out", "n", "one", "null", "fn", "os", "en", " OUT", "cn", "cmd", "to", "flush", "up", "io", "ne", "sys", "outs", "result", "msg", "ch", "conv", "OU", "g", "no", "log", "con", "conn", "jp", "chain", "co", "v", "aos", "o", "outer", "can", "ot", "channel"]}}
{"id1": "9996334", "id2": "21489105", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"generateToken": ["generatorToken", "generateCode", "generateString", " GenerateKey", "generatesString", "generatesToken", " GeneratesString", " GenerateToken", " GeneratesCode", "generatorCode", "generatesKey", "generateKey", " GeneratesKey", "generatorKey", " GeneratesToken", "generatorString", "generatesCode", " GenerateString", " GenerateCode"], "code": ["message", "ce", "template", "value", "function", "rice", "component", "address", "error", "string", "ode", "str", "test", "html", "c", "x", "reason", "source", "close", "char", "Code", "password", "token", "command", "state", "sequence", "text", "e", "codes", "buffer", "content", "hash", "data", "response", "name", "hello"], "md": ["amd", "nd", "cd", "dr", "dh", "ds", "mt", "red", "MD", "m", "pm", "mp", "rm", "der", "mk", "add", "de", "hd", "mo", "mc", "df", "pd", "cmd", "dd", "det", "msg", "ind", "mod", "desc", "mat", "pdf", "mm", "ld", "med", "bd", "od", "mn", "mb", "mand", "d", "sd", "mg", "ms", "di", "sm", "dm"], "bytes": ["b", "pieces", "unks", "gs", "strings", "files", "words", "gets", "vals", "keys", "ds", "binary", "gb", "versions", "users", "s", "bps", "parts", "groups", "results", "tes", "bits", "bs", "Bytes", "classes", "outs", "ents", "steps", "its", "pdf", "seconds", "hex", "lines", "raw", "objects", "latest", "ms", "terms", "es", "values", "pages", "blocks"]}}
{"id1": "10361370", "id2": "16092702", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"hash": ["message", "match", "header", "check", "sign", "update", "array", "ash", "ashes", "test", "html", "key", "h", "filter", "handle", "version", "password", "attribute", "crypt", "Hash", "render", "sum", "print", "code", "profile", "tag", "index"], "saltBefore": ["saltStart", "sadePrevious", " sALTBefore", "SALTBefore", "sALTStart", "SaltPrevious", "sashStart", "sALTPrevious", " saltStart", "sashBefore", "sadeStart", "saveBefore", "SaltAfter", "sadeBefore", "sadeAfter", "SALTAfter", "savePrevious", "SALTPrevious", "sALTAfter", "saveAfter", "sashAfter", "SaltBefore", " sALTStart", "saltPrevious", " sALTAfter", "sALTBefore"], "content": ["message", "path", "value", "format", "title", "input", "url", "subject", "output", "translation", "media", "file", "present", "config", "any", "current", "description", "Content", "string", "str", "record", "html", "c", "reason", "image", "word", "source", "null", "txt", "object", "expression", "xml", "password", "document", "initial", "json", "sequence", "text", "body", "entity", "license", "raw", "cont", "code", "example", "data", "comment", "time"], "saltAfter": ["valtBefore", "SALTBefore", "sintafter", "sintBefore", "vintBody", "soltAfter", "vintafter", "saltafter", "valtAfter", "sadeResult", "soltBefore", "vintAfter", "sintAfter", "SALTPost", "valtBody", "vintBefore", "sALTPost", "saveBefore", "SALTResult", "sALTafter", "soltResult", "saveBody", "SaltAfter", "sadeBefore", "sadeAfter", "soltPost", "SALTAfter", "sALTAfter", "saveAfter", "SaltPost", "SaltResult", "saltResult", "sintBody", "SaltBefore", "saltPost", "valtafter", "saveafter", "sALTBody", "sALTResult", "sALTBefore", "saltBody", "sadePost"], "repeatedHashingCount": ["repeatedRashingCount", "repeatedRashingCode", "repeatedHashCount", "repeatedHASHLength", "repeatedHASHcount", "repeatedHashingLength", "repeatedHashesCode", "repeatedRashingcount", "repeatedHashCounter", "repeatedRashingCC", "repeatedHASHCounter", "repeatedHachingCode", "repeatedRashCount", "repeatedHASHCount", "repeatedHashLength", "repeatedRashesLength", "repeatedRashescount", "repeatedHashesCC", "repeatedHashCC", "repeatedHachingLength", "repeatedHashCode", "repeatedHashingCC", "repeatedHachingCC", "repeatedRashesCount", "repeatedRashesCounter", "repeatedRashingCounter", "repeatedRashingLength", "repeatedRashLength", "repeatedHachingCount", "repeatedRashCode", "repeatedHashingCode", "repeatedHashesLength", "repeatedHashesCounter", "repeatedRashCC", "repeatedHashingcount", "repeatedHashingCounter", "repeatedHashescount", "repeatedHashesCount", "repeatedHashcount"], "digest": ["Dighash", "Digum", " Digest", "digEST", "descest", "fifency", " digitude", "algEST", " Digester", "Digist", "diagnum", "dester", "fifitude", "comphash", "commested", "Digse", "designester", "designested", "algest", "descse", "Digute", " digum", "hashute", "diagnist", "fingerEST", "fingerest", "hashest", "digency", "Digester", "fingeresting", "mdse", "compute", "designesting", "mdester", "compest", "Digests", "extester", "debugest", "argested", "digested", "dert", "digitude", "fifest", " dighest", "extest", "argester", "commse", "printhest", "extse", "commest", "Digested", "dfested", "digute", "dest", "dfester", " digEST", "descity", "digester", "debugEST", "digity", "dested", "hashEST", "printest", "compEST", "printEST", "diagnests", "Digest", "diagnest", "algester", "commity", "argest", "digests", "digist", "debugency", "debugitude", " digert", " digist", " digesting", "DigEST", "mdested", "dfesting", "descested", "dighest", " digse", " Digested", "digum", "dfest", "argEST", "algested", "mdest", " Digert", "hashhash", "digert", "printesting", "dse", "dighash", " digency", " digests", "designest", "digesting", "extested", "fifEST", "fingerhest", " digester", " digity", "digse", " digested"], "digestLength": [" digestData", " digestType", "descesterLength", "digistLength", " digestLen", "digestedOffset", "digistLen", "digestedlength", "descesterlength", "digseLen", " digesterLength", "digesterlength", "digesterType", "digestLen", " digesterData", "digestlength", " digesterLen", "digestedData", "descestLen", "descestlength", "digestedType", "digesterLen", "digesterLength", "digesterData", "digistType", "digesterOffset", "descesterLen", "digestedLength", "digestData", "digistData", "digseLength", "digestedLen", "descesterOffset", "digseOffset", "digestOffset", "descestOffset", "descestLength", "digestType", " digesterType", "digselength"], "i": ["ex", "iter", "is", "init", "my", "gi", "qi", "ski", "it", "uu", "sql", "xi", "ci", "li", "err", "ms", "I", "m", "z", "di", "ai", "ix", "iq", "client", "gu", "x", "bi", "n", "ii", "q", "multi", "u", "mi", "uri", "ic", "in", "batch", "ind", "y", "im", "phi", "iu", "sim", "me", "si", "print", "v", "ei", "pi", "ti", "cli", "j", "ui", "index", "ini", "ip", "mill"]}}
{"id1": "14047629", "id2": "18891988", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "label": 1, "substitutes": {"source": ["message", "SOURCE", "format", "src", "input", "query", "sql", "Source", "address", "output", "shell", "file", "request", "reader", "ource", "seed", "se", "proc", "system", "image", "stream", "from", "q", "in", "expression", "copy", "result", "sequence", "console", "position", "iterator", "buffer", "event", "resource", "content", "sample", "data", "channel", "service"], "process": ["place", "script", "check", "init", "function", "pp", "parse", "store", "make", "thread", "component", "context", "class", "project", "pm", "file", "task", "session", "complex", "and", "processing", "use", "frame", "exec", "program", "network", "link", "se", "job", "proc", "Process", "memory", "term", "pid", "run", "p", "object", "cp", "cmd", "processor", "method", "handle", "pipe", "work", "command", "flow", "state", "sys", "console", "post", "status", "build", "condition", "chain", "code", "create", "execute", "mem", "node", "connect", "service", "call"], "processStdOut": ["processStrEx", "processStstdOut", "processStrdEr", "processStrrEr", "processStrOut", "processStdEx", "processStstdEx", "processStrrIn", "processStrEr", "processStstIn", "processStrdEx", "processStrrOut", "processStstEx", "processStstdIn", "processStstOut", "processStrIn", "processStrrEx", "processStdEr", "processStrdOut", "processStstdEr", "processStstEr", "processStrdIn"], "processStdIn": ["processStdsIN", "processStrIns", "processSTdIns", "processStackdsIn", "processStdIN", "processStdsIn", "processStrIN", "processStdsIns", "processSTdIN", "processSTtIns", "processStackdsin", "processStdsin", "processSttIn", "processStsIN", "processSttIN", "processStsIn", "processSttOut", "processStrin", "processStackdin", "processStrOut", "processStdIns", "processStackdIN", "processSTtIn", "processSTtIN", "processStdin", "processStackdsIN", "processStackdOut", "processStsOut", "processSTdOut", "processStackdsOut", "processStsin", "processStrIn", "processSTdIn", "processSTtOut", "processStdsOut", "processSttIns", "processStackdIn"]}}
{"id1": "16466743", "id2": "15500892", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getmd5": ["getMD4", "getmd6", "getMD2", "getMD6", " getMD4", " getMD5", "getMD5", " getMD6", "getmd4", "getsha5", " getmd6", " getmd2", "getsha2", "getmd2", "getsha6", " getmd4", "getsha4", " getMD2"], "password": ["message", "user", "path", "sword", "auth", "value", "pass", "Password", "ew", "wd", "address", "database", "description", "login", " Password", "string", "padding", "email", "wordpress", "entry", "key", "word", "p", "pattern", "username", "attribute", "token", "shadow", "w", "text", "code", "security", "hash", "data", "name", "phrase", "prefix", "hello", "secret"], "pwHash": ["pswSum", "pwHas", "pswHash", " pwHas", "pwdHash", "pwdhash", "pwdSum", "spwhash", "pswhash", "pWHas", " pwhash", " pwSum", "pwthash", "pWHash", "pWhash", "spwdSum", "pwshash", " pwdHash", "spwdHas", "spwHas", "pwsHash", "spwdhash", " pwdSum", "pwtHash", " pwdHas", "pwSum", "spwSum", "pwsHas", "pwtHas", "pwhash", "spwdHash", "pWSum", "pwtSum", "spwHash", "pswHas", "pwsSum", " pwdhash", "pwdHas"], "md": ["ad", "nd", "ng", " mc", "cd", "ds", "del", "mt", "ms", "red", "grad", "MD", "m", "mp", "pm", "rm", "dir", "der", "cond", "mk", "add", "exec", "hd", " dd", "mo", "mc", "df", " mo", "pd", "cmd", "dd", "def", "det", "cmp", "msg", "mod", "ind", "desc", "mm", "ld", "mail", "bd", "od", "dig", "mn", "mb", "material", "td", "metadata", "d", "sd", "man", " Md", "mem", "mg", " mm", "di", "sm", "doc", "dm"], "b": ["obj", "reb", "bytes", "ba", "binary", "bp", "gb", "f", "ib", "be", "bas", "m", "bf", "ab", "abs", "bis", "bc", "l", "rb", "cb", "bi", "a", "br", "p", "bu", "batch", "bs", "bar", "y", "w", "sb", "bh", "eb", "nb", "g", "B", "bb", "mb", "fb", "d", "v", "buff", "ob", "db"], "i": ["ij", "iter", "is", "my", "init", "us", "gi", "id", "qi", "it", "ski", "xi", "\u0438", "ci", "li", "ms", "I", "m", "l", "oi", "di", "ai", "ix", "gu", "ki", "x", "hi", "ri", "bi", "n", "ii", "next", "a", "q", "p", "u", "multi", "mi", "ic", "in", "io", "y", "ind", "json", "im", "phi", "sim", "iu", "ie", "ji", "si", "yi", "v", "ei", "pi", "span", "o", "ti", "cli", "j", "ui", "index", "ini", "ip"]}}
{"id1": "3756429", "id2": "6517139", "code1": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 1, "substitutes": {"scramble": ["scrambling", "screambles", "scambles", "screamble", " unscrambling", " unscreambled", " unscrambles", " unscreamble", " unscreambling", "scrimble", "scrambles", "scrambled", "screambled", "screambling", "scamble", "scambled", " unscreambles", "scambling", "scrimbling", " unscrambled", "scrimbled", "scrimbles", " unscramble"], "text": ["message", "read", "path", "th", "template", "value", "title", "tt", "input", "aut", "output", "nt", "config", "t", "string", "str", "test", "html", "ext", "TEXT", "word", "txt", "source", "object", "act", "pattern", "char", "document", "command", "msg", "body", "log", "buffer", "cont", "content", "print", "code", "now", "Text", "data", "name"], "md": ["cd", "dr", "dh", "mt", "red", "grad", "nt", "MD", "m", "pm", " MD", "rm", "mp", "der", "ma", "mk", "add", "met", "hd", "mo", "mc", "df", "pd", "cmd", "dd", "def", "det", "sh", "mod", "ind", "sha", "pdf", "mm", "ld", "bd", "od", "mn", "me", "mb", "material", "mand", "sd", "d", " Md", "mg", "ms", "sm", "dm"], "sb": ["sth", "ib", "sg", "gb", "bp", "shell", "bf", "ab", "abs", "bis", "rb", "obb", "bj", "SB", "cb", "sq", "bg", "erb", "lb", "bs", "zb", "sp", "soc", "ub", "gob", "bh", "eb", "nb", "bd", "bb", "bsp", "mb", "ssl", "sa", "sf", "xb", "bt", "kb", "lp", "ob", "db", "obs", "sl", "pb"], "b": ["obj", "bit", "k", "r", "f", "be", "z", "gb", "ib", "db", "m", "bp", "ab", "bc", "s", "t", "rb", "cb", "c", "bi", "n", "a", "br", "u", "bu", "bs", "eb", "nb", "g", "B", "bb", "i", "wb", "fb", "d", "bt", "v", "code", "o", "kb", "j"]}}
{"id1": "9347451", "id2": "20128728", "code1": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"writeData": [" writeResults", "writedata", "readResults", " writeDat", "readDat", "saveResults", " writedata", "readData", "savedata", "readdata", "writeDat", "writeResults", "saveData", "saveDat"], "name": ["b", "path", "item", "value", "title", "out", "id", "type", "info", "filename", "class", "error", "l", "size", "key", "Name", "word", "n", "run", "label", "a", "in", "version", "default", "power", "named", "old", "unique", "w", "ame", "parent", "no", "NAME", "names", "code", "base", "start", "create", "data", "prefix", "comment", "index", "local", "table"], "items": ["item", "files", "links", "Items", "keys", "users", "times", "days", "cases", "reports", "jobs", "types", "results", "rows", "fixes", "ops", "xs", "EMS", "bits", "events", "issues", "ips", "steps", "images", "sections", "ites", "units", "tests", "els", "lines", "names", "objects", "qs", "workers", "ids", "amples", "ims", "pages"], "mzmin": ["myzmain", "mizmin", "mozmin", " mzmain", "mizMin", "mizstart", " mozmin", "mzhstart", "mzermin", "mzhmain", " mizmin", " mzMin", "mzamin", "mzMin", "mzeramin", "mzmain", "myzmax", "mnzstart", "mozamin", " mozmax", "mzhmax", "mzstart", " mizMin", " mozMin", "myzMin", "mzhmin", " mzamin", "mnzMin", "mozMin", " mizstart", " mizmax", "myzmin", "mzhMin", "mizmax", "mzhamin", "mnzmin", " mozmain", "mnzmax", " mzstart", "mozmax", " mozamin", "mzermax", "mozmain"], "mzmax": ["mgzscale", "mizMAX", "mzipscale", " mZmin", "mZax", "mizmin", "mzMax", "Mzmin", "mozMax", "mzdoc", "mozmin", "mzscale", " mizMAX", " mZdoc", "mjMAX", " mjMax", "Mizmax", "mozMAX", " mjMAX", "mizax", "mizscale", "MizMax", " mZax", "mgzmax", "mgzmin", "mgzMax", "mzipMax", " mzMax", " mizax", " mzMAX", "mjMax", "mZmax", "mjmax", "mzMAX", " mjmin", "Mizscale", "mZmin", " mzax", " mjmax", "mzax", "mizMax", " mZmax", " mizMax", "Mizmin", "mzipmax", "MzMax", "mziax", " mzdoc", "Mzmax", "mZMax", "mjmin", "mzipmin", " mizmax", "mizmax", "mzimin", "mZdoc", "mzimax", "mZMAX", "mzidoc", "mozax", "mozmax", "mizdoc", "Mzscale"], "tstart": ["wend", "timebegin", "Tstart", "tend", "timeend", "TStart", "wtStart", "ttcheck", "wbegin", "ttbegin", "wstart", "ttstart", "tbegin", " tread", " tset", "tsize", "tcheck", "tread", "ttend", "Tcheck", "wsize", "Tread", "tStart", "timesize", " tcheck", "ttsize", "ttStart", "tset", "ttset", "wtstart", "timestart", "Tset", " tStart", "wtread"], "tdelta": ["vdiff", "tdiameter", "pdelta", "TDelt", "vdelta", "tdelt", "edddiff", "TDelta", "eddagger", "TDiff", "TDdiff", "pdelt", "tdagger", "vddiff", "vdelt", "eddiameter", "TDiameter", "pdiameter", "tdiff", "tddiff", "eddelta", "pdagger", "eddiff", "TDagger", "eddelt"], "peaks": ["leaves", "leaks", "heks", "speakes", "peek", "peks", "speaks", "speks", "leakens", "kecks", "peakes", "keakes", "speaves", "teakes", "speakers", "heaves", "peakens", "leks", "heakers", "pecks", "leakers", "peaves", "heakens", "specks", "heaks", "tecks", "teakers", "leakes", "peakers", "heek", "teek", "teaks", "teakens", "keakers", "heakes", "leek", "keaks"], "file": ["place", "full", "files", "out", "where", "f", "filename", "fd", "dir", "feed", "image", "le", "util", "report", "writer", "port", "get", "log", "e", "line", "connection", "resource", "service", "user", "library", "format", "or", "write", "open", "run", "close", "handle", "db", "time", "pool", "table", "block", "function", "list", "fp", "per", "core", "entry", "page", "fe", "tree", "io", "field", "folder", "console", "buffer", "print", "base", " f", "comment", "channel", "store", "type", "force", "output", "class", "tf", "reader", "use", "lock", "email", "web", "rule", "fn", " File", "ile", "to", "il", "document", "form", "FILE", "process", "event", "File"], "i": ["b", "item", "my", "on", "xi", "info", "f", "I", "ai", "ix", "iq", "hi", "p", "mi", "u", "batch", "iu", "e", "integer", "v", "ei", "o", "ip", "ij", "is", "init", "id", "II", "oi", "ki", "x", "c", "ii", "multi", "ic", "in", "sim", "chain", "ti", "point", "ui", "ini", "iter", "qi", "ci", "li", "m", "iy", "n", "a", "io", "ind", "sequence", "im", "g", "index", "di", "ims", "ami", "ni", "us", "gi", "it", "ski", "iii", "iso", "l", "client", "bi", "\u00ed", "you", "to", "y", "me", "si", "d", "pi", "start", "inter"], "nothing": ["empty", "sorry", "warning", "Nothing", "everything", "things", "because", "task", "unknown", "just", "know", "done", "string", "what", "anything", "zero", "never", "which", "this", "missing", "null", "little", " none", "not", "good", "nob", "some", "nan", "you", " bad", "general", "seen", "default", " Nothing", "none", "REDACTED", "no", "kind", "hello", "thing", "total", "something", " no", "stuff", "jump", "whatever", "every", "yeah"], "fileLoc": [" fileLocation", " fileloc", "fileloc", "baseLoc", "fileReg", "FILELocation", "fileLocation", "baseReg", "resourceLoc", "FILELOC", "FILELoc", "resourceLOC", "baseLOC", "fileLOC", "FILEReg", "baseloc", "FILEloc", "resourceloc", " fileReg", "resourceLocation", " fileLOC"], "tempDate": [" tempEvent", " tempEnd", " tempDat", "TempDate", "dateDate", "tempEvent", "tmpData", "tmpEnd", "temEvent", "dateTime", "currentData", "TempData", "temDay", " tempData", "tempDay", "temEnd", "TempDat", "currentDat", "tempData", "tmpDate", " tempDay", "dateDat", "tempEnd", "currentDate", "temDat", " tempTime", "tempTime", "tmpDay", "tempDat", "currentDay", "temData", "temTime", "temDate", "dateEvent", "TempDay"], "t": ["at", "title", "tt", " g", "out", "it", "tc", " w", "tg", "tar", "T", "translation", "tf", "rt", "tz", "ta", "term", "n", "a", "p", " tot", "to", "tv", "tree", "dt", " total", "y", "w", "g", "e", "td", "total", "d", "v", "got", "timeout", "ot", "time"], "k": ["ph", "ka", "kok", "ok", "km", "z", "uk", "kt", "ku", "mk", "kid", "kick", "kw", "kh", "ik", "unk", "ki", "key", "K", "kat", "kr", "tk", "q", "ko", "kar", "kj", "ask", "sk", "kk", "ijk", "height", "ak", "kl", "g", "ack", "kan", "aka", "ks", "ke", "kind", "kn", "ck", "ek", "UK", "ikk", "wk", "ark"], "j": ["b", "obj", "ij", "ng", "jack", "out", "z", "ion", "dj", "kid", "l", "bj", "jo", "kh", "ix", "job", "x", "key", "oj", "n", "q", "br", "p", "adj", "kj", "ct", "aj", "jit", "og", "jas", "ody", "jj", "ja", "msg", "y", "json", "uj", "ind", "jc", "js", "g", "ji", "J", "jp", "jl", "jump", "att"], "peaked": ["heaker", " peake", "peaking", "heaking", "heake", " peaken", "seasured", "pleakable", " peaking", "peaken", "seaken", "seakable", "paasured", "meaky", "pseakable", "speaken", "paaked", "seaked", "peasured", "pleaken", "peaky", "seaker", "peken", "pleaned", "paken", "speken", "peakable", "peaker", "meakable", "meaked", "pseasured", "peaned", "paned", "pakable", "pseaked", "speaked", "paaken", "speakable", "heaken", "peake", "meaken", "meaker", "pseken", "heaky", "pseaken", "seaky", "meaned", "pleaked", "paakable", "heaked", "speake", "paked", "speaking"], "test": ["dev", "user", "match", "iter", "check", "full", "store", "thread", "ver", "search", "query", "r", "f", "tmp", "select", "sync", "list", "tf", "reader", "se", "trace", "fake", "train", "run", "val", "this", "txt", "p", "tested", "unit", "testing", "runner", "master", "est", "tr", "result", "valid", "show", "fast", "report", "temp", "tests", "Test", "print", "v", "inner", "sample"]}}
{"id1": "10504714", "id2": "8046691", "code1": "    private MediaWikiResult getFromUri(String url) throws OntologyServiceException {\n        try {\n            logger.info(\"getting \" + url);\n            HttpURLConnection connection = (java.net.HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"OntoCat-\" + Math.random());\n            BufferedInputStream bin = new BufferedInputStream(connection.getInputStream());\n            JAXBContext jaxbContext = JAXBContext.newInstance(\"uk.ac.ebi.ontocat.mediawiki.jaxb\");\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            return (MediaWikiResult) unmarshaller.unmarshal(bin);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new OntologyServiceException(e);\n        }\n    }\n", "code2": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"getFromUri": ["getFromIri", "getByUrpi", "getByUrURI", "getByUURI", "getFromUpi", "getFromUrri", "getFromOURI", "getFromIURI", "getFromOris", "getByUris", "getFromUris", "getFromUrris", "getByUpi", "getFromIpi", "getByUrris", "getFromOri", "getFromUrURI", "getFromOpi", "getFromUURI", "getFromIris", "getFromUrpi", "getByUrri", "getByUri"], "url": ["b", "ls", "path", "rect", "dl", "full", "http", "URL", "id", "r", "address", "file", "l", "ur", "link", "string", "str", "https", "cl", "web", "html", "nl", "loc", "page", "hl", "host", "q", "mount", "u", "uri", "pattern", "util", "char", "xml", "result", "json", "ref", "remote", "Url", "mail", "build", "ssl", "ul", "location", "base", "name", "ll", "ob", "pl"], "connection": ["message", "generation", "collection", "Connection", "http", "application", "open", "context", "database", "ion", "session", "opening", "link", "network", "client", "directory", "entry", "builder", "c", "connected", "character", "still", "close", "uri", "established", "cone", "io", "document", "command", "socket", "position", "statement", "engine", "conn", "con", "condition", "resource", "server", "communication", "creation", "response", "connect", "channel", "relation"], "bin": ["b", "bytes", "sin", "obin", "cgi", "rin", "win", "binary", "output", "file", "ln", "bean", "inn", "browser", "abin", "bian", "bi", "vin", "jiang", " Bin", "n", "inning", "in", "len", "sam", "ebin", "tin", "soc", "body", "din", "bn", "cin", "con", "buffer", "spin", "gin", "ran", "skin", "data", "bank"], "jaxbContext": ["jaxBcontext", "javbForm", "jAXbInstance", "jaxpForm", "javcFactory", "jaxcForm", "jaxBContext", "jaxbaInstance", "javccontext", "jaxpInstance", "jaxbcForm", "jaxpFactory", "jaxbcFactory", "jAXbcontext", "jAXbManager", "jaxpContext", "jaxbForm", "jaxBManager", "jaxcContext", "jaxbFactory", "jaxbccontext", "javbContext", "jAXpContext", "jaxpManager", "jaxbManager", "javbFactory", "jAXpInstance", "jAXpcontext", "jaxbcContext", "jaxpcontext", "jAXpManager", "jaxbcontext", "jaxbacontext", "javcForm", "jaxBInstance", "jaxcFactory", "jaxbInstance", "jaxccontext", "jaxbaContext", "javcContext", "jaxbaManager", "jAXbContext", "javbcontext"], "unmarshaller": ["unmeshcallr", "unmarshAllers", "unmarshalller", "unmarshallter", "unmarshalr", "unmeshaller", "unmapperellrer", "unmarshcallers", "unmapperaller", "unmarshAllger", "unmarshellger", "unmeshalller", "unmarshellrer", "unmeshcalller", "unmarshaler", "unmarshallger", "unmarshallers", "unmarsharsrer", "unmarshAllter", "unmeshallers", "unmarshcaller", "unmarshAller", "unmarshAllr", "unmarsheller", "unmapperellter", "unmeshcaller", "unmarsharster", "unmarshcalller", "unmapperellger", "unmarshcallr", "unmarshellter", "unmeshallr", "unmarsharsger", "unmappereller", "unmarshallr", "unmapperallter", "unmapperallrer", "unmarshAllrer", "unmapperallger", "unmarshalers", "unmarshAlller", "unmarsharser", "unmeshcallers", "unmarshallrer"]}}
{"id1": "13595251", "id2": "732800", "code1": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"descargarArchivo": [" descargarRiv", " descargarMotivo", " descargarActico", " descargarMotive", " descargoArchiv", " descargoMotivo", " descargarActiv", " descargoArchive", " descargoArchico", " descargarActivo", " descargoArchivo", " descargarMotico", " descargarRivo", " descargarActive", " descargarMotiv", " descargarArchiv", " descargarRive", " descargoMotiv", " descargarArchive", " descargarArchico", " descargoMotico", " descargarRico", " descargoMotive"], "fis": ["ffix", "dfis", "fios", "ffios", "Fis", "ffis", " fris", "ffiss", " fios", "fiix", "fiiss", "ufis", "ufris", "fiis", "fiss", "ufiss", "dfiss", "dfris", "fris", "ffos", "Fiss", "fix", " fiss", " fix", "Fris", "fiios", "ufos", "ffris", "Fos", "dfos"], "fos": ["flos", "lfoses", "waos", " foes", "fedOS", "fedos", "infOs", "fbos", "lfbos", "flbos", "foses", "foss", " fows", "infbos", " fOs", "fedbos", "fOS", " fbos", "infOS", " foss", "wos", "infos", "lfos", "woes", "lfaos", "foes", "wows", "woss", "vos", "vows", "faos", "fedOs", "woses", "voss", "voes", " fOS", "floses", "fows", "flaos", "wbos", "fOs"], "inChannel": ["outchannel", "inputGray", "innRow", "initChan", " inchannel", "innerchannel", "inRow", "inConnection", "innerButton", "inputChannel", " inChan", "InConnection", "InGray", "aiRow", "innChan", "aiChan", " inButton", "initGray", "Inchannel", "initConnection", "aiChannel", "inButton", "innerChan", "InButton", "innChannel", "inputChan", "innchannel", "inputConnection", "aichannel", "inchannel", "inChan", "InChan", "outRow", "inGray", "initChannel", "outChan", "InChannel", "innerChannel"], "outChannel": [" outButton", "outchannel", " outChan", "outStream", "inConsole", "inStream", "OUTButton", " outchannel", "OUTChan", "OUTConsole", "inButton", " outStream", "OUTchannel", "OUTChannel", "inchannel", "inChan", "outButton", "outChan", "outConsole", " outConsole", "OUTStream"]}}
{"id1": "742465", "id2": "2217889", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doDatecheck", "doLicenseCheck", "doDateFix", "DoVersionFix", "doVersionFix", "doVersioncheck", "DoVersioncheck", "doVersionsFix", "DoDatecheck", "DoVersionUpdate", "doVersionUpdate", "doDateUpdate", "DoDateCheck", "doDateCheck", "doVersionsCheck", "DoDateUpdate", "doLicensecheck", "DoDateFix", "doVersionscheck", "doVersionsUpdate", "doLicenseUpdate", "doLicenseFix", "DoVersionCheck"], "view": ["block", "check", "review", "display", "http", "out", "input", "update", "query", "subject", "widget", "open", "context", "blade", "wrapper", "file", "help", "browser", "cell", "VIEW", "client", "web", "html", "self", "window", "image", "row", "this", "page", "q", "hl", "host", "cv", "table", "manager", "tv", "layout", "util", "index", "tree", "component", "document", "eye", "console", "show", "report", "form", "see", "engine", "get", "controller", "buffer", "server", "print", "v", "model", "views", "View", "iew", "doc", "call"], "url": ["b", "ls", "path", "dl", "http", "URL", "lr", "id", "r", "address", "f", "file", "l", "ur", "gl", "link", "str", "browser", "string", "client", "web", "html", "nl", "org", "loc", "null", "hl", "lb", "host", "mount", "uri", "char", "rl", "github", "json", "socket", "Url", "log", "ssl", "date", "oul", "ul", "v", "bel", "location", "language", "rel", "ll", "pl", "sl"], "in": ["In", "b", "is", "sin", "init", "out", "input", "rin", "info", "f", "ln", "ain", "IN", "file", "inn", "reader", "l", "inf", "vin", " IN", "stream", "ins", "n", "source", "inc", "kin", "body", "mat", "din", "isin", "cin", "mn", "i", "gin", " din", "asin", "inner"], "bin": ["b", "sin", "obin", "thin", "out", "cache", "rin", "win", "binary", "lib", "ln", "file", "bl", "inn", "reader", "cos", "rb", "abin", "loader", "bi", " Bin", "bg", "pipe", "len", "sam", " bins", "ebin", "din", "stock", "by", "nb", "bn", "mon", "cin", "con", "conn", "buffer", "gin", " din", "spin", "ran", "inner", "mem", "buff", "bed", "bur", "local"], "line": ["ls", "LINE", "path", "block", "range", "liner", "iter", "channel", "store", "lo", "err", "ln", "file", "col", "inline", "frame", "ine", "l", "string", "eline", "cell", "load", "link", "se", "record", "lin", "entry", "job", "trace", "cat", "word", "row", "section", "page", "le", "one", "cmd", "Line", "char", "part", "el", "field", "state", "text", "body", "style", "port", "log", "no", " Line", "ice", "lines", "chain", "print", "level", "ide", "base", "sample", "code", "column", "point", "comment", "lane"], "version": ["match", "value", "format", "title", "number", "ver", "update", "type", "info", "iso", "versions", "translation", "project", "ion", "description", "vers", "video", "string", "release", "browser", "python", "client", "test", "feature", "virtual", "key", "image", "VERSION", "software", "serial", "major", "Version", "scale", "command", "spec", "sequence", "river", "position", "form", "usage", "license", "VER", "date", "vision", "resource", "v", "hash", "latest", "language", "name", "tag", "volume", "status", "index"], "build": ["b", "dev", "develop", "match", "th", "full", "install", "fail", "make", "where", "ver", "update", "binary", "be", "lib", "project", "ward", "Build", "use", "add", "boost", "link", "release", "load", "builder", "test", "bor", "struct", "unit", "building", "util", "work", "old", "last", "round", "style", "uild", "bug", "log", "dist", "date", "hold", "print", "hash", "ble", "other", "ship", "tag", "db", "latest", "built", "arch"]}}
{"id1": "1862616", "id2": "21999120", "code1": "    public static String fetch(String reference) throws IOException {\n        URL url = new URL(reference);\n        HttpURLConnection c = (HttpURLConnection) url.openConnection();\n        c.setRequestMethod(\"GET\");\n        c.setDoOutput(true);\n        c.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n        return parseISToString(c.getInputStream());\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 0, "substitutes": {"fetch": ["tault", " fully", "confault", "tully", " fault", "tetch", "confetch", "fully", "confully", " fDownload", "fDownload", "confDownload", "fault", "tDownload"], "reference": ["external", "library", "path", "message", "template", "value", "title", "note", "number", "register", "address", "filename", "relative", "description", "request", "string", "directory", "absolute", "Reference", "source", "href", "document", "attribute", "definition", "position", "ref", "remote", "re", "resolution", "condition", "resource", "seek", "print", "server", "location", "pointer", "sample", "create", "prefix", "index", "reverse"], "url": ["ls", "dl", "http", "URL", "r", "open", "f", "abs", "l", "ur", "au", "str", "https", "job", "web", "nl", "arl", "loc", "null", "hl", "acl", "q", "h", "gc", "char", "ref", "g", "log", "Url", "ml", "build", "mail", "ssl", "ul", "base", "atl", "ll", "ob", "pl", "service", "sl"], "c": ["b", "cs", "ce", "com", "cache", "tc", "k", "f", "r", "ci", "z", "sc", "fc", "pc", "bc", "t", "l", "rc", "client", "cl", "cb", "etc", "dc", "n", "mc", "cp", "ac", "h", "ct", "coll", "C", "cm", "nc", "cr", "cu", "ch", "enc", "ca", "conv", "g", "ec", "cin", "con", "ctrl", "cont", "co", "v", "cf", "cur", "lc"]}}
{"id1": "9033639", "id2": "11673907", "code1": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"testHttpsConnection": ["testHttpConnection", "testHttlesConnection", "testHttlesconnection", "testHttpsconnection", "testHhttpconnection", "testHttTPSconnection", "testHttpsSocket", "testHttlesSocket", "testHttTPSSession", "testHttTPSConnection", "testHttpSession", "testHttTPSSocket", "testHttpSocket", "testHttpconnection", "testHhttpSocket", "testHttlesSession", "testHhttpSession", "testHhttpsconnection", "testHhttpsSocket", "testHhttpsConnection", "testHhttpConnection", "testHttpsSession", "testHhttpsSession"], "ctx": ["setup", "obj", "init", "qu", "src", "tc", "sc", "context", "tmp", "nt", "pkg", "config", "bc", " cx", "rt", "xc", "cc", "tx", "sq", " context", "txt", "mc", "cp", "hw", "ct", "cmd", "cm", "nc", "sys", "cmp", "hs", "socket", "bh", "conn", "jp", "ssl", "co", "cf", "Context", "np", "ws", "pg", "pool"], "ss": ["ls", "cs", "css", "ess", "ts", "SS", "rss", "ds", "sc", "fs", "ys", "ssh", "sec", "hess", "https", "oss", "tx", "sq", "sch", "rs", "iss", "sk", "bs", "ses", "sys", " SS", "sp", "soc", "sol", "socket", "sb", "js", "ps", "serv", "ks", "ssl", "si", "sf", "sd", "sa", "sw", "ws", "sit"], "hnv": ["kinov", "bnv", "hnov", "mnw", "mnv", " knV", "dnov", "kinver", " knw", "hnw", "hnf", "kinj", "hnver", "mnf", "bnj", "bnver", "mnV", "bnov", "dnf", "hnj", " knf", "dnv", "hnV", "dnV", "dnj", "kinv", "dnver", "dnw", " knv"], "url": ["ls", "b", "dl", "net", "http", "URL", "parse", "r", "address", "abs", "l", "ur", "au", "str", "https", "browser", "client", "nl", "dll", "uri", "util", "char", "rl", "il", "el", "ol", "socket", "sb", "ref", "pl", "log", "Url", "ml", "build", "ssl", "ul", "location", "base", "atl", "name", "ll", "mount", "sl"], "connection": ["message", "operation", "Connection", "function", "application", "open", "subject", "context", "wrapper", "database", "ion", "instance", "session", "request", "link", "network", "client", "entry", "connected", "character", "management", "object", "close", "cp", "established", " Connection", "handler", "result", "command", "sequence", "socket", "statement", "log", "controller", "conn", "condition", "ssl", "event", "resource", "server", "communication", "response", "data", "connect", "node", "channel", "service", "relation"], "peerSocket": ["targetConn", "targetSocket", "serverSite", "targetServer", "peerConnection", "serverConnection", "peerSession", "peerSite", "targetConnection", " peerSession", "parentConn", "peSession", "peerConn", " peerServer", " peerConnection", " peerSite", "peSocket", "peSite", " peerConn", "parentSocket", "serverSession", "peerServer", "serverSocket", "parentConnection", "parentServer", "peConnection"]}}
{"id1": "18544890", "id2": "5759961", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"get": ["put", "read", "match", "range", "pull", "getting", "gets", "cache", "draw", "all", "query", "search", "download", "info", "api", "list", "Get", "game", "run", "show", "post", "stats", "GET", "print", "create", "call"], "url": ["path", "rect", "dl", "http", "URL", "id", "api", "address", "file", "game", "l", "ur", "string", "link", "str", "web", "html", "nl", "domain", "hl", "lb", "host", "q", "uri", "addr", "rl", "xml", "ref", "ret", "pl", "mail", "Url", "build", "ssl", "ul", "location", "base", "ll", "mount", "hub", "sl"], "lat": ["feat", "pt", "rect", "sta", "at", "wp", "grid", "Lat", "kt", "ats", "rt", "str", "pos", " latitude", "apt", "top", "sq", "x", "loc", "alt", "ct", "addr", "area", "height", "y", "st", "coord", "mat", "xy", "west", "south", "dist", "sat", "att", "ip"], "lon": ["ng", "on", "mag", "ino", "elong", "ong", "low", "ln", "las", "los", "l", "phy", "pos", "top", "lin", "x", "loc", "n", "fn", "vert", "lay", "lbs", "len", "lang", "lf", "lu", "lt", "west", "itude", "geon", "location", "lol", "ll", "zon", "local", "land"], "count": ["Count", "range", "th", "counter", "more", "cache", "number", "id", "search", "amount", "nt", "list", "current", "cond", "top", "size", "c", "found", "score", "n", "limit", "page", "ct", "num", "scroll", "batch", "frequency", "length", "last", "nb", "total", "sum", "max", "code", "start", "ount", "index", "call"], "req": ["inv", "aux", "pull", "friend", "rest", "init", "cert", "forge", "http", "cgi", "conf", "fail", "htt", "sql", "r", "comm", "err", "usr", "urg", "search", "pkg", "request", "quick", "reg", "rx", "forced", "dj", "mk", "sem", "Requ", "repl", "quest", "https", "send", "client", "proc", "sq", "tx", "qt", "wx", "org", "peer", "qq", "Request", "crit", "next", "q", "comp", "cmd", "resp", "compl", "ind", "require", "uj", "desc", "typ", "rr", "requ", "sub", "ps", "jp", "dist", "rd", "gr", "res", "cur", "rel", "pr", "j", "hr", "fr", "pas"], "gl": ["ls", "gs", "dl", "tl", "gold", "gm", "gb", "wal", "list", "bl", "tf", "l", "Gl", "fl", "ogl", "gn", "cl", "gel", "nl", "lor", "balls", "hl", "acl", "gc", "ibl", "GL", "abl", "rl", "illas", "il", "gall", "ger", "igl", "als", "wl", "gif", "console", "spring", "vl", "g", "pl", "ml", "gr", "jl", "bel", "lol", "rel", "ll", "bal", "gz", "sl"], "br": ["b", "bro", "dr", "vr", "lr", "bp", "r", "be", "FR", "bl", "sr", "rb", "str", "browser", "pr", "bi", "ber", "bg", "kr", "arr", "shr", "er", "BR", "tr", "sp", "el", "cr", "ch", "wr", "bh", "Br", "buf", "yr", "gr", "bt", "mr", "bm", "hr", "fr"], "line": ["message", "LINE", "range", "header", "block", "liner", "iter", "check", "display", "user", "note", "channel", "lo", "error", "ln", "file", "stroke", "l", "frame", "ine", "string", "eline", "cell", "str", "link", "inline", "trace", "lin", "entry", "rule", "train", "word", "stream", "n", "row", "page", "le", "label", "Line", "el", "msg", "valid", "sequence", "console", "text", "body", "style", "e", "log", "chain", "stay", "edge", "print", "code", "sample", "comment", "phrase", "lane", "point"]}}
{"id1": "3731077", "id2": "6403868", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpDirectory", " cpFiles", "copyFiles", " cpFile", "CopyDirectory", "CopyFile", "downloadfile", "downloadDirectory", "CopyFiles", "downloadFile", " cpfile", "downloadFiles", "copyDirectory", "Copyfile", "copyfile"], "from": ["path", "range", "From", "at", "or", "input", "with", "url", "query", "info", "f", "file", "config", "bean", "star", "add", "s", "se", "str", "link", "before", "what", "string", "original", "as", "html", "org", "origin", "term", "without", "source", "a", "orig", "pro", "por", "part", "old", "st", "view", "ol", "form", "rom", "by", "so", "of", "local", "start", "base", "data", "name", "db", "vol", "fr", "reset", "un"], "to": ["dest", "pt", "th", "full", "or", "template", "tt", "on", "it", "f", "that", "output", "two", "nt", "toc", "file", "html", "t", "bo", "pretty", "oto", "To", "top", "org", "too", "ta", "eto", "size", "etc", "one", "null", "tu", "this", "tom", "TO", "tree", "token", "st", "target", "te", "phi", "none", "po", "parent", "by", "no", "temp", "must", "co", "into", "total", "o", "auto", "base", "name", "table"], "parentDir": ["ParentFile", " parentFile", "netFolder", "rootFolder", "masterDir", "masterFile", "Parentdir", "parentDirectory", " parentDirectory", "parentdir", "rootdir", "netDir", "ParentDir", "masterDirectory", "parentFolder", "ParentDirectory", "masterFolder", "ParentFolder", "parentFile", " parentdir", "rootFile", " parentFolder", "netdir", "rootDir", "netFile"], "in": ["In", "is", "init", "sin", "net", "on", "conf", "input", "rin", "it", "win", "id", "al", "all", "update", "ain", "ma", "IN", "config", "inn", "irc", "inside", "inf", "bin", "ri", "vin", "ir", " IN", "ins", "one", "source", "mc", "inc", "mi", "en", "ini", "up", "xml", "ind", "din", "form", "mm", "isin", "min", "get", "re", "cin", "con", "i", "gin", "raw", "inner", "print", "o", "local", "doc"], "out": ["b", "obj", "css", "ex", "at", "or", "net", "OUT", "ou", "on", "it", "all", "write", "err", "output", "nt", "ion", "file", "ln", "list", "t", "cos", "oss", "client", "again", "gt", "c", "Out", "n", "one", "null", "os", "go", "cn", "gc", "cmd", "io", "ne", "sys", "op", "outs", "conv", "g", "na", "no", "nin", "con", "i", "co", "can", "aos", "o", "v", "outer", "res", "ot", "auto", "vol", "ro", "ns"], "ic": ["ics", "it", "tc", "aic", "ci", "sic", "icon", "mic", "fc", "pc", "bc", "rc", "isc", "ix", "cc", "ik", "c", "nic", "ins", "inc", "ac", "icc", "ric", "wic", "arc", "cus", "ican", "ico", "tic", "cu", "iu", "vc", "iac", "cin", "i", "co", "eric", "IC", "ot", "pic", "irc", "ip", "icy"], "oc": ["ucc", "aco", "ocr", "alloc", "tc", "ci", "aic", "oe", "oco", "toc", "mic", "pc", "cos", "ocon", "OC", "c", "ict", "nic", "roc", "ac", "gc", "oly", "arc", "ric", "og", "unc", "cus", "voc", "oci", "ico", "mot", "nc", "soc", "oca", "cu", "ox", "vc", "ec", "yo", "co", "cot", "o", "anc", "ot", "osc", "pic", "irc", "oct"]}}
{"id1": "1097146", "id2": "3409084", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getContentdigests", "getContentDigest", "getContentDigested", "getContentdigested", "getMessageDecester", "getMessagedigested", "getContentDigester", "getMessagedigester", "getMessageDigester", "getContentDigests", "getMessageDecested", "getMessageDecest", "getMessageDigests", "getMessagedigests", "getMessageDigested", "getContentdigester", "getContentdigest", "getMessageDecests", "getMessagedigest"], "input": ["check", "empty", "value", "format", "human", "out", "it", "uu", "url", "qi", "address", "output", "file", "request", "config", "any", "quick", "unknown", "Input", "string", "focus", "image", "missing", "this", "source", "from", "q", "null", "p", "cmd", "in", "act", "pattern", "up", "char", "xml", "password", "initial", "valid", "msg", "state", "text", "qa", "form", "get", "raw", "buffer", "active", "cur", "sample", "data", "name", "hello", "required"], "md": ["ad", "cd", "dr", "dh", "mu", "ds", "mt", "grad", "nt", "MD", "m", "pm", "mp", "der", "mk", "hd", "managed", "mc", "df", "pd", "cmd", "dd", "def", "comp", "det", "cm", "sam", "mod", "pdf", "mm", "ld", "med", "bd", "od", "mn", "mb", "mand", "d", "sd", " Md", "mg", "ms", "di", "sm", "dm"], "bytes": ["b", "ls", "bags", "pieces", "strings", "files", "words", "clips", "keys", "binary", "versions", "users", "s", "forms", "rings", "reports", "bps", "parts", "ings", "groups", "tes", "bits", "bs", "Bytes", "classes", "outs", "windows", "steps", "seconds", "bles", "units", "videos", "lines", "nets", "objects", "qs", "latest", "ms", "terms", "es", "values", "pages", "blocks"]}}
{"id1": "9109613", "id2": "3806532", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"fileCopy": ["fileUpload", " filecopy", "filecopy", "FileCopy", "doCopy", " fileCop", " fileUpload", "doUpload", "Filecopy", "fileCop", "FileCop", "docopy", "doCop", "FileUpload"], "from_name": ["fromptadmin", "from_world", " from_admin", " from_type", " from_names", " from_user", "fromptnames", " from_client", "from_client", "from__size", "from_names", "from_admin", "from_type", "to_world", " from_base", "to_case", " from_size", "from__name", "from_value", " from_no", " from__size", "from_no", "from_user", "from__names", " from__name", "from_size", "fromptname", "from_base", " from__names", "from_case", " from_value"], "to_name": ["intoNamecode", "toNamepath", "to_path", " to_Name", "toNamename", "intoNamepath", "to_names", "to_long", "intoNamenames", "into_num", " to_long", "into_names", "to_code", "toNamenames", " to_names", "to_num", "to_Name", "toNamecode", "into_name", "into_path", "intoNamename", "into_code"], "fromFile": [" fromLine", "toField", "onFile", "sentPage", " fromfile", " fromGlobal", "tofile", " fromTime", " fromPage", "entryFile", "onfile", "FromFILE", " fromFILE", "startFilename", "boundPlace", "orFile", "givenfile", " fromPlace", "newfile", "FromDo", " fromFiles", "smallPlace", "newFile", "fromLine", "smallFiles", "fromFilename", "fromField", "formFilename", "newGlobal", " fromDo", "Fromfile", "sentFile", "fromFiles", "newPage", "orTime", "entryName", "givenFile", "normalLine", "orPage", "formfile", "sentfile", "startfile", "fromfile", "normalFile", "boundFILE", "oldfile", "boundFile", "normalField", "smallFile", "FromFile", "fromDo", "oldFile", "FromLine", "formFile", "normalPage", "fromPage", "sentField", "fromGlobal", "toPage", "normalfile", "startName", "entryFilename", "onFILE", "fromName", "formName", "entryfile", "fromTime", "orLine", "givenGlobal", "oldDo", "startFile", "fromFILE", "boundFiles", "smallFILE", "fromPlace", "normalTime", "givenPage", "oldLine"], "toFile": ["ToTable", "toTable", "TOFile", "toSourceFile", "TOfile", "ToModel", "targetFile", "twoFiles", "fromTable", "tofile", "templateFile", "toFilename", "templateModel", "toProcess", "intoFiles", " toTime", "byfile", "toTime", "intoPort", "templateTable", "ToFile", " toPort", "intoMessage", "thatFile", "etoMessage", " toPlace", "toFiles", "twoPort", "thatDefault", " toFilename", "bySourceFile", "newfile", "toName", "targetDo", "newFile", "TOPath", " toTable", "twofile", "thatFILE", "toPlace", "twoFile", "toModel", "byPlace", "ToFILE", " toDefault", " toDo", "fromFiles", "targetFILE", " toPath", "etoDefault", "etoName", "fromPort", "etofile", "toPath", "TOSourceFile", "templateFILE", "ToFiles", "intoName", "targetPlace", "etoProcess", "TOTime", " tofile", "toDo", "targetTable", " toFiles", "toPort", "toMessage", "intoTable", " toFILE", "intoFile", "twoTime", "TOFiles", "TOPort", "newPlace", "Tofile", "newSourceFile", "toFILE", "twoPath", "fromMessage", "twoSourceFile", "fromName", "thatfile", " toSourceFile", "targetModel", "etoFile", "toDefault", "ToFilename", "TOPlace", "fromProcess", "intoProcess", "byFile", "etoFILE"], "parent": ["path", "tip", "my", "where", "prop", "id", "component", "tar", "home", "filename", "mt", "tmp", "file", "ma", "m", "parents", "instance", "per", "params", "central", "pos", "directory", "root", "origin", "peer", "mother", "pid", "rule", "family", "this", "source", "null", "page", "host", "p", "def", "Parent", "unit", "global", "layout", "up", "tree", "master", "owner", "sp", "paren", "spec", "folder", "exp", "uid", "desc", "position", "snap", "form", "port", "temp", "remote", "shape", "chain", "event", "module", "server", "man", "holder", "pi", "timeout", "name", "prefix", "point", "pool", "ip", "child"], "dir": ["dev", "path", "iter", "dep", "cd", "dr", "dl", "init", "or", "out", "DIR", "ds", "wd", "vol", "del", "red", "tmp", "file", "fd", "cond", "direct", "md", "str", "directory", "fin", "Dir", "ir", "dc", "loc", "crit", "dd", "def", "good", "coll", "addr", "det", "dict", "odd", "rec", "tr", "div", "mod", "folder", "ind", "dim", "dist", "cont", "module", "d", "cur", "rel", "db", "di"], "from": ["user", "From", "ce", "com", "check", "or", "empty", "init", "on", "store", "out", "input", "query", "with", "false", "clean", "and", "left", "back", "link", "before", "pos", "client", "entry", "origin", "c", "window", "fun", "stream", "term", "source", "orig", "ent", "en", "in", "sent", "initial", "bound", "old", "st", "set", "style", "form", "by", "min", "no", "con", "only", "so", "inner", "local", "start", "ra", "create", "base", "vol", "fr", "reset", "normal"], "to": ["or", "title", "on", "ts", "out", "lo", "with", "write", "tg", "output", "that", "two", "toc", "t", "done", "news", "about", "pretty", "client", "To", "top", "tto", "too", "ta", "eto", "test", "this", "null", "go", "tom", "TO", "tree", "please", "token", "target", "te", "writer", "po", "by", "no", "phi", "ato", "so", "co", "total", "into", "can", "o", "pi", "auto", "base", "tty", "table"], "buffer": ["message", "block", "template", "device", "parse", "cache", "number", "binary", "database", "paste", "stroke", "frame", "append", "queue", "entry", "character", "memory", "window", "Buffer", "row", "word", "page", "batch", "char", "initial", "document", "attribute", "command", "bar", "result", "sequence", "length", "stack", "temp", "buf", "event", "available", "base", "sample", "buff", "phrase", "comment", "button", "table", "variable"], "bytes_read": ["Bytes_have", "bytes_q", "Bytes_read", "bytes5need", "bytes5read", "bytes2read", "Bytes_q", "bytes__read", "bytes_have", "bytes__find", "bytes2need", "bytes5Read", "bytes_write", "Bytes_need", "bytes_find", "bytes2Read", "Bytes_Read", "bytes_Read", "bytes__write", "Bytes_write", "bytes_need", "bytes5write", "bytes__q", "Bytes_find", "bytes2write"]}}
{"id1": "3683344", "id2": "14785308", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"genRandomGUID": [" genRandomSuid", " genRandUU", " genRandomGuid", " genRandGU", " genRandGUID", " genRandomRandomuid", " genRandomGID", " genRandGID", " genRandomUUID", " genRandUID", " genRandomUU", " genRandGuid", " genRandomRandomUID", " genRandomSID", " genRandomRandomU", " genRandomSUID", " genRandUUID", " genRandUuid", " genRandomSU", " genRandomRandomID", " genRandomGU", " genRandomUID", " genRandomUuid"], "secure": ["check", "weak", "quiet", "id", "force", "speed", "sync", " securely", "free", "encrypted", "sec", "sr", "protect", "stable", "pretty", "https", "safe", "client", "google", "confirmed", "domain", "strong", "close", "prime", "trust", "sys", "sensitive", "clear", "status", "ie", "deep", "nice", "ssl", "active", "server", "security", " Secure", "Secure", " insecure"], "valueBeforeMD5": ["valueUnderMM5", "valueUnderMM25", "valueBeforeSHA523", "valueAfterMD0", "valueBeforeND0", "valueBeforeMT25", "valueAfterMDInvalid", "valueBeforeMT2", "valueAfterMD3", "valueBeforeMD523", "valueBeforeMD4", "valueBeforeMT0", "valueAfterDER5", "valueAfterMD4", "valueBeforeMOD2", "valueBeforeID2", "valueUnderMD0", "valueBeforeMODFive", "valueBeforeND3", "valueBeforeDER5", "valueAfterND5", "valueBeforeMM0", "valueBeforeSHA2", "valueBeforeMDInvalid", "valueBeforeDER2", "valueBeforeMD2", "valueBeforeID4", "valueUnderMM0", "valueBeforeND2", "valueAfterND3", "valueBeforeRD5", "valueBeforeMD0", "valueAfterND4", "valueBeforeID3", "valueBeforeSHAInvalid", "valueBeforeMD25", "valueBeforeMTFive", "valueBeforeRDInvalid", "valueAfterND2", "valueBeforeMM25", "valueBeforeRD523", "valueBeforeDERFive", "valueBeforeND25", "valueBeforeMM5", "valueBeforeDER0", "valueBeforeRD2", "valueAfterDERFive", "valueUnderMD25", "valueAfterMD523", "valueBeforeMD3", "valueBeforeND5", "valueAfterDER0", "valueAfterMD2", "valueAfterDER2", "valueBeforeMDFive", "valueBeforeMT5", "valueUnderMD5", "valueBeforeND4", "valueBeforeSHA5", "valueBeforeID5", "valueBeforeMOD5", "valueBeforeMOD0", "valueAfterMDFive"], "valueAfterMD5": ["valueAfterMD55", "valueAfterMC5", "valueAfterCD2", "valueAfterMIPE", "valueAfterEMLeft", "valueAfterMM3", "valueAfterMDLeft", "valueAfterMM4", "valueAftermdPE", "valueBeforeMDRL", "valueAfterMDOK", "valueWithoutMDOK", "valueAfterMTdown", "valueWithoutmd2", "valueAfterMD3", "valueAfterMCdown", "valueBeforeMD4", "valueAfterMI2", "valueAfterMD4", "valueWithoutMDPE", "valueBeforeMM4", "valueBeforeMD8", "valueAfterMDPE", "valueafterEM55", "valueBeforeMC5", "valueAfterSD3", "valueafterEM2", "valueAfterUD3", "valueAfterUD5", "valueWithoutmdPE", "valueBeforeMD2", "valueAfterMDdown", "valueBeforeMC2", "valueafterMD2", "valueBeforeMDdown", "valueAftermd2", "valueAfterMT8", "valueAfterSDODY", "valueAfterMC8", "valueafterMD5", "valueBeforeMCdown", "valueafterMD55", "valueAfterCD5", "valueAftermd5", "valueafterEMLeft", "valueafterMDLeft", "valueAftermdOK", "valueAfterEM2", "valueWithoutmd5", "valueAfterMC4", "valueAfterSD5", "valueAfterMC3", "valueAfterMT2", "valueWithoutmdOK", "valueAfterEM55", "valueBeforeMM5", "valueAfterMM5", "valueAfterUDODY", "valueafterEM5", "valueAfterMI5", "valueAfterMTLeft", "valueAfterMT5", "valueAfterMD8", "valueAfterUDRL", "valueBeforeMD3", "valueAfterMT55", "valueAfterMM2", "valueAfterMIOK", "valueAfterMD2", "valueAfterEM5", "valueAfterMT3", "valueAfterMDODY", "valueBeforeMM3", "valueAfterMDRL", "valueWithoutMD5", "valueBeforeMM2", "valueAfterCDdown", "valueAfterMC2", "valueBeforeMDODY", "valueAfterSDRL", "valueWithoutMD2"], "md5": ["metadata25", "dig3", " MD3", "MD3", "dig2", " md3", "md3", "metadata3", "metadata5", "MD2", " md25", "MD7", " MD2", " MD7", "MD5", "md2", "md25", "metadata2", "md7", " md7", "dig5", " MD5", " md2", "MD25"], "sbValueBeforeMD5": ["sbValueBeforeLM2", "sbValueBeforeMD45", "sbValueAfterMD05", "sbValueBeforeMD2", "sbValueBeforeMED25", "sbValueBeforePD5", "sbValueBeforemd5", "sbValueInsideMD305", "sbValueBeforePD2", "sbValueInsideAMD5", "sbValueBeforemd2", "sbValueFrontMD65", "sbValueInsideMD5", "sbValueBeforeMED45", "sbValueBeforeND5", "sbValueBeforeSDNot", "sbValueBeforeMON5", "sbValueFrontMD20", "sbValueFrontMD2", "sbValueBeforeAND5", "sbValueAfterMD5", "sbValueBeforeMED5", "sbValueAfterMS25", "sbValueDefMD5", "sbValueFrontLM5", "sbValueBeforeMDLE", "sbValueBeforeMON512", "sbValueBeforeMT2", "sbValueAfterMS3", "sbValueBeforeAMD305", "sbValueBeforeMD3", "sbValueBeforeMTFive", "sbValueBeforeMED2", "sbValueBeforeMT65", "sbValueBeforemd45", "sbValueBeforeAND2", "sbValueBeforeMOD45", "sbValueBeforeSD5", "sbValueAfterMDFive", "sbValueBeforeND2", "sbValueAfterMDLE", "sbValueAfterMS5", "sbValueBeforeMEDNot", "sbValueDefMD45", "sbValueBeforeSD2", "sbValueBeforeMD05", "sbValueBeforeMED3", "sbValueBeforeMT5", "sbValueBeforeMS3", "sbValueInsideAMD512", "sbValueBeforeMS45", "sbValueBeforemdLE", "sbValueBeforeND45", "sbValueAfterMS45", "sbValueFrontLM2", "sbValueInsideAMD305", "sbValueInsideAMD2", "sbValueBeforeLM20", "sbValueBeforeAND05", "sbValueAfterMD45", "sbValueFrontMD5", "sbValueBeforeMOD25", "sbValueBeforeMT05", "sbValueAfterMD2", "sbValueFrontLM20", "sbValueBeforeLM65", "sbValueBeforeMS5", "sbValueBeforeMDNot", "sbValueAfterMDNot", "sbValueBeforeMDOK", "sbValueDefmd45", "sbValueBeforeMOD5", "sbValueBeforeMON2", "sbValueFrontLM65", "sbValueDefmd2", "sbValueBeforeMD65", "sbValueInsideMD512", "sbValueBeforeAMD5", "sbValueAfterMD25", "sbValueBeforeMT20", "sbValueBeforeLM5", "sbValueBeforeMDFive", "sbValueDefMD2", "sbValueInsideMD2", "sbValueBeforeMD20", "sbValueBeforeMOD3", "sbValueBeforeANDFive", "sbValueBeforeMD512", "sbValueBeforePDLE", "sbValueBeforeMD25", "sbValueBeforemdOK", "sbValueBeforeAMD512", "sbValueAfterMDOK", "sbValueBeforeMS25", "sbValueBeforePDOK", "sbValueAfterMD3", "sbValueBeforeMD305", "sbValueBeforeAMD2", "sbValueBeforeMON305", "sbValueDefmd5"], "time": ["user", "counter", "value", "TIME", "ts", "id", "tc", "runtime", "times", "etime", "t", "frame", "hour", "lock", "age", "size", "system", "ty", "window", "estamp", "year", "tim", "clock", "sequence", "length", "Time", "port", "race", "ime", "duration", "timer", "event", "date", "total", "now", "start", "timeout", "name", "order", "rate"], "rand": ["inv", "nd", "ng", "range", "rest", "dr", "mid", "init", "id", "rss", "with", "r", "pick", "z", "grad", "nt", "std", "reg", "and", "roll", "seed", "rc", "rt", "md", "kick", "gt", "pid", "random", "rank", "did", "sid", "rid", "trust", "sys", "cr", "uid", "round", "ripp", "rh", "dist", "rot", "rd", "max", "frac", "res", "sample", "hash", "gz", "Rand", "rate", "fine"], "array": ["ami", "external", "range", "collection", "at", "storage", "value", "number", "audio", "Array", "binary", "ary", "save", "amount", "list", "instance", "map", "ash", "app", "ashes", "string", "vector", "our", "aster", "random", "row", "share", "arr", "batch", "angle", "area", "archive", "upper", "length", "stack", "stage", "arrow", "RAY", "ray", "aw", "v", "assets", "rays", "hash", "data", "angular", " Array", "atomic", "var"], "strTemp": [" strTem", "hexCmd", "stringTest", "strtemp", "brTemplate", "stringTemp", "txtTemp", "arrMods", "stringPtr", "frPtr", "strTest", "arrTem", "stringUnt", "STRTem", "brTem", " strUnt", "strNew", " strNew", "frTemplate", "strCmd", "strUnt", "STRNew", "strTem", " strCmd", "frTemp", "txtTr", "brTemp", "arrPtr", " strTemplate", "stringTem", " strtemp", "stringMods", "txtTem", "drMods", " strTest", "arrUnt", "arrNew", "drTemp", "hexTr", "STRtemp", "brPtr", "drPtr", "strTemplate", "arrTest", "STRTemp", "hexTemp", "strMods", "strPtr", "strTr", "frTem", " strTr", "arrTemp", " strPtr", "arrtemp", "txtCmd", "hexTem", "drTem"], "i": ["b", "ogi", "init", "us", "gi", "id", "qi", "xi", "it", "info", "\u0438", "ci", "li", "I", "m", "ai", "ix", "iq", "hi", "gu", "x", "bi", "c", "ki", "ii", "a", "q", "u", "multi", "mi", "uri", "num", "ic", "in", "index", "y", "ind", "im", "phi", "sim", "ji", "chain", "si", "yi", "v", "ei", "pi", "ti", "cli", "name", "j", "ui", "di", "ini"]}}
{"id1": "8385785", "id2": "873012", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"MD5": [" MD2", " mdHash", "SHA5", " MD3", "SHA2", " md3", "MDHash", "MD3", " md5", "SHA3", " MDHash", " md2", "MD2", "SHAHash"], "text": ["message", "path", "read", "pt", "value", "format", "title", "out", "input", "aut", "url", "subject", "select", "output", "translation", "nt", "context", "t", "string", "str", "tx", "test", "x", "ext", "TEXT", "word", "term", "txt", "source", "q", "ct", "act", "pattern", "password", "document", "command", "msg", "form", "log", "buffer", "event", "content", "print", "code", "now", "Text", "data", "name", "prefix", "comment"], "UnsupportedEncodingException": ["UnsupportedEncodedError", "UnsupportedEncodedEx", "UnsupportedDecoderException", "UnsupportedEncoderException", "UnsupportedEncodedException", "UnsupportedEncoder ", "UnsupportedEncode ", "UnsupportedDecoder ", "UnsupportedEncoded ", "UnsupportedEncoderError", "UnsupportedEncodeError", "UnsupportedEncodeEx", "UnsupportedEncoderEx", "UnsupportedDecoding ", "UnsupportedEncodingError", "UnsupportedEncodeException", "UnsupportedDecoderEx", "UnsupportedDecoderError", "UnsupportedEncodingEx", "UnsupportedDecodingError", "UnsupportedDecodingEx", "UnsupportedDecodingException", "UnsupportedEncoding "], "md": [" def", "nd", "ad", "pt", " med", "dr", "mond", " mk", " dist", " img", "mt", "red", "MD", "m", "mp", "pkg", "grad", "dir", " ok", " del", "mk", "der", "add", "rm", "ctr", " sch", "hd", " df", "df", " rand", "Cmd", "h", "dd", "cmd", "pd", " cmd", "det", " exec", " doc", "ind", "mod", " done", " man", "mm", " de", "ld", "bd", "dig", "mail", "od", " ind", "mn", "mb", "deep", "mand", "d", "sd", " cd", "hash", "mg", "ms", "di", "dm"], "md5hash": ["MD2sum", "md2sum", "md3hex", "md4Hash", "MD5sum", "md3Hash", "md4hex", "md3index", " md4hex", " md3Hash", "md2Hash", "md3sum", " md3h", "md3key", "md5index", "md3h", "md7sum", "MD5Hash", "MD2hash", "md5h", " md4key", " md5Hash", "md5hex", "md5Hash", "md512key", "md7h", "md7hash", " md5h", "md4key", " md5sum", " md3sum", "md4index", "md4h", "md5key", "md512hex", "md2hash", "md512hash", "MD2Hash", " md5hex", "md4sum", "md5sum", "md4hash", "md512index", " md5index", "md2h", "md7Hash", "md3hash", " md3hash", "MD5h", "MD5hash", " md4index", " md4hash", " md5key", "MD2h"]}}
{"id1": "10936821", "id2": "19667000", "code1": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "code2": "    public static Reader getReader(String url) throws MalformedURLException, IOException {\n        if (url.startsWith(\"file:\")) return new FileReader(url.substring(5)); else if (url.startsWith(\"http:\")) return new InputStreamReader(new URL(url).openStream());\n        throw new MalformedURLException(\"Invalid URI schema, file: or http: expected.\");\n    }\n", "label": 0, "substitutes": {"doIt": ["DoIt", " doThis", " doWhatever", "makeThis", "makeWhatever", " doWhat", "doThis", "DoThis", "makeIt", "DoWhat", "DoWhatever", "doWhat", "makeWhat", "doWhatever"], "client": ["template", "net", "http", "cache", "secure", "url", "force", "api", "Client", "lib", "wrapper", "open", "core", "quick", "phone", "network", "cell", "cl", "cc", "web", "google", "key", "cloud", "close", "ct", "cmd", "control", "to", "pattern", "util", "cm", "console", "socket", "dial", "parent", "remote", "conn", "con", "ssl", "connection", "resource", "co", "server", "contact", "local", "response", "cli", "connect", "simple", "utils", "channel", "service", "pool", "call"], "ff": ["nd", "pp", "ph", "xff", "fact", "uf", "ft", "ffer", "aft", "fd", "bf", "fp", "fc", "tf", "fo", "cb", "eff", "tif", "cl", "fx", "FF", "df", "aff", "af", "dd", "off", "fi", "lf", "ef", "fg", " fid", "sf", "ck", "fm", "cf", "buff", "uff", "alf"], "jfc": ["Jmc", "jlc", "tFC", "qfc", "qFC", "tpc", "ffc", "npc", "lvc", " jlc", "flc", "lcf", "qcf", "jsfc", "jmc", "Jcf", "jsmc", "jFC", "tcf", " jFC", " jcf", "fcf", "Jpc", "nfc", "ncf", "jpc", " jpc", "llc", "lfc", " jvc", "tfc", "qpc", "jsFC", "jspc", "fvc", "Jfc", "jcf", "JFC", "jvc", " jmc", "nFC"], "f": ["b", "xf", "fs", "file", "fd", "bf", "m", "fc", "tf", "t", "l", "inf", "fo", "c", "fx", "df", "p", "h", "rf", "fi", "lf", "F", "w", "fab", "ef", "g", "fg", "e", "only", "i", "sf", "fa", "v", "cf"], "selection": ["binding", " selected", "slot", "icing", "where", " selecting", "ing", "search", "ION", "select", "finding", "SELECT", "ion", "election", "wa", "opening", "lection", "focus", "pling", "which", "from", "xxx", " Selection", "state", "soc", "position", "ification", "reading", "sea", "sel", "elect", "connection", "something", "location", "security", "choice", "selected"], "msg": ["message", "gs", "init", "conf", "gm", "mu", "info", "comm", "pkg", "task", "map", "alg", "mk", "news", "md", "str", "irm", "summary", "html", "nm", "wx", "mess", "bg", "crit", "txt", "cmd", "resp", "dm", "og", "gent", "cmp", "sys", "notice", "Msg", "desc", "cal", "body", "g", "mail", "log", "mn", "mb", "gr", "sum", "ck", "print", "mem", "comment", "mg", "ms", "sg", "sm", "doc", "cfg"]}}
{"id1": "11032546", "id2": "16142024", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"testCopyUnknownSize": [" testCopyDifferentsize", " testCopyKnownShape", " testcopyUnknownSize", " testCopyKnownsize", " testCopyKnownSize", " testCopyunknownLength", " testcopyUnknownShape", " testcopyKnownShape", " testcopyUnknownsize", " testCopyUnknownShape", " testCopyDifferentShape", " testCopyunknownsize", " testcopyKnownLength", " testCopyunknownSize", " testCopyKnownLength", " testCopyUnknownsize", " testcopyKnownsize", " testCopyunknownShape", " testcopyUnknownLength", " testcopyKnownSize", " testCopyUnknownLength", " testCopyDifferentSize", " testCopyDifferentLength"], "in": ["inv", "In", "is", "sin", "on", "input", "it", "rin", "al", "r", "ain", "file", "IN", "inn", "l", "inside", "inf", "bin", "ins", "source", "from", "null", "en", "up", "copy", "ind", "din", "mm", "isin", "log", "cin", "con", "i", "gin", "inner", "data"], "out": ["inv", "b", "user", "ex", "obj", "check", "at", "or", "OUT", "net", "ou", "on", "all", "it", "err", "output", "list", "t", "client", "gt", "Out", "n", "one", "null", "end", "a", "os", " OUT", "cmd", "to", "up", "io", "outs", "result", " Out", "OU", "by", "log", "con", "gr", "co", "sum", "aos", "res", "auto", "o", "data"], "cpySize": ["cdyCount", "Cplysize", "cplyLength", "Cpysize", " cplyCount", " cpysize", "cpeSize", " cpyCount", "cdysize", " cplysize", "cfiLength", "cpesize", "CpyLength", "CplySize", "CplyCount", "cpyCount", "cpeCount", " cplySize", "cpeLength", "cfiSize", "cfisize", "CplyLength", "cpyLength", "CpySize", "cpysize", "cdyLength", "cplysize", "cplyCount", "cfiCount", " cplyLength", "cplySize", " cpyLength", "CpyCount", "cdySize"], "outArray": [" outString", "outStream", "listArea", "inArray", "outString", "listArray", "OUTObject", "OUTarray", " outarray", "outObject", "listImpl", "inString", "outImpl", "nearray", "outarray", "inImpl", "inArea", "listString", " outArea", " outStream", "neArray", "OUTArray", " outObject", " outImpl", "neObject", "outArea", "neStream", "OUTStream"]}}
{"id1": "6301863", "id2": "1180878", "code1": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "code2": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doRawRequest": ["doNativeAction", "doHttpQuery", "doHttpAction", "sendRawCall", "doHttpRequest", "doRawAction", "doDirectCall", "sendRawRequest", "doNativeQuery", "sendHttpCall", "sendHttpAction", "doRawQuery", "sendRawQuery", "doHttpCall", "doNativeCall", "doDirectRequest", "doRawCall", "doDirectAction", "doDirectQuery", "doNativeRequest", "sendRawAction", "sendHttpRequest", "sendHttpQuery"], "postData": ["PostData", "requestBody", "postdata", "preMessage", "postedMessage", "POSTBody", "postMessage", "postBody", " postString", "postString", " postdata", "requestData", "postedData", " postMessage", "postDATA", "POSTDATA", "posteddata", "preDATA", "Postdata", "requestDATA", "preData", "POSTData", "PostMessage", "preBody", "POSTMessage", "PostString", "postedString", "requestMessage"], "url": ["ls", "sl", "dl", "cert", "http", "URL", "pkg", "abs", "l", "ur", "link", "str", "https", "gl", "client", "google", "web", "org", "nl", "loc", "hl", "lb", "mount", "uri", "cmd", "addr", "ret", "ld", "mail", "Url", "re", "build", "con", "ssl", "ul", "bel", "rel", "ll", "pl", "www"], "conn": ["inv", "pt", "com", "Conn", "net", "cert", "open", "comm", "nt", "col", "l", "exec", "client", "cb", "gn", "org", "c", "fin", "loc", "close", "cp", "nec", "cn", "ct", "cmd", "resp", "addr", "canon", "act", "nc", "sys", "iw", "ch", "enc", "conv", "con", "jp", "ssl", "connection", "cont", "syn", "res", "cur", "rel", "connect", "j", "pg", "ns", "pas"], "wr": ["dr", "wy", "spr", "vr", "wp", "lr", "wid", "write", "wd", "r", "wm", "wn", "mk", "wer", "pr", "wx", "Wr", "rou", "tn", "rew", "kr", "rw", "writ", "WR", "fw", "iw", "vet", "w", "wt", "writer", "kl", "Writer", "dx", "RW", "wb", "nw", "sw", "mr", "wk", "hr", "fr"], "rd": ["nd", "rect", "rob", "rer", "nder", "dr", "erd", "ptr", "rog", "ro", "r", "red", "rx", "sr", "reader", "rc", "rt", "rb", "RD", "pr", "ri", "rpm", "rar", "rs", "rw", "rn", "dd", "rid", "rl", "rend", "cr", "rr", "rod", "ld", "rh", "ra", "rand", "mr", "ry", "ru", "hr", "fr", "adr"], "sb": ["b", "rob", "sth", "ib", "bp", "gb", "RB", "bf", "sv", "bis", "abs", "rb", "bj", "obb", "SB", "bps", "sq", "cb", "bg", "erb", "lb", "gc", "bs", "lbs", "bag", "obs", "sh", "zb", "sp", "gob", "bh", "eb", "nb", "bn", "bd", "bb", "bsp", "mb", "si", "sf", "sa", "sd", "xb", "bt", "kb", "lp", "ob", "sg", "sm", "pb"], "line": ["message", "LINE", "block", "header", "liner", "check", "display", "number", "file", "ln", "list", "inline", "l", "ine", "frame", "string", "eline", "cell", "link", "zone", "stroke", "lin", "entry", "nl", "rule", "word", "row", "page", "le", "label", "pe", "Line", "valid", "sequence", "text", "style", "e", "log", "entity", "ice", "buffer", "stay", "chain", "print", "code", "sample", "name", "comment", "point", "phrase"]}}
{"id1": "1798720", "id2": "13012591", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "label": 0, "substitutes": {"save": ["init", "install", "accept", "store", "register", "update", "download", " Save", "filename", "Save", "pkg", "zip", "send", "release", " seal", "dump", "archive", "version", "saving", "folder", "delete", "upload", "aw", "export", "pack", "data"], "packageName": ["pkgType", " packageNames", "moduleCode", "pkgCode", "moduleName", "pkgKey", " packagename", "pkgNames", " packageKey", "moduleNames", "PackageNames", "moduleId", "packageKey", " packageType", "packageNames", "pkgname", " packageId", " packageCode", "packageCode", "packageType", "modulename", "pkgId", "pkgName", "PackageName", "PackageType", "PackageId", "packagename", "moduleKey", "packageId"], "fileContents": ["fileBytes", " fileBytes", "fileItems", "FileContent", "pageNames", " fileIngredients", "fileIngredients", " fileValues", "packageContents", "pageItems", "byteContent", "FileValues", "FileItems", "packageNames", "byteNames", "pageContents", "pageBytes", "FileBytes", "FileNames", "packageContent", "packageIngredients", "byteContents", "fileValues", "byteValues", " fileItems", " fileContent", "fileContent", "FileContents", "FileIngredients"], "fileNames": ["moduleVaults", "issueContents", "resourceNames", "messageValues", "moduleName", "FileKeys", "resourceContents", " fileKeys", " fileTypes", " fileLeaks", "resourceTypes", "dirTypes", "resourceNumbers", " fileValues", "FileTypes", "fileNumbers", "dirNames", "messageNames", "fileLeaks", "moduleNames", "moduleContents", "FileName", "fileVaults", " fileVaults", "FileValues", "fileTypes", "fieldNumbers", " fileName", "fieldTypes", "dirLeaks", "messageKeys", "dirKeys", "issueVaults", "fileKeys", "fieldNames", "FileContents", "messageName", "FileNames", "issueNames", "fieldContents", "fileName", "issueName", "fileValues", "resourceValues", "FileLeaks", " fileNumbers"], "dirBase": ["folderBas", "pathBas", "DIRBase", "directorybase", "directoryBase", "DirBase", "DirBottom", "pkgbase", "pathbase", "pkgBase", "directorySet", " directoryBase", "dirBuilder", "DIRBuilder", "irBase", "folderBasic", "folderbase", "DIRBas", "directoryBasic", "dirbase", "directoryBas", "DirBuilder", "pathBasic", "irBas", "DirBas", "dirBottom", "dirBas", " directoryBuilder", " directoryBas", "irSet", "folderBase", "DIRBottom", "pkgSet", "pkgBas", " directoryBottom", "irbase", "dirSet", "dirBasic", "pathBase"], "packageDir": ["podD", "moduleDef", "pkgRel", "moduleFolder", "pkgDir", "installDir", "installD", "packageRel", "modulePath", "pkgFolder", "packagePath", "moduleRel", " packageD", "podDef", "podDir", "installDef", " packageDef", "installDist", " packageFolder", "podDist", " packageRel", " packagePath", " packageDist", "packageDist", "pkgDef", "packageD", "packageFolder", "moduleDir", "pkgPath", "packageDef"], "created": ["loaded", "creator", "developed", "founded", "registered", "activated", "ced", "produced", "provided", "associated", "TED", "printed", "present", "forced", " started", "checked", "recorded", "confirmed", "existent", "given", "defined", "started", "locked", "successful", "creat", "added", "raised", " generated", "reported", "called", "filled", "Created", "allowed", "mounted", "joined", "creation", "create", "arted", "installed", "made", "released", "ready", "generated"], "currentPath": ["recentPoint", "recentPath", "currentPoint", "CurrentCh", "currentName", "currentlyPath", " currentName", "currentlyCh", "CurrentParent", " currentCh", "recentParent", "recentName", " currentPoint", " currentParent", "currentParent", "currentlyFile", "currentCh", "CurrentPoint", "currentlyName", "CurrentName", " currentFile", "CurrentFile", "currentFile", "CurrentPath"], "i": ["my", "xi", "mu", "info", "f", "I", "ai", "ix", "iq", "hi", "ri", "p", "mi", "u", "batch", "jj", "phi", "iu", "v", "ei", "o", "status", "ip", "ij", "ex", "init", "cgi", "id", "oi", "ki", "key", "ii", "os", "multi", "ic", "in", "sim", "chain", "zi", "ti", "ui", "ini", "qi", "ci", "li", "m", "iy", "this", "them", "major", "ind", "exp", "im", "ie", "g", "cli", "j", "index", "di", "ami", "gi", "it", "ski", "iii", "bi", "q", "go", "uri", "y", "slice", "ity", "ji", "me", "si", "yi", "pi"], "file": ["path", "header", "template", "format", "type", "info", "f", "dir", "l", "link", "fo", "rule", "row", "source", "le", "page", "p", "h", "ile", "handle", "io", "handler", "set", "body", "port", "FILE", "parent", "log", "disk", "buffer", "sf", "resource", "et", "local", "base", "play", "name", "comment", "db", "File", "pool", "table", "child"], "fos": ["flos", "oos", "ffoes", " foses", "oow", " foes", "fbaos", "fbos", "ffaos", "fbow", "Foes", "fo", "foses", "Fo", "Foss", "foss", "FOS", "ffo", "fOS", "sfoss", "fow", "floes", "floss", " fow", "Faos", "flo", "ffos", " foss", "wos", "oo", "woes", "fbo", "foes", "woss", "faos", " fo", "sfOS", "oaos", "woses", "floses", " fOS", "sfaos", "flaos", "Fos", " faos", "sfos"], "fileSrc": ["jobNci", "fileDsrc", "fileInsRC", "fileDrc", "fileDci", " fileSsrc", "jobSrc", "fileNci", "fileErc", "jobSci", "fileSRC", "jobNrl", "fileSci", "fileDource", "jobSri", "fileSource", "fileInsrc", "fileSsrc", " fileInsrc", "fileErl", "fileEri", "fileDrl", "fileEci", "fileInRC", " fileSRC", "fileSrl", "fileDri", "fileDRC", " fileSource", " fileInssrc", "jobNri", " fileInsRC", " fileInsource", "fileNrl", "fileInource", "fileInsource", "jobNrc", "fileSri", "fileInssrc", "fileNrc", "jobSrl", "fileNri", "fileInrc"], "fileDst": ["fileNld", "filedld", "fileNnd", "fileDnd", "fileDpl", "FileSst", "fileDot", "fileWpl", "FileDlt", "FileSot", "fileWst", "fileSpl", "FileDpl", "fileSlt", "fileNot", "fileDld", "filedst", "FileSpl", "fileNlt", "FileScr", "FileDld", "fileSnd", "fileScr", "fileNpl", "filednd", "fileSot", "fileDlt", "fileSst", "FileDst", "fileDcr", "fileNst", "FileDot", "fileNcr", "FileSld", "FileSlt", "filedcr", "FileSnd", "FileDcr", "fileWlt", "FileDnd", "fileWot", "fileSld"], "reader": ["read", "driver", "rer", "iter", "Reader", "dr", "review", "query", "r", "context", "author", "rx", "actor", "rc", "parser", "loader", "entry", "roller", "ri", "rar", "stream", "row", "ader", "rl", "er", "upper", "runner", "handler", "ner", "rr", "Larry", "reading", "controller", "iterator", "buffer", "rot", "resource", "inner", "ocker", "readable", "oder", "ler", "ro", "book"], "writer": ["wright", "read", "user", "driver", "iter", "liner", "Reader", "storage", "function", "creator", "format", "store", "draw", "query", "write", "wrapper", "writers", "editor", "parser", "player", "browser", "client", "walker", "loader", "builder", "test", "entry", "window", "word", "stream", "ter", "manager", "flush", "riter", "runner", "wire", "document", "caster", "handler", "console", "w", "writing", "report", "adder", "Writer", "worker", "iterator", "buffer", "server", "later", "print", "operator", "outer", "order", "maker", "println", "service", "table", "variable"], "line": ["LINE", "user", "range", "block", "liner", "message", "lined", "header", "number", "ln", "stroke", "frame", "ine", "inline", "link", "eline", "cell", "string", "record", "l", "entry", "lin", "nl", "rule", "continue", "word", "detail", "row", "page", "source", "le", "label", "pe", "Line", "valid", "ole", "sequence", "kin", "text", "style", "port", "entity", "chain", "edge", "date", "print", "code", "sample", "column", "comment", "point", "node"]}}
{"id1": "12197169", "id2": "1156851", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"read": ["init", " recover", " Read", "Read", "find", "download", "open", "reader", " request", "load", " reopen", "record", "stream", "next", "run", "close", " reads", "gc", " replay", " reader", "reading", "log", " download", "start", "connect", " seek", " ingest", "hello", " retrieve"], "in": ["In", "when", "message", "check", "is", "at", "or", "ill", "on", "conf", "out", "ing", "input", "it", "all", "url", "info", "r", "f", "with", "update", "al", "file", "IN", "inn", "reader", "and", "add", "l", "inf", "bin", "record", "again", "entry", "as", "stream", "ins", "run", "source", "from", "inc", "er", "io", "via", "body", "din", "isin", "by", "get", "log", "re", "cin", "con", " din", "inner", "during", "o", "name", "index", "ro"], "line": ["message", "path", "block", "liner", "LINE", "lo", "url", "file", "ln", "stroke", "l", "ine", "frame", "link", "eline", "cell", "string", "record", "inline", "se", "lin", "entry", "word", "stream", "row", "detail", "page", "le", "Line", "char", "part", "sequence", "text", "body", "e", "log", "chain", "piece", "code", "sample", "data", "comment", "point", "lane"], "i": ["iter", "is", "id", "qi", "xi", "ci", "li", "f", "z", "I", "m", "t", "l", "oi", "ai", "ix", "hi", "x", "bi", "c", "ii", "n", "p", "mi", "multi", "u", "to", "index", "y", "sequence", "ind", "im", "phi", "conv", "sim", "ori", "me", "si", "d", "zi", "ei", "pi", "base", "o", "ti", "cli", "v", "j", "di"], "logDatum": ["logDummy", "logBump", "Logdatum", "logdum", " logBummy", "logdata", "logDoictionary", "LogDatum", "logRump", " logDummy", "logBictionary", "logBummy", "logTratum", "logdatum", "logBatum", "logRummy", "logRictionary", "logTrummy", "logTrum", "logDoummy", "LogDummy", "logDump", "LogData", "logDoatum", "Logdummy", "logDum", "logDoump", "logDictionary", " logBictionary", "Logdum", " logBump", " logBatum", " logDictionary", "LogDum", "Logdata", " logDump", "logRatum", "logdummy", "logData", "logTrata"]}}
{"id1": "1421557", "id2": "14758866", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeStringToFile", "encodeFileToFiles", "encodeStringAsDisk", "encodeFileFromStream", "encodeFileFromDisk", "encodeStringAsFile", "encodeFileAsFiles", "encodeFiletoFile", "encodeFiletoFiles", "encodeStringToStream", "encodeFileAsFile", "encodeFileAsDisk", "encodeFileAsStream", "encodeFileFromFile", "encodeStringAsStream", "encodeStringToDisk", "encodeFiletoDisk", "encodeFiletoStream", "encodeStringToFiles", "encodeFileToStream", "encodeStringAsFiles", "encodeFileToDisk"], "infile": ["InFile", "inputfile", "outbase", "inbase", " inFile", "inFile", "outpath", "Inbase", "outFile", "Inpath", " infilename", "Infile", "outfilename", "infilename", "inpath", "inputpath", "inputfilename", "inputFile", " inpath", " inbase"], "outfile": ["inname", "newfile", " outname", "newname", "newfilename", "newFile", "inFile", "tofile", "todir", "fromfp", " outfilename", "infp", "outFile", "fromfile", "outdir", "indir", "fromdir", "tofp", "toFile", "outfp", " outFile", "outfilename", "infilename", "fromFile", "outname"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "image", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ro", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "null", "fn", "os", "en", "cn", "to", "flush", "up", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "can", "aos", "o", "res", "outer", "inner", "ot"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "queue", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "length", "black", "stack", "temp", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", "commit", "ccess", "cess", "value", "accept", "fail", "growth", "warning", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "ith", "successful", "good", "please", "ceed", "town", "result", "valid", " Success", "successfully", " okay", " failure", "ratulations", "photo", "sufficient", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "15241397", "id2": "5138455", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["doget", "DoGET", " doGET", " doget", "handleget", "DoGet", "doGET", "handleGET", " doPut", "handlePut", "handleGet", "doPut", "Doget", "DoPut"], "request": ["setup", "message", "transform", "user", "the", "http", "each", "QUEST", "input", "query", "application", "address", "context", "first", "reference", "current", "frame", "quest", "client", "req", "Request", "in", "forward", "initial", "attribute", "document", "command", "position", "report", "get", "re", "question", "complete", "connection", "server", "create", "start", "hello", "reset"], "response": ["reply", "message", "block", "ce", "http", "write", "application", "context", "output", "description", "session", "frame", "network", "send", "success", "answer", "onse", "image", "next", "page", "object", "exit", "ve", "resp", "xml", "version", "document", "result", "site", "json", "sequence", "respond", "body", "view", "console", "report", "position", "form", "fire", "connection", "content", "server", "print", "resource", "res", "Response", "status", "service", "reset"], "rewrittenQueryString": ["rewrittenqueryString", "rewrittenQuestionString", "rewrittenHeaderStream", "rewwrittenqueryStr", "rewrittenquerystring", "rewrittenRequestStr", "rewrittenURLStr", "rewrittenQuString", "rewrittenQuStr", "rewwrittenqueryString", "rewrittenHeaderString", "rewartedQueryStream", "rewrittenCurrentString", "rewwrittenQueryQuery", "rewrittenHeaderstring", "rewwrittenqueryQuery", "rewrittenRequestQuery", "rewrittenURLStream", "rewliedQueryStream", "rewwrittenQuerystring", "rewrittenCurrentQuery", "rewrittenQueryStream", "rewrittenQuerystring", "rewliedQueryStr", "rewartedQueryStr", "rewrittenQuStream", "rewartedHeaderstring", "rewrittenQuestionStr", "rewrittenqueryStream", "rewrittenURLString", "rewliedQueryString", "rewrittenRequeststring", "rewartedQuerystring", "rewartedQueryString", "rewrittenQustring", "rewartedHeaderStream", "rewrittenRequestString", "rewrittenCurrentstring", "rewwrittenquerystring", "rewrittenHeaderStr", "rewwrittenQueryString", "rewrittenQueryQuery", "rewrittenCurrentStr", "rewrittenqueryStr", "rewrittenqueryQuery", "rewartedHeaderString", "rewliedqueryString", "rewartedHeaderStr", "rewliedqueryStr", "rewwrittenQueryStr", "rewliedqueryStream", "rewrittenQueryStr", "rewrittenQuestionStream", "rewrittenURLstring"], "rewrittenUrl": ["rewrapedPort", "rewartedURL", "RewwrittenURL", "rewittenLink", "rewrapedUrl", "rewrapedURL", "rewadjustedURL", "rewartedurl", "rewrownURL", "rewwrittenLink", "rewriterUrl", "rewrownUrl", "RewrittenURL", "rewadjustedPort", "RewrittenUrl", "Rewrittenurl", "RewwrittenLink", "rewedString", "rewroteUr", "RewwrittenPosition", "rewittenURL", "rewrittenurl", "rewrittenString", "rewartedUrl", "RewrittenLink", "RewrittenPort", "rewwrittenString", "rewriteURL", "rewrittenURL", "rewroteLink", "rewrittenUr", "rewrownPosition", "rewrapedUr", "rewriteUr", "rewwrittenUr", "RewrittenPosition", "rewriteurl", "rewrittenLink", "rewittenurl", "rewittenUrl", "RewrittenString", "Rewwrittenurl", "rewriterURL", "RewwrittenPort", "rewedUrl", "rewwrittenPosition", "rewwrittenPort", "rewriddenURL", "RewwrittenString", "rewrownUr", "rewartedPosition", "RewwrittenUrl", "rewwrittenurl", "rewroteurl", "rewrittenPort", "rewedUr", "rewriterString", "rewriteUrl", "rewadjustedUr", "rewadjustedUrl", "rewroteUrl", "rewriddenPosition", "rewedURL", "rewriddenUr", "rewartedUr", "rewriterUr", "rewriddenUrl", "RewwrittenUr", "rewwrittenUrl", "rewrittenPosition", "rewrotePosition", "RewrittenUr", "rewroteURL", "rewwrittenURL"], "httpURLConnection": ["httpHTTPConfiguration", "ttpUrlConnect", "httpMLApplication", "ttpURLApplication", "httpSRApplication", "httpSRConnection", "httpURLConnect", "httpHTTPConnect", "httpMLconnection", "httpRLConnect", "httpURLConfiguration", "ttpUrlconnection", "HttpHTTPConnect", "HttpURLConnection", "httpMLConnect", "httpSRControl", "httpUrlconnection", "ttpURLConnect", "ttpURLconnection", "HttpHTTPApplication", "httpRLconnection", "HttpURLconnection", "ttpUrlControl", "httpHTTPConnection", "httpMLConnection", " httpURLConnect", "ttpUrlConnection", "HttpURLApplication", " httpUrlconnection", " httpUrlApplication", "ttpUrlApplication", "httpUrlControl", "HttpURLConnect", "HttpHTTPconnection", "httpSRConnect", " httpUrlConnect", "httpUrlApplication", "httpHTTPConn", "httpUrlConfiguration", "httpHTTPControl", "httpSRconnection", "httpUrlConnection", "HttpUrlConnection", "httpUrlConn", "ttpURLConnection", "httpRLApplication", "ttpURLControl", "HttpUrlConnect", "httpFileConnect", "httpURLApplication", " httpURLconnection", " httpURLApplication", "HttpHTTPConfiguration", "HttpUrlconnection", "httpSRConfiguration", "httpRLConnection", "httpFileConnection", "ttpURLConn", " httpUrlConnection", "HttpURLConfiguration", "httpURLControl", "httpURLconnection", "HttpHTTPConnection", "ttpUrlConn", "httpFileConn", "httpFileApplication", "httpHTTPconnection", "httpUrlConnect", "httpHTTPApplication", "httpURLConn"], "header": ["headers", "user", "block", "check", "dr", "init", "format", "title", "device", "shift", "heading", "component", "query", "info", "wrapper", "address", "argument", "core", "head", "zone", "client", "padding", "feature", "rule", "peer", "term", "detail", "page", "Header", "h", "ter", "layer", "handle", "er", "version", "attribute", "part", "field", "token", "handler", "state", "policy", "hidden", "option", "meta", "port", "line", "buffer", "event", "metadata", "holder", "hash", "operator", "column", "comment", "section", "status", "filter", "tag", "prefix", "relation", "variable"], "value": ["message", "VALUE", "format", "save", "Value", "address", "des", "instance", "description", "current", "sv", "zone", "string", "vector", "python", "record", "entry", "test", "job", "key", "email", "ue", "val", "label", "pair", "unit", "expression", "version", "password", "attribute", "default", "field", "element", "json", "sequence", "text", "property", "see", "server", "content", "v", "create", "sample", "language", "data", "example", "comment", "hash", "hello", "name", "values"], "inputStream": ["inputThread", "errorSteam", " inputSteam", "InputLoop", "InputView", "outputThread", " inputView", "outputLoop", " inputLoop", "InputThread", "inputWindow", "InputStream", "errorstream", "outputstream", " inputstream", "outputWindow", " inputThread", "inputLoop", "outputSteam", "errorWindow", "inputView", "inputSteam", "outputView", "inputstream", " inputWindow", "errorStream"], "outputStream": ["displaySteam", "responseForm", "responseLength", "displayStream", " outputView", "responseSteam", "outputForm", " outputSteam", "OutputSteam", "OutputStream", "displaystream", "outputstream", " outputLength", "outputSteam", "displayView", "responseStream", " outputForm", "inputView", "inputSteam", "outputLength", "OutputLength", "outputView", "inputstream", " outputstream", "OutputForm"]}}
{"id1": "12128591", "id2": "16549995", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"hash": [" check", " fingerprint", " Hash", "id", "update", " key", " message", " signature", " sum", " hashing", " equals", " address", " version", " salt", "h", "dump", " text", "hex", " id", " body", "Hash", "print", "code", " h", " mac", " code"], "data": ["message", "bytes", "block", "value", "accept", "out", "input", "mu", "info", "output", "any", "string", "what", "padding", "html", "window", "image", "this", "a", "action", "table", "batch", "password", "result", "command", "json", "sequence", "text", "DATA", "dat", "buffer", "ata", "raw", "content", "rel", "hello", "secret"], "digest": ["mdly", "Digester", " digEST", "displayse", "digEST", "digester", "redester", "mailgest", "mdse", "deest", " digse", "displayested", "diggest", " digit", "mdester", "mailest", "displayest", "mdests", "Digests", "redest", "digave", "digested", "mdest", "Digist", "deist", "Digest", "initest", "deested", "dese", "initested", "displayests", "mdit", "redgest", "digests", "Digse", "digist", " digave", "mailester", "mdgest", "equit", "equse", "mailly", "initEST", "digly", " digist", "digit", "initester", "DigEST", "Digested", "mdested", "mdave", " digester", "equest", "digse", "redly", " digested", "equave"]}}
{"id1": "8132219", "id2": "942693", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " CopyFiles", " CopyFile", "CopyFile", "CopyStream", " copyfile", " Copyfile", "CopyFiles", " copyFiles", " copyStream", " CopyStream", "copyStream", "Copyfile", "copyfile"], "inFile": ["inputFilename", "outName", "innRow", "inName", "inRow", " inRow", "inPath", "dinPath", "ninFilename", "inputName", " inEmail", "ninTemplate", "innFile", "dinEmail", "innPath", "outTemplate", "ninName", " inPath", "ninFile", "dinRow", "dinFile", "inTemplate", "inputTemplate", "inputFile", "innEmail", "inFilename", "outFilename", "inEmail"], "outFile": ["outputfile", " outFormat", "outFILE", "destfile", "inFILE", "inTable", "ouTable", "destFILE", "outfile", " outFILE", "destFormat", "outputTable", "outputFilename", "outFormat", "outTable", "outputFile", "ouFilename", " outfile", "destFile", "ouFile", "inFilename", "outFilename", "outputFormat", "ouFILE", "outputFILE"], "in": ["In", "is", "sin", "init", "on", "input", "rin", "id", "it", "info", "ain", "IN", "inn", "s", "inf", "bin", "ai", "irm", " input", "ir", "ins", "source", "inc", "from", "en", "ze", "ic", "up", "el", "ind", "old", "din", "isin", "cin", "i", "gin", " din", "inner", "o", "ini"], "out": ["b", "ex", "at", "OUT", "net", "ou", "it", "all", "output", "file", "t", "client", "gt", "c", "Out", "n", "one", "os", "p", "en", "to", "io", "ne", "outs", "w", "g", "e", "by", "co", "can", "res", "o", "v", "aos", "ot", "name"], "inChannel": ["insideHandler", "outchannel", "cinColumn", "sinStream", "innCategory", "ginCase", "outStream", " inchannel", "innerchannel", " inHandler", "insideComponent", "ginPanel", "inColumn", "cinStream", "inStream", "cinComponent", "inConnection", "sinBlock", "isinCategory", "outColumn", "insideChannel", " inChan", "vinPanel", "vinChannel", "outConnection", " inConnection", "inSlot", "inCategory", "innCase", " inComponent", "insideButton", "newChannel", "ginCategory", " inButton", "innSlot", "inCase", "newPanel", "innerConnection", "sinColumn", "cinButton", "inButton", "innerChan", "inBlock", "outBlock", "isinChannel", "innChannel", "newCase", "isinCase", "sinChannel", "sinCase", "newCategory", "cinChannel", "vinCase", "isinSlot", "ginChannel", "vinCategory", "inchannel", "cinHandler", "inChan", "inHandler", "sinSlot", "sinCategory", "inPanel", "outChan", "inComponent", "cinBlock", "innerChannel"], "outChannel": ["outchannel", "outputCh", "outChain", " outChan", "outStream", "oPassword", "inPassword", "OutConnection", "oClient", " outClient", "inStream", " outPassword", " outConnection", "OutCh", " outChain", "outConnection", "nChan", " outBlock", "nchannel", " outCh", "nChannel", "exChannel", "oChan", " outchannel", "outClient", "exChan", "OutChan", "exChain", "inClient", "outPassword", "outputChan", "outBlock", "nStream", " outStream", "outputChannel", "outCh", "oChannel", "inchannel", "inChan", "OutChannel", "outChan", "outputConnection", "exBlock"]}}
{"id1": "5683576", "id2": "149935", "code1": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"shorten": [" shortens", " shortense", "shortener", " Shorten", "Shortener", " Shortener", "shortens", "Shortense", "Shortens", " Shortense", " Shortens", "Shorten", "shortense", " shortener"], "url": ["ls", "b", "message", "path", "user", "dl", "format", "http", "URL", "id", "api", "address", "l", "link", "string", "str", "web", "html", "key", "domain", "page", "host", "p", "pattern", "version", "username", "password", "document", "json", "ret", "log", "Url", "ul", "location", "base", "name", "ll", "sl"], "qparams": ["qpackages", "qudetails", "qpins", "qvargs", "qualparam", "sqoptions", "iqoptions", "sqblocks", "quargs", "iqmarks", "qsparam", "qupins", "qqparam", "quoptions", "iqParameters", "sqpackages", "qqargs", "quparam", "sqdetails", " qdetails", "qupackages", "iqblocks", " qargs", "sqnames", "qsfields", "iqpins", "qoptions", "qualpackages", "sqparts", "sqparam", "sqargs", "qmarks", "QParameters", "dqmarks", "dqparams", "qqfields", "Qpins", "iqparam", "iqparams", "qunames", "quparams", "qmembers", "dqmembers", "qnames", "iqterms", "qvparams", "qparts", "qargs", "qvfields", "qvparam", "qqparams", "quams", "qfields", "iqnames", "sqterms", "Qparams", "qdetails", "quterms", "sqparams", "qumarks", "qsargs", "sqams", "iqmembers", "qualparts", " qams", "qumembers", "qterms", "qams", "qublocks", "qsparams", "quparts", "qualparams", "dqparam", "qblocks", "sqParameters", "qparam", "sqpins", "qParameters", "Qparam"], "params": ["headers", "pres", "gs", "ams", "cms", "Par", "ctx", " parameters", "conf", "AMS", "Parameters", "atos", "keys", "api", "options", "param", "config", "properties", "parser", "parts", "caps", "types", "rs", "details", "cp", "settings", "spec", "json", "eters", "mm", "parent", "ps", "stats", "pps", "names", "pi", "data", "terms", "changes"], "httpclient": ["httpconnection", "httpscli", "Httpconnection", "httpsclient", "httpsClient", "httpcache", "Httpcli", " httpcli", " httpClient", "httpscache", "HttpClient", " httpconnection", "Httpmanager", "httpClient", "Httpcache", "httpsconnection", "Httpclient", "httpmanager", "httpsmanager", " httpmanager", "httpcli", " httpcache"], "uri": ["ugi", "path", "range", "storage", "http", "qi", "query", "subject", "address", "filename", "database", "api", "du", "description", "wiki", "uni", "ur", "doi", "ri", "html", "origin", "term", "domain", "source", "u", " URI", "unit", "nu", "folder", "URI", "universal", "remote", "i", "iri", "resource", "location", "base", "pi", "prefix", "ui", "via"], "httpget": ["httpscall", "ttpsearch", "httGet", "httpscreate", "HTTPGet", "ttpget", "httquery", "httget", "httrequest", "HTTPsearch", "ttprequest", "hoverGet", "httpcall", "httpquery", "httpGet", "hoverquery", " httppull", "httpsget", " httpcreate", "ttpGet", "httprequest", "httpcreate", "HTTPget", "ttpquery", " httpcall", "httpspull", "hoverrequest", "httpsearch", "httcreate", "httcall", "httppull", " httpGet", " httpsearch", "httpull", "hoverget"], "response": ["reply", "message", "block", "http", "out", "application", "output", "description", "request", "frame", "success", "summary", "answer", "onse", "entry", "image", "one", "page", "still", "given", "object", "close", "successful", "resp", "document", "result", "json", "sequence", "respond", "body", "report", "connection", "content", "yes", "Response", "status"], "entity": ["obj", "person", "ce", "empty", "info", "output", "oe", "error", "icon", "encrypted", "client", "Entity", "entry", "email", "existent", "peer", "image", "le", "ent", "object", "om", "pe", "good", "eme", "document", "el", "result", "existing", "json", "valid", "body", "ity", "em", "enc", "e", "tex", "orm", "event", "resource", "content", "node", "status", "member", "ee", "activity"], "instream": ["intform", "outStream", "intstream", " inStream", "inStream", "INform", "imloader", "intcase", "inloader", "imcase", "inputform", "imform", "outstream", "inform", "intloader", "inputloader", "outconsole", "INstream", "INStream", " inconsole", "outform", "INconsole", " inform", "inputstream", "inconsole", "inputcase", "imstream", "incase"], "f": ["full", "ph", "conf", "uf", "fs", "fd", "bf", "fp", "tf", "t", "l", "fo", "c", "ff", "fx", "Factory", "df", "p", "af", "rf", "ct", "fac", "fi", "lf", "F", "w", "fab", "fg", "foreign", "e", "of", "sf", "fm", "cf", "v", "fr", "alf"], "jp": ["obj", "parse", "wp", "tp", "vp", "dp", "bp", "pkg", "fps", "fp", "mp", "dj", "hp", "jo", "bj", "iat", "prot", "xp", "p", "cp", "adj", "kj", "Ja", "JP", "jas", "peg", "op", "jj", "ja", "gp", "sp", "pai", "ijk", "uj", "jc", "eps", "js", "ps", "conn", "java", "jl", "np", "lp", "jump", "j", "jen", "fr", "pb", "pas"], "responseObj": ["ResponseCtrl", "ResponseBody", "ResponseOb", " responseObject", "requestObject", "responseCtrl", "ResponseObject", " responseCtrl", "replyVal", "replyBody", " responseVal", "ResponseObj", "replyObject", " responseBody", "responseOb", "responseBody", "requestOb", "responseObject", " responseOb", "replyObj", "requestCtrl", "ResponseVal", "requestObj", "responseVal"], "token": ["when", "channel", "template", "value", "atom", "function", "parse", "KEN", "note", "number", "ski", "tick", "type", "ok", "error", "list", "session", "kt", "task", "current", "lex", "t", "stat", "trigger", "browser", "before", "zero", "key", "word", "next", "txt", "p", "object", "Token", "table", "oken", "to", "tree", "initial", "document", "field", "state", "typ", "json", "element", "notice", "step", "no", "topic", "kn", "event", "complete", "total", "buffer", "reset", "span", "start", "operator", "pointer", "data", "name", "node", "tag", "j", "local", "relation", "normal", "variable"], "fieldname": ["fieldtype", "FIELDtype", "columnid", "ieldname", "FIELDval", "ieldName", " fieldtype", " fieldName", "fieldlen", " fieldlen", "Fieldval", "FIELDname", "ieldtype", "Fieldname", "fieldval", "keykey", "cellkey", "Fieldkey", "FIELDlen", "cellid", "FieldName", "columnName", "fieldName", " fieldkey", "fieldkey", "keyname", "FIELDName", "cellname", "keyName", "columnname", "fieldid", "cellName", "keyval", "columnkey", "FIELDkey", "ieldlen", " fieldid"]}}
{"id1": "21348951", "id2": "15757836", "code1": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "code2": "    private int[] sort(int n) {\n        int[] mas = new int[n];\n        Random rand = new Random();\n        for (int i = 0; i < n; i++) {\n            mas[i] = rand.nextInt(10) + 1;\n        }\n        boolean t = true;\n        int tmp = 0;\n        while (t) {\n            t = false;\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    tmp = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = tmp;\n                    t = true;\n                }\n            }\n        }\n        return mas;\n    }\n", "label": 0, "substitutes": {"processAddByURLSubmit": ["processAddByURLSubit", "processAddByURlsubmit", "processAddByURLSubsmitted", "processAddByURLSUBmitted", "processAddByURlsubmission", "processAddByURLSubmission", "processAddByURLSUBmit", "processAddByURlsummission", "processAddByURLSumit", "processAddByURlsumit", "processAddByURLSubsmit", "processAddByURLSUBmission", "processAddByURlsummitted", "processAddByURlsubit", "processAddByURLSubsit", "processAddByURLSubmitted", "processAddByURlsubmitted", "processAddByURLSUBit", "processAddByURLSubsmission", "processAddByURlsummit", "processAddByURLSummission", "processAddByURLSummit", "processAddByURLSummitted"], "url": ["ls", "external", "rect", "path", "item", "dl", "http", "URL", "input", "id", "force", "address", "file", "use", "l", "ur", "link", "string", "str", "browser", "email", "web", "html", "nl", "key", "loc", "run", "page", "q", "u", "uri", "addr", "util", "char", "rl", "document", "el", "ref", "impl", "mail", "Url", "ssl", "resource", "ul", "location", "base", "bel", "name", "ll", "mount", "sl", "un"], "invalidUrlMsg": ["invalidFileLog", "inInvalidURLStr", "inInvalidStrMsg", "invalidUrMessage", "inInvalidUrlMsg", "inInvalidUrlLog", "inInvalidUrlStr", "invalidURLStr", "invalidurlMsg", "inInvalidStrMessage", "invalidFileMsg", "invalidURLmsg", "invalidurlStr", "invalidurlmsg", "invalidStrMessage", "inInvalidUrlMessage", "inInvalidURLmsg", "invalidFileMessage", "invalidUrlMessage", "invalidUrlStr", "invalidUrlmsg", "invalidUrmsg", "invalidUrLog", "invalidUrMsg", "inInvalidURLMsg", "invalidStrMsg", "invalidURLMsg", "inInvalidUrlmsg", "invalidStrLog", "invalidFileStr", "invalidUrlLog", "invalidStrStr", "inInvalidStrLog", "inInvalidStrStr", "invalidUrStr"], "xmlSourceWriter": ["xmlSourceFileWriter", "xmlsourceReader", "jsonStringWriter", " xmlSourceRW", "xmlsourceWriter", "jsonSourceReader", " xmlSourceWrite", "xmlSourceFileBuilder", "jsonStringCode", "xmlSourceFileRW", "xmlSourceRW", "xmlStringReader", "xmlSourceBuilder", "xmlStringWriting", " xmlSourceWriting", "jsonStringReader", "xmlSourcesReader", "jsonSourceCode", "xmlSourcesWriter", "xmlsourceRW", "jsonSourceWriter", "xmlSourceCode", "xmlStringCode", "xmlsourceBuilder", "xmlsourceWriting", "xmlsourceWrite", "xmlSourceWriting", "jsonStringWriting", "jsonSourceWriting", " xmlSourceReader", "xmlSourceFileWriting", "xmlStringWriter", "xmlSourcesCode", "xmlSourceReader", "xmlSourcesWriting", " xmlSourceBuilder", "xmlSourceWrite"]}}
{"id1": "13499897", "id2": "20267500", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "label": 0, "substitutes": {"CopyFile": ["DownloadDir", "Transferfile", " Copyfile", "Downloadfile", "DownloadPath", "CopyPath", "DownloadFile", "TransferDir", " CopyDir", "TransferPath", "TransferFile", " CopyPath", "Copyfile", "CopyDir"], "sourcefile": ["starturl", " sourcepath", "sourceattribute", "ourcefile", "Sourcefile", "startpath", "srckey", "ourceattribute", " sourceFile", "sourceFile", "styleattribute", "styleFile", "sourcepath", "stylekey", "startfile", "srcattribute", "startFile", "sourcekey", "ourceFile", "ourcekey", "srcFile", "Sourcepath", "srcfile", "sourceurl", " sourceurl", "SourceFile", "stylefile", "Sourceurl"], "destfile": ["DestFile", "tempfile", "sourcefilename", "resultfilename", "destpath", "tempfilename", " destFile", "tempFILE", "masterFile", "Destile", "desturl", "masterfile", "temppath", "resultFile", "masterpath", "destFILE", "srcpath", "masterFILE", "sourceFile", "sourceile", "resultfile", "sourcepath", "resultpath", " destname", "sourcename", "destport", "Destfilename", "Destfile", "tempFile", " destile", " desturl", "destfilename", " destpath", "destname", "Desturl", " destport", " destfilename", "srcFile", "srcport", "destFile", "Destpath", "srcfile", "sourceurl", "Destname", "sourceport", "destile", " destFILE"], "last": ["nd", "rest", "full", "prev", "strip", "first", "any", "and", "Last", "left", "count", "after", "since", "top", "size", "region", "right", "most", "bottom", "end", "this", "good", "master", "est", "default", "shadow", "old", "st", "length", "show", "get", "lot", "dist", "total", "max", "based", "base", "pop", "latest", "start", "recent", "index", "ast", "reverse"], "parent": ["path", "tip", "full", "where", "prop", "pa", "tar", "home", "tmp", "wrapper", "older", "instance", "per", "dir", "request", "parents", "and", "ma", "m", "params", "padding", "root", "test", "key", "mother", "pid", "family", "missing", "page", "p", "fat", "def", "Parent", "unit", "global", "up", "tree", "master", "owner", "part", "sp", "paren", "spec", "folder", "exp", "snap", "fr", "temp", "shape", "chain", "server", "holder", "point", "prefix", "pool", "ip", "child"], "f": ["b", "ft", "fs", "fed", "file", "fd", "bf", "fp", "fc", "tf", "m", "elf", "l", "fo", "fl", "c", "df", "p", "af", "h", "rf", "fe", "fac", "fi", "part", "fw", "lf", "F", "w", "fab", "fr", "g", "e", "of", "sf", "fm", "cf", "v", "local", "alf"], "srcChannel": ["subPanel", "curChan", " srcchannel", " srcCase", "subCase", "srcChan", "rcConnection", "curConnection", "curchannel", "sqchannel", " srcChain", " srcPanel", " srcChan", "sourceChan", "srcCase", "sourceButton", "instButton", "srcConnection", "sourceChannel", "ctrChan", "instchannel", "sourcechannel", "instChan", "ctrButton", "subChannel", "rcChan", "ctrChannel", "rcchannel", "rcButton", "srcchannel", " srcConnection", "curChannel", "sqChannel", "rcChain", "instChannel", "ctrChain", "sqCase", "srcButton", "srcChain", " srcButton", "rcChannel", "subchannel", "srcPanel", "sqPanel"], "dstChannel": ["dstConnection", "dltButton", " dotchannel", "cdstCh", "ddrChannel", "ddrChan", "ddrchannel", "dbrChannel", " dstchannel", " dotChannel", "distCategory", "deltChannel", "cdistCh", "dstCh", "dndButton", "dotchannel", "dotConnection", "drtCh", " dotConnection", "dltChan", "cdstCategory", "dndChan", "deltCh", "dbrConnection", "dotChan", "drtButton", "cdistChannel", "destChannel", "dblChan", "dndCh", "drtChannel", "distCh", " dstConnection", " dstChan", "dstCategory", " dotChan", "dndChannel", "dbrChan", "dstChan", "destChan", "dblChannel", "distButton", "dndCategory", "cdstChannel", "dbrchannel", "deltButton", "dblButton", "dltCh", "dotChannel", "drtCategory", "ddrConnection", "distChannel", "dblCh", "deltChan", "cdistButton", "destButton", "dstchannel", "dltChannel", "destCh", "cdistCategory", "cdstButton", "dstButton"]}}
{"id1": "17786231", "id2": "17947247", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    public String postURL(String urlLocation, ArrayList headers, String content, HashMap postVariables, RenderEngine c) throws Exception {\n        String postContent = null;\n        if (postVariables != null) {\n            boolean firstElement = true;\n            postContent = new String();\n            Iterator elements = postVariables.keySet().iterator();\n            while (elements.hasNext()) {\n                String key = (String) elements.next();\n                String val = (String) postVariables.get(key);\n                if (firstElement) {\n                    postContent += Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                    firstElement = false;\n                } else {\n                    postContent += \"&\" + Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                }\n            }\n            elements = null;\n        } else {\n            postContent = content;\n        }\n        Debug.log(\"Connecting to URL '\" + urlLocation + \"', content '\" + postContent + \"'\");\n        URL url = null;\n        try {\n            url = new URL(urlLocation);\n        } catch (MalformedURLException e) {\n            Debug.log(\"Unable to retrieve URL '\" + urlLocation + \"': \" + e.getMessage());\n            return null;\n        }\n        StringBuffer lines = new StringBuffer();\n        HttpURLConnection conn = null;\n        boolean contentLengthFound = false;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            loadCookies(urlLocation, conn, c);\n            if (headers != null) {\n                for (int i = 0; i < headers.size(); i++) {\n                    String header = (String) headers.get(i);\n                    String key = header.substring(0, header.indexOf(\":\"));\n                    String value = header.substring(header.indexOf(\":\") + 2);\n                    if (key != null && key.equalsIgnoreCase(\"content-length\")) {\n                        contentLengthFound = true;\n                    }\n                    Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                    conn.setRequestProperty(key, value);\n                }\n            }\n            if (!contentLengthFound) {\n                Debug.log(\"Adding new request header 'Content-Length'='\" + postContent.length() + \"'\");\n                conn.setRequestProperty(\"Content-Length\", Integer.toString(postContent.length()));\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(postContent);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                lines.append(line);\n                lines.append(\"\\r\\n\");\n            }\n            handleHeaders(urlLocation, conn.getHeaderFields());\n            wr.close();\n            rd.close();\n            wr = null;\n            rd = null;\n        } catch (IOException e) {\n            if (conn != null) {\n                lines = new StringBuffer();\n                try {\n                    throw new Exception(\"Server returned error code '\" + conn.getResponseCode() + \"': \" + conn.getResponseMessage());\n                } catch (IOException ee) {\n                    throw new Exception(\"Unable to report error codes: \" + ee.getMessage());\n                }\n            }\n            Debug.log(\"I/O Exception occurred while communicating with endpoint: \" + e.getMessage());\n            return lines.toString().trim();\n        } catch (Exception e) {\n        }\n        url = null;\n        conn = null;\n        return lines.toString().trim();\n    }\n", "label": 0, "substitutes": {"downloadFile": ["getContent", "transferContent", "loadResource", "downloadContent", "loadContent", "transferfile", "transferFile", "loadFile", "downloadfile", "loadfile", "downloadResource", "getFile", "transferResource", "getResource", "getfile"], "downloadUrl": ["downloadURL", "linkLink", "linkUrl", "reportWar", "installUr", "transferURL", "transferUrl", "DownloadWar", "DownloadURL", "downloadUr", "DownloadUrl", " downloadLink", "transferUr", "installLink", "linkUr", "reportURL", "DownloadUr", "installURL", " downloadURL", " downloadUr", "installUrl", "transferWar", "linkURL", "downloadLink", "reportUr", "reportUrl", "downloadWar"], "destinationFile": ["destarationDir", "destificationDir", "destiningDir", "destarationPath", "destarationSourceFile", " destificationSourceFile", "coordinationFolder", " destificationFile", " destificationDir", "destacementfile", "destiningFile", "destinationDir", "coordacementFile", "coordacementName", "destinationfile", "destinationPath", "destacementName", "destinationSourceFile", " destinationDir", "destinatedfile", " destinationSourceFile", "destiningPath", " destificationPath", "destinationName", " destinationPath", "destacementFolder", "destificationPath", "destificationFile", "destiningSourceFile", "destinatedFolder", "destinatedFile", "destarationfile", "coordinationfile", "coordacementfile", "destarationFolder", "coordinationFile", "destacementFile", "coordacementFolder", "destinationFolder", "coordinationName", "destinatedName", "destarationName", "destificationSourceFile", "destarationFile"], "client": ["collection", "template", "net", "http", "cache", "tc", "url", "query", "force", "ci", "Client", "api", "context", "wrapper", "request", "phone", "network", "https", "google", "cl", "system", "key", "uri", "io", "cm", "console", "city", "remote", "conn", "connection", "co", "server", "resource", "contact", "cli", "channel", "service", "pool", "call"], "httpGet": ["ttpget", " httpGET", "HttpPut", "ttpPut", "HttpGet", " httpQuery", "httpGET", "httpget", "utilGET", "HttpGET", "utilGet", "httpPut", "ttpGet", " httpPut", "hget", "HttpQuery", "httpQuery", "utilPut", "hPut", "utilQuery", "hGet", "Httpget"], "outputFile": ["OutputFile", "outStream", "outPlace", "betaFILE", "outPoint", "outputPlace", "newPlace", "newStream", "newFile", "OutputPlace", "regionStream", "outputFILE", "tempStream", "outFile", "seeFile", "regionFILE", "tempFile", "newPoint", "OutputStream", "outputPoint", "seeFILE", " outputFILE", "betaFile", "regionFile", "OutputPoint", "tempFILE"], "outputStream": ["printSteam", "OutputView", "inputStreamer", "coinStream", "coinStyle", "outputStreamer", " outputStyle", "coinStreamer", "inputForm", " outputStreamer", "putStyle", " outputView", "printStream", "putSteam", "responseSteam", "inputStyle", "outputForm", "responseStyle", "printForm", " outputSteam", "OutputSteam", "outputStyle", "responseStreamer", "OutputStyle", "OutputStream", "outputstream", "putStreamer", "coinSteam", "outputSteam", "inputView", "inputSteam", "responseStream", "putStream", "printFile", "outputView", "inputFile", " outputForm", "inputstream", "Outputstream", " outputstream"], "response": ["reply", "message", "block", "http", "application", "output", "description", "request", "answer", "onse", "entry", "image", "given", "still", "page", "details", "resp", "version", "initial", "document", "attribute", "result", "json", "body", "post", "remote", "connection", "content", "resource", "yes", "server", "example", "Response", "data", "status", "service"], "entity": ["obj", "person", "message", "ilo", "group", "note", "cache", "secure", "component", "type", "info", "associated", "iso", "translation", "error", "instance", "encrypted", "properties", "Entity", "entry", "email", "existent", "peer", "image", "quote", "detail", "details", "ent", "object", "pe", "xml", "document", "el", "unique", "valid", "json", "existing", "attribute", "body", "result", "ity", "enc", "e", "line", "buffer", "account", "event", "content", "resource", "metadata", "total", "security", "profile", "data", "name", "comment", "status", "member", "local", "activity"], "inputStream": ["inputStreamer", "sourceSteam", " inputSteam", "thisSteam", "sourcestream", "sourceStream", " inputForm", "readstream", "activeStream", "evalStreamer", "InputForm", "imageSteam", "activeSteam", "imageView", "inputForm", "activeView", " inputStreamer", "upstream", "thisStyle", "upForm", "readForm", "Inputstream", " inputView", "inputStyle", "outputForm", "evalSteam", "readStream", "sourceView", "imageStream", "evalStream", "InputStream", "outputStyle", "upStream", "thisForm", " inputstream", "outputstream", "upSteam", "activeStreamer", "thisStream", "outputSteam", "imagestream", "inputSteam", "inputView", "evalView", "outputView", "inputstream", "InputSteam", "InputStyle", "readSteam"], "callback": ["alias", "library", "message", "binding", "soon", "closure", "lambda", "function", "display", "creator", "update", "wrapper", "func", "consumer", "actor", "back", "parser", "cell", "browser", "job", "cb", "loader", "builder", "cc", "continue", "window", "facebook", "gc", "hook", "manager", "pattern", "processor", "handler", "token", "policy", "CB", "finder", "Callback", "background", "backs", "sound", "filter", "call"], "copiedLength": ["copyLength", "CopiedDuration", "copedLength", "CopedSize", "copiedLen", "CopedNumber", "copifiedLength", "CopedLen", "CopiedNumber", "copedDuration", "copifiedLen", "copifiedNumber", "copiedNumber", "CopiedSize", "copedLen", "copyDuration", "CopedDuration", "copedSize", "copIEDNumber", "copifiedDuration", "CopiedLength", "copIEDLength", "copiedSize", "copiedDuration", "CopiedLen", "copIEDDuration", "copedNumber", "CopedLength", "copifiedSize", "copySize", "copyLen"], "percentage": ["capaging", "Percentage", "capale", "percentages", "CENTages", "percentale", "percentaging", "Percentages", "capages", "Percenture", "CENTage", " percentages", " percentale", "percenture", "CENTure", " percenture", " percentaging", "Percentale", "Percentaging", "capage"]}}
{"id1": "11475527", "id2": "12066447", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addTextFormURL", "addDatafromurl", "addTextFromUrl", "addDataToUrl", "addDataFormURL", "addTextFormUrl", "addDataFormLocation", "addDataFromurl", "addDataFromUrl", "addDatafromURL", "addTextFromURL", "addDataFromLocation", "addDatafromLocation", "addDatafromUrl", "addTextFormLocation", "addTextFormurl", "addDataTourl", "addDataFormUrl", "addDataFormurl", "addTextFromurl", "addDataToLocation", "addDataToURL", "addTextFromLocation"], "theurl": ["theURL", "thfile", " theURL", "TheURL", " theUrl", "theUrl", "hefile", "thUrl", "heuri", "heUrl", "thefile", "theuri", "heURL", "heloader", " theuri", "teUrl", "teurl", "heurl", "thloader", " theloader", "Theurl", " thefile", "teuri", "teURL", "theloader", "thurl", "Theuri", "TheUrl"], "line": ["LINE", "lined", "message", "header", "liner", "block", "online", "day", "lane", "ln", "inline", "l", "ine", "frame", "string", "eline", "cell", "stroke", "zone", "link", "email", "lin", "entry", "record", "rule", "row", "source", "page", "le", "Line", " inline", "char", "valid", "ner", "sequence", "text", "ice", "chain", "print", "code", "sample", "name", "node", "point", "comment", "status"], "in": ["In", "read", "pin", "is", "init", "or", "out", "input", "rin", "phys", "win", "al", "open", "f", "it", "r", "lo", "ain", "ma", "IN", "inn", "reader", "t", "l", "inf", "bin", "ai", "id", "proc", "include", "again", "ins", "n", "source", "inc", "mc", "from", "en", "mi", "ac", "ic", "old", "st", "oin", "din", "isin", "cin", "serv", "con", "i", "gin", "conn", "inner", "o"], "data": ["ad", "user", "read", "cache", "out", "input", "query", "info", "da", "file", "join", "reader", "feed", "client", "size", "window", "stream", "next", "this", "a", "def", "pipe", "io", "result", "text", "DATA", "body", "dec", "writer", "dat", "iterator", "buffer", "ata", "raw", "content", "d", "bus"], "e": ["b", "ex", "ce", "or", "r", "f", "err", "be", "error", "oe", "m", "t", "ine", "se", "entry", "ae", "x", "c", "de", "ue", "n", "le", "a", "p", "ze", "ve", "h", "pe", "ed", "er", "eeee", "eu", "ne", "element", "y", "ge", "E", "te", "ie", "g", "es", "re", "ec", "me", "i", "event", "d", "v", "o", "ele", "ee"]}}
{"id1": "21979462", "id2": "9319440", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 1, "substitutes": {"downloadURLtoString": [" downloadurloBytes", " downloadURL2String", " downloadURLToBytes", " downloadURLoText", " downloadURL2Bytes", " downloadurloString", " downloadURLtoJSON", " downloadurloJSON", " downloadurltoString", " downloadurloText", " downloadURLtoText", " downloadURLToString", " downloadURLToJSON", " downloadURLtoBytes", " downloadurltoBytes", " downloadURLoJSON", " downloadURL2Text", " downloadURLoString", " downloadURL2JSON", " downloadurltoJSON", " downloadurltoText", " downloadURLToText", " downloadURLoBytes"], "url": ["ls", "rect", "dl", "http", "URL", "id", "all", "uu", "address", "file", "l", "ur", "gl", "link", "browser", "job", "web", "run", "domain", "uri", "char", "ref", "ret", "log", "Url", "mail", "ssl", "resource", "ul", "location", "base", "bel", "name", "ll", "mount", "sl", "un"], "in": ["In", "read", "check", "is", "or", "ill", "on", "conf", "thin", "out", "input", "it", "al", "all", "info", "ma", "IN", "inn", "reader", "and", "inf", "bin", "ai", "again", "ins", "from", "mc", "inc", "ic", "up", "er", "copy", "io", "ind", "oin", "din", "isin", "by", "re", "cin", "mn", "con", "i", "gin", "sum", "inner"], "sb": ["b", "rob", "pa", "ib", "bp", "gb", "bf", "ab", "bis", "rb", "bj", "SB", "cb", "sq", "bg", "erb", "lb", "gc", "sk", "bs", "sam", "zb", "sp", "ub", "gob", "bh", "eb", "nb", "bn", "bd", "bsp", "bb", "mb", "ssl", "sa", "sf", "wb", "xb", "bt", "sd", "kb", "lp", "db", "sg", "pb"], "str": ["b", "obj", "ls", "sl", "expr", "pt", "block", "dr", "iter", "r", "del", "err", "comm", "m", "list", "bl", "t", "s", "l", "bc", "exec", "Str", "string", "sts", "cat", "req", "n", "next", "txt", "source", "br", "p", "arr", "def", "comp", "char", "part", "tr", "sp", "msg", "div", "st", "set", "text", "STR", "ch", "dat", "re", "chain", "i", "cont", "gr", "print", "syn", "cur", "comment", "j", "vol", "fr"]}}
{"id1": "10728243", "id2": "3745402", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"scramble411": ["scramlepassword", "scramlePassword", "scrambledBasic", "scrambledPassword", "scramblepassword", "scramle ", "scamblesBasic", "scamble ", "scramblePassword", "scrambledpassword", "scramblespassword", "scrambled ", "scamblepassword", "scamblesPassword", "scrambleBasic", "scamblePassword", "scramble ", "scambleBasic", "scrambles ", "scramblesPassword", "scramleBasic", "scramblesBasic", "scambles ", "scamblespassword"], "password": ["remember", "message", "user", "sword", "words", "auth", "pass", "Password", "wd", "address", "database", "description", "secret", "string", "padding", "email", "key", "word", "primary", "pattern", "username", "attribute", "shadow", "token", "text", "crypt", "hash", "profile", "data", "phrase", "prefix", "hello", "reset"], "seed": ["setup", "template", "Salt", "offset", "sudo", "sql", "mix", "ser", "secret", "se", "feed", "vector", "padding", "test", "entry", "key", "needs", "random", " seeded", "source", "df", "derived", "prime", " seeds", "initial", "shadow", "sex", "sequence", "eed", "eder", "start", "sample", "rand", "create", "hash", "example", "phrase", "index", "reset"], "md": ["ad", "nd", "pt", "amd", "cd", "dr", "dh", "gm", "mt", "grad", "red", "nt", "MD", "m", "mp", "pkg", "rm", "pm", "der", "ma", "mk", "exec", "ann", "rpm", "de", "hd", "managed", "mind", "mc", "df", "img", "multi", "pd", "cmd", "dd", "def", "ct", "addr", "det", "cm", "msg", "ind", "mod", "desc", "sha", "pdf", "mm", "ld", "med", "bd", "od", "dig", "mn", "mb", "rd", "esm", "td", "metadata", "sd", "d", "mand", "mg", "ms", "di", "sm", "dm"], "passwordHashStage1": ["passwordHashSHA0", "passwordHashPhaseOne", "passwordhashStage2", "passwordHashstage01", "passwordHashStage5", "passwordHashSHA2", "passwordHashstage2", "passwordhashstage1", "passwordHashstage0", "passwordHashStageOne", "passwordHashPage2", "passwordHashStage0", "passwordHashPhase0", "passwordHashSHA01", "passwordHashstage1", "passwordHashPage0", "passwordHashPhase2", "passwordHashPhase1", "passwordhashStageOne", "passwordhashStage0", "passwordhashStage1", "passwordHashPage5", "passwordhashstage2", "passwordHashstageOne", "passwordHashPage1", "passwordHashstage5", "passwordhashstage0", "passwordHashSHA1", "passwordHashStage01", "passwordhashstageOne"], "passwordHashStage2": ["passwordSaltStage62", "passwordHashStyle62", "passwordHashScene3", "passwordSaltStage2", "passwordHashstage2", "passwordHashStyle3", "passwordHashstageTwo", "passwordHashPhase4", "passwordHashVersionTwo", "passwordHashStyle2", "passwordHashstage1", "passwordHashStage4", "passwordHashStage3", "passwordHashPhase2", "passwordHashPhase1", "passwordHashVersion1", "passwordHashStageTwo", "passwordHashPhaseTwo", "passwordHashVersion4", "passwordSaltStage3", "passwordSaltStageTwo", "passwordHashStage62", "passwordHashScene62", "passwordHashSceneTwo", "passwordHashStyleTwo", "passwordHashVersion2", "passwordHashstage4", "passwordHashScene2"], "toBeXord": ["toBeYor", "tobeYor", "toBeXor", "tobeXor", "tobeYords", "toBeZords", "tobeXold", "toBeTxond", "toBeZor", "toBEXorg", "toBeXLor", "toBEXord", "toBeXond", "toBeZXold", "toBEXor", "toBeZXord", "toBeXords", "toBeYords", "toBexorg", "toBeXLord", "toBeTxords", "toBeZXords", "toBexor", "toBeYord", "toBeYod", "toBeYold", "toBexord", "toBeXorg", "toBEXords", "toBeZord", "tobeXords", "toBeXLords", "tobeYold", "toBeXold", "toBEXod", "toBeTxord", "toBexond", "toBeXLod", "toBEXond", "tobeYord", "toBeYorg", "toBeTxorg", "tobeXorg", "toBeZorg", "tobeXord", "tobeYorg", "toBexords", "toBeXod", "toBeZXor"], "numToXor": ["num2Xors", "numToRestor", "numToRestore", "num2Xor", "num2Xore", "num2Restore", "numToXors", "numToxord", "numtoYOR", "numToZors", "numtoYors", "numToYor", "numToxors", "numtoXord", "num2Restors", "numToYors", "num2Restor", "numToYOR", "numtoYor", "numToxOR", "numToZOR", "num2RestOR", "numToZord", "numtoXOR", "numToXord", "numtoXor", "numToxore", "numtoYord", "numToYord", "numToXOR", "numToZore", "numToXore", "numToRestors", "numToZor", "numtoXors", "numToRestOR", "numToxor", "num2XOR"], "i": ["ex", "is", "init", "ni", "us", "gi", "it", "qi", "xi", "k", "info", "ci", "li", "ms", "z", "I", "m", "\u0438", "t", "s", "ai", "ix", "ri", "x", "bi", "n", "ii", "multi", "u", "mi", "uri", "ic", "in", "batch", "io", "fi", "y", "ind", "set", "sequence", "im", "phi", "sim", "g", "e", "ie", "ji", "si", "span", "ei", "pi", "zi", "o", "ti", "cli", "j", "ui", "di", "ini", "ip"]}}
{"id1": "20929570", "id2": "3197876", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"toMd5": ["toDmHash", "toMd512", "toDd512", "toMMDHash", "toMmd512", "toMmd5", "toMm4", "toDdHash", "toMmd4", "toDm4", "toDm5", "toMm5", "toMdHash", "toMd4", "toMmHash", "toMm512", "toMMD5", "toDd5", "toMmdHash", "toDd4", "toMMD4", "toDm512", "toMMD512"], "str": ["b", "obj", "out", "input", "it", "r", "t", "s", "Str", "string", "ctr", "utt", "c", "n", "this", "txt", "a", "br", "p", "arr", "in", "char", "sp", "msg", "cr", "st", "text", "w", "STR", "ch", "wr", "enc", "e", "print", "v", "data", "name"], "messageDigest": ["messageDefester", "applicationDigest", "applicationdigse", "messageDecests", "messageDefer", "messageDigert", " messageDigester", "messageDigse", "messageDesignester", " messageDigse", "Messagedigests", "applicationdigest", "messagedigest", "Messagediger", "applicationdigester", "messageDester", "messageDecest", " messageDert", "MessageDigse", "messageDest", "MessagedigEST", "messageDecested", "messagemdse", "Messagedigse", " messageDigist", "messagedigist", "messagedigse", " messageDse", "applicationdigested", "messageDesignest", " messageDester", "messagediger", "messageDigEST", "messageDse", "messagedigert", "applicationDigester", "messageDecester", "messagedigEST", " messageDigert", "messagemdest", "messageDesignse", "messageDigist", "messagedigester", " messageDest", "messageDefEST", "messagemdert", "MessageDigester", "Messagedigester", "messagedigests", "applicationDigse", "messageDigester", "MessageDigest", "messageDert", "messagemdester", "MessageDigests", "messageDesignests", "applicationDigested", " messageDiger", "messageDecse", "messageDigests", "MessageDiger", "Messagedigest", "messageDefest", "messageDefist", "MessageDigEST", "messageDesignested", "messageDiger", "messagedigested", "messageDigested"], "byteArray": [" byteList", "viewArray", "fieldRAY", "helloBuffer", "byteString", "basicarray", "basicBuffer", " byteAddress", "fieldArray", "bytesAddress", "entityBuffer", "bytesRAY", "helloArray", "entityArray", "resourceStream", " byteRAY", "basicString", " byteString", "basicAddress", "viewStream", "resourceArray", "bytesLength", "fieldLength", " byteBuffer", "byteList", "seBuffer", "byteLength", "byteRAY", "seArray", "resourceBuffer", "entityList", " byteLength", "byteStream", "byteAddress", "entityarray", "bytearray", "viewBuffer", "basicArray", "basicList", "byteBuffer", "bytesArray", " byteStream", "bytesString", " bytearray"], "md5StrBuff": ["md5StringDb", "md5RatBuff", "md5StPref", "md4StringPref", "md5ObjBuff", "md5StrVert", "md4StrPref", "md4Strbuff", "md65TextBuff", "md4StringBuff", "md5RatBuffer", "md5BuffDb", "md7StringBu", "md5StringPref", "md8RatVert", "md5Buffbuff", "md65TextBuffer", "md5StCop", "md5ObjComp", "md5strComp", "md4StrBuff", "md5ObjVert", "md5StringBu", "md5TextBuff", "md7StrBu", "md7StringBuff", "md5strbuff", "md7StrPref", "md5StBuffer", "md7Strbuff", "md5StringCop", "md65StrComp", "md5Stbuff", "md5StBuff", "md5strVert", "md65StrCop", "md5StrPref", "md5ObjBuffer", "md5strBuffer", "md7StrBuff", "md4Stringbuff", "md5TextComp", "md5StrBu", "md8RatBuffer", "md5StringBuffer", "md65StrBuff", "md5StrComp", "md5TextCop", "md5StringBuff", "md5strBuff", "md8RatBuff", "md5StringComp", "md5BuffPref", "md5RatVert", "md7StringPref", "md5Stringbuff", "md5BuffBuff", "md8StrVert", "md65TextComp", "md4StrDb", "md5Strbuff", "md5StrDb", "md5StrBuffer", "md65StrBuffer", "md4StringDb", "md8StrComp", "md5TextBuffer", "md5StBu", "md8StrBuff", "md5strPref", "md5StrCop", "md5strBu", "md5strDb", "md7Stringbuff", "md8RatComp", "md5RatComp", "md8StrBuffer", "md65TextCop", "md5StComp"], "i": ["ex", "is", "my", "us", "cgi", "gi", "it", "xi", "info", "ci", "li", "gravity", "I", "m", "list", "t", "s", "l", "ai", "ix", "gu", "ki", "x", "c", "hi", "bi", "n", "ii", "q", "a", "go", "u", "multi", "mi", "h", "ic", "in", "batch", "uri", "major", "index", "io", "y", "ind", "json", "slice", "im", "phi", "iu", "status", "conv", "e", "ji", "chain", "me", "si", "v", "ei", "pi", "o", "ti", "cli", "j", "ui", "di", "ini", "ip"]}}
{"id1": "4895903", "id2": "23452437", "code1": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 0, "substitutes": {"load": ["launch", "read", "transform", "loading", "init", "install", "store", "oad", "download", "open", "save", "sync", "Load", "map", "loads", "LOAD", "use", "link", "lock", "loader", "dump", "show", "build", "insert", "sample", "execute", "call"], "sourceType": ["templateCopy", "SOURCEApp", "ourceDefault", "noteType", "statustype", "sequenceType", "sourceStyle", "causeTyp", "templateStyle", "SOURCETyp", "licenseTyp", "scanField", "sequenceUnit", "scoreType", "versionStyle", " sourceSpec", "serviceApp", "licenseVersion", " sourceClass", "componentTYPE", "statusType", "versionType", "sourceVersion", "noTyp", "ourceType", "scopeSpec", "scantype", "componenttype", "styleTyp", "licenseUnit", "versionTyp", "ourceTyp", "speCopy", "statusTyp", "scoreTyp", "noType", "messageTyp", "causetype", "licensetype", "componentType", "versiontype", "sourceField", "styleClass", "styleTYPE", "componentClass", "unittype", "sourceTyp", " sourceTyp", "styleType", "sourceDefault", " sourceStyle", "SOURCEtype", "spetype", "typeUnit", "scopeStyle", "serviceTyp", "scopeType", "noteTy", "versionDefault", "typeEmail", "sourcetype", "templateSpec", "speTyp", "sourceTYPE", "serviceType", "scopetype", "typeType", "noteTyp", "messageDefault", "licenseTYPE", "templatetype", "sourceEmail", "scanType", " sourceTYPE", "sequenceTYPE", "sourceTy", "sequenceEmail", "secretType", "notetype", "sourceSpec", "secrettype", "typeTYPE", "componentTyp", "unitTyp", "scoretype", "SOURCEType", "scanTyp", "secretTyp", "scopeTyp", "notype", "sourceApp", "speType", "statusVersion", "sourceClass", "unitType", "scopeCopy", "sourceCopy", "secretApp", "licenseType", "licenseEmail", "templateTyp", "noStyle", "messageType", "servicetype", "versionTy", "causeType", "sourceUnit", "causeTy", "ourceTy", " sourceField", "messageTy", " sourcetype", "statusTy", "SOURCEVersion", "componentField", "templateType"], "source": ["SOURCE", "ce", "supp", "draw", "update", "search", "find", "filename", "file", "any", "seed", "se", "size", "origin", "image", "expression", "sp", "spec", "text", "body", "report", "none", "get", "license", "resource", "node", "status", "series", "service", "alias", "init", "format", "src", "note", "input", "sql", "subject", "context", "description", "join", "ource", "feature", "key", "stream", "scope", "details", "handle", "settings", "site", "state", "json", "target", "show", "see", "raw", "sample", "scan", "via", "table", "message", "iter", "slot", "storage", "function", "parse", "Source", "instance", "list", "config", "core", "string", "send", "missing", "sequence", "ie", "remote", "comment", "template", "store", "cache", "component", "query", "force", "address", "use", "reason", "from", "object", "unit", "copy", "view", "slice", "style", "parent", "me", "module", "content", "start", "create"], "param": ["item", "path", "rest", "init", "format", "perm", "conf", "prop", "query", "Parameter", "argument", "m", "pm", "config", "rm", "rem", "pre", "reference", "params", "arg", "rpm", "req", "term", "p", "cp", "asm", "method", "Param", "attr", "attribute", "pai", "msg", "problem", "aram", "typ", "par", "property", "cal", "ref", "mm", "meter", "monitor", "arm", "model", "start", "name", "admin", "tag", "comment", "prefix", "index", "member", "prom"], "location": ["operation", "path", "message", "library", "Location", "device", "value", "center", "where", "direction", "search", "info", "address", "context", "filename", "translation", "ion", "activity", "description", "media", "reference", "ocation", "availability", "trace", "directory", "padding", "root", "origin", "feature", "key", "peer", "entry", "loc", "color", "family", "scope", "mount", "area", "layout", "expression", "initial", "owner", "document", "bound", "folder", "sequence", "property", "target", "position", "LOC", "remote", "usage", "condition", "shape", "history", "event", "resource", "module", "sample", "language", "name", "point", "comment", "local", "region"], "type": ["function", "format", "title", "tp", "where", "ver", "time", "info", "all", "id", "options", "class", "address", "error", " Type", "description", "t", "link", "trace", "pretty", "what", "test", "root", "ype", "ty", "key", "types", "color", "family", "scope", "term", "action", "pe", "unit", "method", "ping", "sort", "Type", "op", "part", "command", "state", "typ", "length", "style", "position", "option", "form", "port", "ime", "shape", "role", "kind", "event", "operator", "language", "TYPE", "name", "comment", "tag", "status"], "inputsource": ["submitsource", "InputSource", "inputsum", " inputscope", "pullSOURCE", "Inputstore", " inputource", " inputsample", "uploadstore", "operatorstream", " inputobject", "inputsite", "uploadsource", "outputstore", " inputiterator", "inputobject", "submitsample", " inputsequence", "inputservice", "inputource", "helpiterator", "submitsequence", "insertsource", "outputsource", "inource", "submitsrc", "inputresource", "Inputresource", " inputSource", "insertstore", "othersample", " inputSOURCE", "insource", "Inputsrc", "inputstream", "insertsite", "operatorSOURCE", " inputsum", "operatorseed", " inputseed", " inputstore", " inputservice", "inputsrc", "inputSource", "pullseed", "outputresource", "operatorsource", "pullsource", " inputstream", "acceptsource", "inputiterator", "inputseed", "Inputobject", "helpsite", "inputscope", "acceptsrc", " inputresource", "othersequence", "insertsum", "pullstream", " inputsite", "insertiterator", "inputstore", "Inputsource", "acceptresource", "uploadservice", "inputsample", "insertservice", "outputobject", "helpstore", "outputscope", "othersrc", "insrc", "Inputource", " inputsrc", "acceptscope", "helpsource", "uploadsum", "outputsrc", "othersource", "inputSOURCE", "inSource", "inputsequence"], "url": ["external", "user", "path", "dl", "cert", "net", "http", "URL", "git", "download", "r", "f", "api", "address", "open", "sql", "file", "abs", "l", "ur", "link", "str", "gl", "browser", "string", "client", "web", "html", "nl", "term", "host", "p", "u", "uri", "char", "rl", "xml", "text", "ref", "impl", "mail", "Url", "ml", "buffer", "ssl", "resource", "bel", "base", "rel", "ll", "mount", "sl"], "ds": ["ls", "cs", "dos", "dl", "gs", "dr", "eds", "dh", "ts", "fs", "des", "ys", "gd", "md", "dds", "ysis", "sq", "sts", "ads", "dc", "ees", "uds", "rs", "xs", "df", "pd", "dd", "bs", "Ds", "sys", "dt", "hs", "eps", "js", "ps", "ks", "ss", "sd", "qs", "ws", "DS", "db", "ms", "di", "ns"], "mbeans": ["lubes", "umbean", "Mbs", "mubes", "lbeans", "cmbs", " mbean", "mxbean", "Mubes", "mxubes", "movies", "umovies", "umbeans", "mbs", "mxbs", "cmbean", "lbs", "Mbean", "cmovies", "umbs", "Mbeans", " movies", "mxbeans", "cmbeans", "mbean", "lbean", " mbs"]}}
{"id1": "13563706", "id2": "22264586", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["doget", "DoGET", " doGET", " doget", "handleget", "DoGet", "doGET", "handleGET", " doPut", "handlePut", "handleGet", "doPut", "Doget", "DoPut"], "request": ["setup", "message", "transform", "path", "user", "each", "http", "QUEST", "input", "query", "search", "application", "url", "address", "context", "subject", "project", "first", "reference", "current", "use", "frame", "directory", "route", "Request", "forward", "xml", "initial", "attribute", "document", "command", "version", "view", "socket", "report", "position", "get", "parent", "re", "complete", "connection", "event", "resource", "create", "order", "hello", "reset", "call"], "response": ["reply", "message", "block", "header", "ce", "collection", "format", "display", "http", "search", "write", "application", "output", "description", "frame", "network", "success", "summary", "answer", "zero", "continue", "image", "next", "exit", "ve", "resp", "tree", "version", "document", "default", "result", "foundation", "sequence", "view", "respond", "json", "console", "report", "position", "see", "fire", "render", "condition", "connection", "server", "print", "res", "security", "hash", "Response", "example", "status", "service", "relation"], "selectedPage": ["selectionItem", "electionPage", "selectionFile", " selectedFile", "lectedLine", "selectedLine", "lectedFile", "selectPage", " selectedPort", "specifiedFrame", "selectItem", "selectionPage", "electedPage", "verifiedFile", "selectedDocument", "selectedpage", "namedPort", "matchedPort", "lectedItem", " selectedFrame", "lectedPort", " selectedpage", "singlepage", "selectLine", "namedLine", "matchedpage", "electedPort", "matchedPage", "selectFile", "selectionToken", "singlePage", "singleFrame", "lectedPage", "selectionLine", " selectedRow", "selectedToken", "namedFrame", "namedKey", "specifiedDocument", "selectPort", "lectedRow", "selectPath", "selectedRow", "verifiedRow", "singlePort", "specifiedPort", "lectedDocument", "selectedPath", " selectedPath", "selectedItem", "verifiedPage", "namedPage", "matchedFrame", "lectedKey", " selectedKey", "namedToken", "verifiedpage", "electionDocument", "lectedpage", "lectedToken", "selectedFile", "specifiedPage", "electedpage", "lectedFrame", "selectedKey", "selectedPort", "electionFrame", "namedpage", "lectedPath", "selectedFrame", "electionPort", "selectionPort", " selectedLine", "electedFrame"], "page": ["group", "pp", "project", "current", "phone", "image", "next", "p", "port", "log", "line", "resource", "profile", "node", "filter", "user", "collection", "url", "age", "self", "window", "row", "proxy", "successful", "result", "site", "chain", "pointer", "point", "pool", "table", "message", "block", "application", "instance", "network", "record", "peer", "layout", "version", "Page", "phrase", "channel", "pages", "display", "cache", "number", "office", "associated", "address", "be", "force", "output", "frame", "client", "rule", "created", "menu", "object", "to", "document", "view", "policy", " Page", "position", "form", "parent", "me", "server", "language", "complete"], "portalRequest": ["portaleApply", "portalingAccess", "portalaAccess", "portalityRequest", "portsalResponse", "PortalThread", " portalApply", "portalaCall", "portsortalEvent", "portualRequest", "terminalidQuery", "portortalContext", "portalidSession", "portalContext", "portortalQuery", "portualrequest", " portalCall", "portaleResponse", "portsortalResponse", "portaleSession", "PortalContext", "portaleContext", " portaleCall", "terminalRequest", "portalrequest", "terminalQuery", "PortalQuery", "portalidResponse", "portalingRequest", "portralContext", "PortalResponse", "portpalContext", "terminalResponse", "portalThread", "portalidContext", "portortalRequest", "PortaleContext", "portpalRequest", "portralResponse", "portalidRequest", "portralQuery", "portalFrame", "PortaleThread", "portalidFrame", "portsortalRequest", "portortalThread", " portaleRequest", "portalityResponse", "portpalThread", " portaleApply", "portortalrequest", "portalerequest", "portalingApply", "portalAccess", "portalQuery", "portralSession", "portaleQuery", "portsortalrequest", " portalAccess", "PortalRequest", "terminalidResponse", "portalaRequest", " portaleAccess", "PortalFrame", "portsalrequest", "portortalResponse", "PortaleRequest", "terminalidRequest", "portaleEvent", "portaleCall", "PortaleFrame", "portalityFrame", "portalingCall", "portpalResponse", "portaleThread", "portsalRequest", "portalaApply", "portaleAccess", "PortaleResponse", "portalityContext", "portaleRequest", "portualEvent", "portalApply", "portualResponse", "portalSession", "portsalEvent", "portaleFrame", "portalEvent", "portalidQuery", "PortaleQuery", "portralRequest", "terminalSession", "portalCall", "portortalEvent", "portalResponse", "terminalidSession"], "pageProp": ["poolProp", "propertyPriv", "pagePriv", " pageComp", "propertyProp", "pagePred", "agePro", " pagePriv", "profileZip", "pageProperty", "keyProperty", "profilePred", "poolPred", "phrasePr", "pagePro", "officeProp", "pageComp", "officePriv", "pageZip", " pagePr", "imagePr", "sectionPred", "imageProp", "agePred", "officeDef", "pageDef", "agePr", "propertyDef", " pagePred", "sectionPro", "imagePred", "pagePr", "imagePro", " pagePack", "phraseProperty", "profilePro", "propertyPack", "ageProp", "keyProp", " pagePro", "poolZip", "poolPro", " pageProperty", "sectionProp", "phraseComp", "keyComp", " pageDef", "profileProp", "officePack", "sectionZip", "keyPr", "phraseProp", "pagePack"], "possiblePage": ["PossiblyPage", "PossiblePage", "piblePage", "pibleChild", "pbableCollection", " packedLine", "possiblyCollection", "possibleLine", " possibleTag", "pentialPage", "possiblyUser", "pablePage", "pableLine", "pspecifiedPage", "pspecifiedPages", "packedTag", "possiblyTag", "pbableUser", "possiblyChild", "packedCollection", "possibleChild", " possibleLine", "PossiblePages", "Possiblepage", "PossiblyCollection", " packedTag", " possibleCollection", "pentialTag", "pibleCollection", "possiblepage", "pbableChild", "pspecifiedpage", "pibleUser", "possibleTag", "PossiblyUser", "pbablePage", "pableTag", "possibleCollection", "PossibleTag", "PossibleCollection", "possiblyLine", "possiblePages", " packedCollection", "possiblyPage", "PossiblyChild", "pentialpage", "pableCollection", "pspecifiedTag", " packedPage", "packedPage", "pentialPages", "PossibleChild", "possibleUser", "packedLine", "PossibleUser"], "property": ["message", "header", "value", "Property", "title", "function", "prop", "type", "address", "class", "description", "config", "properties", "second", "frame", "string", "trace", "feature", "key", "rule", "domain", "p", "object", "rue", "expression", "attribute", "owner", "command", "field", "policy", "definition", "position", "behavior", "resource", "metadata", "integer", "location", "operator", "name", "phrase", "relation", "service", "variable"], "referer": ["relender", "relerential", "rorered", "reportrer", "Referee", "retered", "diffrer", "deferer", "refrer", "verrer", "redere", "reonder", "aferential", "refener", "printrier", "afrer", "reener", " refered", "referential", "Refere", "vererential", "refered", "vererer", "requonder", "requering", "retarer", "rorirect", "defrer", "relener", "defirect", "reportered", "refere", "aferer", " refirect", "refonder", "retrer", "relrer", "rorrer", "differer", "rederee", "refering", "refarer", "afener", "fener", "frer", "requerer", "rerier", "rorerer", "reere", "reterer", "reender", "printerer", "refirect", "reering", "rangeender", "reeree", "differing", "ferer", "reerer", "reered", "refender", "diffonder", " refrer", "refrier", "reerential", "redrer", "rangerer", "relering", "rearer", "rederer", "reportarer", "Refrer", "rangeerer", "reporterer", "Referer", "defered", "verrier", "relerer", "fering", "printrer", "printerential", "referee", "rerer", "requrer", "rangeener"], "e": ["r", "f", "err", "oe", "error", "m", "echo", "t", "se", "eg", "ae", "x", "de", "n", "ception", "a", "p", "h", "eeee", "er", "eu", "ge", "E", "te", "ie", "g", "es", "me", "event", "eur", "o", "ee"]}}
{"id1": "3024987", "id2": "8182932", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamWithDecoded", "testCopy_readerToOutputStreamWithDecoding", "testCopy_readerToOutputStream_Choder", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStreamWithEncoder", "testCopy_readerToOutputStream_Decending", "testCopy_readerToOutputStream_Decoded", "testCopy_readerToOutputStream_Choded", "testCopy_readerToOutputStream_Decoding", "testCopy_readerToOutputStream_Choding", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStream_Encending", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStreamWithDecending", "testCopy_readerToOutputStreamWithEncoded", "testCopy_readerToOutputStream_Chending", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStreamWithEncending", "testCopy_readerToOutputStreamWithDecoder", "testCopy_readerToOutputStream_encending", "testCopy_readerToOutputStreamWithEncoding", "testCopy_readerToOutputStream_Decoder"], "in": ["In", "read", "iter", "is", "sin", "init", "input", "rin", "it", "info", "r", "m", "IN", "inn", "Input", "l", "inside", "inf", "bin", "as", " IN", "ins", "n", "source", "from", "mc", "inc", "p", "mi", "ac", "act", "up", "copy", "ind", "din", "mm", "isin", "cin", "con", "i", "gin", "cont", "inner", "data", "local", "ini"], "reader": ["read", "iter", "driver", "Reader", "dr", "input", "query", "r", "red", "oe", "file", "per", "rx", "parser", "loader", "req", "rar", "row", "rise", "rl", "er", "io", "handler", "ner", "rr", "Larry", "writer", "reading", "iterator", "buffer", "rot", "inner", "mr", "ocker", "data", "phrase", "ro"], "baout": ["oain", "haOut", "haouts", "oaout", "caouts", "hain", "baouts", "boin", "BAout", "haout", "yain", "oaOut", "beanOut", "bares", "yaot", "caout", "boOut", "BAot", "caos", "beanin", " baot", "yares", "yaout", "baos", "baot", "beanout", "BAin", "BAres", "boos", "oaos", " bain", "cain", "bain", "caOut", " bares", "baOut", "beanouts", "boout"], "out": ["b", "ex", "OUT", "net", "ou", "all", "update", "output", " bout", " os", "t", "cos", "stable", "bo", "oss", "client", "gt", "Out", "n", "null", " outs", "os", " OUT", "cn", "cmd", "to", "batch", "ao", "copy", "io", "ne", "sys", "outs", " Out", "conv", "OU", "con", "res", "o", "outer", "auto", " output"], "bytes": ["pieces", "unks", "gs", "strings", "files", "gets", "faces", "words", "vals", "ones", "binary", "des", "cells", "versions", "users", "comments", "reads", "reports", "parts", "bps", "ings", "groups", "results", "tes", "resources", "letters", "bits", "services", "bs", "Bytes", "classes", "issues", "ies", "outs", "frames", "ips", "its", "seconds", "pdf", "ites", "units", "videos", "les", "lines", "names", "raw", "objects", "latest", "data", "terms", "es", "values", "pages", "blocks"]}}
{"id1": "4398382", "id2": "13981689", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"digest": ["encest", "digity", "digize", "Digests", "validate", "Digit", "encate", "validest", "Digest", "Digity", "encize", "Digize", "digests", "validests", " digate", " digests", "Digate", "equit", "digate", "equate", "encit", "digit", "validity", "equize", "equest", " digity"], "algorithm": ["ALgo", "algebra", "halgo", "halgorithm", "alitude", "Algebra", "ALitude", "Algorithm", "alterngorithm", "Alitude", "Algo", "alternitude", "isalgorithm", "halphabet", "alchant", "alterngebra", "algo", "isalgo", "alterngo", "halchant", "isalphabet", "ALgorithm", "isalchant", "alphabet", "ALgebra", "Alchant", "Alphabet"], "text": ["message", "path", "read", "template", "value", "title", "input", "aut", "binary", "subject", "filename", "output", "translation", "description", "current", "string", "str", "test", "ext", "TEXT", "image", "term", "word", "source", "txt", "pattern", "char", "password", "document", "username", "physical", "msg", "buffer", "content", "print", "code", "Text", "data", "name", "prefix", "required"], "mDigest": ["mDigitalester", " mDiger", "mDesignse", "mdigse", "MDigester", "mDriest", "mDriet", "mDriested", " mDriested", "MDigse", "mDigester", "Mdigester", "cmDester", "mDigr", "mDose", "MDigest", "mDoester", "mDriester", "mIGse", "mDigse", "mdigest", "cmDest", "cmDigest", "mDigitalested", "mDigested", "cmDigse", "mDesignest", "mDiger", "cmDigester", "cmDr", "mDse", " mDigester", "mdigested", "mDer", " mDigse", "Mdiger", "mdigester", "mIGester", "mDoer", "mDiget", "mDigitalest", "mIGer", "mDr", "mDest", " mDigested", "cmDigr", "mIGest", " mDriet", "mDesignester", "mdiger", "mDigitalet", "mDoest", "mDesignr", " mDriester", "mDester", " mDriest", "mdiget", "Mdigse", "cmDse", "MDiger", " mDiget", "Mdigest", "mdigr"], "raw": ["known", "RAW", "bytes", "full", "secure", "input", "des", "r", "sync", "clean", "core", "unknown", "encrypted", "stable", "row", "rs", "cloud", "orig", "serial", "hook", "cmd", "batch", "sh", "bound", "valid", "Raw", "json", "signed", "unsigned", "form", "hex", "modified", "remote", "re", "log", "aw", "buffer", "custom", "rendered", "pack", "data", "cooked"], "encoder": ["enater", "enode", "enoding", "encaler", "encater", "ENCoding", "Encoder", "Encaler", "enoder", "encode", "decoder", "decode", "Encoding", "ENCaler", "encoding", "enODE", "Encode", "decoding", "Encater", "enaler", "encODE", "ENCoder", "ENCater", "decODE", "EncODE"]}}
{"id1": "8000624", "id2": "19868933", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": ["CopyInt", " copiesFrom", " CopyFrom", " CopyInt", "CopyFrom", " copyInt", " copiesTo", " copyFrom", " copyTo", " copiesInt"], "dest": ["path", "th", "rest", "src", "it", "usr", "filename", "output", "tmp", "dir", "Dest", "origin", "cat", "image", "loc", "fn", "source", "null", "txt", "orig", "p", "them", "img", "nom", "opt", "pipe", "copy", "est", "result", "sp", "st", "w", "target", "temp", "cont", "d", "v", "mem", "name"], "in": ["In", "read", "iter", "is", "sin", "init", "net", "on", "thin", "input", "rin", "al", "it", "win", "r", "file", "ain", "IN", "per", "inn", "reader", "m", "t", "l", "inside", "ire", "inf", "bin", "ai", "client", " input", "ir", "ar", "image", "ins", "one", "source", "inc", "from", "en", "ac", "mi", "up", "ind", "din", "isin", "min", "by", "re", "nin", "cin", "con", "i", "gin", " din", "internal", "inner", "o", "login", "local", "ini"], "out": ["b", "obj", "user", "ex", "at", "full", "net", "OUT", "note", "ou", "it", "all", "write", "dis", "output", "oe", "nt", "list", "ln", "t", "cos", "oss", "client", "gt", "boot", "Out", "n", "one", "null", "end", "fn", "os", "en", "not", "cn", "to", "flush", "up", "batch", "io", "ne", "op", "outs", "w", "writer", "conv", "by", "e", "na", "con", "loss", "co", "inner", "v", "aos", "o", "outer", "can", "other", "ot", "res", "ns"], "c": ["cs", "ce", "cd", "conf", "cap", "sc", "k", "f", "z", "cut", "current", "t", "count", "rc", "bc", "l", "cc", "cb", "cl", "character", "cat", "n", "cp", "ac", "u", "ct", "gc", "unc", "arc", "char", "C", "cm", "nc", "cr", "ch", "cod", "uc", "ca", "e", "g", "ec", "con", "i", "cont", "d", "v", "code", "cf", "lc"]}}
{"id1": "17716716", "id2": "12242903", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 1, "substitutes": {"plainToMD": [" convertToMD", " convertTomd", " stringToDM", " stringFromMD", " stringAsmd", " convertAsmd", " stringFrommd", " convertAsMC", " stringAsMC", " convertToDM", " stringFromDM", " stringAsDM", " convertToMC", " stringTomd", " convertAsMD", " stringToMC", " convertAsDM", " stringAsMD", " stringToMD", " stringFromMC"], "loggerCol": ["loggerCl", "loggerColl", "badgerColl", " logggerCol", " logggerCOL", "loggeCl", "logGERCol", " loggerColumn", "badgerCOL", " loggerCOL", "badinatorCol", "logGERColumn", "badinatorColl", "loggeCOL", "logggerCl", "badgerCl", "badgerCol", "loginatorCl", "logggerColl", "badinatorCOL", "loginatorCOL", "loggeCol", "loginatorColl", " logggerColumn", "badinatorCl", "logiderCOL", "logiderColumn", "loginatorCol", "logGERCOL", "logggerColumn", "loggerCOL", "logiderCol", "logggerCOL", "loggerColumn", "logggerCol", "loggeColl"], "input": ["value", "out", "it", "url", "subject", "context", "output", "file", "request", "config", "Input", "string", "str", "image", "this", "source", "from", "q", "in", "pattern", "up", "char", "initial", "document", "command", "result", " Input", "text", "form", " inputs", "raw", "buffer", "active", "background", "base", "example", "hash", "data", "prefix", "hello"], "byteHash": [" byteMap", "byteMap", " byteTr", "binaryHash", "bytesMap", "byteHas", "ueHash", "uehash", "binaryhash", "bytesHash", "bytehash", " byteHas", "ueLength", "ByteHash", "bytesHas", "ByteHas", " bytehash", "byteLength", "byteshash", "Bytehash", "ByteLength", "ByteTr", " byteLength", "byteTr", "ueTr", "ByteMap", "binaryHas"], "md": ["nd", "ng", " mc", "cd", "dr", "ds", "gm", "mt", " MD", "red", "grad", "MD", "m", "mp", "pm", "rm", "der", "cond", "mk", "mac", "add", "met", "de", "hd", "mo", "mc", "df", "dd", "cmd", "ct", "pd", "comp", "def", "det", "sam", "ded", "msg", "mod", "ind", "mm", "ld", "med", "bd", "od", "dig", "mn", "mb", "material", "gr", "d", " Md", "sd", "hash", "mg", "ms", "di", "sm", "doc", "dm"], "md5result": [" md8Result", "md8message", "MD5results", "md5results", "md3message", "MD5result", "md7string", "md2results", "md3string", "md8proc", "md5comment", " md5Result", "md65Result", "md5message", "MD2Result", "md5response", "md65message", "md45response", " md8proc", "md3results", "MD5Result", "md5string", " md5message", "md2result", "md5proc", "md45result", "md45comment", "MD2results", " md8result", "md64comment", "md64results", "md7result", "md3proc", "md2response", "md8result", "md5Result", "MD5response", "md3result", "md2comment", "md7Result", "MD5comment", "md65result", "md64response", "md7results", "MD2comment", "md3Result", " md5proc", "md65proc", "md8Result", "md45results", "md64result", "MD2response", " md8message", "MD5string", "md2string", "MD2result", "MD2string", "md2Result"], "i": ["b", "iter", "is", "init", "my", "us", "gi", "id", "qi", "it", "xi", "\u0438", "ci", "li", "z", "I", "m", "l", "di", "ai", "ix", "gu", "x", "c", "key", "bi", "n", "ii", "a", "q", "multi", "u", "mi", "uri", "ic", "in", "io", "fi", "ind", "y", "im", "phi", "sim", "ie", "ji", "me", "si", "v", "ei", "pi", "span", "o", "ti", "cli", "j", "ui", "index", "ims", "ip"]}}
{"id1": "23517481", "id2": "18202328", "code1": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 1, "substitutes": {"md5": [" MD2", "MD5", " MD4", " md4", " MD3", " md3", "md3", " MD5", "md4", "MD3", "md2", "MD4", "MD2", " md2"], "uri": ["message", "path", "http", "qi", "uu", "query", "url", "force", "subject", "address", "filename", "du", "file", "description", "uni", "ur", "link", "directory", "ri", "origin", "term", "domain", "q", "u", " URI", "unit", "util", "char", "io", "password", "msg", "course", "requ", "URI", "remote", " ur", "i", "resource", "location", "name", "prefix", "ui", "via"], "messageDigest": ["Messagedigse", "messageDoest", "messageMDer", "messageDigester", "MessageDigest", "messageDigse", "messagedigse", " messageDigse", "messageMDester", " messagedigse", "messageMDse", "messagedigose", " messagedigose", "messagediger", "messageDoose", "messageDose", "messageDigEST", "messagedigment", "messageDigment", " messageDigment", "messagedigest", " messageDigose", "MessageDiger", "Messagedigest", "Messagediger", "messagedigEST", "MessagedigEST", "messageDigose", "messageDoment", "messagedigester", " messagedigment", "MessageDigEST", "messageDiger", "MessageDigester", " messagedigest", "MessageDigse", "messageMDest", "Messagedigester", "messageMDEST"], "bytes": ["sofar", "pieces", "gs", "strings", "files", "gets", "words", "clips", "amps", "gb", "users", "times", "loads", "odes", "s", "bps", "bes", "ings", "groups", "types", "uses", "tes", "ces", "xs", "bits", "bs", "Bytes", "classes", "ies", "outs", "frames", "steps", "images", "seconds", "ions", "buffer", "les", "ors", "terms", "es", "values", "pages", "blocks"], "stringBuffer": ["soundBuff", "StringChannel", "stringChannel", " stringLength", "soundBuffer", "stringView", "stringController", "Stringbuffer", "statusCenter", "stringCenter", " stringChannel", " stringController", "stringBuilder", "stringsQuery", "statusBlock", "stringLength", "libraryBlock", "stringBlock", "statusController", "ringBuilder", "StringLength", "statusBuffer", " stringbuffer", "ringQuery", " stringBuff", "stringbuffer", "StringBuff", "stringBuff", "ringBuffer", "stringsBuffer", "soundbuffer", "libraryController", "libraryCenter", "StringQuery", "StringView", " stringCenter", "stringsBuff", "stringQuery", " stringView", "soundChannel", "ringBuff", "ringView", " stringBlock", "stringsBuilder", "ringLength", "libraryBuffer"], "b": ["obj", "value", "out", "id", "k", "r", "f", "be", "binary", "z", "ib", "gb", "t", "s", "l", "rb", "c", "x", "bi", "n", "a", "p", "u", "h", "bs", "y", "w", "ch", "sb", "e", "nb", "B", "bb", "i", "d", "v", "o", "buff", "j"], "hex": ["xf", "ex", "solid", "com", "full", "ph", "prop", " Hex", "des", "mix", "red", "sv", "zip", "str", "tx", "html", "x", "ext", "term", "color", "pex", "hl", "serial", "h", "def", "percent", "comp", "dump", "sh", "sex", "json", "exp", "uint", "alph", "ch", "form", "bh", "none", "re", "tex", "raw", "escape", "imal", "print", "cf", "rex", "rendered", "hash", "buff", "lit", "hello", "alpha", "oct"]}}
{"id1": "19322941", "id2": "8079516", "code1": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"test_lookupResourceType_FullSearch_TwoWordsInMiddle": ["test_lookupResourceType_FullSearchWithtwoWord", "test_lookupResourceType_FullSearch_twoLetter", "test_lookupResourceType_FullSearch_Threewords", "test_lookupResourceType_FullSearch_Multiwords", "test_lookupResourceType_FullSearch_twowords", "test_lookupResourceType_FullSearch_MultiLetter", "test_lookupResourceType_FullSearch_ThreeLetter", "test_lookupResourceType_FullSearchWithtwowords", "test_lookupResourceType_FullSearch_TwoWord", "test_lookupResourceType_FullSearchWithTwoWords", "test_lookupResourceType_FullSearchWithTwoLetter", "test_lookupResourceType_FullSearch_TwoLetter", "test_lookupResourceType_FullSearch_twoWords", "test_lookupResourceType_FullSearch_ThreeWord", "test_lookupResourceType_FullSearchWithTwoWord", "test_lookupResourceType_FullSearch_MultiWords", "test_lookupResourceType_FullSearchWithtwoWords", "test_lookupResourceType_FullSearch_twoWord", "test_lookupResourceType_FullSearchWithTwowords", "test_lookupResourceType_FullSearch_ThreeWords", "test_lookupResourceType_FullSearch_TwoWords", "test_lookupResourceType_FullSearch_Twowords", "test_lookupResourceType_FullSearch_MultiWord", "test_lookupResourceType_FullSearchWithtwoLetter"], "url": ["ls", "http", "URL", "uu", "open", "f", "r", "l", "ur", "link", "str", "https", "browser", "job", "google", "loader", "nl", "null", "u", "uri", "char", "rl", "document", "el", "get", "impl", "Url", "build", "conn", "ssl", "resource", "ul", "location", "base", "name", "ll", "service", "sl"], "connection": ["operation", "message", "online", "collection", "creator", "Connection", "government", "http", "number", "query", "application", "open", "information", "office", "wrapper", "database", "ion", "description", "session", "request", "reference", "instance", "link", "network", "client", "directory", "character", "entry", "c", "connected", "still", "close", "created", "uri", "established", "computer", "to", "settings", "handler", "command", "console", "socket", "position", "using", "statement", "conn", "con", "condition", "resource", "server", "communication", "creation", "pointer", "response", "connect", "machine", "channel", "relation"]}}
{"id1": "397240", "id2": "5723876", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndResrites", "readAndRepWrite", "readAndResWrite", "readAndRewend", "readAndResend", "readAndrewrite", "readAndrewWrite", "readAndResrite", "readAndRewrites", "readAndrewrites", "readAndReprite", "readAndrewend", "readAndRewWrite", "readAndRepend", "readAndReprites"], "inFile": ["InFile", "inputFilename", "docFile", "docFILE", "iFILE", "iFilename", "INTime", "inFILE", "InFilename", "initPlace", "initFilename", "inputPlace", "docTime", "inFace", "outfile", "infile", "iFile", " inFilename", "initFile", "inPlace", "INPlace", "docFilename", " infile", "inTime", "Infile", "initFace", "INFace", "iTime", "INFilename", "INFile", "INFILE", "inputFile", "inputFace", "inFilename", "outFilename"], "outFile": ["reportFile", " outFilename", "checkFilename", "outFILE", "inFILE", "toFILE", "reportFILE", "tofile", "nameFilename", "outfile", "infile", " outFILE", "reportfile", "reportFilename", "toFilename", "namefile", "nameFile", "toFile", "checkFile", " outfile", "checkFILE", "inFilename", "outFilename", "nameFILE", "checkfile"], "iis": [" iris", "iiIs", "liris", "iIS", "eis", "aiis", "Iiss", "liisc", "Ii", "liIs", "liis", "eIS", "iiisc", "ii", " iiss", "iiss", "iiis", "iiris", " iIs", "iIs", " iIS", "diIs", " ii", "iisc", "IIs", "eIs", "aiIS", "dii", "aiIs", "diis", " iisc", "iris", "Iis", "diiss"], "dcmParser": ["dgrParser", " dpmListener", "dpcReader", "dpmAssistant", "DpmReader", "dcrparser", "dcommReader", " dpmarser", "dcmListener", "dmoduleReader", "dmoduleAssistant", " dpmStatement", "dpmLoader", "dmmParser", " dcmarser", " dpmparser", "dcommListener", "deromParser", "dpmBuilder", "dromparser", "dcmAdapter", "dcrParser", "dfmParser", "dpmStatement", "dmmmReader", " dcmLoader", "dcomReader", "dcmBuilder", "dromAssistant", "DpmAdapter", "dcrBuilder", "dpmPrivate", " dcmPar", "dcomBuilder", "dcrReader", " dpmReader", "dcommAssistant", " dpmLoader", " dcmStatement", " dcmAssistant", "dmmarser", "dmmparser", "DcmBuilder", "dpmarser", "dgrStatement", " dcmBuilder", "dmmmparser", "dcmparser", "dcfStatement", "dromReader", "dcmAssistant", "decmParser", " dcmListener", "deromarser", "Dpmparser", "decmReader", "DcmParser", "dpmAdapter", " dpmParser", "dcmStatement", "dgrReader", " dpmPar", "DpmPar", "dmReader", "decmarser", "dpcAssistant", "DpmBuilder", "dmmReader", "decmparser", "drumParser", "dromarser", " dpmBuilder", " dcmPrivate", "dpcParser", " dpmAssistant", "dcmLoader", "DcmReader", "dromParser", "dmmmParser", " dcmparser", "dmmAdapter", "DpmParser", "drumReader", "dfmReader", "dpmReader", "dgrPar", "dcmReader", "dcfReader", "deromReader", "Dcmparser", "deromparser", "dcommParser", "dmparser", "drumPar", " dcmReader", "dcmarser", "dmarser", "dcmPrivate", "dpmparser", "dcmPar", "dmParser", "dmmmAdapter", "dpcPrivate", "dcfPar", "dromListener", "dcomParser", "dmodulePrivate", "DcmAdapter", "drumBuilder", "dfmBuilder", "dfmLoader", "dpmListener", "dcomLoader", "dpmPar", "dmoduleParser", "dpmParser", "dcfParser", "DcmPar", " dpmPrivate"], "ds": ["ls", "cs", "dos", "dl", "gs", "eds", "dh", "ils", "fs", "des", "vs", "ys", "da", "der", "sv", "s", "gd", "dds", "sets", " des", "as", "ads", "hd", "dq", "rs", "uds", "tes", "xs", "df", "os", "details", "ins", "pd", "dd", "services", "in", "bs", "Ds", "ods", "sys", "obs", "outs", "dt", "hs", "pers", " DS", "eps", "its", "js", "dat", "bd", "ps", "dx", "ks", "ss", "drivers", "sd", "d", "aos", "qs", "data", "ws", "DS", "db", "es", "ims", "ns"], "pdReader": ["ddHelper", "ddParser", "pdLoader", "xdHelper", "pdParser", "tdWriter", "xdLoader", "tdRead", "ddLoader", "vdLoader", "pdRead", "dpCar", "dpLoader", "ddWriter", "ddReader", "pdCar", "ddRunner", "dpRunner", "pedReader", "tdParser", "hdParser", "tdReader", "pedLoader", "pedCar", "hdRead", "pdRunner", "vdHelper", "xdReader", "pdHelper", "hdWriter", "ddRead", "xdWriter", "dpReader", "vdReader", "pedRunner", "hdReader", "ddCar", "vdWriter"], "out": ["over", "full", "on", " err", "err", "t", "str", "ins", "p", "ent", "outs", "ch", "writer", "log", "conn", "con", "co", "sum", "sw", "v", "o", "auto", "name", "status", "gen", "inv", "obj", "ex", "ou", "all", "id", "nt", "s", "cb", "c", "end", "txt", "os", "nr", "cn", "in", "desc", "conv", "serv", "raw", "inner", "outer", "pool", "cfg", "at", "net", "tmp", "list", "pos", "Out", "n", "en", "up", "io", "sys", "w", "js", "aos", "res", "data", "we", "OUT", "cache", "it", "output", "oss", "client", "gt", "one", "null", "screen", "go", "cmd", "to", "opt", "flush", "msg", "gr", "inter"], "dcmEncParam": ["dcmEnPar", "dcmEnVal", "dcmencCmd", "dcmEncVal", "dcmEnParam", "dcmencParam", "dcmEscPar", "dmmencParam", "dcmDecParam", "dmmEncCmd", "dcmEncCmd", "dcmencNum", "dmmEncMsg", "dmmencNum", "dmmEncPar", "dcmEncPar", "dcmEscNum", "dmmEnPar", "dcmDecCmd", "dcmEncMsg", "dcmEnNum", "dmmEnNum", "dcmEscVal", "dcmDecMsg", "dcmEscParam", "dmmEncParam", "dmmencCmd", "dmmEnParam", "dmmEncNum", "dcmEncNum", "dcmDecNum", "dcmencPar", "dcmencMsg", "dmmEncVal", "dmmencMsg"], "pdWriter": ["dpEditor", "PDReader", "tdWriter", "dpWriter", "pidWrite", "PDWriter", "pdwriter", "pidWriter", "PDWrite", "tdWriting", "tdReader", "PDEditor", "pidwriter", "pidWriting", "dpWrite", "tdwriter", "pcWriter", "pcWrite", "pdWrite", "pdWriting", "pcwriter", "tdWrite", "pdEditor", "pcWriting", "dpReader", "tdEditor"]}}
{"id1": "6470716", "id2": "13783898", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"st": ["sta", "nd", "th", "rest", "sth", "tt", "ste", "store", "ft", "std", "ust", "t", "ist", "rt", "se", "stable", "str", "stra", "sts", "inst", "sn", "stream", "ST", "sty", "ast", "ost", "est", "sh", "www", "sp", "set", "St", "step", "ld", "d", "stri", "sw", "start", "service", "sm"], "url": ["ls", "rect", "dl", "rest", "cert", "http", "URL", "r", "f", "address", "li", "shell", "file", "abs", "l", "ur", "gl", "string", "fl", "browser", "str", "client", "cl", "link", "web", "html", "nl", "loc", "domain", "null", "hl", "host", "mount", "uri", "addr", "char", "github", "il", "www", "el", "ch", "ref", "ret", "impl", "mail", "Url", "build", "ssl", "ul", "bel", "location", "base", "rel", "ll", "pl", "sl"], "fis": [" fisl", "ufi", "tais", "fois", "feois", "tiss", "Fier", "fier", " f\u00eds", "feier", "efiss", "xfier", "Fis", "xfi", "tis", "fisl", "ef\u00eds", "Fais", "fei", "ufis", "fiss", "f\u00eds", "flisl", "ufisl", "fais", " fais", "ufiss", "fliss", "fi", "tos", " fiss", " fi", "feis", "xfois", "uf\u00eds", "efis", "Fois", "flis", "xfis", "fli", "efi", "Fos", "Fi", "Fiss"], "zis": ["zos", "zenisi", "zipos", "zhisin", "zeniss", "ozIs", "zipisin", "czIs", " zIs", "zipits", "zenris", "zris", " zisa", " zisi", "czisa", "zits", "zhis", "zhes", "fiss", "czis", "ozisin", " zos", " zits", "zipis", "zipIs", "fris", "czits", "zisi", "zisin", "zipes", "ozes", "zisa", "zIs", " zris", "fisi", "zes", " ziss", "fits", "ozis", "zenis", "ozisa", "zhIs", "ziss", "ozits"], "entry": ["obj", "item", "match", "ce", "jar", "or", "zo", "out", "office", "info", "card", "be", "tmp", "nt", "list", "zip", "link", "se", "cell", "jo", "record", "Entry", "system", "key", "existent", "word", "de", "row", "null", "source", "ent", "def", "pattern", "char", "way", "attribute", "result", "field", "element", "valid", "sp", "form", "ie", "e", "log", "entity", "line", "enter", "chain", "event", "inter", "ry", "name", "comment", "index", "fr", "member"], "count": ["Count", "read", "match", "iter", "check", "counter", "number", "force", "err", "nt", "amount", "core", "current", "t", "add", "ctr", "cell", "cc", "size", "c", "found", "n", "end", "page", "ct", "num", "batch", "len", "char", "acc", "ind", "length", "last", "ch", "nb", "buffer", "cont", "max", "total", "sum", "code", "depth", "base", "start", "name", "ount", "comment", "index", "child", "call"], "data": ["message", "bytes", "block", "value", "format", "cache", " DATA", "number", "out", "all", "mu", "output", "done", "string", "bin", "size", "zero", "image", "reason", "n", "next", "source", "def", "good", "batch", "area", "part", "result", "json", "text", "DATA", "length", "step", "dat", "chain", "buffer", "ata", "raw", "buf", "d", "sample", "mem", "name", "table"], "fos": ["foos", "hOS", "fios", "foops", "wOS", "wis", "Foss", "foss", "fops", "hos", "fOS", "Fol", "hoss", "fol", "fiol", " foss", "wos", "fooss", "fool", "woss", "fiops", " fOS", "Fops", "his", "Fos", "fioss"], "dest": ["nd", "rest", "src", "ptr", "gest", "out", "des", "comb", "usr", "output", "std", "nt", "done", "Dest", "send", "bin", "test", "origin", "cat", "dc", "loc", "crit", "source", "nom", "them", "gate", "comp", "decl", "pipe", "det", "way", "master", "est", "result", "desc", "coord", "target", "exp", "writer", "dat", "foreign", "parent", "temp", "trans", "dist", "cont", "sum", "transfer", "mem", "member", "pas"]}}
{"id1": "21348951", "id2": "20663364", "code1": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"processAddByURLSubmit": ["processAddByURLSubit", "processAddByURlsubmit", "processAddByURLSubsmitted", "processAddByURLSUBmitted", "processAddByURlsubmission", "processAddByURLSubmission", "processAddByURLSUBmit", "processAddByURlsummission", "processAddByURLSumit", "processAddByURlsumit", "processAddByURLSubsmit", "processAddByURLSUBmission", "processAddByURlsummitted", "processAddByURlsubit", "processAddByURLSubsit", "processAddByURLSubmitted", "processAddByURlsubmitted", "processAddByURLSUBit", "processAddByURLSubsmission", "processAddByURlsummit", "processAddByURLSummission", "processAddByURLSummit", "processAddByURLSummitted"], "url": ["ls", "external", "rect", "path", "item", "dl", "http", "URL", "input", "id", "force", "address", "file", "use", "l", "ur", "link", "string", "str", "browser", "email", "web", "html", "nl", "key", "loc", "run", "page", "q", "u", "uri", "addr", "util", "char", "rl", "document", "el", "ref", "impl", "mail", "Url", "ssl", "resource", "ul", "location", "base", "bel", "name", "ll", "mount", "sl", "un"], "invalidUrlMsg": ["invalidFileLog", "inInvalidURLStr", "inInvalidStrMsg", "invalidUrMessage", "inInvalidUrlMsg", "inInvalidUrlLog", "inInvalidUrlStr", "invalidURLStr", "invalidurlMsg", "inInvalidStrMessage", "invalidFileMsg", "invalidURLmsg", "invalidurlStr", "invalidurlmsg", "invalidStrMessage", "inInvalidUrlMessage", "inInvalidURLmsg", "invalidFileMessage", "invalidUrlMessage", "invalidUrlStr", "invalidUrlmsg", "invalidUrmsg", "invalidUrLog", "invalidUrMsg", "inInvalidURLMsg", "invalidStrMsg", "invalidURLMsg", "inInvalidUrlmsg", "invalidStrLog", "invalidFileStr", "invalidUrlLog", "invalidStrStr", "inInvalidStrLog", "inInvalidStrStr", "invalidUrStr"], "xmlSourceWriter": ["xmlSourceFileWriter", "xmlsourceReader", "jsonStringWriter", " xmlSourceRW", "xmlsourceWriter", "jsonSourceReader", " xmlSourceWrite", "xmlSourceFileBuilder", "jsonStringCode", "xmlSourceFileRW", "xmlSourceRW", "xmlStringReader", "xmlSourceBuilder", "xmlStringWriting", " xmlSourceWriting", "jsonStringReader", "xmlSourcesReader", "jsonSourceCode", "xmlSourcesWriter", "xmlsourceRW", "jsonSourceWriter", "xmlSourceCode", "xmlStringCode", "xmlsourceBuilder", "xmlsourceWriting", "xmlsourceWrite", "xmlSourceWriting", "jsonStringWriting", "jsonSourceWriting", " xmlSourceReader", "xmlSourceFileWriting", "xmlStringWriter", "xmlSourcesCode", "xmlSourceReader", "xmlSourcesWriting", " xmlSourceBuilder", "xmlSourceWrite"]}}
{"id1": "471804", "id2": "16215393", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doDatecheck", "doLicenseCheck", "doDateFix", "DoVersionFix", "doVersionFix", "doVersioncheck", "DoVersioncheck", "doVersionsFix", "DoDatecheck", "DoVersionUpdate", "doVersionUpdate", "doDateUpdate", "DoDateCheck", "doDateCheck", "doVersionsCheck", "DoDateUpdate", "doLicensecheck", "DoDateFix", "doVersionscheck", "doVersionsUpdate", "doLicenseUpdate", "doLicenseFix", "DoVersionCheck"], "view": ["block", "check", "review", "display", "http", "out", "input", "update", "query", "subject", "widget", "open", "context", "blade", "wrapper", "file", "help", "browser", "cell", "VIEW", "client", "web", "html", "self", "window", "image", "row", "this", "page", "q", "hl", "host", "cv", "table", "manager", "tv", "layout", "util", "index", "tree", "component", "document", "eye", "console", "show", "report", "form", "see", "engine", "get", "controller", "buffer", "server", "print", "v", "model", "views", "View", "iew", "doc", "call"], "url": ["b", "ls", "path", "dl", "http", "URL", "lr", "id", "r", "address", "f", "file", "l", "ur", "gl", "link", "str", "browser", "string", "client", "web", "html", "nl", "org", "loc", "null", "hl", "lb", "host", "mount", "uri", "char", "rl", "github", "json", "socket", "Url", "log", "ssl", "date", "oul", "ul", "v", "bel", "location", "language", "rel", "ll", "pl", "sl"], "in": ["In", "b", "is", "sin", "init", "out", "input", "rin", "info", "f", "ln", "ain", "IN", "file", "inn", "reader", "l", "inf", "vin", " IN", "stream", "ins", "n", "source", "inc", "kin", "body", "mat", "din", "isin", "cin", "mn", "i", "gin", " din", "asin", "inner"], "bin": ["b", "sin", "obin", "thin", "out", "cache", "rin", "win", "binary", "lib", "ln", "file", "bl", "inn", "reader", "cos", "rb", "abin", "loader", "bi", " Bin", "bg", "pipe", "len", "sam", " bins", "ebin", "din", "stock", "by", "nb", "bn", "mon", "cin", "con", "conn", "buffer", "gin", " din", "spin", "ran", "inner", "mem", "buff", "bed", "bur", "local"], "line": ["ls", "LINE", "path", "block", "range", "liner", "iter", "channel", "store", "lo", "err", "ln", "file", "col", "inline", "frame", "ine", "l", "string", "eline", "cell", "load", "link", "se", "record", "lin", "entry", "job", "trace", "cat", "word", "row", "section", "page", "le", "one", "cmd", "Line", "char", "part", "el", "field", "state", "text", "body", "style", "port", "log", "no", " Line", "ice", "lines", "chain", "print", "level", "ide", "base", "sample", "code", "column", "point", "comment", "lane"], "version": ["match", "value", "format", "title", "number", "ver", "update", "type", "info", "iso", "versions", "translation", "project", "ion", "description", "vers", "video", "string", "release", "browser", "python", "client", "test", "feature", "virtual", "key", "image", "VERSION", "software", "serial", "major", "Version", "scale", "command", "spec", "sequence", "river", "position", "form", "usage", "license", "VER", "date", "vision", "resource", "v", "hash", "latest", "language", "name", "tag", "volume", "status", "index"], "build": ["b", "dev", "develop", "match", "th", "full", "install", "fail", "make", "where", "ver", "update", "binary", "be", "lib", "project", "ward", "Build", "use", "add", "boost", "link", "release", "load", "builder", "test", "bor", "struct", "unit", "building", "util", "work", "old", "last", "round", "style", "uild", "bug", "log", "dist", "date", "hold", "print", "hash", "ble", "other", "ship", "tag", "db", "latest", "built", "arch"]}}
{"id1": "5836744", "id2": "14038176", "code1": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"read": ["check", "init", "parse", "input", "Read", "query", "write", "download", "open", "find", "sync", "reader", "stat", "reads", "load", "test", "stream", "run", "READ", "close", "handle", "access", "show", "report", "reading", "get", "process", "buffer", "seek", "print", "create", "data", "scan", "connect", "readable", "index", "ready"], "name": ["message", "path", "value", "title", "on", "id", "search", "type", "info", "address", "filename", "file", "ma", "t", "link", "string", "str", "client", "size", "nm", "nl", "Name", "image", "n", "word", "term", "null", "key", "domain", "uri", "version", "default", "part", "sp", "named", "state", "mod", "old", "w", "ame", "ref", "parent", "no", "NAME", "names", "event", "code", "location", "start", "mem", "create", "data", "base", "comment", "order", "prefix", "local", "normal"], "status": ["ex", "check", "US", "dr", "format", "wait", "id", "progress", "update", "sc", "type", "iso", "err", "sync", "error", "description", "login", "stat", "use", "s", "gl", "comments", "str", "summary", "success", "mode", "size", "x", "uses", "score", "continue", "source", "iss", "details", "exit", "gc", "flag", "handle", "ping", "char", "scale", "version", "Status", "xml", "result", "msg", "state", "sequence", "st", "console", "json", "set", "access", "report", "ssl", "complete", "server", "print", "v", "code", "cli", "prefix", "index", "service"], "url": ["user", "dl", "cert", "net", "http", "URL", "r", "f", "open", "li", "pkg", "l", "ur", "gl", "link", "fl", "str", "browser", "client", "cl", "web", "html", "nl", "hl", "host", "char", "rl", "www", "ref", "mail", "Url", "build", "log", "ssl", "ul", "bel", "base", "rel", "ll", "mount", "service", "sl"], "in": ["In", "pin", "is", "or", "out", "input", "all", "al", "rin", "m", "ma", "IN", "file", "inn", "reader", "pc", "ai", "bin", "client", "stream", "ins", "source", "inc", "mc", "from", "en", "mi", "io", "body", "im", "din", "form", "isin", "cin", "con", "serv", "i", "gin", "sum", "inner", "ini"]}}
{"id1": "19584877", "id2": "17630906", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static int[] sortAscending(float input[]) {\n        int[] order = new int[input.length];\n        for (int i = 0; i < order.length; i++) order[i] = i;\n        for (int i = input.length; --i >= 0; ) {\n            for (int j = 0; j < i; j++) {\n                if (input[j] > input[j + 1]) {\n                    float mem = input[j];\n                    input[j] = input[j + 1];\n                    input[j + 1] = mem;\n                    int id = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = id;\n                }\n            }\n        }\n        return order;\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileFromFiles", "encodeStringToFile", "encodeFileToFiles", "encodeStringAsDisk", "encodeFileFromStream", "encodeFileFromDisk", "encodeStringAsFile", "encodeFileAsFiles", "encodeFiletoFile", "encodeFiletoFiles", "encodeStringToStream", "encodeFileAsFile", "encodeFileAsDisk", "encodeFileAsStream", "encodeFileFromFile", "encodeStringAsStream", "encodeStringToDisk", "encodeFiletoDisk", "encodeFiletoStream", "encodeStringToFiles", "encodeFileToStream", "encodeStringAsFiles", "encodeFileToDisk"], "infile": ["InFile", "inputfile", "outbase", "inbase", " inFile", "inFile", "outpath", "Inbase", "outFile", "Inpath", " infilename", "Infile", "outfilename", "infilename", "inpath", "inputpath", "inputfilename", "inputFile", " inpath", " inbase"], "outfile": ["inname", "newfile", " outname", "newname", "newfilename", "newFile", "inFile", "tofile", "todir", "fromfp", " outfilename", "infp", "outFile", "fromfile", "outdir", "indir", "fromdir", "tofp", "toFile", "outfp", " outFile", "outfilename", "infilename", "fromFile", "outname"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "image", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ro", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "null", "fn", "os", "en", "cn", "to", "flush", "up", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "can", "aos", "o", "res", "outer", "inner", "ot"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "queue", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "length", "black", "stack", "temp", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", "commit", "ccess", "cess", "value", "accept", "fail", "growth", "warning", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "ith", "successful", "good", "please", "ceed", "town", "result", "valid", " Success", "successfully", " okay", " failure", "ratulations", "photo", "sufficient", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "14093044", "id2": "17202157", "code1": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "code2": "    static Matrix readMatrix(String filename, int nrow, int ncol) {\n        Matrix cij = new Matrix(nrow, ncol);\n        try {\n            URL url = filename.getClass().getResource(filename);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            for (int i = 0; i < nrow; i++) for (int j = 0; j < ncol; j++) cij.set(i, j, Double.parseDouble(lnr.readLine()));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return cij;\n    }\n", "label": 0, "substitutes": {"insert": ["commit", "put", "check", "init", "update", "query", "write", "sql", "save", "select", "database", "login", "Insert", "add", "exec", "append", "load", "push", "submit", "set", "delete", "create", "execute", "scan", "replace", "index"], "consulta": ["conultaria", "consultla", "consumera", "consumptionla", "concenta", "consumerana", "Consumeras", "Consumerana", "conultsas", "Consulta", "consultsa", "conscentar", "Consumera", "consultas", "consumea", "conultae", "consertar", "conultsae", "conscentas", "conultas", "consumptionable", "Conscentla", "consaulta", "conscentana", "consertae", "consultsaria", "consulsae", "conscentae", "consulsaria", "ConsumerA", "Consultana", "consumptionas", "consulsas", "conultar", "conscentable", "Conscentable", "concentas", "consultable", "concentar", "consaultaria", "consultar", "consultsae", "Consultas", "consaultA", "Consultla", "consumeas", "consultaria", "conscentA", "Conscenta", "consumeras", "consaultana", "conulta", "consumeable", "conscenta", "Consultable", "consultae", "consumptionae", "consulsa", "consertas", "consumela", "consumptiona", "conserta", "conultsaria", "consultana", "consumerA", "Conscentas", "concentae", "consaultas", "conultsa", "consultsas", "ConsultA", "consumptionar", "consultA", "consaultae", "conscentla"], "autocommit": ["autoconombit", "autocommulate", "autocubits", "autocumnate", "autocomulate", "autoccelerulate", "autocomits", "autoconomate", "autocommate", "autocompate", "autocomort", "autococomate", "autocondite", "autocommort", "autococomit", "autoconommmit", "autOCommits", "autOComits", "autococomulate", "autocompbit", "autoccelerort", "autoccelerit", "autocommbit", "autoconommit", "autocomit", "autocondits", "autoccelermit", "autOComit", "autOCommit", "autOComulate", "autocompmit", "autocompit", "autocondort", "autOCommort", "autOComate", "autOComort", "autoconommate", "autOCommmit", "autocomate", "autocommits", "autocondit", "autocombit", "autocumnbit", "autocubit", "autOCommite", "autocondmit", "autOCommate", "autocumnmit", "autocondulate", "autoconomit", "autocubite", "autocubmit", "autOCommulate", "autocommmit", "autoconommbit", "autocumnit", "autocommite", "autocompulate", "autocomite", "autococommit", "autOComite"], "transactionIsolation": ["transceptionIsensitivity", "transactionStyleensitivity", "transactionISOL", "transceptionIensitivity", "transactionIsilon", "transceptionIsulation", "transactionStyleilon", "transactionInterolated", "transceptionIulation", "transactionISolated", "transversionIsavior", "transpointInterolation", "transactionIdration", "transceptionIsOL", "transactionIsulation", "transceptionIolated", "transactionInolation", "transactionInOL", "transceptionIsolation", "transactionAsularity", "transversionIsolation", "transceptionIilon", "transactionISavior", "transceptionIsolated", "transactionIfolated", "transceptionIsularity", "transactionInolated", "transactionAsolated", "transversionIsolate", "transactionISensitivity", "transceptionIolation", "transactionInterolate", "transactionInterruption", "transactionIsration", "transactionStyleolation", "transactionIsensitivity", "transactionIularity", "transactionAsolate", "transversionIdolation", "transactionIulation", "transactionIolate", "transpointIsruption", "transceptionIularity", "transactionInsolation", "transactionIsularity", "transactionIsavior", "transactionIsolated", "transactionStyleolate", "transactionInsration", "transversionIsration", "transactionIsola", "transactionInterola", "transactionInsavior", "transversionIdration", "transactionISolate", "transactionAsolation", "transactionISulation", "transactionISolation", "transceptionIOL", "transactionIensitivity", "transceptionIsilon", "transactionIOL", "transceptionIsolate", "transactionIfolation", "transactionInolate", "transactionIsruption", "transpointIsolation", "transactionIsOL", "transactionIdavior", "transactionInterularity", "transactionISilon", "transpointIsola", "transceptionIolate", "transactionIfola", "transactionIilon", "transactionISola", "transpointInterola", "transactionInsolate", "transactionInterulation", "transversionIdavior", "transactionInterolation", "transactionIsolate", "transpointIsolated", "transactionIolated", "transpointInterruption", "transactionISration", "transactionIdolation", "transactionIfruption", "transactionIolation", "transversionIdolate", "transactionISruption", "transactionIdolate", "transpointInterolated"], "cx": ["cxt", "ctx", " cxi", " ctx", "acxt", "Cxi", "cxi", "Cxt", "Ctx", " cxt", "Cx", "ncX", "actx", "cX", "nctx", "ncx", "ncxi", "acx", " cX", "CX", "acX"], "filasInsert": ["filrasUpload", "folasEnter", " filasaAdd", "filasAdd", "filataImport", "filASInsert", "folasRow", " filasaInsert", "filasUpload", "filasRow", "filrasUpdate", "filiasImport", "filasaUpload", "filrasAdd", " filasaUpdate", "filasaUpdate", "filinasEnter", "fundasDelete", "filASImport", "folASEnter", "filASRow", "filaInsert", "fundaDelete", "filinasUpload", "filacsEnter", "filaDelete", "filasUpdate", "filasEnter", "fundasImport", "filataInsert", "folasInsert", "filinasAdd", "filinasUpdate", "filinasInsert", " filasaUpload", "filaImport", " filasUpload", "filrasInsert", "folasImport", "filacsInsert", "fundaInsert", "filiasInsert", " filasAdd", "filacsRow", "filinasImport", "fundaImport", "folASInsert", "filasImport", "folASImport", "fundasInsert", "filiasDelete", "folASRow", " filasUpdate", "filasaAdd", "filasDelete", "filacsImport", "filataDelete", "filinasRow", "filASEnter", "filasaInsert"], "tipoConsulta": ["tipoConsultas", "tipoConsultA", "tipoconsultsada", "tipoConistara", "tipoConsulas", "tipoConistas", "tipoConsultsao", "tipoConsultsA", "tipoconsultsa", "tipoConsulsas", "tipoConsulsa", "tipoConsultsa", "tipoConsulao", "tipoConsumera", "tipoCoultada", "tipoCoultao", "tipoCoultar", "tipoConsulsao", "tipoconsultas", "tipoCoulta", "tipoConsultsas", "tipoConsulara", "tipoConsulsA", "tipoConultas", "tipoConsultada", "tipoConsultsada", "tipoCoulsao", "tipoConsistao", "tipoConista", "tipoConistao", "tipoConsumptiona", "tipoConsumerA", "tipoConsumptionao", "tipoCoulsa", "tipoConsistas", "tipoconsultsas", "tipoconsulta", "tipoConsulsada", "tipoConsultar", "tipoConsumptionara", "tipoConsultao", "tipoConsresenta", "tipoCoulsar", "tipoConsresentar", "tipoconsultsA", "tipoConsista", "tipoconsultA", "tipoConultao", "tipoConsresentao", "tipoConsultsar", "tipoCoulsada", "tipoConsistara", "tipoConsula", "tipoConsumeras", "tipoConulta", "tipoconsultada", "tipoConsultara", "tipoConsumptionas", "tipoConsulsar", "tipoConultara", "tipoConsresentada", "tipoConsumerada"], "execConsulta": ["execConsultalpha", "execConsaultar", "execConsaultas", "execConsultar", "execConsortiumalpha", "execCoulta", "execConsumea", "execCoertai", "execConsertai", "execConsertarea", "execConsumela", "execConsertalpha", "execCoultarea", "execConsonsealpha", "execConulta", "execConsortiumarea", "execConsultas", "execConsonsea", "execConsortiumai", "execConultla", "execCoultai", "execCoerta", "execConsortiuma", "execConsultarea", "execConsumear", "execConsultai", "execConsonseai", "execConultar", "execConsonsearea", "execConsumeas", "execConserta", "execCoertalpha", "execCoultalpha", "execConsaulta", "execConsultla", "execCoertarea", "execConultas", "execConsaultla"], "conexion": ["coextision", "coexione", "coexION", "coextion", "cakexION", "conextION", "coneplexison", "coexison", "coneuxions", "conextion", "coneixison", "caxison", "coneaxione", "caixion", "conextions", "coneuxinion", "Colexpions", "conexpion", "coexions", "coneplexion", "coneexible", "coexision", "coeexION", "Colexpion", "cakexison", "conenexression", "cakexpion", "conexpION", "Colexison", "Colexions", "coneaxison", "conexinion", "coeexion", "conenexION", "conenexions", "cakexpION", "coneaxision", "coexinion", "coneuxion", "coeuxinion", "Colexone", "coneexision", "coextison", "coneplexION", "coneXione", "coneixion", "coneplexione", "coexible", "conexions", "conenexion", "coneXION", "caxION", "coneixION", "conexression", "coneexone", "coneXion", "coeexible", "conexION", "coneexione", "conenexible", "coextione", "Colexion", "Colexpone", "coexion", "conenexone", "coneuxION", "coeexison", "conenexinion", "Colexpison", "conexpions", "coneixression", "cakexione", "coeexione", "conenexione", "conexione", "conextione", "coeuxion", "coexond", "cakexpione", "coneixond", "conexison", "conextison", "coneexison", "coneXible", "conextision", "conexond", "conexpison", "coneexION", "caxion", "coneexond", "caxression", "coeuxions", "conexpone", "coneaxion", "coneixione", "coneexion", "caixison", "conexpond", "conexible", "caixION", "conextinion", "coeuxION", "conexision", "conenexison", "cakexion", "caixression", "conextression", "coeexond", "coneexions", "conexone", "conexpione", "cakexpison"], "st": ["obj", "pt", "nd", "sl", "put", "rest", "sth", "src", "stop", "tt", "ste", "ts", "it", "sc", "mt", "tmp", "std", "ust", "stat", "t", " ST", "ist", "ut", "se", "str", "stable", "sle", "cl", "sts", "inst", "sn", "end", "null", "ST", "sty", "pe", "ct", "ost", "est", "sh", " est", "sp", "state", "set", "St", "statement", "stage", "sw", "start", "sm"], "MySQL": ["myDB", "MyDB", "MYQL", "mysDB", "mySQL", "MYDB", "MyQL", "MYSQL", "myQL", "mysSQL", "mysQL"]}}
{"id1": "13657527", "id2": "22401746", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "label": 1, "substitutes": {"getDatasetsList": ["getDatasuresList", "getDatasesList", "getDatasuresResult", "getDatasetsStatus", "getDatisetsList", "getDatasetList", "getDatisetResult", "getDatasesStatus", "getDatisetStatus", "getDatasetResult", "getDatasetStatus", "getDatisetsStatus", "getDatisetsResult", "getDatasesResult", "getDatisetList", "getDatasuresStatus", "getDatasetsResult"], "surl": ["lsmail", "sUrl", "esUrl", "suri", "sysurl", "stslt", "syslt", "stsurl", "sname", "slim", "lsserver", "jslim", "esname", "sserver", " smail", "lsUrl", "stsserver", "esURL", "lsuri", "sslim", " sname", "sysuri", "esurl", "ssurl", " suri", "stsuri", "jsUrl", "esuri", "ssuri", "lsurl", " sUrl", "lslt", "sURL", "ssURL", "smail", "ssUrl", "slt", "jsuri", "sysserver", "jsurl"], "datasetsList": ["datisetsMap", "datarsetsMap", "datarssetsTable", "datasetsMap", "datasagesData", "datmasetsList", "datassetslist", "dataselinesGroup", "datasETSMap", "datasETSGroup", "datarsetsLock", "datasenslist", "datasagesSet", "datarsetslist", "datasetsName", "datasETSName", "datmassetsData", "datmassetsList", "datassetsSet", "datasagesMap", "datassetsLock", "datasetGroup", "datmassetsMap", "datarsetsList", "datasamesMap", "datassetsData", "datasetData", "datasetLock", "datarssetsLock", "datasourcesTable", "datasensList", "datarssetsList", "datasetName", "datasuresMap", "datmassetsLock", "datassetsTable", "datmasetsLock", "datasagesLock", "datasamesSet", "datasetList", "datasensMap", "datasETSList", "datasagesTable", "datasetSet", "datasamesList", "datisetsList", "datasourcesList", "datassetsMap", "datassetsList", "datisetMap", "datisetsName", "datisetName", "datarsetlist", "datasetMap", "datasetsLock", "dataselinesMap", "datasetsGroup", "datisetGroup", "datarsetsSet", "datisetList", "datasureslist", "datasuresSet", "datmasetsMap", "datarssetsSet", "datasourcesLock", "datisetsGroup", "datasameslist", "dataselinesName", "dataselinesList", "datasetsTable", "datasetsData", "datasetlist", "datarsetList", "datarsetSet", "datmasetsData", "datasourcesSet", "datarsetsTable", "datasetsSet", "datasuresList", "datasagesList", "datasetslist", "datarsetMap"], "result": ["Result", "message", "there", "exist", "cert", "search", "relation", "first", "description", "success", "record", "answer", "test", "found", "results", "detail", "details", "menu", "successful", "def", "default", "valid", "sequence", "set", "successfully", "folder", "report", "form", "ret", "chain", "buffer", "complete", "contact", "res", "response", "comment", "status", "diff", "table"], "reader": ["read", "driver", "rer", "liner", "Reader", "dr", "iter", "range", "query", "r", "wrapper", "older", "author", "file", "ser", "per", "parser", "bo", "client", "loader", "test", "roller", "peer", "rar", "stream", "row", "READ", "layer", "handle", "rl", "er", "runner", "upper", "handler", "field", "ner", "via", "rr", "body", "river", "socket", "writer", "reading", "redo", "iterator", "buffer", "timer", "rd", "resource", "inner", "mr", "operator", "ro"], "url": ["ls", "user", "dl", "http", "URL", "lr", "id", "r", "address", "file", "l", "ur", "link", "str", "browser", "client", "loader", "web", "org", "nl", "key", "stream", "row", "null", "uri", "char", "rl", "il", "mail", "Url", "ssl", "resource", "ul", "location", "ll", "mount", "sl"], "s": ["ls", "b", "cs", "gs", "is", "full", "gets", "strings", "us", "ts", "ds", "sql", "r", "ats", "sv", "abs", "t", "csv", "l", "str", "string", "less", "sym", "sts", "as", "sq", "n", "rs", "source", "tes", "still", "os", "ins", "h", "bs", "S", "y", "hs", "its", "js", "sb", "has", "ps", "series", "i", "ss", "v", "sw", "qs", "sample", "ws", "ids", "ms", "es", "ns"], "list": ["ls", "block", "group", "collection", "dl", "full", "format", "note", "lists", "all", "array", "li", "join", "php", "ist", "l", "left", "add", "pretty", "pool", "top", "test", "L", "word", "detail", "single", "def", "batch", "layout", "listed", "part", "sequence", "set", "st", "form", "stack", "log", "LIST", "ml", "chain", "cont", "print", "ll", "member", "local", "table"]}}
{"id1": "13757855", "id2": "15768167", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"process": ["transform", "format", "display", "parse", "write", "save", "project", "task", "processing", "apply", "add", "load", "proc", "Process", "run", "processor", "handle", "loop", "step", "build", "render", "create", "execute", "replace", "filter", "call"], "tpl": ["tmplate", " tpp", "topl", "Tph", "timplate", "tuple", "ptpl", "ttplug", "stpg", "ttph", "tpr", "timpg", "stspl", "tsurtle", "templ", "tembl", "Tpp", " tph", "ttPL", "tmplates", " tPL", "tpp", "tspl", "tmpp", "atuple", "ptbl", "tbl", "otbl", " tplate", "stbl", "itPL", "ttbl", "tsPL", "Tld", " tbl", "terld", "Tspl", "ttpl", "timspl", " tplates", "Tpr", "TPL", "ptld", "stplug", "itpl", "tmpl", "turtle", "timopl", "atpl", "itplate", "Tbl", "ttopl", "Tplate", "tspr", " turtle", "terplate", "timbl", "otld", "atplate", "atld", "tplate", " tuple", "itbl", "timpl", "otplate", "ptplates", " tld", "stpl", "tempr", "Tpl", "typl", "stplate", "tsbl", "teruple", "Tplates", "tmPL", "otpl", "tPL", "tplug", "timplug", "tyPL", "tmbl", "tld", "stopl", "tpg", "terpl", "temPL", "ttpg", "tyurtle", "tplates", "tph"], "model": ["models", " Model", "M", "Document", "project", "m", "file", "md", "product", "record", "html", "object", "tree", " models", "document", "el", "Model", "parent", "log", "ml", "module", "content", "base", "data", "node"], "packageName": [" packageNames", "Packagename", "viewClass", "packageVersion", "packageClass", " packageFamily", " packagename", "groupNames", " packageRoot", "groupVersion", "viewRoot", "viewname", "pkgNames", "packageFamily", "groupName", "packageNames", "pkgVersion", " packageClass", " packageVersion", "pkgName", "PackageClass", "groupFamily", "PackageName", "viewName", "pkgFamily", "PackageRoot", "packagename", "packageRoot"], "outFileName": ["outImagename", " outFilenameType", "outImageName", " outFileType", " outFilename", " outTableTime", " outTableSize", " outFilenameName", "infileTime", "outFileNames", "outStreamName", "outFilenamePath", "inFileType", "outFName", "outFilenameSize", " outfileNames", "outImagePath", "outFileSize", " outfilePath", "outDirTime", "outImageSize", "outFilenamename", " outTableName", "outFilenameTime", "infileName", "outFNames", " outFileChain", "outFileTime", "outFilenameName", " outFileNames", "inFilePath", "outTablePath", "infileNames", "outFilename", " outFileTime", " outFilenameChain", "outStreamType", "outfilePath", "outFileChain", " outFilenameSize", "outTableSize", "inFileNames", " outfilename", "outTableChain", "outStreamPath", "outfileName", "outStreamTime", "outFPath", "outfilename", "outTableName", "outTableType", "infileType", "inFileName", "outFilenameNames", " outFilePath", "outFname", " outfileName", "outTablename", " outFilenamePath", "outDirName", "outFilePath", " outTablePath", "outFilenameChain", "outDirSize", "outfileNames", "outDirPath", "outfileChain", "outfileTime", "outStreamNames", "outFilenameType", " outFileSize", "infilePath", "outTableTime", "outfileType", " outFilenamename", "inFileTime", "outFileType"], "xsltParam": ["xltConf", "xsltParameter", "xltParam", "xmlParam", "xsslParameter", "xmlConf", "xsmlConf", "xsslConf", "xsmlParam", "xsqlParameter", "xsqlConf", "xmlParameter", "xsltConf", "xltParameter", "xsmlParameter", "xsqlParam", "xsslParam"], "artifact": ["partifacts", "arifact", "artificial", "Artifact", "Artifacts", "anificial", "ardifacts", " artificial", "ardificial", "ardifact", "partifact", "anifact", "ardificate", "anifacts", "artificate", "arifacts", "anificate", " artificate", " artifacts", "artifacts"], "destinationPath": ["destinatedKey", "termininationJar", "destensionDir", "origininatedPath", "destionpath", " destinationTarget", "descositoryPort", "destinationPort", "destinatedHome", "destitutionPoint", "destranceLog", "destensionPoint", "termininationTarget", "destinoPath", "destificationLocation", "delinationLog", "destinatedForm", "destositoryPort", "destinationDir", "estationPart", "identinateInfo", "destinatedPath", "destinateName", "destinationKey", "destensionTemp", "destinoKey", "destinateInfo", "termininerPath", "destacementName", "identinationKey", "destationPath", "destociationHome", "estinationTime", "DestensionHost", "destacementPath", "destinateUrl", "destinationPoint", "destinerHost", "destionPoint", "destesticJar", "estinoTime", "destesticPath", "delinationPoints", "destinatorPort", "destinatorPath", "origininationForm", "termininerTarget", "chaininatedPath", "chaininatedDriver", "delinateLog", "destinatorPoint", "destinateAt", "estionPoint", "destinerJar", "destinateDir", "estionpath", "destociationPath", "destinatedpath", "descositoryPath", "destacementKey", "identinatePath", "origininationNow", "destinationDisk", "destinationPart", "chaininationPath", "destinatorHost", "destinationHost", "DestinationPod", "generinationJar", "identinationInfo", "estationHost", "destificationDir", "estionPath", "identinateKey", "destinoName", "destinationTarget", "descinationParent", "termininerJar", "destociationDir", "destationLocation", " destociationpath", "destinantTemp", "destociationpath", "destositoryParent", "destationDir", "desturationTarget", "destATIONPath", "destinationSystem", "chaininationHome", "destinateKey", "destacementTime", "destATIONParent", "estinationHost", "destinatorpath", "destigationChain", "destinationLog", "destinatorPATH", "estinationKey", "estinationpath", "destociationPoints", "destitutionPATH", "descinationPath", "destigationPath", "destregationpath", "origininatedChain", "destventionDriver", "destionPATH", "desticationDir", "destinantPath", "DestensionPoint", "descinationHost", "destinatorKey", "destinationAt", "origininationPath", "destrancePoints", "destositoryPath", "destinerAt", "destinatePath", "DestinationDir", "destATIONHost", "estionPATH", "destinateNow", "destinationPATH", "estinationPATH", "DestensionTemp", "DestinationUrl", "destificationUrl", " destinationDisk", "destinatorParent", " destociationTarget", "desturationPath", "destinerTarget", "destinateTarget", "origininatedNow", "identinateChain", "destinateChain", "DestinationPoint", "descositoryParent", "identinationChain", " destociationDisk", "destinerPart", "destinationTime", "DestinationTemp", "estinoKey", "destociationHost", "destinoPoint", "destinateLog", "destinationHome", "destinerDir", "generinateAt", "destinerSystem", "identinationPath", "estationPath", "destventionDisk", "destinoDir", "destinationPoints", "destinationpath", "destregationDisk", "generinationPath", "destensionHost", "destranceForm", "DestinationLocation", "destociationLog", "destinationName", "destociationPoint", "destificationPath", "destinationUrl", "desticationPod", "generinatePath", "destinatedDisk", "destinatorChain", "destventionHome", "destociationForm", "termininationPath", " destociationPath", "descositoryHost", "destigationForm", "destinatedTarget", "DestinationPath", "DestificationUrl", "destationUrl", "delinationPath", "estationDir", "destesticSystem", "destinantPod", "destinatorInfo", "destationHost", "origininatedForm", "termininationpath", "chaininatedDisk", "destregationPath", "destinateLocation", "DestificationDir", "DestensionPod", "origininationChain", "delinationForm", "destositoryHost", "estinationPoint", "generinateJar", "destinationChain", "desticationPath", "desturationJar", "destATIONPort", "estinoPath", "delinateForm", "destensionPath", "estinoName", "destinationPod", "destinatePoints", "destinationJar", "destinationDriver", "desticationTemp", "destinatedNow", "destinationForm", "destventionPath", "destationPart", "destinateTime", "destensionPod", "destinatepath", "DestificationLocation", "destinationTemp", "estinationPart", "destitutionPath", "delinatePath", "destesticAt", "desturationpath", "DestinationHost", "estinationName", "generinationSystem", "destinateHost", "descinationPort", "destrancePath", "destionPath", "DestensionDir", "destinatedDriver", "destinatedInfo", "DestensionPath", "destitutionpath", "generinationAt", "destinationParent", "chaininatedHome", "generinateSystem", "destinateSystem", "destociationDisk", "destregationTarget", " destinationpath", "estinationDir", "destociationDriver", "destinoHost", "destinatedChain", "destinateJar", "destinoTime", "destociationTarget", "destinateForm", "destigationNow", "estinationPath", "destinatePart", "destinerPath", "destinantDir", "termininerpath", "chaininationDisk", "destinationNow", "delinatePoints", "chaininationDriver", "destinationInfo", "destinerpath", "destinationLocation", "DestificationPath"], "in": ["In", "input", "id", "info", "r", "f", "file", "m", "IN", "reader", "t", "l", "bin", "c", " IN", "ins", "n", "io", "w", "din", "i", "d", "inner", "o", "doc"], "out": ["inv", "obj", "b", "ex", "or", "OUT", "net", "ou", "conf", "cache", "all", "it", "write", "dis", "f", "err", "output", "nt", "oe", "ln", "list", "file", "t", "s", "l", "client", "c", "Out", "n", "null", "ins", "os", "screen", "go", "nr", "p", "cn", "u", "cmd", "gen", "to", "up", "io", "sys", "ger", "outs", "msg", "w", "report", "ch", "writer", "e", "log", "conn", "con", "raw", "gr", "co", "print", "aos", "res", "o", "outer", "inner", "v", "can", "println", "cfg"], "root": ["group", "id", "r", "context", "ok", "_", "m", "Root", "config", "dir", "parents", " roots", "se", "de", "scope", "p", "roots", "graph", "def", "tree", "dump", "initial", "json", "parent", "impl", "New", "chain", "Template", "start", "create", "data", "name", "node", "println", "table", "child"]}}
{"id1": "15580610", "id2": "16572931", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainObjectifier", " runclassizer", " runclassification", " trainClassizer", " trainClassification", " runClassizer", " runclassifier", " trainModizer", " trainclassifier", " trainclassizer", " trainObjectifer", " trainObjectification", " trainclassification", " trainModification", " runClassifer", " trainclassifer", " runClassifier", " trainModifier", " trainObjectizer", " trainClassifer", " runClassification", " trainModifer", " runclassifer"], "dir": ["path", "dl", "files", "dr", "src", "DIR", "url", "wd", "lib", "grad", "output", "pkg", "tmp", "config", "direct", "done", "md", "pos", "directory", "root", "rad", "Dir", "ir", "loc", "this", "null", "dd", "addr", "io", "div", "folder", "report", "log", "disk", "dist", "module", "d", "local", "base", "data", "prefix", "db", " directory", "doc", "dm"], "command": ["operation", "message", "group", "script", "multiple", "template", "function", "display", "sudo", "shift", "component", "query", "search", "application", "binary", "relative", "force", "argument", "shell", "paste", "request", "config", "description", "and", "mac", "program", "string", "pretty", "link", "send", "directory", "requisite", "key", "three", "menu", "cmd", "control", "pattern", "expression", "method", "archive", "Command", "password", "document", "power", "attribute", "initial", "sequence", "set", "text", "mpeg", "clear", "option", "statement", "position", "delete", "form", "condition", "chain", "buffer", "event", "connection", "content", "call", "history", "base", "execute", "response", "column", "comment", "volume", "button"], "length": ["transform", "pieces", "collection", "creator", "full", "value", "SIZE", "shift", "number", "distance", "space", "ENGTH", "count", "append", "load", "size", "character", "needs", "loc", "end", "given", "limit", "fleet", "len", "dump", "upper", "ength", "power", "height", "sequence", "last", "position", "form", "Length", "capacity", "deep", "build", "ctors", "duration", "shape", "factor", "prototype", "pad", "max", "depth", "total", "available", "level", "now", "bus", "volume", "diff", "strip"], "process": ["message", "channel", "script", "check", "function", "display", "pp", "parse", "thread", "component", "search", "output", "class", "session", "task", "complex", "processing", "use", "request", "exec", "program", "link", "network", "load", "record", "proc", "Process", "system", "pid", "term", "run", "p", "object", "cp", "cmd", "in", "processor", "method", "handle", "result", "flow", "console", "view", "mpeg", "position", "post", "worker", "event", "start", "node", "connect", "status", "service", "call"]}}
{"id1": "5620792", "id2": "421042", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"SHA1": ["HS1", "sha1", "SHAOne", " SHA2", "HS2", "SHA256", "shaOne", " SHA256", "SHA2", "sha256", " SHAOne", "sha2", "HSOne", "HS256"], "text": ["message", "path", "read", "pt", "template", "value", "out", "input", "url", "subject", "select", "output", "translation", "nt", "config", "current", "t", "string", "str", "tx", "test", "key", "ext", "TEXT", "word", "term", "txt", "source", "q", "ct", "act", "pattern", "password", "document", "msg", "form", "cont", "event", "content", "print", "code", "Text", "data", "name", "prefix", "comment"], "HASH_VALUE_SIZE": ["HASH_VAL_NO", "HASH_VALUE_NAME", "HASH_VALUE_DIR", "HASH_VAL_NAME", "HASH_value_TYPE", "HASH_VALUE_NO", "HASH_value_SIZE", "HASH_VALUE_TYPE", "HASH_VALUE_Size", "HASH_VALUE_SOURCE", "HASH_value_DIR", "HASH_VAL_SIZE", "HASH_value_SOURCE", "HASH_VAL_Size"], "md": ["ad", "nd", " mc", "cd", "mond", " ms", "dh", "ds", "mt", "grad", "MD", "m", "mp", "dir", " mm", "rm", " del", "der", "mk", "cond", "add", "and", " ma", "ctr", "mode", "hd", " dd", "mc", "df", " rm", " mo", "h", "dd", "cmd", "pd", " sd", " cmd", "det", "ind", "mod", " man", "mm", "js", "hm", "ld", "bd", "dig", "od", "mn", "mb", "td", "mand", "d", " Md", "sd", " cd", "metadata", "mg", "ms", "sm", "dm"], "sha1hash": ["SHA1hex", "ha2hash", "SHA1hash", "sha3str", " SHA1sum", "ha1result", " SHA1value", "ha1hash", "sha1Hash", "ha2result", "shaonesum", "ha2Hash", "sha2str", "sha31value", " SHA31value", "sha1sum", "sha1hex", "ha1sum", "sha2hex", "sha31hash", "sha31sum", "sha1str", "sha5have", "sha1result", "sha7hex", "sha2sum", "sha1have", "sha7Hash", "sha2value", "shaoneresult", "sha5sum", "sha3hex", "sha1value", "shaonehash", "sha7hash", " SHA31have", "sha3Hash", "shaoneHash", "SHA2str", "sha3hash", " SHA31hash", "SHA2Hash", "SHA2hex", "sha2Hash", "ha1Hash", "SHA1Hash", "SHA1str", "sha7str", " SHA1have", " SHA31sum", "sha5value", "sha2hash", " SHA1hash", "sha5hash", "sha31have", "sha2result", "ha2sum", "SHA2hash", "sha2have"]}}
{"id1": "4629990", "id2": "22366505", "code1": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"logonToServer": ["logonForserver", "logOnToSite", "logonForSite", "logonTOServer", "logOnToClient", "logonTOClient", "logOntoClient", "logonToserver", "logontoClient", "logOntoServer", "logontoSite", "logonTOserver", "logOntoserver", "logontoserver", "logOnToserver", "logonForClient", "logonToSite", "logOnToServer", "logonToClient", "logonForServer", "logontoServer", "logOntoSite", "logonTOSite"], "ftpClient": [" fttpclient", "afttpClient", "afttpclient", "ftcpResponse", "ftspClient", "ftpLib", "ftcpLib", "fttClient", "fftClient", "ffpConnection", " fttpBuilder", "aftpclient", "ftcClient", "ftcpclient", "fttpClient", "ftspclient", "fttpBuilder", " ftpBuilder", "fttConnection", "ftcpBuilder", "aftcpConnection", "fttResponse", "fttLib", "ftcpClient", "ftcResponse", "aftpServer", "ftpResponse", "aftpClient", "fttpServer", "ftcpConnection", "ffpClient", "aftcpResponse", "afttpConnection", " fttpLib", "fttclient", "aftpResponse", "aftcpClient", " ftpLib", "ftpBuilder", "ftcclient", "ftcConnection", "aftcpclient", "ffpclient", "fttpConnection", "fftclient", "fttpclient", "aftpConnection", "fttBuilder", " fttpClient", "ftcpServer", "fftConnection", "ftpServer", " ftpclient", "fttpLib", "ftpConnection", "ftspServer", "aftcpServer", "ftpclient"], "ftpAddress": ["ftcpOrder", "etpAddress", "ftpaddress", " fttpPath", "ffpStreet", "ftfaddress", "ftpAdd", "ettpAdd", "fttpHost", "aftrAddress", "ftphAdd", "ftpPort", "ftphClient", "etpOrder", "fttpPort", "ftcpStreet", "ftcpAddress", "ftphAddress", "ftpeAdd", "ffcpAddress", "ftfPort", "ftpStreet", "ftpHost", "ftpeaddress", " fttpAddress", "ftcpaddress", "ftcpPath", "afttpAddress", "fttAddress", "aftpAdd", "ftcpInterface", "aftraddress", "fttpAddress", "ftrAdd", "ftfAdd", "aftrClient", "ettpaddress", "afttpAdd", "ftcpClient", "ftfHost", "ftPAddress", "ftfAddress", "aftpClient", "fttpAdd", "ftraddress", "fttpOrder", " ftpaddress", "ftpOrder", "aftpAddress", "ffpInterface", "ftpeOrder", "afttpHost", "fttInterface", "ettpOrder", "etpaddress", "ffpAddress", "ftrClient", "ffcpInterface", " fttpPort", "ettpAddress", "ftPStreet", " ftpPath", "ftrAddress", "ftcpAdd", "fttStreet", " ftpPort", "ftfPath", " fttpaddress", "etpAdd", "ftcpHost", "ftpInterface", "fttpPath", "aftrAdd", "ftpeAddress", "fttpaddress", "aftpaddress", "afttpaddress", "ftpPath", "ffcpStreet", "ftcpPort", "ftphaddress", "aftpHost", "ftPInterface"], "noRetries": ["noRetry", "noContrys", "NORetries", "NOReties", "noEntorts", "noContries", "noTrys", "noReties", "noretrys", "noEntries", " noEntorts", "noTry", "noRetorts", " noReties", "NOretries", "NORetrys", "noConties", "noEnties", "noreties", "noretries", "NOreties", " noRetorts", "noTies", "noEntry", "noretorts", "noRetrys", "NOretrys", " noRetrys", "noretry", " noEnties", " noEntries", "noEntrys", "noContorts", "NOretry", " noEntrys", "NORetry", "noTries"], "remoteHomeDir": ["remoteHostDir", "remoteRootDirectory", "externalHomeDirectory", "externalHomeDir", "RemoteHomePath", " remoteHomeDirectory", "remoteWelcomeRoot", "RemoteRootPath", "RemoteRootRoot", "remoteBasePath", "externalHomePath", "remoteBaseDirectory", "remotehomePath", "remotehomeDirectory", "RemoteHomeRoot", "remoteRootPath", "RemoteRootDir", "remoteRootdir", "remoteWelcomePath", " remoteRootDirectory", "remotehomeDir", "remoteHomePath", "RemoteHomeDir", "remotehomedir", "remoteBaseDir", "remoteRootDir", " remoteHomePath", " remoteRootPath", "remoteHomeDirectory", "externalHomedir", "remoteWelcomeDir", "remoteHomedir", "remoteHostPath", "remoteHomeRoot", "remoteRootRoot", "remoteHostRoot", " remoteRootDir"], "noRetriesSoFar": ["noRetrysSONear", "noRetriesTooNear", "noRetriessoNear", "noRetryssofar", "noRetriesSofar", "noRetryssoNear", "noRetrysSOMuch", "noRetriessoMuch", "noRetriesSONear", "noRetriesPefar", "noRetriesOffNear", "noRetriesToofar", "noRetriesOfffar", "noRetriessofar", "noRetrysSOfar", "noRetrysSOFar", "noRetriesPeOld", "noRetriesSoNear", "noRetrysSOobar", "noRetriessoobar", "noRetriesTooobar", "noRetrysSoMuch", "noRetriesSoMuch", "noRetriessoOld", "noRetriesSOMuch", "noRetriesOffFar", "noRetryssoOld", "noRetriesTooFar", "noRetrysSoNear", "noRetriesSOfar", "noRetriesPeNear", "noRetriesSoobar", "noRetriessoFar", "noRetrysSofar", "noRetriesSOobar", "noRetryssoFar", "noRetrysSoOld", "noRetrysSoobar", "noRetriesSOFar", "noRetriesPeFar", "noRetrysSoFar", "noRetriesSoOld", "noRetriesSOOld"], "reply": ["message", "match", "number", "write", "info", "address", "shell", "error", "apply", "echo", "Reply", "count", "consider", "link", "repl", "success", "job", "answer", "zero", "continue", "next", "close", "exit", "py", "flag", "part", "power", "result", "notice", "state", "ignore", "command", "report", "nb", "ply", " Reply", "print", "code", "response", "comment", "status", "reset"]}}
{"id1": "2518655", "id2": "22536033", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"fnOut": ["dnOutput", " fnIn", "bfNet", "synOut", " fnNet", "fnOr", "bfOut", "pdfIn", " fnOs", "bfOs", "fnOs", "fnNet", "pdfOs", "pdfOut", "dnOr", " fnOr", "synOutput", "dnIn", "dnOut", "synOr", "synIn", "fnIn", "fnOutput", " fnOutput", "bfIn", "pdfNet"], "writer": ["wright", "external", "commit", "driver", "creator", "format", "write", "wrapper", "widget", "writers", "file", "written", "editor", "reader", "journal", "and", "rator", "parser", "send", "walker", "client", "loader", "builder", "zero", "aster", "window", "fn", "close", "writ", "flush", "riter", "width", "runner", "master", "caster", "handler", "console", "w", "writing", "report", "Writer", "worker", "white", "buffer", "print", "inner", "auto", "operator", "outer", "her", "comment", "maker", "println", "service", "table", "variable"], "i": ["ij", "is", "ims", "init", "ogi", "us", "my", "gi", "id", "it", "xi", "qi", "ski", "\u0438", "ci", "li", "I", "m", "ma", "ai", "ix", "client", "gu", "ki", "x", "bi", "key", "c", "hi", "ii", "ri", "q", "u", "multi", "mi", "uri", "ic", "batch", "ind", "y", "im", "phi", "iu", "sim", "g", "ie", "me", "chain", "si", "v", "ei", "pi", "ti", "j", "ui", "di", "ini", "ip"], "fInput": [" fIn", "fileInput", "finput", "fileOutput", "lInput", "sfInput", "cfOutput", "linput", "sfIn", "fIn", "cfNew", "sfinput", " fNew", "fOutput", " finput", "cfinput", " fOutput", "fileinput", "fileIn", "lNew", "fNew", "sfOutput", "cfInput", "lOutput"], "in": ["In", "pin", "check", "is", "sin", "or", "conf", "out", "thin", "input", "rin", "al", "all", "info", "r", "it", "ln", "ma", "IN", "inn", "t", "inside", "inf", "bin", "again", "client", "vin", "ins", "n", "inc", "en", "ind", "kin", "din", "conv", "isin", "re", "cin", "serv", "con", "gin", " din", "inner", "ini"]}}
{"id1": "20310134", "id2": "2511579", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpStream", " cpDirectory", " duplicateFile", " CopyDirectory", " cpFile", " CopyFile", " copyfile", " Copyfile", " duplicateDirectory", " duplicateStream", " copyStream", " CopyStream", " cpfile", " duplicatefile", " copyDirectory"], "in": ["b", "In", "is", "init", "on", "input", "rin", "id", "it", "r", "ain", "IN", "inn", "l", "inf", "as", "ins", "source", "inc", "from", "en", "ic", "up", "io", "el", "ind", "old", "din", "mm", "isin", "cin", "i", "gin", "ini"], "out": ["b", "ex", "at", "OUT", "net", "ou", "it", "err", "output", "nt", "t", "help", "l", "s", "gt", "c", "Out", "n", "null", "os", "p", "to", "io", "op", "ne", "outs", "msg", "w", "po", "g", "log", "serv", "v", "o", "ot"], "inChannel": ["oinApplication", "outchannel", " inApplication", "sinButton", "intButton", " inchannel", " inRoom", "insidePanel", "intChannel", " inClient", "inputPanel", " inListener", "oinChannel", " inCase", "cinListener", "inConnection", "inListener", "inputChannel", " inChan", "outConnection", "insideChannel", " inConnection", "sinRoom", "inApplication", " inButton", "dinCommand", "oinchannel", "inCase", "inClient", " inPanel", "cinButton", "inButton", "inCommand", "dinButton", "outApplication", "oinConnection", "inRoom", "insideCommand", "sinCase", "sinChannel", "cinChannel", "sinClient", "intCommand", "intChan", "cinClient", "cinCase", "inchannel", "inChan", "dinChannel", "sinListener", "cinRoom", "inPanel", " inCommand", "inputCommand", "dinChan"], "outChannel": ["outchannel", "outputCh", "fullChan", " outCategory", " outChan", "outCategory", "fullChannel", "cosChan", "OUTCan", "outerConnection", "inCh", "outputchannel", "outerChan", "cosChannel", " outConnection", "cosCategory", " outUser", "outConnection", "inCategory", " outCh", "outMember", " outCan", "OUTCategory", " outchannel", "fullCan", "OUTChan", "outputChan", "noteChan", "outUser", "noteMember", "noteChannel", "noteCategory", "outputChannel", "inMember", "outCh", "OUTChannel", "outCan", "outerChannel", "outerUser", "outputUser", "inchannel", "inChan", "outChan", "fullCategory", "cosMember", "outputConnection"]}}
{"id1": "13852596", "id2": "14877116", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "label": 1, "substitutes": {"execute": ["launch", " perform", "init", "evaluate", " execution", " launch", " sweep", "construct", " eval", "exec", " assemble", "run", " evaluate", " chain", " exec", " executed", " replay", " inherit", " executable", "process", " release", " proceed", " benchmark", " scan", " resolve", " deploy", " test"], "resources": ["models", "Resources", "bytes", "faces", "files", "modules", "actions", "these", "builders", "packages", "writers", "users", "banks", "accessible", "reports", "apps", "pointers", "groups", "projects", "types", "they", "rows", "results", "flows", "rs", "roots", "locks", "ris", "services", "classes", "issues", "images", "lets", "ports", " Resources", "uploads", "relations", "ifiers", "ions", "names", "resource", "objects", "res", "items", "artifacts", "archives", "workers", "rooms", "ids", "stores", "scripts", "blocks"], "i": ["ami", "ij", "ex", "ims", "gi", "mu", "xi", "info", "\u0438", "ci", "li", "I", "list", "ali", "bis", "t", "l", "oi", "ai", "hi", "ri", "ki", "ir", "bi", "ii", "q", "mi", "multi", "h", "in", "io", "im", "phi", "iu", "ios", "ori", "g", "abi", "ji", "e", "si", "iri", "v", "pi", "ti", "cli", "j", "ui", "di", "ini", "ip", "ia"], "classFile": ["classifiedSourceFile", "classifiedFile", "attributeChain", "sourceFiles", "classChain", "ClassFile", " classClass", "classEntry", "targetFile", "instanceFiles", "classResource", "classDirectory", "parentFILE", "classFolder", "classLine", "ClassChain", "recordFiles", "userFile", "objectFolder", "connectionFile", "objectClass", "attributeFile", "instanceFilename", "classfile", "ClassClass", "typeLine", "typeFile", "userFiles", "ClassResource", "clfile", "fastFiles", "cellClass", "connectionFILE", "Classfile", "connectionSourceFile", "targetSourceFile", " classFilename", "parentSourceFile", "ClassSourceFile", "classFILE", "recordfile", "classTree", "classifiedfile", "classFilename", "fastFILE", "recordFile", "typeFILE", " classFILE", "targetFILE", "classifiedFILE", "fastfile", "objectFile", "ClassLine", "attributeFILE", " classDirectory", "attributeEntry", "classSourceFile", "ClassDirectory", "classFiles", "connectionfile", "classClass", "cellFolder", "cellFile", "sourceFILE", " classChain", "userfile", " classFiles", " classFolder", "attributeFiles", "targetFiles", " classSourceFile", "ClassFilename", "sourceClass", "typeFiles", " classResource", "clFiles", "ClassFILE", "ClassFiles", " classLine", "instanceFile", "instanceDirectory", "recordFilename", "sourceFile", "parentFile", "clTree", "clFile", " classEntry", "classifiedFiles", "ClassTree", "userFILE", " classfile", "ClassEntry", " classTree", "parentfile", "attributeResource", "fastFile"], "inputStream": ["inputStreamer", "inputSt", "outputTime", "errorSteam", "ipStyle", "outStream", "jsonSteam", "inputSet", " inputSteam", "InputMode", "outputPort", "thisSteam", "inStream", "familyStream", "InputTime", "audioStreamer", "familyStyle", "jsonSet", " inputMode", "thisSource", " inputStreamer", "inStreamer", "thisFile", "ipSteam", "ipStream", "inSteam", "instream", "Inputstream", "inputSource", "inputStyle", " inputPort", "innerStream", "jsonStreamer", "inSet", "jsonStream", "outSt", "InputStream", "outputStyle", " inputSt", " inputSource", "familySource", "errorstream", "innerSet", "inputMode", "inputTime", "outputstream", " inputstream", "inPort", "outputFile", "familyFile", "audioStream", "thisStream", "outputSteam", "inputPort", "audioSt", "ipFile", "outStreamer", "innerSteam", "inputSteam", "errorMode", " inputTime", "audioSteam", "inputFile", " inputFile", "outSteam", "inputstream", "familySteam", "innerStreamer", "InputSteam", "errorStream"], "reader": ["read", "user", "driver", "rer", "Reader", "dr", "review", "query", "write", "r", "wrapper", "red", "author", "older", "instance", "per", "editor", "actor", "parser", "penter", "client", "loader", "builder", "entry", "test", "key", "peer", "rar", "rule", "row", "stream", "image", "dd", "manager", "layer", "service", "er", "runner", "rl", "master", "owner", "handler", "document", "ner", "field", "ger", "definition", "reading", "Writer", "worker", "finder", "iterator", "prototype", "inner", "mr", "operator", "draft", "readable", "oder", "ler", "variable"], "oldSize": ["olderSize", "OLDsize", "oldFontSize", "olderLength", "oldsize", " oldsize", "OLDFontSize", " oldLength", "OLDSize", "olderFontSize", "OLDLength", " oldFontSize", "oldersize", "oldLength"], "writer": ["read", "message", "driver", "Reader", "storage", "format", "wrote", "review", "draw", "write", "weight", "r", "wrapper", "author", "writers", "written", "editor", "actor", "parser", "penter", "player", "walker", "vector", "loader", "builder", "entry", "test", "key", "word", "row", "rw", "ter", "method", "manager", "riter", "service", "er", "runner", "document", "handler", "owner", "ner", "w", "writing", "definition", "adder", "Writer", "worker", "finder", "buffer", "buf", "wb", "inner", "draft", "node", "ler", "variable"], "b": ["bit", "ib", "r", "f", "gb", "bp", "binary", "m", "bf", "ab", "bis", "t", "l", "rb", "bin", "c", "n", "a", "br", "p", "erb", "u", "bits", "h", "batch", "bs", "bound", "w", "sb", "g", "nb", "B", "bb", "mb", "wb", "fb", "d", "v", "emb", "base", "ob", "db"], "outputStream": ["resultSteam", "writeView", "resultForm", "writeStream", "inputForm", " outputView", "outputString", " outputString", "outputForm", "resultstream", " outputSteam", "OutputSteam", "OutputStream", "resultStream", "outputstream", " outputPoint", "writeSteam", "writePoint", "outputSteam", "resultString", "inputSteam", " outputForm", "inputView", "outputPoint", "outputView", "inputstream", "Outputstream", "OutputString", "OutputForm", "inputPoint"], "injectedClasses": ["injectUsES", "injectedCountES", "injectedUsES", "injectedClassets", "injectedUses", "injectedSuccessBytes", "injectedUsets", "injectUsBytes", "injectedClassES", "injectedSuccessets", "injectedSuccesses", "injectedCountets", "injectedCountBytes", "injectUsets", "injectClasses", "injectClassBytes", "injectedClassBytes", "injectedCountes", "injectUses", "injectClassets", "injectClassES", "injectedSuccessES", "injectedUsBytes"], "newSize": ["newMax", " newName", "newName", "NewMax", "oldFontSize", " newMax", "newFontSize", " newFontSize", "oldMax", "oldName", "NewSize", "NewFontSize", "NewName"]}}
{"id1": "16388708", "id2": "2324868", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFileString", "decodeFileAsfile", "decodeStringToString", "decodeFile2String", "decodeFileAsFile", "decodeFileFileFile", "decodeFileAsString", "decodeString2Files", "decodeFileToFiles", "decodeFile2Files", "decodeFileFilefile", "decodeFile2file", "decodeStringTofile", "decodeString2file", "decodeStringToFile", "decodeFileToString", "decodeString2File", "decodeStringToFiles", "decodeFile2File", "decodeFileFileFiles", "decodeString2String", "decodeFileTofile", "decodeFileAsFiles"], "infile": ["InFile", "inputfile", "inname", "frombase", "isinfolder", "Infilename", "outbase", "inbase", "inFile", "isinname", "Inbase", "infolder", "outFile", "fromfilename", "fromfile", "Infile", "isinFile", "inputname", "outfilename", "infilename", "outfolder", "fromFile", "inputFile", "inputfolder", "isinfile", "outname"], "outfile": ["inname", " outname", "Outfilename", "outFILE", "inFILE", "inFile", "tofile", "todir", " outFILE", "otfile", "outFile", "outdir", "Outdir", "indir", "outname", "otFile", "toFile", " outFile", "otname", "outfilename", "OutFile", "infilename", "otFILE", "tofilename", "Outfile"], "in": ["In", "iter", "pin", "is", "init", "or", "on", "input", "rin", "it", "al", "info", "id", "ain", "per", "IN", "inn", "t", "inside", "inf", "bin", "amin", "ar", "ins", "source", "inc", "from", "en", "up", "ind", "oin", "im", "din", "form", "isin", "by", "get", "re", "nin", "cin", "con", "conn", "i", "gin", " din", "inner", "ini"], "out": ["b", "ex", "at", "net", "OUT", "ou", "on", "it", "write", "output", "nt", "ion", "file", "t", "oss", "gt", "Out", "n", "end", "fn", "null", "os", "en", "cn", "to", "flush", "opt", "io", "ne", "sys", "outs", "writer", "OU", "g", "con", "co", "print", "aos", "res", "o", "auto", "can", "outer", "ot", "inner"], "buffer": ["message", "block", "header", "library", "template", "display", "note", "cache", "number", "binary", "info", "paste", "frame", "bone", "append", "padding", "character", "memory", "window", "Buffer", "row", "batch", "initial", "document", "attribute", "command", "bar", "password", "sequence", "view", "black", "stack", "temp", "shape", "buf", "history", "pad", "total", "print", "available", "base", "sample", "buff", "mem", "column", "phrase", "comment", "button", "table", "variable"], "read": ["iter", "range", "check", " Read", "wait", "shift", "input", "Read", "find", "write", "query", "open", "select", "ok", "give", "first", "reader", "count", "add", "need", "reads", "load", "push", "send", "before", "size", "req", "run", "n", "end", "stream", "READ", "close", "len", "through", "ind", "set", "length", "text", "allow", "reading", "get", "raw", "i", "seek", "hold", "print", "start", "skip", "connect", "readable", "each", "index", "ready"], "success": ["setup", " succeed", "exist", "ccess", "commit", "cess", "value", "accept", "fail", "growth", " successful", "Success", "ok", "error", "first", "same", "second", "done", "surv", "release", "summary", "safe", "submit", "continue", "crit", "primary", "scope", "successful", "good", "please", "ceed", "town", "result", "valid", "successfully", " okay", " failure", "ratulations", " succeeds", "sufficient", "photo", "snap", "city", "unity", "condition", "democracy", " successes", "complete", "support", "positive", "danger", "response", "status", " succ"]}}
{"id1": "21181542", "id2": "1133123", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "label": 0, "substitutes": {"deleteRoleType": ["deleteResourceType", "deleteGroupTyp", "deleteResourceTyp", "deleteRoleTypes", "deleteResourceTypes", "deleteGroupType", "DeleteRoleTyp", "DeleteRoleType", "deleteRoleTyp", "deleteGroupTypes", "DeleteRoleTypes"], "id": ["path", "is", "mid", "aid", "Id", " pid", "iden", "it", "type", "url", "info", "ID", "ion", "instance", "and", "kid", "t", "add", "l", "link", "x", "key", "pid", " tid", "val", "end", "orig", "sid", "p", "oid", "created", "h", "def", "rid", "in", "bid", "part", "uid", "vid", "show", "ref", "edit", "ident", "no", "only", "i", "event", "hide", "d", "ide", "create", "hash", "name", "ids", "like", "node", "time", "index"], "namespaceId": ["namespaceOr", "typesACEId", "workshipID", "workspaceName", "typespaceAnd", "namespaceRef", "namespointId", " namesenceBirth", "namespointName", "namespaceAnd", "namespointid", "namesistenceOr", "namesaceID", "worksetAnd", "namesaceid", "namespacesId", "namespacesid", "namespaceLog", "nameshipID", "namesenceOr", "namesenceBirth", "typespaceId", "namesenceId", "nameshipKey", "namespacesBirth", "namespointRef", "namespaceKey", "workspaceID", "namesetId", "namesspaceid", "nameshipid", "worksetid", "namespaceid", "namesistenceIdent", "namesiteOr", "namesplaceRef", "namespacesID", "workspaceid", "worksplaceRef", "workspaceAnd", "namesistenceId", "namesplaceid", "worksplaceid", "namesiteIdent", "namesiteId", "namesspaceAnd", "namesenceID", "namespaceName", "namesistenceLog", " namespaceOr", " namesiteIdent", "namesaceKey", "namesspaceID", "namespacesKey", "namesositoryID", "typesACEID", " namesiteLog", "workshipid", "worksplaceId", "namesadeAnd", "worksetID", "workspaceId", "workshipKey", "namesositoryBirth", "nameshipId", "namespaceBirth", "namesACEID", "worksplaceName", "namespacesRef", "namespaceID", "namesplaceId", "namespointID", "workspaceRef", " namespaceID", "namesACEId", "workshipId", "namespaceIdent", "namespacesAnd", "namespacesName", "namespointAnd", "namesaceId", " namespaceBirth", "namesetid", "worksetId", " namesenceID", " namesiteId", "namesiteLog", "workspaceKey", "typespaceID", "namesetAnd", "namesetID", " namespaceLog", "namesenceLog", "namesplaceName", "namesadeID", " namespaceIdent", " namesenceId", " namesiteOr", "namesspaceId", "namesadeId", "namesACEAnd", "typesACEAnd", "namesenceIdent", "namesositoryId"], "removeReferencesInRoleTypes": ["removeReferencesInRuleTypes", "removeReferencesInRightNames", "removeReferencesFromMultipleTypes", "removeReferencesInMultipleType", "removeReferencesFromRoleFiles", "removeReferencesInRoleFiles", "removeReferencesInRightType", "removeReferencesFromMultipleType", "removeReferencesInRoleType", "removeReferencesFromMultipleFiles", "removeReferencesInRightTypes", "removeReferencesInroleFiles", "removeReferencesFromRoleType", "removeReferencesInroleType", "removeReferencesInRightFiles", "removeReferencesFromroleFiles", "removeReferencesInMultipleTypes", "removeReferencesFromRoleTypes", "removeReferencesInroleNames", "removeReferencesInRuleNames", "removeReferencesFromMultipleNames", "removeReferencesFromRoleNames", "removeReferencesInRoleNames", "removeReferencesFromroleType", "removeReferencesFromroleNames", "removeReferencesInRuleType", "removeReferencesFromroleTypes", "removeReferencesInroleTypes", "removeReferencesInRuleFiles", "removeReferencesInMultipleFiles", "removeReferencesInMultipleNames"], "permit": ["PERmitted", "Permitted", "Permiss", "permitted", "promitted", "permission", "PERmit", "proMIT", "promit", "PERMIT", " permitted", "Permission", " perMIT", "PerMIT", " permiss", "PERmiss", "PERmission", "Permit", "perMIT", "promission", "permiss"], "exist": ["alias", "remember", "there", "existence", "register", "find", "write", "save", "filename", "present", "login", "list", "know", "current", "mark", "use", "ist", "add", "same", "purpose", "include", "existent", "ext", "missing", "have", "icate", "existing", "attach", "require", "define", "respond", "see", "establish", "meet", "keep", " extant", "cont", "create", "connect", "status", "ready"], "msgBuf": ["msgBlim", "messageRbuff", " msgRuf", " msgRbuff", "messageMuff", "msgBeuf", "msgBfg", "msgPuff", "msgBsuf", "msgPbuf", "msgBsbuf", " msgMbuf", "messageRuf", "msgGlim", "msgRuff", "messageMbuf", "msgAuff", "msgBsuff", " msgMuf", "msgCfg", " msgMuff", "messagePbuf", " msgBbuf", "msgRbuff", "msgRbuf", "msgRlf", " msgBuff", "msgBebuf", "msgMuf", "msgMbuff", "msgCuf", "messageBbuf", "messageBlf", " msgCfg", "msgBuff", " msgBbuff", "msgVbuf", " msgCuf", "messageRlf", "msgRuf", "msgAbuf", "msgBsfg", "msgPuf", "msgAuf", "messageBuff", "messageRuff", "messagePuf", " msgRlim", " msgCuff", "msgVbuff", "msgGbuff", "msgCbuff", "msgBbuff", "msgPlf", " msgRbuf", "messageBuf", "msgMuff", "msgMbuf", "msgPfg", "msgGuf", " msgMbuff", "msgBefg", "messageBfg", "messageRbuf", "messagePuff", " msgBlim", "msgRlim", "messagePfg", "msgGbuf", "messageMbuff", "msgBbuf", "msgCuff", "msgBlf", "msgVuff", " msgCbuf", "msgCbuf", "messageBbuff", "msgAbuff", "messageMuf", "msgRfg", " msgBfg", "msgPbuff", "msgVuf", "msgBeuff"], "objects": ["models", "headers", "faces", "files", "points", "links", "authors", "docs", "books", "keys", "builders", "oids", "packages", "products", "versions", "articles", "parts", "apps", "jobs", "projects", "resources", "plugins", "flows", "bits", "tools", "locks", "beans", "classes", "frames", "organisms", "airs", "images", "ports", "uploads", "codes", "units", "relations", "lines", "ors", "errors", "assets", "items", "artifacts", "workers", "ids", "obs", "values", "pages", "blocks"], "sqlRightId": ["sqlrightName", "sqlrightId", " sqlrightId", "qlRightid", "qlRightId", "sqlRightid", "sqlLeftId", "sqlRightName", "qlrightid", "sqlHeadid", "qlrightId", " sqlrightRef", " sqlrightById", " sqlrightid", "sqlRightRef", "sqlLeftName", "qlrightName", "sqlHeadById", "sqlrightid", "sqlrightById", "sqlLeftid", " sqlRightid", "sqlHeadRef", "sqlHeadId", " sqlRightById", "qlRightName", "sqlrightRef", "sqlRightById", " sqlRightRef"], "sqlParent": ["invparent", "sprChild", "sysParent", "sysChild", "sqlChild", "sqlparent", "sysparent", "sysOwner", "invChild", "sqlOwner", "sprparent", "invParent", "sprParent", "invOwner", "sprOwner"], "sql": ["dl", "template", "description", "session", "ql", "md", "params", "term", "acl", "action", "cmd", "password", "sys", "SQL", "command", "spec", "json", "body", "statement", "drop", "orm", "security", "execute", "data", "comment", "db", "diff", "cfg"], "pstmt": ["wpastmk", "pctms", "pstmk", "pstartng", "pstatmm", "pstMT", "NEW", "pthmt", " pstms", "NULL", "Pstmt", "pstatStatement", "pstatem", "PstStatement", "pastmk", "pondm", "wpastm", "pthem", " pstatmt", "pstartm", "pthmp", "pndmk", "pndmt", "pstartr", "pstms", "pastm", "Exception", "wpstMT", "pStng", "pStm", "context", " pstem", "nt", "pstr", "PStm", "Pstmm", "pastMT", "pstmp", "pstatm", "postmk", "pndm", "insert", "postmt", "pStr", "pstem", "pctem", "wpstm", "Pstm", "pndMT", "pondStatement", "Pstr", "Pstatm", "PstatStatement", "PStng", "pctmt", "def", "Pstatmm", "pstm", " pstatms", "pastStatement", "pondmm", "wpastmt", "Delete", "pstng", "pstStatement", "wpstmt", "wpstmk", "pondmt", "_", "pastmm", " pstatem", "postm", "postMT", " pstmp", "Pstng", "tx", "pastmt", "pstatmp", "pStmt", "pstartmt", "pstmm", "pstatms", "pstatmt", "PStr", "pthms", "create", "pctmp", "Pstatmt", " pstatmp", "wpastMT", "PStmt"], "typeGid": ["typeRegID", "typeGuids", " typeCid", "TypeCid", " typeCids", "typeGenids", "typeRegid", "typeRegId", "typeGId", " typeGno", "TypeGID", "typeCID", "typeCno", "typeGno", "TypeCId", "typeGuID", "TypeCID", "typeGuid", " typeGids", " typeCno", "typeCId", "typeGids", "typeCids", "typeGuId", "typeGuno", "typeGenno", "typeGenid", "typeGID", "typeCid", "TypeGId", "TypeGid"], "defaultLevel": [" defaultDepth", "errorLevel", "DefaultLevel", "DefaultDepth", "errorDepth", "errorMode", "defaultDepth", " defaultlevel", "Defaultlevel", "defaultMode", " defaultMode", "DefaultMode", "errorlevel", "defaultlevel"], "success": [" succeed", "accept", "fail", "pass", "progress", "save", "warn", "info", "Success", "ok", "error", "first", "unknown", "rc", "summary", "submit", "continue", "primary", "close", "successful", "good", "result", "state", "successfully", "failed", "undo", "status"]}}
